{"version":3,"file":"js/vender~46c63d10.97133721.js","mappings":"klBAEWA,E,YACX,SAAWA,GAEPA,EAAMA,EAAa,MAAI,GAAK,QAE5BA,EAAMA,EAAa,MAAI,GAAK,QAE5BA,EAAMA,EAAY,KAAI,GAAK,OAN/B,CAOGA,IAAUA,EAAQ,KAErB,IAeWC,EAfPC,EAAsB,WACtB,SAASA,KAQT,OALAA,EAAKC,EAAI,IAAI,IAAQ,EAAK,EAAK,GAE/BD,EAAKE,EAAI,IAAI,IAAQ,EAAK,EAAK,GAE/BF,EAAKG,EAAI,IAAI,IAAQ,EAAK,EAAK,GACxBH,EATc,IAgBzB,SAAWD,GAEPA,EAAWA,EAAc,EAAI,GAAK,IAElCA,EAAWA,EAAc,EAAI,GAAK,IAElCA,EAAWA,EAAc,EAAI,GAAK,IANtC,CAOGA,IAAeA,EAAa,M,oGC5B3BK,EAAwB,WAOxB,SAASA,EAITC,EAIAC,EAIAC,QACc,IAANF,IAAgBA,EAAI,QACd,IAANC,IAAgBA,EAAI,QACd,IAANC,IAAgBA,EAAI,GACxBC,KAAKH,EAAIA,EACTG,KAAKF,EAAIA,EACTE,KAAKD,EAAIA,EAykBb,OAnkBAH,EAAOK,UAAUC,SAAW,WACxB,MAAO,OAASF,KAAKH,EAAI,MAAQG,KAAKF,EAAI,MAAQE,KAAKD,EAAI,KAM/DH,EAAOK,UAAUE,aAAe,WAC5B,MAAO,UAMXP,EAAOK,UAAUG,YAAc,WAC3B,IAAIC,EAAiB,IAATL,KAAKH,EAAW,EAG5B,OADAQ,EAAe,KADfA,EAAe,IAAPA,GAAyB,IAATL,KAAKF,EAAW,KACP,IAATE,KAAKD,EAAW,IAU5CH,EAAOK,UAAUK,QAAU,SAAUC,EAAOC,GAKxC,YAJc,IAAVA,IAAoBA,EAAQ,GAChCD,EAAMC,GAASR,KAAKH,EACpBU,EAAMC,EAAQ,GAAKR,KAAKF,EACxBS,EAAMC,EAAQ,GAAKR,KAAKD,EACjBC,MAQXJ,EAAOK,UAAUQ,UAAY,SAAUF,EAAOG,GAG1C,YAFe,IAAXA,IAAqBA,EAAS,GAClCd,EAAOe,eAAeJ,EAAOG,EAAQV,MAC9BA,MAOXJ,EAAOK,UAAUW,SAAW,SAAUC,GAElC,YADc,IAAVA,IAAoBA,EAAQ,GACzB,IAAIC,EAAOd,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,EAAGc,IAM9CjB,EAAOK,UAAUc,QAAU,WACvB,MAAO,CAACf,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,IAMjCH,EAAOK,UAAUe,YAAc,WAC3B,MAAgB,GAAThB,KAAKH,EAAmB,IAATG,KAAKF,EAAoB,IAATE,KAAKD,GAO/CH,EAAOK,UAAUgB,SAAW,SAAUC,GAClC,OAAO,IAAItB,EAAOI,KAAKH,EAAIqB,EAAWrB,EAAGG,KAAKF,EAAIoB,EAAWpB,EAAGE,KAAKD,EAAImB,EAAWnB,IAQxFH,EAAOK,UAAUkB,cAAgB,SAAUD,EAAYE,GAInD,OAHAA,EAAOvB,EAAIG,KAAKH,EAAIqB,EAAWrB,EAC/BuB,EAAOtB,EAAIE,KAAKF,EAAIoB,EAAWpB,EAC/BsB,EAAOrB,EAAIC,KAAKD,EAAImB,EAAWnB,EACxBC,MAOXJ,EAAOK,UAAUoB,OAAS,SAAUH,GAChC,OAAOA,GAAclB,KAAKH,IAAMqB,EAAWrB,GAAKG,KAAKF,IAAMoB,EAAWpB,GAAKE,KAAKD,IAAMmB,EAAWnB,GASrGH,EAAOK,UAAUqB,aAAe,SAAUzB,EAAGC,EAAGC,GAC5C,OAAOC,KAAKH,IAAMA,GAAKG,KAAKF,IAAMA,GAAKE,KAAKD,IAAMA,GAOtDH,EAAOK,UAAUsB,MAAQ,SAAUA,GAC/B,OAAO,IAAI3B,EAAOI,KAAKH,EAAI0B,EAAOvB,KAAKF,EAAIyB,EAAOvB,KAAKD,EAAIwB,IAQ/D3B,EAAOK,UAAUuB,WAAa,SAAUD,EAAOH,GAI3C,OAHAA,EAAOvB,EAAIG,KAAKH,EAAI0B,EACpBH,EAAOtB,EAAIE,KAAKF,EAAIyB,EACpBH,EAAOrB,EAAIC,KAAKD,EAAIwB,EACbvB,MAQXJ,EAAOK,UAAUwB,iBAAmB,SAAUF,EAAOH,GAIjD,OAHAA,EAAOvB,GAAKG,KAAKH,EAAI0B,EACrBH,EAAOtB,GAAKE,KAAKF,EAAIyB,EACrBH,EAAOrB,GAAKC,KAAKD,EAAIwB,EACdvB,MASXJ,EAAOK,UAAUyB,WAAa,SAAUC,EAAKC,EAAKR,GAM9C,YALY,IAARO,IAAkBA,EAAM,QAChB,IAARC,IAAkBA,EAAM,GAC5BR,EAAOvB,EAAI,UAAaG,KAAKH,EAAG8B,EAAKC,GACrCR,EAAOtB,EAAI,UAAaE,KAAKF,EAAG6B,EAAKC,GACrCR,EAAOrB,EAAI,UAAaC,KAAKD,EAAG4B,EAAKC,GAC9B5B,MAOXJ,EAAOK,UAAU4B,IAAM,SAAUX,GAC7B,OAAO,IAAItB,EAAOI,KAAKH,EAAIqB,EAAWrB,EAAGG,KAAKF,EAAIoB,EAAWpB,EAAGE,KAAKD,EAAImB,EAAWnB,IAQxFH,EAAOK,UAAU6B,SAAW,SAAUZ,EAAYE,GAI9C,OAHAA,EAAOvB,EAAIG,KAAKH,EAAIqB,EAAWrB,EAC/BuB,EAAOtB,EAAIE,KAAKF,EAAIoB,EAAWpB,EAC/BsB,EAAOrB,EAAIC,KAAKD,EAAImB,EAAWnB,EACxBC,MAOXJ,EAAOK,UAAU8B,SAAW,SAAUb,GAClC,OAAO,IAAItB,EAAOI,KAAKH,EAAIqB,EAAWrB,EAAGG,KAAKF,EAAIoB,EAAWpB,EAAGE,KAAKD,EAAImB,EAAWnB,IAQxFH,EAAOK,UAAU+B,cAAgB,SAAUd,EAAYE,GAInD,OAHAA,EAAOvB,EAAIG,KAAKH,EAAIqB,EAAWrB,EAC/BuB,EAAOtB,EAAIE,KAAKF,EAAIoB,EAAWpB,EAC/BsB,EAAOrB,EAAIC,KAAKD,EAAImB,EAAWnB,EACxBC,MAMXJ,EAAOK,UAAUgC,MAAQ,WACrB,OAAO,IAAIrC,EAAOI,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,IAO3CH,EAAOK,UAAUiC,SAAW,SAAUC,GAIlC,OAHAnC,KAAKH,EAAIsC,EAAOtC,EAChBG,KAAKF,EAAIqC,EAAOrC,EAChBE,KAAKD,EAAIoC,EAAOpC,EACTC,MASXJ,EAAOK,UAAUmC,eAAiB,SAAUvC,EAAGC,EAAGC,GAI9C,OAHAC,KAAKH,EAAIA,EACTG,KAAKF,EAAIA,EACTE,KAAKD,EAAIA,EACFC,MASXJ,EAAOK,UAAUoC,IAAM,SAAUxC,EAAGC,EAAGC,GACnC,OAAOC,KAAKoC,eAAevC,EAAGC,EAAGC,IAMrCH,EAAOK,UAAUqC,YAAc,WAC3B,IAAIC,EAAOC,KAAKC,MAAe,IAATzC,KAAKH,GACvB6C,EAAOF,KAAKC,MAAe,IAATzC,KAAKF,GACvB6C,EAAOH,KAAKC,MAAe,IAATzC,KAAKD,GAC3B,MAAO,IAAM,UAAawC,GAAQ,UAAaG,GAAQ,UAAaC,IAMxE/C,EAAOK,UAAU2C,cAAgB,WAC7B,IAAIC,EAAiB,IAAIjD,EAEzB,OADAI,KAAK8C,mBAAmBD,GACjBA,GAMXjD,EAAOK,UAAU8C,MAAQ,WACrB,IAAI3B,EAAS,IAAIxB,EAEjB,OADAI,KAAKgD,WAAW5B,GACTA,GAMXxB,EAAOK,UAAU+C,WAAa,SAAU5B,GACpC,IAAIvB,EAAIG,KAAKH,EACTC,EAAIE,KAAKF,EACTC,EAAIC,KAAKD,EACT6B,EAAMY,KAAKZ,IAAI/B,EAAGC,EAAGC,GACrB4B,EAAMa,KAAKb,IAAI9B,EAAGC,EAAGC,GACrBkD,EAAI,EACJC,EAAI,EACJC,EAAIvB,EACJwB,EAAKxB,EAAMD,EACH,IAARC,IACAsB,EAAIE,EAAKxB,GAETA,GAAOD,IACHC,GAAO/B,GACPoD,GAAKnD,EAAIC,GAAKqD,EACVtD,EAAIC,IACJkD,GAAK,IAGJrB,GAAO9B,EACZmD,GAAKlD,EAAIF,GAAKuD,EAAK,EAEdxB,GAAO7B,IACZkD,GAAKpD,EAAIC,GAAKsD,EAAK,GAEvBH,GAAK,IAET7B,EAAOvB,EAAIoD,EACX7B,EAAOtB,EAAIoD,EACX9B,EAAOrB,EAAIoD,GAOfvD,EAAOK,UAAU6C,mBAAqB,SAAUD,GAI5C,OAHAA,EAAehD,EAAI2C,KAAKa,IAAIrD,KAAKH,EAAG,MACpCgD,EAAe/C,EAAI0C,KAAKa,IAAIrD,KAAKF,EAAG,MACpC+C,EAAe9C,EAAIyC,KAAKa,IAAIrD,KAAKD,EAAG,MAC7BC,MAMXJ,EAAOK,UAAUqD,aAAe,WAC5B,IAAIT,EAAiB,IAAIjD,EAEzB,OADAI,KAAKuD,kBAAkBV,GAChBA,GAOXjD,EAAOK,UAAUsD,kBAAoB,SAAUV,GAI3C,OAHAA,EAAehD,EAAI2C,KAAKa,IAAIrD,KAAKH,EAAG,MACpCgD,EAAe/C,EAAI0C,KAAKa,IAAIrD,KAAKF,EAAG,MACpC+C,EAAe9C,EAAIyC,KAAKa,IAAIrD,KAAKD,EAAG,MAC7BC,MASXJ,EAAO4D,cAAgB,SAAUC,EAAKC,EAAYC,EAAOvC,GACrD,IAAIwC,EAASD,EAAQD,EACjBT,EAAIQ,EAAM,GACVI,EAAID,GAAU,EAAIpB,KAAKsB,IAAKb,EAAI,EAAK,IACrCpD,EAAI,EACJC,EAAI,EACJC,EAAI,EACJkD,GAAK,GAAKA,GAAK,GACfpD,EAAI+D,EACJ9D,EAAI+D,GAECZ,GAAK,GAAKA,GAAK,GACpBpD,EAAIgE,EACJ/D,EAAI8D,GAECX,GAAK,GAAKA,GAAK,GACpBnD,EAAI8D,EACJ7D,EAAI8D,GAECZ,GAAK,GAAKA,GAAK,GACpBnD,EAAI+D,EACJ9D,EAAI6D,GAECX,GAAK,GAAKA,GAAK,GACpBpD,EAAIgE,EACJ9D,EAAI6D,GAECX,GAAK,GAAKA,GAAK,IACpBpD,EAAI+D,EACJ7D,EAAI8D,GAER,IAAIE,EAAIJ,EAAQC,EAChBxC,EAAOiB,IAAIxC,EAAIkE,EAAGjE,EAAIiE,EAAGhE,EAAIgE,IAOjCnE,EAAOoE,cAAgB,SAAUC,GAC7B,GAA4B,MAAxBA,EAAIC,UAAU,EAAG,IAA6B,IAAfD,EAAIE,OACnC,OAAO,IAAIvE,EAAO,EAAG,EAAG,GAE5B,IAAIC,EAAIuE,SAASH,EAAIC,UAAU,EAAG,GAAI,IAClCpE,EAAIsE,SAASH,EAAIC,UAAU,EAAG,GAAI,IAClCnE,EAAIqE,SAASH,EAAIC,UAAU,EAAG,GAAI,IACtC,OAAOtE,EAAOyE,SAASxE,EAAGC,EAAGC,IAQjCH,EAAO0E,UAAY,SAAU/D,EAAOG,GAEhC,YADe,IAAXA,IAAqBA,EAAS,GAC3B,IAAId,EAAOW,EAAMG,GAASH,EAAMG,EAAS,GAAIH,EAAMG,EAAS,KAQvEd,EAAOe,eAAiB,SAAUJ,EAAOG,EAAQU,QAC9B,IAAXV,IAAqBA,EAAS,GAClCU,EAAOvB,EAAIU,EAAMG,GACjBU,EAAOtB,EAAIS,EAAMG,EAAS,GAC1BU,EAAOrB,EAAIQ,EAAMG,EAAS,IAS9Bd,EAAOyE,SAAW,SAAUxE,EAAGC,EAAGC,GAC9B,OAAO,IAAIH,EAAOC,EAAI,IAAOC,EAAI,IAAOC,EAAI,MAShDH,EAAO2E,KAAO,SAAUC,EAAOC,EAAKC,GAChC,IAAItD,EAAS,IAAIxB,EAAO,EAAK,EAAK,GAElC,OADAA,EAAO+E,UAAUH,EAAOC,EAAKC,EAAQtD,GAC9BA,GASXxB,EAAO+E,UAAY,SAAUC,EAAMC,EAAOH,EAAQtD,GAC9CA,EAAOvB,EAAI+E,EAAK/E,GAAKgF,EAAMhF,EAAI+E,EAAK/E,GAAK6E,EACzCtD,EAAOtB,EAAI8E,EAAK9E,GAAK+E,EAAM/E,EAAI8E,EAAK9E,GAAK4E,EACzCtD,EAAOrB,EAAI6E,EAAK7E,GAAK8E,EAAM9E,EAAI6E,EAAK7E,GAAK2E,GAW7C9E,EAAOkF,QAAU,SAAUC,EAAQC,EAAUC,EAAQC,EAAUR,GAC3D,IAAIS,EAAUT,EAASA,EACnBU,EAAQV,EAASS,EACjBE,EAAQ,EAAMD,EAAQ,EAAMD,EAAU,EACtCG,GAAS,EAAMF,EAAQ,EAAMD,EAC7BI,EAAQH,EAAQ,EAAMD,EAAUT,EAChCc,EAAQJ,EAAQD,EAIpB,OAAO,IAAIvF,EAHHmF,EAAOlF,EAAIwF,EAAQJ,EAAOpF,EAAIyF,EAAQN,EAASnF,EAAI0F,EAAQL,EAASrF,EAAI2F,EACxET,EAAOjF,EAAIuF,EAAQJ,EAAOnF,EAAIwF,EAAQN,EAASlF,EAAIyF,EAAQL,EAASpF,EAAI0F,EACxET,EAAOhF,EAAIsF,EAAQJ,EAAOlF,EAAIuF,EAAQN,EAASjF,EAAIwF,EAAQL,EAASnF,EAAIyF,IAYpF5F,EAAO6F,qBAAuB,SAAUV,EAAQC,EAAUC,EAAQC,EAAUQ,GACxE,IAAItE,EAASxB,EAAO+F,QAEpB,OADA3F,KAAK4F,0BAA0Bb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GAClEA,GAWXxB,EAAOgG,0BAA4B,SAAUb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GACnF,IAAIyE,EAAKH,EAAOA,EAChBtE,EAAOvB,EAAkB,GAAbgG,EAAKH,GAAYX,EAAOlF,GAAK,EAAIgG,EAAK,EAAIH,EAAO,GAAKV,EAASnF,EAAmB,IAAbgG,EAAKH,GAAYT,EAAOpF,GAAK,EAAIgG,EAAK,EAAIH,GAAQR,EAASrF,EAC5IuB,EAAOtB,EAAkB,GAAb+F,EAAKH,GAAYX,EAAOjF,GAAK,EAAI+F,EAAK,EAAIH,EAAO,GAAKV,EAASlF,EAAmB,IAAb+F,EAAKH,GAAYT,EAAOnF,GAAK,EAAI+F,EAAK,EAAIH,GAAQR,EAASpF,EAC5IsB,EAAOrB,EAAkB,GAAb8F,EAAKH,GAAYX,EAAOhF,GAAK,EAAI8F,EAAK,EAAIH,EAAO,GAAKV,EAASjF,EAAmB,IAAb8F,EAAKH,GAAYT,EAAOlF,GAAK,EAAI8F,EAAK,EAAIH,GAAQR,EAASnF,GAMhJH,EAAOkG,IAAM,WACT,OAAO,IAAIlG,EAAO,EAAG,EAAG,IAM5BA,EAAOmG,MAAQ,WACX,OAAO,IAAInG,EAAO,EAAG,EAAG,IAM5BA,EAAOoG,KAAO,WACV,OAAO,IAAIpG,EAAO,EAAG,EAAG,IAM5BA,EAAO+F,MAAQ,WACX,OAAO,IAAI/F,EAAO,EAAG,EAAG,IAE5BqG,OAAOC,eAAetG,EAAQ,gBAAiB,CAI3CuG,IAAK,WACD,OAAOvG,EAAOwG,gBAElBC,YAAY,EACZC,cAAc,IAMlB1G,EAAO2G,MAAQ,WACX,OAAO,IAAI3G,EAAO,EAAG,EAAG,IAM5BA,EAAO4G,OAAS,WACZ,OAAO,IAAI5G,EAAO,GAAK,EAAG,KAM9BA,EAAO6G,QAAU,WACb,OAAO,IAAI7G,EAAO,EAAG,EAAG,IAM5BA,EAAO8G,OAAS,WACZ,OAAO,IAAI9G,EAAO,EAAG,EAAG,IAM5BA,EAAO+G,KAAO,WACV,OAAO,IAAI/G,EAAO,GAAK,GAAK,KAMhCA,EAAOgH,KAAO,WACV,OAAO,IAAIhH,EAAO,EAAG,EAAK,IAM9BA,EAAOiH,OAAS,WACZ,OAAO,IAAIjH,EAAO4C,KAAKsE,SAAUtE,KAAKsE,SAAUtE,KAAKsE,WAGzDlH,EAAOwG,eAAiBxG,EAAO+F,QACxB/F,EAlmBgB,GAwmBvBkB,EAAwB,WAQxB,SAASA,EAITjB,EAIAC,EAIAC,EAIAgH,QACc,IAANlH,IAAgBA,EAAI,QACd,IAANC,IAAgBA,EAAI,QACd,IAANC,IAAgBA,EAAI,QACd,IAANgH,IAAgBA,EAAI,GACxB/G,KAAKH,EAAIA,EACTG,KAAKF,EAAIA,EACTE,KAAKD,EAAIA,EACTC,KAAK+G,EAAIA,EAmcb,OA3bAjG,EAAOb,UAAU+G,WAAa,SAAUnC,GAKpC,OAJA7E,KAAKH,GAAKgF,EAAMhF,EAChBG,KAAKF,GAAK+E,EAAM/E,EAChBE,KAAKD,GAAK8E,EAAM9E,EAChBC,KAAK+G,GAAKlC,EAAMkC,EACT/G,MAMXc,EAAOb,UAAUc,QAAU,WACvB,MAAO,CAACf,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,EAAGC,KAAK+G,IAQzCjG,EAAOb,UAAUK,QAAU,SAAUC,EAAOC,GAMxC,YALc,IAAVA,IAAoBA,EAAQ,GAChCD,EAAMC,GAASR,KAAKH,EACpBU,EAAMC,EAAQ,GAAKR,KAAKF,EACxBS,EAAMC,EAAQ,GAAKR,KAAKD,EACxBQ,EAAMC,EAAQ,GAAKR,KAAK+G,EACjB/G,MAQXc,EAAOb,UAAUQ,UAAY,SAAUF,EAAOG,GAG1C,YAFe,IAAXA,IAAqBA,EAAS,GAClCI,EAAOH,eAAeJ,EAAOG,EAAQV,MAC9BA,MAOXc,EAAOb,UAAUoB,OAAS,SAAUH,GAChC,OAAOA,GAAclB,KAAKH,IAAMqB,EAAWrB,GAAKG,KAAKF,IAAMoB,EAAWpB,GAAKE,KAAKD,IAAMmB,EAAWnB,GAAKC,KAAK+G,IAAM7F,EAAW6F,GAOhIjG,EAAOb,UAAU4B,IAAM,SAAUgD,GAC7B,OAAO,IAAI/D,EAAOd,KAAKH,EAAIgF,EAAMhF,EAAGG,KAAKF,EAAI+E,EAAM/E,EAAGE,KAAKD,EAAI8E,EAAM9E,EAAGC,KAAK+G,EAAIlC,EAAMkC,IAO3FjG,EAAOb,UAAU8B,SAAW,SAAU8C,GAClC,OAAO,IAAI/D,EAAOd,KAAKH,EAAIgF,EAAMhF,EAAGG,KAAKF,EAAI+E,EAAM/E,EAAGE,KAAKD,EAAI8E,EAAM9E,EAAGC,KAAK+G,EAAIlC,EAAMkC,IAQ3FjG,EAAOb,UAAU+B,cAAgB,SAAU6C,EAAOzD,GAK9C,OAJAA,EAAOvB,EAAIG,KAAKH,EAAIgF,EAAMhF,EAC1BuB,EAAOtB,EAAIE,KAAKF,EAAI+E,EAAM/E,EAC1BsB,EAAOrB,EAAIC,KAAKD,EAAI8E,EAAM9E,EAC1BqB,EAAO2F,EAAI/G,KAAK+G,EAAIlC,EAAMkC,EACnB/G,MAOXc,EAAOb,UAAUsB,MAAQ,SAAUA,GAC/B,OAAO,IAAIT,EAAOd,KAAKH,EAAI0B,EAAOvB,KAAKF,EAAIyB,EAAOvB,KAAKD,EAAIwB,EAAOvB,KAAK+G,EAAIxF,IAQ/ET,EAAOb,UAAUuB,WAAa,SAAUD,EAAOH,GAK3C,OAJAA,EAAOvB,EAAIG,KAAKH,EAAI0B,EACpBH,EAAOtB,EAAIE,KAAKF,EAAIyB,EACpBH,EAAOrB,EAAIC,KAAKD,EAAIwB,EACpBH,EAAO2F,EAAI/G,KAAK+G,EAAIxF,EACbvB,MAQXc,EAAOb,UAAUwB,iBAAmB,SAAUF,EAAOH,GAKjD,OAJAA,EAAOvB,GAAKG,KAAKH,EAAI0B,EACrBH,EAAOtB,GAAKE,KAAKF,EAAIyB,EACrBH,EAAOrB,GAAKC,KAAKD,EAAIwB,EACrBH,EAAO2F,GAAK/G,KAAK+G,EAAIxF,EACdvB,MASXc,EAAOb,UAAUyB,WAAa,SAAUC,EAAKC,EAAKR,GAO9C,YANY,IAARO,IAAkBA,EAAM,QAChB,IAARC,IAAkBA,EAAM,GAC5BR,EAAOvB,EAAI,UAAaG,KAAKH,EAAG8B,EAAKC,GACrCR,EAAOtB,EAAI,UAAaE,KAAKF,EAAG6B,EAAKC,GACrCR,EAAOrB,EAAI,UAAaC,KAAKD,EAAG4B,EAAKC,GACrCR,EAAO2F,EAAI,UAAa/G,KAAK+G,EAAGpF,EAAKC,GAC9B5B,MAOXc,EAAOb,UAAUgB,SAAW,SAAUgG,GAClC,OAAO,IAAInG,EAAOd,KAAKH,EAAIoH,EAAMpH,EAAGG,KAAKF,EAAImH,EAAMnH,EAAGE,KAAKD,EAAIkH,EAAMlH,EAAGC,KAAK+G,EAAIE,EAAMF,IAQ3FjG,EAAOb,UAAUkB,cAAgB,SAAU8F,EAAO7F,GAK9C,OAJAA,EAAOvB,EAAIG,KAAKH,EAAIoH,EAAMpH,EAC1BuB,EAAOtB,EAAIE,KAAKF,EAAImH,EAAMnH,EAC1BsB,EAAOrB,EAAIC,KAAKD,EAAIkH,EAAMlH,EAC1BqB,EAAO2F,EAAI/G,KAAK+G,EAAIE,EAAMF,EACnB3F,GAMXN,EAAOb,UAAUC,SAAW,WACxB,MAAO,OAASF,KAAKH,EAAI,MAAQG,KAAKF,EAAI,MAAQE,KAAKD,EAAI,MAAQC,KAAK+G,EAAI,KAMhFjG,EAAOb,UAAUE,aAAe,WAC5B,MAAO,UAMXW,EAAOb,UAAUG,YAAc,WAC3B,IAAIC,EAAiB,IAATL,KAAKH,EAAW,EAI5B,OADAQ,EAAe,KADfA,EAAe,KADfA,EAAe,IAAPA,GAAyB,IAATL,KAAKF,EAAW,KACP,IAATE,KAAKD,EAAW,KACP,IAATC,KAAK+G,EAAW,IAO5CjG,EAAOb,UAAUgC,MAAQ,WACrB,OAAO,IAAInB,EAAOd,KAAKH,EAAGG,KAAKF,EAAGE,KAAKD,EAAGC,KAAK+G,IAOnDjG,EAAOb,UAAUiC,SAAW,SAAUC,GAKlC,OAJAnC,KAAKH,EAAIsC,EAAOtC,EAChBG,KAAKF,EAAIqC,EAAOrC,EAChBE,KAAKD,EAAIoC,EAAOpC,EAChBC,KAAK+G,EAAI5E,EAAO4E,EACT/G,MAUXc,EAAOb,UAAUmC,eAAiB,SAAUvC,EAAGC,EAAGC,EAAGgH,GAKjD,OAJA/G,KAAKH,EAAIA,EACTG,KAAKF,EAAIA,EACTE,KAAKD,EAAIA,EACTC,KAAK+G,EAAIA,EACF/G,MAUXc,EAAOb,UAAUoC,IAAM,SAAUxC,EAAGC,EAAGC,EAAGgH,GACtC,OAAO/G,KAAKoC,eAAevC,EAAGC,EAAGC,EAAGgH,IAOxCjG,EAAOb,UAAUqC,YAAc,SAAU4E,QACd,IAAnBA,IAA6BA,GAAiB,GAClD,IAAI3E,EAAOC,KAAKC,MAAe,IAATzC,KAAKH,GACvB6C,EAAOF,KAAKC,MAAe,IAATzC,KAAKF,GACvB6C,EAAOH,KAAKC,MAAe,IAATzC,KAAKD,GAC3B,GAAImH,EACA,MAAO,IAAM,UAAa3E,GAAQ,UAAaG,GAAQ,UAAaC,GAExE,IAAIwE,EAAO3E,KAAKC,MAAe,IAATzC,KAAK+G,GAC3B,MAAO,IAAM,UAAaxE,GAAQ,UAAaG,GAAQ,UAAaC,GAAQ,UAAawE,IAM7FrG,EAAOb,UAAU2C,cAAgB,WAC7B,IAAIC,EAAiB,IAAI/B,EAEzB,OADAd,KAAK8C,mBAAmBD,GACjBA,GAOX/B,EAAOb,UAAU6C,mBAAqB,SAAUD,GAK5C,OAJAA,EAAehD,EAAI2C,KAAKa,IAAIrD,KAAKH,EAAG,MACpCgD,EAAe/C,EAAI0C,KAAKa,IAAIrD,KAAKF,EAAG,MACpC+C,EAAe9C,EAAIyC,KAAKa,IAAIrD,KAAKD,EAAG,MACpC8C,EAAekE,EAAI/G,KAAK+G,EACjB/G,MAMXc,EAAOb,UAAUqD,aAAe,WAC5B,IAAIT,EAAiB,IAAI/B,EAEzB,OADAd,KAAKuD,kBAAkBV,GAChBA,GAOX/B,EAAOb,UAAUsD,kBAAoB,SAAUV,GAK3C,OAJAA,EAAehD,EAAI2C,KAAKa,IAAIrD,KAAKH,EAAG,MACpCgD,EAAe/C,EAAI0C,KAAKa,IAAIrD,KAAKF,EAAG,MACpC+C,EAAe9C,EAAIyC,KAAKa,IAAIrD,KAAKD,EAAG,MACpC8C,EAAekE,EAAI/G,KAAK+G,EACjB/G,MAiBXc,EAAOkD,cAAgB,SAAUC,GAC7B,GAA4B,MAAxBA,EAAIC,UAAU,EAAG,IAA8B,IAAfD,EAAIE,QAA+B,IAAfF,EAAIE,OACxD,OAAO,IAAIrD,EAAO,EAAK,EAAK,EAAK,GAErC,IAAIjB,EAAIuE,SAASH,EAAIC,UAAU,EAAG,GAAI,IAClCpE,EAAIsE,SAASH,EAAIC,UAAU,EAAG,GAAI,IAClCnE,EAAIqE,SAASH,EAAIC,UAAU,EAAG,GAAI,IAClC6C,EAAmB,IAAf9C,EAAIE,OAAeC,SAASH,EAAIC,UAAU,EAAG,GAAI,IAAM,IAC/D,OAAOpD,EAAOuD,SAASxE,EAAGC,EAAGC,EAAGgH,IASpCjG,EAAOyD,KAAO,SAAUK,EAAMC,EAAOH,GACjC,IAAItD,EAAS,IAAIN,EAAO,EAAK,EAAK,EAAK,GAEvC,OADAA,EAAO6D,UAAUC,EAAMC,EAAOH,EAAQtD,GAC/BA,GASXN,EAAO6D,UAAY,SAAUC,EAAMC,EAAOH,EAAQtD,GAC9CA,EAAOvB,EAAI+E,EAAK/E,GAAKgF,EAAMhF,EAAI+E,EAAK/E,GAAK6E,EACzCtD,EAAOtB,EAAI8E,EAAK9E,GAAK+E,EAAM/E,EAAI8E,EAAK9E,GAAK4E,EACzCtD,EAAOrB,EAAI6E,EAAK7E,GAAK8E,EAAM9E,EAAI6E,EAAK7E,GAAK2E,EACzCtD,EAAO2F,EAAInC,EAAKmC,GAAKlC,EAAMkC,EAAInC,EAAKmC,GAAKrC,GAW7C5D,EAAOgE,QAAU,SAAUC,EAAQC,EAAUC,EAAQC,EAAUR,GAC3D,IAAIS,EAAUT,EAASA,EACnBU,EAAQV,EAASS,EACjBE,EAAQ,EAAMD,EAAQ,EAAMD,EAAU,EACtCG,GAAS,EAAMF,EAAQ,EAAMD,EAC7BI,EAAQH,EAAQ,EAAMD,EAAUT,EAChCc,EAAQJ,EAAQD,EAKpB,OAAO,IAAIrE,EAJHiE,EAAOlF,EAAIwF,EAAQJ,EAAOpF,EAAIyF,EAAQN,EAASnF,EAAI0F,EAAQL,EAASrF,EAAI2F,EACxET,EAAOjF,EAAIuF,EAAQJ,EAAOnF,EAAIwF,EAAQN,EAASlF,EAAIyF,EAAQL,EAASpF,EAAI0F,EACxET,EAAOhF,EAAIsF,EAAQJ,EAAOlF,EAAIuF,EAAQN,EAASjF,EAAIwF,EAAQL,EAASnF,EAAIyF,EACxET,EAAOgC,EAAI1B,EAAQJ,EAAO8B,EAAIzB,EAAQN,EAAS+B,EAAIxB,EAAQL,EAAS6B,EAAIvB,IAYpF1E,EAAO2E,qBAAuB,SAAUV,EAAQC,EAAUC,EAAQC,EAAUQ,GACxE,IAAItE,EAAS,IAAIN,EAEjB,OADAd,KAAK4F,0BAA0Bb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GAClEA,GAWXN,EAAO8E,0BAA4B,SAAUb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GACnF,IAAIyE,EAAKH,EAAOA,EAChBtE,EAAOvB,EAAkB,GAAbgG,EAAKH,GAAYX,EAAOlF,GAAK,EAAIgG,EAAK,EAAIH,EAAO,GAAKV,EAASnF,EAAmB,IAAbgG,EAAKH,GAAYT,EAAOpF,GAAK,EAAIgG,EAAK,EAAIH,GAAQR,EAASrF,EAC5IuB,EAAOtB,EAAkB,GAAb+F,EAAKH,GAAYX,EAAOjF,GAAK,EAAI+F,EAAK,EAAIH,EAAO,GAAKV,EAASlF,EAAmB,IAAb+F,EAAKH,GAAYT,EAAOnF,GAAK,EAAI+F,EAAK,EAAIH,GAAQR,EAASpF,EAC5IsB,EAAOrB,EAAkB,GAAb8F,EAAKH,GAAYX,EAAOhF,GAAK,EAAI8F,EAAK,EAAIH,EAAO,GAAKV,EAASjF,EAAmB,IAAb8F,EAAKH,GAAYT,EAAOlF,GAAK,EAAI8F,EAAK,EAAIH,GAAQR,EAASnF,EAC5IqB,EAAO2F,EAAkB,GAAblB,EAAKH,GAAYX,EAAOgC,GAAK,EAAIlB,EAAK,EAAIH,EAAO,GAAKV,EAAS+B,EAAmB,IAAblB,EAAKH,GAAYT,EAAO8B,GAAK,EAAIlB,EAAK,EAAIH,GAAQR,EAAS6B,GAQhJjG,EAAOsG,WAAa,SAAUC,EAAQxG,GAElC,YADc,IAAVA,IAAoBA,EAAQ,GACzB,IAAIC,EAAOuG,EAAOxH,EAAGwH,EAAOvH,EAAGuH,EAAOtH,EAAGc,IAQpDC,EAAOwD,UAAY,SAAU/D,EAAOG,GAEhC,YADe,IAAXA,IAAqBA,EAAS,GAC3B,IAAII,EAAOP,EAAMG,GAASH,EAAMG,EAAS,GAAIH,EAAMG,EAAS,GAAIH,EAAMG,EAAS,KAQ1FI,EAAOH,eAAiB,SAAUJ,EAAOG,EAAQU,QAC9B,IAAXV,IAAqBA,EAAS,GAClCU,EAAOvB,EAAIU,EAAMG,GACjBU,EAAOtB,EAAIS,EAAMG,EAAS,GAC1BU,EAAOrB,EAAIQ,EAAMG,EAAS,GAC1BU,EAAO2F,EAAIxG,EAAMG,EAAS,IAU9BI,EAAOuD,SAAW,SAAUxE,EAAGC,EAAGC,EAAGgH,GACjC,OAAO,IAAIjG,EAAOjB,EAAI,IAAOC,EAAI,IAAOC,EAAI,IAAOgH,EAAI,MAS3DjG,EAAOwG,aAAe,SAAUC,EAAQC,GAEpC,GAAID,EAAOpD,SAAmB,EAARqD,EAAW,CAE7B,IADA,IAAIC,EAAU,GACLjH,EAAQ,EAAGA,EAAQ+G,EAAOpD,OAAQ3D,GAAS,EAAG,CACnD,IAAIkH,EAAYlH,EAAQ,EAAK,EAC7BiH,EAAQC,GAAYH,EAAO/G,GAC3BiH,EAAQC,EAAW,GAAKH,EAAO/G,EAAQ,GACvCiH,EAAQC,EAAW,GAAKH,EAAO/G,EAAQ,GACvCiH,EAAQC,EAAW,GAAK,EAE5B,OAAOD,EAEX,OAAOF,GAEJzG,EAnegB,GAyevB6G,EAA2B,WAC3B,SAASA,KAIT,OAFAA,EAAU/H,OAAS,eAAsB,EAAGA,EAAO+F,OACnDgC,EAAU7G,OAAS,eAAsB,GAAG,WAAc,OAAO,IAAIA,EAAO,EAAG,EAAG,EAAG,MAC9E6G,EALmB,IAQ9B,OAAc,iBAAkB/H,IAChC,OAAc,iBAAkBkB,I,6DC5lCzB,IAAI8G,EAAe,EAAI,IAMnBC,EAAgB,IAKhBC,GAAO,EAAItF,KAAKuF,KAAK,IAAM,EAMlCC,EAAU,M,gDClBVC,EAAyB,WACzB,SAASA,KAgHT,OAzGAA,EAAQC,UAAY,SAAUC,GAE1B,IADA,IAAIC,EAAgB,GACX5H,EAAQ,EAAGA,EAAQ,EAAGA,IAC3B4H,EAAcC,KAAK,IAAI,IAAM,EAAK,EAAK,EAAK,IAGhD,OADAJ,EAAQK,eAAeH,EAAWC,GAC3BA,GAOXH,EAAQM,kBAAoB,SAAUJ,EAAWK,GAC7C,IAAIzE,EAAIoE,EAAUpE,EAClByE,EAAaC,OAAO5E,EAAIE,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOC,EAAI3E,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOE,EAAI5E,EAAE,IAAMA,EAAE,IAClCyE,EAAaI,EAAI7E,EAAE,IAAMA,EAAE,IAC3ByE,EAAaK,aAOjBZ,EAAQa,iBAAmB,SAAUX,EAAWK,GAC5C,IAAIzE,EAAIoE,EAAUpE,EAClByE,EAAaC,OAAO5E,EAAIE,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOC,EAAI3E,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOE,EAAI5E,EAAE,IAAMA,EAAE,IAClCyE,EAAaI,EAAI7E,EAAE,IAAMA,EAAE,IAC3ByE,EAAaK,aAOjBZ,EAAQc,kBAAoB,SAAUZ,EAAWK,GAC7C,IAAIzE,EAAIoE,EAAUpE,EAClByE,EAAaC,OAAO5E,EAAIE,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOC,EAAI3E,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOE,EAAI5E,EAAE,IAAMA,EAAE,GAClCyE,EAAaI,EAAI7E,EAAE,IAAMA,EAAE,IAC3ByE,EAAaK,aAOjBZ,EAAQe,mBAAqB,SAAUb,EAAWK,GAC9C,IAAIzE,EAAIoE,EAAUpE,EAClByE,EAAaC,OAAO5E,EAAIE,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOC,EAAI3E,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOE,EAAI5E,EAAE,IAAMA,EAAE,GAClCyE,EAAaI,EAAI7E,EAAE,IAAMA,EAAE,IAC3ByE,EAAaK,aAOjBZ,EAAQgB,iBAAmB,SAAUd,EAAWK,GAC5C,IAAIzE,EAAIoE,EAAUpE,EAClByE,EAAaC,OAAO5E,EAAIE,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOC,EAAI3E,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOE,EAAI5E,EAAE,IAAMA,EAAE,GAClCyE,EAAaI,EAAI7E,EAAE,IAAMA,EAAE,IAC3ByE,EAAaK,aAOjBZ,EAAQiB,oBAAsB,SAAUf,EAAWK,GAC/C,IAAIzE,EAAIoE,EAAUpE,EAClByE,EAAaC,OAAO5E,EAAIE,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOC,EAAI3E,EAAE,GAAKA,EAAE,GACjCyE,EAAaC,OAAOE,EAAI5E,EAAE,IAAMA,EAAE,GAClCyE,EAAaI,EAAI7E,EAAE,IAAMA,EAAE,IAC3ByE,EAAaK,aAOjBZ,EAAQK,eAAiB,SAAUH,EAAWC,GAE1CH,EAAQM,kBAAkBJ,EAAWC,EAAc,IAEnDH,EAAQa,iBAAiBX,EAAWC,EAAc,IAElDH,EAAQc,kBAAkBZ,EAAWC,EAAc,IAEnDH,EAAQe,mBAAmBb,EAAWC,EAAc,IAEpDH,EAAQgB,iBAAiBd,EAAWC,EAAc,IAElDH,EAAQiB,oBAAoBf,EAAWC,EAAc,KAElDH,EAjHiB,I,8ECAxBkB,EAA6B,WAC7B,SAASA,KAyCT,OAvCAA,EAAYC,wBAA0B,SAAUC,EAAWC,EAASC,EAAYC,EAAYC,EAASC,GACjG,IAAK,IAAIlJ,EAAQ+I,EAAY/I,EAAQ+I,EAAaC,EAAYhJ,IAAS,CACnE,IAAIE,EAA0B,EAAjB4I,EAAQ9I,GACjBqD,EAAIwF,EAAU3I,GACdgI,EAAIW,EAAU3I,EAAS,GACvBiI,EAAIU,EAAU3I,EAAS,GAC3B+I,EAAQE,0BAA0B9F,EAAG6E,EAAGC,GACxCe,EAAQE,0BAA0B/F,EAAG6E,EAAGC,KAGhDQ,EAAYU,iBAAmB,SAAUR,EAAW7E,EAAOgD,EAAOsC,EAAQL,EAASC,GAC/E,IAAK,IAAIlJ,EAAQgE,EAAO9D,EAAS8D,EAAQsF,EAAQtJ,EAAQgE,EAAQgD,EAAOhH,IAASE,GAAUoJ,EAAQ,CAC/F,IAAIjG,EAAIwF,EAAU3I,GACdgI,EAAIW,EAAU3I,EAAS,GACvBiI,EAAIU,EAAU3I,EAAS,GAC3B+I,EAAQE,0BAA0B9F,EAAG6E,EAAGC,GACxCe,EAAQE,0BAA0B/F,EAAG6E,EAAGC,MAGhD,QAAW,CACP,aAAsB,WAElB,IADA,IAAIoB,EAAK,GACAC,EAAK,EAAGA,EAAKC,UAAU9F,OAAQ6F,IACpCD,EAAGC,GAAMC,UAAUD,GAEvB,IAAIX,EAAYU,EAAG,GAAIT,EAAUS,EAAG,GACpC,OAAQG,MAAMC,QAAQd,KAAea,MAAMC,QAAQb,OAExDH,EAAa,0BAA2B,OAC3C,QAAW,CACP,aAAsB,WAElB,IADA,IAAIY,EAAK,GACAC,EAAK,EAAGA,EAAKC,UAAU9F,OAAQ6F,IACpCD,EAAGC,GAAMC,UAAUD,GAEvB,IAAIX,EAAYU,EAAG,GACnB,OAAQG,MAAMC,QAAQd,OAE3BF,EAAa,mBAAoB,MAC7BA,EA1CqB,GAqDzB,SAASC,EAAwBC,EAAWC,EAASC,EAAYC,EAAYY,QACnE,IAATA,IAAmBA,EAAO,MAC9B,IAAIX,EAAU,IAAI,IAAQY,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WACjEZ,EAAU,IAAI,KAASW,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,WAUxE,OATAnB,EAAYC,wBAAwBC,EAAWC,EAASC,EAAYC,EAAYC,EAASC,GACrFU,IACAX,EAAQ5F,GAAK4F,EAAQ5F,EAAIuG,EAAKvG,EAAIuG,EAAK1B,EACvCe,EAAQf,GAAKe,EAAQf,EAAI0B,EAAKvG,EAAIuG,EAAK1B,EACvCe,EAAQd,GAAKc,EAAQd,EAAIyB,EAAKvG,EAAIuG,EAAK1B,EACvCgB,EAAQ7F,GAAK6F,EAAQ7F,EAAIuG,EAAKvG,EAAIuG,EAAK1B,EACvCgB,EAAQhB,GAAKgB,EAAQhB,EAAI0B,EAAKvG,EAAIuG,EAAK1B,EACvCgB,EAAQf,GAAKe,EAAQf,EAAIyB,EAAKvG,EAAIuG,EAAK1B,GAEpC,CACHe,QAASA,EACTC,QAASA,GAYV,SAASG,EAAiBR,EAAW7E,EAAOgD,EAAO4C,EAAMN,QAC/C,IAATM,IAAmBA,EAAO,MAC9B,IAAIX,EAAU,IAAI,IAAQY,OAAOC,UAAWD,OAAOC,UAAWD,OAAOC,WACjEZ,EAAU,IAAI,KAASW,OAAOC,WAAYD,OAAOC,WAAYD,OAAOC,WAaxE,OAZKR,IACDA,EAAS,GAEbX,EAAYU,iBAAiBR,EAAW7E,EAAOgD,EAAOsC,EAAQL,EAASC,GACnEU,IACAX,EAAQ5F,GAAK4F,EAAQ5F,EAAIuG,EAAKvG,EAAIuG,EAAK1B,EACvCe,EAAQf,GAAKe,EAAQf,EAAI0B,EAAKvG,EAAIuG,EAAK1B,EACvCe,EAAQd,GAAKc,EAAQd,EAAIyB,EAAKvG,EAAIuG,EAAK1B,EACvCgB,EAAQ7F,GAAK6F,EAAQ7F,EAAIuG,EAAKvG,EAAIuG,EAAK1B,EACvCgB,EAAQhB,GAAKgB,EAAQhB,EAAI0B,EAAKvG,EAAIuG,EAAK1B,EACvCgB,EAAQf,GAAKe,EAAQf,EAAIyB,EAAKvG,EAAIuG,EAAK1B,GAEpC,CACHe,QAASA,EACTC,QAASA,K,2DC7Fba,EAA4B,WAM5B,SAASA,EAET1G,EAEA6E,QACc,IAAN7E,IAAgBA,EAAI,QACd,IAAN6E,IAAgBA,EAAI,GACxB1I,KAAK6D,EAAIA,EACT7D,KAAK0I,EAAIA,EACL7E,IAAMrB,KAAKgI,MAAM3G,KACXrB,KAAKgI,MAAM3G,GACjB,SAAY,uCAEZ6E,IAAMlG,KAAKgI,MAAM9B,KACXlG,KAAKgI,MAAM9B,GACjB,SAAY,uCAsGpB,OA9FA6B,EAAWtK,UAAUgC,MAAQ,WACzB,OAAO,IAAIsI,EAAWvK,KAAK6D,EAAG7D,KAAK0I,IAQvC6B,EAAWtK,UAAUwK,cAAgB,SAAUC,GAE3C,IAAI7G,EAAI7D,KAAK6D,EAGb,OAFA7D,KAAK6D,EAAI6G,EAAM7G,EAAI6G,EAAMhC,EAAI1I,KAAK0I,EAClC1I,KAAK0I,EAAI7E,EAAI7D,KAAK0I,EAAIgC,EAAM7G,EACrB7D,MAQXuK,EAAWtK,UAAU0K,iBAAmB,SAAUD,GAC9C,IAAI7G,EAAI7D,KAAK6D,EAGb,OAFA7D,KAAK6D,EAAIA,EAAI7D,KAAK0I,EAAIgC,EAAMhC,EAC5B1I,KAAK0I,EAAIgC,EAAM7G,EAAI6G,EAAMhC,EAAI7E,EACtB7D,MAUXuK,EAAWtK,UAAU2K,UAAY,SAAU7G,EAAG8G,GAEtC9G,IAAMvB,KAAKgI,MAAMzG,KACXvB,KAAKgI,MAAMzG,GACjB,SAAY,wCAEZ8G,IAAMrI,KAAKgI,MAAMK,KACXrI,KAAKgI,MAAMK,GACjB,SAAY,wCAEhB,IAAIhH,EAAI7D,KAAK6D,EAGb,OAFA7D,KAAK6D,EAAIE,EAAIF,EAAI7D,KAAK0I,EACtB1I,KAAK0I,EAAImC,EAAIhH,EACN7D,MAUXuK,EAAWtK,UAAU6K,aAAe,SAAU/G,EAAG8G,GAEzC9G,IAAMvB,KAAKgI,MAAMzG,KACXvB,KAAKgI,MAAMzG,GACjB,SAAY,uCAEZ8G,IAAMrI,KAAKgI,MAAMK,KACXrI,KAAKgI,MAAMK,GACjB,SAAY,yCAEhB,IAAIhH,EAAI7D,KAAK6D,EAGb,OAFA7D,KAAK6D,EAAI7D,KAAK0I,EAAImC,EAClB7K,KAAK0I,EAAI3E,EAAI8G,EAAIhH,EAAI7D,KAAK0I,EACnB1I,MAQXuK,EAAWtK,UAAU8K,kBAAoB,SAAUC,EAAQC,GACvD,IAAIC,EAAQ,WAGZ,OAFAA,EAAMrH,EAAImH,EAAOnH,EAAI,EAAI7D,KAAK6D,EAAIoH,EAAcjL,KAAK0I,EAAIuC,EACzDC,EAAMxC,EAAIsC,EAAOtC,EAAIlG,KAAKuF,KAAK,GAAK/H,KAAK0I,EAAIuC,EACtCC,GAOXX,EAAWY,KAAO,WACd,OAAO,IAAIZ,EAAW,EAAG,IAEtBA,EA3HoB,I,sjBCHpBa,E,kCACX,SAAWA,GAIPA,EAAYA,EAAgB,GAAI,GAAK,KAErCA,EAAYA,EAAiB,IAAI,GAAK,MAN1C,CAOGA,IAAgBA,EAAc,KAEjC,IAAIC,EAA6B,WAC7B,SAASA,KA4BT,OAjBAA,EAAYC,YAAc,SAAUC,EAAGC,EAAIC,EAAIC,EAAIC,GAM/C,IAJA,IAAIC,EAAK,EAAI,EAAIF,EAAK,EAAIF,EACtBK,EAAK,EAAIH,EAAK,EAAIF,EAClBM,EAAK,EAAIN,EACTO,EAAWR,EACNS,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,IAAIC,EAAYF,EAAWA,EAI3BA,IAFQH,GADQK,EAAYF,GACHF,EAAKI,EAAYH,EAAKC,EAE9BR,IADL,GAAO,EAAMK,EAAKK,EAAY,EAAMJ,EAAKE,EAAWD,IAEhEC,EAAWvJ,KAAKb,IAAI,EAAGa,KAAKZ,IAAI,EAAGmK,IAGvC,OAAO,EAAIvJ,KAAKa,IAAI,EAAI0I,EAAU,GAAKA,EAAWN,EAAK,GAAK,EAAIM,GAAYvJ,KAAKa,IAAI0I,EAAU,GAAKJ,EAAKnJ,KAAKa,IAAI0I,EAAU,IAEzHV,EA7BqB,GAmC5Ba,EAAuB,WAKvB,SAASA,EAAMC,GACXnM,KAAKoM,SAAWD,EACZnM,KAAKoM,SAAW,IAChBpM,KAAKoM,UAAY,EAAM5J,KAAK6J,IA4CpC,OArCAH,EAAMjM,UAAUqM,QAAU,WACtB,OAAwB,IAAhBtM,KAAKoM,SAAoB5J,KAAK6J,IAM1CH,EAAMjM,UAAUkM,QAAU,WACtB,OAAOnM,KAAKoM,UAQhBF,EAAMK,iBAAmB,SAAUxF,EAAGhH,GAClC,IAAIyM,EAAQzM,EAAEgC,SAASgF,GAEvB,OAAO,IAAImF,EADC1J,KAAKiK,MAAMD,EAAM9D,EAAG8D,EAAM3I,KAQ1CqI,EAAMQ,YAAc,SAAUP,GAC1B,OAAO,IAAID,EAAMC,IAOrBD,EAAMS,YAAc,SAAUL,GAC1B,OAAO,IAAIJ,EAAOI,EAAU9J,KAAK6J,GAAM,MAEpCH,EApDe,GA0DtBU,EAOA,SAEAC,EAEAC,EAEAC,GACI/M,KAAK6M,WAAaA,EAClB7M,KAAK8M,SAAWA,EAChB9M,KAAK+M,SAAWA,EAChB,IAAIC,EAAOxK,KAAKa,IAAIyJ,EAASjJ,EAAG,GAAKrB,KAAKa,IAAIyJ,EAASpE,EAAG,GACtDuE,GAAczK,KAAKa,IAAIwJ,EAAWhJ,EAAG,GAAKrB,KAAKa,IAAIwJ,EAAWnE,EAAG,GAAKsE,GAAQ,EAC9EE,GAAYF,EAAOxK,KAAKa,IAAI0J,EAASlJ,EAAG,GAAKrB,KAAKa,IAAI0J,EAASrE,EAAG,IAAM,EACxEyE,GAAON,EAAWhJ,EAAIiJ,EAASjJ,IAAMiJ,EAASpE,EAAIqE,EAASrE,IAAMoE,EAASjJ,EAAIkJ,EAASlJ,IAAMgJ,EAAWnE,EAAIoE,EAASpE,GACzH1I,KAAKoN,YAAc,IAAI,MAASH,GAAcH,EAASpE,EAAIqE,EAASrE,GAAKwE,GAAYL,EAAWnE,EAAIoE,EAASpE,IAAMyE,IAAON,EAAWhJ,EAAIiJ,EAASjJ,GAAKqJ,GAAYJ,EAASjJ,EAAIkJ,EAASlJ,GAAKoJ,GAAcE,GAC5MnN,KAAKqN,OAASrN,KAAKoN,YAAYrL,SAAS/B,KAAK6M,YAAY1I,SACzDnE,KAAKsN,WAAapB,EAAMK,iBAAiBvM,KAAKoN,YAAapN,KAAK6M,YAChE,IAAIU,EAAKvN,KAAKsN,WAAWhB,UACrBkB,EAAKtB,EAAMK,iBAAiBvM,KAAKoN,YAAapN,KAAK8M,UAAUR,UAC7DmB,EAAKvB,EAAMK,iBAAiBvM,KAAKoN,YAAapN,KAAK+M,UAAUT,UAE7DkB,EAAKD,EAAK,MACVC,GAAM,KAENA,EAAKD,GAAM,MACXC,GAAM,KAENC,EAAKD,EAAK,MACVC,GAAM,KAENA,EAAKD,GAAM,MACXC,GAAM,KAEVzN,KAAK0N,YAAcF,EAAKD,EAAK,EAAInC,EAAYuC,GAAKvC,EAAYwC,IAC9D5N,KAAK6N,MAAQ3B,EAAMS,YAAY3M,KAAK0N,cAAgBtC,EAAYuC,GAAKJ,EAAKE,EAAKA,EAAKF,IAQxFO,EAAuB,WAMvB,SAASA,EAAMjK,EAAG6E,GACd1I,KAAK+N,QAAU,IAAI7D,MACnBlK,KAAKgO,QAAU,EAIfhO,KAAKiO,QAAS,EACdjO,KAAK+N,QAAQ1F,KAAK,IAAI,KAAQxE,EAAG6E,IAgHrC,OAxGAoF,EAAM7N,UAAUiO,UAAY,SAAUrK,EAAG6E,GACrC,GAAI1I,KAAKiO,OACL,OAAOjO,KAEX,IAAImO,EAAW,IAAI,KAAQtK,EAAG6E,GAC1B0F,EAAgBpO,KAAK+N,QAAQ/N,KAAK+N,QAAQ5J,OAAS,GAGvD,OAFAnE,KAAK+N,QAAQ1F,KAAK8F,GAClBnO,KAAKgO,SAAWG,EAASpM,SAASqM,GAAejK,SAC1CnE,MAWX8N,EAAM7N,UAAUoO,SAAW,SAAUC,EAAMC,EAAMC,EAAMC,EAAMC,GAEzD,QADyB,IAArBA,IAA+BA,EAAmB,IAClD1O,KAAKiO,OACL,OAAOjO,KAEX,IAAI6M,EAAa7M,KAAK+N,QAAQ/N,KAAK+N,QAAQ5J,OAAS,GAChD2I,EAAW,IAAI,KAAQwB,EAAMC,GAC7BxB,EAAW,IAAI,KAAQyB,EAAMC,GAC7BE,EAAM,IAAI/B,EAAKC,EAAYC,EAAUC,GACrC6B,EAAYD,EAAId,MAAM1B,UAAYuC,EAClCC,EAAIjB,cAAgBtC,EAAYuC,KAChCiB,IAAc,GAGlB,IADA,IAAIC,EAAeF,EAAIrB,WAAWnB,UAAYyC,EACrC5C,EAAI,EAAGA,EAAI0C,EAAkB1C,IAAK,CACvC,IAAInI,EAAIrB,KAAKsM,IAAID,GAAgBF,EAAItB,OAASsB,EAAIvB,YAAYvJ,EAC1D6E,EAAIlG,KAAKuM,IAAIF,GAAgBF,EAAItB,OAASsB,EAAIvB,YAAY1E,EAC9D1I,KAAKkO,UAAUrK,EAAG6E,GAClBmG,GAAgBD,EAEpB,OAAO5O,MAMX8N,EAAM7N,UAAU+O,MAAQ,WAEpB,OADAhP,KAAKiO,QAAS,EACPjO,MAMX8N,EAAM7N,UAAUkE,OAAS,WACrB,IAAI/C,EAASpB,KAAKgO,QAClB,GAAIhO,KAAKiO,OAAQ,CACb,IAAIgB,EAAYjP,KAAK+N,QAAQ/N,KAAK+N,QAAQ5J,OAAS,GAEnD/C,GADiBpB,KAAK+N,QAAQ,GACThM,SAASkN,GAAW9K,SAE7C,OAAO/C,GAMX0M,EAAM7N,UAAUiP,UAAY,WACxB,OAAOlP,KAAK+N,SAOhBD,EAAM7N,UAAUkP,yBAA2B,SAAUC,GACjD,GAAIA,EAA2B,GAAKA,EAA2B,EAC3D,OAAO,YAIX,IAFA,IAAIC,EAAiBD,EAA2BpP,KAAKmE,SACjDmL,EAAiB,EACZtD,EAAI,EAAGA,EAAIhM,KAAK+N,QAAQ5J,OAAQ6H,IAAK,CAC1C,IAAIuD,GAAKvD,EAAI,GAAKhM,KAAK+N,QAAQ5J,OAC3B4C,EAAI/G,KAAK+N,QAAQ/B,GAEjBwD,EADIxP,KAAK+N,QAAQwB,GACRxN,SAASgF,GAClB0I,EAAaD,EAAKrL,SAAWmL,EACjC,GAAID,GAAkBC,GAAkBD,GAAkBI,EAAY,CAClE,IAAIC,EAAMF,EAAK3G,YACX8G,EAAcN,EAAiBC,EACnC,OAAO,IAAI,KAAQvI,EAAElD,EAAI6L,EAAI7L,EAAI8L,EAAa5I,EAAE2B,EAAIgH,EAAIhH,EAAIiH,GAEhEL,EAAiBG,EAErB,OAAO,aAQX3B,EAAM8B,WAAa,SAAU/L,EAAG6E,GAC5B,OAAO,IAAIoF,EAAMjK,EAAG6E,IAEjBoF,EA7He,GAoItB+B,EAAwB,WAUxB,SAASA,EAITC,EAAMC,EAAaC,EAAKC,QACA,IAAhBF,IAA0BA,EAAc,WACd,IAA1BE,IAAoCA,GAAwB,GAChEjQ,KAAK8P,KAAOA,EACZ9P,KAAKkQ,OAAS,IAAIhG,MAClBlK,KAAKmQ,WAAa,IAAIjG,MACtBlK,KAAKoQ,UAAY,IAAIlG,MACrBlK,KAAKqQ,SAAW,IAAInG,MACpBlK,KAAKsQ,WAAa,IAAIpG,MAEtBlK,KAAKuQ,aAAe,CAChBC,GAAI,EACJtF,MAAO,WACPuF,wBAAyB,EACzBC,SAAU,EACVC,YAAa,EACbC,kBAAkB,EAClBC,oBAAqB,iBAEzB,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAK3L,OAAQ2M,IAC7B9Q,KAAKkQ,OAAOY,GAAKhB,EAAKgB,GAAG7O,QAE7BjC,KAAK+Q,KAAOf,IAAO,EACnBhQ,KAAKgR,uBAAyBf,EAC9BjQ,KAAKiR,SAASlB,EAAaE,GAgZ/B,OA1YAJ,EAAO5P,UAAUiR,SAAW,WACxB,OAAOlR,KAAKkQ,QAMhBL,EAAO5P,UAAUiP,UAAY,WACzB,OAAOlP,KAAKkQ,QAKhBL,EAAO5P,UAAUkE,OAAS,WACtB,OAAOnE,KAAKmQ,WAAWnQ,KAAKmQ,WAAWhM,OAAS,IAMpD0L,EAAO5P,UAAUkR,YAAc,WAC3B,OAAOnR,KAAKoQ,WAMhBP,EAAO5P,UAAUmR,WAAa,WAC1B,OAAOpR,KAAKqQ,UAMhBR,EAAO5P,UAAUoR,aAAe,WAC5B,OAAOrR,KAAKsQ,YAMhBT,EAAO5P,UAAUqR,aAAe,WAC5B,OAAOtR,KAAKmQ,YAOhBN,EAAO5P,UAAUsR,WAAa,SAAUb,GACpC,OAAO1Q,KAAKwR,mBAAmBd,GAAUxF,OAQ7C2E,EAAO5P,UAAUwR,aAAe,SAAUf,EAAUgB,GAGhD,YAFqB,IAAjBA,IAA2BA,GAAe,GAC9C1R,KAAKwR,mBAAmBd,EAAUgB,GAC3BA,EAAe,yBAA6B,cAAmB1R,KAAKuQ,aAAaM,qBAAuB7Q,KAAKoQ,UAAUpQ,KAAKuQ,aAAaE,0BAQpJZ,EAAO5P,UAAU0R,YAAc,SAAUjB,EAAUgB,GAG/C,YAFqB,IAAjBA,IAA2BA,GAAe,GAC9C1R,KAAKwR,mBAAmBd,EAAUgB,GAC3BA,EAAe,yBAA6B,YAAiB1R,KAAKuQ,aAAaM,qBAAuB7Q,KAAKqQ,SAASrQ,KAAKuQ,aAAaE,0BAQjJZ,EAAO5P,UAAU2R,cAAgB,SAAUlB,EAAUgB,GAGjD,YAFqB,IAAjBA,IAA2BA,GAAe,GAC9C1R,KAAKwR,mBAAmBd,EAAUgB,GAC3BA,EAAe,yBAA6B,eAAoB1R,KAAKuQ,aAAaM,qBAAuB7Q,KAAKsQ,WAAWtQ,KAAKuQ,aAAaE,0BAOtJZ,EAAO5P,UAAU4R,cAAgB,SAAUnB,GACvC,OAAO1Q,KAAKmE,SAAWuM,GAO3Bb,EAAO5P,UAAU6R,wBAA0B,SAAUpB,GAEjD,OADA1Q,KAAKwR,mBAAmBd,GACjB1Q,KAAKuQ,aAAaE,yBAO7BZ,EAAO5P,UAAU8R,iBAAmB,SAAUrB,GAE1C,OADA1Q,KAAKwR,mBAAmBd,GACjB1Q,KAAKuQ,aAAaI,aAO7Bd,EAAO5P,UAAU+R,qBAAuB,SAAUC,GAG9C,IAFA,IAAIC,EAAmB7H,OAAOC,UAC1B6H,EAAkB,EACbnG,EAAI,EAAGA,EAAIhM,KAAKkQ,OAAO/L,OAAS,EAAG6H,IAAK,CAC7C,IAAId,EAAQlL,KAAKkQ,OAAOlE,EAAI,GACxBoG,EAAUpS,KAAKkQ,OAAOlE,EAAI,GAAGjK,SAASmJ,GAAOrC,YAC7CwJ,EAAYrS,KAAKmQ,WAAWnE,EAAI,GAAKhM,KAAKmQ,WAAWnE,EAAI,GACzD2E,EAAcnO,KAAKb,IAAKa,KAAKZ,IAAI,QAAYwQ,EAASH,EAAOlQ,SAASmJ,GAAOrC,aAAc,GAAO,aAAiBqC,EAAO+G,GAAWI,EAAW,GAChJC,EAAW,aAAiBpH,EAAMrJ,IAAIuQ,EAAQ7Q,MAAMoP,EAAc0B,IAAaJ,GAC/EK,EAAWJ,IACXA,EAAmBI,EACnBH,GAAmBnS,KAAKmQ,WAAWnE,EAAI,GAAKqG,EAAY1B,GAAe3Q,KAAKmE,UAGpF,OAAOgO,GAQXtC,EAAO5P,UAAUsS,MAAQ,SAAU/N,EAAOC,GAStC,QARc,IAAVD,IAAoBA,EAAQ,QACpB,IAARC,IAAkBA,EAAM,GACxBD,EAAQ,IACRA,EAAQ,IAAe,EAATA,EAAgB,GAE9BC,EAAM,IACNA,EAAM,IAAa,EAAPA,EAAc,GAE1BD,EAAQC,EAAK,CACb,IAAI+N,EAAShO,EACbA,EAAQC,EACRA,EAAM+N,EAEV,IAAIC,EAAczS,KAAKkR,WACnBrE,EAAa7M,KAAKuR,WAAW/M,GAC7BkO,EAAa1S,KAAK8R,wBAAwBtN,GAC1CuI,EAAW/M,KAAKuR,WAAW9M,GAC3BkO,EAAW3S,KAAK8R,wBAAwBrN,GAAO,EAC/CmO,EAAc,GASlB,OARc,IAAVpO,IACAkO,IACAE,EAAYvK,KAAKwE,IAErB+F,EAAYvK,KAAKwK,MAAMD,EAAaH,EAAYF,MAAMG,EAAYC,IACtD,IAARlO,GAAyB,IAAVD,GACfoO,EAAYvK,KAAK0E,GAEd,IAAI8C,EAAO+C,EAAa5S,KAAK2R,YAAYnN,GAAQxE,KAAK+Q,KAAM/Q,KAAKgR,yBAS5EnB,EAAO5P,UAAU6S,OAAS,SAAUhD,EAAMC,EAAaE,QAC/B,IAAhBF,IAA0BA,EAAc,WACd,IAA1BE,IAAoCA,GAAwB,GAChE,IAAK,IAAIa,EAAI,EAAGA,EAAIhB,EAAK3L,OAAQ2M,IAC7B9Q,KAAKkQ,OAAOY,GAAGjN,EAAIiM,EAAKgB,GAAGjN,EAC3B7D,KAAKkQ,OAAOY,GAAGpI,EAAIoH,EAAKgB,GAAGpI,EAC3B1I,KAAKkQ,OAAOY,GAAGnI,EAAImH,EAAKgB,GAAGnI,EAG/B,OADA3I,KAAKiR,SAASlB,EAAaE,GACpBjQ,MAGX6P,EAAO5P,UAAUgR,SAAW,SAAUlB,EAAaE,QACjB,IAA1BA,IAAoCA,GAAwB,GAChE,IAAI8C,EAAI/S,KAAKkQ,OAAO/L,OACpB,KAAI4O,EAAI,GAAR,CAIA/S,KAAKoQ,UAAU,GAAKpQ,KAAKgT,uBAAuB,GAC3ChT,KAAK+Q,MACN/Q,KAAKoQ,UAAU,GAAGvH,YAEtB7I,KAAKoQ,UAAU2C,EAAI,GAAK/S,KAAKkQ,OAAO6C,EAAI,GAAGhR,SAAS/B,KAAKkQ,OAAO6C,EAAI,IAC/D/S,KAAK+Q,MACN/Q,KAAKoQ,UAAU2C,EAAI,GAAGlK,YAG1B,IAYIoK,EACAC,EACAC,EAEAC,EACAC,EAjBAC,EAAMtT,KAAKoQ,UAAU,GACrBmD,EAAMvT,KAAKwT,cAAcF,EAAKvD,GAClC/P,KAAKqQ,SAAS,GAAKkD,EACdvT,KAAK+Q,MACN/Q,KAAKqQ,SAAS,GAAGxH,YAErB7I,KAAKsQ,WAAW,GAAK,UAAcgD,EAAKtT,KAAKqQ,SAAS,IACjDrQ,KAAK+Q,MACN/Q,KAAKsQ,WAAW,GAAGzH,YAEvB7I,KAAKmQ,WAAW,GAAK,EAQrB,IAAK,IAAInE,EAAI,EAAGA,EAAI+G,EAAG/G,IAEnBiH,EAAOjT,KAAKyT,sBAAsBzH,GAC9BA,EAAI+G,EAAI,IACRG,EAAMlT,KAAKgT,uBAAuBhH,GAClChM,KAAKoQ,UAAUpE,GAAKiE,EAAwBiD,EAAMD,EAAKpR,IAAIqR,GAC3DlT,KAAKoQ,UAAUpE,GAAGnD,aAEtB7I,KAAKmQ,WAAWnE,GAAKhM,KAAKmQ,WAAWnE,EAAI,GAAKhM,KAAKkQ,OAAOlE,GAAGjK,SAAS/B,KAAKkQ,OAAOlE,EAAI,IAAI7H,SAG1FgP,EAAUnT,KAAKoQ,UAAUpE,GACzBqH,EAAYrT,KAAKsQ,WAAWtE,EAAI,GAChChM,KAAKqQ,SAASrE,GAAK,UAAcqH,EAAWF,GACvCnT,KAAK+Q,OAC4B,IAA9B/Q,KAAKqQ,SAASrE,GAAG7H,UACjBiP,EAAUpT,KAAKqQ,SAASrE,EAAI,GAC5BhM,KAAKqQ,SAASrE,GAAKoH,EAAQnR,SAG3BjC,KAAKqQ,SAASrE,GAAGnD,aAGzB7I,KAAKsQ,WAAWtE,GAAK,UAAcmH,EAASnT,KAAKqQ,SAASrE,IACrDhM,KAAK+Q,MACN/Q,KAAKsQ,WAAWtE,GAAGnD,YAG3B7I,KAAKuQ,aAAaC,GAAKkD,MAI3B7D,EAAO5P,UAAU+S,uBAAyB,SAAUxS,GAGhD,IAFA,IAAIwL,EAAI,EACJ2H,EAAW3T,KAAKkQ,OAAO1P,EAAQwL,GAAGjK,SAAS/B,KAAKkQ,OAAO1P,IAC9B,IAAtBmT,EAASxP,UAAkB3D,EAAQwL,EAAI,EAAIhM,KAAKkQ,OAAO/L,QAC1D6H,IACA2H,EAAW3T,KAAKkQ,OAAO1P,EAAQwL,GAAGjK,SAAS/B,KAAKkQ,OAAO1P,IAE3D,OAAOmT,GAIX9D,EAAO5P,UAAUwT,sBAAwB,SAAUjT,GAG/C,IAFA,IAAIwL,EAAI,EACJ4H,EAAW5T,KAAKkQ,OAAO1P,GAAOuB,SAAS/B,KAAKkQ,OAAO1P,EAAQwL,IAClC,IAAtB4H,EAASzP,UAAkB3D,EAAQwL,EAAI,GAC1CA,IACA4H,EAAW5T,KAAKkQ,OAAO1P,GAAOuB,SAAS/B,KAAKkQ,OAAO1P,EAAQwL,IAE/D,OAAO4H,GAKX/D,EAAO5P,UAAUuT,cAAgB,SAAUK,EAAIC,GAC3C,IAAIC,EACAC,EAAMH,EAAG1P,SAIb,GAHY,IAAR6P,IACAA,EAAM,GAENF,QAAiC,CACjC,IAAI5I,OAAQ,EAYRA,EAXC,kBAAqB1I,KAAKsB,IAAI+P,EAAGnL,GAAKsL,EAAK,EAAK,MAI3C,kBAAqBxR,KAAKsB,IAAI+P,EAAGhQ,GAAKmQ,EAAK,EAAK,MAGhD,kBAAqBxR,KAAKsB,IAAI+P,EAAGlL,GAAKqL,EAAK,EAAK,MAI9C,WAHA,IAAI,IAAQ,EAAK,EAAK,GAHtB,IAAI,IAAQ,EAAK,EAAK,GAHtB,IAAI,IAAQ,GAAM,EAAK,GAWnCD,EAAU,UAAcF,EAAI3I,QAG5B6I,EAAU,UAAcF,EAAIC,GAC5B,eAAmBC,EAASF,EAAIE,GAGpC,OADAA,EAAQlL,YACDkL,GASXlE,EAAO5P,UAAUuR,mBAAqB,SAAUd,EAAUuD,GAGtD,QAFuB,IAAnBA,IAA6BA,GAAiB,GAE9CjU,KAAKuQ,aAAaC,KAAOE,EAIzB,OAHK1Q,KAAKuQ,aAAaK,kBACnB5Q,KAAKkU,6BAEFlU,KAAKuQ,aAGZvQ,KAAKuQ,aAAaC,GAAKE,EAE3B,IAAI+B,EAAczS,KAAKkP,YAEvB,GAAIwB,GAAY,EACZ,OAAO1Q,KAAKmU,gBAAgB,EAAK,EAAK1B,EAAY,GAAI,EAAGwB,GAExD,GAAIvD,GAAY,EACjB,OAAO1Q,KAAKmU,gBAAgB,EAAK,EAAK1B,EAAYA,EAAYtO,OAAS,GAAIsO,EAAYtO,OAAS,EAAG8P,GAMvG,IAJA,IACIG,EADAhG,EAAgBqE,EAAY,GAE5B4B,EAAgB,EAChBC,EAAe5D,EAAW1Q,KAAKmE,SAC1B6H,EAAI,EAAGA,EAAIyG,EAAYtO,OAAQ6H,IAAK,CACzCoI,EAAe3B,EAAYzG,GAC3B,IAAIsG,EAAW,aAAiBlE,EAAegG,GAE/C,IADAC,GAAiB/B,KACKgC,EAClB,OAAOtU,KAAKmU,gBAAgBzD,EAAU,EAAK0D,EAAcpI,EAAGiI,GAE3D,GAAII,EAAgBC,EAAc,CACnC,IACIC,GADWF,EAAgBC,GACThC,EAClB5C,EAAMtB,EAAcrM,SAASqS,GAC7BlJ,EAAQkJ,EAAavS,IAAI6N,EAAI8E,aAAaD,IAC9C,OAAOvU,KAAKmU,gBAAgBzD,EAAU,EAAI6D,EAAMrJ,EAAOc,EAAI,EAAGiI,GAElE7F,EAAgBgG,EAEpB,OAAOpU,KAAKuQ,cAUhBV,EAAO5P,UAAUkU,gBAAkB,SAAUzD,EAAUC,EAAazF,EAAOuJ,EAAaR,GASpF,OARAjU,KAAKuQ,aAAarF,MAAQA,EAC1BlL,KAAKuQ,aAAaG,SAAWA,EAC7B1Q,KAAKuQ,aAAaI,YAAcA,EAChC3Q,KAAKuQ,aAAaE,wBAA0BgE,EAC5CzU,KAAKuQ,aAAaK,iBAAmBqD,EACjCA,GACAjU,KAAKkU,6BAEFlU,KAAKuQ,cAKhBV,EAAO5P,UAAUiU,2BAA6B,WAC1ClU,KAAKuQ,aAAaM,oBAAsB,gBACxC,IAAI4D,EAAczU,KAAKuQ,aAAaE,wBACpC,GAAIgE,IAAgBzU,KAAKoQ,UAAUjM,OAAS,EAAG,CAC3C,IAAI3D,EAAQiU,EAAc,EACtBC,EAAc1U,KAAKoQ,UAAUqE,GAAaxS,QAC1C0S,EAAa3U,KAAKqQ,SAASoE,GAAaxS,QACxC2S,EAAe5U,KAAKsQ,WAAWmE,GAAaxS,QAC5C4S,EAAY7U,KAAKoQ,UAAU5P,GAAOyB,QAClC6S,EAAW9U,KAAKqQ,SAAS7P,GAAOyB,QAChC8S,EAAa/U,KAAKsQ,WAAW9P,GAAOyB,QACpC+S,EAAW,gCAAsCL,EAAYC,EAAcF,GAC3EO,EAAS,gCAAsCH,EAAUC,EAAYF,GAC5D,WAAiBG,EAAUC,EAAQjV,KAAKuQ,aAAaI,aAC3DuE,iBAAiBlV,KAAKuQ,aAAaM,uBAG3ChB,EAtbgB,GA8bvBsF,EAAwB,WAOxB,SAASA,EAAOC,GACZpV,KAAKgO,QAAU,EACfhO,KAAK+N,QAAUqH,EACfpV,KAAKgO,QAAUhO,KAAKqV,eAAeD,GAyMvC,OA/LAD,EAAOG,sBAAwB,SAAUC,EAAIC,EAAIC,EAAIC,GACjDA,EAAWA,EAAW,EAAIA,EAAW,EAMrC,IALA,IAAIC,EAAM,IAAIzL,MACV0L,EAAW,SAAUrK,EAAGsK,EAAMC,EAAMC,GAEpC,OADW,EAAMxK,IAAM,EAAMA,GAAKsK,EAAO,EAAMtK,GAAK,EAAMA,GAAKuK,EAAOvK,EAAIA,EAAIwK,GAGzE/J,EAAI,EAAGA,GAAK0J,EAAU1J,IAC3B2J,EAAItN,KAAK,IAAI,IAAQuN,EAAS5J,EAAI0J,EAAUH,EAAG1R,EAAG2R,EAAG3R,EAAG4R,EAAG5R,GAAI+R,EAAS5J,EAAI0J,EAAUH,EAAG7M,EAAG8M,EAAG9M,EAAG+M,EAAG/M,GAAIkN,EAAS5J,EAAI0J,EAAUH,EAAG5M,EAAG6M,EAAG7M,EAAG8M,EAAG9M,KAEnJ,OAAO,IAAIwM,EAAOQ,IAWtBR,EAAOa,kBAAoB,SAAUT,EAAIC,EAAIC,EAAIQ,EAAIP,GACjDA,EAAWA,EAAW,EAAIA,EAAW,EAMrC,IALA,IAAIC,EAAM,IAAIzL,MACV0L,EAAW,SAAUrK,EAAGsK,EAAMC,EAAMC,EAAMG,GAE1C,OADW,EAAM3K,IAAM,EAAMA,IAAM,EAAMA,GAAKsK,EAAO,EAAMtK,GAAK,EAAMA,IAAM,EAAMA,GAAKuK,EAAO,EAAMvK,EAAIA,GAAK,EAAMA,GAAKwK,EAAOxK,EAAIA,EAAIA,EAAI2K,GAGtIlK,EAAI,EAAGA,GAAK0J,EAAU1J,IAC3B2J,EAAItN,KAAK,IAAI,IAAQuN,EAAS5J,EAAI0J,EAAUH,EAAG1R,EAAG2R,EAAG3R,EAAG4R,EAAG5R,EAAGoS,EAAGpS,GAAI+R,EAAS5J,EAAI0J,EAAUH,EAAG7M,EAAG8M,EAAG9M,EAAG+M,EAAG/M,EAAGuN,EAAGvN,GAAIkN,EAAS5J,EAAI0J,EAAUH,EAAG5M,EAAG6M,EAAG7M,EAAG8M,EAAG9M,EAAGsN,EAAGtN,KAErK,OAAO,IAAIwM,EAAOQ,IAWtBR,EAAOgB,oBAAsB,SAAUC,EAAIC,EAAIC,EAAIzQ,EAAI6P,GAGnD,IAFA,IAAIa,EAAU,IAAIrM,MACdsM,EAAO,EAAMd,EACR1J,EAAI,EAAGA,GAAK0J,EAAU1J,IAC3BuK,EAAQlO,KAAK,YAAgB+N,EAAIC,EAAIC,EAAIzQ,EAAImG,EAAIwK,IAErD,OAAO,IAAIrB,EAAOoB,IAStBpB,EAAOsB,uBAAyB,SAAUrB,EAAQM,EAAUzH,GACxD,IAAIyI,EAAa,IAAIxM,MACjBsM,EAAO,EAAMd,EACbhR,EAAS,EACb,GAAIuJ,EAAQ,CAER,IADA,IAAI0I,EAAcvB,EAAOjR,OAChB6H,EAAI,EAAGA,EAAI2K,EAAa3K,IAAK,CAClCtH,EAAS,EACT,IAAK,IAAIkS,EAAI,EAAGA,EAAIlB,EAAUkB,IAC1BF,EAAWrO,KAAK,eAAmB+M,EAAOpJ,EAAI2K,GAAcvB,GAAQpJ,EAAI,GAAK2K,GAAcvB,GAAQpJ,EAAI,GAAK2K,GAAcvB,GAAQpJ,EAAI,GAAK2K,GAAcjS,IACzJA,GAAU8R,EAGlBE,EAAWrO,KAAKqO,EAAW,QAE1B,CACD,IAAIG,EAAc,IAAI3M,MACtB2M,EAAYxO,KAAK+M,EAAO,GAAGnT,SAC3BiI,MAAMjK,UAAUoI,KAAKwK,MAAMgE,EAAazB,GACxCyB,EAAYxO,KAAK+M,EAAOA,EAAOjR,OAAS,GAAGlC,SAE3C,IADI+J,EAAI,EACDA,EAAI6K,EAAY1S,OAAS,EAAG6H,IAAK,CACpCtH,EAAS,EACT,IAASkS,EAAI,EAAGA,EAAIlB,EAAUkB,IAC1BF,EAAWrO,KAAK,eAAmBwO,EAAY7K,GAAI6K,EAAY7K,EAAI,GAAI6K,EAAY7K,EAAI,GAAI6K,EAAY7K,EAAI,GAAItH,IAC/GA,GAAU8R,EAGlBxK,IACA0K,EAAWrO,KAAK,eAAmBwO,EAAY7K,GAAI6K,EAAY7K,EAAI,GAAI6K,EAAY7K,EAAI,GAAI6K,EAAY7K,EAAI,GAAItH,IAEnH,OAAO,IAAIyQ,EAAOuB,IAatBvB,EAAO2B,eAAiB,SAAUC,EAAOC,EAAQC,EAAOC,EAAOjJ,EAAQkJ,QACrD,IAAVD,IAAoBA,EAAQ,SACjB,IAAXjJ,IAAqBA,GAAS,QACf,IAAfkJ,IAAyBA,GAAa,GAC1C,IAAIxI,EAAM,IAAIzE,MACVkN,EAAOJ,EAAOjV,SAASgV,GACvBM,EAAOJ,EAAMlV,SAASiV,GACtBM,EAAOP,EAAMhV,SAASkV,GACtBM,EAAQ,UAAcH,EAAMC,GAC5BG,EAAOD,EAAMpT,SACjB,GAAIqT,EAAOhV,KAAKa,IAAI,IAAK,GACrB,OAAO,IAAI8R,EAAOxG,GAEtB,IAAI8I,EAAUL,EAAKM,gBACfC,EAAUN,EAAKK,gBACfE,EAAUN,EAAKI,gBACfG,EAAUN,EAAMG,gBAIhBrK,EAAU,GAHH+J,EAAKjT,SACLkT,EAAKlT,SACLmT,EAAKnT,SAC0BqT,EAItCzQ,GAAM,GAAM4Q,EAHL,QAAYP,EAAME,GAGKO,EAC9B9X,GAAM,GAAM6X,EAHL,QAAYR,EAAMC,GAGKQ,EAC9BjB,GAAM,GAAMa,EAHL,QAAYJ,EAAMC,GAGKO,EAC9BC,EAASf,EAAMxV,MAAMwF,GAAGlF,IAAImV,EAAOzV,MAAMxB,IAAI8B,IAAIoV,EAAM1V,MAAMqV,IAE7DmB,EADYhB,EAAMhV,SAAS+V,GACTjP,YAClBmP,EAAQ,UAAcT,EAAOQ,GAAOlP,YACxC,GAAIsO,EAAY,CAEZ,IADA,IAAIc,EAAS,EAAIzV,KAAK6J,GAAM6K,EACnBgB,EAAQ,EAAGA,GAAS,EAAI1V,KAAK6J,GAAI6L,GAASD,EAC/CtJ,EAAItG,KAAKyP,EAAOjW,IAAIkW,EAAMxW,MAAM8L,EAAS7K,KAAKsM,IAAIoJ,IAAQrW,IAAImW,EAAMzW,MAAM8L,EAAS7K,KAAKuM,IAAImJ,OAEhGvJ,EAAItG,KAAK0O,OAER,CACGkB,EAAQ,EAAIf,EACZgB,EAAQ,EADZ,IAEIhN,EAAQ,WACZ,GACIA,EAAQ4M,EAAOjW,IAAIkW,EAAMxW,MAAM8L,EAAS7K,KAAKsM,IAAIoJ,IAAQrW,IAAImW,EAAMzW,MAAM8L,EAAS7K,KAAKuM,IAAImJ,MAC3FvJ,EAAItG,KAAK6C,GACTgN,GAASD,SACH/M,EAAMiN,kBAAkBlB,EAAO5J,EAAS4K,EAAQ,MAC1DtJ,EAAItG,KAAK4O,GACLhJ,GACAU,EAAItG,KAAK0O,GAGjB,OAAO,IAAI5B,EAAOxG,IAKtBwG,EAAOlV,UAAUiP,UAAY,WACzB,OAAOlP,KAAK+N,SAKhBoH,EAAOlV,UAAUkE,OAAS,WACtB,OAAOnE,KAAKgO,SAShBmH,EAAOlV,UAAUmY,SAAW,SAAUC,GAIlC,IAHA,IAAIpJ,EAAYjP,KAAK+N,QAAQ/N,KAAK+N,QAAQ5J,OAAS,GAC/CmU,EAAkBtY,KAAK+N,QAAQwE,QAC/BE,EAAc4F,EAAMnJ,YACflD,EAAI,EAAGA,EAAIyG,EAAYtO,OAAQ6H,IACpCsM,EAAgBjQ,KAAKoK,EAAYzG,GAAGjK,SAAS0Q,EAAY,IAAI5Q,IAAIoN,IAGrE,OADqB,IAAIkG,EAAOmD,IAGpCnD,EAAOlV,UAAUoV,eAAiB,SAAUvF,GAExC,IADA,IAAIiD,EAAI,EACC/G,EAAI,EAAGA,EAAI8D,EAAK3L,OAAQ6H,IAC7B+G,GAAKjD,EAAK9D,GAAGjK,SAAS+N,EAAK9D,EAAI,IAAI7H,SAEvC,OAAO4O,GAEJoC,EAnNgB,I,gDC5tBvBoD,EAAuB,WAQvB,SAASA,EAAMxR,EAAGhH,EAAG6W,EAAGhO,GACpB5I,KAAKyI,OAAS,IAAI,IAAQ1B,EAAGhH,EAAG6W,GAChC5W,KAAK4I,EAAIA,EA2Kb,OAtKA2P,EAAMtY,UAAUc,QAAU,WACtB,MAAO,CAACf,KAAKyI,OAAO5E,EAAG7D,KAAKyI,OAAOC,EAAG1I,KAAKyI,OAAOE,EAAG3I,KAAK4I,IAM9D2P,EAAMtY,UAAUgC,MAAQ,WACpB,OAAO,IAAIsW,EAAMvY,KAAKyI,OAAO5E,EAAG7D,KAAKyI,OAAOC,EAAG1I,KAAKyI,OAAOE,EAAG3I,KAAK4I,IAKvE2P,EAAMtY,UAAUE,aAAe,WAC3B,MAAO,SAKXoY,EAAMtY,UAAUG,YAAc,WAC1B,IAAIC,EAAOL,KAAKyI,OAAOrI,cAEvB,OADAC,EAAe,IAAPA,GAAwB,EAATL,KAAK4I,IAOhC2P,EAAMtY,UAAU4I,UAAY,WACxB,IAAI2P,EAAOhW,KAAKuF,KAAK/H,KAAKyI,OAAO5E,EAAI7D,KAAKyI,OAAO5E,EAAI7D,KAAKyI,OAAOC,EAAI1I,KAAKyI,OAAOC,EAAI1I,KAAKyI,OAAOE,EAAI3I,KAAKyI,OAAOE,GAC7G8P,EAAY,EAQhB,OAPa,IAATD,IACAC,EAAY,EAAMD,GAEtBxY,KAAKyI,OAAO5E,GAAK4U,EACjBzY,KAAKyI,OAAOC,GAAK+P,EACjBzY,KAAKyI,OAAOE,GAAK8P,EACjBzY,KAAK4I,GAAK6P,EACHzY,MAOXuY,EAAMtY,UAAUkI,UAAY,SAAUuQ,GAClC,IAAIC,EAAiBJ,EAAMK,WAC3BF,EAAeG,YAAYF,GAC3B,IAAI5U,EAAI4U,EAAe5U,EACnBF,EAAI7D,KAAKyI,OAAO5E,EAChB6E,EAAI1I,KAAKyI,OAAOC,EAChBC,EAAI3I,KAAKyI,OAAOE,EAChBC,EAAI5I,KAAK4I,EAKb,OAAO,IAAI2P,EAJG1U,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GAAK6E,EAAI7E,EAAE,GACvCF,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GAAK6E,EAAI7E,EAAE,GACvCF,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,IAAM6E,EAAI7E,EAAE,IACzCF,EAAIE,EAAE,IAAM2E,EAAI3E,EAAE,IAAM4E,EAAI5E,EAAE,IAAM6E,EAAI7E,EAAE,MAQ3DwU,EAAMtY,UAAU6Y,cAAgB,SAAU5N,GACtC,OAAOlL,KAAKyI,OAAO5E,EAAIqH,EAAMrH,EAAI7D,KAAKyI,OAAOC,EAAIwC,EAAMxC,EAAI1I,KAAKyI,OAAOE,EAAIuC,EAAMvC,EAAI3I,KAAK4I,GAS9F2P,EAAMtY,UAAU8Y,eAAiB,SAAUC,EAAQC,EAAQC,GACvD,IAUIC,EAVA3N,EAAKyN,EAAOpV,EAAImV,EAAOnV,EACvB4H,EAAKwN,EAAOvQ,EAAIsQ,EAAOtQ,EACvB0Q,EAAKH,EAAOtQ,EAAIqQ,EAAOrQ,EACvB+C,EAAKwN,EAAOrV,EAAImV,EAAOnV,EACvB8H,EAAKuN,EAAOxQ,EAAIsQ,EAAOtQ,EACvB2Q,EAAKH,EAAOvQ,EAAIqQ,EAAOrQ,EACvB2Q,EAAK7N,EAAK4N,EAAKD,EAAKzN,EACpB4N,EAAKH,EAAK1N,EAAKF,EAAK6N,EACpBG,EAAKhO,EAAKG,EAAKF,EAAKC,EACpB+N,EAAOjX,KAAKuF,KAAKuR,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,GAY9C,OATIL,EADS,IAATM,EACU,EAAMA,EAGN,EAEdzZ,KAAKyI,OAAO5E,EAAIyV,EAAKH,EACrBnZ,KAAKyI,OAAOC,EAAI6Q,EAAKJ,EACrBnZ,KAAKyI,OAAOE,EAAI6Q,EAAKL,EACrBnZ,KAAK4I,IAAM5I,KAAKyI,OAAO5E,EAAImV,EAAOnV,EAAI7D,KAAKyI,OAAOC,EAAIsQ,EAAOtQ,EAAI1I,KAAKyI,OAAOE,EAAIqQ,EAAOrQ,GACjF3I,MAWXuY,EAAMtY,UAAUyZ,gBAAkB,SAAUC,EAAWC,GAEnD,OADU,QAAY5Z,KAAKyI,OAAQkR,IACrBC,GAOlBrB,EAAMtY,UAAU4Z,iBAAmB,SAAU3O,GACzC,OAAO,QAAYA,EAAOlL,KAAKyI,QAAUzI,KAAK4I,GAQlD2P,EAAMjU,UAAY,SAAU/D,GACxB,OAAO,IAAIgY,EAAMhY,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,KASzDgY,EAAMuB,WAAa,SAAUd,EAAQC,EAAQC,GACzC,IAAI9X,EAAS,IAAImX,EAAM,EAAK,EAAK,EAAK,GAEtC,OADAnX,EAAO2X,eAAeC,EAAQC,EAAQC,GAC/B9X,GASXmX,EAAMwB,sBAAwB,SAAU/O,EAAQvC,GAC5C,IAAIrH,EAAS,IAAImX,EAAM,EAAK,EAAK,EAAK,GAItC,OAHA9P,EAAOI,YACPzH,EAAOqH,OAASA,EAChBrH,EAAOwH,IAAMH,EAAO5E,EAAImH,EAAOnH,EAAI4E,EAAOC,EAAIsC,EAAOtC,EAAID,EAAOE,EAAIqC,EAAOrC,GACpEvH,GASXmX,EAAMyB,2CAA6C,SAAUhP,EAAQvC,EAAQyC,GACzE,IAAItC,IAAMH,EAAO5E,EAAImH,EAAOnH,EAAI4E,EAAOC,EAAIsC,EAAOtC,EAAID,EAAOE,EAAIqC,EAAOrC,GACxE,OAAO,QAAYuC,EAAOzC,GAAUG,GAExC2P,EAAMK,WAAa,gBACZL,EArLe,I,iCCD1B,IAAI0B,EAAwB,WACxB,SAASA,KA2VT,OAlVAA,EAAOC,cAAgB,SAAUnT,EAAGhH,EAAG6Z,GAEnC,YADgB,IAAZA,IAAsBA,EAAU,aAC7BpX,KAAKsB,IAAIiD,EAAIhH,IAAM6Z,GAO9BK,EAAOE,MAAQ,SAAUnO,GACrB,IAAIoO,EAAMpO,EAAE9L,SAAS,IACrB,OAAI8L,GAAK,IACG,IAAMoO,GAAKC,cAEhBD,EAAIC,eAOfJ,EAAOK,KAAO,SAAU3W,GAEpB,OAAc,KADdA,GAASA,IACU4W,MAAM5W,GACdA,EAEJA,EAAQ,EAAI,GAAK,GAW5BsW,EAAOO,MAAQ,SAAU7W,EAAOhC,EAAKC,GAGjC,YAFY,IAARD,IAAkBA,EAAM,QAChB,IAARC,IAAkBA,EAAM,GACrBY,KAAKb,IAAIC,EAAKY,KAAKZ,IAAID,EAAKgC,KAOvCsW,EAAOQ,KAAO,SAAU9W,GACpB,OAAOnB,KAAKkY,IAAI/W,GAASnB,KAAKmY,OAOlCV,EAAOW,MAAQ,SAAUjX,GACrB,GAAInB,KAAKqY,KACL,OAAOrY,KAAKgI,MAAMhI,KAAKqY,KAAKlX,IAEhC,GAAIA,EAAQ,EACR,OAAO+P,IAEN,GAAc,IAAV/P,EACL,OAAQmX,IAEZ,IAAIjQ,EAAI,EACR,GAAIlH,EAAQ,EAAG,CACX,KAAOA,EAAQ,GACXkH,IACAlH,GAAgB,EAEpBkH,GAAKA,OAEJ,GAAIlH,EAAQ,EACb,KAAOA,EAAQ,GACXkH,IACAlH,EAAQnB,KAAKgI,MAAM7G,EAAQ,GAGnC,OAAOkH,GAaXoP,EAAOc,OAAS,SAAUpX,EAAOQ,GAC7B,OAAOR,EAAQnB,KAAKgI,MAAM7G,EAAQQ,GAAUA,GAShD8V,EAAOe,UAAY,SAAUrX,EAAOhC,EAAKC,GACrC,OAAQ+B,EAAQhC,IAAQC,EAAMD,IASlCsY,EAAOgB,YAAc,SAAUC,EAAYvZ,EAAKC,GAC5C,OAAOsZ,GAActZ,EAAMD,GAAOA,GAQtCsY,EAAOkB,WAAa,SAAUC,EAASnJ,GACnC,IAAIoJ,EAAMpB,EAAOc,OAAO9I,EAASmJ,EAAS,KAI1C,OAHIC,EAAM,MACNA,GAAO,KAEJA,GAQXpB,EAAOqB,SAAW,SAAUC,EAAIpX,GAC5B,IAAIoH,EAAI0O,EAAOc,OAAOQ,EAAa,EAATpX,GAC1B,OAAOA,EAAS3B,KAAKsB,IAAIyH,EAAIpH,IAYjC8V,EAAOuB,WAAa,SAAUC,EAAMC,EAAIH,GACpC,IAAIhQ,EAAI0O,EAAOO,MAAMe,GAErB,OAAOG,GADPnQ,GAAK,EAAMA,EAAIA,EAAIA,EAAI,EAAMA,EAAIA,GACjBkQ,GAAQ,EAAMlQ,IAYlC0O,EAAO0B,YAAc,SAAUP,EAASnJ,EAAQ2J,GAQ5C,OANIpZ,KAAKsB,IAAImO,EAASmJ,IAAYQ,EACrB3J,EAGAmJ,EAAUnB,EAAOK,KAAKrI,EAASmJ,GAAWQ,GAc3D3B,EAAO4B,iBAAmB,SAAUT,EAASnJ,EAAQ2J,GACjD,IAAIP,EAAMpB,EAAOkB,WAAWC,EAASnJ,GACjC7Q,EAAS,EAQb,OAPKwa,EAAWP,GAAOA,EAAMO,EACzBxa,EAAS6Q,GAGTA,EAASmJ,EAAUC,EACnBja,EAAS6Y,EAAO0B,YAAYP,EAASnJ,EAAQ2J,IAE1Cxa,GASX6Y,EAAO1V,KAAO,SAAUC,EAAOC,EAAKC,GAChC,OAAOF,GAASC,EAAMD,GAASE,GAUnCuV,EAAO6B,UAAY,SAAUtX,EAAOC,EAAKC,GACrC,IAAI2W,EAAMpB,EAAOc,OAAOtW,EAAMD,EAAO,KAIrC,OAHI6W,EAAM,MACNA,GAAO,KAEJ7W,EAAQ6W,EAAMpB,EAAOO,MAAM9V,IAStCuV,EAAO8B,YAAc,SAAUhV,EAAGhH,EAAG4D,GAQjC,OANIoD,GAAKhH,EACIka,EAAOO,OAAO7W,EAAQoD,IAAMhH,EAAIgH,IAGhC,GAcjBkT,EAAOnV,QAAU,SAAUC,EAAQC,EAAUC,EAAQC,EAAUR,GAC3D,IAAIS,EAAUT,EAASA,EACnBU,EAAQV,EAASS,EAKrB,OAAOJ,GAJK,EAAMK,EAAQ,EAAMD,EAAU,GAIlBF,IAHX,EAAMG,EAAQ,EAAMD,GAGQH,GAF7BI,EAAQ,EAAMD,EAAUT,GAEwBQ,GADhDE,EAAQD,IAYxB8U,EAAOxU,qBAAuB,SAAUV,EAAQC,EAAUC,EAAQC,EAAUQ,GACxE,IAAIG,EAAKH,EAAOA,EAChB,OAAqB,GAAbG,EAAKH,GAAYX,GAAU,EAAIc,EAAK,EAAIH,EAAO,GAAKV,EAA0B,IAAba,EAAKH,GAAYT,GAAU,EAAIY,EAAK,EAAIH,GAAQR,GAQ7H+U,EAAO+B,YAAc,SAAUra,EAAKC,GAChC,OAAID,IAAQC,EACDD,EAEJa,KAAKsE,UAAYlF,EAAMD,GAAOA,GAYzCsY,EAAOgC,eAAiB,SAAUC,EAAQva,EAAKC,GAC3C,OAAQsa,EAASva,IAAQC,EAAMD,IAWnCsY,EAAOkC,eAAiB,SAAUC,EAASza,EAAKC,GAC5C,OAAQA,EAAMD,GAAOya,EAAUza,GAOnCsY,EAAOoC,iBAAmB,SAAUxO,GAQhC,OADAA,GAASoM,EAAOqC,MAAQ9Z,KAAKgI,OAAOqD,EAAQrL,KAAK6J,IAAM4N,EAAOqC,QASlErC,EAAOsC,IAAM,SAAUxV,EAAGhH,GACtB,IAAIF,EAAIkH,EAAIhH,EACZ,OAAU,IAANF,EACOE,EAEJka,EAAOsC,IAAIxc,EAAGF,IAKzBoa,EAAOqC,MAAkB,EAAV9Z,KAAK6J,GACb4N,EA5VgB,I,iCCA3B,IAAIuC,EAAsB,WAMtB,SAASA,EAAKC,EAAOC,GACjB1c,KAAKyc,MAAQA,EACbzc,KAAK0c,OAASA,EA+HlB,OAzHAF,EAAKvc,UAAUC,SAAW,WACtB,MAAO,OAAOyc,OAAO3c,KAAKyc,MAAO,SAASE,OAAO3c,KAAK0c,OAAQ,MAMlEF,EAAKvc,UAAUE,aAAe,WAC1B,MAAO,QAMXqc,EAAKvc,UAAUG,YAAc,WACzB,IAAIC,EAAoB,EAAbL,KAAKyc,MAEhB,OADApc,EAAe,IAAPA,GAA6B,EAAdL,KAAK0c,SAOhCF,EAAKvc,UAAUiC,SAAW,SAAU0a,GAChC5c,KAAKyc,MAAQG,EAAIH,MACjBzc,KAAK0c,OAASE,EAAIF,QAQtBF,EAAKvc,UAAUmC,eAAiB,SAAUqa,EAAOC,GAG7C,OAFA1c,KAAKyc,MAAQA,EACbzc,KAAK0c,OAASA,EACP1c,MAQXwc,EAAKvc,UAAUoC,IAAM,SAAUoa,EAAOC,GAClC,OAAO1c,KAAKoC,eAAeqa,EAAOC,IAQtCF,EAAKvc,UAAU4c,iBAAmB,SAAUC,EAAG7Z,GAC3C,OAAO,IAAIuZ,EAAKxc,KAAKyc,MAAQK,EAAG9c,KAAK0c,OAASzZ,IAMlDuZ,EAAKvc,UAAUgC,MAAQ,WACnB,OAAO,IAAIua,EAAKxc,KAAKyc,MAAOzc,KAAK0c,SAOrCF,EAAKvc,UAAUoB,OAAS,SAAUqJ,GAC9B,QAAKA,IAGE1K,KAAKyc,QAAU/R,EAAM+R,OAASzc,KAAK0c,SAAWhS,EAAMgS,SAE/DzW,OAAOC,eAAesW,EAAKvc,UAAW,UAAW,CAI7CkG,IAAK,WACD,OAAOnG,KAAKyc,MAAQzc,KAAK0c,QAE7BrW,YAAY,EACZC,cAAc,IAMlBkW,EAAKrR,KAAO,WACR,OAAO,IAAIqR,EAAK,EAAK,IAOzBA,EAAKvc,UAAU4B,IAAM,SAAUkb,GAE3B,OADQ,IAAIP,EAAKxc,KAAKyc,MAAQM,EAAUN,MAAOzc,KAAK0c,OAASK,EAAUL,SAQ3EF,EAAKvc,UAAU8B,SAAW,SAAUgb,GAEhC,OADQ,IAAIP,EAAKxc,KAAKyc,MAAQM,EAAUN,MAAOzc,KAAK0c,OAASK,EAAUL,SAU3EF,EAAKjY,KAAO,SAAUC,EAAOC,EAAKC,GAG9B,OAAO,IAAI8X,EAFHhY,EAAMiY,OAAShY,EAAIgY,MAAQjY,EAAMiY,OAAS/X,EAC1CF,EAAMkY,QAAUjY,EAAIiY,OAASlY,EAAMkY,QAAUhY,IAGlD8X,EAvIc,I,oJCKrBQ,EAAgB,SAAUrZ,GAC1B,OAAOS,SAAST,EAAMzD,WAAW+c,QAAQ,MAAO,MAKhDC,EAAyB,WAMzB,SAASA,EAETrZ,EAEA6E,QACc,IAAN7E,IAAgBA,EAAI,QACd,IAAN6E,IAAgBA,EAAI,GACxB1I,KAAK6D,EAAIA,EACT7D,KAAK0I,EAAIA,EA2oBb,OAroBAwU,EAAQjd,UAAUC,SAAW,WACzB,MAAO,OAAOyc,OAAO3c,KAAK6D,EAAG,QAAQ8Y,OAAO3c,KAAK0I,EAAG,MAMxDwU,EAAQjd,UAAUE,aAAe,WAC7B,MAAO,WAMX+c,EAAQjd,UAAUG,YAAc,WAC5B,IAEIC,EAFI2c,EAAchd,KAAK6D,GAI3B,OADAxD,EAAe,IAAPA,EAFA2c,EAAchd,KAAK0I,IAY/BwU,EAAQjd,UAAUK,QAAU,SAAUC,EAAOC,GAIzC,YAHc,IAAVA,IAAoBA,EAAQ,GAChCD,EAAMC,GAASR,KAAK6D,EACpBtD,EAAMC,EAAQ,GAAKR,KAAK0I,EACjB1I,MAQXkd,EAAQjd,UAAUQ,UAAY,SAAUF,EAAOC,GAG3C,YAFc,IAAVA,IAAoBA,EAAQ,GAChC0c,EAAQvc,eAAeJ,EAAOC,EAAOR,MAC9BA,MAMXkd,EAAQjd,UAAUc,QAAU,WACxB,IAAIK,EAAS,IAAI8I,MAEjB,OADAlK,KAAKM,QAAQc,EAAQ,GACdA,GAOX8b,EAAQjd,UAAUiC,SAAW,SAAUC,GAGnC,OAFAnC,KAAK6D,EAAI1B,EAAO0B,EAChB7D,KAAK0I,EAAIvG,EAAOuG,EACT1I,MAQXkd,EAAQjd,UAAUmC,eAAiB,SAAUyB,EAAG6E,GAG5C,OAFA1I,KAAK6D,EAAIA,EACT7D,KAAK0I,EAAIA,EACF1I,MAQXkd,EAAQjd,UAAUoC,IAAM,SAAUwB,EAAG6E,GACjC,OAAO1I,KAAKoC,eAAeyB,EAAG6E,IAOlCwU,EAAQjd,UAAU4B,IAAM,SAAUsb,GAC9B,OAAO,IAAID,EAAQld,KAAK6D,EAAIsZ,EAAYtZ,EAAG7D,KAAK0I,EAAIyU,EAAYzU,IAQpEwU,EAAQjd,UAAU6B,SAAW,SAAUqb,EAAa/b,GAGhD,OAFAA,EAAOyC,EAAI7D,KAAK6D,EAAIsZ,EAAYtZ,EAChCzC,EAAOsH,EAAI1I,KAAK0I,EAAIyU,EAAYzU,EACzB1I,MAOXkd,EAAQjd,UAAU+G,WAAa,SAAUmW,GAGrC,OAFAnd,KAAK6D,GAAKsZ,EAAYtZ,EACtB7D,KAAK0I,GAAKyU,EAAYzU,EACf1I,MAOXkd,EAAQjd,UAAUmd,WAAa,SAAUD,GACrC,OAAO,IAAID,EAAQld,KAAK6D,EAAIsZ,EAAYtZ,EAAG7D,KAAK0I,EAAIyU,EAAYzU,IAOpEwU,EAAQjd,UAAU8B,SAAW,SAAUob,GACnC,OAAO,IAAID,EAAQld,KAAK6D,EAAIsZ,EAAYtZ,EAAG7D,KAAK0I,EAAIyU,EAAYzU,IAQpEwU,EAAQjd,UAAU+B,cAAgB,SAAUmb,EAAa/b,GAGrD,OAFAA,EAAOyC,EAAI7D,KAAK6D,EAAIsZ,EAAYtZ,EAChCzC,EAAOsH,EAAI1I,KAAK0I,EAAIyU,EAAYzU,EACzB1I,MAOXkd,EAAQjd,UAAUod,gBAAkB,SAAUF,GAG1C,OAFAnd,KAAK6D,GAAKsZ,EAAYtZ,EACtB7D,KAAK0I,GAAKyU,EAAYzU,EACf1I,MAOXkd,EAAQjd,UAAUqd,gBAAkB,SAAUH,GAG1C,OAFAnd,KAAK6D,GAAKsZ,EAAYtZ,EACtB7D,KAAK0I,GAAKyU,EAAYzU,EACf1I,MAOXkd,EAAQjd,UAAUgB,SAAW,SAAUkc,GACnC,OAAO,IAAID,EAAQld,KAAK6D,EAAIsZ,EAAYtZ,EAAG7D,KAAK0I,EAAIyU,EAAYzU,IAQpEwU,EAAQjd,UAAUkB,cAAgB,SAAUgc,EAAa/b,GAGrD,OAFAA,EAAOyC,EAAI7D,KAAK6D,EAAIsZ,EAAYtZ,EAChCzC,EAAOsH,EAAI1I,KAAK0I,EAAIyU,EAAYzU,EACzB1I,MAQXkd,EAAQjd,UAAU4c,iBAAmB,SAAUhZ,EAAG6E,GAC9C,OAAO,IAAIwU,EAAQld,KAAK6D,EAAIA,EAAG7D,KAAK0I,EAAIA,IAO5CwU,EAAQjd,UAAUsd,OAAS,SAAUJ,GACjC,OAAO,IAAID,EAAQld,KAAK6D,EAAIsZ,EAAYtZ,EAAG7D,KAAK0I,EAAIyU,EAAYzU,IAQpEwU,EAAQjd,UAAUud,YAAc,SAAUL,EAAa/b,GAGnD,OAFAA,EAAOyC,EAAI7D,KAAK6D,EAAIsZ,EAAYtZ,EAChCzC,EAAOsH,EAAI1I,KAAK0I,EAAIyU,EAAYzU,EACzB1I,MAOXkd,EAAQjd,UAAUwd,cAAgB,SAAUN,GACxC,OAAOnd,KAAKwd,YAAYL,EAAand,OAMzCkd,EAAQjd,UAAUyd,OAAS,WACvB,OAAO,IAAIR,GAASld,KAAK6D,GAAI7D,KAAK0I,IAMtCwU,EAAQjd,UAAU0d,cAAgB,WAG9B,OAFA3d,KAAK6D,IAAM,EACX7D,KAAK0I,IAAM,EACJ1I,MAOXkd,EAAQjd,UAAU2d,YAAc,SAAUxc,GACtC,OAAOA,EAAOgB,gBAAyB,EAAVpC,KAAK6D,GAAkB,EAAV7D,KAAK0I,IAOnDwU,EAAQjd,UAAUuU,aAAe,SAAUjT,GAGvC,OAFAvB,KAAK6D,GAAKtC,EACVvB,KAAK0I,GAAKnH,EACHvB,MAOXkd,EAAQjd,UAAUsB,MAAQ,SAAUA,GAChC,IAAIH,EAAS,IAAI8b,EAAQ,EAAG,GAE5B,OADAld,KAAKwB,WAAWD,EAAOH,GAChBA,GAQX8b,EAAQjd,UAAUuB,WAAa,SAAUD,EAAOH,GAG5C,OAFAA,EAAOyC,EAAI7D,KAAK6D,EAAItC,EACpBH,EAAOsH,EAAI1I,KAAK0I,EAAInH,EACbvB,MAQXkd,EAAQjd,UAAUwB,iBAAmB,SAAUF,EAAOH,GAGlD,OAFAA,EAAOyC,GAAK7D,KAAK6D,EAAItC,EACrBH,EAAOsH,GAAK1I,KAAK0I,EAAInH,EACdvB,MAOXkd,EAAQjd,UAAUoB,OAAS,SAAU8b,GACjC,OAAOA,GAAend,KAAK6D,IAAMsZ,EAAYtZ,GAAK7D,KAAK0I,IAAMyU,EAAYzU,GAQ7EwU,EAAQjd,UAAUkY,kBAAoB,SAAUgF,EAAavD,GAEzD,YADgB,IAAZA,IAAsBA,EAAU,MAC7BuD,GAAe,kBAAqBnd,KAAK6D,EAAGsZ,EAAYtZ,EAAG+V,IAAY,kBAAqB5Z,KAAK0I,EAAGyU,EAAYzU,EAAGkR,IAO9HsD,EAAQjd,UAAUuK,MAAQ,WACtB,OAAO,IAAI0S,EAAQ1a,KAAKgI,MAAMxK,KAAK6D,GAAIrB,KAAKgI,MAAMxK,KAAK0I,KAO3DwU,EAAQjd,UAAU4d,MAAQ,WACtB,OAAO,IAAIX,EAAQld,KAAK6D,EAAIrB,KAAKgI,MAAMxK,KAAK6D,GAAI7D,KAAK0I,EAAIlG,KAAKgI,MAAMxK,KAAK0I,KAQ7EwU,EAAQjd,UAAU6d,YAAc,SAAUjQ,EAAOzM,GAC7C,IAAI0N,EAAMtM,KAAKsM,IAAIjB,GACfkB,EAAMvM,KAAKuM,IAAIlB,GAGnB,OAFAzM,EAAOyC,EAAIiL,EAAM9O,KAAK6D,EAAIkL,EAAM/O,KAAK0I,EACrCtH,EAAOsH,EAAIqG,EAAM/O,KAAK6D,EAAIiL,EAAM9O,KAAK0I,EAC9B1I,MAOXkd,EAAQjd,UAAUkE,OAAS,WACvB,OAAO3B,KAAKuF,KAAK/H,KAAK6D,EAAI7D,KAAK6D,EAAI7D,KAAK0I,EAAI1I,KAAK0I,IAMrDwU,EAAQjd,UAAUyX,cAAgB,WAC9B,OAAO1X,KAAK6D,EAAI7D,KAAK6D,EAAI7D,KAAK0I,EAAI1I,KAAK0I,GAO3CwU,EAAQjd,UAAU4I,UAAY,WAE1B,OADAqU,EAAQa,eAAe/d,KAAMA,MACtBA,MAMXkd,EAAQjd,UAAUgC,MAAQ,WACtB,OAAO,IAAIib,EAAQld,KAAK6D,EAAG7D,KAAK0I,IAOpCwU,EAAQ/R,KAAO,WACX,OAAO,IAAI+R,EAAQ,EAAG,IAM1BA,EAAQc,IAAM,WACV,OAAO,IAAId,EAAQ,EAAG,IAQ1BA,EAAQ5Y,UAAY,SAAU/D,EAAOG,GAEjC,YADe,IAAXA,IAAqBA,EAAS,GAC3B,IAAIwc,EAAQ3c,EAAMG,GAASH,EAAMG,EAAS,KAQrDwc,EAAQvc,eAAiB,SAAUJ,EAAOG,EAAQU,GAC9CA,EAAOyC,EAAItD,EAAMG,GACjBU,EAAOsH,EAAInI,EAAMG,EAAS,IAW9Bwc,EAAQe,WAAa,SAAUlZ,EAAQE,EAAQiZ,EAAQC,EAAQzZ,GAC3D,IAAIS,EAAUT,EAASA,EACnBU,EAAQV,EAASS,EAWrB,OAAO,IAAI+X,EAVH,IACH,EAAMjY,EAAOpB,IACRkB,EAAOlB,EAAIqa,EAAOra,GAAKa,GACxB,EAAMK,EAAOlB,EAAI,EAAMoB,EAAOpB,EAAI,EAAMqa,EAAOra,EAAIsa,EAAOta,GAAKsB,IAC9DJ,EAAOlB,EAAI,EAAMoB,EAAOpB,EAAI,EAAMqa,EAAOra,EAAIsa,EAAOta,GAAKuB,GAC3D,IACH,EAAMH,EAAOyD,IACR3D,EAAO2D,EAAIwV,EAAOxV,GAAKhE,GACxB,EAAMK,EAAO2D,EAAI,EAAMzD,EAAOyD,EAAI,EAAMwV,EAAOxV,EAAIyV,EAAOzV,GAAKvD,IAC9DJ,EAAO2D,EAAI,EAAMzD,EAAOyD,EAAI,EAAMwV,EAAOxV,EAAIyV,EAAOzV,GAAKtD,KAYvE8X,EAAQ1C,MAAQ,SAAU7W,EAAOhC,EAAKC,GAClC,IAAIiC,EAAIF,EAAME,EAEdA,GADAA,EAAIA,EAAIjC,EAAIiC,EAAIjC,EAAIiC,EAAIA,GAChBlC,EAAIkC,EAAIlC,EAAIkC,EAAIA,EACxB,IAAI6E,EAAI/E,EAAM+E,EAGd,OAAO,IAAIwU,EAAQrZ,EADnB6E,GADAA,EAAIA,EAAI9G,EAAI8G,EAAI9G,EAAI8G,EAAIA,GAChB/G,EAAI+G,EAAI/G,EAAI+G,EAAIA,IAY5BwU,EAAQpY,QAAU,SAAUC,EAAQC,EAAUC,EAAQC,EAAUR,GAC5D,IAAIS,EAAUT,EAASA,EACnBU,EAAQV,EAASS,EACjBE,EAAQ,EAAMD,EAAQ,EAAMD,EAAU,EACtCG,GAAS,EAAMF,EAAQ,EAAMD,EAC7BI,EAAQH,EAAQ,EAAMD,EAAUT,EAChCc,EAAQJ,EAAQD,EAGpB,OAAO,IAAI+X,EAFHnY,EAAOlB,EAAIwB,EAAQJ,EAAOpB,EAAIyB,EAAQN,EAASnB,EAAI0B,EAAQL,EAASrB,EAAI2B,EACxET,EAAO2D,EAAIrD,EAAQJ,EAAOyD,EAAIpD,EAAQN,EAAS0D,EAAInD,EAAQL,EAASwD,EAAIlD,IAYpF0X,EAAQzX,qBAAuB,SAAUV,EAAQC,EAAUC,EAAQC,EAAUQ,GACzE,IAAItE,EAAS8b,EAAQ/R,OAErB,OADAnL,KAAK4F,0BAA0Bb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GAClEA,GAWX8b,EAAQtX,0BAA4B,SAAUb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GACpF,IAAIyE,EAAKH,EAAOA,EAChBtE,EAAOyC,EAAkB,GAAbgC,EAAKH,GAAYX,EAAOlB,GAAK,EAAIgC,EAAK,EAAIH,EAAO,GAAKV,EAASnB,EAAmB,IAAbgC,EAAKH,GAAYT,EAAOpB,GAAK,EAAIgC,EAAK,EAAIH,GAAQR,EAASrB,EAC5IzC,EAAOsH,EAAkB,GAAb7C,EAAKH,GAAYX,EAAO2D,GAAK,EAAI7C,EAAK,EAAIH,EAAO,GAAKV,EAAS0D,EAAmB,IAAb7C,EAAKH,GAAYT,EAAOyD,GAAK,EAAI7C,EAAK,EAAIH,GAAQR,EAASwD,GAShJwU,EAAQ3Y,KAAO,SAAUC,EAAOC,EAAKC,GAGjC,OAAO,IAAIwY,EAFH1Y,EAAMX,GAAKY,EAAIZ,EAAIW,EAAMX,GAAKa,EAC9BF,EAAMkE,GAAKjE,EAAIiE,EAAIlE,EAAMkE,GAAKhE,IAS1CwY,EAAQkB,IAAM,SAAUxZ,EAAMC,GAC1B,OAAOD,EAAKf,EAAIgB,EAAMhB,EAAIe,EAAK8D,EAAI7D,EAAM6D,GAO7CwU,EAAQlC,UAAY,SAAUqD,GAC1B,IAAIC,EAAYpB,EAAQ/R,OAExB,OADAnL,KAAK+d,eAAeM,EAAQC,GACrBA,GAOXpB,EAAQa,eAAiB,SAAUM,EAAQjd,GACvC,IAAImd,EAAMF,EAAOla,SACL,IAARoa,IAGJnd,EAAOyC,EAAIwa,EAAOxa,EAAI0a,EACtBnd,EAAOsH,EAAI2V,EAAO3V,EAAI6V,IAQ1BrB,EAAQsB,SAAW,SAAU5Z,EAAMC,GAG/B,OAAO,IAAIqY,EAFHtY,EAAKf,EAAIgB,EAAMhB,EAAIe,EAAKf,EAAIgB,EAAMhB,EAClCe,EAAK8D,EAAI7D,EAAM6D,EAAI9D,EAAK8D,EAAI7D,EAAM6D,IAS9CwU,EAAQuB,SAAW,SAAU7Z,EAAMC,GAG/B,OAAO,IAAIqY,EAFHtY,EAAKf,EAAIgB,EAAMhB,EAAIe,EAAKf,EAAIgB,EAAMhB,EAClCe,EAAK8D,EAAI7D,EAAM6D,EAAI9D,EAAK8D,EAAI7D,EAAM6D,IAS9CwU,EAAQwB,UAAY,SAAUL,EAAQ3F,GAClC,IAAI7Y,EAAIqd,EAAQ/R,OAEhB,OADA+R,EAAQyB,eAAeN,EAAQ3F,EAAgB7Y,GACxCA,GAQXqd,EAAQyB,eAAiB,SAAUN,EAAQ3F,EAAgBtX,GACvD,IAAI2C,EAAI2U,EAAe3U,EACnBF,EAAIwa,EAAOxa,EAAIE,EAAE,GAAKsa,EAAO3V,EAAI3E,EAAE,GAAKA,EAAE,IAC1C2E,EAAI2V,EAAOxa,EAAIE,EAAE,GAAKsa,EAAO3V,EAAI3E,EAAE,GAAKA,EAAE,IAC9C3C,EAAOyC,EAAIA,EACXzC,EAAOsH,EAAIA,GAUfwU,EAAQ0B,gBAAkB,SAAU9N,EAAG+N,EAAIzI,EAAIE,GAC3C,IAAIvP,EAAI,KAAYqP,EAAG1N,EAAI4N,EAAGzS,EAAIgb,EAAGnW,IAAM0N,EAAGvS,EAAIyS,EAAGzS,GAAKgb,EAAGhb,GAAKuS,EAAG1N,EAAI4N,EAAG5N,GAAK0N,EAAGvS,EAAIyS,EAAG5N,GACvFoW,EAAO/X,EAAI,GAAK,EAAI,EACpB7D,GAAK2b,EAAGnW,EAAI4N,EAAGzS,EAAIgb,EAAGhb,EAAIyS,EAAG5N,GAAK4N,EAAG5N,EAAImW,EAAGnW,GAAKoI,EAAEjN,GAAKgb,EAAGhb,EAAIyS,EAAGzS,GAAKiN,EAAEpI,GAAKoW,EAC9EvT,GAAKsT,EAAGhb,EAAIuS,EAAG1N,EAAImW,EAAGnW,EAAI0N,EAAGvS,GAAKgb,EAAGnW,EAAI0N,EAAG1N,GAAKoI,EAAEjN,GAAKuS,EAAGvS,EAAIgb,EAAGhb,GAAKiN,EAAEpI,GAAKoW,EAClF,OAAO5b,EAAI,GAAKqI,EAAI,GAAKrI,EAAIqI,EAAI,EAAIxE,EAAI+X,GAQ7C5B,EAAQ6B,SAAW,SAAUha,EAAQE,GACjC,OAAOzC,KAAKuF,KAAKmV,EAAQ8B,gBAAgBja,EAAQE,KAQrDiY,EAAQ8B,gBAAkB,SAAUja,EAAQE,GACxC,IAAIpB,EAAIkB,EAAOlB,EAAIoB,EAAOpB,EACtB6E,EAAI3D,EAAO2D,EAAIzD,EAAOyD,EAC1B,OAAO7E,EAAIA,EAAI6E,EAAIA,GAQvBwU,EAAQ+B,OAAS,SAAUla,EAAQE,GAC/B,OAAOiY,EAAQgC,YAAYna,EAAQE,EAAQiY,EAAQ/R,SASvD+R,EAAQgC,YAAc,SAAUna,EAAQE,EAAQka,GAC5C,OAAOA,EAAI/c,gBAAgB2C,EAAOlB,EAAIoB,EAAOpB,GAAK,GAAIkB,EAAO2D,EAAIzD,EAAOyD,GAAK,IASjFwU,EAAQkC,2BAA6B,SAAUtO,EAAGuO,EAAMC,GACpD,IAAIC,EAAKrC,EAAQ8B,gBAAgBK,EAAMC,GACvC,GAAW,IAAPC,EACA,OAAOrC,EAAQ6B,SAASjO,EAAGuO,GAE/B,IAAIlc,EAAImc,EAAKvd,SAASsd,GAClB9T,EAAI/I,KAAKZ,IAAI,EAAGY,KAAKb,IAAI,EAAGub,EAAQkB,IAAItN,EAAE/O,SAASsd,GAAOlc,GAAKoc,IAC/DC,EAAOH,EAAKxd,IAAIsB,EAAE0Z,iBAAiBtR,EAAGA,IAC1C,OAAO2R,EAAQ6B,SAASjO,EAAG0O,IAExBtC,EAzpBiB,GAkqBxBuC,EAAyB,WAOzB,SAASA,EAAQ5b,EAAG6E,EAAGC,QACT,IAAN9E,IAAgBA,EAAI,QACd,IAAN6E,IAAgBA,EAAI,QACd,IAANC,IAAgBA,EAAI,GAExB3I,KAAK0f,UAAW,EAChB1f,KAAK2f,GAAK9b,EACV7D,KAAK4f,GAAKlX,EACV1I,KAAK6f,GAAKlX,EAujDd,OArjDA1C,OAAOC,eAAeuZ,EAAQxf,UAAW,IAAK,CAE1CkG,IAAK,WACD,OAAOnG,KAAK2f,IAEhBtd,IAAK,SAAUsB,GACX3D,KAAK2f,GAAKhc,EACV3D,KAAK0f,UAAW,GAEpBrZ,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAeuZ,EAAQxf,UAAW,IAAK,CAE1CkG,IAAK,WACD,OAAOnG,KAAK4f,IAEhBvd,IAAK,SAAUsB,GACX3D,KAAK4f,GAAKjc,EACV3D,KAAK0f,UAAW,GAEpBrZ,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAeuZ,EAAQxf,UAAW,IAAK,CAE1CkG,IAAK,WACD,OAAOnG,KAAK6f,IAEhBxd,IAAK,SAAUsB,GACX3D,KAAK6f,GAAKlc,EACV3D,KAAK0f,UAAW,GAEpBrZ,YAAY,EACZC,cAAc,IAMlBmZ,EAAQxf,UAAUC,SAAW,WACzB,MAAO,OAAOyc,OAAO3c,KAAK2f,GAAI,QAAQhD,OAAO3c,KAAK4f,GAAI,QAAQjD,OAAO3c,KAAK6f,GAAI,MAMlFJ,EAAQxf,UAAUE,aAAe,WAC7B,MAAO,WAMXsf,EAAQxf,UAAUG,YAAc,WAC5B,IAGIC,EAHI2c,EAAchd,KAAK2f,IAM3B,OADAtf,EAAe,KADfA,EAAe,IAAPA,EAHA2c,EAAchd,KAAK4f,KACnB5C,EAAchd,KAAK6f,KAW/BJ,EAAQxf,UAAUc,QAAU,WACxB,IAAIK,EAAS,GAEb,OADApB,KAAKM,QAAQc,EAAQ,GACdA,GAQXqe,EAAQxf,UAAUK,QAAU,SAAUC,EAAOC,GAKzC,YAJc,IAAVA,IAAoBA,EAAQ,GAChCD,EAAMC,GAASR,KAAK2f,GACpBpf,EAAMC,EAAQ,GAAKR,KAAK4f,GACxBrf,EAAMC,EAAQ,GAAKR,KAAK6f,GACjB7f,MAQXyf,EAAQxf,UAAUQ,UAAY,SAAUF,EAAOC,GAG3C,YAFc,IAAVA,IAAoBA,EAAQ,GAChCif,EAAQ9e,eAAeJ,EAAOC,EAAOR,MAC9BA,MAMXyf,EAAQxf,UAAU6f,aAAe,WAC7B,OAAOC,EAAWC,qBAAqBhgB,KAAK4f,GAAI5f,KAAK2f,GAAI3f,KAAK6f,KAOlEJ,EAAQxf,UAAU+G,WAAa,SAAUmW,GACrC,OAAOnd,KAAKigB,qBAAqB9C,EAAYwC,GAAIxC,EAAYyC,GAAIzC,EAAY0C,KASjFJ,EAAQxf,UAAUggB,qBAAuB,SAAUpc,EAAG6E,EAAGC,GAIrD,OAHA3I,KAAK6D,GAAKA,EACV7D,KAAK0I,GAAKA,EACV1I,KAAK2I,GAAKA,EACH3I,MAOXyf,EAAQxf,UAAU4B,IAAM,SAAUsb,GAC9B,OAAO,IAAIsC,EAAQzf,KAAK2f,GAAKxC,EAAYwC,GAAI3f,KAAK4f,GAAKzC,EAAYyC,GAAI5f,KAAK6f,GAAK1C,EAAY0C,KAQjGJ,EAAQxf,UAAU6B,SAAW,SAAUqb,EAAa/b,GAChD,OAAOA,EAAOgB,eAAepC,KAAK2f,GAAKxC,EAAYwC,GAAI3f,KAAK4f,GAAKzC,EAAYyC,GAAI5f,KAAK6f,GAAK1C,EAAY0C,KAO3GJ,EAAQxf,UAAUod,gBAAkB,SAAUF,GAI1C,OAHAnd,KAAK6D,GAAKsZ,EAAYwC,GACtB3f,KAAK0I,GAAKyU,EAAYyC,GACtB5f,KAAK2I,GAAKwU,EAAY0C,GACf7f,MAOXyf,EAAQxf,UAAU8B,SAAW,SAAUob,GACnC,OAAO,IAAIsC,EAAQzf,KAAK2f,GAAKxC,EAAYwC,GAAI3f,KAAK4f,GAAKzC,EAAYyC,GAAI5f,KAAK6f,GAAK1C,EAAY0C,KAQjGJ,EAAQxf,UAAU+B,cAAgB,SAAUmb,EAAa/b,GACrD,OAAOpB,KAAKkgB,wBAAwB/C,EAAYwC,GAAIxC,EAAYyC,GAAIzC,EAAY0C,GAAIze,IASxFqe,EAAQxf,UAAUkgB,mBAAqB,SAAUtc,EAAG6E,EAAGC,GACnD,OAAO,IAAI8W,EAAQzf,KAAK2f,GAAK9b,EAAG7D,KAAK4f,GAAKlX,EAAG1I,KAAK6f,GAAKlX,IAU3D8W,EAAQxf,UAAUigB,wBAA0B,SAAUrc,EAAG6E,EAAGC,EAAGvH,GAC3D,OAAOA,EAAOgB,eAAepC,KAAK2f,GAAK9b,EAAG7D,KAAK4f,GAAKlX,EAAG1I,KAAK6f,GAAKlX,IAMrE8W,EAAQxf,UAAUyd,OAAS,WACvB,OAAO,IAAI+B,GAASzf,KAAK2f,IAAK3f,KAAK4f,IAAK5f,KAAK6f,KAMjDJ,EAAQxf,UAAU0d,cAAgB,WAI9B,OAHA3d,KAAK6D,IAAM,EACX7D,KAAK0I,IAAM,EACX1I,KAAK2I,IAAM,EACJ3I,MAOXyf,EAAQxf,UAAU2d,YAAc,SAAUxc,GACtC,OAAOA,EAAOgB,gBAA0B,EAAXpC,KAAK2f,IAAoB,EAAX3f,KAAK4f,IAAoB,EAAX5f,KAAK6f,KAOlEJ,EAAQxf,UAAUuU,aAAe,SAAUjT,GAIvC,OAHAvB,KAAK6D,GAAKtC,EACVvB,KAAK0I,GAAKnH,EACVvB,KAAK2I,GAAKpH,EACHvB,MAOXyf,EAAQxf,UAAUsB,MAAQ,SAAUA,GAChC,OAAO,IAAIke,EAAQzf,KAAK2f,GAAKpe,EAAOvB,KAAK4f,GAAKre,EAAOvB,KAAK6f,GAAKte,IAQnEke,EAAQxf,UAAUuB,WAAa,SAAUD,EAAOH,GAC5C,OAAOA,EAAOgB,eAAepC,KAAK2f,GAAKpe,EAAOvB,KAAK4f,GAAKre,EAAOvB,KAAK6f,GAAKte,IAQ7Eke,EAAQxf,UAAUmgB,6BAA+B,SAAUC,EAAGjf,GAC1D,IAAIkf,EAAKD,EAAEvD,EAAI9c,KAAK6D,EAAIwc,EAAE3X,EAAI1I,KAAK2I,EAAI0X,EAAE1X,EAAI3I,KAAK0I,EAC9C6X,EAAKF,EAAEvD,EAAI9c,KAAK0I,EAAI2X,EAAE1X,EAAI3I,KAAK6D,EAAIwc,EAAExc,EAAI7D,KAAK2I,EAC9C6X,EAAKH,EAAEvD,EAAI9c,KAAK2I,EAAI0X,EAAExc,EAAI7D,KAAK0I,EAAI2X,EAAE3X,EAAI1I,KAAK6D,EAC9C4c,GAAMJ,EAAExc,EAAI7D,KAAK6D,EAAIwc,EAAE3X,EAAI1I,KAAK0I,EAAI2X,EAAE1X,EAAI3I,KAAK2I,EAInD,OAHAvH,EAAOyC,EAAIyc,EAAKD,EAAEvD,EAAI2D,GAAMJ,EAAExc,EAAI0c,GAAMF,EAAE1X,EAAI6X,GAAMH,EAAE3X,EACtDtH,EAAOsH,EAAI6X,EAAKF,EAAEvD,EAAI2D,GAAMJ,EAAE3X,EAAI8X,GAAMH,EAAExc,EAAIyc,GAAMD,EAAE1X,EACtDvH,EAAOuH,EAAI6X,EAAKH,EAAEvD,EAAI2D,GAAMJ,EAAE1X,EAAI2X,GAAMD,EAAE3X,EAAI6X,GAAMF,EAAExc,EAC/CzC,GAOXqe,EAAQxf,UAAUygB,+BAAiC,SAAUL,GACzD,OAAOrgB,KAAKogB,6BAA6BC,EAAGrgB,OAOhDyf,EAAQxf,UAAU0gB,wBAA0B,SAAUN,GAClD,OAAOrgB,KAAKogB,6BAA6BC,EAAGZ,EAAQtU,SAQxDsU,EAAQxf,UAAUwB,iBAAmB,SAAUF,EAAOH,GAClD,OAAOA,EAAO6e,qBAAqBjgB,KAAK2f,GAAKpe,EAAOvB,KAAK4f,GAAKre,EAAOvB,KAAK6f,GAAKte,IAQnFke,EAAQxf,UAAU2gB,eAAiB,SAAUC,EAAO7V,GAChD,IAAI5J,EAASqe,EAAQtU,OAErB,OADAnL,KAAK8gB,oBAAoBD,EAAO7V,EAAQ5J,GACjCA,GAQXqe,EAAQxf,UAAU6gB,oBAAsB,SAAUD,EAAO7V,EAAQ5J,GAC7D,IAAIyJ,EAAIgW,EAAMpY,OACVG,EAAIiY,EAAMjY,EACVmY,EAAIC,EAAQvB,QAAQ,GAExBzf,KAAKgC,cAAcgJ,EAAQ+V,GAC3BA,EAAElY,YACF,IAAIoY,EAAQxB,EAAQrB,IAAI2C,EAAGlW,GACvBU,IAAMkU,EAAQrB,IAAIpT,EAAQH,GAAKjC,GAAKqY,EAEpCC,EAAUH,EAAEvM,aAAajJ,GAC7BP,EAAOlJ,SAASof,EAAS9f,IAO7Bqe,EAAQxf,UAAUoB,OAAS,SAAU8b,GACjC,OAAOA,GAAend,KAAK2f,KAAOxC,EAAYwC,IAAM3f,KAAK4f,KAAOzC,EAAYyC,IAAM5f,KAAK6f,KAAO1C,EAAY0C,IAQ9GJ,EAAQxf,UAAUkY,kBAAoB,SAAUgF,EAAavD,GAEzD,YADgB,IAAZA,IAAsBA,EAAU,MAC5BuD,GACJ,kBAAqBnd,KAAK2f,GAAIxC,EAAYwC,GAAI/F,IAC9C,kBAAqB5Z,KAAK4f,GAAIzC,EAAYyC,GAAIhG,IAC9C,kBAAqB5Z,KAAK6f,GAAI1C,EAAY0C,GAAIjG,IAStD6F,EAAQxf,UAAUkhB,eAAiB,SAAUtd,EAAG6E,EAAGC,GAC/C,OAAO3I,KAAK2f,KAAO9b,GAAK7D,KAAK4f,KAAOlX,GAAK1I,KAAK6f,KAAOlX,GAOzD8W,EAAQxf,UAAUqd,gBAAkB,SAAUH,GAI1C,OAHAnd,KAAK6D,GAAKsZ,EAAYwC,GACtB3f,KAAK0I,GAAKyU,EAAYyC,GACtB5f,KAAK2I,GAAKwU,EAAY0C,GACf7f,MAOXyf,EAAQxf,UAAUgB,SAAW,SAAUkc,GACnC,OAAOnd,KAAK6c,iBAAiBM,EAAYwC,GAAIxC,EAAYyC,GAAIzC,EAAY0C,KAQ7EJ,EAAQxf,UAAUkB,cAAgB,SAAUgc,EAAa/b,GACrD,OAAOA,EAAOgB,eAAepC,KAAK2f,GAAKxC,EAAYwC,GAAI3f,KAAK4f,GAAKzC,EAAYyC,GAAI5f,KAAK6f,GAAK1C,EAAY0C,KAS3GJ,EAAQxf,UAAU4c,iBAAmB,SAAUhZ,EAAG6E,EAAGC,GACjD,OAAO,IAAI8W,EAAQzf,KAAK2f,GAAK9b,EAAG7D,KAAK4f,GAAKlX,EAAG1I,KAAK6f,GAAKlX,IAO3D8W,EAAQxf,UAAUsd,OAAS,SAAUJ,GACjC,OAAO,IAAIsC,EAAQzf,KAAK2f,GAAKxC,EAAYwC,GAAI3f,KAAK4f,GAAKzC,EAAYyC,GAAI5f,KAAK6f,GAAK1C,EAAY0C,KAQjGJ,EAAQxf,UAAUud,YAAc,SAAUL,EAAa/b,GACnD,OAAOA,EAAOgB,eAAepC,KAAK2f,GAAKxC,EAAYwC,GAAI3f,KAAK4f,GAAKzC,EAAYyC,GAAI5f,KAAK6f,GAAK1C,EAAY0C,KAO3GJ,EAAQxf,UAAUwd,cAAgB,SAAUN,GACxC,OAAOnd,KAAKwd,YAAYL,EAAand,OAOzCyf,EAAQxf,UAAUmhB,gBAAkB,SAAU1W,GAC1C,OAAO1K,KAAK2J,0BAA0Be,EAAMiV,GAAIjV,EAAMkV,GAAIlV,EAAMmV,KAOpEJ,EAAQxf,UAAUohB,gBAAkB,SAAU3W,GAC1C,OAAO1K,KAAK4J,0BAA0Bc,EAAMiV,GAAIjV,EAAMkV,GAAIlV,EAAMmV,KASpEJ,EAAQxf,UAAU0J,0BAA4B,SAAU9F,EAAG6E,EAAGC,GAU1D,OATI9E,EAAI7D,KAAK2f,KACT3f,KAAK6D,EAAIA,GAET6E,EAAI1I,KAAK4f,KACT5f,KAAK0I,EAAIA,GAETC,EAAI3I,KAAK6f,KACT7f,KAAK2I,EAAIA,GAEN3I,MASXyf,EAAQxf,UAAU2J,0BAA4B,SAAU/F,EAAG6E,EAAGC,GAU1D,OATI9E,EAAI7D,KAAK2f,KACT3f,KAAK6D,EAAIA,GAET6E,EAAI1I,KAAK4f,KACT5f,KAAK0I,EAAIA,GAETC,EAAI3I,KAAK6f,KACT7f,KAAK2I,EAAIA,GAEN3I,MAQXyf,EAAQxf,UAAUqhB,0BAA4B,SAAU1H,GACpD,IAAI2H,EAAO/e,KAAKsB,IAAI9D,KAAK2f,IACrB6B,EAAOhf,KAAKsB,IAAI9D,KAAK4f,IACzB,IAAK,kBAAqB2B,EAAMC,EAAM5H,GAClC,OAAO,EAEX,IAAI6H,EAAOjf,KAAKsB,IAAI9D,KAAK6f,IACzB,OAAK,kBAAqB0B,EAAME,EAAM7H,KAGjC,kBAAqB4H,EAAMC,EAAM7H,IAK1C3T,OAAOC,eAAeuZ,EAAQxf,UAAW,eAAgB,CAIrDkG,IAAK,WACD,IAAIob,EAAO/e,KAAKsB,IAAI9D,KAAK2f,IAEzB,OAAI4B,IADO/e,KAAKsB,IAAI9D,KAAK4f,KAKrB2B,IADO/e,KAAKsB,IAAI9D,KAAK6f,KAM7BxZ,YAAY,EACZC,cAAc,IAMlBmZ,EAAQxf,UAAUuK,MAAQ,WACtB,OAAO,IAAIiV,EAAQjd,KAAKgI,MAAMxK,KAAK2f,IAAKnd,KAAKgI,MAAMxK,KAAK4f,IAAKpd,KAAKgI,MAAMxK,KAAK6f,MAMjFJ,EAAQxf,UAAU4d,MAAQ,WACtB,OAAO,IAAI4B,EAAQzf,KAAK2f,GAAKnd,KAAKgI,MAAMxK,KAAK2f,IAAK3f,KAAK4f,GAAKpd,KAAKgI,MAAMxK,KAAK4f,IAAK5f,KAAK6f,GAAKrd,KAAKgI,MAAMxK,KAAK6f,MAO/GJ,EAAQxf,UAAUkE,OAAS,WACvB,OAAO3B,KAAKuF,KAAK/H,KAAK2f,GAAK3f,KAAK2f,GAAK3f,KAAK4f,GAAK5f,KAAK4f,GAAK5f,KAAK6f,GAAK7f,KAAK6f,KAM5EJ,EAAQxf,UAAUyX,cAAgB,WAC9B,OAAO1X,KAAK2f,GAAK3f,KAAK2f,GAAK3f,KAAK4f,GAAK5f,KAAK4f,GAAK5f,KAAK6f,GAAK7f,KAAK6f,IAElE5Z,OAAOC,eAAeuZ,EAAQxf,UAAW,oBAAqB,CAI1DkG,IAAK,WACD,OAAOnG,KAAK2f,GAAK3f,KAAK4f,GAAK5f,KAAK6f,IAAO,GAE3CxZ,YAAY,EACZC,cAAc,IAOlBmZ,EAAQxf,UAAU4I,UAAY,WAC1B,OAAO7I,KAAK0hB,oBAAoB1hB,KAAKmE,WAOzCsb,EAAQxf,UAAU0hB,eAAiB,SAAUC,GACzC,IAAIC,EAAQ7hB,KAEZ,MAAc,SADd4hB,EAAQA,EAAME,iBAIdd,EAAQvB,QAAQ,GAAGvd,SAASlC,MAC5B,CAAC,IAAK,IAAK,KAAK+hB,SAAQ,SAAUC,EAAKhW,GACnC6V,EAAMG,GAAOhB,EAAQvB,QAAQ,GAAGmC,EAAM5V,QAJ/BhM,MAcfyf,EAAQxf,UAAUgiB,wBAA0B,SAAUC,EAAY9gB,GAG9D,OAFA8gB,EAAWhN,iBAAiB8L,EAAQmB,OAAO,IAC3C1C,EAAQ2C,0BAA0BpiB,KAAMghB,EAAQmB,OAAO,GAAI/gB,GACpDA,GASXqe,EAAQxf,UAAUoiB,mCAAqC,SAAUH,EAAYhX,EAAO9J,GAIhF,OAHApB,KAAKgC,cAAckJ,EAAO8V,EAAQvB,QAAQ,IAC1CuB,EAAQvB,QAAQ,GAAGwC,wBAAwBC,EAAYlB,EAAQvB,QAAQ,IACvEvU,EAAMpJ,SAASkf,EAAQvB,QAAQ,GAAIre,GAC5BA,GAQXqe,EAAQxf,UAAUqiB,MAAQ,SAAU5X,GAChC,OAAO+U,EAAQ8C,MAAMviB,KAAM0K,IAQ/B+U,EAAQxf,UAAUyhB,oBAAsB,SAAUnD,GAC9C,OAAY,IAARA,GAAqB,IAARA,EACNve,KAEJA,KAAKwU,aAAa,EAAM+J,IAMnCkB,EAAQxf,UAAUuiB,eAAiB,WAC/B,IAAItH,EAAa,IAAIuE,EAAQ,EAAG,EAAG,GAEnC,OADAzf,KAAKyiB,eAAevH,GACbA,GAOXuE,EAAQxf,UAAUwiB,eAAiB,SAAUC,GACzC,IAAInE,EAAMve,KAAKmE,SACf,OAAY,IAARoa,GAAqB,IAARA,EACNmE,EAAUtgB,eAAepC,KAAK2f,GAAI3f,KAAK4f,GAAI5f,KAAK6f,IAEpD7f,KAAKwB,WAAW,EAAM+c,EAAKmE,IAMtCjD,EAAQxf,UAAUgC,MAAQ,WACtB,OAAO,IAAIwd,EAAQzf,KAAK2f,GAAI3f,KAAK4f,GAAI5f,KAAK6f,KAO9CJ,EAAQxf,UAAUiC,SAAW,SAAUC,GACnC,OAAOnC,KAAKoC,eAAeD,EAAOwd,GAAIxd,EAAOyd,GAAIzd,EAAO0d,KAS5DJ,EAAQxf,UAAUmC,eAAiB,SAAUyB,EAAG6E,EAAGC,GAI/C,OAHA3I,KAAK6D,EAAIA,EACT7D,KAAK0I,EAAIA,EACT1I,KAAK2I,EAAIA,EACF3I,MASXyf,EAAQxf,UAAUoC,IAAM,SAAUwB,EAAG6E,EAAGC,GACpC,OAAO3I,KAAKoC,eAAeyB,EAAG6E,EAAGC,IAOrC8W,EAAQxf,UAAU0iB,OAAS,SAAUxf,GAEjC,OADAnD,KAAK6D,EAAI7D,KAAK0I,EAAI1I,KAAK2I,EAAIxF,EACpBnD,MAWXyf,EAAQmD,cAAgB,SAAUC,EAASC,EAASC,EAAMC,GACtD,IAAIC,EAAKxD,EAAQrB,IAAIyE,EAASE,GAAQC,EAGtC,OADQC,GAAMA,GADLxD,EAAQrB,IAAI0E,EAASC,GAAQC,KAW1CvD,EAAQyD,uBAAyB,SAAUL,EAASC,EAASra,GACzD,IAAI8M,EAAKsN,EAAQJ,eAAezB,EAAQvB,QAAQ,IAC5CjK,EAAKsN,EAAQL,eAAezB,EAAQvB,QAAQ,IAC5C0D,EAAM1D,EAAQrB,IAAI7I,EAAIC,GAE1B2N,EAAM,UAAaA,GAAM,EAAG,GAC5B,IAAItV,EAAQrL,KAAK4gB,KAAKD,GAClBtY,EAAImW,EAAQvB,QAAQ,GAExB,OADAA,EAAQ4D,WAAW9N,EAAIC,EAAI3K,GACvB4U,EAAQrB,IAAIvT,EAAGpC,GAAU,EAClB8R,MAAM1M,GAAS,EAAIA,EAEvB0M,MAAM1M,IAAUrL,KAAK6J,IAAM7J,KAAK4gB,KAAKD,IAShD1D,EAAQ6D,8BAAgC,SAAUT,EAASC,EAASra,GAChEuY,EAAQvB,QAAQ,GAAGvd,SAAS2gB,GAC5B,IAAItN,EAAKyL,EAAQvB,QAAQ,GACzBuB,EAAQvB,QAAQ,GAAGvd,SAAS4gB,GAC5B,IAAItN,EAAKwL,EAAQvB,QAAQ,GACzBuB,EAAQvB,QAAQ,GAAGvd,SAASuG,GAC5B,IAAI8a,EAAUvC,EAAQvB,QAAQ,GAC1B5a,EAAQmc,EAAQvB,QAAQ,GACxB+D,EAAUxC,EAAQvB,QAAQ,GAC9BlK,EAAG1M,YACH2M,EAAG3M,YACH0a,EAAQ1a,YACR4W,EAAQ4D,WAAWE,EAAShO,EAAI1Q,GAChC4a,EAAQ4D,WAAWxe,EAAO0e,EAASC,GACnC,IAAI3V,EAAQrL,KAAKiK,MAAMgT,EAAQrB,IAAI5I,EAAI3Q,GAAQ4a,EAAQrB,IAAI5I,EAAIgO,IAC/D,OAAO,qBAAwB3V,IASnC4R,EAAQgE,WAAa,SAAUZ,EAASC,EAASY,EAAOtiB,GACpDsiB,EAAQ,UAAaA,EAAO,EAAG,GAC/B,IAAIC,EAAa3C,EAAQvB,QAAQ,GAC7BmE,EAAa5C,EAAQvB,QAAQ,GACjCkE,EAAWzhB,SAAS2gB,GACpB,IAAIgB,EAAgBF,EAAWxf,SAC/Bwf,EAAWjC,oBAAoBmC,GAC/BD,EAAW1hB,SAAS4gB,GACpB,IAAIgB,EAAgBF,EAAWzf,SAC/Byf,EAAWlC,oBAAoBoC,GAC/B,IACIC,EACAC,EAFAb,EAAM1D,EAAQrB,IAAIuF,EAAYC,GAGlC,GAAIT,EAAM,EAAI,KAAS,CACnB,IAAIc,EAAQzhB,KAAK4gB,KAAKD,GAClBe,EAAS,EAAI1hB,KAAKuM,IAAIkV,GAC1BF,EAASvhB,KAAKuM,KAAK,EAAI2U,GAASO,GAASC,EACzCF,EAASxhB,KAAKuM,IAAI2U,EAAQO,GAASC,OAInCH,EAAS,EAAIL,EACbM,EAASN,EAEbC,EAAWnP,aAAauP,GACxBH,EAAWpP,aAAawP,GACxB5iB,EAAOc,SAASyhB,GAAY3c,WAAW4c,GACvCxiB,EAAOoT,aAAa,SAAYqP,EAAeC,EAAeJ,KAUlEjE,EAAQ0E,YAAc,SAAUhiB,EAAQiiB,EAAMC,EAAWC,EAAUljB,GAC/Dqe,EAAQgE,WAAWthB,EAAQiiB,EAAmB,IAAbE,EAAiB,EAAID,EAAYC,EAAUljB,IAQhFqe,EAAQnb,UAAY,SAAU/D,EAAOG,GAEjC,YADe,IAAXA,IAAqBA,EAAS,GAC3B,IAAI+e,EAAQlf,EAAMG,GAASH,EAAMG,EAAS,GAAIH,EAAMG,EAAS,KASxE+e,EAAQ8E,eAAiB,SAAUhkB,EAAOG,GACtC,OAAO+e,EAAQnb,UAAU/D,EAAOG,IAQpC+e,EAAQ9e,eAAiB,SAAUJ,EAAOG,EAAQU,GAC9CA,EAAOyC,EAAItD,EAAMG,GACjBU,EAAOsH,EAAInI,EAAMG,EAAS,GAC1BU,EAAOuH,EAAIpI,EAAMG,EAAS,IAS9B+e,EAAQ+E,oBAAsB,SAAUjkB,EAAOG,EAAQU,GACnD,OAAOqe,EAAQ9e,eAAeJ,EAAOG,EAAQU,IASjDqe,EAAQgF,gBAAkB,SAAU5gB,EAAG6E,EAAGC,EAAGvH,GACzCA,EAAOgB,eAAeyB,EAAG6E,EAAGC,IAMhC8W,EAAQtU,KAAO,WACX,OAAO,IAAIsU,EAAQ,EAAK,EAAK,IAMjCA,EAAQzB,IAAM,WACV,OAAO,IAAIyB,EAAQ,EAAK,EAAK,IAMjCA,EAAQiF,GAAK,WACT,OAAO,IAAIjF,EAAQ,EAAK,EAAK,IAEjCxZ,OAAOC,eAAeuZ,EAAS,aAAc,CAIzCtZ,IAAK,WACD,OAAOsZ,EAAQkF,aAEnBte,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAeuZ,EAAS,gBAAiB,CAI5CtZ,IAAK,WACD,OAAOsZ,EAAQmF,gBAEnBve,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAeuZ,EAAS,eAAgB,CAI3CtZ,IAAK,WACD,OAAOsZ,EAAQoF,eAEnBxe,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAeuZ,EAAS,4BAA6B,CAIxDtZ,IAAK,WACD,OAAOsZ,EAAQqF,4BAEnBze,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAeuZ,EAAS,6BAA8B,CAIzDtZ,IAAK,WACD,OAAOsZ,EAAQsF,6BAEnB1e,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAeuZ,EAAS,eAAgB,CAI3CtZ,IAAK,WACD,OAAOsZ,EAAQuF,eAEnB3e,YAAY,EACZC,cAAc,IAMlBmZ,EAAQwF,KAAO,WACX,OAAO,IAAIxF,EAAQ,GAAM,EAAK,IAOlCA,EAAQyF,QAAU,SAAUC,GAExB,YAD0B,IAAtBA,IAAgCA,GAAoB,GACjD,IAAI1F,EAAQ,EAAK,EAAK0F,GAAqB,EAAM,IAO5D1F,EAAQ2F,SAAW,SAAUD,GAEzB,YAD0B,IAAtBA,IAAgCA,GAAoB,GACjD,IAAI1F,EAAQ,EAAK,EAAK0F,EAAoB,GAAO,IAM5D1F,EAAQ4F,MAAQ,WACZ,OAAO,IAAI5F,EAAQ,EAAK,EAAK,IAMjCA,EAAQ6F,KAAO,WACX,OAAO,IAAI7F,GAAS,EAAK,EAAK,IASlCA,EAAQ8F,qBAAuB,SAAUlH,EAAQ3F,GAC7C,IAAItX,EAASqe,EAAQtU,OAErB,OADAsU,EAAQ2C,0BAA0B/D,EAAQ3F,EAAgBtX,GACnDA,GASXqe,EAAQ2C,0BAA4B,SAAU/D,EAAQ3F,EAAgBtX,GAClEqe,EAAQ+F,oCAAoCnH,EAAOsB,GAAItB,EAAOuB,GAAIvB,EAAOwB,GAAInH,EAAgBtX,IAWjGqe,EAAQ+F,oCAAsC,SAAU3hB,EAAG6E,EAAGC,EAAG+P,EAAgBtX,GAC7E,IAAI2C,EAAI2U,EAAe3U,EACnB0hB,EAAK5hB,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GAAKA,EAAE,IACxC2hB,EAAK7hB,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GAAKA,EAAE,IACxC4hB,EAAK9hB,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,IAAMA,EAAE,IACzC6hB,EAAK,GAAK/hB,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,IAAMA,EAAE,KAClD3C,EAAOyC,EAAI4hB,EAAKG,EAChBxkB,EAAOsH,EAAIgd,EAAKE,EAChBxkB,EAAOuH,EAAIgd,EAAKC,GASpBnG,EAAQoG,gBAAkB,SAAUxH,EAAQ3F,GACxC,IAAItX,EAASqe,EAAQtU,OAErB,OADAsU,EAAQqG,qBAAqBzH,EAAQ3F,EAAgBtX,GAC9CA,GASXqe,EAAQqG,qBAAuB,SAAUzH,EAAQ3F,EAAgBtX,GAC7DpB,KAAK+lB,+BAA+B1H,EAAOsB,GAAItB,EAAOuB,GAAIvB,EAAOwB,GAAInH,EAAgBtX,IAWzFqe,EAAQsG,+BAAiC,SAAUliB,EAAG6E,EAAGC,EAAG+P,EAAgBtX,GACxE,IAAI2C,EAAI2U,EAAe3U,EACvB3C,EAAOyC,EAAIA,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GACvC3C,EAAOsH,EAAI7E,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GACvC3C,EAAOuH,EAAI9E,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,KAW3C0b,EAAQxB,WAAa,SAAUlZ,EAAQE,EAAQiZ,EAAQC,EAAQzZ,GAC3D,IAAIS,EAAUT,EAASA,EACnBU,EAAQV,EAASS,EAgBrB,OAAO,IAAIsa,EAfH,IACH,EAAMxa,EAAO0a,KACR5a,EAAO4a,GAAKzB,EAAOyB,IAAMjb,GAC1B,EAAMK,EAAO4a,GAAK,EAAM1a,EAAO0a,GAAK,EAAMzB,EAAOyB,GAAKxB,EAAOwB,IAAMxa,IAClEJ,EAAO4a,GAAK,EAAM1a,EAAO0a,GAAK,EAAMzB,EAAOyB,GAAKxB,EAAOwB,IAAMva,GAC/D,IACH,EAAMH,EAAO2a,KACR7a,EAAO6a,GAAK1B,EAAO0B,IAAMlb,GAC1B,EAAMK,EAAO6a,GAAK,EAAM3a,EAAO2a,GAAK,EAAM1B,EAAO0B,GAAKzB,EAAOyB,IAAMza,IAClEJ,EAAO6a,GAAK,EAAM3a,EAAO2a,GAAK,EAAM1B,EAAO0B,GAAKzB,EAAOyB,IAAMxa,GAC/D,IACH,EAAMH,EAAO4a,KACR9a,EAAO8a,GAAK3B,EAAO2B,IAAMnb,GAC1B,EAAMK,EAAO8a,GAAK,EAAM5a,EAAO4a,GAAK,EAAM3B,EAAO2B,GAAK1B,EAAO0B,IAAM1a,IAClEJ,EAAO8a,GAAK,EAAM5a,EAAO4a,GAAK,EAAM3B,EAAO2B,GAAK1B,EAAO0B,IAAMza,KAY3Eqa,EAAQjF,MAAQ,SAAU7W,EAAOhC,EAAKC,GAClC,IAAIuB,EAAI,IAAIsc,EAEZ,OADAA,EAAQuG,WAAWriB,EAAOhC,EAAKC,EAAKuB,GAC7BA,GAWXsc,EAAQuG,WAAa,SAAUriB,EAAOhC,EAAKC,EAAKR,GAC5C,IAAIyC,EAAIF,EAAMgc,GAEd9b,GADAA,EAAIA,EAAIjC,EAAI+d,GAAK/d,EAAI+d,GAAK9b,GAClBlC,EAAIge,GAAKhe,EAAIge,GAAK9b,EAC1B,IAAI6E,EAAI/E,EAAMic,GAEdlX,GADAA,EAAIA,EAAI9G,EAAIge,GAAKhe,EAAIge,GAAKlX,GAClB/G,EAAIie,GAAKje,EAAIie,GAAKlX,EAC1B,IAAIC,EAAIhF,EAAMkc,GAEdlX,GADAA,EAAIA,EAAI/G,EAAIie,GAAKje,EAAIie,GAAKlX,GAClBhH,EAAIke,GAAKle,EAAIke,GAAKlX,EAC1BvH,EAAOgB,eAAeyB,EAAG6E,EAAGC,IAQhC8W,EAAQwG,aAAe,SAAU9iB,EAAGxB,EAAKC,GACrCD,EAAIyf,gBAAgBje,GACpBvB,EAAIyf,gBAAgBle,IAWxBsc,EAAQ3a,QAAU,SAAUC,EAAQC,EAAUC,EAAQC,EAAUR,GAC5D,IAAIS,EAAUT,EAASA,EACnBU,EAAQV,EAASS,EACjBE,EAAQ,EAAMD,EAAQ,EAAMD,EAAU,EACtCG,GAAS,EAAMF,EAAQ,EAAMD,EAC7BI,EAAQH,EAAQ,EAAMD,EAAUT,EAChCc,EAAQJ,EAAQD,EAIpB,OAAO,IAAIsa,EAHH1a,EAAO4a,GAAKta,EAAQJ,EAAO0a,GAAKra,EAAQN,EAAS2a,GAAKpa,EAAQL,EAASya,GAAKna,EAC5ET,EAAO6a,GAAKva,EAAQJ,EAAO2a,GAAKta,EAAQN,EAAS4a,GAAKra,EAAQL,EAAS0a,GAAKpa,EAC5ET,EAAO8a,GAAKxa,EAAQJ,EAAO4a,GAAKva,EAAQN,EAAS6a,GAAKta,EAAQL,EAAS2a,GAAKra,IAYxFia,EAAQha,qBAAuB,SAAUV,EAAQC,EAAUC,EAAQC,EAAUQ,GACzE,IAAItE,EAASqe,EAAQtU,OAErB,OADAnL,KAAK4F,0BAA0Bb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GAClEA,GAWXqe,EAAQ7Z,0BAA4B,SAAUb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GACpF,IAAIyE,EAAKH,EAAOA,EAChBtE,EAAOyC,EAAkB,GAAbgC,EAAKH,GAAYX,EAAOlB,GAAK,EAAIgC,EAAK,EAAIH,EAAO,GAAKV,EAASnB,EAAmB,IAAbgC,EAAKH,GAAYT,EAAOpB,GAAK,EAAIgC,EAAK,EAAIH,GAAQR,EAASrB,EAC5IzC,EAAOsH,EAAkB,GAAb7C,EAAKH,GAAYX,EAAO2D,GAAK,EAAI7C,EAAK,EAAIH,EAAO,GAAKV,EAAS0D,EAAmB,IAAb7C,EAAKH,GAAYT,EAAOyD,GAAK,EAAI7C,EAAK,EAAIH,GAAQR,EAASwD,EAC5ItH,EAAOuH,EAAkB,GAAb9C,EAAKH,GAAYX,EAAO4D,GAAK,EAAI9C,EAAK,EAAIH,EAAO,GAAKV,EAAS2D,EAAmB,IAAb9C,EAAKH,GAAYT,EAAO0D,GAAK,EAAI9C,EAAK,EAAIH,GAAQR,EAASyD,GAShJ8W,EAAQlb,KAAO,SAAUC,EAAOC,EAAKC,GACjC,IAAItD,EAAS,IAAIqe,EAAQ,EAAG,EAAG,GAE/B,OADAA,EAAQ9a,UAAUH,EAAOC,EAAKC,EAAQtD,GAC/BA,GASXqe,EAAQ9a,UAAY,SAAUH,EAAOC,EAAKC,EAAQtD,GAC9CA,EAAOyC,EAAIW,EAAMmb,IAAMlb,EAAIkb,GAAKnb,EAAMmb,IAAMjb,EAC5CtD,EAAOsH,EAAIlE,EAAMob,IAAMnb,EAAImb,GAAKpb,EAAMob,IAAMlb,EAC5CtD,EAAOuH,EAAInE,EAAMqb,IAAMpb,EAAIob,GAAKrb,EAAMqb,IAAMnb,GAQhD+a,EAAQrB,IAAM,SAAUxZ,EAAMC,GAC1B,OAAOD,EAAK+a,GAAK9a,EAAM8a,GAAK/a,EAAKgb,GAAK/a,EAAM+a,GAAKhb,EAAKib,GAAKhb,EAAMgb,IASrEJ,EAAQ8C,MAAQ,SAAU3d,EAAMC,GAC5B,IAAIzD,EAASqe,EAAQtU,OAErB,OADAsU,EAAQ4D,WAAWze,EAAMC,EAAOzD,GACzBA,GASXqe,EAAQ4D,WAAa,SAAUze,EAAMC,EAAOzD,GACxC,IAAIyC,EAAIe,EAAKgb,GAAK/a,EAAMgb,GAAKjb,EAAKib,GAAKhb,EAAM+a,GACzClX,EAAI9D,EAAKib,GAAKhb,EAAM8a,GAAK/a,EAAK+a,GAAK9a,EAAMgb,GACzClX,EAAI/D,EAAK+a,GAAK9a,EAAM+a,GAAKhb,EAAKgb,GAAK/a,EAAM8a,GAC7Cve,EAAOgB,eAAeyB,EAAG6E,EAAGC,IAOhC8W,EAAQzE,UAAY,SAAUqD,GAC1B,IAAIjd,EAASqe,EAAQtU,OAErB,OADAsU,EAAQ1B,eAAeM,EAAQjd,GACxBA,GAOXqe,EAAQ1B,eAAiB,SAAUM,EAAQjd,GACvCid,EAAOoE,eAAerhB,IAU1Bqe,EAAQyG,QAAU,SAAU7H,EAAQ8H,EAAOhe,EAAWie,GAClD,IAAIhlB,EAAS,IAAIqe,EAEjB,OADAA,EAAQ4G,aAAahI,EAAQ8H,EAAOhe,EAAWie,EAAUhlB,GAClDA,GAWXqe,EAAQ4G,aAAe,SAAUhI,EAAQ8H,EAAOhe,EAAWie,EAAUhlB,GACjE,IAAIklB,EAAKF,EAAS3J,MACd8J,EAAKH,EAAS1J,OACd8J,EAAKJ,EAASviB,EACd4iB,EAAKL,EAAS1d,EACdge,EAAiB1F,EAAQmB,OAAO,GACpCA,EAAOwE,gBAAgBL,EAAK,EAAK,EAAG,EAAG,EAAG,GAAIC,EAAK,EAAK,EAAG,EAAG,EAAG,EAAG,GAAK,EAAGC,EAAKF,EAAK,EAAKC,EAAK,EAAME,EAAI,GAAK,EAAGC,GAClH,IAAIE,EAAS5F,EAAQmB,OAAO,GAI5B,OAHAgE,EAAMhlB,cAAcgH,EAAWye,GAC/BA,EAAOzlB,cAAculB,EAAgBE,GACrCnH,EAAQ2C,0BAA0B/D,EAAQuI,EAAQxlB,GAC3CA,GAQXqe,EAAQoH,kCAAoC,SAAU1kB,EAAQykB,EAAQxlB,GAClEqe,EAAQ2C,0BAA0BjgB,EAAQykB,EAAQxlB,GAClD,IAAI2C,EAAI6iB,EAAO7iB,EACXsX,EAAMlZ,EAAOwd,GAAK5b,EAAE,GAAK5B,EAAOyd,GAAK7b,EAAE,GAAK5B,EAAO0d,GAAK9b,EAAE,IAAMA,EAAE,IAClE,kBAAqBsX,EAAK,IAC1Bja,EAAOoT,aAAa,EAAM6G,IAYlCoE,EAAQqH,uBAAyB,SAAU3kB,EAAQ4kB,EAAeC,EAAgBb,EAAOhe,GACrF,OAAOnI,KAAKinB,UAAU9kB,EAAQ4kB,EAAeC,EAAgBb,EAAOhe,EAAWga,EAAO+E,mBAY1FzH,EAAQwH,UAAY,SAAU9kB,EAAQ4kB,EAAeC,EAAgBb,EAAOgB,EAAMC,GAC9E,IAAIhmB,EAASqe,EAAQtU,OAErB,OADAsU,EAAQ4H,eAAellB,EAAQ4kB,EAAeC,EAAgBb,EAAOgB,EAAMC,EAAYhmB,GAChFA,GAYXqe,EAAQ4H,eAAiB,SAAUllB,EAAQ4kB,EAAeC,EAAgBb,EAAOgB,EAAMC,EAAYhmB,GAC/Fqe,EAAQ6H,qBAAqBnlB,EAAOwd,GAAIxd,EAAOyd,GAAIzd,EAAO0d,GAAIkH,EAAeC,EAAgBb,EAAOgB,EAAMC,EAAYhmB,IAc1Hqe,EAAQ6H,qBAAuB,SAAUC,EAASC,EAASC,EAASV,EAAeC,EAAgBb,EAAOgB,EAAMC,EAAYhmB,GACxH,IAAI2I,EACA6c,EAAS5F,EAAQmB,OAAO,GAC5BgE,EAAMhlB,cAAcgmB,EAAMP,GAC1BA,EAAOzlB,cAAcimB,EAAYR,GACjCA,EAAOc,SACP,IAAIC,EAAe3G,EAAQvB,QAAQ,GACnCkI,EAAa9jB,EAAK0jB,EAAUR,EAAiB,EAAI,EACjDY,EAAajf,IAAO8e,EAAUR,EAAkB,EAAI,IACP,QAAxCjd,EAAK,6BAAkD,IAAPA,OAAgB,EAASA,EAAG6d,iBAC7ED,EAAahf,EAAI8e,EAGjBE,EAAahf,EAAI,EAAI8e,EAAU,EAEnChI,EAAQoH,kCAAkCc,EAAcf,EAAQxlB,IAQpEqe,EAAQjB,SAAW,SAAU5Z,EAAMC,GAC/B,IAAIlD,EAAMiD,EAAK3C,QAEf,OADAN,EAAIyf,gBAAgBvc,GACblD,GAQX8d,EAAQhB,SAAW,SAAU7Z,EAAMC,GAC/B,IAAIjD,EAAMgD,EAAK3C,QAEf,OADAL,EAAIyf,gBAAgBxc,GACbjD,GAQX6d,EAAQV,SAAW,SAAUha,EAAQE,GACjC,OAAOzC,KAAKuF,KAAK0X,EAAQT,gBAAgBja,EAAQE,KAQrDwa,EAAQT,gBAAkB,SAAUja,EAAQE,GACxC,IAAIpB,EAAIkB,EAAO4a,GAAK1a,EAAO0a,GACvBjX,EAAI3D,EAAO6a,GAAK3a,EAAO2a,GACvBjX,EAAI5D,EAAO8a,GAAK5a,EAAO4a,GAC3B,OAAOhc,EAAIA,EAAI6E,EAAIA,EAAIC,EAAIA,GAc/B8W,EAAQoI,uBAAyB,SAAUxJ,EAAQQ,EAAIzI,EAAIE,EAAI6I,GAC3D,IAAI2I,EAAO9G,EAAQvB,QAAQ,GACvBsI,EAAO/G,EAAQvB,QAAQ,GACvBuI,EAAOhH,EAAQvB,QAAQ,GACvBhX,EAASuY,EAAQvB,QAAQ,GACzBwI,EAAWjH,EAAQvB,QAAQ,GAE/BrJ,EAAGpU,cAAc6c,EAAIiJ,GACrBxR,EAAGtU,cAAc6c,EAAIkJ,GACrBzR,EAAGtU,cAAcoU,EAAI4R,GACrB,IAAIE,EAAQJ,EAAK3jB,SACbgkB,EAAQJ,EAAK5jB,SACbikB,EAAQJ,EAAK7jB,SACjB,GAAI+jB,EAAQ,MAAWC,EAAQ,MAAWC,EAAQ,KAK9C,OADAjJ,EAAIjd,SAAS2c,GACNY,EAAQV,SAASV,EAAQQ,GAGpCR,EAAOrc,cAAc6c,EAAIoJ,GACzBxI,EAAQ4D,WAAWyE,EAAMC,EAAMtf,GAC/B,IAAI4f,EAAK5f,EAAOtE,SAChB,GAAIkkB,EAAK,KAGL,OADAlJ,EAAIjd,SAAS2c,GACNY,EAAQV,SAASV,EAAQQ,GAEpCpW,EAAOiZ,oBAAoB2G,GAC3B,IAAItV,EAAIkV,EAAS9jB,SACjB,GAAI4O,EAAI,KAGJ,OADAoM,EAAIjd,SAAS2c,GACN,EAEXoJ,EAASvG,oBAAoB3O,GAE7B,IAAIuV,EAAO7I,EAAQrB,IAAI3V,EAAQwf,GAC3BM,EAAavH,EAAQvB,QAAQ,GAC7BD,EAAOwB,EAAQvB,QAAQ,GAC3B8I,EAAWrmB,SAASuG,GAAQ+L,cAAczB,EAAIuV,GAC9C9I,EAAKtd,SAASmc,GAAQrX,WAAWuhB,GAEjC,IAAIhT,EAAKyL,EAAQvB,QAAQ,GACrBjK,EAAKwL,EAAQvB,QAAQ,GACrBhK,EAAKuL,EAAQvB,QAAQ,GACrB+I,EAAMxH,EAAQvB,QAAQ,GAC1BlK,EAAGrT,SAAS4lB,GAAMtT,aAAa,EAAI0T,GACnCM,EAAItmB,SAAS6lB,GAAMvT,aAAa,EAAI2T,GACpC5S,EAAGvO,WAAWwhB,GAAKhU,cAAc,GACjCgB,EAAGtT,SAAS4lB,GAAMtT,cAAc,EAAI0T,GACpCM,EAAItmB,SAAS8lB,GAAMxT,aAAa,EAAI4T,GACpC5S,EAAGxO,WAAWwhB,GAAKhU,cAAc,GACjCiB,EAAGvT,SAAS8lB,GAAMxT,cAAc,EAAI4T,GACpCI,EAAItmB,SAAS6lB,GAAMvT,cAAc,EAAI2T,GACrC1S,EAAGzO,WAAWwhB,GAAKhU,cAAc,GAEjC,IAAIiU,EAAQzH,EAAQvB,QAAQ,GAE5BgJ,EAAMvmB,SAASsd,GAAMnC,gBAAgBwB,GACrCY,EAAQ4D,WAAW9N,EAAIkT,EAAOD,GAE9B,IAAIE,EADEjJ,EAAQrB,IAAIoK,EAAK/f,GAEvBggB,EAAMvmB,SAASsd,GAAMnC,gBAAgBjH,GACrCqJ,EAAQ4D,WAAW7N,EAAIiT,EAAOD,GAE9B,IAAIG,EADElJ,EAAQrB,IAAIoK,EAAK/f,GAEvBggB,EAAMvmB,SAASsd,GAAMnC,gBAAgB/G,GACrCmJ,EAAQ4D,WAAW5N,EAAIgT,EAAOD,GAE9B,IAEII,EAAIC,EAFJC,EADErJ,EAAQrB,IAAIoK,EAAK/f,GAEnBsgB,EAAO/H,EAAQvB,QAAQ,IAEvBiJ,EAAK,GAAKC,EAAK,GACfI,EAAK7mB,SAAS4lB,GACdc,EAAK/J,EACLgK,EAAKzS,GAEAuS,EAAK,GAAKG,EAAK,GACpBC,EAAK7mB,SAAS8lB,GACdY,EAAKxS,EACLyS,EAAKvS,IAGLyS,EAAK7mB,SAAS6lB,GAAMvT,cAAc,GAClCoU,EAAKtS,EACLuS,EAAKhK,GAGT,IAAImK,EAAOhI,EAAQvB,QAAQ,GACvBwJ,EAAOjI,EAAQvB,QAAQ,GAM3B,GALAmJ,EAAG5mB,cAAcwd,EAAMgJ,GACvBK,EAAG7mB,cAAcwd,EAAMwJ,GACvBvJ,EAAQ4D,WAAWmF,EAAKQ,EAAMC,KACdxJ,EAAQrB,IAAI6K,EAAMxgB,GAAU,GAIxC,OADA0W,EAAIjd,SAASsd,GACNhd,KAAKsB,IAAIiP,EAAIuV,GAGxB,IAAIzoB,EAAImhB,EAAQvB,QAAQ,GACxBA,EAAQ4D,WAAW0F,EAAME,EAAMppB,GAC/BA,EAAEgJ,YACF,IAAIqgB,EAASlI,EAAQvB,QAAQ,GAC7ByJ,EAAOhnB,SAAS0mB,GAAIvL,gBAAgBmC,GACpC,IAAI2J,EAAUD,EAAO/kB,SACrB,GAAIglB,EAAU,KAGV,OADAhK,EAAIjd,SAAS0mB,GACNnJ,EAAQV,SAASV,EAAQuK,GAEpCM,EAAOxH,oBAAoByH,GAC3B,IAAIC,EAAO3J,EAAQrB,IAAIve,EAAGqpB,GACtBG,EAAUrI,EAAQvB,QAAQ,GAC9B4J,EAAQnnB,SAASsd,GAAMxY,WAAWnH,EAAE2U,aAAa2U,EAAUC,IAE3DZ,EAAItmB,SAASmnB,GAAShM,gBAAgBuL,GACtC7V,EAAIgW,EAAK5kB,SACT4kB,EAAKrH,oBAAoB3O,GACzB,IAAIxH,EAAIkU,EAAQrB,IAAIoK,EAAKO,GAAQvmB,KAAKZ,IAAImR,EAAG,MAI7C,OAHAxH,EAAI,UAAaA,EAAG,EAAG,GACvB8d,EAAQnnB,SAAS0mB,GAAI5hB,WAAW+hB,EAAKvU,aAAajJ,EAAIwH,IACtDoM,EAAIjd,SAASmnB,GACN5J,EAAQV,SAASV,EAAQgL,IAQpC5J,EAAQR,OAAS,SAAUla,EAAQE,GAC/B,OAAOwa,EAAQP,YAAYna,EAAQE,EAAQwa,EAAQtU,SASvDsU,EAAQP,YAAc,SAAUna,EAAQE,EAAQka,GAC5C,OAAOA,EAAI/c,gBAAgB2C,EAAO4a,GAAK1a,EAAO0a,IAAM,GAAI5a,EAAO6a,GAAK3a,EAAO2a,IAAM,GAAI7a,EAAO8a,GAAK5a,EAAO4a,IAAM,IAalHJ,EAAQ6J,iBAAmB,SAAUC,EAAOC,EAAOC,GAC/C,IAAIC,EAAWjK,EAAQtU,OAEvB,OADAsU,EAAQkK,sBAAsBJ,EAAOC,EAAOC,EAAOC,GAC5CA,GASXjK,EAAQkK,sBAAwB,SAAUJ,EAAOC,EAAOC,EAAOtK,GAC3D,IAAIyK,EAAO5I,EAAQjB,WAAW,GAC9BA,EAAW8J,gCAAgCN,EAAOC,EAAOC,EAAOG,GAChEA,EAAKE,mBAAmB3K,IAE5BM,EAAQkF,YAAclF,EAAQiF,KAC9BjF,EAAQqF,2BAA6BrF,EAAQyF,SAAQ,GACrDzF,EAAQsF,4BAA8BtF,EAAQyF,SAAQ,GACtDzF,EAAQmF,eAAiBnF,EAAQ4F,QACjC5F,EAAQoF,cAAgBpF,EAAQ6F,OAChC7F,EAAQuF,cAAgBvF,EAAQtU,OACzBsU,EAtkDiB,GA4kDxBsK,EAAyB,WAQzB,SAASA,EAETlmB,EAEA6E,EAEAC,EAEAmU,GACI9c,KAAK6D,EAAIA,EACT7D,KAAK0I,EAAIA,EACT1I,KAAK2I,EAAIA,EACT3I,KAAK8c,EAAIA,EAytBb,OAntBAiN,EAAQ9pB,UAAUC,SAAW,WACzB,MAAO,OAAOyc,OAAO3c,KAAK6D,EAAG,QAAQ8Y,OAAO3c,KAAK0I,EAAG,QAAQiU,OAAO3c,KAAK2I,EAAG,QAAQgU,OAAO3c,KAAK8c,EAAG,MAMtGiN,EAAQ9pB,UAAUE,aAAe,WAC7B,MAAO,WAMX4pB,EAAQ9pB,UAAUG,YAAc,WAC5B,IAIIC,EAJI2c,EAAchd,KAAK6D,GAQ3B,OADAxD,EAAe,KADfA,EAAe,KADfA,EAAe,IAAPA,EAJA2c,EAAchd,KAAK0I,IACnBsU,EAAchd,KAAK2I,IACnBqU,EAAchd,KAAK8c,IAY/BiN,EAAQ9pB,UAAUc,QAAU,WACxB,IAAIK,EAAS,IAAI8I,MAEjB,OADAlK,KAAKM,QAAQc,EAAQ,GACdA,GAQX2oB,EAAQ9pB,UAAUK,QAAU,SAAUC,EAAOC,GAQzC,YAPcwpB,IAAVxpB,IACAA,EAAQ,GAEZD,EAAMC,GAASR,KAAK6D,EACpBtD,EAAMC,EAAQ,GAAKR,KAAK0I,EACxBnI,EAAMC,EAAQ,GAAKR,KAAK2I,EACxBpI,EAAMC,EAAQ,GAAKR,KAAK8c,EACjB9c,MAQX+pB,EAAQ9pB,UAAUQ,UAAY,SAAUF,EAAOC,GAG3C,YAFc,IAAVA,IAAoBA,EAAQ,GAChCupB,EAAQppB,eAAeJ,EAAOC,EAAOR,MAC9BA,MAOX+pB,EAAQ9pB,UAAU+G,WAAa,SAAUmW,GAKrC,OAJAnd,KAAK6D,GAAKsZ,EAAYtZ,EACtB7D,KAAK0I,GAAKyU,EAAYzU,EACtB1I,KAAK2I,GAAKwU,EAAYxU,EACtB3I,KAAK8c,GAAKK,EAAYL,EACf9c,MAOX+pB,EAAQ9pB,UAAU4B,IAAM,SAAUsb,GAC9B,OAAO,IAAI4M,EAAQ/pB,KAAK6D,EAAIsZ,EAAYtZ,EAAG7D,KAAK0I,EAAIyU,EAAYzU,EAAG1I,KAAK2I,EAAIwU,EAAYxU,EAAG3I,KAAK8c,EAAIK,EAAYL,IAQpHiN,EAAQ9pB,UAAU6B,SAAW,SAAUqb,EAAa/b,GAKhD,OAJAA,EAAOyC,EAAI7D,KAAK6D,EAAIsZ,EAAYtZ,EAChCzC,EAAOsH,EAAI1I,KAAK0I,EAAIyU,EAAYzU,EAChCtH,EAAOuH,EAAI3I,KAAK2I,EAAIwU,EAAYxU,EAChCvH,EAAO0b,EAAI9c,KAAK8c,EAAIK,EAAYL,EACzB9c,MAOX+pB,EAAQ9pB,UAAUod,gBAAkB,SAAUF,GAK1C,OAJAnd,KAAK6D,GAAKsZ,EAAYtZ,EACtB7D,KAAK0I,GAAKyU,EAAYzU,EACtB1I,KAAK2I,GAAKwU,EAAYxU,EACtB3I,KAAK8c,GAAKK,EAAYL,EACf9c,MAOX+pB,EAAQ9pB,UAAU8B,SAAW,SAAUob,GACnC,OAAO,IAAI4M,EAAQ/pB,KAAK6D,EAAIsZ,EAAYtZ,EAAG7D,KAAK0I,EAAIyU,EAAYzU,EAAG1I,KAAK2I,EAAIwU,EAAYxU,EAAG3I,KAAK8c,EAAIK,EAAYL,IAQpHiN,EAAQ9pB,UAAU+B,cAAgB,SAAUmb,EAAa/b,GAKrD,OAJAA,EAAOyC,EAAI7D,KAAK6D,EAAIsZ,EAAYtZ,EAChCzC,EAAOsH,EAAI1I,KAAK0I,EAAIyU,EAAYzU,EAChCtH,EAAOuH,EAAI3I,KAAK2I,EAAIwU,EAAYxU,EAChCvH,EAAO0b,EAAI9c,KAAK8c,EAAIK,EAAYL,EACzB9c,MAaX+pB,EAAQ9pB,UAAUkgB,mBAAqB,SAAUtc,EAAG6E,EAAGC,EAAGmU,GACtD,OAAO,IAAIiN,EAAQ/pB,KAAK6D,EAAIA,EAAG7D,KAAK0I,EAAIA,EAAG1I,KAAK2I,EAAIA,EAAG3I,KAAK8c,EAAIA,IAWpEiN,EAAQ9pB,UAAUigB,wBAA0B,SAAUrc,EAAG6E,EAAGC,EAAGmU,EAAG1b,GAK9D,OAJAA,EAAOyC,EAAI7D,KAAK6D,EAAIA,EACpBzC,EAAOsH,EAAI1I,KAAK0I,EAAIA,EACpBtH,EAAOuH,EAAI3I,KAAK2I,EAAIA,EACpBvH,EAAO0b,EAAI9c,KAAK8c,EAAIA,EACb9c,MAMX+pB,EAAQ9pB,UAAUyd,OAAS,WACvB,OAAO,IAAIqM,GAAS/pB,KAAK6D,GAAI7D,KAAK0I,GAAI1I,KAAK2I,GAAI3I,KAAK8c,IAMxDiN,EAAQ9pB,UAAU0d,cAAgB,WAK9B,OAJA3d,KAAK6D,IAAM,EACX7D,KAAK0I,IAAM,EACX1I,KAAK2I,IAAM,EACX3I,KAAK8c,IAAM,EACJ9c,MAOX+pB,EAAQ9pB,UAAU2d,YAAc,SAAUxc,GACtC,OAAOA,EAAOgB,gBAAyB,EAAVpC,KAAK6D,GAAkB,EAAV7D,KAAK0I,GAAkB,EAAV1I,KAAK2I,GAAkB,EAAV3I,KAAK8c,IAO7EiN,EAAQ9pB,UAAUuU,aAAe,SAAUjT,GAKvC,OAJAvB,KAAK6D,GAAKtC,EACVvB,KAAK0I,GAAKnH,EACVvB,KAAK2I,GAAKpH,EACVvB,KAAK8c,GAAKvb,EACHvB,MAOX+pB,EAAQ9pB,UAAUsB,MAAQ,SAAUA,GAChC,OAAO,IAAIwoB,EAAQ/pB,KAAK6D,EAAItC,EAAOvB,KAAK0I,EAAInH,EAAOvB,KAAK2I,EAAIpH,EAAOvB,KAAK8c,EAAIvb,IAQhFwoB,EAAQ9pB,UAAUuB,WAAa,SAAUD,EAAOH,GAK5C,OAJAA,EAAOyC,EAAI7D,KAAK6D,EAAItC,EACpBH,EAAOsH,EAAI1I,KAAK0I,EAAInH,EACpBH,EAAOuH,EAAI3I,KAAK2I,EAAIpH,EACpBH,EAAO0b,EAAI9c,KAAK8c,EAAIvb,EACbvB,MAQX+pB,EAAQ9pB,UAAUwB,iBAAmB,SAAUF,EAAOH,GAKlD,OAJAA,EAAOyC,GAAK7D,KAAK6D,EAAItC,EACrBH,EAAOsH,GAAK1I,KAAK0I,EAAInH,EACrBH,EAAOuH,GAAK3I,KAAK2I,EAAIpH,EACrBH,EAAO0b,GAAK9c,KAAK8c,EAAIvb,EACdvB,MAOX+pB,EAAQ9pB,UAAUoB,OAAS,SAAU8b,GACjC,OAAOA,GAAend,KAAK6D,IAAMsZ,EAAYtZ,GAAK7D,KAAK0I,IAAMyU,EAAYzU,GAAK1I,KAAK2I,IAAMwU,EAAYxU,GAAK3I,KAAK8c,IAAMK,EAAYL,GAQrIiN,EAAQ9pB,UAAUkY,kBAAoB,SAAUgF,EAAavD,GAEzD,YADgB,IAAZA,IAAsBA,EAAU,MAC5BuD,GACJ,kBAAqBnd,KAAK6D,EAAGsZ,EAAYtZ,EAAG+V,IAC5C,kBAAqB5Z,KAAK0I,EAAGyU,EAAYzU,EAAGkR,IAC5C,kBAAqB5Z,KAAK2I,EAAGwU,EAAYxU,EAAGiR,IAC5C,kBAAqB5Z,KAAK8c,EAAGK,EAAYL,EAAGlD,IAUpDmQ,EAAQ9pB,UAAUkhB,eAAiB,SAAUtd,EAAG6E,EAAGC,EAAGmU,GAClD,OAAO9c,KAAK6D,IAAMA,GAAK7D,KAAK0I,IAAMA,GAAK1I,KAAK2I,IAAMA,GAAK3I,KAAK8c,IAAMA,GAOtEiN,EAAQ9pB,UAAUqd,gBAAkB,SAAUH,GAK1C,OAJAnd,KAAK6D,GAAKsZ,EAAYtZ,EACtB7D,KAAK0I,GAAKyU,EAAYzU,EACtB1I,KAAK2I,GAAKwU,EAAYxU,EACtB3I,KAAK8c,GAAKK,EAAYL,EACf9c,MAOX+pB,EAAQ9pB,UAAUgB,SAAW,SAAUkc,GACnC,OAAO,IAAI4M,EAAQ/pB,KAAK6D,EAAIsZ,EAAYtZ,EAAG7D,KAAK0I,EAAIyU,EAAYzU,EAAG1I,KAAK2I,EAAIwU,EAAYxU,EAAG3I,KAAK8c,EAAIK,EAAYL,IAQpHiN,EAAQ9pB,UAAUkB,cAAgB,SAAUgc,EAAa/b,GAKrD,OAJAA,EAAOyC,EAAI7D,KAAK6D,EAAIsZ,EAAYtZ,EAChCzC,EAAOsH,EAAI1I,KAAK0I,EAAIyU,EAAYzU,EAChCtH,EAAOuH,EAAI3I,KAAK2I,EAAIwU,EAAYxU,EAChCvH,EAAO0b,EAAI9c,KAAK8c,EAAIK,EAAYL,EACzB9c,MAUX+pB,EAAQ9pB,UAAU4c,iBAAmB,SAAUhZ,EAAG6E,EAAGC,EAAGmU,GACpD,OAAO,IAAIiN,EAAQ/pB,KAAK6D,EAAIA,EAAG7D,KAAK0I,EAAIA,EAAG1I,KAAK2I,EAAIA,EAAG3I,KAAK8c,EAAIA,IAOpEiN,EAAQ9pB,UAAUsd,OAAS,SAAUJ,GACjC,OAAO,IAAI4M,EAAQ/pB,KAAK6D,EAAIsZ,EAAYtZ,EAAG7D,KAAK0I,EAAIyU,EAAYzU,EAAG1I,KAAK2I,EAAIwU,EAAYxU,EAAG3I,KAAK8c,EAAIK,EAAYL,IAQpHiN,EAAQ9pB,UAAUud,YAAc,SAAUL,EAAa/b,GAKnD,OAJAA,EAAOyC,EAAI7D,KAAK6D,EAAIsZ,EAAYtZ,EAChCzC,EAAOsH,EAAI1I,KAAK0I,EAAIyU,EAAYzU,EAChCtH,EAAOuH,EAAI3I,KAAK2I,EAAIwU,EAAYxU,EAChCvH,EAAO0b,EAAI9c,KAAK8c,EAAIK,EAAYL,EACzB9c,MAOX+pB,EAAQ9pB,UAAUwd,cAAgB,SAAUN,GACxC,OAAOnd,KAAKwd,YAAYL,EAAand,OAOzC+pB,EAAQ9pB,UAAUmhB,gBAAkB,SAAU1W,GAa1C,OAZIA,EAAM7G,EAAI7D,KAAK6D,IACf7D,KAAK6D,EAAI6G,EAAM7G,GAEf6G,EAAMhC,EAAI1I,KAAK0I,IACf1I,KAAK0I,EAAIgC,EAAMhC,GAEfgC,EAAM/B,EAAI3I,KAAK2I,IACf3I,KAAK2I,EAAI+B,EAAM/B,GAEf+B,EAAMoS,EAAI9c,KAAK8c,IACf9c,KAAK8c,EAAIpS,EAAMoS,GAEZ9c,MAOX+pB,EAAQ9pB,UAAUohB,gBAAkB,SAAU3W,GAa1C,OAZIA,EAAM7G,EAAI7D,KAAK6D,IACf7D,KAAK6D,EAAI6G,EAAM7G,GAEf6G,EAAMhC,EAAI1I,KAAK0I,IACf1I,KAAK0I,EAAIgC,EAAMhC,GAEfgC,EAAM/B,EAAI3I,KAAK2I,IACf3I,KAAK2I,EAAI+B,EAAM/B,GAEf+B,EAAMoS,EAAI9c,KAAK8c,IACf9c,KAAK8c,EAAIpS,EAAMoS,GAEZ9c,MAMX+pB,EAAQ9pB,UAAUuK,MAAQ,WACtB,OAAO,IAAIuf,EAAQvnB,KAAKgI,MAAMxK,KAAK6D,GAAIrB,KAAKgI,MAAMxK,KAAK0I,GAAIlG,KAAKgI,MAAMxK,KAAK2I,GAAInG,KAAKgI,MAAMxK,KAAK8c,KAMnGiN,EAAQ9pB,UAAU4d,MAAQ,WACtB,OAAO,IAAIkM,EAAQ/pB,KAAK6D,EAAIrB,KAAKgI,MAAMxK,KAAK6D,GAAI7D,KAAK0I,EAAIlG,KAAKgI,MAAMxK,KAAK0I,GAAI1I,KAAK2I,EAAInG,KAAKgI,MAAMxK,KAAK2I,GAAI3I,KAAK8c,EAAIta,KAAKgI,MAAMxK,KAAK8c,KAOvIiN,EAAQ9pB,UAAUkE,OAAS,WACvB,OAAO3B,KAAKuF,KAAK/H,KAAK6D,EAAI7D,KAAK6D,EAAI7D,KAAK0I,EAAI1I,KAAK0I,EAAI1I,KAAK2I,EAAI3I,KAAK2I,EAAI3I,KAAK8c,EAAI9c,KAAK8c,IAMzFiN,EAAQ9pB,UAAUyX,cAAgB,WAC9B,OAAO1X,KAAK6D,EAAI7D,KAAK6D,EAAI7D,KAAK0I,EAAI1I,KAAK0I,EAAI1I,KAAK2I,EAAI3I,KAAK2I,EAAI3I,KAAK8c,EAAI9c,KAAK8c,GAO/EiN,EAAQ9pB,UAAU4I,UAAY,WAC1B,IAAI0V,EAAMve,KAAKmE,SACf,OAAY,IAARoa,EACOve,KAEJA,KAAKwU,aAAa,EAAM+J,IAMnCwL,EAAQ9pB,UAAUgqB,UAAY,WAC1B,OAAO,IAAIxK,EAAQzf,KAAK6D,EAAG7D,KAAK0I,EAAG1I,KAAK2I,IAM5CohB,EAAQ9pB,UAAUgC,MAAQ,WACtB,OAAO,IAAI8nB,EAAQ/pB,KAAK6D,EAAG7D,KAAK0I,EAAG1I,KAAK2I,EAAG3I,KAAK8c,IAOpDiN,EAAQ9pB,UAAUiC,SAAW,SAAUC,GAKnC,OAJAnC,KAAK6D,EAAI1B,EAAO0B,EAChB7D,KAAK0I,EAAIvG,EAAOuG,EAChB1I,KAAK2I,EAAIxG,EAAOwG,EAChB3I,KAAK8c,EAAI3a,EAAO2a,EACT9c,MAUX+pB,EAAQ9pB,UAAUmC,eAAiB,SAAUyB,EAAG6E,EAAGC,EAAGmU,GAKlD,OAJA9c,KAAK6D,EAAIA,EACT7D,KAAK0I,EAAIA,EACT1I,KAAK2I,EAAIA,EACT3I,KAAK8c,EAAIA,EACF9c,MAUX+pB,EAAQ9pB,UAAUoC,IAAM,SAAUwB,EAAG6E,EAAGC,EAAGmU,GACvC,OAAO9c,KAAKoC,eAAeyB,EAAG6E,EAAGC,EAAGmU,IAOxCiN,EAAQ9pB,UAAU0iB,OAAS,SAAUxf,GAEjC,OADAnD,KAAK6D,EAAI7D,KAAK0I,EAAI1I,KAAK2I,EAAI3I,KAAK8c,EAAI3Z,EAC7BnD,MASX+pB,EAAQzlB,UAAY,SAAU/D,EAAOG,GAIjC,OAHKA,IACDA,EAAS,GAEN,IAAIqpB,EAAQxpB,EAAMG,GAASH,EAAMG,EAAS,GAAIH,EAAMG,EAAS,GAAIH,EAAMG,EAAS,KAQ3FqpB,EAAQppB,eAAiB,SAAUJ,EAAOG,EAAQU,GAC9CA,EAAOyC,EAAItD,EAAMG,GACjBU,EAAOsH,EAAInI,EAAMG,EAAS,GAC1BU,EAAOuH,EAAIpI,EAAMG,EAAS,GAC1BU,EAAO0b,EAAIvc,EAAMG,EAAS,IAQ9BqpB,EAAQvF,oBAAsB,SAAUjkB,EAAOG,EAAQU,GACnD2oB,EAAQppB,eAAeJ,EAAOG,EAAQU,IAU1C2oB,EAAQtF,gBAAkB,SAAU5gB,EAAG6E,EAAGC,EAAGmU,EAAG1b,GAC5CA,EAAOyC,EAAIA,EACXzC,EAAOsH,EAAIA,EACXtH,EAAOuH,EAAIA,EACXvH,EAAO0b,EAAIA,GAMfiN,EAAQ5e,KAAO,WACX,OAAO,IAAI4e,EAAQ,EAAK,EAAK,EAAK,IAMtCA,EAAQ/L,IAAM,WACV,OAAO,IAAI+L,EAAQ,EAAK,EAAK,EAAK,IAOtCA,EAAQ/O,UAAY,SAAUqD,GAC1B,IAAIjd,EAAS2oB,EAAQ5e,OAErB,OADA4e,EAAQhM,eAAeM,EAAQjd,GACxBA,GAOX2oB,EAAQhM,eAAiB,SAAUM,EAAQjd,GACvCA,EAAOc,SAASmc,GAChBjd,EAAOyH,aAQXkhB,EAAQvL,SAAW,SAAU5Z,EAAMC,GAC/B,IAAIlD,EAAMiD,EAAK3C,QAEf,OADAN,EAAIyf,gBAAgBvc,GACblD,GAQXooB,EAAQtL,SAAW,SAAU7Z,EAAMC,GAC/B,IAAIjD,EAAMgD,EAAK3C,QAEf,OADAL,EAAIyf,gBAAgBxc,GACbjD,GAQXmoB,EAAQhL,SAAW,SAAUha,EAAQE,GACjC,OAAOzC,KAAKuF,KAAKgiB,EAAQ/K,gBAAgBja,EAAQE,KAQrD8kB,EAAQ/K,gBAAkB,SAAUja,EAAQE,GACxC,IAAIpB,EAAIkB,EAAOlB,EAAIoB,EAAOpB,EACtB6E,EAAI3D,EAAO2D,EAAIzD,EAAOyD,EACtBC,EAAI5D,EAAO4D,EAAI1D,EAAO0D,EACtBmU,EAAI/X,EAAO+X,EAAI7X,EAAO6X,EAC1B,OAAOjZ,EAAIA,EAAI6E,EAAIA,EAAIC,EAAIA,EAAImU,EAAIA,GAQvCiN,EAAQ9K,OAAS,SAAUla,EAAQE,GAC/B,OAAO8kB,EAAQ7K,YAAYna,EAAQE,EAAQ8kB,EAAQ5e,SASvD4e,EAAQ7K,YAAc,SAAUna,EAAQE,EAAQka,GAC5C,OAAOA,EAAI/c,gBAAgB2C,EAAOlB,EAAIoB,EAAOpB,GAAK,GAAIkB,EAAO2D,EAAIzD,EAAOyD,GAAK,GAAI3D,EAAO4D,EAAI1D,EAAO0D,GAAK,GAAI5D,EAAO+X,EAAI7X,EAAO6X,GAAK,IAUvIiN,EAAQxE,qBAAuB,SAAUlH,EAAQ3F,GAC7C,IAAItX,EAAS2oB,EAAQ5e,OAErB,OADA4e,EAAQ3H,0BAA0B/D,EAAQ3F,EAAgBtX,GACnDA,GAUX2oB,EAAQ3H,0BAA4B,SAAU/D,EAAQ3F,EAAgBtX,GAClE2oB,EAAQvE,oCAAoCnH,EAAOsB,GAAItB,EAAOuB,GAAIvB,EAAOwB,GAAInH,EAAgBtX,IAYjG2oB,EAAQvE,oCAAsC,SAAU3hB,EAAG6E,EAAGC,EAAG+P,EAAgBtX,GAC7E,IAAI2C,EAAI2U,EAAe3U,EACnB0hB,EAAK5hB,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GAAKA,EAAE,IACxC2hB,EAAK7hB,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GAAKA,EAAE,IACxC4hB,EAAK9hB,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,IAAMA,EAAE,IACzC6hB,EAAK/hB,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,IAAMA,EAAE,IAC7C3C,EAAOyC,EAAI4hB,EACXrkB,EAAOsH,EAAIgd,EACXtkB,EAAOuH,EAAIgd,EACXvkB,EAAO0b,EAAI8I,GASfmE,EAAQlE,gBAAkB,SAAUxH,EAAQ3F,GACxC,IAAItX,EAAS2oB,EAAQ5e,OAErB,OADA4e,EAAQjE,qBAAqBzH,EAAQ3F,EAAgBtX,GAC9CA,GASX2oB,EAAQjE,qBAAuB,SAAUzH,EAAQ3F,EAAgBtX,GAC7D,IAAI2C,EAAI2U,EAAe3U,EACnBF,EAAIwa,EAAOxa,EAAIE,EAAE,GAAKsa,EAAO3V,EAAI3E,EAAE,GAAKsa,EAAO1V,EAAI5E,EAAE,GACrD2E,EAAI2V,EAAOxa,EAAIE,EAAE,GAAKsa,EAAO3V,EAAI3E,EAAE,GAAKsa,EAAO1V,EAAI5E,EAAE,GACrD4E,EAAI0V,EAAOxa,EAAIE,EAAE,GAAKsa,EAAO3V,EAAI3E,EAAE,GAAKsa,EAAO1V,EAAI5E,EAAE,IACzD3C,EAAOyC,EAAIA,EACXzC,EAAOsH,EAAIA,EACXtH,EAAOuH,EAAIA,EACXvH,EAAO0b,EAAIuB,EAAOvB,GAYtBiN,EAAQhE,+BAAiC,SAAUliB,EAAG6E,EAAGC,EAAGmU,EAAGpE,EAAgBtX,GAC3E,IAAI2C,EAAI2U,EAAe3U,EACvB3C,EAAOyC,EAAIA,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GACvC3C,EAAOsH,EAAI7E,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,GACvC3C,EAAOuH,EAAI9E,EAAIE,EAAE,GAAK2E,EAAI3E,EAAE,GAAK4E,EAAI5E,EAAE,IACvC3C,EAAO0b,EAAIA,GAQfiN,EAAQG,YAAc,SAAU/nB,EAAQ2a,GAEpC,YADU,IAANA,IAAgBA,EAAI,GACjB,IAAIiN,EAAQ5nB,EAAOwd,GAAIxd,EAAOyd,GAAIzd,EAAO0d,GAAI/C,IAEjDiN,EA7uBiB,GAqvBxBhK,EAA4B,WAQ5B,SAASA,EAAWlc,EAAG6E,EAAGC,EAAGmU,QACf,IAANjZ,IAAgBA,EAAI,QACd,IAAN6E,IAAgBA,EAAI,QACd,IAANC,IAAgBA,EAAI,QACd,IAANmU,IAAgBA,EAAI,GAExB9c,KAAK0f,UAAW,EAChB1f,KAAK2f,GAAK9b,EACV7D,KAAK4f,GAAKlX,EACV1I,KAAK6f,GAAKlX,EACV3I,KAAKmqB,GAAKrN,EAi4Bd,OA/3BA7W,OAAOC,eAAe6Z,EAAW9f,UAAW,IAAK,CAE7CkG,IAAK,WACD,OAAOnG,KAAK2f,IAEhBtd,IAAK,SAAUsB,GACX3D,KAAK2f,GAAKhc,EACV3D,KAAK0f,UAAW,GAEpBrZ,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe6Z,EAAW9f,UAAW,IAAK,CAE7CkG,IAAK,WACD,OAAOnG,KAAK4f,IAEhBvd,IAAK,SAAUsB,GACX3D,KAAK4f,GAAKjc,EACV3D,KAAK0f,UAAW,GAEpBrZ,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe6Z,EAAW9f,UAAW,IAAK,CAE7CkG,IAAK,WACD,OAAOnG,KAAK6f,IAEhBxd,IAAK,SAAUsB,GACX3D,KAAK6f,GAAKlc,EACV3D,KAAK0f,UAAW,GAEpBrZ,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe6Z,EAAW9f,UAAW,IAAK,CAE7CkG,IAAK,WACD,OAAOnG,KAAKmqB,IAEhB9nB,IAAK,SAAUsB,GACX3D,KAAKmqB,GAAKxmB,EACV3D,KAAK0f,UAAW,GAEpBrZ,YAAY,EACZC,cAAc,IAMlByZ,EAAW9f,UAAUC,SAAW,WAC5B,MAAO,OAAOyc,OAAO3c,KAAK2f,GAAI,QAAQhD,OAAO3c,KAAK4f,GAAI,QAAQjD,OAAO3c,KAAK6f,GAAI,QAAQlD,OAAO3c,KAAKmqB,GAAI,MAM1GpK,EAAW9f,UAAUE,aAAe,WAChC,MAAO,cAMX4f,EAAW9f,UAAUG,YAAc,WAC/B,IAIIC,EAJI2c,EAAchd,KAAK2f,IAQ3B,OADAtf,EAAe,KADfA,EAAe,KADfA,EAAe,IAAPA,EAJA2c,EAAchd,KAAK4f,KACnB5C,EAAchd,KAAK6f,KACnB7C,EAAchd,KAAKmqB,KAW/BpK,EAAW9f,UAAUc,QAAU,WAC3B,MAAO,CAACf,KAAK2f,GAAI3f,KAAK4f,GAAI5f,KAAK6f,GAAI7f,KAAKmqB,KAO5CpK,EAAW9f,UAAUoB,OAAS,SAAU+oB,GACpC,OAAOA,GAAmBpqB,KAAK2f,KAAOyK,EAAgBzK,IAAM3f,KAAK4f,KAAOwK,EAAgBxK,IAAM5f,KAAK6f,KAAOuK,EAAgBvK,IAAM7f,KAAKmqB,KAAOC,EAAgBD,IAQhKpK,EAAW9f,UAAUkY,kBAAoB,SAAUiS,EAAiBxQ,GAEhE,YADgB,IAAZA,IAAsBA,EAAU,MAC5BwQ,GACJ,kBAAqBpqB,KAAK2f,GAAIyK,EAAgBzK,GAAI/F,IAClD,kBAAqB5Z,KAAK4f,GAAIwK,EAAgBxK,GAAIhG,IAClD,kBAAqB5Z,KAAK6f,GAAIuK,EAAgBvK,GAAIjG,IAClD,kBAAqB5Z,KAAKmqB,GAAIC,EAAgBD,GAAIvQ,IAM1DmG,EAAW9f,UAAUgC,MAAQ,WACzB,OAAO,IAAI8d,EAAW/f,KAAK2f,GAAI3f,KAAK4f,GAAI5f,KAAK6f,GAAI7f,KAAKmqB,KAO1DpK,EAAW9f,UAAUiC,SAAW,SAAUwI,GAKtC,OAJA1K,KAAK6D,EAAI6G,EAAMiV,GACf3f,KAAK0I,EAAIgC,EAAMkV,GACf5f,KAAK2I,EAAI+B,EAAMmV,GACf7f,KAAK8c,EAAIpS,EAAMyf,GACRnqB,MAUX+f,EAAW9f,UAAUmC,eAAiB,SAAUyB,EAAG6E,EAAGC,EAAGmU,GAKrD,OAJA9c,KAAK6D,EAAIA,EACT7D,KAAK0I,EAAIA,EACT1I,KAAK2I,EAAIA,EACT3I,KAAK8c,EAAIA,EACF9c,MAUX+f,EAAW9f,UAAUoC,IAAM,SAAUwB,EAAG6E,EAAGC,EAAGmU,GAC1C,OAAO9c,KAAKoC,eAAeyB,EAAG6E,EAAGC,EAAGmU,IAOxCiD,EAAW9f,UAAU4B,IAAM,SAAU6I,GACjC,OAAO,IAAIqV,EAAW/f,KAAK2f,GAAKjV,EAAMiV,GAAI3f,KAAK4f,GAAKlV,EAAMkV,GAAI5f,KAAK6f,GAAKnV,EAAMmV,GAAI7f,KAAKmqB,GAAKzf,EAAMyf,KAOtGpK,EAAW9f,UAAU+G,WAAa,SAAU0D,GAKxC,OAJA1K,KAAK2f,IAAMjV,EAAMiV,GACjB3f,KAAK4f,IAAMlV,EAAMkV,GACjB5f,KAAK6f,IAAMnV,EAAMmV,GACjB7f,KAAKmqB,IAAMzf,EAAMyf,GACVnqB,MAOX+f,EAAW9f,UAAU8B,SAAW,SAAU2I,GACtC,OAAO,IAAIqV,EAAW/f,KAAK2f,GAAKjV,EAAMiV,GAAI3f,KAAK4f,GAAKlV,EAAMkV,GAAI5f,KAAK6f,GAAKnV,EAAMmV,GAAI7f,KAAKmqB,GAAKzf,EAAMyf,KAOtGpK,EAAW9f,UAAUod,gBAAkB,SAAU3S,GAK7C,OAJA1K,KAAK2f,IAAMjV,EAAMiV,GACjB3f,KAAK4f,IAAMlV,EAAMkV,GACjB5f,KAAK6f,IAAMnV,EAAMmV,GACjB7f,KAAKmqB,IAAMzf,EAAMyf,GACVnqB,MAOX+f,EAAW9f,UAAUsB,MAAQ,SAAUoC,GACnC,OAAO,IAAIoc,EAAW/f,KAAK2f,GAAKhc,EAAO3D,KAAK4f,GAAKjc,EAAO3D,KAAK6f,GAAKlc,EAAO3D,KAAKmqB,GAAKxmB,IAQvFoc,EAAW9f,UAAUuB,WAAa,SAAUD,EAAOH,GAK/C,OAJAA,EAAOyC,EAAI7D,KAAK2f,GAAKpe,EACrBH,EAAOsH,EAAI1I,KAAK4f,GAAKre,EACrBH,EAAOuH,EAAI3I,KAAK6f,GAAKte,EACrBH,EAAO0b,EAAI9c,KAAKmqB,GAAK5oB,EACdvB,MAOX+f,EAAW9f,UAAUuU,aAAe,SAAU7Q,GAK1C,OAJA3D,KAAK6D,GAAKF,EACV3D,KAAK0I,GAAK/E,EACV3D,KAAK2I,GAAKhF,EACV3D,KAAK8c,GAAKnZ,EACH3D,MAQX+f,EAAW9f,UAAUwB,iBAAmB,SAAUF,EAAOH,GAKrD,OAJAA,EAAOyC,GAAK7D,KAAK2f,GAAKpe,EACtBH,EAAOsH,GAAK1I,KAAK4f,GAAKre,EACtBH,EAAOuH,GAAK3I,KAAK6f,GAAKte,EACtBH,EAAO0b,GAAK9c,KAAKmqB,GAAK5oB,EACfvB,MAOX+f,EAAW9f,UAAUgB,SAAW,SAAUopB,GACtC,IAAIjpB,EAAS,IAAI2e,EAAW,EAAG,EAAG,EAAG,GAErC,OADA/f,KAAKmB,cAAckpB,EAAIjpB,GAChBA,GAQX2e,EAAW9f,UAAUkB,cAAgB,SAAUkpB,EAAIjpB,GAC/C,IAAIyC,EAAI7D,KAAK2f,GAAK0K,EAAGF,GAAKnqB,KAAK4f,GAAKyK,EAAGxK,GAAK7f,KAAK6f,GAAKwK,EAAGzK,GAAK5f,KAAKmqB,GAAKE,EAAG1K,GACvEjX,GAAK1I,KAAK2f,GAAK0K,EAAGxK,GAAK7f,KAAK4f,GAAKyK,EAAGF,GAAKnqB,KAAK6f,GAAKwK,EAAG1K,GAAK3f,KAAKmqB,GAAKE,EAAGzK,GACxEjX,EAAI3I,KAAK2f,GAAK0K,EAAGzK,GAAK5f,KAAK4f,GAAKyK,EAAG1K,GAAK3f,KAAK6f,GAAKwK,EAAGF,GAAKnqB,KAAKmqB,GAAKE,EAAGxK,GACvE/C,GAAK9c,KAAK2f,GAAK0K,EAAG1K,GAAK3f,KAAK4f,GAAKyK,EAAGzK,GAAK5f,KAAK6f,GAAKwK,EAAGxK,GAAK7f,KAAKmqB,GAAKE,EAAGF,GAE5E,OADA/oB,EAAOgB,eAAeyB,EAAG6E,EAAGC,EAAGmU,GACxB9c,MAOX+f,EAAW9f,UAAUqd,gBAAkB,SAAU+M,GAE7C,OADArqB,KAAKmB,cAAckpB,EAAIrqB,MAChBA,MAOX+f,EAAW9f,UAAUqqB,eAAiB,SAAUnL,GAE5C,OADAA,EAAI/c,gBAAgBpC,KAAK2f,IAAK3f,KAAK4f,IAAK5f,KAAK6f,GAAI7f,KAAKmqB,IAC/CnqB,MAMX+f,EAAW9f,UAAUsqB,iBAAmB,WAIpC,OAHAvqB,KAAK6D,IAAM,EACX7D,KAAK0I,IAAM,EACX1I,KAAK2I,IAAM,EACJ3I,MAMX+f,EAAW9f,UAAUuqB,UAAY,WAC7B,OAAO,IAAIzK,GAAY/f,KAAK2f,IAAK3f,KAAK4f,IAAK5f,KAAK6f,GAAI7f,KAAKmqB,KAM7DpK,EAAW9f,UAAUynB,OAAS,WAC1B,IAAI8C,EAAYxqB,KAAKwqB,YACjB9S,EAAgB1X,KAAK0X,gBACzB,OAAqB,GAAjBA,GAAuC,GAAjBA,GAG1B8S,EAAUhW,aAAa,EAAIkD,GAFhB8S,GASfzK,EAAW9f,UAAUwqB,cAAgB,WACjCzqB,KAAKuqB,mBACL,IAAI7S,EAAgB1X,KAAK0X,gBACzB,OAAqB,GAAjBA,GAAuC,GAAjBA,GAG1B1X,KAAKwU,aAAa,EAAIkD,GAFX1X,MASf+f,EAAW9f,UAAUyX,cAAgB,WACjC,OAAO1X,KAAK2f,GAAK3f,KAAK2f,GAAK3f,KAAK4f,GAAK5f,KAAK4f,GAAK5f,KAAK6f,GAAK7f,KAAK6f,GAAK7f,KAAKmqB,GAAKnqB,KAAKmqB,IAMtFpK,EAAW9f,UAAUkE,OAAS,WAC1B,OAAO3B,KAAKuF,KAAK/H,KAAK0X,kBAM1BqI,EAAW9f,UAAU4I,UAAY,WAC7B,IAAI0V,EAAMve,KAAKmE,SACf,GAAY,IAARoa,EACA,OAAOve,KAEX,IAAI0qB,EAAM,EAAMnM,EAEhB,OADAve,KAAKwU,aAAakW,GACX1qB,MAMX+f,EAAW9f,UAAUuiB,eAAiB,WAClC,IAAIjE,EAAMve,KAAKmE,SACf,GAAY,IAARoa,EACA,OAAOve,KAAKiC,QAEhB,IAAIyoB,EAAM,EAAMnM,EAChB,OAAOve,KAAKuB,MAAMmpB,IAOtB3K,EAAW9f,UAAU0qB,cAAgB,WACjC,IAAIvpB,EAASqe,EAAQtU,OAErB,OADAnL,KAAK8pB,mBAAmB1oB,GACjBA,GAQX2e,EAAW9f,UAAU6pB,mBAAqB,SAAU1oB,GAChD,IAAIwpB,EAAK5qB,KAAK6f,GACVgL,EAAK7qB,KAAK2f,GACVmL,EAAK9qB,KAAK4f,GACVmL,EAAK/qB,KAAKmqB,GACVa,EAASF,EAAKF,EAAKC,EAAKE,EACxBE,EAAQ,SACZ,GAAID,GAAUC,EACV7pB,EAAOsH,EAAI,EAAIlG,KAAKiK,MAAMqe,EAAIC,GAC9B3pB,EAAOyC,EAAIrB,KAAK6J,GAAK,EACrBjL,EAAOuH,EAAI,OAEV,GAAIqiB,EAASC,EACd7pB,EAAOsH,EAAI,EAAIlG,KAAKiK,MAAMqe,EAAIC,GAC9B3pB,EAAOyC,GAAKrB,KAAK6J,GAAK,EACtBjL,EAAOuH,EAAI,MAEV,CACD,IAAIuiB,EAAMH,EAAKA,EACXI,EAAMP,EAAKA,EACXQ,EAAMP,EAAKA,EACXQ,EAAMP,EAAKA,EACf1pB,EAAOuH,EAAInG,KAAKiK,MAAM,GAAOoe,EAAKC,EAAKF,EAAKG,IAAMI,EAAMC,EAAMC,EAAMH,GACpE9pB,EAAOyC,EAAIrB,KAAK8oB,MAAM,EAAMN,GAC5B5pB,EAAOsH,EAAIlG,KAAKiK,MAAM,GAAOme,EAAKC,EAAKC,EAAKC,GAAKI,EAAMC,EAAMC,EAAMH,GAEvE,OAAOlrB,MAOX+f,EAAW9f,UAAUiV,iBAAmB,SAAU9T,GAE9C,OADA+gB,EAAOoJ,oBAAoBvrB,KAAMoB,GAC1BpB,MAOX+f,EAAW9f,UAAUurB,mBAAqB,SAAU5E,GAEhD,OADA7G,EAAW0L,wBAAwB7E,EAAQ5mB,MACpCA,MAQX+f,EAAW2L,mBAAqB,SAAU9E,GACtC,IAAIxlB,EAAS,IAAI2e,EAEjB,OADAA,EAAW0L,wBAAwB7E,EAAQxlB,GACpCA,GAOX2e,EAAW0L,wBAA0B,SAAU7E,EAAQxlB,GACnD,IAKI8B,EALAyoB,EAAO/E,EAAO7iB,EACd6nB,EAAMD,EAAK,GAAIE,EAAMF,EAAK,GAAIG,EAAMH,EAAK,GACzCI,EAAMJ,EAAK,GAAIK,EAAML,EAAK,GAAIM,EAAMN,EAAK,GACzCO,EAAMP,EAAK,GAAIQ,EAAMR,EAAK,GAAIS,EAAMT,EAAK,IACzCU,EAAQT,EAAMI,EAAMI,EAEpBC,EAAQ,GACRnpB,EAAI,GAAMV,KAAKuF,KAAKskB,EAAQ,GAC5BjrB,EAAO0b,EAAI,IAAO5Z,EAClB9B,EAAOyC,GAAKsoB,EAAMF,GAAO/oB,EACzB9B,EAAOsH,GAAKojB,EAAMI,GAAOhpB,EACzB9B,EAAOuH,GAAKojB,EAAMF,GAAO3oB,GAEpB0oB,EAAMI,GAAOJ,EAAMQ,GACxBlpB,EAAI,EAAMV,KAAKuF,KAAK,EAAM6jB,EAAMI,EAAMI,GACtChrB,EAAO0b,GAAKqP,EAAMF,GAAO/oB,EACzB9B,EAAOyC,EAAI,IAAOX,EAClB9B,EAAOsH,GAAKmjB,EAAME,GAAO7oB,EACzB9B,EAAOuH,GAAKmjB,EAAMI,GAAOhpB,GAEpB8oB,EAAMI,GACXlpB,EAAI,EAAMV,KAAKuF,KAAK,EAAMikB,EAAMJ,EAAMQ,GACtChrB,EAAO0b,GAAKgP,EAAMI,GAAOhpB,EACzB9B,EAAOyC,GAAKgoB,EAAME,GAAO7oB,EACzB9B,EAAOsH,EAAI,IAAOxF,EAClB9B,EAAOuH,GAAKsjB,EAAME,GAAOjpB,IAGzBA,EAAI,EAAMV,KAAKuF,KAAK,EAAMqkB,EAAMR,EAAMI,GACtC5qB,EAAO0b,GAAKiP,EAAMF,GAAO3oB,EACzB9B,EAAOyC,GAAKioB,EAAMI,GAAOhpB,EACzB9B,EAAOsH,GAAKujB,EAAME,GAAOjpB,EACzB9B,EAAOuH,EAAI,IAAOzF,IAS1B6c,EAAW3B,IAAM,SAAUxZ,EAAMC,GAC7B,OAAOD,EAAK+a,GAAK9a,EAAM8a,GAAK/a,EAAKgb,GAAK/a,EAAM+a,GAAKhb,EAAKib,GAAKhb,EAAMgb,GAAKjb,EAAKulB,GAAKtlB,EAAMslB,IAQ1FpK,EAAWuM,SAAW,SAAUC,EAAOC,GAEnC,OADUzM,EAAW3B,IAAImO,EAAOC,IAClB,GAWlBzM,EAAWoE,YAAc,SAAUhiB,EAAQiiB,EAAMC,EAAWC,EAAUljB,GAClE,IAAIsiB,EAAqB,IAAbY,EAAiB,EAAID,EAAYC,EAC7CZ,EAAQ,UAAaA,EAAO,EAAG,GAC/B3D,EAAW0D,WAAWthB,EAAQiiB,EAAMV,EAAOtiB,IAM/C2e,EAAW5U,KAAO,WACd,OAAO,IAAI4U,EAAW,EAAK,EAAK,EAAK,IAOzCA,EAAW0M,QAAU,SAAUpM,GAC3B,OAAO,IAAIN,GAAYM,EAAEV,IAAKU,EAAET,IAAKS,EAAER,GAAIQ,EAAE8J,KAQjDpK,EAAW2M,aAAe,SAAUrM,EAAGjf,GAEnC,OADAA,EAAOiB,KAAKge,EAAEV,IAAKU,EAAET,IAAKS,EAAER,GAAIQ,EAAE8J,IAC3B/oB,GAMX2e,EAAW4M,SAAW,WAClB,OAAO,IAAI5M,EAAW,EAAK,EAAK,EAAK,IAOzCA,EAAW6M,WAAa,SAAU1K,GAC9B,OAAOA,GAAgC,IAAlBA,EAAWvC,IAA8B,IAAlBuC,EAAWtC,IAA8B,IAAlBsC,EAAWrC,IAA8B,IAAlBqC,EAAWiI,IAQzGpK,EAAW8M,aAAe,SAAU9J,EAAMlV,GACtC,OAAOkS,EAAW+M,kBAAkB/J,EAAMlV,EAAO,IAAIkS,IASzDA,EAAW+M,kBAAoB,SAAU/J,EAAMlV,EAAOzM,GAClD,IAAI2N,EAAMvM,KAAKuM,IAAIlB,EAAQ,GAM3B,OALAkV,EAAKla,YACLzH,EAAO0b,EAAIta,KAAKsM,IAAIjB,EAAQ,GAC5BzM,EAAOyC,EAAIkf,EAAKpD,GAAK5Q,EACrB3N,EAAOsH,EAAIqa,EAAKnD,GAAK7Q,EACrB3N,EAAOuH,EAAIoa,EAAKlD,GAAK9Q,EACd3N,GAQX2e,EAAWzb,UAAY,SAAU/D,EAAOG,GAIpC,OAHKA,IACDA,EAAS,GAEN,IAAIqf,EAAWxf,EAAMG,GAASH,EAAMG,EAAS,GAAIH,EAAMG,EAAS,GAAIH,EAAMG,EAAS,KAQ9Fqf,EAAWpf,eAAiB,SAAUJ,EAAOG,EAAQU,GACjDA,EAAOyC,EAAItD,EAAMG,GACjBU,EAAOsH,EAAInI,EAAMG,EAAS,GAC1BU,EAAOuH,EAAIpI,EAAMG,EAAS,GAC1BU,EAAO0b,EAAIvc,EAAMG,EAAS,IAS9Bqf,EAAWgN,gBAAkB,SAAUlpB,EAAG6E,EAAGC,GACzC,IAAI0X,EAAI,IAAIN,EAEZ,OADAA,EAAWiN,0BAA0BtkB,EAAG7E,EAAG8E,EAAG0X,GACvCA,GAUXN,EAAWkN,qBAAuB,SAAUppB,EAAG6E,EAAGC,EAAGvH,GAEjD,OADA2e,EAAWiN,0BAA0BtkB,EAAG7E,EAAG8E,EAAGvH,GACvCA,GAOX2e,EAAWmN,gBAAkB,SAAUC,GACnC,IAAI9M,EAAI,IAAIN,EAEZ,OADAA,EAAWiN,0BAA0BG,EAAIvN,GAAIuN,EAAIxN,GAAIwN,EAAItN,GAAIQ,GACtDA,GAQXN,EAAWqN,qBAAuB,SAAUD,EAAK/rB,GAE7C,OADA2e,EAAWiN,0BAA0BG,EAAIvN,GAAIuN,EAAIxN,GAAIwN,EAAItN,GAAIze,GACtDA,GASX2e,EAAWsN,qBAAuB,SAAUC,EAASC,EAAOnsB,GACxD,IAAIvB,EAAI4f,EAAQrB,IAAIkP,EAASC,GAAS,EAatC,OAZI1tB,EAAI,KACA2C,KAAKsB,IAAIwpB,EAAQzpB,GAAKrB,KAAKsB,IAAIwpB,EAAQ3kB,GACvCvH,EAAOiB,KAAKirB,EAAQ5kB,EAAG4kB,EAAQzpB,EAAG,EAAG,GAGrCzC,EAAOiB,IAAI,GAAIirB,EAAQ3kB,EAAG2kB,EAAQ5kB,EAAG,IAIzC+W,EAAQ4D,WAAWiK,EAASC,EAAOC,EAAW/N,QAAQ,IACtDre,EAAOiB,IAAImrB,EAAW/N,QAAQ,GAAG5b,EAAG2pB,EAAW/N,QAAQ,GAAG/W,EAAG8kB,EAAW/N,QAAQ,GAAG9W,EAAG9I,IAEnFuB,EAAOyH,aASlBkX,EAAWC,qBAAuB,SAAUyN,EAAKC,EAAOC,GACpD,IAAItN,EAAI,IAAIN,EAEZ,OADAA,EAAWiN,0BAA0BS,EAAKC,EAAOC,EAAMtN,GAChDA,GASXN,EAAWiN,0BAA4B,SAAUS,EAAKC,EAAOC,EAAMvsB,GAE/D,IAAIwsB,EAAkB,GAAPD,EACXE,EAAoB,GAARH,EACZI,EAAgB,GAANL,EACVM,EAAUvrB,KAAKuM,IAAI6e,GACnBI,EAAUxrB,KAAKsM,IAAI8e,GACnBK,EAAWzrB,KAAKuM,IAAI8e,GACpBK,EAAW1rB,KAAKsM,IAAI+e,GACpBM,EAAS3rB,KAAKuM,IAAI+e,GAClBM,EAAS5rB,KAAKsM,IAAIgf,GACtB1sB,EAAOyC,EAAIuqB,EAASH,EAAWD,EAAUG,EAASD,EAAWH,EAC7D3sB,EAAOsH,EAAIylB,EAASD,EAAWF,EAAUI,EAASH,EAAWF,EAC7D3sB,EAAOuH,EAAIylB,EAASF,EAAWH,EAAUI,EAASF,EAAWD,EAC7D5sB,EAAO0b,EAAIsR,EAASF,EAAWF,EAAUG,EAASF,EAAWF,GASjEhO,EAAWsO,uBAAyB,SAAUxtB,EAAOytB,EAAMC,GACvD,IAAIntB,EAAS,IAAI2e,EAEjB,OADAA,EAAWyO,4BAA4B3tB,EAAOytB,EAAMC,EAAOntB,GACpDA,GASX2e,EAAWyO,4BAA8B,SAAU3tB,EAAOytB,EAAMC,EAAOntB,GAEnE,IAAIqtB,EAAuC,IAAjBF,EAAQ1tB,GAC9B6tB,EAAwC,IAAjBH,EAAQ1tB,GAC/B8tB,EAAkB,GAAPL,EACfltB,EAAOyC,EAAIrB,KAAKsM,IAAI4f,GAAuBlsB,KAAKuM,IAAI4f,GACpDvtB,EAAOsH,EAAIlG,KAAKuM,IAAI2f,GAAuBlsB,KAAKuM,IAAI4f,GACpDvtB,EAAOuH,EAAInG,KAAKuM,IAAI0f,GAAsBjsB,KAAKsM,IAAI6f,GACnDvtB,EAAO0b,EAAIta,KAAKsM,IAAI2f,GAAsBjsB,KAAKsM,IAAI6f,IASvD5O,EAAW6O,2BAA6B,SAAUrF,EAAOC,EAAOC,GAC5D,IAAIG,EAAO,IAAI7J,EAAW,EAAK,EAAK,EAAK,GAEzC,OADAA,EAAW8J,gCAAgCN,EAAOC,EAAOC,EAAOG,GACzDA,GASX7J,EAAW8J,gCAAkC,SAAUN,EAAOC,EAAOC,EAAOtK,GACxE,IAAI0P,EAAS7N,EAAQmB,OAAO,GAC5BA,EAAO2M,iBAAiBvF,EAAM1gB,YAAa2gB,EAAM3gB,YAAa4gB,EAAM5gB,YAAagmB,GACjF9O,EAAW0L,wBAAwBoD,EAAQ1P,IAS/CY,EAAWgP,oBAAsB,SAAUvL,EAASwL,GAChD,IAAIpF,EAAO,IAAI7J,EAEf,OADAA,EAAWkP,yBAAyBzL,EAASwL,EAAIpF,GAC1CA,GASX7J,EAAWkP,yBAA2B,SAAUzL,EAASwL,EAAI7P,GACzD,IAAI0P,EAAS7N,EAAQmB,OAAO,GAC5BA,EAAO+M,qBAAqB1L,EAASwL,EAAIH,GACzC9O,EAAW0L,wBAAwBoD,EAAQ1P,IAS/CY,EAAWoP,oBAAsB,SAAU3L,EAASwL,GAChD,IAAIpF,EAAO,IAAI7J,EAEf,OADAA,EAAWqP,yBAAyB5L,EAASwL,EAAIpF,GAC1CA,GASX7J,EAAWqP,yBAA2B,SAAU5L,EAASwL,EAAI7P,GACzD,IAAI0P,EAAS7N,EAAQmB,OAAO,GAE5B,OADAA,EAAOkN,qBAAqB7L,EAASwL,EAAIH,GAClC9O,EAAW0L,wBAAwBoD,EAAQ1P,IAStDY,EAAWuP,MAAQ,SAAU1qB,EAAMC,EAAOH,GACtC,IAAItD,EAAS2e,EAAW4M,WAExB,OADA5M,EAAW0D,WAAW7e,EAAMC,EAAOH,EAAQtD,GACpCA,GASX2e,EAAW0D,WAAa,SAAU7e,EAAMC,EAAOH,EAAQtD,GACnD,IAAImuB,EACAC,EACAC,EAAO7qB,EAAK+a,GAAK9a,EAAM8a,GAAK/a,EAAKgb,GAAK/a,EAAM+a,GAAKhb,EAAKib,GAAKhb,EAAMgb,GAAKjb,EAAKulB,GAAKtlB,EAAMslB,GACtFuF,GAAO,EAKX,GAJID,EAAO,IACPC,GAAO,EACPD,GAAQA,GAERA,EAAO,QACPD,EAAO,EAAI9qB,EACX6qB,EAAOG,GAAQhrB,EAASA,MAEvB,CACD,IAAIirB,EAAOntB,KAAK4gB,KAAKqM,GACjBG,EAAO,EAAMptB,KAAKuM,IAAI4gB,GAC1BH,EAAOhtB,KAAKuM,KAAK,EAAMrK,GAAUirB,GAAQC,EACzCL,EAAOG,GAAQltB,KAAKuM,IAAIrK,EAASirB,GAAQC,EAAOptB,KAAKuM,IAAIrK,EAASirB,GAAQC,EAE9ExuB,EAAOyC,EAAI2rB,EAAO5qB,EAAK+a,GAAK4P,EAAO1qB,EAAM8a,GACzCve,EAAOsH,EAAI8mB,EAAO5qB,EAAKgb,GAAK2P,EAAO1qB,EAAM+a,GACzCxe,EAAOuH,EAAI6mB,EAAO5qB,EAAKib,GAAK0P,EAAO1qB,EAAMgb,GACzCze,EAAO0b,EAAI0S,EAAO5qB,EAAKulB,GAAKoF,EAAO1qB,EAAMslB,IAW7CpK,EAAWjb,QAAU,SAAUC,EAAQC,EAAUC,EAAQC,EAAUR,GAC/D,IAAIS,EAAUT,EAASA,EACnBU,EAAQV,EAASS,EACjBE,EAAQ,EAAMD,EAAQ,EAAMD,EAAU,EACtCG,GAAS,EAAMF,EAAQ,EAAMD,EAC7BI,EAAQH,EAAQ,EAAMD,EAAUT,EAChCc,EAAQJ,EAAQD,EAKpB,OAAO,IAAI4a,EAJHhb,EAAO4a,GAAKta,EAAQJ,EAAO0a,GAAKra,EAAQN,EAAS2a,GAAKpa,EAAQL,EAASya,GAAKna,EAC5ET,EAAO6a,GAAKva,EAAQJ,EAAO2a,GAAKta,EAAQN,EAAS4a,GAAKra,EAAQL,EAAS0a,GAAKpa,EAC5ET,EAAO8a,GAAKxa,EAAQJ,EAAO4a,GAAKva,EAAQN,EAAS6a,GAAKta,EAAQL,EAAS2a,GAAKra,EAC5ET,EAAOolB,GAAK9kB,EAAQJ,EAAOklB,GAAK7kB,EAAQN,EAASmlB,GAAK5kB,EAAQL,EAASilB,GAAK3kB,IAYxFua,EAAWta,qBAAuB,SAAUV,EAAQC,EAAUC,EAAQC,EAAUQ,GAC5E,IAAItE,EAAS2e,EAAW5U,OAExB,OADAnL,KAAK4F,0BAA0Bb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GAClEA,GAWX2e,EAAWna,0BAA4B,SAAUb,EAAQC,EAAUC,EAAQC,EAAUQ,EAAMtE,GACvF,IAAIyE,EAAKH,EAAOA,EAChBtE,EAAOyC,EAAkB,GAAbgC,EAAKH,GAAYX,EAAOlB,GAAK,EAAIgC,EAAK,EAAIH,EAAO,GAAKV,EAASnB,EAAmB,IAAbgC,EAAKH,GAAYT,EAAOpB,GAAK,EAAIgC,EAAK,EAAIH,GAAQR,EAASrB,EAC5IzC,EAAOsH,EAAkB,GAAb7C,EAAKH,GAAYX,EAAO2D,GAAK,EAAI7C,EAAK,EAAIH,EAAO,GAAKV,EAAS0D,EAAmB,IAAb7C,EAAKH,GAAYT,EAAOyD,GAAK,EAAI7C,EAAK,EAAIH,GAAQR,EAASwD,EAC5ItH,EAAOuH,EAAkB,GAAb9C,EAAKH,GAAYX,EAAO4D,GAAK,EAAI9C,EAAK,EAAIH,EAAO,GAAKV,EAAS2D,EAAmB,IAAb9C,EAAKH,GAAYT,EAAO0D,GAAK,EAAI9C,EAAK,EAAIH,GAAQR,EAASyD,EAC5IvH,EAAO0b,EAAkB,GAAbjX,EAAKH,GAAYX,EAAO+X,GAAK,EAAIjX,EAAK,EAAIH,EAAO,GAAKV,EAAS8X,EAAmB,IAAbjX,EAAKH,GAAYT,EAAO6X,GAAK,EAAIjX,EAAK,EAAIH,GAAQR,EAAS4X,GAEzIiD,EAn5BoB,GAy5B3BoC,EAAwB,WAIxB,SAASA,IACLniB,KAAK6vB,aAAc,EACnB7vB,KAAK8vB,kBAAmB,EACxB9vB,KAAK+vB,gBAAiB,EACtB/vB,KAAKgwB,qBAAsB,EAM3BhwB,KAAKiwB,YAAc,EACf,gCACA,+BAAmDjwB,MAEvDA,KAAKkwB,GAAK,IAAI,sBAA0C,IACxDlwB,KAAKmwB,gBAi0DT,OA/zDAlqB,OAAOC,eAAeic,EAAQ,YAAa,CAIvChc,IAAK,WACD,OAAO,qBAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAeic,EAAOliB,UAAW,IAAK,CAIzCkG,IAAK,WACD,OAAOnG,KAAKkwB,IAEhB7pB,YAAY,EACZC,cAAc,IAKlB6b,EAAOliB,UAAUkwB,cAAgB,WAC7BnwB,KAAKiwB,WAAa9N,EAAOiO,kBACzBpwB,KAAK6vB,aAAc,EACnB7vB,KAAK+vB,gBAAiB,EACtB/vB,KAAK8vB,kBAAmB,EACxB9vB,KAAKgwB,qBAAsB,GAE/B7N,EAAOliB,UAAUowB,sBAAwB,SAAUC,EAAYC,EAAiBC,EAAeC,QACnE,IAApBF,IAA8BA,GAAkB,QAC9B,IAAlBC,IAA4BA,GAAgB,QACrB,IAAvBC,IAAiCA,GAAqB,GAC1DzwB,KAAK6vB,YAAcS,EACnBtwB,KAAK+vB,eAAiBO,GAAcE,EACpCxwB,KAAK8vB,kBAAmB9vB,KAAK6vB,aAAsBU,EACnDvwB,KAAKgwB,qBAAsBhwB,KAAK+vB,gBAAyBU,GAO7DtO,EAAOliB,UAAUqwB,WAAa,WAC1B,GAAItwB,KAAK8vB,iBAAkB,CACvB9vB,KAAK8vB,kBAAmB,EACxB,IAAI/rB,EAAI/D,KAAKkwB,GACblwB,KAAK6vB,YACQ,IAAT9rB,EAAE,IACW,IAATA,EAAE,IACO,IAATA,EAAE,IACO,IAATA,EAAE,IACO,IAATA,EAAE,IACO,IAATA,EAAE,IACO,IAATA,EAAE,IACO,IAATA,EAAE,IACO,IAATA,EAAE,IACO,IAATA,EAAE,IACQ,IAAVA,EAAE,KACQ,IAAVA,EAAE,KACQ,IAAVA,EAAE,KACQ,IAAVA,EAAE,KACQ,IAAVA,EAAE,KACQ,IAAVA,EAAE,IAEd,OAAO/D,KAAK6vB,aAMhB1N,EAAOliB,UAAUywB,gBAAkB,WAyB/B,OAxBI1wB,KAAKgwB,sBACLhwB,KAAKgwB,qBAAsB,EACR,IAAfhwB,KAAKkwB,GAAG,IAA6B,IAAflwB,KAAKkwB,GAAG,IAA8B,IAAhBlwB,KAAKkwB,GAAG,KAGhC,IAAflwB,KAAKkwB,GAAG,IACE,IAAflwB,KAAKkwB,GAAG,IACO,IAAflwB,KAAKkwB,GAAG,IACO,IAAflwB,KAAKkwB,GAAG,IACO,IAAflwB,KAAKkwB,GAAG,IACO,IAAflwB,KAAKkwB,GAAG,IACO,IAAflwB,KAAKkwB,GAAG,IACO,IAAflwB,KAAKkwB,GAAG,IACQ,IAAhBlwB,KAAKkwB,GAAG,KACQ,IAAhBlwB,KAAKkwB,GAAG,KACQ,IAAhBlwB,KAAKkwB,GAAG,KACQ,IAAhBlwB,KAAKkwB,GAAG,KACQ,IAAhBlwB,KAAKkwB,GAAG,IAdRlwB,KAAK+vB,gBAAiB,EAkBtB/vB,KAAK+vB,gBAAiB,GAGvB/vB,KAAK+vB,gBAMhB5N,EAAOliB,UAAU0wB,YAAc,WAC3B,IAAyB,IAArB3wB,KAAK6vB,YACL,OAAO,EAEX,IAAI9rB,EAAI/D,KAAKkwB,GACTU,EAAM7sB,EAAE,GAAI8sB,EAAM9sB,EAAE,GAAI+sB,EAAM/sB,EAAE,GAAIgtB,EAAMhtB,EAAE,GAC5CitB,EAAMjtB,EAAE,GAAI6nB,EAAM7nB,EAAE,GAAI8nB,EAAM9nB,EAAE,GAAI+nB,EAAM/nB,EAAE,GAC5CktB,EAAMltB,EAAE,GAAIgoB,EAAMhoB,EAAE,GAAIioB,EAAMjoB,EAAE,IAAKkoB,EAAMloB,EAAE,IAC7CmtB,EAAMntB,EAAE,IAAKmoB,EAAMnoB,EAAE,IAAKooB,EAAMpoB,EAAE,IAAKqoB,EAAMroB,EAAE,IAU/CotB,EAAYnF,EAAMI,EAAMD,EAAMF,EAC9BmF,EAAYrF,EAAMK,EAAMF,EAAMD,EAC9BoF,EAAYtF,EAAMI,EAAMD,EAAMF,EAC9BsF,EAAYL,EAAM7E,EAAM8E,EAAMjF,EAC9BsF,EAAYN,EAAM9E,EAAMH,EAAMkF,EAC9BM,EAAYP,EAAM/E,EAAMgF,EAAMnF,EAKlC,OAAO6E,IAJWhF,EAAMuF,EAAYtF,EAAMuF,EAAYtF,EAAMuF,GAInCR,IAHPG,EAAMG,EAAYtF,EAAMyF,EAAYxF,EAAMyF,GAGjBT,IAFzBE,EAAMI,EAAYxF,EAAM0F,EAAYxF,EAAM0F,GAECT,IAD3CC,EAAMK,EAAYzF,EAAM2F,EAAY1F,EAAM2F,IAQhErP,EAAOliB,UAAUK,QAAU,WACvB,OAAON,KAAKkwB,IAMhB/N,EAAOliB,UAAUc,QAAU,WACvB,OAAOf,KAAKkwB,IAMhB/N,EAAOliB,UAAUynB,OAAS,WAEtB,OADA1nB,KAAK6Y,YAAY7Y,MACVA,MAMXmiB,EAAOliB,UAAUwxB,MAAQ,WAGrB,OAFAtP,EAAOwE,gBAAgB,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK3mB,MACvGA,KAAKqwB,uBAAsB,GACpBrwB,MAOXmiB,EAAOliB,UAAU4B,IAAM,SAAU6I,GAC7B,IAAItJ,EAAS,IAAI+gB,EAEjB,OADAniB,KAAK8B,SAAS4I,EAAOtJ,GACdA,GAQX+gB,EAAOliB,UAAU6B,SAAW,SAAU4I,EAAOtJ,GAIzC,IAHA,IAAI2C,EAAI/D,KAAKkwB,GACTwB,EAAUtwB,EAAO8uB,GACjByB,EAASjnB,EAAM3G,EACVvD,EAAQ,EAAGA,EAAQ,GAAIA,IAC5BkxB,EAAQlxB,GAASuD,EAAEvD,GAASmxB,EAAOnxB,GAGvC,OADAY,EAAO+uB,gBACAnwB,MAOXmiB,EAAOliB,UAAU2xB,UAAY,SAAUlnB,GAGnC,IAFA,IAAI3G,EAAI/D,KAAKkwB,GACTyB,EAASjnB,EAAM3G,EACVvD,EAAQ,EAAGA,EAAQ,GAAIA,IAC5BuD,EAAEvD,IAAUmxB,EAAOnxB,GAGvB,OADAR,KAAKmwB,gBACEnwB,MAOXmiB,EAAOliB,UAAU4Y,YAAc,SAAUnO,GACrC,IAAyB,IAArB1K,KAAK6vB,YAEL,OADA1N,EAAO0P,cAAcnnB,GACd1K,KAGX,IAAI+D,EAAI/D,KAAKkwB,GACTU,EAAM7sB,EAAE,GAAI8sB,EAAM9sB,EAAE,GAAI+sB,EAAM/sB,EAAE,GAAIgtB,EAAMhtB,EAAE,GAC5CitB,EAAMjtB,EAAE,GAAI6nB,EAAM7nB,EAAE,GAAI8nB,EAAM9nB,EAAE,GAAI+nB,EAAM/nB,EAAE,GAC5CktB,EAAMltB,EAAE,GAAIgoB,EAAMhoB,EAAE,GAAIioB,EAAMjoB,EAAE,IAAKkoB,EAAMloB,EAAE,IAC7CmtB,EAAMntB,EAAE,IAAKmoB,EAAMnoB,EAAE,IAAKooB,EAAMpoB,EAAE,IAAKqoB,EAAMroB,EAAE,IAC/CotB,EAAYnF,EAAMI,EAAMD,EAAMF,EAC9BmF,EAAYrF,EAAMK,EAAMF,EAAMD,EAC9BoF,EAAYtF,EAAMI,EAAMD,EAAMF,EAC9BsF,EAAYL,EAAM7E,EAAM8E,EAAMjF,EAC9BsF,EAAYN,EAAM9E,EAAMH,EAAMkF,EAC9BM,EAAYP,EAAM/E,EAAMgF,EAAMnF,EAC9B+F,IAAclG,EAAMuF,EAAYtF,EAAMuF,EAAYtF,EAAMuF,GACxDU,IAAcf,EAAMG,EAAYtF,EAAMyF,EAAYxF,EAAMyF,GACxDS,IAAchB,EAAMI,EAAYxF,EAAM0F,EAAYxF,EAAM0F,GACxDS,IAAcjB,EAAMK,EAAYzF,EAAM2F,EAAY1F,EAAM2F,GACxDrkB,EAAMyjB,EAAMkB,EAAYjB,EAAMkB,EAAYjB,EAAMkB,EAAYjB,EAAMkB,EACtE,GAAY,IAAR9kB,EAGA,OADAzC,EAAMxI,SAASlC,MACRA,KAEX,IAAIkyB,EAAS,EAAI/kB,EACbglB,EAAYtG,EAAMO,EAAMD,EAAML,EAC9BsG,EAAYxG,EAAMQ,EAAMF,EAAMJ,EAC9BuG,EAAYzG,EAAMO,EAAMD,EAAML,EAC9ByG,EAAYtB,EAAM5E,EAAM8E,EAAMpF,EAC9ByG,EAAYvB,EAAM7E,EAAM+E,EAAMrF,EAC9B2G,EAAYxB,EAAM9E,EAAMgF,EAAMtF,EAC9B6G,EAAY5G,EAAMI,EAAMD,EAAMF,EAC9B4G,EAAY9G,EAAMK,EAAMF,EAAMD,EAC9B6G,EAAY/G,EAAMI,EAAMD,EAAMF,EAC9B+G,EAAY5B,EAAM/E,EAAMgF,EAAMnF,EAC9B+G,EAAY7B,EAAMhF,EAAMiF,EAAMpF,EAC9BiH,EAAY9B,EAAMjF,EAAMkF,EAAMrF,EAC9BmH,IAAclC,EAAMM,EAAYL,EAAMM,EAAYL,EAAMM,GACxD2B,IAAcpC,EAAMO,EAAYL,EAAMQ,EAAYP,EAAMQ,GACxD0B,IAAcrC,EAAMQ,EAAYP,EAAMS,EAAYP,EAAMS,GACxD0B,IAActC,EAAMS,EAAYR,EAAMU,EAAYT,EAAMU,GACxD2B,IAActC,EAAMsB,EAAYrB,EAAMsB,EAAYrB,EAAMsB,GACxDe,IAAcxC,EAAMuB,EAAYrB,EAAMwB,EAAYvB,EAAMwB,GACxDc,IAAczC,EAAMwB,EAAYvB,EAAMyB,EAAYvB,EAAMyB,GACxDc,IAAc1C,EAAMyB,EAAYxB,EAAM0B,EAAYzB,EAAM0B,GACxDe,IAAc1C,EAAM4B,EAAY3B,EAAM4B,EAAY3B,EAAM4B,GACxDa,IAAc5C,EAAM6B,EAAY3B,EAAM8B,EAAY7B,EAAM8B,GACxDY,IAAc7C,EAAM8B,EAAY7B,EAAM+B,EAAY7B,EAAM+B,GACxDY,KAAc9C,EAAM+B,EAAY9B,EAAMgC,EAAY/B,EAAMgC,GAE5D,OADA3Q,EAAOwE,gBAAgBmL,EAAYI,EAAQa,EAAYb,EAAQiB,EAAYjB,EAAQqB,EAAYrB,EAAQH,EAAYG,EAAQc,EAAYd,EAAQkB,EAAYlB,EAAQsB,EAAYtB,EAAQF,EAAYE,EAAQe,EAAYf,EAAQmB,EAAYnB,EAAQuB,EAAYvB,EAAQD,EAAYC,EAAQgB,EAAYhB,EAAQoB,EAAYpB,EAAQwB,GAAYxB,EAAQxnB,GAChV1K,MAQXmiB,EAAOliB,UAAU0zB,WAAa,SAAUnzB,EAAOmD,GAG3C,OAFA3D,KAAKkwB,GAAG1vB,IAAUmD,EAClB3D,KAAKmwB,gBACEnwB,MAQXmiB,EAAOliB,UAAU2zB,gBAAkB,SAAUpzB,EAAOmD,GAGhD,OAFA3D,KAAKkwB,GAAG1vB,IAAUmD,EAClB3D,KAAKmwB,gBACEnwB,MASXmiB,EAAOliB,UAAU4zB,yBAA2B,SAAUhwB,EAAG6E,EAAGC,GAKxD,OAJA3I,KAAKkwB,GAAG,IAAMrsB,EACd7D,KAAKkwB,GAAG,IAAMxnB,EACd1I,KAAKkwB,GAAG,IAAMvnB,EACd3I,KAAKmwB,gBACEnwB,MASXmiB,EAAOliB,UAAU6zB,yBAA2B,SAAUjwB,EAAG6E,EAAGC,GAKxD,OAJA3I,KAAKkwB,GAAG,KAAOrsB,EACf7D,KAAKkwB,GAAG,KAAOxnB,EACf1I,KAAKkwB,GAAG,KAAOvnB,EACf3I,KAAKmwB,gBACEnwB,MAOXmiB,EAAOliB,UAAU8zB,eAAiB,SAAUC,GACxC,OAAOh0B,KAAK6zB,yBAAyBG,EAAQrU,GAAIqU,EAAQpU,GAAIoU,EAAQnU,KAMzEsC,EAAOliB,UAAUg0B,eAAiB,WAC9B,OAAO,IAAIxU,EAAQzf,KAAKkwB,GAAG,IAAKlwB,KAAKkwB,GAAG,IAAKlwB,KAAKkwB,GAAG,MAOzD/N,EAAOliB,UAAUi0B,oBAAsB,SAAU9yB,GAI7C,OAHAA,EAAOyC,EAAI7D,KAAKkwB,GAAG,IACnB9uB,EAAOsH,EAAI1I,KAAKkwB,GAAG,IACnB9uB,EAAOuH,EAAI3I,KAAKkwB,GAAG,IACZlwB,MAMXmiB,EAAOliB,UAAUk0B,yBAA2B,WACxC,IAAIpwB,EAAI/D,KAAK+D,EAGb,OAFAoe,EAAOwE,gBAAgB,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK5iB,EAAE,IAAKA,EAAE,IAAKA,EAAE,IAAKA,EAAE,IAAK/D,MAC/GA,KAAKqwB,sBAAgC,IAAVtsB,EAAE,KAAuB,IAAVA,EAAE,KAAuB,IAAVA,EAAE,KAAuB,IAAVA,EAAE,KACnE/D,MAOXmiB,EAAOliB,UAAUgB,SAAW,SAAUyJ,GAClC,IAAItJ,EAAS,IAAI+gB,EAEjB,OADAniB,KAAKmB,cAAcuJ,EAAOtJ,GACnBA,GAOX+gB,EAAOliB,UAAUiC,SAAW,SAAUwI,GAClCA,EAAM0pB,YAAYp0B,KAAKkwB,IACvB,IAAImE,EAAI3pB,EAGR,OAFA1K,KAAKiwB,WAAaoE,EAAEpE,WACpBjwB,KAAKqwB,sBAAsBgE,EAAExE,YAAawE,EAAEvE,iBAAkBuE,EAAEtE,eAAgBsE,EAAErE,qBAC3EhwB,MAQXmiB,EAAOliB,UAAUm0B,YAAc,SAAU7zB,EAAOG,QAC7B,IAAXA,IAAqBA,EAAS,GAClC,IAAIyB,EAASnC,KAAKkwB,GAiBlB,OAhBA3vB,EAAMG,GAAUyB,EAAO,GACvB5B,EAAMG,EAAS,GAAKyB,EAAO,GAC3B5B,EAAMG,EAAS,GAAKyB,EAAO,GAC3B5B,EAAMG,EAAS,GAAKyB,EAAO,GAC3B5B,EAAMG,EAAS,GAAKyB,EAAO,GAC3B5B,EAAMG,EAAS,GAAKyB,EAAO,GAC3B5B,EAAMG,EAAS,GAAKyB,EAAO,GAC3B5B,EAAMG,EAAS,GAAKyB,EAAO,GAC3B5B,EAAMG,EAAS,GAAKyB,EAAO,GAC3B5B,EAAMG,EAAS,GAAKyB,EAAO,GAC3B5B,EAAMG,EAAS,IAAMyB,EAAO,IAC5B5B,EAAMG,EAAS,IAAMyB,EAAO,IAC5B5B,EAAMG,EAAS,IAAMyB,EAAO,IAC5B5B,EAAMG,EAAS,IAAMyB,EAAO,IAC5B5B,EAAMG,EAAS,IAAMyB,EAAO,IAC5B5B,EAAMG,EAAS,IAAMyB,EAAO,IACrBnC,MAQXmiB,EAAOliB,UAAUkB,cAAgB,SAAUuJ,EAAOtJ,GAC9C,OAAIpB,KAAK6vB,aACLzuB,EAAOc,SAASwI,GACT1K,MAEP0K,EAAMmlB,aACNzuB,EAAOc,SAASlC,MACTA,OAEXA,KAAKs0B,gBAAgB5pB,EAAOtJ,EAAO8uB,GAAI,GACvC9uB,EAAO+uB,gBACAnwB,OASXmiB,EAAOliB,UAAUq0B,gBAAkB,SAAU5pB,EAAOtJ,EAAQV,GACxD,IAAIqD,EAAI/D,KAAKkwB,GACTyB,EAASjnB,EAAM3G,EACfwwB,EAAMxwB,EAAE,GAAIywB,EAAMzwB,EAAE,GAAI0wB,EAAM1wB,EAAE,GAAI2wB,EAAM3wB,EAAE,GAC5C4wB,EAAM5wB,EAAE,GAAI6wB,EAAM7wB,EAAE,GAAI8wB,EAAM9wB,EAAE,GAAI+wB,EAAM/wB,EAAE,GAC5CgxB,EAAMhxB,EAAE,GAAIixB,EAAMjxB,EAAE,GAAIkxB,EAAOlxB,EAAE,IAAKmxB,EAAOnxB,EAAE,IAC/CoxB,EAAOpxB,EAAE,IAAKqxB,EAAOrxB,EAAE,IAAKsxB,EAAOtxB,EAAE,IAAKuxB,EAAOvxB,EAAE,IACnDwxB,EAAM5D,EAAO,GAAI6D,EAAM7D,EAAO,GAAI8D,EAAM9D,EAAO,GAAI+D,EAAM/D,EAAO,GAChEgE,EAAMhE,EAAO,GAAIiE,EAAMjE,EAAO,GAAIkE,EAAMlE,EAAO,GAAImE,EAAMnE,EAAO,GAChEoE,EAAMpE,EAAO,GAAIqE,EAAMrE,EAAO,GAAIsE,EAAOtE,EAAO,IAAKuE,EAAOvE,EAAO,IACnEwE,EAAOxE,EAAO,IAAKyE,EAAOzE,EAAO,IAAK0E,EAAO1E,EAAO,IAAK2E,EAAO3E,EAAO,IAiB3E,OAhBAvwB,EAAOV,GAAU6zB,EAAMgB,EAAMf,EAAMmB,EAAMlB,EAAMsB,EAAMrB,EAAMyB,EAC3D/0B,EAAOV,EAAS,GAAK6zB,EAAMiB,EAAMhB,EAAMoB,EAAMnB,EAAMuB,EAAMtB,EAAM0B,EAC/Dh1B,EAAOV,EAAS,GAAK6zB,EAAMkB,EAAMjB,EAAMqB,EAAMpB,EAAMwB,EAAOvB,EAAM2B,EAChEj1B,EAAOV,EAAS,GAAK6zB,EAAMmB,EAAMlB,EAAMsB,EAAMrB,EAAMyB,EAAOxB,EAAM4B,EAChEl1B,EAAOV,EAAS,GAAKi0B,EAAMY,EAAMX,EAAMe,EAAMd,EAAMkB,EAAMjB,EAAMqB,EAC/D/0B,EAAOV,EAAS,GAAKi0B,EAAMa,EAAMZ,EAAMgB,EAAMf,EAAMmB,EAAMlB,EAAMsB,EAC/Dh1B,EAAOV,EAAS,GAAKi0B,EAAMc,EAAMb,EAAMiB,EAAMhB,EAAMoB,EAAOnB,EAAMuB,EAChEj1B,EAAOV,EAAS,GAAKi0B,EAAMe,EAAMd,EAAMkB,EAAMjB,EAAMqB,EAAOpB,EAAMwB,EAChEl1B,EAAOV,EAAS,GAAKq0B,EAAMQ,EAAMP,EAAMW,EAAMV,EAAOc,EAAMb,EAAOiB,EACjE/0B,EAAOV,EAAS,GAAKq0B,EAAMS,EAAMR,EAAMY,EAAMX,EAAOe,EAAMd,EAAOkB,EACjEh1B,EAAOV,EAAS,IAAMq0B,EAAMU,EAAMT,EAAMa,EAAMZ,EAAOgB,EAAOf,EAAOmB,EACnEj1B,EAAOV,EAAS,IAAMq0B,EAAMW,EAAMV,EAAMc,EAAMb,EAAOiB,EAAOhB,EAAOoB,EACnEl1B,EAAOV,EAAS,IAAMy0B,EAAOI,EAAMH,EAAOO,EAAMN,EAAOU,EAAMT,EAAOa,EACpE/0B,EAAOV,EAAS,IAAMy0B,EAAOK,EAAMJ,EAAOQ,EAAMP,EAAOW,EAAMV,EAAOc,EACpEh1B,EAAOV,EAAS,IAAMy0B,EAAOM,EAAML,EAAOS,EAAMR,EAAOY,EAAOX,EAAOe,EACrEj1B,EAAOV,EAAS,IAAMy0B,EAAOO,EAAMN,EAAOU,EAAMT,EAAOa,EAAOZ,EAAOgB,EAC9Dt2B,MAOXmiB,EAAOliB,UAAUoB,OAAS,SAAUsC,GAChC,IAAI+G,EAAQ/G,EACZ,IAAK+G,EACD,OAAO,EAEX,IAAI1K,KAAK6vB,aAAenlB,EAAMmlB,eACrB7vB,KAAK8vB,mBAAqBplB,EAAMolB,iBACjC,OAAO9vB,KAAK6vB,aAAenlB,EAAMmlB,YAGzC,IAAI9rB,EAAI/D,KAAK+D,EACTwyB,EAAK7rB,EAAM3G,EACf,OAAQA,EAAE,KAAOwyB,EAAG,IAChBxyB,EAAE,KAAOwyB,EAAG,IACZxyB,EAAE,KAAOwyB,EAAG,IACZxyB,EAAE,KAAOwyB,EAAG,IACZxyB,EAAE,KAAOwyB,EAAG,IACZxyB,EAAE,KAAOwyB,EAAG,IACZxyB,EAAE,KAAOwyB,EAAG,IACZxyB,EAAE,KAAOwyB,EAAG,IACZxyB,EAAE,KAAOwyB,EAAG,IACZxyB,EAAE,KAAOwyB,EAAG,IACZxyB,EAAE,MAAQwyB,EAAG,KACbxyB,EAAE,MAAQwyB,EAAG,KACbxyB,EAAE,MAAQwyB,EAAG,KACbxyB,EAAE,MAAQwyB,EAAG,KACbxyB,EAAE,MAAQwyB,EAAG,KACbxyB,EAAE,MAAQwyB,EAAG,KAMrBpU,EAAOliB,UAAUgC,MAAQ,WACrB,IAAI2kB,EAAS,IAAIzE,EAEjB,OADAyE,EAAO1kB,SAASlC,MACT4mB,GAMXzE,EAAOliB,UAAUE,aAAe,WAC5B,MAAO,UAMXgiB,EAAOliB,UAAUG,YAAc,WAE3B,IADA,IAAIC,EAAO2c,EAAchd,KAAKkwB,GAAG,IACxBlkB,EAAI,EAAGA,EAAI,GAAIA,IACpB3L,EAAe,IAAPA,EAAc2c,EAAchd,KAAKkwB,GAAGlkB,IAEhD,OAAO3L,GAOX8hB,EAAOliB,UAAUu2B,yBAA2B,SAAUC,GAElD,OADAA,EAAKC,mBAAqBD,EAAKC,oBAAsB,IAAI3W,EAClD/f,KAAK22B,UAAUF,EAAKG,QAASH,EAAKC,mBAAoBD,EAAK/lB,WAUtEyR,EAAOliB,UAAU02B,UAAY,SAAUp1B,EAAOmoB,EAAUmN,EAAaC,GACjE,GAAI92B,KAAK6vB,YAUL,OATIgH,GACAA,EAAYlU,OAAO,GAEnBphB,GACAA,EAAMohB,OAAO,GAEb+G,GACAA,EAAStnB,eAAe,EAAG,EAAG,EAAG,IAE9B,EAEX,IAAI2B,EAAI/D,KAAKkwB,GAQb,GAPI2G,GACAA,EAAYz0B,eAAe2B,EAAE,IAAKA,EAAE,IAAKA,EAAE,MAE/CxC,EAAQA,GAASyf,EAAQvB,QAAQ,IAC3B5b,EAAIrB,KAAKuF,KAAKhE,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IACzDxC,EAAMmH,EAAIlG,KAAKuF,KAAKhE,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IACzDxC,EAAMoH,EAAInG,KAAKuF,KAAKhE,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,KACtD+yB,EAAqB,CACrB,IAAIC,EAAQD,EAAoBF,QAAQ/yB,EAAI,GAAK,EAAI,EACjDmzB,EAAQF,EAAoBF,QAAQluB,EAAI,GAAK,EAAI,EACjDuuB,EAAQH,EAAoBF,QAAQjuB,EAAI,GAAK,EAAI,EACrDpH,EAAMsC,GAAKkzB,EACXx1B,EAAMmH,GAAKsuB,EACXz1B,EAAMoH,GAAKsuB,OAGPj3B,KAAK2wB,eAAiB,IACtBpvB,EAAMmH,IAAM,GAGpB,GAAiB,IAAbnH,EAAMoe,IAAyB,IAAbpe,EAAMqe,IAAyB,IAAbre,EAAMse,GAI1C,OAHI6J,GACAA,EAAStnB,eAAe,EAAK,EAAK,EAAK,IAEpC,EAEX,GAAIsnB,EAAU,CACV,IAAIwN,EAAK,EAAI31B,EAAMoe,GAAIwX,EAAK,EAAI51B,EAAMqe,GAAIwX,EAAK,EAAI71B,EAAMse,GACzDsC,EAAOwE,gBAAgB5iB,EAAE,GAAKmzB,EAAInzB,EAAE,GAAKmzB,EAAInzB,EAAE,GAAKmzB,EAAI,EAAKnzB,EAAE,GAAKozB,EAAIpzB,EAAE,GAAKozB,EAAIpzB,EAAE,GAAKozB,EAAI,EAAKpzB,EAAE,GAAKqzB,EAAIrzB,EAAE,GAAKqzB,EAAIrzB,EAAE,IAAMqzB,EAAI,EAAK,EAAK,EAAK,EAAK,EAAKpW,EAAQmB,OAAO,IAC7KpC,EAAW0L,wBAAwBzK,EAAQmB,OAAO,GAAIuH,GAE1D,OAAO,GAOXvH,EAAOliB,UAAUo3B,OAAS,SAAU72B,GAChC,GAAIA,EAAQ,GAAKA,EAAQ,EACrB,OAAO,KAEX,IAAIwL,EAAY,EAARxL,EACR,OAAO,IAAIupB,EAAQ/pB,KAAKkwB,GAAGlkB,EAAI,GAAIhM,KAAKkwB,GAAGlkB,EAAI,GAAIhM,KAAKkwB,GAAGlkB,EAAI,GAAIhM,KAAKkwB,GAAGlkB,EAAI,KAQnFmW,EAAOliB,UAAUq3B,OAAS,SAAU92B,EAAO+2B,GACvC,OAAOv3B,KAAKw3B,iBAAiBh3B,EAAO+2B,EAAI1zB,EAAG0zB,EAAI7uB,EAAG6uB,EAAI5uB,EAAG4uB,EAAIza,IAMjEqF,EAAOliB,UAAUw3B,UAAY,WACzB,OAAOtV,EAAOuV,UAAU13B,OAO5BmiB,EAAOliB,UAAU03B,eAAiB,SAAUv2B,GAExC,OADA+gB,EAAOyV,eAAe53B,KAAMoB,GACrBpB,MAWXmiB,EAAOliB,UAAUu3B,iBAAmB,SAAUh3B,EAAOqD,EAAG6E,EAAGC,EAAGmU,GAC1D,GAAItc,EAAQ,GAAKA,EAAQ,EACrB,OAAOR,KAEX,IAAIgM,EAAY,EAARxL,EAMR,OALAR,KAAKkwB,GAAGlkB,EAAI,GAAKnI,EACjB7D,KAAKkwB,GAAGlkB,EAAI,GAAKtD,EACjB1I,KAAKkwB,GAAGlkB,EAAI,GAAKrD,EACjB3I,KAAKkwB,GAAGlkB,EAAI,GAAK8Q,EACjB9c,KAAKmwB,gBACEnwB,MAOXmiB,EAAOliB,UAAUsB,MAAQ,SAAUA,GAC/B,IAAIH,EAAS,IAAI+gB,EAEjB,OADAniB,KAAKwB,WAAWD,EAAOH,GAChBA,GAQX+gB,EAAOliB,UAAUuB,WAAa,SAAUD,EAAOH,GAC3C,IAAK,IAAIZ,EAAQ,EAAGA,EAAQ,GAAIA,IAC5BY,EAAO8uB,GAAG1vB,GAASR,KAAKkwB,GAAG1vB,GAASe,EAGxC,OADAH,EAAO+uB,gBACAnwB,MAQXmiB,EAAOliB,UAAUwB,iBAAmB,SAAUF,EAAOH,GACjD,IAAK,IAAIZ,EAAQ,EAAGA,EAAQ,GAAIA,IAC5BY,EAAO8uB,GAAG1vB,IAAUR,KAAKkwB,GAAG1vB,GAASe,EAGzC,OADAH,EAAO+uB,gBACAnwB,MAMXmiB,EAAOliB,UAAU43B,eAAiB,SAAU1Y,GACxC,IAAIqJ,EAAMxH,EAAQmB,OAAO,GACzBniB,KAAK6Y,YAAY2P,GACjBA,EAAImP,eAAexY,GACnB,IAAIpb,EAAIob,EAAI+Q,GACZ/N,EAAOwE,gBAAgB5iB,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAI,EAAKA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAI,EAAKA,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAAK,EAAK,EAAK,EAAK,EAAK,EAAKob,IAMrHgD,EAAOliB,UAAU63B,kBAAoB,WACjC,IAAI12B,EAAS,IAAI+gB,EAEjB,OADAniB,KAAK+3B,uBAAuB32B,GACrBA,GAOX+gB,EAAOliB,UAAU83B,uBAAyB,SAAU32B,GAChD,IAAIG,EAAQyf,EAAQvB,QAAQ,GAC5B,IAAKzf,KAAK22B,UAAUp1B,GAEhB,OADA4gB,EAAO0P,cAAczwB,GACdpB,KAEX,IAAI+D,EAAI/D,KAAKkwB,GACTgH,EAAK,EAAI31B,EAAMoe,GAAIwX,EAAK,EAAI51B,EAAMqe,GAAIwX,EAAK,EAAI71B,EAAMse,GAEzD,OADAsC,EAAOwE,gBAAgB5iB,EAAE,GAAKmzB,EAAInzB,EAAE,GAAKmzB,EAAInzB,EAAE,GAAKmzB,EAAI,EAAKnzB,EAAE,GAAKozB,EAAIpzB,EAAE,GAAKozB,EAAIpzB,EAAE,GAAKozB,EAAI,EAAKpzB,EAAE,GAAKqzB,EAAIrzB,EAAE,GAAKqzB,EAAIrzB,EAAE,IAAMqzB,EAAI,EAAK,EAAK,EAAK,EAAK,EAAKh2B,GACvJpB,MAKXmiB,EAAOliB,UAAU+3B,6BAA+B,WAC5C,IAAIj0B,EAAI/D,KAAKkwB,GACbnsB,EAAE,KAAO,EACTA,EAAE,KAAO,EACTA,EAAE,KAAO,EACTA,EAAE,KAAO,EACTA,EAAE,MAAQ,EACV/D,KAAKmwB,iBAKThO,EAAOliB,UAAUg4B,kCAAoC,WACjD,IAAIl0B,EAAI/D,KAAKkwB,GACbnsB,EAAE,KAAO,EACTA,EAAE,KAAO,EACTA,EAAE,MAAQ,EACVA,EAAE,MAAQ,EACV/D,KAAKmwB,iBASThO,EAAO7d,UAAY,SAAU/D,EAAOG,QACjB,IAAXA,IAAqBA,EAAS,GAClC,IAAIU,EAAS,IAAI+gB,EAEjB,OADAA,EAAOxhB,eAAeJ,EAAOG,EAAQU,GAC9BA,GAQX+gB,EAAOxhB,eAAiB,SAAUJ,EAAOG,EAAQU,GAC7C,IAAK,IAAIZ,EAAQ,EAAGA,EAAQ,GAAIA,IAC5BY,EAAO8uB,GAAG1vB,GAASD,EAAMC,EAAQE,GAErCU,EAAO+uB,iBASXhO,EAAO+V,4BAA8B,SAAU33B,EAAOG,EAAQa,EAAOH,GACjE,IAAK,IAAIZ,EAAQ,EAAGA,EAAQ,GAAIA,IAC5BY,EAAO8uB,GAAG1vB,GAASD,EAAMC,EAAQE,GAAUa,EAE/CH,EAAO+uB,iBAEXlqB,OAAOC,eAAeic,EAAQ,mBAAoB,CAI9Chc,IAAK,WACD,OAAOgc,EAAOgW,mBAElB9xB,YAAY,EACZC,cAAc,IAsBlB6b,EAAOwE,gBAAkB,SAAUyR,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAY/3B,GAC/N,IAAI2C,EAAI3C,EAAO8uB,GACfnsB,EAAE,GAAKq0B,EACPr0B,EAAE,GAAKs0B,EACPt0B,EAAE,GAAKu0B,EACPv0B,EAAE,GAAKw0B,EACPx0B,EAAE,GAAKy0B,EACPz0B,EAAE,GAAK00B,EACP10B,EAAE,GAAK20B,EACP30B,EAAE,GAAK40B,EACP50B,EAAE,GAAK60B,EACP70B,EAAE,GAAK80B,EACP90B,EAAE,IAAM+0B,EACR/0B,EAAE,IAAMg1B,EACRh1B,EAAE,IAAMi1B,EACRj1B,EAAE,IAAMk1B,EACRl1B,EAAE,IAAMm1B,EACRn1B,EAAE,IAAMo1B,EACR/3B,EAAO+uB,iBAsBXhO,EAAOiX,WAAa,SAAUhB,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,EAAYC,GAC9M,IAAI/3B,EAAS,IAAI+gB,EACbpe,EAAI3C,EAAO8uB,GAkBf,OAjBAnsB,EAAE,GAAKq0B,EACPr0B,EAAE,GAAKs0B,EACPt0B,EAAE,GAAKu0B,EACPv0B,EAAE,GAAKw0B,EACPx0B,EAAE,GAAKy0B,EACPz0B,EAAE,GAAK00B,EACP10B,EAAE,GAAK20B,EACP30B,EAAE,GAAK40B,EACP50B,EAAE,GAAK60B,EACP70B,EAAE,GAAK80B,EACP90B,EAAE,IAAM+0B,EACR/0B,EAAE,IAAMg1B,EACRh1B,EAAE,IAAMi1B,EACRj1B,EAAE,IAAMk1B,EACRl1B,EAAE,IAAMm1B,EACRn1B,EAAE,IAAMo1B,EACR/3B,EAAO+uB,gBACA/uB,GASX+gB,EAAOkX,QAAU,SAAU93B,EAAOmoB,EAAUmN,GACxC,IAAIz1B,EAAS,IAAI+gB,EAEjB,OADAA,EAAOmX,aAAa/3B,EAAOmoB,EAAUmN,EAAaz1B,GAC3CA,GASX+gB,EAAOmX,aAAe,SAAU/3B,EAAOmoB,EAAUmN,EAAaz1B,GAC1D,IAAI2C,EAAI3C,EAAO8uB,GACXrsB,EAAI6lB,EAAS/J,GAAIjX,EAAIghB,EAAS9J,GAAIjX,EAAI+gB,EAAS7J,GAAI/C,EAAI4M,EAASS,GAChEze,EAAK7H,EAAIA,EAAG8H,EAAKjD,EAAIA,EAAG2Q,EAAK1Q,EAAIA,EACjC4wB,EAAK11B,EAAI6H,EAAI8N,EAAK3V,EAAI8H,EAAI4N,EAAK1V,EAAIwV,EACnCmgB,EAAK9wB,EAAIiD,EAAI2N,EAAK5Q,EAAI2Q,EAAIogB,EAAK9wB,EAAI0Q,EACnCqgB,EAAK5c,EAAIpR,EAAIiuB,EAAK7c,EAAInR,EAAIiuB,EAAK9c,EAAIzD,EACnC6d,EAAK31B,EAAMoe,GAAIwX,EAAK51B,EAAMqe,GAAIwX,EAAK71B,EAAMse,GAC7C9b,EAAE,IAAM,GAAKy1B,EAAKC,IAAOvC,EACzBnzB,EAAE,IAAMyV,EAAKogB,GAAM1C,EACnBnzB,EAAE,IAAMwV,EAAKogB,GAAMzC,EACnBnzB,EAAE,GAAK,EACPA,EAAE,IAAMyV,EAAKogB,GAAMzC,EACnBpzB,EAAE,IAAM,GAAKw1B,EAAKE,IAAOtC,EACzBpzB,EAAE,IAAMuV,EAAKogB,GAAMvC,EACnBpzB,EAAE,GAAK,EACPA,EAAE,IAAMwV,EAAKogB,GAAMvC,EACnBrzB,EAAE,IAAMuV,EAAKogB,GAAMtC,EACnBrzB,EAAE,KAAO,GAAKw1B,EAAKC,IAAOpC,EAC1BrzB,EAAE,IAAM,EACRA,EAAE,IAAM8yB,EAAYlX,GACpB5b,EAAE,IAAM8yB,EAAYjX,GACpB7b,EAAE,IAAM8yB,EAAYhX,GACpB9b,EAAE,IAAM,EACR3C,EAAO+uB,iBAMXhO,EAAOwK,SAAW,WACd,IAAIkN,EAAW1X,EAAOiX,WAAW,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GAE5G,OADAS,EAASxJ,uBAAsB,GACxBwJ,GAMX1X,EAAO0P,cAAgB,SAAUzwB,GAC7B+gB,EAAOwE,gBAAgB,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAKvlB,GACvGA,EAAOivB,uBAAsB,IAMjClO,EAAOhX,KAAO,WACV,IAAI2uB,EAAO3X,EAAOiX,WAAW,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,GAExG,OADAU,EAAKzJ,uBAAsB,GACpByJ,GAOX3X,EAAO4X,UAAY,SAAUlsB,GACzB,IAAIzM,EAAS,IAAI+gB,EAEjB,OADAA,EAAO6X,eAAensB,EAAOzM,GACtBA,GAOX+gB,EAAO8X,OAAS,SAAU93B,GACtB,IAAIf,EAAS,IAAI+gB,EAEjB,OADAhgB,EAAO0W,YAAYzX,GACZA,GAOX+gB,EAAO6X,eAAiB,SAAUnsB,EAAOzM,GACrC,IAAI8B,EAAIV,KAAKuM,IAAIlB,GACb+I,EAAIpU,KAAKsM,IAAIjB,GACjBsU,EAAOwE,gBAAgB,EAAK,EAAK,EAAK,EAAK,EAAK/P,EAAG1T,EAAG,EAAK,GAAMA,EAAG0T,EAAG,EAAK,EAAK,EAAK,EAAK,EAAKxV,GAChGA,EAAOivB,sBAA4B,IAANzZ,GAAiB,IAAN1T,IAO5Cif,EAAO+X,UAAY,SAAUrsB,GACzB,IAAIzM,EAAS,IAAI+gB,EAEjB,OADAA,EAAOgY,eAAetsB,EAAOzM,GACtBA,GAOX+gB,EAAOgY,eAAiB,SAAUtsB,EAAOzM,GACrC,IAAI8B,EAAIV,KAAKuM,IAAIlB,GACb+I,EAAIpU,KAAKsM,IAAIjB,GACjBsU,EAAOwE,gBAAgB/P,EAAG,GAAM1T,EAAG,EAAK,EAAK,EAAK,EAAK,EAAKA,EAAG,EAAK0T,EAAG,EAAK,EAAK,EAAK,EAAK,EAAKxV,GAChGA,EAAOivB,sBAA4B,IAANzZ,GAAiB,IAAN1T,IAO5Cif,EAAOiY,UAAY,SAAUvsB,GACzB,IAAIzM,EAAS,IAAI+gB,EAEjB,OADAA,EAAOkY,eAAexsB,EAAOzM,GACtBA,GAOX+gB,EAAOkY,eAAiB,SAAUxsB,EAAOzM,GACrC,IAAI8B,EAAIV,KAAKuM,IAAIlB,GACb+I,EAAIpU,KAAKsM,IAAIjB,GACjBsU,EAAOwE,gBAAgB/P,EAAG1T,EAAG,EAAK,GAAMA,EAAG0T,EAAG,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAKxV,GAChGA,EAAOivB,sBAA4B,IAANzZ,GAAiB,IAAN1T,IAQ5Cif,EAAO0K,aAAe,SAAU9J,EAAMlV,GAClC,IAAIzM,EAAS,IAAI+gB,EAEjB,OADAA,EAAO2K,kBAAkB/J,EAAMlV,EAAOzM,GAC/BA,GAQX+gB,EAAO2K,kBAAoB,SAAU/J,EAAMlV,EAAOzM,GAC9C,IAAI8B,EAAIV,KAAKuM,KAAKlB,GACd+I,EAAIpU,KAAKsM,KAAKjB,GACdysB,EAAK,EAAI1jB,EACbmM,EAAKla,YACL,IAAI9E,EAAI3C,EAAO8uB,GACfnsB,EAAE,GAAKgf,EAAKpD,GAAKoD,EAAKpD,GAAK2a,EAAK1jB,EAChC7S,EAAE,GAAKgf,EAAKpD,GAAKoD,EAAKnD,GAAK0a,EAAKvX,EAAKlD,GAAK3c,EAC1Ca,EAAE,GAAKgf,EAAKpD,GAAKoD,EAAKlD,GAAKya,EAAKvX,EAAKnD,GAAK1c,EAC1Ca,EAAE,GAAK,EACPA,EAAE,GAAKgf,EAAKnD,GAAKmD,EAAKpD,GAAK2a,EAAKvX,EAAKlD,GAAK3c,EAC1Ca,EAAE,GAAKgf,EAAKnD,GAAKmD,EAAKnD,GAAK0a,EAAK1jB,EAChC7S,EAAE,GAAKgf,EAAKnD,GAAKmD,EAAKlD,GAAKya,EAAKvX,EAAKpD,GAAKzc,EAC1Ca,EAAE,GAAK,EACPA,EAAE,GAAKgf,EAAKlD,GAAKkD,EAAKpD,GAAK2a,EAAKvX,EAAKnD,GAAK1c,EAC1Ca,EAAE,GAAKgf,EAAKlD,GAAKkD,EAAKnD,GAAK0a,EAAKvX,EAAKpD,GAAKzc,EAC1Ca,EAAE,IAAMgf,EAAKlD,GAAKkD,EAAKlD,GAAKya,EAAK1jB,EACjC7S,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACR3C,EAAO+uB,iBASXhO,EAAOoY,mBAAqB,SAAU9e,EAAMC,EAAIta,GAC5C,IAAIwV,EAAI6I,EAAQrB,IAAI1C,EAAID,GACpB1X,EAAI3C,EAAO8uB,GACf,GAAItZ,GAAK,EAAI,KAGT7S,EAAE,IAAM,EACRA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,IAAM,EACRA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,GAAK,EACPA,EAAE,IAAM,EACRA,EAAE,IAAM,MAEP,CACD,IAAIZ,EAAIsc,EAAQ8C,MAAM7G,EAAID,GACtB+e,EAAI,GAAK,EAAI5jB,GACjB7S,EAAE,GAAKZ,EAAEwc,GAAKxc,EAAEwc,GAAK6a,EAAI5jB,EACzB7S,EAAE,GAAKZ,EAAEyc,GAAKzc,EAAEwc,GAAK6a,EAAIr3B,EAAE0c,GAC3B9b,EAAE,GAAKZ,EAAE0c,GAAK1c,EAAEwc,GAAK6a,EAAIr3B,EAAEyc,GAC3B7b,EAAE,GAAK,EACPA,EAAE,GAAKZ,EAAEwc,GAAKxc,EAAEyc,GAAK4a,EAAIr3B,EAAE0c,GAC3B9b,EAAE,GAAKZ,EAAEyc,GAAKzc,EAAEyc,GAAK4a,EAAI5jB,EACzB7S,EAAE,GAAKZ,EAAE0c,GAAK1c,EAAEyc,GAAK4a,EAAIr3B,EAAEwc,GAC3B5b,EAAE,GAAK,EACPA,EAAE,GAAKZ,EAAEwc,GAAKxc,EAAE0c,GAAK2a,EAAIr3B,EAAEyc,GAC3B7b,EAAE,GAAKZ,EAAEyc,GAAKzc,EAAE0c,GAAK2a,EAAIr3B,EAAEwc,GAC3B5b,EAAE,IAAMZ,EAAE0c,GAAK1c,EAAE0c,GAAK2a,EAAI5jB,EAC1B7S,EAAE,IAAM,EAEZA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,EACR3C,EAAO+uB,iBASXhO,EAAOnC,qBAAuB,SAAUyN,EAAKC,EAAOC,GAChD,IAAIvsB,EAAS,IAAI+gB,EAEjB,OADAA,EAAO6K,0BAA0BS,EAAKC,EAAOC,EAAMvsB,GAC5CA,GASX+gB,EAAO6K,0BAA4B,SAAUS,EAAKC,EAAOC,EAAMvsB,GAC3D2e,EAAWiN,0BAA0BS,EAAKC,EAAOC,EAAM3M,EAAQjB,WAAW,IAC1EiB,EAAQjB,WAAW,GAAG7K,iBAAiB9T,IAS3C+gB,EAAOsY,QAAU,SAAU52B,EAAG6E,EAAGC,GAC7B,IAAIvH,EAAS,IAAI+gB,EAEjB,OADAA,EAAOuY,aAAa72B,EAAG6E,EAAGC,EAAGvH,GACtBA,GASX+gB,EAAOuY,aAAe,SAAU72B,EAAG6E,EAAGC,EAAGvH,GACrC+gB,EAAOwE,gBAAgB9iB,EAAG,EAAK,EAAK,EAAK,EAAK6E,EAAG,EAAK,EAAK,EAAK,EAAKC,EAAG,EAAK,EAAK,EAAK,EAAK,EAAKvH,GACjGA,EAAOivB,sBAA4B,IAANxsB,GAAiB,IAAN6E,GAAiB,IAANC,IASvDwZ,EAAOwY,YAAc,SAAU92B,EAAG6E,EAAGC,GACjC,IAAIvH,EAAS,IAAI+gB,EAEjB,OADAA,EAAOyY,iBAAiB/2B,EAAG6E,EAAGC,EAAGvH,GAC1BA,GASX+gB,EAAOyY,iBAAmB,SAAU/2B,EAAG6E,EAAGC,EAAGvH,GACzC+gB,EAAOwE,gBAAgB,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK9iB,EAAG6E,EAAGC,EAAG,EAAKvH,GACjGA,EAAOivB,sBAA4B,IAANxsB,GAAiB,IAAN6E,GAAiB,IAANC,IASvDwZ,EAAO5d,KAAO,SAAUs2B,EAAYC,EAAUC,GAC1C,IAAI35B,EAAS,IAAI+gB,EAEjB,OADAA,EAAOxd,UAAUk2B,EAAYC,EAAUC,EAAU35B,GAC1CA,GASX+gB,EAAOxd,UAAY,SAAUk2B,EAAYC,EAAUC,EAAU35B,GAIzD,IAHA,IAAIswB,EAAUtwB,EAAO8uB,GACjB8K,EAASH,EAAW92B,EACpBk3B,EAAOH,EAAS/2B,EACXvD,EAAQ,EAAGA,EAAQ,GAAIA,IAC5BkxB,EAAQlxB,GAASw6B,EAAOx6B,IAAU,EAAMu6B,GAAYE,EAAKz6B,GAASu6B,EAEtE35B,EAAO+uB,iBAYXhO,EAAO+Y,cAAgB,SAAUL,EAAYC,EAAUC,GACnD,IAAI35B,EAAS,IAAI+gB,EAEjB,OADAA,EAAOgZ,mBAAmBN,EAAYC,EAAUC,EAAU35B,GACnDA,GAYX+gB,EAAOgZ,mBAAqB,SAAUN,EAAYC,EAAUC,EAAU35B,GAClE,IAAIg6B,EAAapa,EAAQvB,QAAQ,GAC7B4b,EAAgBra,EAAQjB,WAAW,GACnCub,EAAmBta,EAAQvB,QAAQ,GACvCob,EAAWlE,UAAUyE,EAAYC,EAAeC,GAChD,IAAIC,EAAWva,EAAQvB,QAAQ,GAC3B+b,EAAcxa,EAAQjB,WAAW,GACjC0b,EAAiBza,EAAQvB,QAAQ,GACrCqb,EAASnE,UAAU4E,EAAUC,EAAaC,GAC1C,IAAIC,EAAc1a,EAAQvB,QAAQ,GAClCA,EAAQ9a,UAAUy2B,EAAYG,EAAUR,EAAUW,GAClD,IAAIC,EAAiB3a,EAAQjB,WAAW,GACxCA,EAAW0D,WAAW4X,EAAeG,EAAaT,EAAUY,GAC5D,IAAIC,EAAoB5a,EAAQvB,QAAQ,GACxCA,EAAQ9a,UAAU22B,EAAkBG,EAAgBV,EAAUa,GAC9DzZ,EAAOmX,aAAaoC,EAAaC,EAAgBC,EAAmBx6B,IAUxE+gB,EAAO0Z,SAAW,SAAUC,EAAK7pB,EAAQ+c,GACrC,IAAI5tB,EAAS,IAAI+gB,EAEjB,OADAA,EAAO4Z,cAAcD,EAAK7pB,EAAQ+c,EAAI5tB,GAC/BA,GAUX+gB,EAAO4Z,cAAgB,SAAUD,EAAK7pB,EAAQ+c,EAAI5tB,GAC9C,IAAI2W,EAAQiJ,EAAQvB,QAAQ,GACxBzH,EAAQgJ,EAAQvB,QAAQ,GACxBlI,EAAQyJ,EAAQvB,QAAQ,GAE5BxN,EAAOjQ,cAAc85B,EAAKvkB,GAC1BA,EAAM1O,YAEN4W,EAAQ4D,WAAW2L,EAAIzX,EAAOQ,GAC9B,IAAIikB,EAAgBjkB,EAAML,gBACJ,IAAlBskB,EACAjkB,EAAMlU,EAAI,EAGVkU,EAAM2J,oBAAoBlf,KAAKuF,KAAKi0B,IAGxCvc,EAAQ4D,WAAW9L,EAAOQ,EAAOC,GACjCA,EAAMnP,YAEN,IAAIozB,GAAMxc,EAAQrB,IAAIrG,EAAO+jB,GACzBI,GAAMzc,EAAQrB,IAAIpG,EAAO8jB,GACzBK,GAAM1c,EAAQrB,IAAI7G,EAAOukB,GAC7B3Z,EAAOwE,gBAAgB5O,EAAM4H,GAAI3H,EAAM2H,GAAIpI,EAAMoI,GAAI,EAAK5H,EAAM6H,GAAI5H,EAAM4H,GAAIrI,EAAMqI,GAAI,EAAK7H,EAAM8H,GAAI7H,EAAM6H,GAAItI,EAAMsI,GAAI,EAAKoc,EAAIC,EAAIC,EAAI,EAAK/6B,IAUrJ+gB,EAAOia,SAAW,SAAUN,EAAK7pB,EAAQ+c,GACrC,IAAI5tB,EAAS,IAAI+gB,EAEjB,OADAA,EAAOka,cAAcP,EAAK7pB,EAAQ+c,EAAI5tB,GAC/BA,GAUX+gB,EAAOka,cAAgB,SAAUP,EAAK7pB,EAAQ+c,EAAI5tB,GAC9C,IAAI2W,EAAQiJ,EAAQvB,QAAQ,GACxBzH,EAAQgJ,EAAQvB,QAAQ,GACxBlI,EAAQyJ,EAAQvB,QAAQ,GAE5Bqc,EAAI95B,cAAciQ,EAAQsF,GAC1BA,EAAM1O,YAEN4W,EAAQ4D,WAAW2L,EAAIzX,EAAOQ,GAC9B,IAAIikB,EAAgBjkB,EAAML,gBACJ,IAAlBskB,EACAjkB,EAAMlU,EAAI,EAGVkU,EAAM2J,oBAAoBlf,KAAKuF,KAAKi0B,IAGxCvc,EAAQ4D,WAAW9L,EAAOQ,EAAOC,GACjCA,EAAMnP,YAEN,IAAIozB,GAAMxc,EAAQrB,IAAIrG,EAAO+jB,GACzBI,GAAMzc,EAAQrB,IAAIpG,EAAO8jB,GACzBK,GAAM1c,EAAQrB,IAAI7G,EAAOukB,GAC7B3Z,EAAOwE,gBAAgB5O,EAAM4H,GAAI3H,EAAM2H,GAAIpI,EAAMoI,GAAI,EAAK5H,EAAM6H,GAAI5H,EAAM4H,GAAIrI,EAAMqI,GAAI,EAAK7H,EAAM8H,GAAI7H,EAAM6H,GAAItI,EAAMsI,GAAI,EAAKoc,EAAIC,EAAIC,EAAI,EAAK/6B,IASrJ+gB,EAAOma,gBAAkB,SAAU9Y,EAASwL,GACxC,IAAI5tB,EAAS,IAAI+gB,EAEjB,OADAA,EAAO+M,qBAAqB1L,EAASwL,EAAI5tB,GAClCA,GASX+gB,EAAO+M,qBAAuB,SAAU1L,EAASwL,EAAI5tB,GACjD,IAAIm7B,EAAOvb,EAAQvB,QAAQ,GAC3B8c,EAAKr6B,SAASshB,GACd+Y,EAAK/nB,cAAc,GACnB,IAAI5P,EAAOoc,EAAQvB,QAAQ,GAC3BA,EAAQ4D,WAAW2L,EAAIuN,EAAM33B,GAE7Bud,EAAOwE,gBAAgB/hB,EAAK+a,GAAI/a,EAAKgb,GAAIhb,EAAKib,GAAI,EAAKmP,EAAGrP,GAAIqP,EAAGpP,GAAIoP,EAAGnP,GAAI,EAAK0c,EAAK5c,GAAI4c,EAAK3c,GAAI2c,EAAK1c,GAAI,EAAK,EAAG,EAAG,EAAG,EAAKze,IASnI+gB,EAAOqa,gBAAkB,SAAUhZ,EAASwL,GACxC,IAAI5tB,EAAS,IAAI+gB,EAEjB,OADAA,EAAOkN,qBAAqB7L,EAASwL,EAAI5tB,GAClCA,GASX+gB,EAAOkN,qBAAuB,SAAU7L,EAASwL,EAAI5tB,GACjD,IAAIyD,EAAQmc,EAAQvB,QAAQ,GAC5BA,EAAQ4D,WAAW2L,EAAIxL,EAAS3e,GAEhCsd,EAAOwE,gBAAgB9hB,EAAM8a,GAAI9a,EAAM+a,GAAI/a,EAAMgb,GAAI,EAAKmP,EAAGrP,GAAIqP,EAAGpP,GAAIoP,EAAGnP,GAAI,EAAK2D,EAAQ7D,GAAI6D,EAAQ5D,GAAI4D,EAAQ3D,GAAI,EAAK,EAAG,EAAG,EAAG,EAAKze,IAW/I+gB,EAAOsa,QAAU,SAAUhgB,EAAOC,EAAQggB,EAAOC,EAAMC,GACnD,IAAIhW,EAAS,IAAIzE,EAEjB,OADAA,EAAO0a,aAAapgB,EAAOC,EAAQggB,EAAOC,EAAM/V,EAAQgW,GACjDhW,GAWXzE,EAAO0a,aAAe,SAAUpgB,EAAOC,EAAQggB,EAAOC,EAAMv7B,EAAQw7B,GAChE,IAEI71B,EAAI,EAAM0V,EACV1c,EAAI,EAAM2c,EACV9F,EAAI,GAHA+lB,EADAD,GAKJ9zB,IAJI+zB,EADAD,IACAC,EADAD,GAMRva,EAAOwE,gBAAgB5f,EAAG,EAAK,EAAK,EAAK,EAAKhH,EAAG,EAAK,EAAK,EAAK,EAAK6W,EAAG,EAAK,EAAK,EAAKhO,EAAG,EAAKxH,GAC3Fw7B,GACAx7B,EAAOD,cAAc27B,EAA2B17B,GAEpDA,EAAOivB,sBAA4B,IAANtpB,GAAiB,IAANhH,GAAiB,IAAN6W,GAAiB,IAANhO,IAalEuZ,EAAO4a,iBAAmB,SAAUn4B,EAAMC,EAAOm4B,EAAQC,EAAKP,EAAOC,EAAMC,GACvE,IAAIhW,EAAS,IAAIzE,EAEjB,OADAA,EAAO+a,sBAAsBt4B,EAAMC,EAAOm4B,EAAQC,EAAKP,EAAOC,EAAM/V,EAAQgW,GACrEhW,GAaXzE,EAAO+a,sBAAwB,SAAUt4B,EAAMC,EAAOm4B,EAAQC,EAAKP,EAAOC,EAAMv7B,EAAQw7B,GACpF,IAEI71B,EAAI,GAAOlC,EAAQD,GACnB7E,EAAI,GAAOk9B,EAAMD,GACjBpmB,EAAI,GAHA+lB,EADAD,GAKJ9zB,IAJI+zB,EADAD,IACAC,EADAD,GAMJS,GAAMv4B,EAAOC,IAAUD,EAAOC,GAC9Bu4B,GAAMH,EAAMD,IAAWA,EAASC,GACpC9a,EAAOwE,gBAAgB5f,EAAG,EAAK,EAAK,EAAK,EAAKhH,EAAG,EAAK,EAAK,EAAK,EAAK6W,EAAG,EAAKumB,EAAIC,EAAIx0B,EAAG,EAAKxH,GACzFw7B,GACAx7B,EAAOD,cAAc27B,EAA2B17B,GAEpDA,EAAO+uB,iBAaXhO,EAAOkb,iBAAmB,SAAUz4B,EAAMC,EAAOm4B,EAAQC,EAAKP,EAAOC,EAAMC,GACvE,IAAIhW,EAAS,IAAIzE,EAEjB,OADAA,EAAOmb,sBAAsB14B,EAAMC,EAAOm4B,EAAQC,EAAKP,EAAOC,EAAM/V,EAAQgW,GACrEhW,GAaXzE,EAAOmb,sBAAwB,SAAU14B,EAAMC,EAAOm4B,EAAQC,EAAKP,EAAOC,EAAMv7B,EAAQw7B,GACpFza,EAAO+a,sBAAsBt4B,EAAMC,EAAOm4B,EAAQC,EAAKP,EAAOC,EAAMv7B,EAAQw7B,GAC5Ex7B,EAAO8uB,GAAG,MAAQ,GAYtB/N,EAAOob,cAAgB,SAAU9gB,EAAOC,EAAQggB,EAAOC,EAAMC,EAAYY,QACzC,IAAxBA,IAAkCA,EAAsB,GAC5D,IAAI5W,EAAS,IAAIzE,EAGbpb,EAAK,EAFD21B,EAEYjgB,EAChB1c,EAAK,EAHD28B,EAGYhgB,EAChB9F,GAHI+lB,EADAD,IACAC,EADAD,GAKJ9zB,GAAM,EAJF+zB,EADAD,GACAC,EADAD,GAMJe,EAAMj7B,KAAKk7B,IAAIF,GAMnB,OALArb,EAAOwE,gBAAgB5f,EAAG,EAAK,EAAK,EAAK,EAAKhH,EAAG,EAAK09B,EAAK,EAAK,EAAK7mB,EAAG,EAAK,EAAK,EAAKhO,EAAG,EAAKge,GAC3FgW,GACAhW,EAAOzlB,cAAc27B,EAA2BlW,GAEpDA,EAAOyJ,uBAAsB,GACtBzJ,GAaXzE,EAAOwb,iBAAmB,SAAUC,EAAKC,EAAQnB,EAAOC,EAAMC,EAAYY,EAAqBM,QAC/D,IAAxBN,IAAkCA,EAAsB,QAC7B,IAA3BM,IAAqCA,GAAyB,GAClE,IAAIlX,EAAS,IAAIzE,EAEjB,OADAA,EAAO4b,sBAAsBH,EAAKC,EAAQnB,EAAOC,EAAM/V,GAAQ,EAAMgW,EAAYY,EAAqBM,GAC/FlX,GAcXzE,EAAO4b,sBAAwB,SAAUH,EAAKC,EAAQnB,EAAOC,EAAMv7B,EAAQ48B,EAAoBpB,EAAYY,EAAqBM,QACjG,IAAvBE,IAAiCA,GAAqB,QAC9B,IAAxBR,IAAkCA,EAAsB,QAC7B,IAA3BM,IAAqCA,GAAyB,GAClE,IAAIjzB,EAAI6xB,EACJuB,EAAItB,EACJpxB,EAAI,EAAM/I,KAAKk7B,IAAU,GAANE,GACnB72B,EAAIi3B,EAAqBzyB,EAAIsyB,EAAStyB,EACtCxL,EAAIi+B,EAAqBzyB,EAAIA,EAAIsyB,EACjCjnB,EAAIknB,GAAgC,IAANjzB,GAAW,EAAU,IAANozB,GAAWA,EAAIpzB,IAAMozB,EAAIpzB,GAAK,EAC3EjC,EAAIk1B,GAAgC,IAANjzB,EAAU,EAAIozB,EAAU,IAANA,GAAY,EAAMA,EAAIpzB,GAAMozB,EAAIpzB,IAAM,EAAIA,EAC1F4yB,EAAMj7B,KAAKk7B,IAAIF,GACnBrb,EAAOwE,gBAAgB5f,EAAG,EAAK,EAAK,EAAK,EAAKhH,EAAG,EAAK09B,EAAK,EAAK,EAAK7mB,EAAG,EAAK,EAAK,EAAKhO,EAAG,EAAKxH,GAC3Fw7B,GACAx7B,EAAOD,cAAc27B,EAA2B17B,GAEpDA,EAAOivB,uBAAsB,IAajClO,EAAO+b,6BAA+B,SAAUN,EAAKC,EAAQnB,EAAOC,EAAMv7B,EAAQ48B,EAAoBpB,EAAYY,QACnF,IAAvBQ,IAAiCA,GAAqB,QAC9B,IAAxBR,IAAkCA,EAAsB,GAC5D,IAAIjyB,EAAI,EAAM/I,KAAKk7B,IAAU,GAANE,GACnB72B,EAAIi3B,EAAqBzyB,EAAIsyB,EAAStyB,EACtCxL,EAAIi+B,EAAqBzyB,EAAIA,EAAIsyB,EACjCJ,EAAMj7B,KAAKk7B,IAAIF,GACnBrb,EAAOwE,gBAAgB5f,EAAG,EAAK,EAAK,EAAK,EAAKhH,EAAG,EAAK09B,EAAK,EAAK,GAAMf,EAAO,EAAK,EAAK,EAAK,EAAK,EAAKt7B,GAClGw7B,GACAx7B,EAAOD,cAAc27B,EAA2B17B,GAEpDA,EAAOivB,uBAAsB,IAajClO,EAAOgc,iBAAmB,SAAUP,EAAKC,EAAQnB,EAAOC,EAAMC,EAAYY,EAAqBM,QAC/D,IAAxBN,IAAkCA,EAAsB,QAC7B,IAA3BM,IAAqCA,GAAyB,GAClE,IAAIlX,EAAS,IAAIzE,EAEjB,OADAA,EAAOic,sBAAsBR,EAAKC,EAAQnB,EAAOC,EAAM/V,GAAQ,EAAMgW,EAAYY,EAAqBM,GAC/FlX,GAcXzE,EAAOic,sBAAwB,SAAUR,EAAKC,EAAQnB,EAAOC,EAAMv7B,EAAQ48B,EAAoBpB,EAAYY,EAAqBM,QAKjG,IAAvBE,IAAiCA,GAAqB,QAC9B,IAAxBR,IAAkCA,EAAsB,QAC7B,IAA3BM,IAAqCA,GAAyB,GAClE,IAAIjzB,EAAI6xB,EACJuB,EAAItB,EACJpxB,EAAI,EAAM/I,KAAKk7B,IAAU,GAANE,GACnB72B,EAAIi3B,EAAqBzyB,EAAIsyB,EAAStyB,EACtCxL,EAAIi+B,EAAqBzyB,EAAIA,EAAIsyB,EACjCjnB,EAAIknB,GAAgC,IAANjzB,EAAU,EAAU,IAANozB,IAAYA,EAAIpzB,IAAMozB,EAAIpzB,IAAM,EAC5EjC,EAAIk1B,GAAgC,IAANjzB,EAAU,EAAIozB,EAAU,IAANA,GAAY,EAAIA,EAAIpzB,GAAMozB,EAAIpzB,IAAM,EAAIA,EACxF4yB,EAAMj7B,KAAKk7B,IAAIF,GACnBrb,EAAOwE,gBAAgB5f,EAAG,EAAK,EAAK,EAAK,EAAKhH,EAAG,EAAK09B,EAAK,EAAK,EAAK7mB,GAAI,EAAK,EAAK,EAAKhO,EAAG,EAAKxH,GAC5Fw7B,GACAx7B,EAAOD,cAAc27B,EAA2B17B,GAEpDA,EAAOivB,uBAAsB,IAajClO,EAAOkc,6BAA+B,SAAUT,EAAKC,EAAQnB,EAAOC,EAAMv7B,EAAQ48B,EAAoBpB,EAAYY,QACnF,IAAvBQ,IAAiCA,GAAqB,QAC9B,IAAxBR,IAAkCA,EAAsB,GAC5D,IAAIjyB,EAAI,EAAM/I,KAAKk7B,IAAU,GAANE,GACnB72B,EAAIi3B,EAAqBzyB,EAAIsyB,EAAStyB,EACtCxL,EAAIi+B,EAAqBzyB,EAAIA,EAAIsyB,EACjCJ,EAAMj7B,KAAKk7B,IAAIF,GACnBrb,EAAOwE,gBAAgB5f,EAAG,EAAK,EAAK,EAAK,EAAKhH,EAAG,EAAK09B,EAAK,EAAK,GAAMf,GAAQ,EAAK,EAAK,GAAM,EAAK,EAAKt7B,GACpGw7B,GACAx7B,EAAOD,cAAc27B,EAA2B17B,GAEpDA,EAAOivB,uBAAsB,IAgBjClO,EAAOmc,yBAA2B,SAAUV,EAAKlB,EAAOC,EAAMv7B,EAAQm9B,EAAa3B,EAAYY,QACvE,IAAhBe,IAA0BA,GAAc,QAChB,IAAxBf,IAAkCA,EAAsB,GAC5D,IAAIgB,EAAoBD,GAAe,EAAI,EACvCE,EAAQj8B,KAAKk7B,IAAKE,EAAIc,UAAYl8B,KAAK6J,GAAM,KAC7CsyB,EAAUn8B,KAAKk7B,IAAKE,EAAIgB,YAAcp8B,KAAK6J,GAAM,KACjDwyB,EAAUr8B,KAAKk7B,IAAKE,EAAIkB,YAAct8B,KAAK6J,GAAM,KACjD0yB,EAAWv8B,KAAKk7B,IAAKE,EAAIoB,aAAex8B,KAAK6J,GAAM,KACnD4yB,EAAS,GAAOJ,EAAUE,GAC1BG,EAAS,GAAOT,EAAQE,GACxBlB,EAAMj7B,KAAKk7B,IAAIF,GACfz5B,EAAI3C,EAAO8uB,GACfnsB,EAAE,GAAKk7B,EACPl7B,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAK,EAC5BA,EAAE,GAAKm7B,EACPn7B,EAAE,GAAK,EACPA,EAAE,GAAK05B,EACP15B,EAAE,IAAM86B,EAAUE,GAAYE,EAAS,GACvCl7B,EAAE,KAAQ06B,EAAQE,GAAWO,EAAS,GACtCn7B,EAAE,KAAO44B,GAAQD,EAAQC,GACzB54B,EAAE,IAAM,EAAMy6B,EACdz6B,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAM,EACxBA,EAAE,KAAQ,EAAM44B,EAAOD,GAAUC,EAAOD,GACpCE,GACAx7B,EAAOD,cAAc27B,EAA2B17B,GAEpDA,EAAO+uB,iBAYXhO,EAAOgd,eAAiB,SAAU/Y,EAAUD,EAAOgB,EAAMC,EAAYgY,EAAMC,GACvE,IAAI/Y,EAAKF,EAAS3J,MACd8J,EAAKH,EAAS1J,OACd8J,EAAKJ,EAASviB,EACd4iB,EAAKL,EAAS1d,EACdge,EAAiBvE,EAAOiX,WAAW9S,EAAK,EAAK,EAAK,EAAK,EAAK,GAAMC,EAAK,EAAK,EAAK,EAAK,EAAK,EAAK8Y,EAAOD,EAAM,EAAK5Y,EAAKF,EAAK,EAAKC,EAAK,EAAME,EAAI2Y,EAAM,GACtJxY,EAAS5F,EAAQmB,OAAO,GAG5B,OAFAgE,EAAMhlB,cAAcgmB,EAAMP,GAC1BA,EAAOzlB,cAAcimB,EAAYR,GAC1BA,EAAO3lB,SAASylB,IAO3BvE,EAAOmd,eAAiB,SAAU1Y,GAC9B,IAAI7iB,EAAI6iB,EAAO7iB,EACXw7B,EAAM,CAACx7B,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAC/B,OAAO,oBAA0Cw7B,EAAM,IAAIC,aAAaD,IAO5Epd,EAAOsd,eAAiB,SAAU7Y,GAC9B,IAAI7iB,EAAI6iB,EAAO7iB,EACXw7B,EAAM,CAACx7B,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,KAC7D,OAAO,oBAA0Cw7B,EAAM,IAAIC,aAAaD,IAO5Epd,EAAOuV,UAAY,SAAU9Q,GACzB,IAAIxlB,EAAS,IAAI+gB,EAEjB,OADAA,EAAOyV,eAAehR,EAAQxlB,GACvBA,GAOX+gB,EAAOyV,eAAiB,SAAUhR,EAAQxlB,GACtC,IAAIs+B,EAAKt+B,EAAO8uB,GACZyP,EAAK/Y,EAAO7iB,EAChB27B,EAAG,GAAKC,EAAG,GACXD,EAAG,GAAKC,EAAG,GACXD,EAAG,GAAKC,EAAG,GACXD,EAAG,GAAKC,EAAG,IACXD,EAAG,GAAKC,EAAG,GACXD,EAAG,GAAKC,EAAG,GACXD,EAAG,GAAKC,EAAG,GACXD,EAAG,GAAKC,EAAG,IACXD,EAAG,GAAKC,EAAG,GACXD,EAAG,GAAKC,EAAG,GACXD,EAAG,IAAMC,EAAG,IACZD,EAAG,IAAMC,EAAG,IACZD,EAAG,IAAMC,EAAG,GACZD,EAAG,IAAMC,EAAG,GACZD,EAAG,IAAMC,EAAG,IACZD,EAAG,IAAMC,EAAG,IACZv+B,EAAO+uB,gBAEP/uB,EAAOivB,sBAAsBzJ,EAAOiJ,YAAajJ,EAAOkJ,mBAO5D3N,EAAOyd,WAAa,SAAU/e,GAC1B,IAAI+F,EAAS,IAAIzE,EAEjB,OADAA,EAAO0d,gBAAgBhf,EAAO+F,GACvBA,GAOXzE,EAAO0d,gBAAkB,SAAUhf,EAAOzf,GACtCyf,EAAMhY,YACN,IAAIhF,EAAIgd,EAAMpY,OAAO5E,EACjB6E,EAAImY,EAAMpY,OAAOC,EACjBC,EAAIkY,EAAMpY,OAAOE,EACjBqE,GAAQ,EAAInJ,EACZi8B,GAAS,EAAIp3B,EACbq3B,GAAS,EAAIp3B,EACjBwZ,EAAOwE,gBAAgB3Z,EAAOnJ,EAAI,EAAGi8B,EAAQj8B,EAAGk8B,EAAQl8B,EAAG,EAAKmJ,EAAOtE,EAAGo3B,EAAQp3B,EAAI,EAAGq3B,EAAQr3B,EAAG,EAAKsE,EAAOrE,EAAGm3B,EAAQn3B,EAAGo3B,EAAQp3B,EAAI,EAAG,EAAKqE,EAAO6T,EAAMjY,EAAGk3B,EAAQjf,EAAMjY,EAAGm3B,EAAQlf,EAAMjY,EAAG,EAAKxH,IAS7M+gB,EAAO2M,iBAAmB,SAAUkR,EAAOC,EAAOC,EAAO9+B,GACrD+gB,EAAOwE,gBAAgBqZ,EAAMrgB,GAAIqgB,EAAMpgB,GAAIogB,EAAMngB,GAAI,EAAKogB,EAAMtgB,GAAIsgB,EAAMrgB,GAAIqgB,EAAMpgB,GAAI,EAAKqgB,EAAMvgB,GAAIugB,EAAMtgB,GAAIsgB,EAAMrgB,GAAI,EAAK,EAAK,EAAK,EAAK,EAAKze,IAOxJ+gB,EAAOoJ,oBAAsB,SAAU3B,EAAMxoB,GACzC,IAAIm4B,EAAK3P,EAAKjK,GAAKiK,EAAKjK,GACpB6Z,EAAK5P,EAAKhK,GAAKgK,EAAKhK,GACpB6Z,EAAK7P,EAAK/J,GAAK+J,EAAK/J,GACpBrG,EAAKoQ,EAAKjK,GAAKiK,EAAKhK,GACpBugB,EAAKvW,EAAK/J,GAAK+J,EAAKO,GACpBiW,EAAKxW,EAAK/J,GAAK+J,EAAKjK,GACpB0gB,EAAKzW,EAAKhK,GAAKgK,EAAKO,GACpB7Q,EAAKsQ,EAAKhK,GAAKgK,EAAK/J,GACpBygB,EAAK1W,EAAKjK,GAAKiK,EAAKO,GACxB/oB,EAAO8uB,GAAG,GAAK,EAAM,GAAOsJ,EAAKC,GACjCr4B,EAAO8uB,GAAG,GAAK,GAAO1W,EAAK2mB,GAC3B/+B,EAAO8uB,GAAG,GAAK,GAAOkQ,EAAKC,GAC3Bj/B,EAAO8uB,GAAG,GAAK,EACf9uB,EAAO8uB,GAAG,GAAK,GAAO1W,EAAK2mB,GAC3B/+B,EAAO8uB,GAAG,GAAK,EAAM,GAAOuJ,EAAKF,GACjCn4B,EAAO8uB,GAAG,GAAK,GAAO5W,EAAKgnB,GAC3Bl/B,EAAO8uB,GAAG,GAAK,EACf9uB,EAAO8uB,GAAG,GAAK,GAAOkQ,EAAKC,GAC3Bj/B,EAAO8uB,GAAG,GAAK,GAAO5W,EAAKgnB,GAC3Bl/B,EAAO8uB,GAAG,IAAM,EAAM,GAAOsJ,EAAKD,GAClCn4B,EAAO8uB,GAAG,IAAM,EAChB9uB,EAAO8uB,GAAG,IAAM,EAChB9uB,EAAO8uB,GAAG,IAAM,EAChB9uB,EAAO8uB,GAAG,IAAM,EAChB9uB,EAAO8uB,GAAG,IAAM,EAChB9uB,EAAO+uB,iBAEXhO,EAAOiO,gBAAkB,EACzBjO,EAAOgW,kBAAoBhW,EAAOwK,WAC3BxK,EAp1DgB,GA21DvBnB,EAAyB,WACzB,SAASA,KAKT,OAHAA,EAAQvB,QAAU,eAAsB,GAAIA,EAAQtU,MACpD6V,EAAQmB,OAAS,eAAsB,EAAGA,EAAOwK,UACjD3L,EAAQjB,WAAa,eAAsB,EAAGA,EAAW5U,MAClD6V,EANiB,GAWxBwM,EAA4B,WAC5B,SAASA,KAOT,OALAA,EAAWtQ,QAAU,eAAsB,EAAGA,EAAQ/R,MACtDqiB,EAAW/N,QAAU,eAAsB,GAAIA,EAAQtU,MACvDqiB,EAAWzD,QAAU,eAAsB,EAAGA,EAAQ5e,MACtDqiB,EAAWzN,WAAa,eAAsB,EAAGA,EAAW5U,MAC5DqiB,EAAWrL,OAAS,eAAsB,EAAGA,EAAOwK,UAC7Ca,EARoB,IAW/B,OAAc,kBAAmBtQ,IACjC,OAAc,kBAAmBuC,IACjC,OAAc,kBAAmBsK,IACjC,OAAc,iBAAkB5H,GAChC,IAAI2a,EAA4B3a,EAAOiX,WAAW,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAK,EAAG,EAAG,EAAG,GAAK,I,wDC3vL/FmH,EAAsC,WAMtC,SAASA,EAET7vB,EAEAjI,QACqB,IAAbiI,IAAuBA,EAAW,iBACvB,IAAXjI,IAAqBA,EAAS,UAClCzI,KAAK0Q,SAAWA,EAChB1Q,KAAKyI,OAASA,EASlB,OAHA83B,EAAqBtgC,UAAUgC,MAAQ,WACnC,OAAO,IAAIs+B,EAAqBvgC,KAAK0Q,SAASzO,QAASjC,KAAKyI,OAAOxG,UAEhEs+B,EAvB8B,GA6BrCC,EAA6C,WAO7C,SAASA,EAET9vB,EAEAjI,EAEAg4B,QACqB,IAAb/vB,IAAuBA,EAAW,iBACvB,IAAXjI,IAAqBA,EAAS,eACvB,IAAPg4B,IAAiBA,EAAK,aAC1BzgC,KAAK0Q,SAAWA,EAChB1Q,KAAKyI,OAASA,EACdzI,KAAKygC,GAAKA,EASd,OAHAD,EAA4BvgC,UAAUgC,MAAQ,WAC1C,OAAO,IAAIu+B,EAA4BxgC,KAAK0Q,SAASzO,QAASjC,KAAKyI,OAAOxG,QAASjC,KAAKygC,GAAGx+B,UAExFu+B,EA5BqC,I,iCC9BhD,IAAIE,EAA0B,WAQ1B,SAASA,EAET78B,EAEA6E,EAEA+T,EAEAC,GACI1c,KAAK6D,EAAIA,EACT7D,KAAK0I,EAAIA,EACT1I,KAAKyc,MAAQA,EACbzc,KAAK0c,OAASA,EAgClB,OAxBAgkB,EAASzgC,UAAU0gC,SAAW,SAAUC,EAAaC,GACjD,OAAO,IAAIH,EAAS1gC,KAAK6D,EAAI+8B,EAAa5gC,KAAK0I,EAAIm4B,EAAc7gC,KAAKyc,MAAQmkB,EAAa5gC,KAAK0c,OAASmkB,IAS7GH,EAASzgC,UAAU6gC,cAAgB,SAAUF,EAAaC,EAAc1hB,GAKpE,OAJAA,EAAItb,EAAI7D,KAAK6D,EAAI+8B,EACjBzhB,EAAIzW,EAAI1I,KAAK0I,EAAIm4B,EACjB1hB,EAAI1C,MAAQzc,KAAKyc,MAAQmkB,EACzBzhB,EAAIzC,OAAS1c,KAAK0c,OAASmkB,EACpB7gC,MAMX0gC,EAASzgC,UAAUgC,MAAQ,WACvB,OAAO,IAAIy+B,EAAS1gC,KAAK6D,EAAG7D,KAAK0I,EAAG1I,KAAKyc,MAAOzc,KAAK0c,SAElDgkB,EApDkB,I,kECmCzBK,EAAuB,CACvBv+B,KAAKuF,KAAK,GAAK,EAAIvF,KAAK6J,MACvB7J,KAAKuF,KAAK,GAAK,EAAIvF,KAAK6J,KACzB7J,KAAKuF,KAAK,GAAK,EAAIvF,KAAK6J,MACvB7J,KAAKuF,KAAK,GAAK,EAAIvF,KAAK6J,KACzB7J,KAAKuF,KAAK,IAAM,EAAIvF,KAAK6J,MACxB7J,KAAKuF,KAAK,IAAM,EAAIvF,KAAK6J,KAC1B7J,KAAKuF,KAAK,GAAK,GAAKvF,KAAK6J,MACxB7J,KAAKuF,KAAK,IAAM,EAAIvF,KAAK6J,KAC1B7J,KAAKuF,KAAK,IAAM,GAAKvF,KAAK6J,MAM1B20B,EAAgC,CAChC,WAAc,OAAO,GACrB,SAAUrnB,GAAa,OAAOA,EAAUjR,GACxC,SAAUiR,GAAa,OAAOA,EAAUhR,GACxC,SAAUgR,GAAa,OAAOA,EAAU9V,GACxC,SAAU8V,GAAa,OAAOA,EAAU9V,EAAI8V,EAAUjR,GACtD,SAAUiR,GAAa,OAAOA,EAAUjR,EAAIiR,EAAUhR,GACtD,SAAUgR,GAAa,OAAO,EAAIA,EAAUhR,EAAIgR,EAAUhR,EAAI,GAC9D,SAAUgR,GAAa,OAAOA,EAAU9V,EAAI8V,EAAUhR,GACtD,SAAUgR,GAAa,OAAOA,EAAU9V,EAAI8V,EAAU9V,EAAI8V,EAAUjR,EAAIiR,EAAUjR,IAGlFu4B,EAAW,SAAUC,EAAIvnB,GACzB,OAAOonB,EAAqBG,GAAMF,EAA8BE,GAAIvnB,IAIpEwnB,EAAyB,CAAC3+B,KAAK6J,GAAK,EAAI7J,KAAK6J,GAAM,EAAI,EAAI7J,KAAK6J,GAAM,EAAI,EAAI7J,KAAK6J,GAAM,EAAG7J,KAAK6J,GAAK,EAAG7J,KAAK6J,GAAK,EAAG7J,KAAK6J,GAAK,EAAG7J,KAAK6J,GAAK,EAAG7J,KAAK6J,GAAK,GAI1J+0B,EAAoC,WACpC,SAASA,IAILphC,KAAKqhC,WAAY,EAIjBrhC,KAAKshC,IAAM,WAIXthC,KAAKuhC,KAAO,WAIZvhC,KAAKwhC,IAAM,WAIXxhC,KAAKyhC,IAAM,WAIXzhC,KAAK0hC,KAAO,WAIZ1hC,KAAK2hC,KAAO,WAIZ3hC,KAAK4hC,IAAM,WAIX5hC,KAAK6hC,IAAM,WAIX7hC,KAAK8hC,IAAM,WA4Kf,OApKAV,EAAmBnhC,UAAU8hC,SAAW,SAAUpoB,EAAW1S,EAAO+6B,GAChE,oBAA0B/6B,EAAMpH,EAAGoH,EAAMnH,EAAGmH,EAAMlH,GAClD,IAAIkiC,EAAc,gBACdrrB,EAAI,gBACRqrB,EAAYzgC,WAAWwgC,EAAiBprB,GACxCA,EAAEpV,WAAWy/B,EAAS,EAAGtnB,GAAY,iBACrC3Z,KAAKshC,IAAIt6B,WAAW,iBACpB4P,EAAEpV,WAAWy/B,EAAS,EAAGtnB,GAAY,iBACrC3Z,KAAKuhC,KAAKv6B,WAAW,iBACrB4P,EAAEpV,WAAWy/B,EAAS,EAAGtnB,GAAY,iBACrC3Z,KAAKwhC,IAAIx6B,WAAW,iBACpB4P,EAAEpV,WAAWy/B,EAAS,EAAGtnB,GAAY,iBACrC3Z,KAAKyhC,IAAIz6B,WAAW,iBACpB4P,EAAEpV,WAAWy/B,EAAS,EAAGtnB,GAAY,iBACrC3Z,KAAK0hC,KAAK16B,WAAW,iBACrB4P,EAAEpV,WAAWy/B,EAAS,EAAGtnB,GAAY,iBACrC3Z,KAAK2hC,KAAK36B,WAAW,iBACrB4P,EAAEpV,WAAWy/B,EAAS,EAAGtnB,GAAY,iBACrC3Z,KAAK4hC,IAAI56B,WAAW,iBACpB4P,EAAEpV,WAAWy/B,EAAS,EAAGtnB,GAAY,iBACrC3Z,KAAK6hC,IAAI76B,WAAW,iBACpB4P,EAAEpV,WAAWy/B,EAAS,EAAGtnB,GAAY,iBACrC3Z,KAAK8hC,IAAI96B,WAAW,kBAMxBo6B,EAAmBnhC,UAAUuU,aAAe,SAAUjT,GAClDvB,KAAKshC,IAAI9sB,aAAajT,GACtBvB,KAAKuhC,KAAK/sB,aAAajT,GACvBvB,KAAKwhC,IAAIhtB,aAAajT,GACtBvB,KAAKyhC,IAAIjtB,aAAajT,GACtBvB,KAAK0hC,KAAKltB,aAAajT,GACvBvB,KAAK2hC,KAAKntB,aAAajT,GACvBvB,KAAK4hC,IAAIptB,aAAajT,GACtBvB,KAAK6hC,IAAIrtB,aAAajT,GACtBvB,KAAK8hC,IAAIttB,aAAajT,IAa1B6/B,EAAmBnhC,UAAUiiC,oCAAsC,WAE/DliC,KAAKshC,IAAI9sB,aAAa2sB,EAAuB,IAE7CnhC,KAAKuhC,KAAK/sB,aAAa2sB,EAAuB,IAC9CnhC,KAAKwhC,IAAIhtB,aAAa2sB,EAAuB,IAC7CnhC,KAAKyhC,IAAIjtB,aAAa2sB,EAAuB,IAE7CnhC,KAAK0hC,KAAKltB,aAAa2sB,EAAuB,IAC9CnhC,KAAK2hC,KAAKntB,aAAa2sB,EAAuB,IAC9CnhC,KAAK4hC,IAAIptB,aAAa2sB,EAAuB,IAC7CnhC,KAAK6hC,IAAIrtB,aAAa2sB,EAAuB,IAC7CnhC,KAAK8hC,IAAIttB,aAAa2sB,EAAuB,KAWjDC,EAAmBnhC,UAAUkiC,sCAAwC,WACjEniC,KAAKwU,aAAa,EAAMhS,KAAK6J,KAWjC+0B,EAAmBnhC,UAAUmiC,qBAAuB,WAChDpiC,KAAKqhC,WAAY,EACjBrhC,KAAKshC,IAAI9sB,aAAausB,EAAqB,IAC3C/gC,KAAKuhC,KAAK/sB,aAAausB,EAAqB,IAC5C/gC,KAAKwhC,IAAIhtB,aAAausB,EAAqB,IAC3C/gC,KAAKyhC,IAAIjtB,aAAausB,EAAqB,IAC3C/gC,KAAK0hC,KAAKltB,aAAausB,EAAqB,IAC5C/gC,KAAK2hC,KAAKntB,aAAausB,EAAqB,IAC5C/gC,KAAK4hC,IAAIptB,aAAausB,EAAqB,IAC3C/gC,KAAK6hC,IAAIrtB,aAAausB,EAAqB,IAC3C/gC,KAAK8hC,IAAIttB,aAAausB,EAAqB,KAO/CK,EAAmBnhC,UAAUoiC,gBAAkB,SAAU1W,GAUrD,OATA,mBAAuBA,EAAK,GAAI,EAAG3rB,KAAKshC,KACxC,mBAAuB3V,EAAK,GAAI,EAAG3rB,KAAKuhC,MACxC,mBAAuB5V,EAAK,GAAI,EAAG3rB,KAAKwhC,KACxC,mBAAuB7V,EAAK,GAAI,EAAG3rB,KAAKyhC,KACxC,mBAAuB9V,EAAK,GAAI,EAAG3rB,KAAK0hC,MACxC,mBAAuB/V,EAAK,GAAI,EAAG3rB,KAAK2hC,MACxC,mBAAuBhW,EAAK,GAAI,EAAG3rB,KAAK4hC,KACxC,mBAAuBjW,EAAK,GAAI,EAAG3rB,KAAK6hC,KACxC,mBAAuBlW,EAAK,GAAI,EAAG3rB,KAAK8hC,KACjC9hC,MAOXohC,EAAmBnhC,UAAUqiC,sBAAwB,SAAU3W,GAU3D,OATA,oBAAwBA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAI3rB,KAAKshC,KACxD,oBAAwB3V,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAI3rB,KAAKuhC,MACxD,oBAAwB5V,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAI3rB,KAAKwhC,KACxD,oBAAwB7V,EAAK,GAAIA,EAAK,IAAKA,EAAK,IAAK3rB,KAAKyhC,KAC1D,oBAAwB9V,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK3rB,KAAK0hC,MAC3D,oBAAwB/V,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK3rB,KAAK2hC,MAC3D,oBAAwBhW,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK3rB,KAAK4hC,KAC3D,oBAAwBjW,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK3rB,KAAK6hC,KAC3D,oBAAwBlW,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAK3rB,KAAK8hC,KACpD9hC,MAOXohC,EAAmB98B,UAAY,SAAUqnB,GAErC,OADS,IAAIyV,GACHiB,gBAAgB1W,IAQ9ByV,EAAmBmB,eAAiB,SAAUC,GAC1C,IAAIphC,EAAS,IAAIggC,EAejB,OAdAhgC,EAAOkgC,IAAMkB,EAAWjJ,GAAGh4B,MAAM,SAAUM,IAAI2gC,EAAWhJ,GAAGj4B,MAAM,UAAWM,IAAI2gC,EAAW/I,GAAGl4B,MAAM,UACtGH,EAAOmgC,KAAOiB,EAAW95B,EAAEnH,MAAM,SACjCH,EAAOogC,IAAMgB,EAAW75B,EAAEpH,MAAM,SAChCH,EAAOqgC,IAAMe,EAAW3+B,EAAEtC,MAAM,SAChCH,EAAOsgC,KAAOc,EAAWhpB,GAAGjY,MAAM,SAClCH,EAAOugC,KAAOa,EAAWlpB,GAAG/X,MAAM,SAClCH,EAAOwgC,IAAMY,EAAW/I,GAAGl4B,MAAM,SAASQ,SAASygC,EAAWjJ,GAAGh4B,MAAM,UAAWQ,SAASygC,EAAWhJ,GAAGj4B,MAAM,UAC/GH,EAAOygC,IAAMW,EAAWpC,GAAG7+B,MAAM,SACjCH,EAAO0gC,IAAMU,EAAWjJ,GAAGh4B,MAAM,SAASQ,SAASygC,EAAWhJ,GAAGj4B,MAAM,UACvEH,EAAOmgC,KAAK/sB,cAAc,GAC1BpT,EAAOqgC,IAAIjtB,cAAc,GACzBpT,EAAOugC,KAAKntB,cAAc,GAC1BpT,EAAOygC,IAAIrtB,cAAc,GACzBpT,EAAOoT,aAAahS,KAAK6J,IAClBjL,GAEJggC,EArN4B,GA2NnCqB,EAAqC,WACrC,SAASA,IAILziC,KAAK6D,EAAI,WAIT7D,KAAK0I,EAAI,WAIT1I,KAAK2I,EAAI,WAIT3I,KAAKu5B,GAAK,WAIVv5B,KAAKw5B,GAAK,WAIVx5B,KAAKy5B,GAAK,WAIVz5B,KAAKwZ,GAAK,WAIVxZ,KAAKsZ,GAAK,WAIVtZ,KAAKogC,GAAK,WAsGd,OApGAn6B,OAAOC,eAAeu8B,EAAoBxiC,UAAW,qBAAsB,CAIvEkG,IAAK,WAOD,OANKnG,KAAK0iC,aACN1iC,KAAK0iC,WAAatB,EAAmBmB,eAAeviC,OAEnDA,KAAK0iC,WAAWrB,WACjBrhC,KAAK0iC,WAAWN,uBAEbpiC,KAAK0iC,YAEhBr8B,YAAY,EACZC,cAAc,IAMlBm8B,EAAoBxiC,UAAU0iC,WAAa,SAAU17B,GACjD,+BAAqCA,EAAMpH,EAAGoH,EAAMnH,EAAGmH,EAAMlH,GAC7D,IAAIkiC,EAAc,gBAClBjiC,KAAKu5B,GAAGvyB,WAAWi7B,GACnBjiC,KAAKw5B,GAAGxyB,WAAWi7B,GACnBjiC,KAAKy5B,GAAGzyB,WAAWi7B,IAMvBQ,EAAoBxiC,UAAUuU,aAAe,SAAUjT,GACnDvB,KAAK6D,EAAE2Q,aAAajT,GACpBvB,KAAK0I,EAAE8L,aAAajT,GACpBvB,KAAK2I,EAAE6L,aAAajT,GACpBvB,KAAKu5B,GAAG/kB,aAAajT,GACrBvB,KAAKw5B,GAAGhlB,aAAajT,GACrBvB,KAAKy5B,GAAGjlB,aAAajT,GACrBvB,KAAKsZ,GAAG9E,aAAajT,GACrBvB,KAAKogC,GAAG5rB,aAAajT,GACrBvB,KAAKwZ,GAAGhF,aAAajT,IAOzBkhC,EAAoBxiC,UAAU2iC,oBAAsB,SAAUC,GAwB1D,OAvBA7iC,KAAK0iC,WAAaG,EAClB7iC,KAAK6D,EAAE3B,SAAS2gC,EAAUpB,KAC1BzhC,KAAK6D,EAAE2Q,aAAa,SAASA,cAAc,GAC3CxU,KAAK0I,EAAExG,SAAS2gC,EAAUtB,MAC1BvhC,KAAK0I,EAAE8L,aAAa,SAASA,cAAc,GAC3CxU,KAAK2I,EAAEzG,SAAS2gC,EAAUrB,KAC1BxhC,KAAK2I,EAAE6L,aAAa,SACpBxU,KAAKu5B,GAAGr3B,SAAS2gC,EAAUvB,KAC3B,yBAA+BuB,EAAUjB,KAAKptB,aAAa,SAC3D,yBAA+BquB,EAAUf,KAAKttB,aAAa,SAC3DxU,KAAKu5B,GAAG/kB,aAAa,SAAU6I,gBAAgB,iBAAuBrW,WAAW,iBACjFhH,KAAKw5B,GAAGt3B,SAAS2gC,EAAUvB,KAC3BthC,KAAKw5B,GAAGhlB,aAAa,SAAU6I,gBAAgB,iBAAuBA,gBAAgB,iBACtFrd,KAAKy5B,GAAGv3B,SAAS2gC,EAAUvB,KAC3B,yBAA+BuB,EAAUjB,KAAKptB,aAAa,SAC3DxU,KAAKy5B,GAAGjlB,aAAa,SAAUxN,WAAW,iBAC1ChH,KAAKsZ,GAAGpX,SAAS2gC,EAAUlB,MAC3B3hC,KAAKsZ,GAAG9E,aAAa,SAAUA,cAAc,GAC7CxU,KAAKogC,GAAGl+B,SAAS2gC,EAAUhB,KAC3B7hC,KAAKogC,GAAG5rB,aAAa,SAAUA,cAAc,GAC7CxU,KAAKwZ,GAAGtX,SAAS2gC,EAAUnB,MAC3B1hC,KAAKwZ,GAAGhF,aAAa,SACrBxU,KAAKwU,aAAa,EAAMhS,KAAK6J,IACtBrM,MAOXyiC,EAAoBK,cAAgB,SAAUD,GAE1C,OADa,IAAIJ,GACHG,oBAAoBC,IAOtCJ,EAAoBn+B,UAAY,SAAUqnB,GACtC,IAAIoX,EAAK,IAAIN,EAUb,OATA,mBAAuB9W,EAAK,GAAI,EAAGoX,EAAGl/B,GACtC,mBAAuB8nB,EAAK,GAAI,EAAGoX,EAAGr6B,GACtC,mBAAuBijB,EAAK,GAAI,EAAGoX,EAAGp6B,GACtC,mBAAuBgjB,EAAK,GAAI,EAAGoX,EAAGxJ,IACtC,mBAAuB5N,EAAK,GAAI,EAAGoX,EAAGvJ,IACtC,mBAAuB7N,EAAK,GAAI,EAAGoX,EAAGtJ,IACtC,mBAAuB9N,EAAK,GAAI,EAAGoX,EAAGzpB,IACtC,mBAAuBqS,EAAK,GAAI,EAAGoX,EAAG3C,IACtC,mBAAuBzU,EAAK,GAAI,EAAGoX,EAAGvpB,IAC/BupB,GAEJN,EA3I6B,I,8GCtQjC,SAASO,EAAoBC,GAChC,IAOI55B,EANAC,EAAU,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IACxI45B,EAAU,CACV,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC1K,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAEpDC,EAAM,GAEN1mB,EAAQwmB,EAAQxmB,OAASwmB,EAAQjgB,MAAQ,EACzCtG,EAASumB,EAAQvmB,QAAUumB,EAAQjgB,MAAQ,EAC3CogB,EAAQH,EAAQG,OAASH,EAAQjgB,MAAQ,EACzCqgB,EAAOJ,EAAQI,OAAQ,EACvBC,OAAkC,IAAtBL,EAAQK,UAAuB,EAAIL,EAAQK,UACvDC,OAAwC,IAAzBN,EAAQM,aAA0B,EAAIN,EAAQM,aAK7DC,EAFW,CAAC,EAAG,EAAG,EAAG,GAFzBF,GAAaA,EAAY,GAAK,GAK1BG,EAFc,CAAC,EAAG,EAAG,EAAG,GAF5BF,GAAgBA,EAAe,GAAK,GAKhCG,EAAgB,CAChB,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EACzK,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAEjF,GAAIL,EAAM,CACN/5B,EAAU,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,IACxFo6B,EAAgB,EACX,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAgBzK,IAdA,IAAIC,EAAc,CACd,CAAC,EAAG,EAAG,GACP,EAAE,EAAG,EAAG,GACR,EAAE,EAAG,GAAI,GACT,CAAC,EAAG,GAAI,IAERC,EAAiB,CACjB,EAAE,GAAI,EAAG,GACT,CAAC,GAAI,EAAG,GACR,CAAC,GAAI,GAAI,GACT,EAAE,GAAI,GAAI,IAEVC,EAAe,CAAC,GAAI,GAAI,GAAI,IAC5BC,EAAkB,CAAC,GAAI,GAAI,GAAI,IAC5BN,EAAW,GACdG,EAAYI,QAAQJ,EAAYK,OAChCH,EAAaE,QAAQF,EAAaG,OAClCR,IAEJ,KAAOC,EAAc,GACjBG,EAAeG,QAAQH,EAAeI,OACtCF,EAAgBC,QAAQD,EAAgBE,OACxCP,IAEJE,EAAcA,EAAYM,OAC1BL,EAAiBA,EAAeK,OAChCP,EAAgBA,EAAc/mB,OAAOgnB,GAAahnB,OAAOinB,GACzDt6B,EAAQjB,KAAKw7B,EAAa,GAAIA,EAAa,GAAIA,EAAa,GAAIA,EAAa,GAAIA,EAAa,GAAIA,EAAa,IAC/Gv6B,EAAQjB,KAAKy7B,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,IAErI,IAAII,EAAa,CAACznB,EAAQ,EAAGC,EAAS,EAAG0mB,EAAQ,GACjD/5B,EAAYq6B,EAAcS,QAAO,SAAUC,EAAaC,EAAcC,GAAgB,OAAOF,EAAYznB,OAAO0nB,EAAeH,EAAWI,EAAe,MAAQ,IAMjK,IALA,IAAIC,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBACjFC,EAASvB,EAAQuB,QAAU,IAAIt6B,MAAM,GACrCu6B,EAAaxB,EAAQwB,WACrBl9B,EAAS,GAEJ02B,EAAI,EAAGA,EAAI,EAAGA,SACDjU,IAAdwa,EAAOvG,KACPuG,EAAOvG,GAAK,IAAI,KAAQ,EAAG,EAAG,EAAG,IAEjCwG,QAAgCza,IAAlBya,EAAWxG,KACzBwG,EAAWxG,GAAK,IAAI,KAAO,EAAG,EAAG,EAAG,IAI5C,IAAK,IAAIz9B,EAAQ,EAAGA,EA3EN,EA2EuBA,IAKjC,GAJA2iC,EAAI96B,KAAKm8B,EAAOhkC,GAAOmI,EAAG,8BAAiD,EAAM67B,EAAOhkC,GAAOsc,EAAI0nB,EAAOhkC,GAAOsc,GACjHqmB,EAAI96B,KAAKm8B,EAAOhkC,GAAOqD,EAAG,8BAAiD,EAAM2gC,EAAOhkC,GAAOsc,EAAI0nB,EAAOhkC,GAAOsc,GACjHqmB,EAAI96B,KAAKm8B,EAAOhkC,GAAOqD,EAAG,8BAAiD,EAAM2gC,EAAOhkC,GAAOkI,EAAI87B,EAAOhkC,GAAOkI,GACjHy6B,EAAI96B,KAAKm8B,EAAOhkC,GAAOmI,EAAG,8BAAiD,EAAM67B,EAAOhkC,GAAOkI,EAAI87B,EAAOhkC,GAAOkI,GAC7G+7B,EACA,IAAK,IAAI7tB,EAAI,EAAGA,EAAI,EAAGA,IACnBrP,EAAOc,KAAKo8B,EAAWjkC,GAAOX,EAAG4kC,EAAWjkC,GAAOV,EAAG2kC,EAAWjkC,GAAOT,EAAG0kC,EAAWjkC,GAAOuG,GAKzG,kBAAyBw9B,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SAEtG,IAAIC,EAAa,IAAI,IAKrB,GAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACbsB,EAAY,CACZ,IAAII,EAAcN,IAAoB,eAAwBh9B,EAAOoV,OAAOpV,GAAUA,EACtFq9B,EAAWr9B,OAASs9B,EAExB,OAAOD,EA8BJ,SAASE,EAAUC,EAAM9B,EAAS+B,QACrB,IAAZ/B,IAAsBA,EAAU,SACtB,IAAV+B,IAAoBA,EAAQ,MAChC,IAAIC,EAAM,IAAI,KAAKF,EAAMC,GAKzB,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClEU,EAAIC,gCAAkCjC,EAAQsB,gBAC7BvB,EAAoBC,GAC1BkC,YAAYF,EAAKhC,EAAQmC,WAC7BH,EAMJ,IAAII,EAAa,CAEpBP,UAAWA,GAGf,cAAuB9B,EACvB,eAAiB,SAAU+B,EAAM/hB,EAAMgiB,EAAOI,EAAWb,GAOrD,YANc,IAAVS,IAAoBA,EAAQ,MAMzBF,EAAUC,EALH,CACV/hB,KAAMA,EACNuhB,gBAAiBA,EACjBa,UAAWA,GAEiBJ,K,mGChL7B,SAASM,EAAwBrC,QACpB,IAAZA,IAAsBA,EAAU,CAChCsC,aAAc,EACdC,aAAc,GACd9oB,OAAQ,EACRrP,OAAQ,IACRo4B,gBAAiB,IAErB,IAsBI5hC,EAAG6E,EAtBH68B,EAAe/iC,KAAKZ,IAAIqhC,EAAQsC,aAAetC,EAAQsC,aAAe,EAAG,GACzEC,EAAehjC,KAAKZ,IAAIqhC,EAAQuC,aAAevC,EAAQuC,aAAe,GAAI,GAC1E9oB,EAASla,KAAKZ,IAAIqhC,EAAQvmB,OAASumB,EAAQvmB,OAAS,EAAG,GACvDrP,EAAS7K,KAAKZ,IAAIqhC,EAAQ51B,OAAS41B,EAAQ51B,OAAS,IAAM,GAC1Dq4B,EAAYljC,KAAKZ,IAAIqhC,EAAQwC,gBAAkBxC,EAAQwC,gBAAkB,EAAG,GAC5EE,EAAiBH,EACjBI,EAAiBL,EACjBM,EAAYrjC,KAAKZ,IAAIqhC,EAAQ4C,UAAY5C,EAAQ4C,UAAYx4B,EAAQ,GACrEy4B,EAAetjC,KAAKZ,IAAIqhC,EAAQ6C,aAAe7C,EAAQ6C,aAAez4B,EAAQ,GAC9E04B,EAAkBrpB,GAAUmpB,EAAYC,GAExCE,EAAc,EAAMxjC,KAAK6J,GACzB45B,EAAkBzjC,KAAKZ,IAAIqhC,EAAQiD,mBAAqBjD,EAAQiD,mBAAqBR,EAAW,GAChGS,EAAqB3jC,KAAKZ,IAAIqhC,EAAQmD,sBAAwBnD,EAAQmD,sBAAwBV,EAAW,GACzG7kC,EAAQ2B,KAAK4gB,MAAM0iB,EAAeD,GAAanpB,GAC/CpT,EAAU,GACV+8B,EAAW,GACXnD,EAAU,GACVC,EAAM,GACN3iC,EAAQ,EACR8lC,EAAa,GAAIC,EAA+B,GAAlBR,EAC9BS,EAAgB,GAAVhkC,KAAK6J,GAEX5D,EAAS,WACTg+B,EAAS,WACTC,EAAWlkC,KAAKsM,IAAIjO,GACpB8lC,EAAWnkC,KAAKuM,IAAIlO,GACpB+lC,EAAa,IAAI,KAAQf,EAAYc,EAAUJ,EAAaV,EAAYa,GACvE3kC,SAAS,IAAI,KAAQ+jC,EAAea,EAAwBb,EAAeY,EAA5BH,IAC/CpiC,SAED0iC,EAAKhB,EAAYhlC,EAAQ+lC,EAAad,GAAgBU,EAAM3lC,GAC5DsC,EAAI,EACR,IAAKuF,EAAI,EAAGA,GAAKu9B,EAAiBv9B,IAAK,CACnC,IAAIo+B,EAAW,GACX//B,EAAIy/B,EAAM3lC,GAAS6H,EAAIu9B,GAC3B9iC,GAAM0iC,EAAYhlC,EAASolC,EAC3B,IAAI3d,EAAO9lB,KAAKsM,IAAI/H,GAChBggC,EAAOvkC,KAAKuM,IAAIhI,GAEhBigC,EAAU1e,EAAOud,EACrB,IAAKhiC,EAAI,EAAGA,GAAK8hC,EAAgB9hC,IAAK,CAClC,IACIqU,GADA+uB,EAAIpjC,EAAI8hC,GACIK,EAjCP,EAkCLkB,EAAW1kC,KAAKuM,IAAImJ,GACpBivB,EAAW3kC,KAAKsM,IAAIoJ,GAExBuuB,EAAO5iC,EAAImjC,EAAUE,EACrBT,EAAO/9B,EAAI69B,EAAaQ,EAAOlB,EAC/BY,EAAO99B,EAAIq+B,EAAUG,EACrBd,EAASh+B,KAAKo+B,EAAO5iC,EAAG4iC,EAAO/9B,EAAG+9B,EAAO99B,GAEzCF,EAAOpG,IAAIimB,EAAO4e,EAAUH,EAAMze,EAAO6e,GACzCjE,EAAQ76B,KAAKI,EAAO5E,EAAG4E,EAAOC,EAAGD,EAAOE,GAExCw6B,EAAI96B,KAAK4+B,EAAG,8BAAiD9jC,EAAI0jC,EAAK,EAAI1jC,EAAI0jC,GAE9EC,EAASz+B,KAAK7H,GAEdA,IAGJ8lC,EAAWj+B,KAAKy+B,GAEpB,IAAIM,EAAa1qB,EAASmpB,EAAYC,EAAeY,EAAWb,EAAYa,EAAWZ,EACnFuB,EAASV,GAAYb,EAAeD,GAAcuB,EACtD,IAAK1+B,EAAI,EAAGA,GAAKk9B,EAAgBl9B,IAAK,CAC9Bo+B,EAAW,GACf3jC,GAAKyjC,EAAahB,EAEdoB,EAAUL,GAAaj+B,GAAKo9B,EAAeD,GAAcD,EAAiBC,GAC9E,IAAKhiC,EAAI,EAAGA,GAAK8hC,EAAgB9hC,IAAK,CAE9BqU,GADA+uB,EAAIpjC,EAAI8hC,GACIK,EA/DP,EAgELkB,EAAW1kC,KAAKuM,IAAImJ,GACpBivB,EAAW3kC,KAAKsM,IAAIoJ,GAExBuuB,EAAO5iC,EAAImjC,EAAUE,EACrBT,EAAO/9B,EAAI69B,EAAaG,EAAWb,EAAan9B,EAAI0+B,EAAcxB,EAClEa,EAAO99B,EAAIq+B,EAAUG,EACrBd,EAASh+B,KAAKo+B,EAAO5iC,EAAG4iC,EAAO/9B,EAAG+9B,EAAO99B,GAEzCF,EAAOpG,IAAI6kC,EAAUG,EAAOF,GAAUt+B,YACtCq6B,EAAQ76B,KAAKI,EAAO5E,EAAG4E,EAAOC,EAAGD,EAAOE,GAExCw6B,EAAI96B,KAAK4+B,EAAG,8BAAiD9jC,EAAI0jC,EAAK,EAAI1jC,EAAI0jC,GAE9EC,EAASz+B,KAAK7H,GAEdA,IAGJ8lC,EAAWj+B,KAAKy+B,GAEpB,IAAKp+B,EAAI,EAAGA,GAAKy9B,EAAoBz9B,IAAK,CAClCo+B,EAAW,GACX//B,EAAIy/B,EAAM3lC,GAAS2B,KAAK6J,GAAKxL,IAAU6H,EAAIy9B,GAC/ChjC,GAAM2iC,EAAejlC,EAASslC,EAC1B7d,EAAO9lB,KAAKsM,IAAI/H,GAChBggC,EAAOvkC,KAAKuM,IAAIhI,GAEhBigC,EAAU1e,EAAOwd,EACrB,IAAKjiC,EAAI,EAAGA,GAAK8hC,EAAgB9hC,IAAK,CAClC,IAAIojC,EACA/uB,GADA+uB,EAAIpjC,EAAI8hC,GACIK,EA9FP,EA+FLkB,EAAW1kC,KAAKuM,IAAImJ,GACpBivB,EAAW3kC,KAAKsM,IAAIoJ,GAExBuuB,EAAO5iC,EAAImjC,EAAUE,EACrBT,EAAO/9B,EAAkBq+B,EAAOjB,EAApBS,EACZE,EAAO99B,EAAIq+B,EAAUG,EACrBd,EAASh+B,KAAKo+B,EAAO5iC,EAAG4iC,EAAO/9B,EAAG+9B,EAAO99B,GAEzCF,EAAOpG,IAAIimB,EAAO4e,EAAUH,EAAMze,EAAO6e,GACzCjE,EAAQ76B,KAAKI,EAAO5E,EAAG4E,EAAOC,EAAGD,EAAOE,GAExCw6B,EAAI96B,KAAK4+B,EAAG,8BAAiD9jC,EAAI0jC,EAAK,EAAI1jC,EAAI0jC,GAE9EC,EAASz+B,KAAK7H,GAEdA,IAGJ8lC,EAAWj+B,KAAKy+B,GAGpB,IAAKjjC,EAAI,EAAGA,EAAI8hC,EAAgB9hC,IAC5B,IAAK6E,EAAI,EAAGA,EAAIu9B,EAAkBL,EAAiBO,EAAoBz9B,IAAK,CAExE,IAAI00B,EAAKkJ,EAAW59B,GAAG7E,GACnByjC,EAAKhB,EAAW59B,EAAI,GAAG7E,GACvB0jC,EAAKjB,EAAW59B,EAAI,GAAG7E,EAAI,GAC3B2jC,EAAKlB,EAAW59B,GAAG7E,EAAI,GAE3ByF,EAAQjB,KAAK+0B,GACb9zB,EAAQjB,KAAKi/B,GACbh+B,EAAQjB,KAAKm/B,GAEbl+B,EAAQjB,KAAKi/B,GACbh+B,EAAQjB,KAAKk/B,GACbj+B,EAAQjB,KAAKm/B,GAIrB,GADAl+B,EAAUA,EAAQm+B,UACdxE,EAAQv1B,cAAgBu1B,EAAQv1B,YAAYrM,OAAO,UAAe,CAClE,IAAI0C,EAAI,IAAI,KACZk/B,EAAQv1B,YACHzL,QACAV,MAAgB,GAAViB,KAAK6J,IACXiW,MAAM,UACNxC,eACA5K,iBAAiBnR,GAEtB,IADA,IAAI2jC,EAAM,WACD17B,EAAI,EAAGA,EAAIq6B,EAASliC,OAAQ6H,GAAK,EACtC07B,EAAIrlC,IAAIgkC,EAASr6B,GAAIq6B,EAASr6B,EAAI,GAAIq6B,EAASr6B,EAAI,IACnD,8BAAkC07B,EAAIzlC,QAAS8B,EAAG2jC,GAClDrB,EAASr6B,GAAK07B,EAAI7jC,EAClBwiC,EAASr6B,EAAI,GAAK07B,EAAIh/B,EACtB29B,EAASr6B,EAAI,GAAK07B,EAAI/+B,EAG9B,IAAIg/B,EAAO,IAAI,IAKf,OAJAA,EAAKt+B,UAAYg9B,EACjBsB,EAAKzE,QAAUA,EACfyE,EAAKxE,IAAMA,EACXwE,EAAKr+B,QAAUA,EACRq+B,EAUJ,SAASC,EAAc7C,EAAM9B,EAAS+B,QACzB,IAAZ/B,IAAsBA,EAAU,CAChCv1B,YAAa,SACb63B,aAAc,EACdC,aAAc,GACd9oB,OAAQ,EACRrP,OAAQ,IACRo4B,gBAAiB,EACjBL,WAAW,SAED,IAAVJ,IAAoBA,EAAQ,MAChC,IAAI6C,EAAU,IAAI,KAAK9C,EAAMC,GAG7B,OAFiBM,EAAwBrC,GAC9BkC,YAAY0C,EAAS5E,EAAQmC,WACjCyC,EAOJ,IAAIC,EAAiB,CAExBF,cAAeA,GAUnB,mBAAqB,SAAU7C,EAAM9B,EAAS+B,GAC1C,OAAO4C,EAAc7C,EAAM9B,EAAS+B,IAExC,kBAA2BM,G,qIC7LpB,SAASyC,EAAyB9E,GACrC,IAAIvmB,EAASumB,EAAQvmB,QAAU,EAC3BsrB,EAAsC,IAAxB/E,EAAQ+E,YAAoB,EAAI/E,EAAQ+E,aAAe/E,EAAQgF,UAAY,EACzFC,EAA4C,IAA3BjF,EAAQiF,eAAuB,EAAIjF,EAAQiF,gBAAkBjF,EAAQgF,UAAY,EACtGD,EAAcA,GAAe,KAC7BE,EAAiBA,GAAkB,KACnC,IAaIjK,EAbAuH,EAAevC,EAAQuC,cAAgB,GACvCD,EAAetC,EAAQsC,cAAgB,EACvC4C,IAAWlF,EAAQkF,SACnBC,IAAUnF,EAAQmF,QAClBC,EAAsB,IAAhBpF,EAAQoF,IAAY,EAAIpF,EAAQoF,KAAO,aAC7C15B,EAAMs0B,EAAQt0B,MAAQs0B,EAAQt0B,KAAO,GAAKs0B,EAAQt0B,IAAM,GAAK,EAAMs0B,EAAQt0B,KAAO,EAClF41B,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBACjFC,EAASvB,EAAQuB,QAAU,IAAIt6B,MAAM,GACrCu6B,EAAaxB,EAAQwB,WAIrB6D,EAAY,GAAK,GAFA,IAAR35B,GAAay5B,EAAU,EAAI,KAC3BD,EAAW5C,EAAe,GAGvC,IAAKtH,EAAI,EAAGA,EAAIqK,EAAWrK,IACnBwG,QAAgCza,IAAlBya,EAAWxG,KACzBwG,EAAWxG,GAAK,IAAI,KAAO,EAAG,EAAG,EAAG,IAG5C,IAAKA,EAAI,EAAGA,EAAIqK,EAAWrK,IACnBuG,QAAwBxa,IAAdwa,EAAOvG,KACjBuG,EAAOvG,GAAK,IAAI,KAAQ,EAAG,EAAG,EAAG,IAGzC,IAMIpwB,EACA5K,EACAoK,EASArB,EACAuD,EACA1P,EAnBAyJ,EAAU,IAAIY,MACdb,EAAY,IAAIa,MAChBg5B,EAAU,IAAIh5B,MACdi5B,EAAM,IAAIj5B,MACV3C,EAAS,IAAI2C,MACbq+B,EAAuB,EAAV/lC,KAAK6J,GAASsC,EAAO62B,EAIlC9H,GAAOwK,EAAiBF,GAAe,EAAItrB,EAC3C8rB,EAAa,WACbC,EAAa,WACbC,EAAkB,WAClBC,EAAkB,WAClBC,EAAa,WACblpC,EAAI,OAKJmpC,EAAU,EACV3lC,EAAI,EACJ4lC,EAAK,EACL3lC,EAAI,EACR,IAAK6I,EAAI,EAAGA,GAAKu5B,EAAcv5B,IAI3B,IAFAqB,IADApK,EAAI+I,EAAIu5B,IACOyC,EAAcE,GAAkBA,GAAkB,EACjEW,EAAUV,GAAkB,IAANn8B,GAAWA,IAAMu5B,EAAe,EAAI,EACrD1lC,EAAI,EAAGA,EAAIgpC,EAAShpC,IAAK,CAO1B,IANIsoC,IACAjlC,GAAKrD,GAELuoC,IACAllC,GAAK,EAAIrD,GAER0P,EAAI,EAAGA,GAAKi2B,EAAcj2B,IAC3B1B,EAAQ0B,EAAIg5B,EAEZC,EAAW3kC,EAAIrB,KAAKsM,KAAKjB,GAASR,EAClCm7B,EAAW9/B,GAAKgU,EAAS,EAAIzZ,EAAIyZ,EACjC8rB,EAAW7/B,EAAInG,KAAKuM,KAAKlB,GAASR,EAEd,IAAhB26B,GAAqBh8B,IAAMu5B,GAE3BkD,EAAW5kC,EAAIq/B,EAAQA,EAAQ/+B,OAA8B,GAApBqhC,EAAe,IACxDiD,EAAW//B,EAAIw6B,EAAQA,EAAQ/+B,OAA8B,GAApBqhC,EAAe,GAAS,GACjEiD,EAAW9/B,EAAIu6B,EAAQA,EAAQ/+B,OAA8B,GAApBqhC,EAAe,GAAS,KAGjEiD,EAAW5kC,EAAI2kC,EAAW3kC,EAC1B4kC,EAAW9/B,EAAI6/B,EAAW7/B,EAC1B8/B,EAAW//B,EAAIlG,KAAKuF,KAAK0gC,EAAW5kC,EAAI4kC,EAAW5kC,EAAI4kC,EAAW9/B,EAAI8/B,EAAW9/B,GAAK+0B,EACtF+K,EAAW5/B,aAGL,IAAN0G,IACAm5B,EAAgBxmC,SAASsmC,GACzBG,EAAgBzmC,SAASumC,IAE7Bp/B,EAAUhB,KAAKmgC,EAAW3kC,EAAG2kC,EAAW9/B,EAAG8/B,EAAW7/B,GACtDu6B,EAAQ76B,KAAKogC,EAAW5kC,EAAG4kC,EAAW//B,EAAG+/B,EAAW9/B,GAEhDxF,EADAglC,EACIW,IAAO5lC,EAAIshC,EAAOthC,GAAGwF,EAAI87B,EAAOthC,GAAG4Z,EAGnC0nB,EAAOthC,GAAGwF,GAAK87B,EAAOthC,GAAG4Z,EAAI0nB,EAAOthC,GAAGwF,GAAKzF,EAEpDkgC,EAAI96B,KAAKm8B,EAAOthC,GAAGW,GAAM2gC,EAAOthC,GAAGyF,EAAI67B,EAAOthC,GAAGW,GAAK0L,EAAKi2B,EAAc,8BAAiD,EAAIriC,EAAIA,GAC9HshC,GACAl9B,EAAOc,KAAKo8B,EAAWvhC,GAAGrD,EAAG4kC,EAAWvhC,GAAGpD,EAAG2kC,EAAWvhC,GAAGnD,EAAG0kC,EAAWvhC,GAAG6D,GAIzE,IAAR4H,GAAay5B,IACb/+B,EAAUhB,KAAKmgC,EAAW3kC,EAAG2kC,EAAW9/B,EAAG8/B,EAAW7/B,GACtDU,EAAUhB,KAAK,EAAGmgC,EAAW9/B,EAAG,GAChCW,EAAUhB,KAAK,EAAGmgC,EAAW9/B,EAAG,GAChCW,EAAUhB,KAAKqgC,EAAgB7kC,EAAG6kC,EAAgBhgC,EAAGggC,EAAgB//B,GACrE,eAAmBjJ,EAAG+oC,EAAYG,GAClCA,EAAW//B,YACXq6B,EAAQ76B,KAAKugC,EAAW/kC,EAAG+kC,EAAWlgC,EAAGkgC,EAAWjgC,EAAGigC,EAAW/kC,EAAG+kC,EAAWlgC,EAAGkgC,EAAWjgC,GAC9F,eAAmBggC,EAAiBjpC,EAAGkpC,GACvCA,EAAW//B,YACXq6B,EAAQ76B,KAAKugC,EAAW/kC,EAAG+kC,EAAWlgC,EAAGkgC,EAAWjgC,EAAGigC,EAAW/kC,EAAG+kC,EAAWlgC,EAAGkgC,EAAWjgC,GAE1FxF,EADAglC,EACIW,IAAO5lC,EAAIshC,EAAOthC,EAAI,GAAGwF,EAAI87B,EAAOthC,EAAI,GAAG4Z,EAG3C0nB,EAAOthC,EAAI,GAAGwF,GAAK87B,EAAOthC,EAAI,GAAG4Z,EAAI0nB,EAAOthC,EAAI,GAAGwF,GAAKzF,EAEhEkgC,EAAI96B,KAAKm8B,EAAOthC,EAAI,GAAGW,EAAG,8BAAiD,EAAIV,EAAIA,GACnFggC,EAAI96B,KAAKm8B,EAAOthC,EAAI,GAAGyF,EAAG,8BAAiD,EAAIxF,EAAIA,GAE/EA,EADAglC,EACIW,IAAO5lC,EAAIshC,EAAOthC,EAAI,GAAGwF,EAAI87B,EAAOthC,EAAI,GAAG4Z,EAG3C0nB,EAAOthC,EAAI,GAAGwF,GAAK87B,EAAOthC,EAAI,GAAG4Z,EAAI0nB,EAAOthC,EAAI,GAAGwF,GAAKzF,EAEhEkgC,EAAI96B,KAAKm8B,EAAOthC,EAAI,GAAGW,EAAG,8BAAiD,EAAIV,EAAIA,GACnFggC,EAAI96B,KAAKm8B,EAAOthC,EAAI,GAAGyF,EAAG,8BAAiD,EAAIxF,EAAIA,GAC/EshC,IACAl9B,EAAOc,KAAKo8B,EAAWvhC,EAAI,GAAGrD,EAAG4kC,EAAWvhC,EAAI,GAAGpD,EAAG2kC,EAAWvhC,EAAI,GAAGnD,EAAG0kC,EAAWvhC,EAAI,GAAG6D,GAC7FQ,EAAOc,KAAKo8B,EAAWvhC,EAAI,GAAGrD,EAAG4kC,EAAWvhC,EAAI,GAAGpD,EAAG2kC,EAAWvhC,EAAI,GAAGnD,EAAG0kC,EAAWvhC,EAAI,GAAG6D,GAC7FQ,EAAOc,KAAKo8B,EAAWvhC,EAAI,GAAGrD,EAAG4kC,EAAWvhC,EAAI,GAAGpD,EAAG2kC,EAAWvhC,EAAI,GAAGnD,EAAG0kC,EAAWvhC,EAAI,GAAG6D,GAC7FQ,EAAOc,KAAKo8B,EAAWvhC,EAAI,GAAGrD,EAAG4kC,EAAWvhC,EAAI,GAAGpD,EAAG2kC,EAAWvhC,EAAI,GAAGnD,EAAG0kC,EAAWvhC,EAAI,GAAG6D,KAGjG+hC,IAAO5lC,IACP4lC,EAAK5lC,GAKjB,IAAI6lC,EAAY,IAARp6B,GAAay5B,EAAU5C,EAAe,EAAIA,EAElD,IADAx5B,EAAI,EACC9I,EAAI,EAAGA,EAAIqiC,EAAcriC,IAAK,CAC/B,IAAIi6B,EAAK,EACLC,EAAK,EACLkK,EAAK,EACLC,EAAK,EACT,IAAKh4B,EAAI,EAAGA,EAAIi2B,EAAcj2B,IAC1B4tB,EAAKnxB,GAAK+8B,EAAI,GAAKx5B,EACnB6tB,GAAMpxB,EAAI,IAAM+8B,EAAI,GAAKx5B,EACzB+3B,EAAKt7B,GAAK+8B,EAAI,IAAMx5B,EAAI,GACxBg4B,GAAMv7B,EAAI,IAAM+8B,EAAI,IAAMx5B,EAAI,GAC9BjG,EAAQjB,KAAK80B,EAAIC,EAAIkK,GACrBh+B,EAAQjB,KAAKk/B,EAAID,EAAIlK,GAEb,IAARzuB,GAAay5B,IAEb9+B,EAAQjB,KAAK80B,EAAK,EAAGC,EAAK,EAAGkK,EAAK,GAClCh+B,EAAQjB,KAAKk/B,EAAK,EAAGD,EAAK,EAAGlK,EAAK,GAClC9zB,EAAQjB,KAAK80B,EAAK,EAAGC,EAAK,EAAGkK,EAAK,GAClCh+B,EAAQjB,KAAKk/B,EAAK,EAAGD,EAAK,EAAGlK,EAAK,IAEtCpxB,EAAIm8B,EAAWn8B,EAAI,EAAIA,EAAI,EAG/B,IAAIg9B,EAAoB,SAAUC,GAC9B,IAAI57B,EAAS47B,EAAQjB,EAAc,EAAIE,EAAiB,EACxD,GAAe,IAAX76B,EAAJ,CAIA,IAAIQ,EACAq7B,EACAl9B,EACAi7B,EAAIgC,EAAQzE,EAAO8D,EAAY,GAAK9D,EAAO,GAC3C5tB,EAAI,KACJ6tB,IACA7tB,EAAIqyB,EAAQxE,EAAW6D,EAAY,GAAK7D,EAAW,IAGvD,IAAI0E,EAAQ9/B,EAAUlF,OAAS,EAC3BzD,EAASuoC,EAAQvsB,EAAS,GAAKA,EAAS,EACxC5E,EAAS,IAAI,IAAQ,EAAGpX,EAAQ,GACpC2I,EAAUhB,KAAKyP,EAAOjU,EAAGiU,EAAOpP,EAAGoP,EAAOnP,GAC1Cu6B,EAAQ76B,KAAK,EAAG4gC,EAAQ,GAAK,EAAG,GAChC,IAAI9lC,EAAI8jC,EAAEv+B,EAAkB,IAAbu+B,EAAEnqB,EAAImqB,EAAEv+B,GACvBy6B,EAAI96B,KAAK4+B,EAAEpjC,EAAkB,IAAbojC,EAAEt+B,EAAIs+B,EAAEpjC,GAAU,8BAAiD,EAAIV,EAAIA,GACvFyT,GACArP,EAAOc,KAAKuO,EAAE/W,EAAG+W,EAAE9W,EAAG8W,EAAE7W,EAAG6W,EAAE7P,GAEjC,IAAIqiC,EAAe,IAAI,KAAQ,GAAK,IACpC,IAAKp9B,EAAI,EAAGA,GAAKw5B,EAAcx5B,IAAK,CAChC6B,EAAmB,EAAVrL,KAAK6J,GAASL,EAAI2C,EAAO62B,EAClC,IAAI12B,EAAMtM,KAAKsM,KAAKjB,GAChBkB,EAAMvM,KAAKuM,KAAKlB,GACpBq7B,EAAe,IAAI,IAAQp6B,EAAMzB,EAAQ3M,EAAQqO,EAAM1B,GACvD,IAAIg8B,EAAoB,IAAI,KAAQv6B,EAAMs6B,EAAavlC,EAAI,GAAKkL,EAAMq6B,EAAa1gC,EAAI,IACvFW,EAAUhB,KAAK6gC,EAAarlC,EAAGqlC,EAAaxgC,EAAGwgC,EAAavgC,GAC5Du6B,EAAQ76B,KAAK,EAAG4gC,EAAQ,GAAK,EAAG,GAChC,IAAIvB,EAAMT,EAAEv+B,GAAKu+B,EAAEnqB,EAAImqB,EAAEv+B,GAAK2gC,EAAkB3gC,EAChDy6B,EAAI96B,KAAK4+B,EAAEpjC,GAAKojC,EAAEt+B,EAAIs+B,EAAEpjC,GAAKwlC,EAAkBxlC,EAAG,8BAAiD,EAAI6jC,EAAMA,GACzG9wB,GACArP,EAAOc,KAAKuO,EAAE/W,EAAG+W,EAAE9W,EAAG8W,EAAE7W,EAAG6W,EAAE7P,GAIrC,IAAKiF,EAAI,EAAGA,EAAIw5B,EAAcx5B,IACrBi9B,GAMD3/B,EAAQjB,KAAK8gC,GACb7/B,EAAQjB,KAAK8gC,GAASn9B,EAAI,IAC1B1C,EAAQjB,KAAK8gC,GAASn9B,EAAI,MAP1B1C,EAAQjB,KAAK8gC,GACb7/B,EAAQjB,KAAK8gC,GAASn9B,EAAI,IAC1B1C,EAAQjB,KAAK8gC,GAASn9B,EAAI,OAUlCq8B,IAAQ,gBAAkBA,IAAQ,cAClCW,GAAkB,GAElBX,IAAQ,cAAgBA,IAAQ,cAChCW,GAAkB,GAGtB,kBAAyBzE,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SACtG,IAAIC,EAAa,IAAI,IAQrB,OAPAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACbsB,IACAG,EAAWr9B,OAASA,GAEjBq9B,EA8CJ,SAAS0E,EAAevE,EAAM9B,EAAS+B,QAC1B,IAAZ/B,IAAsBA,EAAU,IACpC,IAAIsG,EAAW,IAAI,KAAKxE,EAAMC,GAK9B,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClEgF,EAASrE,gCAAkCjC,EAAQsB,gBAClCwD,EAAyB9E,GAC/BkC,YAAYoE,EAAUtG,EAAQmC,WAClCmE,EAMJ,IAAIC,EAAkB,CAEzBF,eAAgBA,GAEpB,mBAA4BvB,EAC5B,oBAAsB,SAAUhD,EAAMroB,EAAQsrB,EAAaE,EAAgB1C,EAAcD,EAAcP,EAAOI,EAAWb,GAkBrH,YAjBcva,IAAVgb,GAAyBA,aAAiB,WAC5Bhb,IAAVgb,IACAT,EAAkBa,GAAa,iBAC/BA,EAAYJ,GAEhBA,EAAQO,EACRA,EAAe,GAWZ+D,EAAevE,EATR,CACVroB,OAAQA,EACRsrB,YAAaA,EACbE,eAAgBA,EAChB1C,aAAcA,EACdD,aAAcA,EACdhB,gBAAiBA,EACjBa,UAAWA,GAEsBJ,K,+GClVlC,SAASyE,EAAY1E,EAAM2E,EAAYzG,GAC1C,IAAI35B,EAAUogC,EAAWC,aACrBtgC,EAAYqgC,EAAWE,gBAAgB,kBACvC1G,EAAUwG,EAAWE,gBAAgB,gBACrCzG,EAAMuG,EAAWE,gBAAgB,YACjCl5B,EAAWuyB,EAAQvyB,UAAY,WAC/BjI,EAASw6B,EAAQx6B,QAAU,SAC3Bua,EAAOigB,EAAQjgB,MAAQ,UACvBnV,EAAQo1B,EAAQp1B,OAAS,EAE7B,IAAKpF,EAAQ,CACT,IAAIwJ,EAAS,IAAI,IAAQ,EAAG,EAAG,GAC3B43B,EAASH,EAAWI,WAAWC,aAC/BC,EAAoB,yBAA6B/3B,EAAQ43B,EAAOI,kBACpExhC,EAASohC,EAAOK,eAAenoC,SAASioC,GAE5C,IAAIvc,GAAOjrB,KAAKiK,MAAMhE,EAAOE,EAAGF,EAAO5E,GAAKrB,KAAK6J,GAAK,EAClDkS,EAAM/b,KAAKuF,KAAKU,EAAO5E,EAAI4E,EAAO5E,EAAI4E,EAAOE,EAAIF,EAAOE,GACxD+kB,EAAQlrB,KAAKiK,MAAMhE,EAAOC,EAAG6V,GAE7B4rB,EAAmB,0BAA4B1c,EAAKC,EAAO7f,GAAO5M,SAAS,iBAAmByP,EAAS7M,EAAG6M,EAAShI,EAAGgI,EAAS/H,IAC/HyhC,EAA0B,YAAcD,GAExCE,EADkBX,EAAWO,iBACKhpC,SAASmpC,GAC3CxF,EAAa,IAAI,IACrBA,EAAWt7B,QAAU,GACrBs7B,EAAWv7B,UAAY,GACvBu7B,EAAW1B,QAAU,GACrB0B,EAAWzB,IAAM,GAoHjB,IAnHA,IAAImH,EAAyB,EACzBC,EAAsB,SAAUC,GAChC,IAAIppC,EAAS,IAAI,IACjB,IAAKkI,IAAYD,IAAc65B,EAC3B,OAAO9hC,EAEX,IAAIqpC,EAAWnhC,EAAQkhC,GAOvB,GANAppC,EAAOsP,SAAW,IAAI,IAAQrH,EAAqB,EAAXohC,GAAephC,EAAqB,EAAXohC,EAAe,GAAIphC,EAAqB,EAAXohC,EAAe,IAE7GrpC,EAAOsP,SAAW,yBAA6BtP,EAAOsP,SAAU25B,GAEhEjpC,EAAOqH,OAAS,IAAI,IAAQy6B,EAAmB,EAAXuH,GAAevH,EAAmB,EAAXuH,EAAe,GAAIvH,EAAmB,EAAXuH,EAAe,IACrGrpC,EAAOqH,OAAS,oBAAwBrH,EAAOqH,OAAQ4hC,GACnDpH,EAAQyH,YAAcvH,EAAK,CAC3B,IAAIhgC,EAAIggC,EAAe,EAAXsH,EAAe,GAC3BrpC,EAAOq/B,GAAK,IAAI,KAAQ0C,EAAe,EAAXsH,GAAe,8BAAiD,EAAItnC,EAAIA,GAExG,OAAO/B,GAEPupC,EAAO,SAAUtE,EAAUtjB,GAC3B,GAAwB,IAApBsjB,EAASliC,OACT,OAAOkiC,EAQX,IANA,IAAIuE,EAAW,GAAMpoC,KAAKsB,IAAI,QAAYkf,EAAMD,IAC5C8nB,EAAe,SAAUt1B,EAAIC,GAC7B,IAAIs1B,EAAa,kBAAsBv1B,EAAG7E,SAAU8E,EAAG9E,SAAUqS,EAAM6nB,GACvE,OAAO,IAAI,IAA4B,SAAar1B,EAAG7E,SAAU8E,EAAG9E,SAAUo6B,GAAa,SAAav1B,EAAG9M,OAAQ+M,EAAG/M,OAAQqiC,KAE9H1pC,EAAS,IAAI8I,MACR1J,EAAQ,EAAGA,EAAQ6lC,EAASliC,OAAQ3D,GAAS,EAAG,CACrD,IACIuqC,EAAM,KACNC,EAAM,KACNC,EAAM,KACNC,EAAM,KAINC,EAHK,QAAY9E,EAAS7lC,GAAOkQ,SAAUqS,GAAQ6nB,EAGtC,EACbQ,EAHK,QAAY/E,EAAS7lC,EAAQ,GAAGkQ,SAAUqS,GAAQ6nB,EAG1C,EACbS,EAHK,QAAYhF,EAAS7lC,EAAQ,GAAGkQ,SAAUqS,GAAQ6nB,EAG1C,EAEjB,QADSO,EAAQ,EAAI,IAAMC,EAAQ,EAAI,IAAMC,EAAQ,EAAI,IAErD,KAAK,EACDjqC,EAAOiH,KAAKg+B,EAAS7lC,IACrBY,EAAOiH,KAAKg+B,EAAS7lC,EAAQ,IAC7BY,EAAOiH,KAAKg+B,EAAS7lC,EAAQ,IAC7B,MACJ,KAAK,EAOD,GANI2qC,IACAJ,EAAM1E,EAAS7lC,EAAQ,GACvBwqC,EAAM3E,EAAS7lC,EAAQ,GACvByqC,EAAMJ,EAAaxE,EAAS7lC,GAAQuqC,GACpCG,EAAML,EAAaxE,EAAS7lC,GAAQwqC,IAEpCI,EAAO,CACPL,EAAM1E,EAAS7lC,GACfwqC,EAAM3E,EAAS7lC,EAAQ,GACvByqC,EAAMJ,EAAaxE,EAAS7lC,EAAQ,GAAIuqC,GACxCG,EAAML,EAAaxE,EAAS7lC,EAAQ,GAAIwqC,GACxC5pC,EAAOiH,KAAK4iC,GACZ7pC,EAAOiH,KAAK2iC,EAAI/oC,SAChBb,EAAOiH,KAAK0iC,EAAI9oC,SAChBb,EAAOiH,KAAK2iC,EAAI/oC,SAChBb,EAAOiH,KAAK4iC,EAAIhpC,SAChBb,EAAOiH,KAAK6iC,GACZ,MAEAG,IACAN,EAAM1E,EAAS7lC,GACfwqC,EAAM3E,EAAS7lC,EAAQ,GACvByqC,EAAMJ,EAAaxE,EAAS7lC,EAAQ,GAAIuqC,GACxCG,EAAML,EAAaxE,EAAS7lC,EAAQ,GAAIwqC,IAExCD,GAAOC,GAAOC,GAAOC,IACrB9pC,EAAOiH,KAAK0iC,EAAI9oC,SAChBb,EAAOiH,KAAK2iC,EAAI/oC,SAChBb,EAAOiH,KAAK4iC,GACZ7pC,EAAOiH,KAAK6iC,GACZ9pC,EAAOiH,KAAK4iC,EAAIhpC,SAChBb,EAAOiH,KAAK2iC,EAAI/oC,UAEpB,MACJ,KAAK,EACIkpC,IAEDH,EAAMH,EADNE,EAAM1E,EAAS7lC,GAAOyB,QACEokC,EAAS7lC,EAAQ,IACzCyqC,EAAMJ,EAAaE,EAAK1E,EAAS7lC,EAAQ,IACzCY,EAAOiH,KAAK0iC,GACZ3pC,EAAOiH,KAAK2iC,GACZ5pC,EAAOiH,KAAK4iC,IAEXG,IAEDJ,EAAMH,EADNE,EAAM1E,EAAS7lC,EAAQ,GAAGyB,QACFokC,EAAS7lC,EAAQ,IACzCyqC,EAAMJ,EAAaE,EAAK1E,EAAS7lC,IACjCY,EAAOiH,KAAK0iC,GACZ3pC,EAAOiH,KAAK2iC,GACZ5pC,EAAOiH,KAAK4iC,IAEXI,IAEDL,EAAMH,EADNE,EAAM1E,EAAS7lC,EAAQ,GAAGyB,QACFokC,EAAS7lC,IACjCyqC,EAAMJ,EAAaE,EAAK1E,EAAS7lC,EAAQ,IACzCY,EAAOiH,KAAK0iC,GACZ3pC,EAAOiH,KAAK2iC,GACZ5pC,EAAOiH,KAAK4iC,KAO5B,OAAO7pC,GAEFZ,EAAQ,EAAGA,EAAQ8I,EAAQnF,OAAQ3D,GAAS,EAAG,CACpD,IAAI8qC,EAAe,IAAIphC,MAWvB,GAVAohC,EAAajjC,KAAKkiC,EAAoB/pC,IACtC8qC,EAAajjC,KAAKkiC,EAAoB/pC,EAAQ,IAC9C8qC,EAAajjC,KAAKkiC,EAAoB/pC,EAAQ,IAE9C8qC,EAAeX,EAAKW,EAAc,IAAI,IAAQ,EAAG,EAAG,IACpDA,EAAeX,EAAKW,EAAc,IAAI,KAAS,EAAG,EAAG,IACrDA,EAAeX,EAAKW,EAAc,IAAI,IAAQ,EAAG,EAAG,IACpDA,EAAeX,EAAKW,EAAc,IAAI,IAAQ,GAAI,EAAG,IACrDA,EAAeX,EAAKW,EAAc,IAAI,IAAQ,EAAG,EAAG,IAExB,KAD5BA,EAAeX,EAAKW,EAAc,IAAI,IAAQ,EAAG,GAAI,KACpCnnC,OAIjB,IAAK,IAAIonC,EAAS,EAAGA,EAASD,EAAannC,OAAQonC,IAAU,CACzD,IAAI9E,EAAS6E,EAAaC,GAK1B,GAHA3G,EAAWt7B,QAAQjB,KAAKiiC,GACxB7D,EAAO/1B,SAASpQ,QAAQskC,EAAWv7B,UAAoC,EAAzBihC,GAC9C7D,EAAOh+B,OAAOnI,QAAQskC,EAAW1B,QAAkC,EAAzBoH,GACrCrH,EAAQyH,WAMTjE,EAAOhG,GAAGngC,QAAQskC,EAAWzB,IAA8B,EAAzBmH,OANb,CACrB1F,EAAWzB,IAAI96B,KAAK,GAAMo+B,EAAO/1B,SAAS7M,EAAImf,EAAKnf,GACnD,IAAIV,EAAI,GAAMsjC,EAAO/1B,SAAShI,EAAIsa,EAAKta,EACvCk8B,EAAWzB,IAAI96B,KAAK,8BAAiD,EAAIlF,EAAIA,GAKjFmnC,KAIR,IAAIkB,EAAQ,IAAI,KAAKzG,EAAM2E,EAAWI,YAItC,OAHAlF,EAAWO,YAAYqG,GACvBA,EAAM96B,SAAWA,EAASzO,QAC1BupC,EAAM9hB,SAAW,IAAI,IAAQgE,EAAOD,EAAK5f,GAClC29B,EAMJ,IAAIC,EAAe,CAEtBhC,YAAaA,GAEjB,iBAAmB,SAAU1E,EAAM2E,EAAYh5B,EAAUjI,EAAQua,EAAMnV,GAOnE,OAAO47B,EAAY1E,EAAM2E,EANX,CACVh5B,SAAUA,EACVjI,OAAQA,EACRua,KAAMA,EACNnV,MAAOA,M,8ECzMf,SAAS69B,EAAqBzI,GAC1B,IAAI55B,EAAY,IAAIa,MAChBZ,EAAU,IAAIY,MACdg5B,EAAU,IAAIh5B,MACdi5B,EAAM,IAAIj5B,MACVmD,EAAS41B,EAAQ51B,QAAU,GAC3Bm4B,EAAevC,EAAQuC,cAAgB,GACvC72B,EAAMs0B,EAAQt0B,MAAQs0B,EAAQt0B,KAAO,GAAKs0B,EAAQt0B,IAAM,GAAK,EAAMs0B,EAAQt0B,KAAO,EAClF41B,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBAErFl7B,EAAUhB,KAAK,EAAG,EAAG,GACrB86B,EAAI96B,KAAK,GAAK,IAId,IAHA,IAAI6P,EAAkB,EAAV1V,KAAK6J,GAASsC,EACtB6H,EAAe,IAAR7H,EAAYuJ,EAAQstB,EAAettB,GAASstB,EAAe,GAClEz+B,EAAI,EACCwE,EAAI,EAAGA,EAAIi6B,EAAcj6B,IAAK,CACnC,IAAI1H,EAAIrB,KAAKsM,IAAI/H,GACb2B,EAAIlG,KAAKuM,IAAIhI,GACbkgC,GAAKpjC,EAAI,GAAK,EACdV,GAAK,EAAIuF,GAAK,EAClBW,EAAUhB,KAAKgF,EAASxJ,EAAGwJ,EAAS3E,EAAG,GACvCy6B,EAAI96B,KAAK4+B,EAAG,8BAAiD,EAAI9jC,EAAIA,GACrE4D,GAAKyP,EAEG,IAAR7H,IACAtF,EAAUhB,KAAKgB,EAAU,GAAIA,EAAU,GAAIA,EAAU,IACrD85B,EAAI96B,KAAK86B,EAAI,GAAI,8BAAiD,EAAIA,EAAI,GAAKA,EAAI,KAIvF,IADA,IAAIwI,EAAWtiC,EAAUlF,OAAS,EACzB6H,EAAI,EAAGA,EAAI2/B,EAAW,EAAG3/B,IAC9B1C,EAAQjB,KAAK2D,EAAI,EAAG,EAAGA,GAG3B,mBAA0B3C,EAAWC,EAAS45B,GAC9C,kBAAyBqB,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SACtG,IAAIC,EAAa,IAAI,IAKrB,OAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EAuBJ,SAASgH,EAAW7G,EAAM9B,EAAS+B,QACtB,IAAZ/B,IAAsBA,EAAU,SACtB,IAAV+B,IAAoBA,EAAQ,MAChC,IAAI6G,EAAO,IAAI,KAAK9G,EAAMC,GAK1B,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClEsH,EAAK3G,gCAAkCjC,EAAQsB,gBAC9BmH,EAAqBzI,GAC3BkC,YAAY0G,EAAM5I,EAAQmC,WAC9ByG,EAMJ,IAAIC,EAAc,CAErBF,WAAYA,GAEhB,eAAwBF,EACxB,gBAAkB,SAAU3G,EAAM13B,EAAQm4B,EAAcR,EAAOI,EAAWb,GAQtE,YAPc,IAAVS,IAAoBA,EAAQ,MAOzB4G,EAAW7G,EANJ,CACV13B,OAAQA,EACRm4B,aAAcA,EACdjB,gBAAiBA,EACjBa,UAAWA,GAEkBJ,K,sEC1E9B,SAAS+G,EAAehH,EAAM9B,EAAS+B,QAC5B,IAAVA,IAAoBA,EAAQ,MAChC,IAAIjhC,EAAIk/B,EAAQl/B,GAAK,EACjBA,IAAMvB,KAAKgI,MAAMzG,KACXvB,KAAKgI,MAAMzG,GACjB,SAAY,wCAEhB,IAAI8G,EAAIo4B,EAAQp4B,GAAK,EAKrB,GAJIA,IAAMrI,KAAKgI,MAAMK,KACXrI,KAAKgI,MAAMK,GACjB,SAAY,wCAEZA,EAAI9G,EAAG,CACP,IAAIiJ,EAAOnC,EACXA,EAAI9G,EACJA,EAAIiJ,EACJ,SAAY,mCAEhB,IAAIg/B,EAAU,IAAI,KAClBA,EAAQC,MAAMloC,EAAG8G,GACjB,IACIqhC,EAAa,CACbC,OAFe,uBAA+BH,GAG9ChpB,KAAMigB,EAAQjgB,KACdopB,MAAOnJ,EAAQmJ,MACfC,MAAOpJ,EAAQoJ,MACfC,MAAOrJ,EAAQqJ,MACf9H,OAAQvB,EAAQuB,OAChBC,WAAYxB,EAAQwB,WACpBR,KAAMhB,EAAQgB,KACdmB,UAAWnC,EAAQmC,UACnBb,gBAAiBtB,EAAQsB,gBACzBG,SAAUzB,EAAQyB,SAClBC,QAAS1B,EAAQ0B,SAGrB,OADe,QAAiBI,EAAMmH,EAAYlH,K,qIC3D/C,SAASuH,EAAyBtJ,EAASuJ,GAc9C,IAbA,IAAIxpB,EAAOigB,EAAQjgB,KACfopB,EAAQnJ,EAAQmJ,OAASppB,GAAQ,EACjCqpB,EAAQpJ,EAAQoJ,OAASrpB,GAAQ,EACjCspB,EAAQrJ,EAAQqJ,OAAStpB,GAAQ,EACjCuhB,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBACjFl7B,EAAY,IAAIa,MAChBZ,EAAU,IAAIY,MACdg5B,EAAU,IAAIh5B,MACdi5B,EAAM,IAAIj5B,MACVuiC,EAAO3xB,IACP4xB,GAAQ5xB,IACR6xB,EAAO7xB,IACP8xB,GAAQ9xB,IACH3X,EAAI,EAAGA,EAAIqpC,EAAa/F,OAAOtiC,OAAQhB,IAC5CspC,EAAOjqC,KAAKb,IAAI8qC,EAAMD,EAAa/F,OAAOtjC,GAAG,GAAKipC,GAClDM,EAAOlqC,KAAKZ,IAAI8qC,EAAMF,EAAa/F,OAAOtjC,GAAG,GAAKipC,GAClDO,EAAOnqC,KAAKb,IAAIgrC,EAAMH,EAAa/F,OAAOtjC,GAAG,GAAKkpC,GAClDO,EAAOpqC,KAAKZ,IAAIgrC,EAAMJ,EAAa/F,OAAOtjC,GAAG,GAAKkpC,GAGtD,IADA,IAAI7rC,EAAQ,EACHy9B,EAAI,EAAGA,EAAIuO,EAAaK,KAAK1oC,OAAQ85B,IAAK,CAC/C,IAAI6O,EAAQN,EAAaK,KAAK5O,GAC1Bl3B,EAAI,cAAkBylC,EAAa/F,OAAOqG,EAAM,KAChD/sC,EAAI,cAAkBysC,EAAa/F,OAAOqG,EAAM,KAChDl2B,EAAI,cAAkB41B,EAAa/F,OAAOqG,EAAM,KAChDC,EAAKhtC,EAAEgC,SAASgF,GAChBimC,EAAKp2B,EAAE7U,SAASgF,GAChByR,EAAO,UAAcw0B,EAAID,GAAIlkC,YACjC,IAAS1F,EAAI,EAAGA,EAAI2pC,EAAM3oC,OAAQhB,IAAK,CACnC+/B,EAAQ76B,KAAKmQ,EAAK3U,EAAG2U,EAAK9P,EAAG8P,EAAK7P,GAClC,IAAIskC,EAAQT,EAAa/F,OAAOqG,EAAM3pC,IACtCkG,EAAUhB,KAAK4kC,EAAM,GAAKb,EAAOa,EAAM,GAAKZ,EAAOY,EAAM,GAAKX,GAC9D,IAAIY,GAAUD,EAAM,GAAKZ,EAAQM,IAASC,EAAOD,GACjDxJ,EAAI96B,MAAM4kC,EAAM,GAAKb,EAAQK,IAASC,EAAOD,GAAO,8BAAiD,EAAIS,EAASA,GAEtH,IAAS/pC,EAAI,EAAGA,EAAI2pC,EAAM3oC,OAAS,EAAGhB,IAClCmG,EAAQjB,KAAK7H,EAAOA,EAAQ2C,EAAI,EAAG3C,EAAQ2C,EAAI,GAEnD3C,GAASssC,EAAM3oC,OAEnB,kBAAyBogC,EAAiBl7B,EAAWC,EAAS45B,EAASC,GACvE,IAAIyB,EAAa,IAAI,IAKrB,OAJAA,EAAWv7B,UAAYA,EACvBu7B,EAAWt7B,QAAUA,EACrBs7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EAWJ,SAASuI,EAAepI,EAAM9B,EAAS+B,QAC5B,IAAVA,IAAoBA,EAAQ,MAChC,IAAIhiB,EAAOigB,EAAQjgB,KACfopB,EAAQnJ,EAAQmJ,OAASppB,GAAQ,EACjCqpB,EAAQpJ,EAAQoJ,OAASrpB,GAAQ,EACjCspB,EAAQrJ,EAAQqJ,OAAStpB,GAAQ,EACjCjf,EAAIk/B,EAAQl/B,GAAK,EACjBA,IAAMvB,KAAKgI,MAAMzG,KACXvB,KAAKgI,MAAMzG,GACjB,SAAY,wCAEhB,IAAI8G,EAAIo4B,EAAQp4B,GAAK,EAKrB,GAJIA,IAAMrI,KAAKgI,MAAMK,KACXrI,KAAKgI,MAAMK,GACjB,SAAY,wCAEZA,EAAI9G,EAAG,CACP,IAAIiJ,EAAOnC,EACXA,EAAI9G,EACJA,EAAIiJ,EACJ,SAAY,mCAEhB,IAAIg/B,EAAU,IAAI,KAClBA,EAAQC,MAAMloC,EAAG8G,GACjB,IAAIuiC,EAAe,uBAA+BpB,GAC9CQ,EAAeY,EAAaC,2BAC5BC,EAAW,IAAI,IAAavI,EAAMC,GACtC/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClE+I,EAASpI,gCAAkCjC,EAAQsB,gBAClCgI,EAAyBtJ,EAASuJ,GACxCrH,YAAYmI,EAAUrK,EAAQmC,WACzCkI,EAASd,aAAae,cAAgBH,EAAaI,YACnDF,EAASd,aAAaiB,gBAAkBL,EAAaM,UACrDJ,EAASd,aAAamB,cAAgBP,EAAaO,cACnDL,EAASd,aAAaoB,QAAUN,EAASd,aAAae,cAAgBD,EAASd,aAAaiB,gBAC5FH,EAASd,aAAaqB,eAAiBP,EAASd,aAAaiB,gBAAkB,IAAM,GACrF,IAAK,IAAIxP,EAAI,EAAGA,EAAImP,EAAa3G,OAAOtiC,OAAQ85B,IAC5CqP,EAASd,aAAasB,YAAYzlC,KAAK,cAAkB+kC,EAAa3G,OAAOxI,KAC7EqP,EAASd,aAAasB,YAAY7P,GAAGp6B,GAAKuoC,EAC1CkB,EAASd,aAAasB,YAAY7P,GAAGv1B,GAAK2jC,EAC1CiB,EAASd,aAAasB,YAAY7P,GAAGt1B,GAAK2jC,EAC1CgB,EAASd,aAAa/H,WAAWp8B,KAAK,IAAI,KAAO,EAAG,EAAG,EAAG,IAE9D,IAAS41B,EAAI,EAAGA,EAAIuO,EAAaK,KAAK1oC,OAAQ85B,IAAK,CAC/C,IAAI6O,EAAQN,EAAaK,KAAK5O,GAC1Bl3B,EAAI,cAAkBylC,EAAa/F,OAAOqG,EAAM,KAChD/sC,EAAI,cAAkBysC,EAAa/F,OAAOqG,EAAM,KAChDl2B,EAAI,cAAkB41B,EAAa/F,OAAOqG,EAAM,KAChDC,EAAKhtC,EAAEgC,SAASgF,GAChBimC,EAAKp2B,EAAE7U,SAASgF,GAChByR,EAAO,UAAcw0B,EAAID,GAAIlkC,YAC7BF,EAAI,UAAcqkC,EAAIx0B,GAAM3P,YAChCykC,EAASd,aAAauB,UAAU1lC,KAAK2kC,EAAGnkC,aACxCykC,EAASd,aAAawB,UAAU3lC,KAAKmQ,GACrC80B,EAASd,aAAayB,UAAU5lC,KAAKM,GAEzC,OAAO2kC,EAEX,oBAAsBH,G,8LC5Gf,SAASe,EAAuBjL,GACnC,IAII1L,EAAK4W,EAJL7kC,EAAU,GACVD,EAAY,GACZ65B,EAAU,GACVC,EAAM,GAEN1mB,EAAQwmB,EAAQxmB,OAAS,EACzBC,EAASumB,EAAQvmB,QAAU,EAC3B0xB,EAAgBnL,EAAQmL,eAAiBnL,EAAQsC,cAAgB,EACjE8I,EAAgBpL,EAAQoL,eAAiBpL,EAAQsC,cAAgB,EACrE,IAAKhO,EAAM,EAAGA,GAAO8W,EAAe9W,IAChC,IAAK4W,EAAM,EAAGA,GAAOC,EAAeD,IAAO,CACvC,IAAIz9B,EAAW,IAAI,IAASy9B,EAAM1xB,EAAS2xB,EAAgB3xB,EAAQ,EAAK,GAAK4xB,EAAgB9W,GAAO7a,EAAU2xB,EAAgB3xB,EAAS,GACnIjU,EAAS,IAAI,IAAQ,EAAG,EAAK,GACjCY,EAAUhB,KAAKqI,EAAS7M,EAAG6M,EAAShI,EAAGgI,EAAS/H,GAChDu6B,EAAQ76B,KAAKI,EAAO5E,EAAG4E,EAAOC,EAAGD,EAAOE,GACxCw6B,EAAI96B,KAAK8lC,EAAMC,EAAe,8BAAiD7W,EAAM8W,EAAgB,EAAM9W,EAAM8W,GAGzH,IAAK9W,EAAM,EAAGA,EAAM8W,EAAe9W,IAC/B,IAAK4W,EAAM,EAAGA,EAAMC,EAAeD,IAC/B7kC,EAAQjB,KAAK8lC,EAAM,GAAK5W,EAAM,IAAM6W,EAAgB,IACpD9kC,EAAQjB,KAAK8lC,EAAM,EAAI5W,GAAO6W,EAAgB,IAC9C9kC,EAAQjB,KAAK8lC,EAAM5W,GAAO6W,EAAgB,IAC1C9kC,EAAQjB,KAAK8lC,GAAO5W,EAAM,IAAM6W,EAAgB,IAChD9kC,EAAQjB,KAAK8lC,EAAM,GAAK5W,EAAM,IAAM6W,EAAgB,IACpD9kC,EAAQjB,KAAK8lC,EAAM5W,GAAO6W,EAAgB,IAIlD,IAAIxJ,EAAa,IAAI,IAKrB,OAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EAuBJ,SAAS0J,EAA4BrL,GACxC,IAUI1L,EAAK4W,EAAKI,EAASC,EAVnBC,OAAwBzkB,IAAjBiZ,EAAQwL,MAAuC,OAAjBxL,EAAQwL,KAAgBxL,EAAQwL,MAAQ,EAC7ErP,OAAwBpV,IAAjBiZ,EAAQ7D,MAAuC,OAAjB6D,EAAQ7D,KAAgB6D,EAAQ7D,MAAQ,EAC7EsP,OAAwB1kB,IAAjBiZ,EAAQyL,MAAuC,OAAjBzL,EAAQyL,KAAgBzL,EAAQyL,KAAO,EAC5ErP,OAAwBrV,IAAjBiZ,EAAQ5D,MAAuC,OAAjB4D,EAAQ5D,KAAgB4D,EAAQ5D,KAAO,EAC5EkG,EAAetC,EAAQsC,cAAgB,CAAEzoB,EAAG,EAAG7Z,EAAG,GAClD0rC,EAAY1L,EAAQ0L,WAAa,CAAE7xB,EAAG,EAAG7Z,EAAG,GAC5CqG,EAAU,IAAIY,MACdb,EAAY,IAAIa,MAChBg5B,EAAU,IAAIh5B,MACdi5B,EAAM,IAAIj5B,MAEdq7B,EAAatiC,EAAIsiC,EAAatiC,EAAI,EAAI,EAAIsiC,EAAatiC,EACvDsiC,EAAazoB,EAAIyoB,EAAazoB,EAAI,EAAI,EAAIyoB,EAAazoB,EACvD6xB,EAAU7xB,EAAI6xB,EAAU7xB,EAAI,EAAI,EAAI6xB,EAAU7xB,EAC9C6xB,EAAU1rC,EAAI0rC,EAAU1rC,EAAI,EAAI,EAAI0rC,EAAU1rC,EAC9C,IAAI2rC,GACIF,EAAOD,GAAQlJ,EAAazoB,EADhC8xB,GAEIvP,EAAOD,GAAQmG,EAAatiC,EAEpC,SAAS4rC,EAAUC,EAAUC,EAAUC,EAAUC,GAE7C,IAAIC,EAAO7lC,EAAUlF,OAAS,EAC1BgrC,EAAYR,EAAU7xB,EAAI,EAC9B,IAAKya,EAAM,EAAGA,EAAMoX,EAAU1rC,EAAGs0B,IAC7B,IAAK4W,EAAM,EAAGA,EAAMQ,EAAU7xB,EAAGqxB,IAAO,CACpC,IAAIiB,EAAS,CAACF,EAAOf,EAAM5W,EAAM4X,EAAWD,GAAQf,EAAM,GAAK5W,EAAM4X,EAAWD,GAAQf,EAAM,IAAM5W,EAAM,GAAK4X,EAAWD,EAAOf,GAAO5W,EAAM,GAAK4X,GACnJ7lC,EAAQjB,KAAK+mC,EAAO,IACpB9lC,EAAQjB,KAAK+mC,EAAO,IACpB9lC,EAAQjB,KAAK+mC,EAAO,IACpB9lC,EAAQjB,KAAK+mC,EAAO,IACpB9lC,EAAQjB,KAAK+mC,EAAO,IACpB9lC,EAAQjB,KAAK+mC,EAAO,IAI5B,IAAI1+B,EAAW,WACXjI,EAAS,IAAI,IAAQ,EAAG,EAAK,GACjC,IAAK8uB,EAAM,EAAGA,GAAOoX,EAAU1rC,EAAGs0B,IAE9B,IADA7mB,EAAS/H,EAAK4uB,GAAO0X,EAAWF,GAAaJ,EAAU1rC,EAAI8rC,EACtDZ,EAAM,EAAGA,GAAOQ,EAAU7xB,EAAGqxB,IAC9Bz9B,EAAS7M,EAAKsqC,GAAOa,EAAWF,GAAaH,EAAU7xB,EAAIgyB,EAC3Dp+B,EAAShI,EAAI,EACbW,EAAUhB,KAAKqI,EAAS7M,EAAG6M,EAAShI,EAAGgI,EAAS/H,GAChDu6B,EAAQ76B,KAAKI,EAAO5E,EAAG4E,EAAOC,EAAGD,EAAOE,GACxCw6B,EAAI96B,KAAK8lC,EAAMQ,EAAU7xB,EAAGya,EAAMoX,EAAU1rC,GAIxD,IAAKsrC,EAAU,EAAGA,EAAUhJ,EAAatiC,EAAGsrC,IACxC,IAAKC,EAAU,EAAGA,EAAUjJ,EAAazoB,EAAG0xB,IACxCK,EAAUJ,EAAOD,EAAUI,EAAYxP,EAAOmP,EAAUK,EAAYH,GAAQD,EAAU,GAAKI,EAAYxP,GAAQmP,EAAU,GAAKK,GAItI,IAAIhK,EAAa,IAAI,IAKrB,OAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EA2BJ,SAASyK,EAAoCpM,GAChD,IAII1L,EAAK4W,EAJL7kC,EAAU,GACVD,EAAY,GACZ65B,EAAU,GACVC,EAAM,GAENmM,EAASrM,EAAQsM,aAAe,IAAI,KAAO,GAAK,IAAM,KACtDC,EAAcvM,EAAQuM,aAAe,EACrC9nB,GAAS,EACb,GAAIub,EAAQwM,UAAYxM,EAAQyM,UAAW,CACvChoB,GAAS,EACT,IAAI1a,EAAOi2B,EAAQyM,UACnBzM,EAAQyM,UAAYzM,EAAQwM,UAC5BxM,EAAQwM,UAAYziC,EAGxB,IAAKuqB,EAAM,EAAGA,GAAO0L,EAAQsC,aAAchO,IACvC,IAAK4W,EAAM,EAAGA,GAAOlL,EAAQsC,aAAc4I,IAAO,CAC9C,IAAIz9B,EAAW,IAAI,IAASy9B,EAAMlL,EAAQxmB,MAASwmB,EAAQsC,aAAetC,EAAQxmB,MAAQ,EAAK,GAAKwmB,EAAQsC,aAAehO,GAAO0L,EAAQvmB,OAAUumB,EAAQsC,aAAetC,EAAQvmB,OAAS,GAIxLizB,EAAwD,KAFxCj/B,EAAS7M,EAAIo/B,EAAQxmB,MAAQ,GAAKwmB,EAAQxmB,OAAUwmB,EAAQ2M,YAAc,GAAM,KACjF,GAAOl/B,EAAS/H,EAAIs6B,EAAQvmB,OAAS,GAAKumB,EAAQvmB,SAAWumB,EAAQ4M,aAAe,GAAM,GACxE5M,EAAQ2M,aACzC/vC,EAAIojC,EAAQ6M,OAAOH,GAAO,IAC1B7vC,EAAImjC,EAAQ6M,OAAOH,EAAM,GAAK,IAC9B5vC,EAAIkjC,EAAQ6M,OAAOH,EAAM,GAAK,IAC9B5oC,EAAIk8B,EAAQ6M,OAAOH,EAAM,GAAK,IAC9BjoB,IACA7nB,EAAI,EAAMA,EACVC,EAAI,EAAMA,EACVC,EAAI,EAAMA,GAEd,IAAIg7B,EAAWl7B,EAAIyvC,EAAOzvC,EAAIC,EAAIwvC,EAAOxvC,EAAIC,EAAIuvC,EAAOvvC,EAIpD2Q,EAAShI,EADT3B,GAAKyoC,EACQvM,EAAQwM,WAAaxM,EAAQyM,UAAYzM,EAAQwM,WAAa1U,EAG9DkI,EAAQwM,UAAY,KAGrCpmC,EAAUhB,KAAKqI,EAAS7M,EAAG6M,EAAShI,EAAGgI,EAAS/H,GAChDu6B,EAAQ76B,KAAK,EAAG,EAAG,GACnB86B,EAAI96B,KAAK8lC,EAAMlL,EAAQsC,aAAc,EAAMhO,EAAM0L,EAAQsC,cAIjE,IAAKhO,EAAM,EAAGA,EAAM0L,EAAQsC,aAAchO,IACtC,IAAK4W,EAAM,EAAGA,EAAMlL,EAAQsC,aAAc4I,IAAO,CAE7C,IAAI4B,EAAO5B,EAAM,GAAK5W,EAAM,IAAM0L,EAAQsC,aAAe,GACrDyK,EAAO7B,EAAM,EAAI5W,GAAO0L,EAAQsC,aAAe,GAC/C0K,EAAO9B,EAAM5W,GAAO0L,EAAQsC,aAAe,GAC3C2K,EAAO/B,GAAO5W,EAAM,IAAM0L,EAAQsC,aAAe,GAIjD4K,EAAgB9mC,EAAiB,EAAP0mC,EAAW,IAAM9M,EAAQwM,UACnDW,EAAgB/mC,EAAiB,EAAP2mC,EAAW,IAAM/M,EAAQwM,UACnDY,EAAgBhnC,EAAiB,EAAP4mC,EAAW,IAAMhN,EAAQwM,UACnDU,GAAiBC,GAAiBC,IAClC/mC,EAAQjB,KAAK0nC,GACbzmC,EAAQjB,KAAK2nC,GACb1mC,EAAQjB,KAAK4nC,IAEG5mC,EAAiB,EAAP6mC,EAAW,IAAMjN,EAAQwM,WAClCU,GAAiBE,IAClC/mC,EAAQjB,KAAK6nC,GACb5mC,EAAQjB,KAAK0nC,GACbzmC,EAAQjB,KAAK4nC,IAKzB,mBAA0B5mC,EAAWC,EAAS45B,GAE9C,IAAI0B,EAAa,IAAI,IAKrB,OAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EAmBJ,SAAS0L,EAAavL,EAAM9B,EAAS+B,QACxB,IAAZ/B,IAAsBA,EAAU,IACpC,IAAIsN,EAAS,IAAI,IAAWxL,EAAMC,GAalC,OAZAuL,EAAOC,WAAU,GACjBD,EAAOE,eAAiBxN,EAAQmL,eAAiBnL,EAAQsC,cAAgB,EACzEgL,EAAOG,eAAiBzN,EAAQoL,eAAiBpL,EAAQsC,cAAgB,EACzEgL,EAAOI,OAAS1N,EAAQxmB,OAAS,EACjC8zB,EAAOK,QAAU3N,EAAQvmB,QAAU,EACnC6zB,EAAOM,MAAQN,EAAOI,OAAS,EAC/BJ,EAAOO,MAAQP,EAAOK,QAAU,EAChCL,EAAOQ,OAASR,EAAOM,MACvBN,EAAOS,OAAST,EAAOO,MACN5C,EAAuBjL,GAC7BkC,YAAYoL,EAAQtN,EAAQmC,WACvCmL,EAAOC,WAAU,GACVD,EA0BJ,SAASU,EAAkBlM,EAAM9B,EAAS+B,QAC/B,IAAVA,IAAoBA,EAAQ,MAChC,IAAIkM,EAAc,IAAI,KAAKnM,EAAMC,GAGjC,OAFiBsJ,EAA4BrL,GAClCkC,YAAY+L,EAAajO,EAAQmC,WACrC8L,EA8BJ,SAASC,EAA0BpM,EAAMqM,EAAKnO,EAAS+B,QAC1C,IAAZ/B,IAAsBA,EAAU,SACtB,IAAV+B,IAAoBA,EAAQ,MAChC,IAAIvoB,EAAQwmB,EAAQxmB,OAAS,GACzBC,EAASumB,EAAQvmB,QAAU,GAC3B6oB,EAAetC,EAAQsC,cAAgB,EACvCkK,EAAYxM,EAAQwM,WAAa,EACjCC,EAAYzM,EAAQyM,WAAa,EACjCJ,EAASrM,EAAQsM,aAAe,IAAI,KAAO,GAAK,IAAM,KACtDC,EAAcvM,EAAQuM,aAAe,EACrCpK,EAAYnC,EAAQmC,UACpBiM,EAAUpO,EAAQoO,QACtBrM,EAAQA,GAAS,qBACjB,IAAIuL,EAAS,IAAI,IAAWxL,EAAMC,GAClCuL,EAAOE,eAAiBlL,EACxBgL,EAAOG,eAAiBnL,EACxBgL,EAAOI,OAASl0B,EAChB8zB,EAAOK,QAAUl0B,EACjB6zB,EAAOM,MAAQN,EAAOI,OAAS,EAC/BJ,EAAOO,MAAQP,EAAOK,QAAU,EAChCL,EAAOQ,OAASR,EAAOM,MACvBN,EAAOS,OAAST,EAAOO,MACvBP,EAAOC,WAAU,GA4BjB,OADA,eAAgBY,GA1BH,SAAUE,GACnB,IAAI1B,EAAc0B,EAAI70B,MAClBozB,EAAeyB,EAAI50B,OACvB,IAAIsoB,EAAMuM,WAAV,CAGA,IAAIzB,EAAS9K,aAAqC,EAASA,EAAMwM,YAAYC,kBAAkBH,EAAK1B,EAAaC,GAChGR,EAAoC,CACjD5yB,MAAOA,EACPC,OAAQA,EACR6oB,aAAcA,EACdkK,UAAWA,EACXC,UAAWA,EACXH,YAAaD,EACbQ,OAAQA,EACRF,YAAaA,EACbC,aAAcA,EACdL,YAAaA,IAENrK,YAAYoL,EAAQnL,GAE3BiM,GACAA,EAAQd,GAEZA,EAAOC,WAAU,OAEQ,cAAiBxL,EAAM0M,iBAC7CnB,EAMJ,IAAIoB,EAAgB,CAEvBrB,aAAcA,EAEda,0BAA2BA,EAE3BF,kBAAmBA,GAEvB,iBAA0B/C,EAC1B,sBAA+BI,EAC/B,8BAAuCe,EACvC,kBAAoB,SAAUtK,EAAMtoB,EAAOC,EAAQ6oB,EAAcP,EAAOI,GAOpE,OAAOkL,EAAavL,EANN,CACVtoB,MAAOA,EACPC,OAAQA,EACR6oB,aAAcA,EACdH,UAAWA,GAEoBJ,IAEvC,uBAAyB,SAAUD,EAAM0J,EAAMrP,EAAMsP,EAAMrP,EAAMkG,EAAcoJ,EAAW3J,EAAOI,GAU7F,OAAO6L,EAAkBlM,EATX,CACV0J,KAAMA,EACNrP,KAAMA,EACNsP,KAAMA,EACNrP,KAAMA,EACNkG,aAAcA,EACdoJ,UAAWA,EACXvJ,UAAWA,GAEyBJ,IAE5C,+BAAiC,SAAUD,EAAMqM,EAAK30B,EAAOC,EAAQ6oB,EAAckK,EAAWC,EAAW1K,EAAOI,EAAWiM,EAAS7B,GAWhI,OAAO2B,EAA0BpM,EAAMqM,EAVzB,CACV30B,MAAOA,EACPC,OAAQA,EACR6oB,aAAcA,EACdkK,UAAWA,EACXC,UAAWA,EACXtK,UAAWA,EACXiM,QAASA,EACT7B,YAAaA,GAEoCxK,K,8EC9alD,SAAS4M,EAAiB7M,EAAM9B,EAAS+B,QAC5B,IAAZ/B,IAAsBA,EAAU,IAC/BA,EAAQgF,WACThF,EAAQgF,SAAW,GAElBhF,EAAQ4O,WACT5O,EAAQ4O,SAAW,IAEvB,IAAIC,GAAa,QAAa,GAAI,CAAEv/B,MAAO,GAAK01B,SAAUhF,EAAQgF,SAAU4J,SAAU5O,EAAQ4O,UAAY7M,GACtG6G,GAAO,OAAW,GAAI,CAAEx+B,OAAQ41B,EAAQgF,SAAW,EAAGzC,aAAiC,EAAnBvC,EAAQ4O,UAAgB,EAAI5O,EAAQ4O,WAAa7M,GACzH6G,EAAKniB,SAAS7lB,GAAKrB,KAAK6J,GAAK,EAC7Bw/B,EAAKkG,OAASD,EACd,IAAIE,EAAS,iBAAiB,CAACnG,EAAMiG,IAAa,GAElD,OADAE,EAAOjN,KAAOA,EACPiN,EAMJ,IAAIC,EAAoB,CAE3BL,iBAAkBA,GAStB,sBAAwB,SAAU7M,EAAM8M,EAAU5J,EAAUjD,GAKxD,OAAO4M,EAAiB7M,EAJV,CACV8M,SAAUA,EACV5J,SAAUA,GAEyBjD,K,oGCtBpC,SAASkN,EAA0BjP,GACtC,IAgNIkP,EAhNA5N,EAAkBtB,EAAQsB,iBAAmB,gBAC7Cl3B,EAAS41B,EAAQ51B,QAAU,EAC3B42B,OAAwBja,IAAjBiZ,EAAQgB,MAA4BhB,EAAQgB,KACnDsB,EAAetC,EAAQsC,cAAgB,EACvC6M,EAAUnP,EAAQmP,SAAW/kC,EAC7BglC,EAAUpP,EAAQoP,SAAWhlC,EAC7BilC,EAAUrP,EAAQqP,SAAWjlC,EAC7B9B,GAAK,EAAI/I,KAAKuF,KAAK,IAAM,EAEzBwqC,EAAc,EACb,EACDhnC,GACC,EACD,EACAA,EACA,GACC,GACAA,EACD,EACA,GACCA,EACD,EACA,GACC,GACAA,EACD,EACA,GACCA,EACD,GACC,EACDA,EACA,EACA,EACAA,EACAA,EACA,EACA,EACAA,EACA,GACC,GACAA,EACD,EACA,GACCA,EACD,GACC,GAGDinC,EAAc,CACd,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GACxK,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,GAGhCC,EAAsB,CACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GAEA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IAGAC,EAAe,CACf,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAgDAC,EAAS,CACT,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEArpC,EAAU,IAAIY,MACdb,EAAY,IAAIa,MAChBg5B,EAAU,IAAIh5B,MACdi5B,EAAM,IAAIj5B,MACV0oC,EAAiB,EAEjBC,EAAkB,IAAI3oC,MAAM,GAC5B4oC,EAAiB,IAAI5oC,MAAM,GAE/B,IAAKioC,EAAO,EAAGA,EAAO,EAAGA,IACrBU,EAAgBV,GAAQ,WACxBW,EAAeX,GAAQ,YAG3B,IAAK,IAAItF,EAAO,EAAGA,EAAO,GAAIA,IAAQ,CAElC,IAAKsF,EAAO,EAAGA,EAAO,EAAGA,IAAQ,CAE7B,IAAIY,EAAOP,EAAY,EAAI3F,EAAOsF,GAElCU,EAAgBV,GAAM/vC,eAAemwC,EAAY,EAAIE,EAAoBM,IAAQR,EAAY,EAAIE,EAAoBM,GAAQ,GAAIR,EAAY,EAAIE,EAAoBM,GAAQ,IAE7KF,EAAgBV,GAAMtpC,YAAY2L,aAAanH,GAE/CylC,EAAeX,GAAM/vC,eAxDjB,WAwDgCswC,EAAa,EAAIK,GAtD/C,WAIQ,SAkDiEJ,EAAO9F,GAvDlF,YAuD2G6F,EAAa,EAAIK,EAAO,GArDjI,WAIQ,UAiDgJJ,EAAO9F,IAyEzK,IAnCA,IAAImG,EAAgB,SAAU5V,EAAIkK,EAAIhN,EAAI2Y,GAItC,IAIIC,EAJAC,EAAS,SAAaN,EAAgB,GAAIA,EAAgB,GAAIvL,EAAK/B,GACnE6N,EAAS,SAAaP,EAAgB,GAAIA,EAAgB,GAAIvL,EAAK/B,GACnE8N,EAAa9N,IAAiB+B,EAAKuL,EAAgB,GAAK,SAAaM,EAAQC,EAAQhW,GAAMmI,EAAe+B,IAG9G,GAFA+L,EAAWxqC,YAEPo7B,EAAM,CAEN,IAAIqP,EAAc,SAAaT,EAAgB,GAAIA,EAAgB,GAAII,EAAK1N,GACxEgO,EAAc,SAAaV,EAAgB,GAAIA,EAAgB,GAAII,EAAK1N,GAC5E2N,EAAgB,SAAaI,EAAaC,EAAajZ,GAAMiL,EAAe0N,SAI5EC,EAAgB,IAAI,IAAQG,EAAWxvC,EAAGwvC,EAAW3qC,EAAG2qC,EAAW1qC,GAGvEuqC,EAAcrvC,GAAKuuC,EACnBc,EAAcxqC,GAAK2pC,EACnBa,EAAcvqC,GAAK2pC,EACnBY,EAAcrqC,YACd,IAAI2qC,EAAQ,UAAaV,EAAe,GAAIA,EAAe,GAAIxL,EAAK/B,GAChEkO,EAAQ,UAAaX,EAAe,GAAIA,EAAe,GAAIxL,EAAK/B,GAChEmO,EAAYnO,IAAiB+B,EAAKwL,EAAe,GAAK,UAAaU,EAAOC,EAAOrW,GAAMmI,EAAe+B,IAC1Gj+B,EAAUhB,KAAKgrC,EAAWxvC,EAAIuuC,EAASiB,EAAW3qC,EAAI2pC,EAASgB,EAAW1qC,EAAI2pC,GAC9EpP,EAAQ76B,KAAK6qC,EAAcrvC,EAAGqvC,EAAcxqC,EAAGwqC,EAAcvqC,GAC7Dw6B,EAAI96B,KAAKqrC,EAAU7vC,EAAG,8BAAiD,EAAM6vC,EAAUhrC,EAAIgrC,EAAUhrC,GAGrGY,EAAQjB,KAAKuqC,GACbA,KAEKtL,EAAK,EAAGA,EAAK/B,EAAc+B,IAChC,IAAK,IAAIlK,EAAK,EAAGA,EAAKkK,EAAK/B,EAAcnI,IAGrC4V,EAAc5V,EAAIkK,EAAIlK,EAAK,EAAM,EAAGkK,EAAK,EAAM,GAC/C0L,EAAc5V,EAAK,EAAGkK,EAAIlK,EAAK,EAAM,EAAGkK,EAAK,EAAM,GACnD0L,EAAc5V,EAAIkK,EAAK,EAAGlK,EAAK,EAAM,EAAGkK,EAAK,EAAM,GAC/ClK,EAAKkK,EAAK,EAAI/B,IAGdyN,EAAc5V,EAAK,EAAGkK,EAAIlK,EAAK,EAAM,EAAGkK,EAAK,EAAM,GACnD0L,EAAc5V,EAAK,EAAGkK,EAAK,EAAGlK,EAAK,EAAM,EAAGkK,EAAK,EAAM,GACvD0L,EAAc5V,EAAIkK,EAAK,EAAGlK,EAAK,EAAM,EAAGkK,EAAK,EAAM,IAMnE,kBAAyB/C,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SAEtG,IAAIC,EAAa,IAAI,IAKrB,OAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EA2BJ,SAAS+O,EAAgB5O,EAAM9B,EAAS+B,QAC3B,IAAZ/B,IAAsBA,EAAU,SACtB,IAAV+B,IAAoBA,EAAQ,MAChC,IAAI4O,EAAS,IAAI,KAAK7O,EAAMC,GAK5B,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClEqP,EAAO1O,gCAAkCjC,EAAQsB,gBAChC2N,EAA0BjP,GAChCkC,YAAYyO,EAAQ3Q,EAAQmC,WAChCwO,EAMJ,IAAIC,EAAmB,CAE1BF,gBAAiBA,GAErB,oBAA6BzB,EAC7B,qBAAuB,SAAUnN,EAAM9B,EAAS+B,GAC5C,OAAO2O,EAAgB5O,EAAM9B,EAAS+B,K,mpCC1WnC,SAAS8O,EAAY/O,EAAM9B,EAAS+B,QACzB,IAAVA,IAAoBA,EAAQ,MAChC,IAeI+O,EACAjkC,EAhBAnB,EAAMs0B,EAAQt0B,IAAOs0B,EAAQt0B,KAAO,GAAKs0B,EAAQt0B,IAAM,EAAI,EAAMs0B,EAAQt0B,IAAO,EAChFV,OAA4B+b,IAAnBiZ,EAAQh1B,QAA8Bg1B,EAAQh1B,OACvD+lC,EAAQ/Q,EAAQ+Q,MAChB3mC,EAAS41B,EAAQ51B,QAAU,EAC3Bm4B,EAAevC,EAAQuC,cAAgB,GACvCmF,EAAO1H,EAAQ0H,MAAQ,EACvBvF,EAAYnC,EAAQmC,UACpBb,EAAkB,gCAAgCtB,EAAQsB,iBAC1D8D,EAAMpF,EAAQoF,KAAO,YACrB7B,EAAgB,EAAVhkC,KAAK6J,GACX4nC,EAAQ,IAAI/pC,MACZgqC,EAAWjR,EAAQiR,WAAY,EAC/BloC,EAAI,EACJ8E,EAAI,EACJ0F,EAAQgwB,EAAMhB,EAAgB72B,EAGlC,IAAK3C,EAAI,EAAGA,GAAKw5B,EAAemF,EAAM3+B,IAAK,CAMvC,IALA8D,EAAO,GACHu4B,GAAO,gBAAkBA,GAAO,eAChCv4B,EAAKzH,KAAK,IAAI,IAAQ,EAAG2rC,EAAM,GAAGtrC,EAAG,IACrCoH,EAAKzH,KAAK,IAAI,IAAQ7F,KAAKsM,IAAI9C,EAAIwK,GAAQw9B,EAAM,GAAGnwC,EAAIwJ,EAAQ2mC,EAAM,GAAGtrC,EAAGlG,KAAKuM,IAAI/C,EAAIwK,GAAQw9B,EAAM,GAAGnwC,EAAIwJ,KAE7GyD,EAAI,EAAGA,EAAIkjC,EAAM7vC,OAAQ2M,IAC1BijC,EAAU,IAAI,IAAQvxC,KAAKsM,IAAI9C,EAAIwK,GAAQw9B,EAAMljC,GAAGjN,EAAIwJ,EAAQ2mC,EAAMljC,GAAGpI,EAAGlG,KAAKuM,IAAI/C,EAAIwK,GAAQw9B,EAAMljC,GAAGjN,EAAIwJ,GAC9GyC,EAAKzH,KAAK0rC,GAEV1L,GAAO,cAAgBA,GAAO,eAC9Bv4B,EAAKzH,KAAK,IAAI,IAAQ7F,KAAKsM,IAAI9C,EAAIwK,GAAQw9B,EAAMA,EAAM7vC,OAAS,GAAGN,EAAIwJ,EAAQ2mC,EAAMA,EAAM7vC,OAAS,GAAGuE,EAAGlG,KAAKuM,IAAI/C,EAAIwK,GAAQw9B,EAAMA,EAAM7vC,OAAS,GAAGN,EAAIwJ,IAC3JyC,EAAKzH,KAAK,IAAI,IAAQ,EAAG2rC,EAAMA,EAAM7vC,OAAS,GAAGuE,EAAG,KAExDurC,EAAM5rC,KAAKyH,GAIf,OADY,QAAai1B,EAAM,CAAEoP,UAAWF,EAAOG,WAAYnmC,EAAQs2B,gBAAiBA,EAAiBa,UAAWA,EAAW8O,SAAUA,EAAUxP,SAAUzB,EAAQyB,SAAUC,QAAS1B,EAAQ0B,SAAWK,GAOxM,IAAIqP,EAAe,CAEtBP,YAAaA,GAEjB,iBAAmB,SAAU/O,EAAMiP,EAAO3mC,EAAQm4B,EAAcR,EAAOI,EAAWb,GAQ9E,OAAOuP,EAAY/O,EAPL,CACViP,MAAOA,EACP3mC,OAAQA,EACRm4B,aAAcA,EACdjB,gBAAiBA,EACjBa,UAAWA,GAEmBJ,K,oJC1E/B,SAASsP,EAA2BrR,GAOvC,IANA,IAAI35B,EAAU,GACVD,EAAY,GACZkrC,EAAQtR,EAAQsR,MAChBhtC,EAAS07B,EAAQ17B,OACjBitC,EAAe,GACfC,EAAM,EACD1hC,EAAI,EAAGA,EAAIwhC,EAAMpwC,OAAQ4O,IAE9B,IADA,IAAIqC,EAASm/B,EAAMxhC,GACVvS,EAAQ,EAAGA,EAAQ4U,EAAOjR,OAAQ3D,IAAS,CAEhD,GADA6I,EAAUhB,KAAK+M,EAAO5U,GAAOqD,EAAGuR,EAAO5U,GAAOkI,EAAG0M,EAAO5U,GAAOmI,GAC3DpB,EAAQ,CACR,IAAIN,EAAQM,EAAOwL,GACnByhC,EAAansC,KAAKpB,EAAMzG,GAAOX,EAAGoH,EAAMzG,GAAOV,EAAGmH,EAAMzG,GAAOT,EAAGkH,EAAMzG,GAAOuG,GAE/EvG,EAAQ,IACR8I,EAAQjB,KAAKosC,EAAM,GACnBnrC,EAAQjB,KAAKosC,IAEjBA,IAGR,IAAI7P,EAAa,IAAI,IAMrB,OALAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACnB9B,IACAq9B,EAAWr9B,OAASitC,GAEjB5P,EAeJ,SAAS8P,EAA4BzR,GACxC,IASI0R,EACAC,EAVAC,EAAW5R,EAAQ4R,UAAY,EAC/BC,EAAU7R,EAAQ6R,SAAW,EAC7BC,EAAS9R,EAAQ8R,QAAU,IAC3B3/B,EAAS6tB,EAAQ7tB,OACjB/L,EAAY,IAAIa,MAChBZ,EAAU,IAAIY,MACd8qC,EAAU,WACVC,EAAK,EACLC,EAAK,EAGLC,EAAU,EACVV,EAAM,EACNzoC,EAAI,EACR,IAAKA,EAAI,EAAGA,EAAIoJ,EAAOjR,OAAS,EAAG6H,IAC/BoJ,EAAOpJ,EAAI,GAAGhK,cAAcoT,EAAOpJ,GAAIgpC,GACvCC,GAAMD,EAAQ7wC,SAIlB,IADAywC,EAAYC,GADZF,EAAOM,EAAKF,IACoBF,EAAWC,GACtC9oC,EAAI,EAAGA,EAAIoJ,EAAOjR,OAAS,EAAG6H,IAAK,CACpCoJ,EAAOpJ,EAAI,GAAGhK,cAAcoT,EAAOpJ,GAAIgpC,GACvCE,EAAK1yC,KAAKgI,MAAMwqC,EAAQ7wC,SAAWwwC,GACnCK,EAAQnsC,YACR,IAAK,IAAI0G,EAAI,EAAGA,EAAI2lC,EAAI3lC,IACpB4lC,EAAUR,EAAOplC,EACjBlG,EAAUhB,KAAK+M,EAAOpJ,GAAGnI,EAAIsxC,EAAUH,EAAQnxC,EAAGuR,EAAOpJ,GAAGtD,EAAIysC,EAAUH,EAAQtsC,EAAG0M,EAAOpJ,GAAGrD,EAAIwsC,EAAUH,EAAQrsC,GACrHU,EAAUhB,KAAK+M,EAAOpJ,GAAGnI,GAAKsxC,EAAUP,GAAYI,EAAQnxC,EAAGuR,EAAOpJ,GAAGtD,GAAKysC,EAAUP,GAAYI,EAAQtsC,EAAG0M,EAAOpJ,GAAGrD,GAAKwsC,EAAUP,GAAYI,EAAQrsC,GAC5JW,EAAQjB,KAAKosC,EAAKA,EAAM,GACxBA,GAAO,EAIf,IAAI7P,EAAa,IAAI,IAGrB,OAFAA,EAAWv7B,UAAYA,EACvBu7B,EAAWt7B,QAAUA,EACds7B,EA0BJ,SAASwQ,EAAiBrQ,EAAM9B,EAAS+B,GAC5C,IAAIqQ,EAAWpS,EAAQoS,SACnBd,EAAQtR,EAAQsR,MAChBhtC,EAAS07B,EAAQ17B,OACrB,GAAI8tC,EAAU,CAEV,IAAIhsC,EAAYgsC,EAASzL,gBAAgB,kBACrC0L,OAAc,EACdC,OAAa,EACbhuC,IACA+tC,EAAcD,EAASzL,gBAAgB,gBAI3C,IAFA,IAAI59B,EAAI,EACJ4K,EAAI,EACC7D,EAAI,EAAGA,EAAIwhC,EAAMpwC,OAAQ4O,IAE9B,IADA,IAAIqC,EAASm/B,EAAMxhC,GACVjC,EAAI,EAAGA,EAAIsE,EAAOjR,OAAQ2M,IAC/BzH,EAAU2C,GAAKoJ,EAAOtE,GAAGjN,EACzBwF,EAAU2C,EAAI,GAAKoJ,EAAOtE,GAAGpI,EAC7BW,EAAU2C,EAAI,GAAKoJ,EAAOtE,GAAGnI,EACzBpB,GAAU+tC,IACVC,EAAahuC,EAAOwL,GACpBuiC,EAAY1+B,GAAK2+B,EAAWzkC,GAAGjR,EAC/By1C,EAAY1+B,EAAI,GAAK2+B,EAAWzkC,GAAGhR,EACnCw1C,EAAY1+B,EAAI,GAAK2+B,EAAWzkC,GAAG/Q,EACnCu1C,EAAY1+B,EAAI,GAAK2+B,EAAWzkC,GAAG/J,EACnC6P,GAAK,GAET5K,GAAK,EAOb,OAJAqpC,EAASG,mBAAmB,iBAA2BnsC,GAAW,GAAO,GACrE9B,GAAU+tC,GACVD,EAASG,mBAAmB,cAAwBF,GAAa,GAAO,GAErED,EAGX,IAAII,IAAiBluC,EACjBmuC,EAAa,IAAI,IAAU3Q,EAAMC,EAAO,UAAMhb,OAAWA,EAAWyrB,EAAgBxS,EAAQ0S,eAAgB1S,EAAQ2S,UAGxH,OAFiBtB,EAA2BrR,GACjCkC,YAAYuQ,EAAYzS,EAAQmC,WACpCsQ,EAyBJ,SAASG,EAAY9Q,EAAM9B,EAAS+B,QACzB,IAAVA,IAAoBA,EAAQ,MAChC,IAAIz9B,EAAS07B,EAAQ17B,OAAS,CAAC07B,EAAQ17B,QAAU,KAEjD,OADY6tC,EAAiBrQ,EAAM,CAAEwP,MAAO,CAACtR,EAAQ7tB,QAASgwB,UAAWnC,EAAQmC,UAAWiQ,SAAUpS,EAAQoS,SAAU9tC,OAAQA,EAAQouC,eAAgB1S,EAAQ0S,eAAgBC,SAAU3S,EAAQ2S,UAAY5Q,GA8B3M,SAAS8Q,EAAkB/Q,EAAM9B,EAAS+B,QAC/B,IAAVA,IAAoBA,EAAQ,MAChC,IAAI5vB,EAAS6tB,EAAQ7tB,OACjBigC,EAAWpS,EAAQoS,SACnBP,EAAU7R,EAAQ6R,SAAW,EAC7BD,EAAW5R,EAAQ4R,UAAY,EACnC,GAAIQ,EAAU,CAiDV,OAJIpS,EAAQ8R,QAAU9R,EAAQ4R,UAAY5R,EAAQ6R,SAAW7R,EAAQ0S,gBAAkB1S,EAAQ2S,WAC3F,SAAY,iIAEhBP,EAASU,qBA9Cc,SAAU1sC,GAC7B,IAIIsrC,EACAC,EALAI,EAAU,WACVgB,EAAQ3sC,EAAUlF,OAAS,EAC3B8wC,EAAK,EACLC,EAAK,EAGLC,EAAU,EACVrkC,EAAI,EACJ9E,EAAI,EACJuD,EAAI,EACR,IAAKvD,EAAI,EAAGA,EAAIoJ,EAAOjR,OAAS,EAAG6H,IAC/BoJ,EAAOpJ,EAAI,GAAGhK,cAAcoT,EAAOpJ,GAAIgpC,GACvCC,GAAMD,EAAQ7wC,SAElBwwC,EAAOM,EAAKe,EACZ,IAAInB,EAAWQ,EAASY,qBAAqBpB,SAG7C,IADAD,EAAYC,EAAWF,GAASE,EADlBQ,EAASY,qBAAqBnB,SAEvC9oC,EAAI,EAAGA,EAAIoJ,EAAOjR,OAAS,EAAG6H,IAK/B,IAJAoJ,EAAOpJ,EAAI,GAAGhK,cAAcoT,EAAOpJ,GAAIgpC,GACvCE,EAAK1yC,KAAKgI,MAAMwqC,EAAQ7wC,SAAWwwC,GACnCK,EAAQnsC,YACR0G,EAAI,EACGA,EAAI2lC,GAAMpkC,EAAIzH,EAAUlF,QAC3BgxC,EAAUR,EAAOplC,EACjBlG,EAAUyH,GAAKsE,EAAOpJ,GAAGnI,EAAIsxC,EAAUH,EAAQnxC,EAC/CwF,EAAUyH,EAAI,GAAKsE,EAAOpJ,GAAGtD,EAAIysC,EAAUH,EAAQtsC,EACnDW,EAAUyH,EAAI,GAAKsE,EAAOpJ,GAAGrD,EAAIwsC,EAAUH,EAAQrsC,EACnDU,EAAUyH,EAAI,GAAKsE,EAAOpJ,GAAGnI,GAAKsxC,EAAUP,GAAYI,EAAQnxC,EAChEwF,EAAUyH,EAAI,GAAKsE,EAAOpJ,GAAGtD,GAAKysC,EAAUP,GAAYI,EAAQtsC,EAChEW,EAAUyH,EAAI,GAAKsE,EAAOpJ,GAAGrD,GAAKwsC,EAAUP,GAAYI,EAAQrsC,EAChEmI,GAAK,EACLvB,IAGR,KAAOuB,EAAIzH,EAAUlF,QACjBkF,EAAUyH,GAAKsE,EAAOpJ,GAAGnI,EACzBwF,EAAUyH,EAAI,GAAKsE,EAAOpJ,GAAGtD,EAC7BW,EAAUyH,EAAI,GAAKsE,EAAOpJ,GAAGrD,EAC7BmI,GAAK,KAMkC,GACxCukC,EAGX,IAAIa,EAAc,IAAI,IAAUnR,EAAMC,EAAO,UAAMhb,OAAWA,OAAWA,EAAWiZ,EAAQ0S,eAAgB1S,EAAQ2S,UAMpH,OALiBlB,EAA4BzR,GAClCkC,YAAY+Q,EAAajT,EAAQmC,WAC5C8Q,EAAYD,qBAAuB,IAAI,KACvCC,EAAYD,qBAAqBpB,SAAWA,EAC5CqB,EAAYD,qBAAqBnB,QAAUA,EACpCoB,EAMJ,IAAIC,EAAe,CACtBL,kBAAmBA,EACnBV,iBAAkBA,EAClBS,YAAaA,GAEjB,qBAA8BvB,EAC9B,sBAA+BI,EAC/B,iBAAmB,SAAU3P,EAAM3vB,EAAQ4vB,EAAOI,EAAWiQ,GASzD,YARc,IAAVrQ,IAAoBA,EAAQ,WACd,IAAdI,IAAwBA,GAAY,QACvB,IAAbiQ,IAAuBA,EAAW,MAM/BQ,EAAY9Q,EALL,CACV3vB,OAAQA,EACRgwB,UAAWA,EACXiQ,SAAUA,GAEoBrQ,IAEtC,uBAAyB,SAAUD,EAAM3vB,EAAQy/B,EAAUC,EAASC,EAAQ/P,EAAOI,EAAWiQ,GAU1F,YATc,IAAVrQ,IAAoBA,EAAQ,MASzB8Q,EAAkB/Q,EARX,CACV3vB,OAAQA,EACRy/B,SAAUA,EACVC,QAASA,EACTC,OAAQA,EACR3P,UAAWA,EACXiQ,SAAUA,GAE0BrQ,K,yFC5SrC,SAASoR,EAAsBnT,GAClC,IAAI35B,EAAU,GACVD,EAAY,GACZ65B,EAAU,GACVC,EAAM,GACN1mB,EAAQwmB,EAAQxmB,OAASwmB,EAAQjgB,MAAQ,EACzCtG,EAASumB,EAAQvmB,QAAUumB,EAAQjgB,MAAQ,EAC3CuhB,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBAEjF8R,EAAY55B,EAAQ,EACpB8pB,EAAa7pB,EAAS,EAC1BrT,EAAUhB,MAAMguC,GAAY9P,EAAY,GACxCrD,EAAQ76B,KAAK,EAAG,GAAI,GACpB86B,EAAI96B,KAAK,EAAK,8BAAiD,EAAM,GACrEgB,EAAUhB,KAAKguC,GAAY9P,EAAY,GACvCrD,EAAQ76B,KAAK,EAAG,GAAI,GACpB86B,EAAI96B,KAAK,EAAK,8BAAiD,EAAM,GACrEgB,EAAUhB,KAAKguC,EAAW9P,EAAY,GACtCrD,EAAQ76B,KAAK,EAAG,GAAI,GACpB86B,EAAI96B,KAAK,EAAK,8BAAiD,EAAM,GACrEgB,EAAUhB,MAAMguC,EAAW9P,EAAY,GACvCrD,EAAQ76B,KAAK,EAAG,GAAI,GACpB86B,EAAI96B,KAAK,EAAK,8BAAiD,EAAM,GAErEiB,EAAQjB,KAAK,GACbiB,EAAQjB,KAAK,GACbiB,EAAQjB,KAAK,GACbiB,EAAQjB,KAAK,GACbiB,EAAQjB,KAAK,GACbiB,EAAQjB,KAAK,GAEb,kBAAyBk8B,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SAEtG,IAAIC,EAAa,IAAI,IAKrB,OAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EAwBJ,SAAS0R,EAAYvR,EAAM9B,EAAS+B,QACvB,IAAZ/B,IAAsBA,EAAU,SACtB,IAAV+B,IAAoBA,EAAQ,MAChC,IAAInkB,EAAQ,IAAI,KAAKkkB,EAAMC,GAS3B,OARA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClE1jB,EAAMqkB,gCAAkCjC,EAAQsB,gBAC/B6R,EAAsBnT,GAC5BkC,YAAYtkB,EAAOoiB,EAAQmC,WAClCnC,EAAQsT,cACR11B,EAAM21B,UAAUvT,EAAQsT,YAAY9tC,QAASw6B,EAAQsT,YAAY3tC,GACjEiY,EAAM41B,aAAaxT,EAAQsT,YAAY9tC,OAAOlH,OAAO,KAElDsf,EAMJ,IAAI61B,EAAe,CAEtBJ,YAAaA,GAEjB,gBAAyBF,EACzB,iBAAmB,SAAUrR,EAAM/hB,EAAMgiB,EAAOI,EAAWb,GAQvD,OAAO+R,EAAYvR,EAPL,CACV/hB,KAAMA,EACNvG,MAAOuG,EACPtG,OAAQsG,EACRuhB,gBAAiBA,EACjBa,UAAWA,GAEmBJ,K,yJC7F/B,SAAS2R,EAAwBC,EAASrS,EAAiBsS,EAAKC,EAASpS,EAAUC,EAASoS,GAM/F,IALA,IAAIvS,EAASqS,GAAO,IAAI3sC,MAAM,GAC1Bu6B,EAAaqS,EACbvvC,EAAS,GACT87B,EAAO0T,IAAO,EAET9Y,EAAI,EAAGA,EAAI,EAAGA,SACDjU,IAAdwa,EAAOvG,KACPuG,EAAOvG,GAAK,IAAI,KAAQ,EAAG,EAAG,EAAG,IAEjCwG,QAAgCza,IAAlBya,EAAWxG,KACzBwG,EAAWxG,GAAK,IAAI,KAAO,EAAG,EAAG,EAAG,IAG5C,IAAI50B,EAAYutC,EAAQhN,gBAAgB,kBACpC1G,EAAU0T,EAAQhN,gBAAgB,gBAClCzG,EAAMyT,EAAQhN,gBAAgB,YAC9BtgC,EAAUstC,EAAQjN,aAClBj3B,EAAarJ,EAAUlF,OAAS,EAChC6yC,EAAO,EACPC,EAAQ,EACRC,EAAQ,EAERC,EAAW,EACXC,EAAW,CAAC,GAChB,GAAI/T,EACA,IAAK,IAAIgU,EAAQ3kC,EAAY2kC,EAAQhuC,EAAUlF,OAAS,EAAGkzC,GAAS,EAChEJ,EAAQ5tC,EAAU,GAAKguC,EAAQ,IAAMhuC,EAAU,EAAIguC,GACnDH,EAAQ7tC,EAAU,GAAKguC,EAAQ,GAAK,GAAKhuC,EAAU,EAAIguC,EAAQ,GAE/DF,GADO30C,KAAKuF,KAAKkvC,EAAQA,EAAQC,EAAQA,GAEzCE,EAAS/uC,KAAK8uC,GAMtB,IAFA,IAAI1C,EAAM,EACN5H,EAAO,EACFrsC,EAAQ,EAAGA,EAAQ0iC,EAAQ/+B,OAAQ3D,GAAS,EAE7CgC,KAAKsB,IAAIo/B,EAAQ1iC,EAAQ,IAAM,OAC/BqsC,EAAO,GAGPrqC,KAAKsB,IAAIo/B,EAAQ1iC,EAAQ,GAAK,GAAK,OACnCqsC,EAAO,GAGPrqC,KAAKsB,IAAIo/B,EAAQ1iC,EAAQ,GAAK,GAAK,OACnCqsC,EAAO,GAEX4H,EAAMj0C,EAAQ,EACD,IAATqsC,GACAmK,EAAOvC,EAAM/hC,EAGLywB,EAAI,EAAIsR,GAFZuC,EAAO,EAAI,IACP3T,EACemB,EAAOqI,GAAMhpC,GAAM2gC,EAAOqI,GAAMlkC,EAAI67B,EAAOqI,GAAMhpC,GAAKuzC,EAAS50C,KAAKgI,MAAMwsC,EAAO,IAAOG,EAGxF3S,EAAOqI,GAAMhpC,EAI5Bw/B,EACemB,EAAOqI,GAAMhpC,GAAM2gC,EAAOqI,GAAMlkC,EAAI67B,EAAOqI,GAAMhpC,GAAKuzC,EAAS50C,KAAKgI,MAAMwsC,EAAO,GAAK,GAAMG,EAG5F3S,EAAOqI,GAAMlkC,EAIhCw6B,EAAI,EAAIsR,EAAM,GADduC,EAAO,GAAM,EACM,8BAAiD,EAAMxS,EAAOqI,GAAM/vB,EAAI0nB,EAAOqI,GAAM/vB,EAGrF,8BAAiD,EAAM0nB,EAAOqI,GAAMnkC,EAAI87B,EAAOqI,GAAMnkC,IAI5Gy6B,EAAI,EAAIsR,IAAQ,EAAItR,EAAI,EAAIsR,IAAQjQ,EAAOqI,GAAMhpC,EAAIs/B,EAAI,EAAIsR,GAAOjQ,EAAOqI,GAAMlkC,EACjFw6B,EAAI,EAAIsR,EAAM,IAAM,EAAItR,EAAI,EAAIsR,EAAM,IAAMjQ,EAAOqI,GAAMnkC,EAAIy6B,EAAI,EAAIsR,EAAM,GAAKjQ,EAAOqI,GAAM/vB,EACzF,gCACAqmB,EAAI,EAAIsR,EAAM,GAAK,EAAMtR,EAAI,EAAIsR,EAAM,KAG3ChQ,GACAl9B,EAAOc,KAAKo8B,EAAWoI,GAAMhtC,EAAG4kC,EAAWoI,GAAM/sC,EAAG2kC,EAAWoI,GAAM9sC,EAAG0kC,EAAWoI,GAAM9lC,GAIjG,kBAAyBw9B,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKuB,EAAUC,GAEtF,IAAIC,EAAa,IAAI,IAKrB,GAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACbsB,EAAY,CACZ,IAAII,EAAcN,IAAoB,eAAwBh9B,EAAOoV,OAAOpV,GAAUA,EACtFq9B,EAAWr9B,OAASs9B,EAExB,OAAOD,EA2BJ,SAAS0S,EAAcvS,EAAM9B,EAAS+B,EAAOuS,QAClC,IAAVvS,IAAoBA,EAAQ,WACR,IAApBuS,IAA8BA,EAAkBC,QACpDvU,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAOlE,IANA,IAAIyP,EAAQ/Q,EAAQ+Q,MAChByD,EAAQxU,EAAQwU,OAAS,GACzBrU,EAAQH,EAAQG,OAAS,EACzBsU,EAAqBzU,EAAQyU,oBAAsB,EACnDC,EAAW,GACXC,EAAO,GACF5rC,EAAI,EAAGA,EAAIgoC,EAAM7vC,OAAQ6H,IAC9B2rC,EAAS3rC,GAAK,IAAI,KAAQgoC,EAAMhoC,GAAGnI,EAAGmwC,EAAMhoC,GAAGrD,GAG/CgvC,EAAS,GAAGx/B,kBAAkBw/B,EAASA,EAASxzC,OAAS,GAD/C,OAEVwzC,EAAS3T,MAGb,IADA,IAAI6T,EAAuB,IAAI,IAAmB9S,EAAM4S,EAAU3S,GAAS,qBAA8BuS,GAChGO,EAAM,EAAGA,EAAML,EAAMtzC,OAAQ2zC,IAAO,CACzCF,EAAO,GACP,IAAK,IAAIG,EAAS,EAAGA,EAASN,EAAMK,GAAK3zC,OAAQ4zC,IAC7CH,EAAKvvC,KAAK,IAAI,KAAQovC,EAAMK,GAAKC,GAAQl0C,EAAG4zC,EAAMK,GAAKC,GAAQpvC,IAEnEkvC,EAAqBG,QAAQJ,GAGjC,IAAIhB,EAAUiB,EAAqB5L,OAAM,EAAO7I,EAAOsU,GAIvD,OAHAd,EAAQ1R,gCAAkCjC,EAAQsB,gBACjCoS,EAAwBC,EAAS3T,EAAQsB,gBAAiBtB,EAAQuB,OAAQvB,EAAQwB,WAAYxB,EAAQyB,SAAUzB,EAAQ0B,QAAS1B,EAAQI,MAC/I8B,YAAYyR,EAAS3T,EAAQmC,WACjCwR,EAsBJ,SAASqB,EAAelT,EAAM9B,EAAS+B,EAAOuS,GAGjD,YAFc,IAAVvS,IAAoBA,EAAQ,WACR,IAApBuS,IAA8BA,EAAkBC,QAC7CF,EAAcvS,EAAM9B,EAAS+B,EAAOuS,GAMxC,IAAIW,EAAiB,CACxBD,eAAgBA,EAChBX,cAAeA,GAEnB,kBAA2BX,EAC3B,mBAAqB,SAAU5R,EAAMiP,EAAOhP,EAAOyS,EAAOrS,EAAWb,EAAiBgT,GAQlF,YAPwB,IAApBA,IAA8BA,EAAkBC,QAO7CF,EAAcvS,EANP,CACViP,MAAOA,EACPyD,MAAOA,EACPrS,UAAWA,EACXb,gBAAiBA,GAEeS,EAAOuS,IAE/C,oBAAsB,SAAUxS,EAAMiP,EAAO5Q,EAAO4B,EAAOyS,EAAOrS,EAAWb,EAAiBgT,GAS1F,YARwB,IAApBA,IAA8BA,EAAkBC,QAQ7CS,EAAelT,EAPR,CACViP,MAAOA,EACPyD,MAAOA,EACPrU,MAAOA,EACPgC,UAAWA,EACXb,gBAAiBA,GAEgBS,EAAOuS,K,+GCjMzC,SAASY,EAA2BlV,GAIvC,IAAImV,EAAY,GAChBA,EAAU,GAAK,CACX3R,OAAQ,CACJ,CAAC,EAAG,EAAG,UACP,CAAC,SAAU,GAAI,UACf,EAAE,SAAW,UAAW,UACxB,EAAE,UAAY,UAAW,WAE7BoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,KAGfuL,EAAU,GAAK,CACX3R,OAAQ,CACJ,CAAC,EAAG,EAAG,UACP,CAAC,SAAU,EAAG,GACd,CAAC,EAAG,SAAU,GACd,EAAE,SAAU,EAAG,GACf,CAAC,GAAI,SAAU,GACf,CAAC,EAAG,GAAI,WAEZoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,KAGfuL,EAAU,GAAK,CACX3R,OAAQ,CACJ,CAAC,EAAG,EAAG,UACP,CAAC,SAAW,EAAG,UACf,EAAE,SAAW,QAAU,UACvB,EAAE,UAAY,QAAU,UACxB,CAAC,SAAW,QAAU,UACtB,CAAC,UAAY,QAAU,UACvB,EAAE,SAAW,QAAU,UACvB,CAAC,SAAW,EAAG,UACf,CAAC,UAAY,EAAG,UAChB,EAAE,UAAY,QAAU,UACxB,CAAC,SAAW,SAAW,UACvB,CAAC,UAAY,SAAW,UACxB,EAAE,SAAW,SAAW,UACxB,EAAE,SAAW,GAAI,UACjB,EAAE,UAAY,GAAI,UAClB,EAAE,UAAY,SAAW,UACzB,CAAC,SAAW,SAAW,UACvB,CAAC,UAAY,SAAW,UACxB,EAAE,SAAW,GAAI,UACjB,CAAC,EAAG,GAAI,WAEZoG,KAAM,CACF,CAAC,EAAG,EAAG,EAAG,EAAG,GACb,CAAC,EAAG,EAAG,EAAG,EAAG,GACb,CAAC,EAAG,EAAG,EAAG,EAAG,GACb,CAAC,EAAG,EAAG,GAAI,GAAI,GACf,CAAC,EAAG,EAAG,GAAI,GAAI,GACf,CAAC,EAAG,EAAG,GAAI,GAAI,GACf,CAAC,EAAG,GAAI,GAAI,GAAI,GAChB,CAAC,EAAG,EAAG,GAAI,GAAI,IACf,CAAC,EAAG,GAAI,GAAI,GAAI,GAChB,CAAC,GAAI,GAAI,GAAI,GAAI,IACjB,CAAC,GAAI,GAAI,GAAI,GAAI,IACjB,CAAC,GAAI,GAAI,GAAI,GAAI,MAGzBuL,EAAU,GAAK,CACX3R,OAAQ,CACJ,CAAC,EAAG,EAAG,UACP,CAAC,SAAU,EAAG,UACd,CAAC,SAAW,EAAG,UACf,EAAE,SAAW,QAAU,UACvB,EAAE,UAAY,QAAU,UACxB,CAAC,UAAY,EAAG,UAChB,CAAC,SAAW,SAAW,UACvB,CAAC,UAAY,SAAW,UACxB,EAAE,SAAW,GAAI,UACjB,EAAE,SAAU,GAAI,UAChB,EAAE,UAAY,GAAI,UAClB,CAAC,EAAG,GAAI,WAEZoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IACP,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,EAAG,IACP,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,GAAI,IACR,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,GAAI,MAGhBuL,EAAU,GAAK,CACX3R,OAAQ,CACJ,CAAC,EAAG,EAAG,UACP,CAAC,SAAW,EAAG,UACf,EAAE,QAAU,SAAW,UACvB,EAAE,SAAW,SAAW,UACxB,EAAE,SAAW,SAAW,UACxB,CAAC,SAAW,SAAW,UACvB,CAAC,QAAS,SAAW,UACrB,CAAC,UAAY,SAAW,UACxB,EAAE,SAAW,EAAG,UAChB,EAAE,UAAY,GAAK,UACnB,EAAE,SAAW,GAAK,UAClB,EAAE,UAAY,EAAG,UACjB,CAAC,SAAW,GAAI,UAChB,CAAC,UAAY,IAAM,UACnB,CAAC,SAAW,IAAM,UAClB,CAAC,UAAY,GAAI,UACjB,EAAE,SAAW,UAAY,UACzB,EAAE,SAAU,UAAY,UACxB,EAAE,UAAY,UAAY,UAC1B,CAAC,QAAU,UAAY,UACvB,CAAC,UAAY,UAAY,UACzB,CAAC,SAAW,UAAY,UACxB,EAAE,SAAW,GAAI,UACjB,CAAC,EAAG,GAAI,WAEZoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IACP,CAAC,EAAG,GAAI,IACR,CAAC,EAAG,GAAI,IACR,CAAC,GAAI,GAAI,IACT,CAAC,GAAI,GAAI,IACT,CAAC,GAAI,GAAI,IACT,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,GAAI,GACX,CAAC,EAAG,EAAG,GAAI,GACX,CAAC,EAAG,EAAG,GAAI,GACX,CAAC,EAAG,GAAI,GAAI,GACZ,CAAC,EAAG,GAAI,GAAI,GACZ,CAAC,EAAG,EAAG,GAAI,IACX,CAAC,EAAG,GAAI,GAAI,IACZ,CAAC,EAAG,GAAI,GAAI,IACZ,CAAC,EAAG,GAAI,GAAI,IACZ,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,GAAI,MAGrBuL,EAAU,GAAK,CACX3R,OAAQ,CACJ,CAAC,EAAG,EAAG,UACP,CAAC,SAAU,EAAG,UACd,EAAE,SAAW,SAAW,UACxB,CAAC,UAAY,SAAU,UACvB,CAAC,SAAW,UAAY,UACxB,EAAE,UAAY,UAAY,WAE9BoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,KAGlBuL,EAAU,GAAK,CACX3R,OAAQ,CACJ,CAAC,EAAG,EAAG,UACP,CAAC,SAAU,EAAG,UACd,EAAE,SAAW,SAAW,UACxB,EAAE,UAAY,SAAW,UACzB,CAAC,SAAW,UAAY,WACxB,CAAC,UAAY,UAAY,UACzB,EAAE,SAAU,UAAY,WACxB,EAAE,UAAY,UAAW,UACzB,CAAC,SAAW,UAAY,UACxB,EAAE,UAAY,SAAW,WAE7BoG,KAAM,CACF,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,EAAG,GACb,CAAC,EAAG,EAAG,EAAG,EAAG,KAGrBuL,EAAU,GAAK,CACX3R,OAAQ,CACJ,CAAC,EAAG,EAAG,UACP,CAAC,SAAW,EAAG,UACf,EAAE,SAAW,SAAW,UACxB,EAAE,UAAY,SAAW,UACzB,CAAC,SAAW,SAAW,UACvB,CAAC,UAAW,UAAY,UACxB,EAAE,SAAU,SAAW,UACvB,EAAE,UAAY,UAAY,UAC1B,CAAC,SAAW,UAAY,UACxB,CAAC,UAAY,UAAY,UACzB,EAAE,SAAW,GAAI,UACjB,CAAC,EAAG,GAAI,WAEZoG,KAAM,CACF,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,GAAI,GACX,CAAC,EAAG,EAAG,GAAI,GACX,CAAC,EAAG,GAAI,GAAI,GACZ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAChB,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,KAG1BuL,EAAU,GAAK,CACX3R,OAAQ,CACJ,EAAE,QAAU,QAAU,SACtB,EAAE,SAAW,QAAU,SACvB,EAAE,SAAW,QAAU,SACvB,CAAC,QAAU,QAAU,SACrB,CAAC,SAAW,QAAU,UAE1BoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,EAAG,KAGlBuL,EAAU,GAAK,CACX3R,OAAQ,CACJ,EAAE,SAAW,QAAU,QACvB,EAAE,QAAU,QAAU,QACtB,EAAE,QAAU,SAAW,SACvB,EAAE,QAAU,SAAU,SACtB,CAAC,QAAU,SAAW,SACtB,CAAC,SAAW,SAAW,UAE3BoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,EAAG,EAAG,KAGrBuL,EAAU,IAAM,CACZ3R,OAAQ,CACJ,EAAE,QAAU,QAAU,SACtB,EAAE,SAAW,QAAU,SACvB,EAAE,QAAU,OAAS,SACrB,CAAC,SAAW,MAAQ,SACpB,CAAC,QAAU,QAAU,UAEzBoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,KAGfuL,EAAU,IAAM,CACZ3R,OAAQ,CACJ,EAAE,SAAU,SAAW,SACvB,EAAE,SAAW,QAAU,SACvB,EAAE,SAAW,SAAW,SACxB,CAAC,QAAU,SAAW,SACtB,CAAC,QAAU,QAAU,SACrB,CAAC,SAAW,QAAU,SACtB,CAAC,SAAU,SAAW,UAE1BoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,KAGfuL,EAAU,IAAM,CACZ3R,OAAQ,CACJ,EAAE,QAAU,SAAW,SACvB,EAAE,QAAU,QAAU,SACtB,EAAE,MAAQ,SAAU,GACpB,EAAE,SAAW,SAAW,SACxB,EAAE,SAAW,QAAU,SACvB,CAAC,QAAU,SAAW,SACtB,CAAC,QAAU,QAAU,SACrB,CAAC,OAAS,SAAU,GACpB,CAAC,SAAW,SAAW,SACvB,CAAC,SAAW,QAAU,UAE1BoG,KAAM,CACF,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,KAGlBuL,EAAU,IAAM,CACZ3R,OAAQ,CACJ,EAAE,QAAU,SAAW,SACvB,EAAE,QAAU,QAAU,SACtB,EAAE,SAAW,SAAW,SACxB,EAAE,QAAU,QAAU,GACtB,EAAE,SAAW,QAAU,SACvB,EAAE,QAAU,SAAW,SACvB,CAAC,SAAW,SAAW,SACvB,CAAC,QAAU,QAAU,SACrB,CAAC,SAAW,QAAU,GACtB,CAAC,QAAU,SAAW,SACtB,CAAC,SAAW,QAAU,SACtB,CAAC,SAAW,SAAW,UAE3BoG,KAAM,CACF,CAAC,GAAI,GAAI,GACT,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,GAAI,GAAI,EAAG,GACZ,CAAC,GAAI,EAAG,EAAG,GACX,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,GAAI,EAAG,KAGnBuL,EAAU,IAAM,CACZ3R,OAAQ,CACJ,EAAE,OAAS,SAAW,SACtB,EAAE,SAAW,SAAW,SACxB,EAAE,QAAU,QAAU,SACtB,EAAE,SAAW,QAAU,SACvB,EAAE,QAAU,SAAW,SACvB,EAAE,SAAW,SAAW,SACxB,EAAE,QAAU,OAAS,QACrB,EAAE,SAAW,SAAW,SACxB,EAAE,QAAU,SAAW,SACvB,EAAE,SAAW,QAAU,SACvB,EAAE,QAAU,QAAU,SACtB,EAAE,SAAW,SAAW,SACxB,CAAC,QAAU,QAAU,SACrB,CAAC,SAAW,SAAW,SACvB,CAAC,OAAS,SAAU,SACpB,CAAC,SAAW,QAAU,SACtB,CAAC,QAAU,QAAU,SACrB,CAAC,SAAW,SAAW,SACvB,CAAC,SAAW,QAAU,SACtB,CAAC,QAAU,OAAS,SACpB,CAAC,QAAU,QAAU,SACrB,CAAC,SAAW,QAAU,SACtB,CAAC,SAAW,SAAW,SACvB,CAAC,QAAU,QAAU,QACrB,CAAC,UAAW,OAAS,UAEzBoG,KAAM,CACF,CAAC,GAAI,GAAI,IACT,CAAC,GAAI,GAAI,IACT,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IACP,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,GAAI,GACX,CAAC,EAAG,GAAI,GAAI,IACZ,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,GAAI,GAAI,EAAG,GACZ,CAAC,GAAI,EAAG,GAAI,IACZ,CAAC,GAAI,GAAI,GAAI,IACb,CAAC,EAAG,GAAI,GAAI,IACZ,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,GAAI,GAAI,EAAG,GACf,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,MAG1C,IAqBI5F,EAAG9jC,EAAGk1C,EAAKx0C,EAAG6E,EAAG8f,EArBjB8vB,EAAOrV,EAAQqV,OAASrV,EAAQqV,KAAO,GAAKrV,EAAQqV,MAAQF,EAAUj0C,QAAU,EAAI8+B,EAAQqV,MAAQ,EACpGt1B,EAAOigB,EAAQjgB,KACfopB,EAAQnJ,EAAQmJ,OAASppB,GAAQ,EACjCqpB,EAAQpJ,EAAQoJ,OAASrpB,GAAQ,EACjCspB,EAAQrJ,EAAQqJ,OAAStpB,GAAQ,EACjC2I,EAAOsX,EAAQkJ,QAAUiM,EAAUE,GACnCC,EAAU5sB,EAAKkhB,KAAK1oC,OACpBqgC,EAASvB,EAAQuB,QAAU,IAAIt6B,MAAMquC,GACrC9T,EAAaxB,EAAQwB,WACrBR,OAAwBja,IAAjBiZ,EAAQgB,MAA4BhB,EAAQgB,KACnDM,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBACjFl7B,EAAY,IAAIa,MAChBZ,EAAU,IAAIY,MACdg5B,EAAU,IAAIh5B,MACdi5B,EAAM,IAAIj5B,MACV3C,EAAS,IAAI2C,MACb1J,EAAQ,EACRg4C,EAAU,EACVC,EAAU,IAAIvuC,MACd8B,EAAI,EACJiyB,EAAI,EAGR,GAAIgG,EACA,IAAKhG,EAAI,EAAGA,EAAIsa,EAASta,IACjBwG,QAAgCza,IAAlBya,EAAWxG,KACzBwG,EAAWxG,GAAK,IAAI,KAAO,EAAG,EAAG,EAAG,IAEpCuG,QAAwBxa,IAAdwa,EAAOvG,KACjBuG,EAAOvG,GAAK,IAAI,KAAQ,EAAG,EAAG,EAAG,IAI7C,GAAKgG,EAYD,IAAKhG,EAAI,EAAGA,EAAIsa,EAASta,IAAK,CAC1B,IAAIya,EAAK/sB,EAAKkhB,KAAK5O,GAAG95B,OAKtB,IAJAk0C,EAAO,EAAI71C,KAAK6J,GAAMqsC,EACtB70C,EAAI,GAAMrB,KAAKk7B,IAAI2a,EAAM,GACzB3vC,EAAI,GAECsD,EAAI,EAAGA,EAAI0sC,EAAI1sC,IAEhB3C,EAAUhB,KAAKsjB,EAAK8a,OAAO9a,EAAKkhB,KAAK5O,GAAGjyB,IAAI,GAAKogC,EAAOzgB,EAAK8a,OAAO9a,EAAKkhB,KAAK5O,GAAGjyB,IAAI,GAAKqgC,EAAO1gB,EAAK8a,OAAO9a,EAAKkhB,KAAK5O,GAAGjyB,IAAI,GAAKsgC,GACnImM,EAAQpwC,KAAK7H,GACbA,IAEAymC,EAAIzC,EAAOvG,GAAGp6B,GAAK2gC,EAAOvG,GAAGt1B,EAAI67B,EAAOvG,GAAGp6B,IAAM,GAAMA,GACvDV,EAAIqhC,EAAOvG,GAAGv1B,GAAK87B,EAAOvG,GAAGnhB,EAAI0nB,EAAOvG,GAAGv1B,IAAMA,EAAI,IACrDy6B,EAAI96B,KAAK4+B,EAAG,8BAAiD,EAAM9jC,EAAIA,GACvEqlB,EAAM3kB,EAAIrB,KAAKsM,IAAIupC,GAAO3vC,EAAIlG,KAAKuM,IAAIspC,GACvC3vC,EAAI7E,EAAIrB,KAAKuM,IAAIspC,GAAO3vC,EAAIlG,KAAKsM,IAAIupC,GACrCx0C,EAAI2kB,EAEAic,GACAl9B,EAAOc,KAAKo8B,EAAWxG,GAAGp+B,EAAG4kC,EAAWxG,GAAGn+B,EAAG2kC,EAAWxG,GAAGl+B,EAAG0kC,EAAWxG,GAAGl3B,GAIrF,IAAKiF,EAAI,EAAGA,EAAI0sC,EAAK,EAAG1sC,IACpB1C,EAAQjB,KAAKowC,EAAQ,EAAID,GAAUC,EAAQzsC,EAAI,EAAIwsC,GAAUC,EAAQzsC,EAAI,EAAIwsC,IAEjFA,GAAWE,MAvCR,CACP,IAAK1sC,EAAI,EAAGA,EAAI2f,EAAK8a,OAAOtiC,OAAQ6H,IAChC3C,EAAUhB,KAAKsjB,EAAK8a,OAAOz6B,GAAG,GAAKogC,EAAOzgB,EAAK8a,OAAOz6B,GAAG,GAAKqgC,EAAO1gB,EAAK8a,OAAOz6B,GAAG,GAAKsgC,GACzFnJ,EAAI96B,KAAK,EAAG,8BAAiD,EAAM,GAEvE,IAAK41B,EAAI,EAAGA,EAAIsa,EAASta,IACrB,IAAKjyB,EAAI,EAAGA,EAAI2f,EAAKkhB,KAAK5O,GAAG95B,OAAS,EAAG6H,IACrC1C,EAAQjB,KAAKsjB,EAAKkhB,KAAK5O,GAAG,GAAItS,EAAKkhB,KAAK5O,GAAGjyB,EAAI,GAAI2f,EAAKkhB,KAAK5O,GAAGjyB,EAAI,IAmChF,mBAA0B3C,EAAWC,EAAS45B,GAC9C,kBAAyBqB,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SACtG,IAAIC,EAAa,IAAI,IAQrB,OAPAA,EAAWv7B,UAAYA,EACvBu7B,EAAWt7B,QAAUA,EACrBs7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACbsB,GAAcR,IACdW,EAAWr9B,OAASA,GAEjBq9B,EAkCJ,SAAS+T,EAAiB5T,EAAM9B,EAAS+B,QAC5B,IAAZ/B,IAAsBA,EAAU,SACtB,IAAV+B,IAAoBA,EAAQ,MAChC,IAAI4T,EAAa,IAAI,KAAK7T,EAAMC,GAKhC,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClEqU,EAAW1T,gCAAkCjC,EAAQsB,gBACpC4T,EAA2BlV,GACjCkC,YAAYyT,EAAY3V,EAAQmC,WACpCwT,EAMJ,IAAIC,EAAoB,CAE3BF,iBAAkBA,GAEtB,qBAA8BR,EAC9B,sBAAwB,SAAUpT,EAAM9B,EAAS+B,GAC7C,OAAO2T,EAAiB5T,EAAM9B,EAAS+B,K,+GC5jBpC,SAAS8T,EAAuB7V,GACnC,IAAIkR,EAAYlR,EAAQkR,UACpBC,EAAanR,EAAQmR,aAAc,EACnC2E,EAAY9V,EAAQ8V,YAAa,EACjC7E,EAAWjR,EAAQiR,WAAY,EAC/B8E,EAAgBx2C,KAAKgI,MAAM2pC,EAAU,GAAGhwC,OAAS,GACjDzD,EAASuiC,EAAQviC,QAAUs4C,EAC/Bt4C,EAASA,EAASs4C,EAAgBA,EAAgBx2C,KAAKgI,MAAM9J,GAC7D,IAWIu4C,EAGAnoC,EACA9E,EACAuD,EAhBAg1B,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBACjF2U,EAAWjW,EAAQE,IACnBgW,EAAelW,EAAQ17B,OACvB8B,EAAY,GACZC,EAAU,GACV45B,EAAU,GACVC,EAAM,GACNiW,EAAK,GACLC,EAAK,GACLC,EAAiB,GACjBC,EAAiB,GAEjBtE,EAAK,GACLR,EAAM,GAKV,GAAIN,EAAUhwC,OAAS,EAAG,CACtB,IAAIq1C,EAAM,GACNC,EAAM,GACV,IAAKztC,EAAI,EAAGA,EAAImoC,EAAU,GAAGhwC,OAASzD,EAAQsL,IAC1CwtC,EAAInxC,KAAK8rC,EAAU,GAAGnoC,IACtBytC,EAAIpxC,KAAK8rC,EAAU,GAAGnoC,EAAItL,IAE9ByzC,EAAY,CAACqF,EAAKC,GAGtB,IAEI3pC,EACAiD,EAGA2mC,EAgCAC,EACAC,EAvCAC,EAAM,EACNC,EAAgBf,EAAY,EAAI,EAMpC,IAHAE,EAAQ9E,EAAU,GAAGhwC,OAGhB2M,EAAI,EAAGA,EAAIqjC,EAAUhwC,OAAQ2M,IAAK,CAOnC,IANAwoC,EAAexoC,GAAK,EACpBsoC,EAAGtoC,GAAK,CAAC,GAGTmoC,EAAQA,GADRlmC,GADAjD,EAAOqkC,EAAUrjC,IACR3M,QACW80C,EAAQlmC,EAC5BxD,EAAI,EACGA,EAAIwD,GACP1J,EAAUhB,KAAKyH,EAAKP,GAAG1L,EAAGiM,EAAKP,GAAG7G,EAAGoH,EAAKP,GAAG5G,GACzC4G,EAAI,IAEJmqC,EADS5pC,EAAKP,GAAGxN,SAAS+N,EAAKP,EAAI,IAAIpL,SACvBm1C,EAAexoC,GAC/BsoC,EAAGtoC,GAAGzI,KAAKqxC,GACXJ,EAAexoC,GAAK4oC,GAExBnqC,IAEAwpC,IAEAxpC,IACAlG,EAAUhB,KAAKyH,EAAK,GAAGjM,EAAGiM,EAAK,GAAGpH,EAAGoH,EAAK,GAAGnH,GAE7C+wC,EADS5pC,EAAKP,GAAGxN,SAAS+N,EAAK,IAAI3L,SACnBm1C,EAAexoC,GAC/BsoC,EAAGtoC,GAAGzI,KAAKqxC,GACXJ,EAAexoC,GAAK4oC,GAExBzE,EAAGnkC,GAAKiC,EAAI+mC,EACZrF,EAAI3jC,GAAK+oC,EACTA,GAAO9mC,EAAI+mC,EAKf,IAmCI7S,EACA9jC,EApCA42C,EAAU,KACVC,EAAU,KACd,IAAKhuC,EAAI,EAAGA,EAAIitC,EAAQa,EAAe9tC,IAAK,CAGxC,IAFAutC,EAAevtC,GAAK,EACpBqtC,EAAGrtC,GAAK,CAAC,GACJ8E,EAAI,EAAGA,EAAIqjC,EAAUhwC,OAAS,EAAG2M,IAClC6oC,EAAQxF,EAAUrjC,GAClB8oC,EAAQzF,EAAUrjC,EAAI,GAClB9E,IAAMitC,GAENc,EAAUJ,EAAM,GAChBK,EAAUJ,EAAM,KAGhBG,EAAUJ,EAAM3tC,GAChBguC,EAAUJ,EAAM5tC,IAGpB0tC,EADSM,EAAQj4C,SAASg4C,GAAS51C,SACnBo1C,EAAevtC,GAC/BqtC,EAAGrtC,GAAG3D,KAAKqxC,GACXH,EAAevtC,GAAK0tC,EAEpBtF,GAAc4F,GAAWD,IACzBJ,EAAQxF,EAAUrjC,GAClB8oC,EAAQzF,EAAU,GACdnoC,IAAMitC,IAENe,EAAUJ,EAAM,IAGpBF,EADSM,EAAQj4C,SAASg4C,GAAS51C,SACnBo1C,EAAevtC,GAC/ButC,EAAevtC,GAAK0tC,GAM5B,GAAIR,EACA,IAAKpoC,EAAI,EAAGA,EAAIooC,EAAS/0C,OAAQ2M,IAC7BqyB,EAAI96B,KAAK6wC,EAASpoC,GAAGjN,EAAG,8BAAiD,EAAMq1C,EAASpoC,GAAGpI,EAAIwwC,EAASpoC,GAAGpI,QAI/G,IAAKoI,EAAI,EAAGA,EAAIqjC,EAAUhwC,OAAQ2M,IAC9B,IAAK9E,EAAI,EAAGA,EAAIitC,EAAQa,EAAe9tC,IACnCi7B,EAAyB,GAArBqS,EAAexoC,GAAYsoC,EAAGtoC,GAAG9E,GAAKstC,EAAexoC,GAAK,EAC9D3N,EAAyB,GAArBo2C,EAAevtC,GAAYqtC,EAAGrtC,GAAG8E,GAAKyoC,EAAevtC,GAAK,EAC1DkoC,EACA/Q,EAAI96B,KAAKlF,EAAG8jC,GAGZ9D,EAAI96B,KAAK4+B,EAAG,8BAAiD,EAAM9jC,EAAIA,GAavF,IANA,IAAI82C,EAAK,EACLC,EAAKjF,EAFTnkC,EAAI,GAEa,EACbyO,EAAK01B,EAAGnkC,EAAI,GAAK,EACjBnP,EAAMu4C,EAAK36B,EAAK26B,EAAK36B,EACrBo1B,EAAOF,EAAI,GAAKA,EAAI,GACpB0F,EAAU/F,EAAaa,EAAG9wC,OAAS8wC,EAAG9wC,OAAS,EAC5C81C,GAAMt4C,GAAOmP,EAAIqpC,GAGpB7wC,EAAQjB,KAAK4xC,EAAIA,EAAKtF,EAAMsF,EAAK,GACjC3wC,EAAQjB,KAAK4xC,EAAKtF,EAAO,EAAGsF,EAAK,EAAGA,EAAKtF,IACzCsF,GAAM,KACKt4C,MAEPmP,IACUmkC,EAAG9wC,OAAS,GAElBwwC,EAAOF,EAAI,GAAKA,EAAI3jC,GACpBopC,EAAKjF,EAAGnkC,GAAK,EACbyO,EAAK01B,EAAG,GAAK,IAGbN,EAAOF,EAAI3jC,EAAI,GAAK2jC,EAAI3jC,GACxBopC,EAAKjF,EAAGnkC,GAAK,EACbyO,EAAK01B,EAAGnkC,EAAI,GAAK,GAErBmpC,EAAKxF,EAAI3jC,GACTnP,EAAMu4C,EAAK36B,EAAK26B,EAAKD,EAAK16B,EAAK06B,GAKvC,GADA,mBAA0B5wC,EAAWC,EAAS45B,GAC1C6V,EAAW,CAEX,IAAIqB,EAAa,EACbC,EAAY,EAChB,IAAKvpC,EAAI,EAAGA,EAAIqjC,EAAUhwC,OAAQ2M,IAC9BspC,EAAsB,EAAT3F,EAAI3jC,GAEbupC,EADAvpC,EAAI,EAAIqjC,EAAUhwC,OACa,GAAlBswC,EAAI3jC,EAAI,GAAK,GAGdoyB,EAAQ/+B,OAAS,EAEjC++B,EAAQkX,GAA2D,IAA5ClX,EAAQkX,GAAclX,EAAQmX,IACrDnX,EAAQkX,EAAa,GAA0D,IAApDlX,EAAQkX,EAAa,GAAKlX,EAAQmX,EAAY,IACzEnX,EAAQkX,EAAa,GAA0D,IAApDlX,EAAQkX,EAAa,GAAKlX,EAAQmX,EAAY,IACzEnX,EAAQmX,GAAanX,EAAQkX,GAC7BlX,EAAQmX,EAAY,GAAKnX,EAAQkX,EAAa,GAC9ClX,EAAQmX,EAAY,GAAKnX,EAAQkX,EAAa,GAItD,kBAAyB7V,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SAEtG,IAAIp9B,EAAS,KACb,GAAI4xC,EAAc,CACd5xC,EAAS,IAAIi4B,aAAmC,EAAtB2Z,EAAah1C,QACvC,IAAK,IAAIyS,EAAI,EAAGA,EAAIuiC,EAAah1C,OAAQyS,IACrCrP,EAAW,EAAJqP,GAASuiC,EAAaviC,GAAG/W,EAChC0H,EAAW,EAAJqP,EAAQ,GAAKuiC,EAAaviC,GAAG9W,EACpCyH,EAAW,EAAJqP,EAAQ,GAAKuiC,EAAaviC,GAAG7W,EACpCwH,EAAW,EAAJqP,EAAQ,GAAKuiC,EAAaviC,GAAG7P,EAI5C,IAAI69B,EAAa,IAAI,IACjB0V,EAAc,IAAI9a,aAAan2B,GAC/BkxC,EAAY,IAAI/a,aAAa0D,GAC7BsX,EAAQ,IAAIhb,aAAa2D,GAW7B,OAVAyB,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYixC,EACvB1V,EAAW1B,QAAUqX,EACrB3V,EAAWzB,IAAMqX,EACbjzC,GACAq9B,EAAWviC,IAAIkF,EAAQ,eAEvBwxC,IACAnU,EAAW6V,KAAOhG,GAEf7P,EAqCJ,SAAS8V,EAAa3V,EAAM9B,EAAS+B,QAC1B,IAAVA,IAAoBA,EAAQ,MAChC,IAAImP,EAAYlR,EAAQkR,UACpBC,EAAanR,EAAQmR,WACrB2E,EAAY9V,EAAQ8V,UACpBxU,EAAkB,gCAAgCtB,EAAQsB,iBAC1D8Q,EAAWpS,EAAQoS,SACnBjQ,EAAYnC,EAAQmC,UACxB,GAAIiQ,EAAU,CAIV,IAAIsF,EAAY,uBAA6BtwC,OAAOC,WAChDswC,EAAY,wBAA8BvwC,OAAOC,WA8BjDjB,EAAYgsC,EAASzL,gBAAgB,kBASzC,GAtCuB,SAAUvgC,GAK7B,IAJA,IAAI4vC,EAAQ9E,EAAU,GAAGhwC,OACrB02C,EAAOxF,EACPrpC,EAAI,EACJ8uC,EAAKD,EAAK3V,kCAAoC,gBAAkB,EAAI,EAC/D6V,EAAK,EAAGA,GAAMD,IAAMC,EACzB,IAAK,IAAIjqC,EAAI,EAAGA,EAAIqjC,EAAUhwC,SAAU2M,EAAG,CACvC,IAAIhB,EAAOqkC,EAAUrjC,GACjBiC,EAAIjD,EAAK3L,OACb80C,EAAQA,EAAQlmC,EAAIkmC,EAAQlmC,EAC5B,IAAK,IAAIxD,EAAI,EAAGA,EAAI0pC,IAAS1pC,EAAG,CAC5B,IAAIyrC,EAAYlrC,EAAKP,GACrBlG,EAAU2C,GAAKgvC,EAAUn3C,EACzBwF,EAAU2C,EAAI,GAAKgvC,EAAUtyC,EAC7BW,EAAU2C,EAAI,GAAKgvC,EAAUryC,EAC7BgyC,EAAUhxC,0BAA0BqxC,EAAUn3C,EAAGm3C,EAAUtyC,EAAGsyC,EAAUryC,GACxEiyC,EAAUhxC,0BAA0BoxC,EAAUn3C,EAAGm3C,EAAUtyC,EAAGsyC,EAAUryC,GACxEqD,GAAK,EAET,GAAI6uC,EAAK5E,sBAAwB4E,EAAK5E,qBAAqB8C,UAAW,CAC9DiC,EAAYlrC,EAAK,GACrBzG,EAAU2C,GAAKgvC,EAAUn3C,EACzBwF,EAAU2C,EAAI,GAAKgvC,EAAUtyC,EAC7BW,EAAU2C,EAAI,GAAKgvC,EAAUryC,EAC7BqD,GAAK,IAMrBivC,CAAiB5xC,GACbgsC,EAAS6F,gBACT7F,EAAS8F,kBAAkBC,YAAYT,EAAWC,EAAWvF,EAASgG,cAGtEhG,EAASiG,kBAAkBX,EAAWC,EAAWvF,EAASgG,cAE9DhG,EAASG,mBAAmB,iBAA2BnsC,GAAW,GAAO,GACrE45B,EAAQ17B,OAAQ,CAEhB,IADA,IAAIA,EAAS8tC,EAASzL,gBAAgB,eAC7BhzB,EAAI,EAAG2kC,EAAa,EAAG3kC,EAAIqsB,EAAQ17B,OAAOpD,OAAQyS,IAAK2kC,GAAc,EAAG,CAC7E,IAAIt0C,EAAQg8B,EAAQ17B,OAAOqP,GAC3BrP,EAAOg0C,GAAct0C,EAAMpH,EAC3B0H,EAAOg0C,EAAa,GAAKt0C,EAAMnH,EAC/ByH,EAAOg0C,EAAa,GAAKt0C,EAAMlH,EAC/BwH,EAAOg0C,EAAa,GAAKt0C,EAAMF,EAEnCsuC,EAASG,mBAAmB,cAAwBjuC,GAAQ,GAAO,GAEvE,GAAI07B,EAAQE,IAAK,CAEb,IADA,IAAIA,EAAMkS,EAASzL,gBAAgB,YAC1B59B,EAAI,EAAGA,EAAIi3B,EAAQE,IAAIh/B,OAAQ6H,IACpCm3B,EAAQ,EAAJn3B,GAASi3B,EAAQE,IAAIn3B,GAAGnI,EAC5Bs/B,EAAQ,EAAJn3B,EAAQ,GAAK,8BAAiD,EAAMi3B,EAAQE,IAAIn3B,GAAGtD,EAAIu6B,EAAQE,IAAIn3B,GAAGtD,EAE9G2sC,EAASG,mBAAmB,WAAqBrS,GAAK,GAAO,GAEjE,IAAKkS,EAASmG,kBAAoBnG,EAASoG,mBAAoB,CAC3D,IAAInyC,EAAU+rC,EAAS1L,aACnBzG,EAAUmS,EAASzL,gBAAgB,gBACnC8R,EAASrG,EAASoG,mBAAqBpG,EAASsG,yBAA2B,KAE/E,GADA,mBAA0BtyC,EAAWC,EAAS45B,EAASwY,GACnDrG,EAASY,sBAAwBZ,EAASY,qBAAqB8C,UAG/D,IAFA,IAAIqB,EAAa,EACbC,EAAY,EACPvpC,EAAI,EAAGA,EAAIqjC,EAAUhwC,OAAQ2M,IAClCspC,EAAoD,EAAvC/E,EAASY,qBAAqBxB,IAAI3jC,GAE3CupC,EADAvpC,EAAI,EAAIqjC,EAAUhwC,OAC2C,GAAhDkxC,EAASY,qBAAqBxB,IAAI3jC,EAAI,GAAK,GAG5CoyB,EAAQ/+B,OAAS,EAEjC++B,EAAQkX,GAA2D,IAA5ClX,EAAQkX,GAAclX,EAAQmX,IACrDnX,EAAQkX,EAAa,GAA0D,IAApDlX,EAAQkX,EAAa,GAAKlX,EAAQmX,EAAY,IACzEnX,EAAQkX,EAAa,GAA0D,IAApDlX,EAAQkX,EAAa,GAAKlX,EAAQmX,EAAY,IACzEnX,EAAQmX,GAAanX,EAAQkX,GAC7BlX,EAAQmX,EAAY,GAAKnX,EAAQkX,EAAa,GAC9ClX,EAAQmX,EAAY,GAAKnX,EAAQkX,EAAa,GAGjD/E,EAASmG,kBACVnG,EAASG,mBAAmB,eAAyBtS,GAAS,GAAO,GAG7E,OAAOmS,EAIP,IAAIuG,EAAS,IAAI,KAAK7W,EAAMC,GAC5B4W,EAAO1W,gCAAkCX,EACzCqX,EAAO3F,qBAAuB,IAAI,KAClC,IAAIrR,EAAakU,EAAuB7V,GAOxC,OANI8V,IACA6C,EAAO3F,qBAAqBxB,IAAM7P,EAAW6V,MAEjDmB,EAAO3F,qBAAqB8C,UAAYA,EACxC6C,EAAO3F,qBAAqB7B,WAAaA,EACzCxP,EAAWO,YAAYyW,EAAQxW,GACxBwW,EAOR,IAAIC,EAAgB,CAEvBnB,aAAcA,GAElB,iBAA0B5B,EAC1B,kBAAoB,SAAU/T,EAAMoP,EAAWC,EAAY2E,EAAWr4C,EAAQskC,EAAOI,EAAWb,EAAiB8Q,GAG7G,YAFmB,IAAfjB,IAAyBA,GAAa,QACxB,IAAdhP,IAAwBA,GAAY,GACjCsV,EAAa3V,EAAM,CACtBoP,UAAWA,EACXC,WAAYA,EACZ2E,UAAWA,EACXr4C,OAAQA,EACR0kC,UAAWA,EACXb,gBAAiBA,EACjB8Q,SAAUA,GACXrQ,K,oGC1XA,SAAS8W,EAAa/W,EAAM9B,EAAS+B,QAC1B,IAAVA,IAAoBA,EAAQ,MAChC,IAAIl1B,EAAOmzB,EAAQnzB,KACfkkC,EAAQ/Q,EAAQ+Q,MAChBzyC,EAAQ0hC,EAAQ1hC,OAAS,EACzBmoB,EAAWuZ,EAAQvZ,UAAY,EAC/B2e,EAAsB,IAAhBpF,EAAQoF,IAAY,EAAIpF,EAAQoF,KAAO,YAC7CjD,EAAYnC,EAAQmC,UACpBb,EAAkB,gCAAgCtB,EAAQsB,iBAC1D8Q,EAAWpS,EAAQoS,UAAY,KAC/BnB,EAAWjR,EAAQiR,WAAY,EAC/B6H,EAAa9Y,EAAQ8Y,aAAc,EAEvC,OAAOC,EAAqBjX,EAAMiP,EAAOlkC,EAAMvO,EAAOmoB,EAAU,KAAM,KADtDuZ,EAAQ8V,YAAa,EACkDgD,EAAY1T,GAAK,EAAOrD,IAAOI,EAA0Bb,EAAiB8Q,EAAUnB,EAAUjR,EAAQyB,UAAY,KAAMzB,EAAQ0B,SAAW,MA6C/N,SAASsX,EAAmBlX,EAAM9B,EAAS+B,QAChC,IAAVA,IAAoBA,EAAQ,MAChC,IAAIl1B,EAAOmzB,EAAQnzB,KAiBnB,OAAOksC,EAAqBjX,EAhBhB9B,EAAQ+Q,MAgBqBlkC,EAAM,KAAM,KAfjCmzB,EAAQiZ,eACxB,WACI,OAAO,GAEQjZ,EAAQkZ,kBAC3B,WACI,OAAO,GAEQlZ,EAAQ8V,WAAa9V,EAAQmZ,mBAAoB,EAClDnZ,EAAQ8Y,YAAc9Y,EAAQoZ,kBAAmB,EAC7C,IAAhBpZ,EAAQoF,IAAY,EAAIpF,EAAQoF,KAAO,aAKmF,EAAMrD,IAJ1H/B,EAAQmC,UACF,gCAAgCnC,EAAQsB,iBAC/CtB,EAAQoS,UAEiL,KADzLpS,EAAQiR,WAAY,EACqLjR,EAAQyB,UAAY,KAAMzB,EAAQ0B,SAAW,MAEzQ,SAASqX,EAAqBjX,EAAMiP,EAAO37B,EAAO9W,EAAOmoB,EAAUwyB,EAAeI,EAAgBC,EAAMC,EAAMnU,EAAK8D,EAAQnH,EAAOyX,EAAQC,EAAMrH,EAAUnB,EAAUxP,EAAUC,GAE1K,IAoEIgY,EACAxI,EArEAyI,EAAqB,SAAU5I,EAAO37B,EAAOskC,EAAQE,EAAYt7C,EAAOmoB,EAAUwyB,EAAeI,EAAgBjU,EAAK8D,GAgBtH,IAfA,IAAI2Q,EAAWH,EAAOxrC,cAClB+xB,EAAUyZ,EAAOvrC,aACjB2rC,EAAYJ,EAAOtrC,eACnB2rC,EAAYL,EAAOrrC,eACnBzD,EAAQ,EAORovC,EAAS9Q,GAAUmQ,EAAiBA,EAHnB,WACjB,OAAoB,OAAb5yB,EAAoBA,EAAW,GAGtCwzB,EAAM/Q,GAAU+P,EAAgBA,EAPlB,WACd,OAAiB,OAAV36C,EAAiBA,EAAQ,GAOhCf,EAAQ6nC,IAAQ,aAAeA,IAAQ,aAAe,EAAI,EAC1D8U,EAAiB,eACZnxC,EAAI,EAAGA,EAAIqM,EAAMlU,OAAQ6H,IAAK,CAInC,IAHA,IAAIoxC,EAAY,IAAIlzC,MAChBq+B,EAAY0U,EAAOjxC,EAAGgxC,EAAUhxC,IAChCqxC,EAAaH,EAAIlxC,EAAGgxC,EAAUhxC,IACzB8E,EAAI,EAAGA,EAAIkjC,EAAM7vC,OAAQ2M,IAAK,CACnC,uBAAyBgsC,EAAS9wC,GAAI6B,EAAOsvC,GAC7C,IAAIG,EAASR,EAAS9wC,GAAGzK,MAAMyyC,EAAMljC,GAAGnI,GAAG9G,IAAIqhC,EAAQl3B,GAAGzK,MAAMyyC,EAAMljC,GAAGjN,IAAIhC,IAAIk7C,EAAU/wC,GAAGzK,MAAMyyC,EAAMljC,GAAGpI,IACzGqrC,EAAUqJ,EAAUtsC,GAAKssC,EAAUtsC,GAAK,WAC5C,8BAAkCwsC,EAAQH,EAAgBpJ,GAC1DA,EAAQv/B,aAAa6oC,GAAYr2C,WAAWqR,EAAMrM,IAClDoxC,EAAUtsC,GAAKijC,EAEnB8I,EAAWr8C,GAAS48C,EACpBvvC,GAAS06B,EACT/nC,IAGJ,IAAI+8C,EAAU,SAAUH,GACpB,IAEIpxC,EAFAwxC,EAAWtzC,QACXuzC,EAAa,WAEjB,IAAKzxC,EAAI,EAAGA,EAAIoxC,EAAUj5C,OAAQ6H,IAC9ByxC,EAAWz2C,WAAWo2C,EAAUpxC,IAGpC,IADAyxC,EAAWjpC,aAAa,EAAM4oC,EAAUj5C,QACnC6H,EAAI,EAAGA,EAAIoxC,EAAUj5C,OAAQ6H,IAC9BwxC,EAASn1C,KAAKo1C,GAElB,OAAOD,GAEX,OAAQnV,GACJ,KAAK,YACD,MACJ,KAAK,eACDwU,EAAW,GAAKU,EAAQV,EAAW,IACnCA,EAAW,GAAKA,EAAW,GAC3B,MACJ,KAAK,aACDA,EAAWr8C,GAASq8C,EAAWr8C,EAAQ,GACvCq8C,EAAWr8C,EAAQ,GAAK+8C,EAAQV,EAAWr8C,EAAQ,IACnD,MACJ,KAAK,aACDq8C,EAAW,GAAKU,EAAQV,EAAW,IACnCA,EAAW,GAAKA,EAAW,GAC3BA,EAAWr8C,GAASq8C,EAAWr8C,EAAQ,GACvCq8C,EAAWr8C,EAAQ,GAAK+8C,EAAQV,EAAWr8C,EAAQ,IAK3D,OAAOq8C,GAIX,GAAIxH,EAAU,CAEV,IAAIqI,EAAUrI,EAASY,qBAIvB,OAHA0G,EAASe,EAAQf,OAAO7pC,OAAOuF,GAC/B87B,EAAYyI,EAAmB5I,EAAO37B,EAAOqlC,EAAQf,OAAQe,EAAQvJ,UAAW5yC,EAAOmoB,EAAUwyB,EAAeI,EAAgBoB,EAAQrV,IAAK8D,GAC7IkJ,GAAW,QAAa,GAAI,CAAElB,UAAWA,EAAWC,YAAY,EAAO2E,WAAW,EAAOr4C,OAAQ,EAAG0kC,WAAW,EAAOb,gBAAiB,EAAG8Q,SAAUA,GAAYrQ,QAAShb,GAO7KmqB,EAAYyI,EAAmB5I,EAAO37B,EAHtCskC,EAAS,IAAI,KAAOtkC,GACA,IAAInO,MAE4C3I,EAAOmoB,EAAUwyB,EAAeI,EADpGjU,EAAMA,EAAM,GAAKA,EAAM,EAAI,EAAIA,EAC0F8D,GACzH,IAAIwR,GAAkB,QAAa5Y,EAAM,CACrCoP,UAAWA,EACXC,WAAYmI,EACZxD,UAAWyD,EACXpX,UAAWqX,EACXlY,gBAAiBmY,EACjBxI,SAAUA,EACVxP,SAAUA,QAAY1a,EACtB2a,QAASA,QAAW3a,GACrBgb,GAIH,OAHA2Y,EAAgB1H,qBAAqB9B,UAAYA,EACjDwJ,EAAgB1H,qBAAqB0G,OAASA,EAC9CgB,EAAgB1H,qBAAqB5N,IAAMA,EACpCsV,EAMJ,IAAIC,EAAe,CAEtB9B,aAAcA,EAEdG,mBAAoBA,GAExB,kBAAoB,SAAUlX,EAAMiP,EAAOlkC,EAAMvO,EAAOmoB,EAAU2e,EAAKrD,EAAOI,EAAWb,EAAiB8Q,GAYtG,YAXc,IAAVrQ,IAAoBA,EAAQ,MAWzB8W,EAAa/W,EAVN,CACViP,MAAOA,EACPlkC,KAAMA,EACNvO,MAAOA,EACPmoB,SAAUA,EACV2e,IAAa,IAARA,EAAY,EAAIA,GAAO,YAC5B9D,gBAAiBA,EACjB8Q,SAAUA,EACVjQ,UAAWA,GAEoBJ,IAEvC,wBAA0B,SAAUD,EAAMiP,EAAOlkC,EAAMosC,EAAeC,EAAkBC,EAAkBC,EAAiBhU,EAAKrD,EAAOI,EAAWb,EAAiB8Q,GAa/J,OAAO4G,EAAmBlX,EAZZ,CACViP,MAAOA,EACPlkC,KAAMA,EACNosC,cAAeA,EACfC,iBAAkBA,EAClBC,iBAAkBA,EAClBC,gBAAiBA,EACjBhU,IAAa,IAARA,EAAY,EAAIA,GAAO,YAC5B9D,gBAAiBA,EACjB8Q,SAAUA,EACVjQ,UAAWA,GAE0BJ,K,oGCjOtC,SAAS6Y,EAAuB5a,GAgBnC,IAfA,IAAI4O,EAAW5O,EAAQ4O,UAAY,GAC/BiM,EAAY7a,EAAQ6a,WAAa7a,EAAQgF,UAAY,EACrD8V,EAAY9a,EAAQ8a,WAAa9a,EAAQgF,UAAY,EACrD+V,EAAY/a,EAAQ+a,WAAa/a,EAAQgF,UAAY,EACrDt5B,EAAMs0B,EAAQt0B,MAAQs0B,EAAQt0B,KAAO,GAAKs0B,EAAQt0B,IAAM,GAAK,EAAMs0B,EAAQt0B,KAAO,EAClF4D,EAAQ0wB,EAAQ1wB,OAAS0wB,EAAQ1wB,OAAS,EAAI,EAAM0wB,EAAQ1wB,OAAS,EACrEgyB,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBACjF0Z,IAA0Bhb,EAAQgb,sBAClC5wC,EAAS,IAAI,IAAQywC,EAAY,EAAGC,EAAY,EAAGC,EAAY,GAC/DE,EAAsB,EAAIrM,EAC1BsM,EAAsB,EAAID,EAC1B50C,EAAU,GACVD,EAAY,GACZ65B,EAAU,GACVC,EAAM,GACDib,EAAgB,EAAGA,GAAiBF,EAAqBE,IAAiB,CAG/E,IAFA,IAAIC,EAAcD,EAAgBF,EAC9BI,EAASD,EAAc77C,KAAK6J,GAAKkG,EAC5BgsC,EAAgB,EAAGA,GAAiBJ,EAAqBI,IAAiB,CAC/E,IAAIC,EAAcD,EAAgBJ,EAC9BM,EAASD,EAAch8C,KAAK6J,GAAK,EAAIsC,EACrC+vC,EAAY,gBAAkBJ,GAC9BK,EAAY,eAAiBF,GAC7BG,EAAY,yBAA6B,SAAcF,GACvDG,EAAW,yBAA6BD,EAAWD,GACnDlY,EAASoY,EAAS59C,SAASoM,GAC3B5E,EAASo2C,EAASthC,OAAOlQ,GAAQxE,YACrCQ,EAAUhB,KAAKo+B,EAAO5iC,EAAG4iC,EAAO/9B,EAAG+9B,EAAO99B,GAC1Cu6B,EAAQ76B,KAAKI,EAAO5E,EAAG4E,EAAOC,EAAGD,EAAOE,GACxCw6B,EAAI96B,KAAKm2C,EAAa,8BAAiD,EAAMH,EAAcA,GAE/F,GAAID,EAAgB,EAEhB,IADA,IAAIU,EAAgBz1C,EAAUlF,OAAS,EAC9B46C,EAAaD,EAAgB,GAAKX,EAAsB,GAAIY,EAAaZ,EAAsB,EAAIW,EAAeC,IACnHd,GACIG,EAAgB,IAChB90C,EAAQjB,KAAK02C,GACbz1C,EAAQjB,KAAK02C,EAAa,GAC1Bz1C,EAAQjB,KAAK02C,EAAaZ,EAAsB,KAEhDC,EAAgBF,GAAuB3rC,EAAQ,KAC/CjJ,EAAQjB,KAAK02C,EAAaZ,EAAsB,GAChD70C,EAAQjB,KAAK02C,EAAa,GAC1Bz1C,EAAQjB,KAAK02C,EAAaZ,EAAsB,MAIpD70C,EAAQjB,KAAK02C,GACbz1C,EAAQjB,KAAK02C,EAAa,GAC1Bz1C,EAAQjB,KAAK02C,EAAaZ,EAAsB,GAChD70C,EAAQjB,KAAK02C,EAAaZ,EAAsB,GAChD70C,EAAQjB,KAAK02C,EAAa,GAC1Bz1C,EAAQjB,KAAK02C,EAAaZ,EAAsB,IAMhE,kBAAyB5Z,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SAEtG,IAAIC,EAAa,IAAI,IAKrB,OAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EA6BJ,SAASoa,EAAaja,EAAM9B,EAAS+B,QACxB,IAAZ/B,IAAsBA,EAAU,SACtB,IAAV+B,IAAoBA,EAAQ,MAChC,IAAI4O,EAAS,IAAI,KAAK7O,EAAMC,GAK5B,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClEqP,EAAO1O,gCAAkCjC,EAAQsB,gBAChCsZ,EAAuB5a,GAC7BkC,YAAYyO,EAAQ3Q,EAAQmC,WAChCwO,EAMJ,IAAIqL,EAAgB,CAEvBD,aAAcA,GAElB,iBAA0BnB,EAC1B,kBAAoB,SAAU9Y,EAAM8M,EAAU5J,EAAUjD,EAAOI,EAAWb,GAStE,OAAOya,EAAaja,EARN,CACV8M,SAAUA,EACViM,UAAW7V,EACX8V,UAAW9V,EACX+V,UAAW/V,EACX1D,gBAAiBA,EACjBa,UAAWA,GAEoBJ,K,0HCnHhC,SAASka,EAAyBjc,GAcrC,IAbA,IACIuB,EAASvB,EAAQuB,QAAU,IAAIt6B,MAAM,GACrCu6B,EAAaxB,EAAQwB,WACrB0a,EAAWlc,EAAQmc,SAAW,aAC9B3iC,EAAQwmB,EAAQxmB,OAASwmB,EAAQjgB,MAAQ,EACzCtG,EAASumB,EAAQvmB,QAAUumB,EAAQjgB,MAAQ,EAC3CogB,EAAQH,EAAQG,OAASH,EAAQjgB,MAAQ,EACzCq8B,EAAYpc,EAAQoc,WAAapc,EAAQ2L,UAAY,EACrD0Q,EAAarc,EAAQqc,YAAcrc,EAAQ2L,UAAY,EACvD2Q,EAAStc,EAAQuc,iBAAmB,EACpCC,EAASxc,EAAQyc,eAAiB,EAClCnb,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBAE5EtG,EAAI,EAAGA,EAbF,EAaeA,SACPjU,IAAdwa,EAAOvG,KACPuG,EAAOvG,GAAK,IAAI,KAAQ,EAAG,EAAG,EAAG,IAEjCwG,QAAgCza,IAAlBya,EAAWxG,KACzBwG,EAAWxG,GAAK,IAAI,KAAO,EAAG,EAAG,EAAG,IAG5C,IAAIoY,EAAY55B,EAAQ,EACpB8pB,EAAa7pB,EAAS,EACtBijC,EAAYvc,EAAQ,EACpBwc,EAAiB,GACrB,IAAS3hB,EAAI,EAAGA,EAAI,EAAGA,IAEnB2hB,EAAe3hB,IAAK,QAA2B,CAC3CmhB,QAASD,EACTE,UAAWA,EACXC,WAAYA,EACZ7iC,MAAOA,EACPC,OAAQA,EACRgjC,cAAeD,EACfD,gBAAiBD,EACjBhb,gBAAiBA,IAGzB,IAAStG,EAAI,EAAGA,EAAI,EAAGA,IAEnB2hB,EAAe3hB,IAAK,QAA2B,CAC3CmhB,QAASD,EACTE,UAAWA,EACXC,WAAYA,EACZ7iC,MAAO2mB,EACP1mB,OAAQA,EACRgjC,cAAeD,EACfD,gBAAiBD,EACjBhb,gBAAiBA,IAGzB,IAAIsb,EAAaJ,EACbA,IAAW,YACXI,EAAa,SAERJ,IAAW,WAChBI,EAAa,aAEjB,IAAS5hB,EAAI,EAAGA,EAAI,EAAGA,IAEnB2hB,EAAe3hB,IAAK,QAA2B,CAC3CmhB,QAASD,EACTE,UAAWA,EACXC,WAAYA,EACZ7iC,MAAOA,EACPC,OAAQ0mB,EACRsc,cAAeG,EACfL,gBAAiBD,EACjBhb,gBAAiBA,IAGzB,IAAIl7B,EAAY,GACZ65B,EAAU,GACVC,EAAM,GACN75B,EAAU,GACV/B,EAAS,GACTu4C,EAAgB,GAChBC,EAAc,GACdC,EAAY,GACZC,EAAK,EACLC,EAAK,EACT,IAASjiB,EAAI,EAAGA,EAjFF,EAiFeA,IAAK,CAC9B,IAAI1f,EAAMqhC,EAAe3hB,GAAG50B,UAAUlF,OACtC27C,EAAc7hB,GAAK,GACnB8hB,EAAY9hB,GAAK,GACjB,IAAK,IAAIntB,EAAI,EAAGA,EAAIyN,EAAM,EAAGzN,IACzBgvC,EAAc7hB,GAAG51B,KAAK,IAAI,IAAQu3C,EAAe3hB,GAAG50B,UAAU,EAAIyH,GAAI8uC,EAAe3hB,GAAG50B,UAAU,EAAIyH,EAAI,GAAI8uC,EAAe3hB,GAAG50B,UAAU,EAAIyH,EAAI,KAClJivC,EAAY9hB,GAAG51B,KAAK,IAAI,IAAQu3C,EAAe3hB,GAAGiF,QAAQ,EAAIpyB,GAAI8uC,EAAe3hB,GAAGiF,QAAQ,EAAIpyB,EAAI,GAAI8uC,EAAe3hB,GAAGiF,QAAQ,EAAIpyB,EAAI,KAG9ImvC,EAAKL,EAAe3hB,GAAGkF,IAAIh/B,OAC3B67C,EAAU/hB,GAAK,GACf,IAAK,IAAIjyB,EAAI,EAAGA,EAAIi0C,EAAIj0C,GAAK,EACzBg0C,EAAU/hB,GAAGjyB,GAAKw4B,EAAOvG,GAAGp6B,GAAK2gC,EAAOvG,GAAGt1B,EAAI67B,EAAOvG,GAAGp6B,GAAK+7C,EAAe3hB,GAAGkF,IAAIn3B,GACpFg0C,EAAU/hB,GAAGjyB,EAAI,GAAKw4B,EAAOvG,GAAGv1B,GAAK87B,EAAOvG,GAAGnhB,EAAI0nB,EAAOvG,GAAGv1B,GAAKk3C,EAAe3hB,GAAGkF,IAAIn3B,EAAI,GACxF,gCACAg0C,EAAU/hB,GAAGjyB,EAAI,GAAK,EAAMg0C,EAAU/hB,GAAGjyB,EAAI,IAMrD,GAHAm3B,EAAMA,EAAIxmB,OAAOqjC,EAAU/hB,IAC3B30B,EAAUA,EAAQqT,OAAOijC,EAAe3hB,GAAG30B,QAAQ62C,KAAI,SAAUt8C,GAAK,OAAOA,EAAIq8C,MACjFA,GAAMJ,EAAc7hB,GAAG95B,OACnBsgC,EACA,IAAK,IAAI7tB,EAAI,EAAGA,EAAI,EAAGA,IACnBrP,EAAOc,KAAKo8B,EAAWxG,GAAGp+B,EAAG4kC,EAAWxG,GAAGn+B,EAAG2kC,EAAWxG,GAAGl+B,EAAG0kC,EAAWxG,GAAGl3B,GAIzF,IAAIq5C,EAAO,IAAI,IAAQ,EAAG,EAAGT,GACzBU,EAAQ,eAAiB79C,KAAK6J,IAClChD,EAAYy2C,EAAc,GACrBK,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOD,GAAOx+C,IAAIu+C,MACxED,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,IAC/FnB,EAAU6c,EAAY,GACjBI,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOD,MAC7DF,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,IAC/Fh7B,EAAYA,EAAUsT,OAAOmjC,EAAc,GACtCK,KAAI,SAAUG,GAAS,OAAOA,EAAMv+C,SAASq+C,MAC7CD,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAC/FnB,EAAUA,EAAQvmB,OAAOojC,EAAY,GAAGI,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MAAOw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAChM,IAAIhtB,EAAO,IAAI,IAAQg/B,EAAW,EAAG,GACjCkK,EAAQ,gBAAkB/9C,KAAK6J,GAAK,GACxChD,EAAYA,EAAUsT,OAAOmjC,EAAc,GACtCK,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOC,GAAO1+C,IAAIwV,MACxE8oC,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAC/FnB,EAAUA,EAAQvmB,OAAOojC,EAAY,GAChCI,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOC,MAC7DJ,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAC/F,IAAImc,EAAQ,eAAiBh+C,KAAK6J,GAAK,GACvChD,EAAYA,EAAUsT,OAAOmjC,EAAc,GACtCK,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOE,GAAOz+C,SAASsV,MAC7E8oC,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAC/FnB,EAAUA,EAAQvmB,OAAOojC,EAAY,GAChCI,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOE,MAC7DL,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAC/F,IAAIoc,EAAO,IAAI,IAAQ,EAAGla,EAAY,GAClCma,EAAQ,eAAiBl+C,KAAK6J,GAAK,GACvChD,EAAYA,EAAUsT,OAAOmjC,EAAc,GACtCK,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOI,GAAO7+C,IAAI4+C,MACxEN,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAC/FnB,EAAUA,EAAQvmB,OAAOojC,EAAY,GAChCI,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOI,MAC7DP,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAC/F,IAAIsc,EAAQ,gBAAkBn+C,KAAK6J,GAAK,GACxChD,EAAYA,EAAUsT,OAAOmjC,EAAc,GACtCK,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOK,GAAO5+C,SAAS0+C,MAC7EN,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAC/FnB,EAAUA,EAAQvmB,OAAOojC,EAAY,GAChCI,KAAI,SAAUG,GAAS,OAAO,oBAAwBA,EAAOK,MAC7DR,KAAI,SAAUG,GAAS,MAAO,CAACA,EAAMz8C,EAAGy8C,EAAM53C,EAAG43C,EAAM33C,MACvDw7B,QAAO,SAAUC,EAAaC,GAAgB,OAAOD,EAAYznB,OAAO0nB,KAAkB,KAE/F,kBAAyBE,EAAiBl7B,EAAWC,EAAS45B,EAASC,GAEvE,IAAIyB,EAAa,IAAI,IAKrB,GAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACbsB,EAAY,CACZ,IAAII,EAAcN,IAAoB,eAAwBh9B,EAAOoV,OAAOpV,GAAUA,EACtFq9B,EAAWr9B,OAASs9B,EAExB,OAAOD,EAoCJ,SAASgc,EAAe7b,EAAM9B,EAAS+B,QAC5B,IAAVA,IAAoBA,EAAQ,MAChC,IAAIC,EAAM,IAAI,KAAKF,EAAMC,GAKzB,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClEU,EAAIC,gCAAkCjC,EAAQsB,gBAC7B2a,EAAyBjc,GAC/BkC,YAAYF,EAAKhC,EAAQmC,WAC7BH,EAMJ,IAAI4b,EAAkB,CAEzBD,eAAgBA,GAEpB,mBAA4B1B,G,8ECzOrB,SAAS4B,EAA2B7d,GACvC,IAAIkc,EAAWlc,EAAQmc,SAAW,aAC9BC,EAAYpc,EAAQoc,WAAapc,EAAQ2L,UAAY,EACrD0Q,EAAarc,EAAQqc,YAAcrc,EAAQ2L,UAAY,EACvD2Q,EAAStc,EAAQuc,iBAAmB,EACpCC,EAASxc,EAAQyc,eAAiB,EAClCjjC,EAAQwmB,EAAQxmB,OAASwmB,EAAQjgB,MAAQ,EACzC+9B,EAASv+C,KAAKgI,MAAMiS,EAAQ4iC,GAC5B2B,EAAUvkC,EAAQskC,EAAS1B,EAC3B3iC,EAASumB,EAAQvmB,QAAUumB,EAAQjgB,MAAQ,EAC3Ci+B,EAASz+C,KAAKgI,MAAMkS,EAAS4iC,GAC7B4B,EAAUxkC,EAASukC,EAAS3B,EAC5BjJ,EAAagJ,EAAY0B,EAAU,EACnCxa,EAAc+Y,EAAa2B,EAAU,EACrCE,EAAU,EACVC,EAAU,EACVC,EAAS,EACTC,EAAS,EACT9yC,EAAO,EACPC,EAAO,EAEX,GAAIuyC,EAAU,GAAKE,EAAU,EAAG,CAK5B,OAJAG,GAAUhL,EACViL,GAAU/a,EACV/3B,EAAO6nC,EACP5nC,EAAO83B,EACCgZ,GACJ,KAAK,YAED8B,GADAL,GAAW,EAEXxyC,GAAQwyC,EACR,MACJ,KAAK,UACDxyC,GAAQwyC,EACRG,GAAWH,EAAU,EACrB,MACJ,KAAK,WACDK,GAAUL,EACVG,EAAUH,EAAU,EAG5B,OAAQvB,GACJ,KAAK,YAED6B,GADAJ,GAAW,EAEXzyC,GAAQyyC,EACR,MACJ,KAAK,YACDzyC,GAAQyyC,EACRE,GAAWF,EAAU,EACrB,MACJ,KAAK,SACDI,GAAUJ,EACVE,EAAUF,EAAU,GAIhC,IAAI73C,EAAY,GACZ65B,EAAU,GACVqe,EAAS,GACbA,EAAO,GAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAClCA,EAAO,GAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9BpC,IAAa,kBAAoBA,IAAa,kBAC9CoC,EAAO,GAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAElCpC,IAAa,gBAAkBA,IAAa,gBAC5CoC,EAAO,GAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAElCpC,IAAa,yBAA2BA,IAAa,yBACrDoC,EAAO,GAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAMtC,IAJA,IAAIpe,EAAM,GACN57B,EAAS,GACT+B,EAAU,GACV9I,EAAQ,EACHkI,EAAI,EAAGA,EAAIu4C,EAAQv4C,IACxB,IAAK,IAAI7E,EAAI,EAAGA,EAAIk9C,EAAQl9C,IACxBwF,EAAUhB,KAAkBxE,EAAIw7C,EAAhBhJ,EAA4B8K,EAAuBz4C,EAAI42C,EAAjB/Y,EAA8B6a,EAAS,GAC7F/3C,EAAUhB,MAAmBxE,EAAI,GAAKw7C,EAAtBhJ,EAAkC8K,EAAuBz4C,EAAI42C,EAAjB/Y,EAA8B6a,EAAS,GACnG/3C,EAAUhB,MAAmBxE,EAAI,GAAKw7C,EAAtBhJ,EAAkC8K,GAAwBz4C,EAAI,GAAK42C,EAAvB/Y,EAAoC6a,EAAS,GACzG/3C,EAAUhB,KAAkBxE,EAAIw7C,EAAhBhJ,EAA4B8K,GAAwBz4C,EAAI,GAAK42C,EAAvB/Y,EAAoC6a,EAAS,GACnG93C,EAAQjB,KAAK7H,EAAOA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GAEpE2iC,EADAgc,IAAa,gBAAkBA,IAAa,kBAAoBA,IAAa,wBACvEhc,EAAIxmB,OAAO4kC,GAAS19C,EAAI,EAAM6E,EAAI,GAAM,IAEzCy2C,IAAa,eAAiBA,IAAa,iBAAmBA,IAAa,uBAC1Ehc,EAAIxmB,OAAO4kC,EAAO74C,EAAI,IAGtBy6B,EAAIxmB,OAAO4kC,EAAO,IAE5Bh6C,EAAOc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzD66B,EAAQ76B,KAAK,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAClD7H,GAAS,EAIjB,GAAIwgD,EAAU,GAAKE,EAAU,EAAG,CAC5B,IAAIM,EAAmBN,EAAU,IAAMzB,IAAW,aAAeA,IAAW,UACxEgC,EAAgBP,EAAU,IAAMzB,IAAW,aAAeA,IAAW,aACrEiC,EAAiBV,EAAU,IAAMzB,IAAW,aAAeA,IAAW,YACtEoC,EAAkBX,EAAU,IAAMzB,IAAW,aAAeA,IAAW,WACvEqC,EAAS,GACT76C,OAAI,EAAQhH,OAAI,EAAQ6W,OAAI,EAAQhO,OAAI,EA2G5C,GAzGI44C,GAAoBE,IAEpBr4C,EAAUhB,KAAKg5C,EAASF,EAASG,EAASF,EAAS,GACnD/3C,EAAUhB,MAAMguC,EAAY8K,EAASG,EAASF,EAAS,GACvD/3C,EAAUhB,MAAMguC,EAAY8K,EAASG,EAASJ,EAAUE,EAAS,GACjE/3C,EAAUhB,KAAKg5C,EAASF,EAASG,EAASJ,EAAUE,EAAS,GAC7D93C,EAAQjB,KAAK7H,EAAOA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GACxEA,GAAS,EAKTohD,EAAS,CAJT76C,EAAI,EAAIi6C,EAAU3B,EAClBt/C,EAAI,EAAImhD,EAAU5B,EAClB1oC,EAAI,EAEe7W,EAAG6W,EADtBhO,EAAI,EACwB7B,EAAG6B,GAC3Bu2C,IAAa,kBACbyC,EAAS,CAAC,EAAI76C,EAAG,EAAIhH,EAAG,EAAI6W,EAAG,EAAI7W,EAAG,EAAI6W,EAAG,EAAIhO,EAAG,EAAI7B,EAAG,EAAI6B,IAE/Du2C,IAAa,gBACbyC,EAAS,CAAC,EAAI76C,EAAGhH,EAAG,EAAI6W,EAAG7W,EAAG,EAAI6W,EAAGhO,EAAG,EAAI7B,EAAG6B,IAE/Cu2C,IAAa,yBACbyC,EAAS,CAAC76C,EAAG,EAAIhH,EAAG6W,EAAG,EAAI7W,EAAG6W,EAAG,EAAIhO,EAAG7B,EAAG,EAAI6B,IAEnDu6B,EAAMA,EAAIxmB,OAAOilC,GACjBr6C,EAAOc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzD66B,EAAQ76B,KAAK,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,IAElDm5C,GAAoBG,IAEpBt4C,EAAUhB,KAAKguC,EAAY8K,EAASG,EAASF,EAAS,GACtD/3C,EAAUhB,KAAKmG,EAAO2yC,EAASG,EAASF,EAAS,GACjD/3C,EAAUhB,KAAKmG,EAAO2yC,EAASG,EAASJ,EAAUE,EAAS,GAC3D/3C,EAAUhB,KAAKguC,EAAY8K,EAASG,EAASJ,EAAUE,EAAS,GAChE93C,EAAQjB,KAAK7H,EAAOA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GACxEA,GAAS,EAKTohD,EAAS,CAJT76C,EAAI,EACJhH,EAAI,EAAImhD,EAAU5B,EAClB1oC,EAAIoqC,EAAU3B,EAEKt/C,EAAG6W,EADtBhO,EAAI,EACwB7B,EAAG6B,IAC3Bu2C,IAAa,iBAAoBA,IAAa,kBAAoB4B,EAAS,GAAM,KACjFa,EAAS,CAAC,EAAI76C,EAAG,EAAIhH,EAAG,EAAI6W,EAAG,EAAI7W,EAAG,EAAI6W,EAAG,EAAIhO,EAAG,EAAI7B,EAAG,EAAI6B,KAE/Du2C,IAAa,eAAkBA,IAAa,gBAAkB4B,EAAS,GAAM,KAC7Ea,EAAS,CAAC,EAAI76C,EAAGhH,EAAG,EAAI6W,EAAG7W,EAAG,EAAI6W,EAAGhO,EAAG,EAAI7B,EAAG6B,KAE/Cu2C,IAAa,wBAA2BA,IAAa,yBAA2B4B,EAAS,GAAM,KAC/Fa,EAAS,CAAC76C,EAAG,EAAIhH,EAAG6W,EAAG,EAAI7W,EAAG6W,EAAG,EAAIhO,EAAG7B,EAAG,EAAI6B,IAEnDu6B,EAAMA,EAAIxmB,OAAOilC,GACjBr6C,EAAOc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzD66B,EAAQ76B,KAAK,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,IAElDo5C,GAAiBC,IAEjBr4C,EAAUhB,KAAKg5C,EAASF,EAAS5a,EAAa6a,EAAS,GACvD/3C,EAAUhB,MAAMguC,EAAY8K,EAAS5a,EAAa6a,EAAS,GAC3D/3C,EAAUhB,MAAMguC,EAAY8K,EAAS1yC,EAAO2yC,EAAS,GACrD/3C,EAAUhB,KAAKg5C,EAASF,EAAS1yC,EAAO2yC,EAAS,GACjD93C,EAAQjB,KAAK7H,EAAOA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GACxEA,GAAS,EAKTohD,EAAS,CAJT76C,EAAI,EAAIi6C,EAAU3B,EAClBt/C,EAAI,EACJ6W,EAAI,EAEe7W,EAAG6W,EADtBhO,EAAIs4C,EAAU5B,EACcv4C,EAAG6B,IAC1Bu2C,IAAa,iBAAmB8B,EAAS,GAAM,GAAO9B,IAAa,kBAAoB8B,EAAS,GAAM,KACvGW,EAAS,CAAC,EAAI76C,EAAG,EAAIhH,EAAG,EAAI6W,EAAG,EAAI7W,EAAG,EAAI6W,EAAG,EAAIhO,EAAG,EAAI7B,EAAG,EAAI6B,KAE9Du2C,IAAa,eAAiB8B,EAAS,GAAM,GAAO9B,IAAa,gBAAkB8B,EAAS,GAAM,KACnGW,EAAS,CAAC,EAAI76C,EAAGhH,EAAG,EAAI6W,EAAG7W,EAAG,EAAI6W,EAAGhO,EAAG,EAAI7B,EAAG6B,KAE9Cu2C,IAAa,wBAA0B8B,EAAS,GAAM,GAAO9B,IAAa,yBAA2B8B,EAAS,GAAM,KACrHW,EAAS,CAAC76C,EAAG,EAAIhH,EAAG6W,EAAG,EAAI7W,EAAG6W,EAAG,EAAIhO,EAAG7B,EAAG,EAAI6B,IAEnDu6B,EAAMA,EAAIxmB,OAAOilC,GACjBr6C,EAAOc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzD66B,EAAQ76B,KAAK,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,IAElDo5C,GAAiBE,IAEjBt4C,EAAUhB,KAAKguC,EAAY8K,EAAS5a,EAAa6a,EAAS,GAC1D/3C,EAAUhB,KAAKmG,EAAO2yC,EAAS5a,EAAa6a,EAAS,GACrD/3C,EAAUhB,KAAKmG,EAAO2yC,EAAS1yC,EAAO2yC,EAAS,GAC/C/3C,EAAUhB,KAAKguC,EAAY8K,EAAS1yC,EAAO2yC,EAAS,GACpD93C,EAAQjB,KAAK7H,EAAOA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GACxEA,GAAS,EAKTohD,EAAS,CAJT76C,EAAI,EACJhH,EAAI,EACJ6W,EAAIoqC,EAAU3B,EAEKt/C,EAAG6W,EADtBhO,EAAIs4C,EAAU5B,EACcv4C,EAAG6B,IAC1Bu2C,IAAa,iBAAmB8B,EAAS,GAAM,GAAO9B,IAAa,mBAAqB8B,EAASF,GAAU,GAAM,KAClHa,EAAS,CAAC,EAAI76C,EAAG,EAAIhH,EAAG,EAAI6W,EAAG,EAAI7W,EAAG,EAAI6W,EAAG,EAAIhO,EAAG,EAAI7B,EAAG,EAAI6B,KAE9Du2C,IAAa,eAAiB8B,EAAS,GAAM,GAAO9B,IAAa,iBAAmB8B,EAASF,GAAU,GAAM,KAC9Ga,EAAS,CAAC,EAAI76C,EAAGhH,EAAG,EAAI6W,EAAG7W,EAAG,EAAI6W,EAAGhO,EAAG,EAAI7B,EAAG6B,KAE9Cu2C,IAAa,wBAA0B8B,EAAS,GAAM,GAAO9B,IAAa,0BAA4B8B,EAASF,GAAU,GAAM,KAChIa,EAAS,CAAC76C,EAAG,EAAIhH,EAAG6W,EAAG,EAAI7W,EAAG6W,EAAG,EAAIhO,EAAG7B,EAAG,EAAI6B,IAEnDu6B,EAAMA,EAAIxmB,OAAOilC,GACjBr6C,EAAOc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzD66B,EAAQ76B,KAAK,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,IAGlDm5C,EAAkB,CAClB,IAAIK,EAAW,GACf96C,EAAI,EACJhH,EAAI,EAAImhD,EAAU5B,EAClB1oC,EAAI,EACJhO,EAAI,EACJi5C,EAAS,GAAK,CAAC96C,EAAGhH,EAAG6W,EAAG7W,EAAG6W,EAAGhO,EAAG7B,EAAG6B,GACpCi5C,EAAS,GAAK,CAAC96C,EAAGhH,EAAG6W,EAAG7W,EAAG6W,EAAGhO,EAAG7B,EAAG6B,GAChCu2C,IAAa,kBAAoBA,IAAa,kBAC9C0C,EAAS,GAAK,CAAC,EAAI96C,EAAG,EAAIhH,EAAG,EAAI6W,EAAG,EAAI7W,EAAG,EAAI6W,EAAG,EAAIhO,EAAG,EAAI7B,EAAG,EAAI6B,IAEpEu2C,IAAa,gBAAkBA,IAAa,gBAC5C0C,EAAS,GAAK,CAAC,EAAI96C,EAAGhH,EAAG,EAAI6W,EAAG7W,EAAG,EAAI6W,EAAGhO,EAAG,EAAI7B,EAAG6B,IAEpDu2C,IAAa,yBAA2BA,IAAa,yBACrD0C,EAAS,GAAK,CAAC96C,EAAG,EAAIhH,EAAG6W,EAAG,EAAI7W,EAAG6W,EAAG,EAAIhO,EAAG7B,EAAG,EAAI6B,IAExD,IAAS/E,EAAI,EAAGA,EAAIk9C,EAAQl9C,IACxBwF,EAAUhB,KAAkBxE,EAAIw7C,EAAhBhJ,EAA4B8K,EAASG,EAASF,EAAS,GACvE/3C,EAAUhB,MAAmBxE,EAAI,GAAKw7C,EAAtBhJ,EAAkC8K,EAASG,EAASF,EAAS,GAC7E/3C,EAAUhB,MAAmBxE,EAAI,GAAKw7C,EAAtBhJ,EAAkC8K,EAASG,EAASJ,EAAUE,EAAS,GACvF/3C,EAAUhB,KAAkBxE,EAAIw7C,EAAhBhJ,EAA4B8K,EAASG,EAASJ,EAAUE,EAAS,GACjF93C,EAAQjB,KAAK7H,EAAOA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GACxEA,GAAS,EAEL2iC,EADAgc,IAAa,gBAAkBA,IAAa,kBAAoBA,IAAa,wBACvEhc,EAAIxmB,OAAOklC,GAAUh+C,EAAI,GAAK,IAE/Bs7C,IAAa,eAAiBA,IAAa,iBAAmBA,IAAa,uBAC1Ehc,EAAIxmB,OAAOklC,EAAS,IAGpB1e,EAAIxmB,OAAOklC,EAAS,IAE9Bt6C,EAAOc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzD66B,EAAQ76B,KAAK,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAG1D,GAAIo5C,EAAe,CACf,IAAIK,EAAW,GACf/6C,EAAI,EACJhH,EAAI,EACJ6W,EAAI,EACJhO,EAAIs4C,EAAU5B,EACdwC,EAAS,GAAK,CAAC/6C,EAAGhH,EAAG6W,EAAG7W,EAAG6W,EAAGhO,EAAG7B,EAAG6B,GACpCk5C,EAAS,GAAK,CAAC/6C,EAAGhH,EAAG6W,EAAG7W,EAAG6W,EAAGhO,EAAG7B,EAAG6B,GAChCu2C,IAAa,kBAAoBA,IAAa,kBAC9C2C,EAAS,GAAK,CAAC,EAAI/6C,EAAG,EAAIhH,EAAG,EAAI6W,EAAG,EAAI7W,EAAG,EAAI6W,EAAG,EAAIhO,EAAG,EAAI7B,EAAG,EAAI6B,IAEpEu2C,IAAa,gBAAkBA,IAAa,gBAC5C2C,EAAS,GAAK,CAAC,EAAI/6C,EAAGhH,EAAG,EAAI6W,EAAG7W,EAAG,EAAI6W,EAAGhO,EAAG,EAAI7B,EAAG6B,IAEpDu2C,IAAa,yBAA2BA,IAAa,yBACrD2C,EAAS,GAAK,CAAC/6C,EAAG,EAAIhH,EAAG6W,EAAG,EAAI7W,EAAG6W,EAAG,EAAIhO,EAAG7B,EAAG,EAAI6B,IAExD,IAAS/E,EAAI,EAAGA,EAAIk9C,EAAQl9C,IACxBwF,EAAUhB,KAAkBxE,EAAIw7C,EAAhBhJ,EAA4B8K,EAAS1yC,EAAOyyC,EAAUE,EAAS,GAC/E/3C,EAAUhB,MAAmBxE,EAAI,GAAKw7C,EAAtBhJ,EAAkC8K,EAAS1yC,EAAOyyC,EAAUE,EAAS,GACrF/3C,EAAUhB,MAAmBxE,EAAI,GAAKw7C,EAAtBhJ,EAAkC8K,EAAS1yC,EAAO2yC,EAAS,GAC3E/3C,EAAUhB,KAAkBxE,EAAIw7C,EAAhBhJ,EAA4B8K,EAAS1yC,EAAO2yC,EAAS,GACrE93C,EAAQjB,KAAK7H,EAAOA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GACxEA,GAAS,EAEL2iC,EADAgc,IAAa,gBAAkBA,IAAa,kBAAoBA,IAAa,wBACvEhc,EAAIxmB,OAAOmlC,GAAUj+C,EAAIo9C,GAAU,IAEpC9B,IAAa,eAAiBA,IAAa,iBAAmBA,IAAa,uBAC1Ehc,EAAIxmB,OAAOmlC,EAASb,EAAS,IAG7B9d,EAAIxmB,OAAOmlC,EAAS,IAE9Bv6C,EAAOc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzD66B,EAAQ76B,KAAK,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAG1D,GAAIq5C,EAAgB,CAChB,IAAIK,EAAW,GACfh7C,EAAI,EAAIi6C,EAAU3B,EAClBt/C,EAAI,EACJ6W,EAAI,EACJhO,EAAI,EACJm5C,EAAS,GAAK,CAACh7C,EAAGhH,EAAG6W,EAAG7W,EAAG6W,EAAGhO,EAAG7B,EAAG6B,GACpCm5C,EAAS,GAAK,CAACh7C,EAAGhH,EAAG6W,EAAG7W,EAAG6W,EAAGhO,EAAG7B,EAAG6B,GAChCu2C,IAAa,kBAAoBA,IAAa,kBAC9C4C,EAAS,GAAK,CAAC,EAAIh7C,EAAG,EAAIhH,EAAG,EAAI6W,EAAG,EAAI7W,EAAG,EAAI6W,EAAG,EAAIhO,EAAG,EAAI7B,EAAG,EAAI6B,IAEpEu2C,IAAa,gBAAkBA,IAAa,gBAC5C4C,EAAS,GAAK,CAAC,EAAIh7C,EAAGhH,EAAG,EAAI6W,EAAG7W,EAAG,EAAI6W,EAAGhO,EAAG,EAAI7B,EAAG6B,IAEpDu2C,IAAa,yBAA2BA,IAAa,yBACrD4C,EAAS,GAAK,CAACh7C,EAAG,EAAIhH,EAAG6W,EAAG,EAAI7W,EAAG6W,EAAG,EAAIhO,EAAG7B,EAAG,EAAI6B,IAExD,IAASF,EAAI,EAAGA,EAAIu4C,EAAQv4C,IACxBW,EAAUhB,KAAKg5C,EAASF,EAAuBz4C,EAAI42C,EAAjB/Y,EAA8B6a,EAAS,GACzE/3C,EAAUhB,KAAKg5C,EAASL,EAAUG,EAAuBz4C,EAAI42C,EAAjB/Y,EAA8B6a,EAAS,GACnF/3C,EAAUhB,KAAKg5C,EAASL,EAAUG,GAAwBz4C,EAAI,GAAK42C,EAAvB/Y,EAAoC6a,EAAS,GACzF/3C,EAAUhB,KAAKg5C,EAASF,GAAwBz4C,EAAI,GAAK42C,EAAvB/Y,EAAoC6a,EAAS,GAC/E93C,EAAQjB,KAAK7H,EAAOA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GACxEA,GAAS,EAEL2iC,EADAgc,IAAa,gBAAkBA,IAAa,kBAAoBA,IAAa,wBACvEhc,EAAIxmB,OAAOolC,GAAUr5C,EAAI,GAAK,IAE/By2C,IAAa,eAAiBA,IAAa,iBAAmBA,IAAa,uBAC1Ehc,EAAIxmB,OAAOolC,EAASr5C,EAAI,IAGxBy6B,EAAIxmB,OAAOolC,EAAS,IAE9Bx6C,EAAOc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzD66B,EAAQ76B,KAAK,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAG1D,GAAIs5C,EAAiB,CACjB,IAAIK,EAAW,GACfj7C,EAAI,EACJhH,EAAI,EACJ6W,EAAIoqC,EAAU1B,EACd12C,EAAI,EACJo5C,EAAS,GAAK,CAACj7C,EAAGhH,EAAG6W,EAAG7W,EAAG6W,EAAGhO,EAAG7B,EAAG6B,GACpCo5C,EAAS,GAAK,CAACj7C,EAAGhH,EAAG6W,EAAG7W,EAAG6W,EAAGhO,EAAG7B,EAAG6B,GAChCu2C,IAAa,kBAAoBA,IAAa,kBAC9C6C,EAAS,GAAK,CAAC,EAAIj7C,EAAG,EAAIhH,EAAG,EAAI6W,EAAG,EAAI7W,EAAG,EAAI6W,EAAG,EAAIhO,EAAG,EAAI7B,EAAG,EAAI6B,IAEpEu2C,IAAa,gBAAkBA,IAAa,gBAC5C6C,EAAS,GAAK,CAAC,EAAIj7C,EAAGhH,EAAG,EAAI6W,EAAG7W,EAAG,EAAI6W,EAAGhO,EAAG,EAAI7B,EAAG6B,IAEpDu2C,IAAa,yBAA2BA,IAAa,yBACrD6C,EAAS,GAAK,CAACj7C,EAAG,EAAIhH,EAAG6W,EAAG,EAAI7W,EAAG6W,EAAG,EAAIhO,EAAG7B,EAAG,EAAI6B,IAExD,IAASF,EAAI,EAAGA,EAAIu4C,EAAQv4C,IACxBW,EAAUhB,KAAKmG,EAAOwyC,EAAUG,EAAuBz4C,EAAI42C,EAAjB/Y,EAA8B6a,EAAS,GACjF/3C,EAAUhB,KAAKmG,EAAO2yC,EAAuBz4C,EAAI42C,EAAjB/Y,EAA8B6a,EAAS,GACvE/3C,EAAUhB,KAAKmG,EAAO2yC,GAAwBz4C,EAAI,GAAK42C,EAAvB/Y,EAAoC6a,EAAS,GAC7E/3C,EAAUhB,KAAKmG,EAAOwyC,EAAUG,GAAwBz4C,EAAI,GAAK42C,EAAvB/Y,EAAoC6a,EAAS,GACvF93C,EAAQjB,KAAK7H,EAAOA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,EAAGA,EAAQ,GACxEA,GAAS,EAEL2iC,EADAgc,IAAa,gBAAkBA,IAAa,kBAAoBA,IAAa,wBACvEhc,EAAIxmB,OAAOqlC,GAAUt5C,EAAIq4C,GAAU,IAEpC5B,IAAa,eAAiBA,IAAa,iBAAmBA,IAAa,uBAC1Ehc,EAAIxmB,OAAOqlC,EAASt5C,EAAI,IAGxBy6B,EAAIxmB,OAAOqlC,EAAS,IAE9Bz6C,EAAOc,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzD66B,EAAQ76B,KAAK,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,IAI9D,IAAIk8B,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBAErF,kBAAyBA,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SAEtG,IAAIC,EAAa,IAAI,IACrBA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACjB,IAAI0B,EAAcN,IAAoB,eAAwBh9B,EAAOoV,OAAOpV,GAAUA,EAEtF,OADAq9B,EAAWr9B,OAASs9B,EACbD,EAmCJ,SAASqd,EAAiBld,EAAM9B,EAAS+B,QAC9B,IAAVA,IAAoBA,EAAQ,MAChC,IAAInkB,EAAQ,IAAI,KAAKkkB,EAAMC,GAK3B,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClE1jB,EAAMqkB,gCAAkCjC,EAAQsB,gBAC/Buc,EAA2B7d,GACjCkC,YAAYtkB,EAAOoiB,EAAQmC,WAC/BvkB,EAMJ,IAAIqhC,EAAoB,CAE3BD,iBAAkBA,GAEtB,qBAA8BnB,G,oGCjbvB,SAASqB,EAAsBlf,GAUlC,IATA,IAAI35B,EAAU,GACVD,EAAY,GACZ65B,EAAU,GACVC,EAAM,GACN8E,EAAWhF,EAAQgF,UAAY,EAC/Bma,EAAYnf,EAAQmf,WAAa,GACjC5c,EAAevC,EAAQuC,cAAgB,GACvCjB,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBACjFz6B,EAAS07B,EAAe,EACnBx5B,EAAI,EAAGA,GAAKw5B,EAAcx5B,IAI/B,IAHA,IAAIi7B,EAAIj7B,EAAIw5B,EACR6c,EAAcr2C,EAAIxJ,KAAK6J,GAAK,EAAOm5B,EAAehjC,KAAK6J,GAAK,EAC5DlE,EAAY,iBAAmB8/B,EAAW,EAAK,EAAG,GAAGhnC,SAAS,eAAiBohD,IAC1E9yC,EAAI,EAAGA,GAAKi2B,EAAcj2B,IAAK,CACpC,IAAIpM,EAAI,EAAIoM,EAAIi2B,EACZ8c,EAAc/yC,EAAI/M,KAAK6J,GAAK,EAAOm5B,EAAehjC,KAAK6J,GACvDk2C,EAAK//C,KAAKsM,IAAIwzC,GACdE,EAAKhgD,KAAKuM,IAAIuzC,GAEd75C,EAAS,IAAI,IAAQ85C,EAAIC,EAAI,GAC7B9xC,EAAWjI,EAAOlH,MAAM6gD,EAAY,GACpC/Y,EAAoB,IAAI,KAAQpC,EAAG9jC,GACvCuN,EAAW,yBAA6BA,EAAUvI,GAClDM,EAAS,oBAAwBA,EAAQN,GACzCkB,EAAUhB,KAAKqI,EAAS7M,EAAG6M,EAAShI,EAAGgI,EAAS/H,GAChDu6B,EAAQ76B,KAAKI,EAAO5E,EAAG4E,EAAOC,EAAGD,EAAOE,GACxCw6B,EAAI96B,KAAKghC,EAAkBxlC,EAAG,8BAAiD,EAAMwlC,EAAkB3gC,EAAI2gC,EAAkB3gC,GAE7H,IAAI+5C,GAASz2C,EAAI,GAAKlC,EAClB44C,GAASnzC,EAAI,GAAKzF,EACtBR,EAAQjB,KAAK2D,EAAIlC,EAASyF,GAC1BjG,EAAQjB,KAAK2D,EAAIlC,EAAS44C,GAC1Bp5C,EAAQjB,KAAKo6C,EAAQ34C,EAASyF,GAC9BjG,EAAQjB,KAAK2D,EAAIlC,EAAS44C,GAC1Bp5C,EAAQjB,KAAKo6C,EAAQ34C,EAAS44C,GAC9Bp5C,EAAQjB,KAAKo6C,EAAQ34C,EAASyF,GAItC,kBAAyBg1B,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SAEtG,IAAIC,EAAa,IAAI,IAKrB,OAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EAuBJ,SAAS+d,EAAY5d,EAAM9B,EAAS+B,QACvB,IAAZ/B,IAAsBA,EAAU,IACpC,IAAI2f,EAAQ,IAAI,KAAK7d,EAAMC,GAK3B,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClEqe,EAAM1d,gCAAkCjC,EAAQsB,gBAC/B4d,EAAsBlf,GAC5BkC,YAAYyd,EAAO3f,EAAQmC,WAC/Bwd,EAMJ,IAAIC,EAAe,CAEtBF,YAAaA,GAEjB,gBAAyBR,EACzB,iBAAmB,SAAUpd,EAAMkD,EAAUma,EAAW5c,EAAcR,EAAOI,EAAWb,GAQpF,OAAOoe,EAAY5d,EAPL,CACVkD,SAAUA,EACVma,UAAWA,EACX5c,aAAcA,EACdjB,gBAAiBA,EACjBa,UAAWA,GAEmBJ,K,oGCzF/B,SAAS8d,EAA0B7f,GACtC,IAuBIj3B,EACAuD,EAxBAjG,EAAU,IAAIY,MACdb,EAAY,IAAIa,MAChBg5B,EAAU,IAAIh5B,MACdi5B,EAAM,IAAIj5B,MACVmD,EAAS41B,EAAQ51B,QAAU,EAC3B01C,EAAO9f,EAAQ8f,MAAQ,GACvBpd,EAAiB1C,EAAQ0C,gBAAkB,GAC3Cqd,EAAkB/f,EAAQ+f,iBAAmB,GAC7ClyC,EAAImyB,EAAQnyB,GAAK,EACjBuP,EAAI4iB,EAAQ5iB,GAAK,EACjBkkB,EAA8C,IAA5BtB,EAAQsB,gBAAwB,EAAItB,EAAQsB,iBAAmB,gBAEjF0e,EAAS,SAAUp1C,GACnB,IAAIq1C,EAAK1gD,KAAKsM,IAAIjB,GACds1C,EAAK3gD,KAAKuM,IAAIlB,GACdu1C,EAAW/iC,EAAIvP,EAAKjD,EACpBi7B,EAAKtmC,KAAKsM,IAAIs0C,GACd7nC,EAAKlO,GAAU,EAAIy7B,GAAM,GAAMoa,EAC/BG,EAAKh2C,GAAU,EAAIy7B,GAAMqa,EAAK,GAC9BG,EAAKj2C,EAAS7K,KAAKuM,IAAIq0C,GAAW,GACtC,OAAO,IAAI,IAAQ7nC,EAAI8nC,EAAIC,IAK/B,IAAKt3C,EAAI,EAAGA,GAAK25B,EAAgB35B,IAAK,CAClC,IACIi7B,EADOj7B,EAAI25B,EACCA,EAAkB,EAAI70B,EAAItO,KAAK6J,GAC3C+J,EAAK6sC,EAAOhc,GACZ3wB,EAAK2sC,EAAOhc,EAAI,KAChBsc,EAAOjtC,EAAGvU,SAASqU,GACnBvL,EAAIyL,EAAGzU,IAAIuU,GACXotC,EAAQ,UAAcD,EAAM14C,GAIhC,IAHAA,EAAI,UAAc24C,EAAOD,GACzBC,EAAM36C,YACNgC,EAAEhC,YACG0G,EAAI,EAAGA,EAAIyzC,EAAiBzzC,IAAK,CAClC,IACIpM,EADOoM,EAAIyzC,EACCA,EAAmB,EAAIxgD,KAAK6J,GACxCma,GAAMu8B,EAAOvgD,KAAKsM,IAAI3L,GACtBsjB,EAAKs8B,EAAOvgD,KAAKuM,IAAI5L,GACzBkG,EAAUhB,KAAK+N,EAAGvS,EAAI2iB,EAAK3b,EAAEhH,EAAI4iB,EAAK+8B,EAAM3/C,GAC5CwF,EAAUhB,KAAK+N,EAAG1N,EAAI8d,EAAK3b,EAAEnC,EAAI+d,EAAK+8B,EAAM96C,GAC5CW,EAAUhB,KAAK+N,EAAGzN,EAAI6d,EAAK3b,EAAElC,EAAI8d,EAAK+8B,EAAM76C,GAC5Cw6B,EAAI96B,KAAK2D,EAAI25B,GACbxC,EAAI96B,KAAK,8BAAiD,EAAMkH,EAAIyzC,EAAkBzzC,EAAIyzC,IAGlG,IAAKh3C,EAAI,EAAGA,EAAI25B,EAAgB35B,IAC5B,IAAKuD,EAAI,EAAGA,EAAIyzC,EAAiBzzC,IAAK,CAClC,IAAIk0C,GAASl0C,EAAI,GAAKyzC,EAClBj8C,EAAIiF,EAAIg3C,EAAkBzzC,EAC1BxP,GAAKiM,EAAI,GAAKg3C,EAAkBzzC,EAChCqH,GAAK5K,EAAI,GAAKg3C,EAAkBS,EAChC76C,EAAIoD,EAAIg3C,EAAkBS,EAC9Bn6C,EAAQjB,KAAKO,GACbU,EAAQjB,KAAKtI,GACbuJ,EAAQjB,KAAKtB,GACbuC,EAAQjB,KAAKO,GACbU,EAAQjB,KAAKuO,GACbtN,EAAQjB,KAAKtI,GAIrB,mBAA0BsJ,EAAWC,EAAS45B,GAE9C,kBAAyBqB,EAAiBl7B,EAAWC,EAAS45B,EAASC,EAAKF,EAAQyB,SAAUzB,EAAQ0B,SAEtG,IAAIC,EAAa,IAAI,IAKrB,OAJAA,EAAWt7B,QAAUA,EACrBs7B,EAAWv7B,UAAYA,EACvBu7B,EAAW1B,QAAUA,EACrB0B,EAAWzB,IAAMA,EACVyB,EA2BJ,SAAS8e,EAAgB3e,EAAM9B,EAAS+B,QAC3B,IAAZ/B,IAAsBA,EAAU,IACpC,IAAI0gB,EAAY,IAAI,KAAK5e,EAAMC,GAK/B,OAJA/B,EAAQsB,gBAAkB,gCAAgCtB,EAAQsB,iBAClEof,EAAUze,gCAAkCjC,EAAQsB,gBACnCue,EAA0B7f,GAChCkC,YAAYwe,EAAW1gB,EAAQmC,WACnCue,EAMJ,IAAIC,EAAmB,CAE1BF,gBAAiBA,GAErB,oBAA6BZ,EAC7B,qBAAuB,SAAU/d,EAAM13B,EAAQ01C,EAAMpd,EAAgBqd,EAAiBlyC,EAAGuP,EAAG2kB,EAAOI,EAAWb,GAW1G,OAAOmf,EAAgB3e,EAVT,CACV13B,OAAQA,EACR01C,KAAMA,EACNpd,eAAgBA,EAChBqd,gBAAiBA,EACjBlyC,EAAGA,EACHuP,EAAGA,EACHkkB,gBAAiBA,EACjBa,UAAWA,GAEuBJ,K,yFCxHnC,SAAS6e,EAAW9e,EAAM9B,EAAS+B,QACxB,IAAVA,IAAoBA,EAAQ,MAChC,IAAIl1B,EAAOmzB,EAAQnzB,KACfulC,EAAWpS,EAAQoS,SACnBhoC,EAAS,OACU2c,IAAnBiZ,EAAQ51B,OACRA,EAAS41B,EAAQ51B,OAEZgoC,IACLhoC,EAASgoC,EAASY,qBAAqB5oC,QAE3C,IAAIm4B,EAAevC,EAAQuC,cAAgB,GACvCse,EAAiB7gB,EAAQ6gB,gBAAkB,KAC3Czb,EAAMpF,EAAQoF,KAAO,YACrB6L,EAAWjR,EAAQiR,WAAY,EAC/B9O,EAAYnC,EAAQmC,UACpBb,EAAkB,gCAAgCtB,EAAQsB,iBAC9DtB,EAAQt0B,IAAMs0B,EAAQt0B,MAAQs0B,EAAQt0B,KAAO,GAAOs0B,EAAQt0B,IAAM,GAAO,EAAMs0B,EAAQt0B,KAAO,EAE9F,IA0DIguC,EACAxI,EA3DA4P,EAAgB,SAAUj0C,EAAM6sC,EAAQqH,EAAa32C,EAAQm4B,EAAcse,EAAgBzb,EAAK15B,GAchG,IAbA,IAOIs1C,EACAC,EACAz7C,EACAsrC,EAVA+I,EAAWH,EAAOxrC,cAClB+xB,EAAUyZ,EAAOvrC,aACjB4rC,EAAYL,EAAOrrC,eAEnBkF,EADgB,EAAVhU,KAAK6J,GACGm5B,EAAgB72B,EAE9Bw1C,EAAsBL,GADP,WAAc,OAAOz2C,GAMpC8vC,EAAiB,eACjB38C,EAAQ6nC,IAAQ,aAAeA,IAAQ,aAAe,EAAI,EACrDr8B,EAAI,EAAGA,EAAI8D,EAAK3L,OAAQ6H,IAAK,CAClCk4C,EAAMC,EAAoBn4C,EAAGgxC,EAAUhxC,IACvCi4C,EAAa/5C,QACbzB,EAASy6B,EAAQl3B,GACjB,IAAK,IAAIT,EAAI,EAAGA,EAAIi6B,EAAcj6B,IAC9B,uBAAyBuxC,EAAS9wC,GAAIwK,EAAOjL,EAAG4xC,GAChDpJ,EAAUkQ,EAAW14C,GAAK04C,EAAW14C,GAAK,WAC1C,8BAAkC9C,EAAQ00C,EAAgBpJ,GAC1DA,EAAQv/B,aAAa0vC,GAAKl9C,WAAW8I,EAAK9D,IAC1Ci4C,EAAW14C,GAAKwoC,EAEpBiQ,EAAYxjD,GAASyjD,EACrBzjD,IAGJ,IAAI+8C,EAAU,SAAU7nC,EAAU0uC,GAE9B,IADA,IAAI5G,EAAWtzC,QACN8B,EAAI,EAAGA,EAAI0J,EAAU1J,IAC1BwxC,EAASn1C,KAAKyH,EAAKs0C,IAEvB,OAAO5G,GAEX,OAAQnV,GACJ,KAAK,YACD,MACJ,KAAK,eACD2b,EAAY,GAAKzG,EAAQ/X,EAAc,GACvCwe,EAAY,GAAKA,EAAY,GAAGzxC,MAAM,GACtC,MACJ,KAAK,aACDyxC,EAAYxjD,GAASwjD,EAAYxjD,EAAQ,GAAG+R,MAAM,GAClDyxC,EAAYxjD,EAAQ,GAAK+8C,EAAQ/X,EAAc11B,EAAK3L,OAAS,GAC7D,MACJ,KAAK,aACD6/C,EAAY,GAAKzG,EAAQ/X,EAAc,GACvCwe,EAAY,GAAKA,EAAY,GAAGzxC,MAAM,GACtCyxC,EAAYxjD,GAASwjD,EAAYxjD,EAAQ,GAAG+R,MAAM,GAClDyxC,EAAYxjD,EAAQ,GAAK+8C,EAAQ/X,EAAc11B,EAAK3L,OAAS,GAKrE,OAAO6/C,GAIX,GAAI3O,EAAU,CAEV,IAAIqI,EAAUrI,EAASY,qBACnBtnC,EAAMs0B,EAAQt0B,KAAO+uC,EAAQ/uC,IASjC,OAPAwlC,EAAY4P,EAAcj0C,EAD1B6sC,EAASe,EAAQf,OAAO7pC,OAAOhD,GACS4tC,EAAQvJ,UAAW9mC,EAAQqwC,EAAQlY,aAAcse,EAAgBpG,EAAQrV,IAAK15B,GACtH0mC,GAAW,QAAa,GAAI,CAAElB,UAAWA,EAAWkB,SAAUA,IAE9DqI,EAAQf,OAASA,EACjBe,EAAQvJ,UAAYA,EACpBuJ,EAAQ/uC,IAAMA,EACd+uC,EAAQrwC,OAASA,EACVgoC,EAMXlB,EAAY4P,EAAcj0C,EAH1B6sC,EAAS,IAAI,KAAO7sC,GACD,IAAI5F,MAE+BmD,EAAQm4B,EAAcse,EAD5Ezb,EAAMA,EAAM,GAAKA,EAAM,EAAI,EAAIA,EACkEpF,EAAQt0B,KACzG,IAAIo0C,GAAO,QAAahe,EAAM,CAC1BoP,UAAWA,EACX4E,WAAW,EACX3E,YAAY,EACZhP,UAAWA,EACXb,gBAAiBA,EACjB2P,SAAUA,EACVxP,SAAUzB,EAAQyB,SAClBC,QAAS1B,EAAQ0B,SAClBK,GAOH,OANA+d,EAAK9M,qBAAqB9B,UAAYA,EACtC4O,EAAK9M,qBAAqB0G,OAASA,EACnCoG,EAAK9M,qBAAqBzQ,aAAeA,EACzCud,EAAK9M,qBAAqB5N,IAAMA,EAChC0a,EAAK9M,qBAAqBtnC,IAAMs0B,EAAQt0B,IACxCo0C,EAAK9M,qBAAqB5oC,OAASA,EAC5B01C,EAMJ,IAAIsB,EAAc,CAErBR,WAAYA,GAEhB,gBAAkB,SAAU9e,EAAMj1B,EAAMzC,EAAQm4B,EAAcse,EAAgBzb,EAAKrD,EAAOI,EAAWb,EAAiB8Q,GAYlH,OAAOwO,EAAW9e,EAXJ,CACVj1B,KAAMA,EACNzC,OAAQA,EACRm4B,aAAcA,EACdse,eAAgBA,EAChBn1C,IAAK,EACL05B,IAAKA,EACLjD,UAAWA,EACXb,gBAAiBA,EACjB8Q,SAAUA,GAEmBrQ,K,sECnKrC,SAASsf,EAAWC,EAAeC,EAAUC,EAAYC,EAAeC,EAAiBC,GACrF,IAAI9U,EAAS,IAAIyU,EAAcM,cAC/B/U,EAAOgV,KAAKN,EAAUA,EAASO,YAC/B,IACIC,EACAC,EAFAC,EAAU,IAAIX,EAAcY,QAGhC,IACI,IAAI7M,EAAO4M,EAAQE,uBAAuBtV,GAC1C,OAAQwI,GACJ,KAAKiM,EAAcc,gBACfL,EAAW,IAAIT,EAAce,KAC7BL,EAASC,EAAQK,mBAAmBzV,EAAQkV,GAC5C,MACJ,KAAKT,EAAciB,YACfR,EAAW,IAAIT,EAAckB,WAC7BR,EAASC,EAAQQ,yBAAyB5V,EAAQkV,GAClD,MACJ,QACI,MAAM,IAAIW,MAAM,yBAAyBhpC,OAAO27B,IAExD,IAAK2M,EAAOW,OAASZ,EAASa,IAC1B,MAAM,IAAIF,MAAMV,EAAOa,aAE3B,GAAIxN,IAASiM,EAAcc,gBAAiB,CACxC,IACIU,EAAwB,EADbf,EAASgB,YAEpBjB,EAA0B,EAAbgB,EACbF,EAAMtB,EAAc0B,QAAQlB,GAChC,IACIG,EAAQgB,wBAAwBlB,EAAUD,EAAYc,GACtD,IAAIv8C,EAAU,IAAI68C,YAAYJ,GAC9Bz8C,EAAQjH,IAAI,IAAI8jD,YAAY5B,EAAc6B,QAAQtW,OAAQ+V,EAAKE,IAC/DrB,EAAcp7C,GAElB,QACIi7C,EAAc8B,MAAMR,IAG5B,IAAIS,EAAmB,SAAUC,EAAMC,EAAWC,QAC9B,IAAZA,IAAsBA,EAAU,GACpC,IAAIC,EAAgBF,EAAUG,iBAC1BC,EAAY5B,EAAS6B,aACrBC,EAAYF,EAAYF,EACxB3B,EAAa+B,EAAYtnB,aAAaunB,kBACtClB,EAAMtB,EAAc0B,QAAQlB,GAChC,IACIG,EAAQ8B,kCAAkChC,EAAUwB,EAAWjC,EAAc0C,WAAYlC,EAAYc,GACrG,IAAIqB,EAAS,IAAI1nB,aAAa+kB,EAAc6B,QAAQtW,OAAQ+V,EAAKiB,GACjE,GAAa,UAATP,GAAsC,IAAlBG,EAAqB,CAEzC,IADA,IAAIS,EAAc,IAAI3nB,aAAyB,EAAZonB,GAC1B56C,EAAI,EAAGuD,EAAI,EAAGvD,EAAIm7C,EAAYhjD,OAAQ6H,GAAK,EAAGuD,GAAKm3C,EACxDS,EAAYn7C,EAAI,GAAKk7C,EAAO33C,EAAI,GAChC43C,EAAYn7C,EAAI,GAAKk7C,EAAO33C,EAAI,GAChC43C,EAAYn7C,EAAI,GAAKk7C,EAAO33C,EAAI,GAChC43C,EAAYn7C,EAAI,GAAK,EAEzB24C,EAAgB4B,EAAMY,OAErB,CAGD,IAFIA,EAAc,IAAI3nB,aAAasnB,IACvBzkD,IAAI,IAAIm9B,aAAa+kB,EAAc6B,QAAQtW,OAAQ+V,EAAKiB,IACpD,IAAZL,EACA,IAASz6C,EAAI,EAAGA,EAAIm7C,EAAYhjD,OAAQ6H,IACpCm7C,EAAYn7C,GAAKm7C,EAAYn7C,GAAKy6C,EAG1C9B,EAAgB4B,EAAMY,IAG9B,QACI5C,EAAc8B,MAAMR,KAG5B,GAAIpB,EACA,IAAK,IAAI8B,KAAQ9B,EAAY,CACzB,IAAIj0C,EAAKi0C,EAAW8B,GAGpBD,EAAiBC,EAFDrB,EAAQkC,uBAAuBpC,EAAUx0C,GAC1Co0C,GAAYA,EAAS2B,IAAU,OAIjD,CACD,IAAIc,EAAuB,CACvB32C,SAAU,WACVjI,OAAQ,SACRxB,MAAO,QACPw5B,GAAI,aAER,IAAK,IAAI8lB,KAAQc,EAAsB,CAEnC,IAAY,KADR72C,EAAK00C,EAAQoC,eAAetC,EAAUT,EAAc8C,EAAqBd,MAGzED,EAAiBC,EADDrB,EAAQqC,aAAavC,EAAUx0C,MAM/D,QACQw0C,GACAT,EAAciD,QAAQxC,GAE1BT,EAAciD,QAAQtC,GACtBX,EAAciD,QAAQ1X,IAM9B,SAAS2X,IACL,IAAIC,EACJC,UAAY,SAAUC,GAClB,IAAIj8B,EAAOi8B,EAAMj8B,KACjB,OAAQA,EAAKnb,IACT,IAAK,OACD,IAAI00C,EAAUv5B,EAAKu5B,QACfA,EAAQ9T,MACRyW,cAAc3C,EAAQ9T,KACtBsW,EAAiBI,mBAAmB,CAAEC,WAAY7C,EAAQ6C,cAE9DC,YAAY,QACZ,MAEJ,IAAK,aACD,IAAKN,EACD,MAAM,IAAI/B,MAAM,yCAEpB+B,EAAeO,MAAK,SAAU/C,GAC1BZ,EAAWY,EAASv5B,EAAK64B,SAAU74B,EAAK84B,YAAY,SAAUn7C,GAC1D0+C,YAAY,CAAEx3C,GAAI,UAAW7M,MAAO2F,GAAW,CAACA,EAAQwmC,YACzD,SAAUyW,EAAM56B,GACfq8B,YAAY,CAAEx3C,GAAI+1C,EAAM5iD,MAAOgoB,GAAQ,CAACA,EAAKmkB,YAEjDkY,YAAY,aA0ChC,IAAIE,EAAkC,WAKlC,SAASA,EAAiBC,QACH,IAAfA,IAAyBA,EAAaD,EAAiBE,mBAC3D,IAAIlD,EAAUgD,EAAiBG,cAAcnD,QACzCoD,EAAcpD,EAAQqD,SAAWrD,EAAQsD,eAAwC,iBAAhBC,YAC/D,CACErX,IAAK,oBAAqB8T,EAAQqD,SAClCG,kBAAmB,mBAAoB,oBAAqBxD,EAAQsD,iBAEtE,CACEpX,IAAK,oBAAqB8T,EAAQyD,aAClCD,kBAAmBE,QAAQC,aAAQ7+B,IAEvCm+B,GAAgC,mBAAXW,OACrB9oD,KAAK+oD,mBAAqBT,EAAYI,kBAAkBT,MAAK,SAAUe,GACnE,IAAIC,EAAgB,GAAGtsC,OAAO2nC,EAAY,KAAK3nC,OAAO8qC,EAAQ,OAC1DyB,EAAgBC,IAAIC,gBAAgB,IAAIC,KAAK,CAACJ,GAAgB,CAAE3Q,KAAM,4BAC1E,OAAO,IAAI,IAAsB6P,GAAY,WACzC,OAAO,IAAIS,SAAQ,SAAUC,EAASS,GAClC,IAAI7B,EAAS,IAAIqB,OAAOI,GACpBK,EAAU,SAAUC,GACpB/B,EAAOgC,oBAAoB,QAASF,GACpC9B,EAAOgC,oBAAoB,UAAWC,GACtCJ,EAAOE,IAEPE,EAAY,SAAUC,GACD,SAAjBA,EAAQh+B,OACR87B,EAAOgC,oBAAoB,QAASF,GACpC9B,EAAOgC,oBAAoB,UAAWC,GACtCb,EAAQpB,KAGhBA,EAAOmC,iBAAiB,QAASL,GACjC9B,EAAOmC,iBAAiB,UAAWF,GACnCjC,EAAOO,YAAY,CACfx3C,GAAI,OACJ00C,QAAS,CACL9T,IAAKkX,EAAYlX,IACjB2W,WAAYiB,cAQhChpD,KAAK6pD,sBAAwBvB,EAAYI,kBAAkBT,MAAK,SAAUe,GACtE,IAAKV,EAAYlX,IACb,MAAM,IAAIuU,MAAM,yCAEpB,OAAO,qBAAsB2C,EAAYlX,KAAK6W,MAAK,WAC/C,OA5OQF,EA4OkBiB,EA3OnC,IAAIJ,SAAQ,SAAUC,GACzBf,mBAAmB,CAAEC,WAAYA,IAAcE,MAAK,SAAU6B,GAC1DjB,EAAQ,CAAEiB,OAAQA,UAH9B,IAA4B/B,QA2XxB,OA1IA9hD,OAAOC,eAAegiD,EAAkB,mBAAoB,CAIxD/hD,IAAK,WACD,IAAI++C,EAAUgD,EAAiBG,cAAcnD,QAC7C,SAAWA,EAAQqD,SAAWrD,EAAQsD,eAAwC,iBAAhBC,aAA6BvD,EAAQyD,cAEvGtiD,YAAY,EACZC,cAAc,IAElB4hD,EAAiB6B,qBAAuB,WACpC,MAAyB,iBAAdC,WAA2BA,UAAUC,oBAIzCznD,KAAKb,IAAIa,KAAKgI,MAAsC,GAAhCw/C,UAAUC,qBAA4B,GAHtD,GAKfhkD,OAAOC,eAAegiD,EAAkB,UAAW,CAI/C/hD,IAAK,WAID,OAHK+hD,EAAiBgC,WAClBhC,EAAiBgC,SAAW,IAAIhC,GAE7BA,EAAiBgC,UAE5B7jD,YAAY,EACZC,cAAc,IAKlB4hD,EAAiBjoD,UAAUkqD,QAAU,WAC7BnqD,KAAK+oD,oBACL/oD,KAAK+oD,mBAAmBd,MAAK,SAAUmC,GACnCA,EAAWD,oBAGZnqD,KAAK+oD,0BACL/oD,KAAK6pD,uBAMhB3B,EAAiBjoD,UAAUoqD,eAAiB,WACxC,OAAIrqD,KAAK+oD,mBACE/oD,KAAK+oD,mBAAmBd,MAAK,eAEpCjoD,KAAK6pD,sBACE7pD,KAAK6pD,sBAAsB5B,MAAK,eAEpCW,QAAQC,WASnBX,EAAiBjoD,UAAUqqD,gBAAkB,SAAU3+B,EAAM84B,EAAYG,GACrE,IAAIJ,EAAW74B,aAAgB4+B,YAAc,IAAIC,WAAW7+B,GAAQA,EACpE,GAAI3rB,KAAK+oD,mBACL,OAAO/oD,KAAK+oD,mBAAmBd,MAAK,SAAUmC,GAC1C,OAAO,IAAIxB,SAAQ,SAAUC,EAASS,GAClCc,EAAW/hD,MAAK,SAAUo/C,EAAQgD,GAC9B,IAAI7lB,EAAa,IAAI,IACjB2kB,EAAU,SAAUC,GACpB/B,EAAOgC,oBAAoB,QAASF,GACpC9B,EAAOgC,oBAAoB,UAAWC,GACtCJ,EAAOE,GACPiB,KAEAf,EAAY,SAAUC,GACtB,GAAqB,SAAjBA,EAAQh+B,KACR87B,EAAOgC,oBAAoB,QAASF,GACpC9B,EAAOgC,oBAAoB,UAAWC,GACtCb,EAAQjkB,GACR6lB,SAEC,GAAwB,YAApBd,EAAQh+B,KAAKnb,GAClBo0B,EAAWt7B,QAAUqgD,EAAQh+B,KAAKhoB,UAEjC,CAED,IAAI8iD,EAAU7B,GAAYA,EAAS+E,EAAQh+B,KAAKnb,IAAMo0C,EAAS+E,EAAQh+B,KAAKnb,IAAM,EAClF,GAAgB,IAAZi2C,EAEA,IAAK,IAAIz6C,EAAI,EAAGA,EAAI29C,EAAQh+B,KAAKhoB,MAAMQ,OAAQ6H,IAC3C29C,EAAQh+B,KAAKhoB,MAAMqI,GAAK29C,EAAQh+B,KAAKhoB,MAAMqI,GAAKy6C,EAGxD7hB,EAAWviC,IAAIsnD,EAAQh+B,KAAKhoB,MAAOgmD,EAAQh+B,KAAKnb,MAGxDi3C,EAAOmC,iBAAiB,QAASL,GACjC9B,EAAOmC,iBAAiB,UAAWF,GACnC,IAAIgB,EAAe,IAAIF,WAAWhG,EAASO,YAC3C2F,EAAaroD,IAAI,IAAImoD,WAAWhG,EAAS1U,OAAQ0U,EAASmG,WAAYnG,EAASO,aAC/E0C,EAAOO,YAAY,CAAEx3C,GAAI,aAAcg0C,SAAUkG,EAAcjG,WAAYA,GAAc,CAACiG,EAAa5a,kBAKvH,GAAI9vC,KAAK6pD,sBACL,OAAO7pD,KAAK6pD,sBAAsB5B,MAAK,SAAU/C,GAC7C,IAAItgB,EAAa,IAAI,IAMrB,OALA0f,EAAWY,EAAQ4E,OAAQtF,EAAUC,GAAY,SAAUn7C,GACvDs7B,EAAWt7B,QAAUA,KACtB,SAAUi9C,EAAM56B,GACfiZ,EAAWviC,IAAIspB,EAAM46B,KACtB3B,GACIhgB,KAGf,MAAM,IAAI+gB,MAAM,0CAQpBuC,EAAiBG,cAAgB,CAC7BnD,QAAS,CACLqD,QAAS,2DACTC,cAAe,wDACfG,YAAa,wDAMrBT,EAAiBE,kBAAoBF,EAAiB6B,uBACtD7B,EAAiBgC,SAAW,KACrBhC,EAtM0B,I,wHClKjC0C,EAAoC,WAIpC,SAASA,IACL,IAAI1F,EAAU0F,EAAmBvC,cAAcnD,QAC/CllD,KAAK6pD,sBAAwB,qBAAsB,oBAAqB3E,EAAQ9T,MAAM6W,MAAK,WAEvF,OAAO4C,eAAeC,SAqD9B,OAlDA7kD,OAAOC,eAAe0kD,EAAoB,UAAW,CAIjDzkD,IAAK,WAID,OAHKykD,EAAmBV,WACpBU,EAAmBV,SAAW,IAAIU,GAE/BA,EAAmBV,UAE9B7jD,YAAY,EACZC,cAAc,IAKlBskD,EAAmB3qD,UAAUkqD,QAAU,kBAC5BnqD,KAAK6pD,uBAYhBe,EAAmB3qD,UAAU8qD,sBAAwB,SAAU5oD,EAAQqF,EAAOsC,EAAQkhD,EAAM1b,GACxF,OAAOtvC,KAAK6pD,sBAAsB5B,MAAK,WACnC,IAAI7mD,EAAS,IAAIopD,WAAWhjD,EAAQsC,GAEpC,OADA+gD,eAAeI,iBAAiB7pD,EAAQoG,EAAOsC,EAAQ3H,EAAQ6oD,EAAM1b,GAC9DluC,MAWfwpD,EAAmBvC,cAAgB,CAC/BnD,QAAS,CACL9T,IAAK,qDAGbwZ,EAAmBV,SAAW,KACvBU,EA7D4B,I,gDCpBnCM,EAAiC,SAAUC,GAE3C,SAASD,EAAgBE,GACrB,IAAIvpC,EAAQspC,EAAOE,KAAKrrD,OAASA,KAEjC,OADA6hB,EAAMypC,QAAUF,EACTvpC,EASX,OAbA,QAAUqpC,EAAiBC,GAM3BllD,OAAOC,eAAeglD,EAAgBjrD,UAAW,qBAAsB,CACnEkG,IAAK,WACD,OAAOnG,KAAKsrD,SAEhBjlD,YAAY,EACZC,cAAc,IAEX4kD,EAdyB,C,SAelC,I,gDCfEK,EAAkC,SAAUJ,GAE5C,SAASI,EAAiBH,GACtB,IAAIvpC,EAAQspC,EAAOE,KAAKrrD,OAASA,KAEjC,OADA6hB,EAAMypC,QAAUF,EACTvpC,EASX,OAbA,QAAU0pC,EAAkBJ,GAM5BllD,OAAOC,eAAeqlD,EAAiBtrD,UAAW,qBAAsB,CACpEkG,IAAK,WACD,OAAOnG,KAAKsrD,SAEhBjlD,YAAY,EACZC,cAAc,IAEXilD,EAd0B,C,SAenC,I,+NCEEC,EACA,WACIxrD,KAAKyrD,QAAU,EACfzrD,KAAK0rD,yBAA2B,GAChC1rD,KAAK2rD,sBAAwB,KAC7B3rD,KAAK4rD,kBAAmB,EACxB5rD,KAAK6rD,gBAAkB,GACvB7rD,KAAK8rD,OAAS,WACd9rD,KAAK+rD,OAAS,CAEVnqD,IAAK,EAELnC,EAAG,EAEHC,EAAG,EAEHC,EAAG,GAEPK,KAAKgsD,gBAAiB,EACtBhsD,KAAKisD,uBAAwB,GAQjCC,EACA,WACIlsD,KAAKmsD,iBAAkB,EACvBnsD,KAAKosD,kBAAmB,EACxBpsD,KAAKqsD,oBAAsB,EAC3BrsD,KAAKssD,WAAY,EACjBtsD,KAAKusD,iBAAkB,EACvBvsD,KAAKwsD,WAAa,IAAIhB,EACtBxrD,KAAKysD,YAAc,EACnBzsD,KAAK0sD,UAAY,KACjB1sD,KAAK2sD,WAAa,UAClB3sD,KAAK4sD,2BAA4B,EACjC5sD,KAAK6sD,WAAY,EACjB7sD,KAAK8sD,mBAAoB,EACzB9sD,KAAK+sD,uBAAwB,EAC7B/sD,KAAKgtD,+BAAgC,EACrChtD,KAAKitD,mBAAoB,EACzBjtD,KAAKktD,YAAc,KACnBltD,KAAKmtD,uBAAwB,EAC7BntD,KAAKotD,qBAAuB,EAC5BptD,KAAKqtD,oBAAsB,KAC3BrtD,KAAKstD,kBAAoB,EACzBttD,KAAKutD,6BAA+B,KACpCvtD,KAAKwtD,UAAY,KACjBxtD,KAAKytD,WAAa,KAElBztD,KAAK0tD,mBAAqB,IAAI,IAC9B1tD,KAAK2tD,uBAAwB,GAOjCC,EAA8B,SAAUzC,GAQxC,SAASyC,EAAa7oB,EAAMC,QACV,IAAVA,IAAoBA,EAAQ,MAChC,IAAInjB,EAAQspC,EAAOE,KAAKrrD,KAAM+kC,EAAMC,GAAO,IAAUhlC,KAkKrD,OA/JA6hB,EAAMgsC,8BAAgC,IAAI3B,EAE1CrqC,EAAMisC,mBAAqB,KAW3BjsC,EAAMksC,gBAAkBH,EAAaI,oCAKrCnsC,EAAMosC,oBAAsB,IAAI,KAIhCpsC,EAAMqsC,oCAAsC,IAAI,KAIhDrsC,EAAMssC,4BAA8B,IAAI,KAKxCtsC,EAAMusC,sBAAuB,EAE7BvsC,EAAMwsC,gBAAkB,KAExBxsC,EAAMysC,gBAAkB,KAIxBzsC,EAAM0sC,WAAalkD,OAAOC,UAI1BuX,EAAM2sC,WAAY,EAIlB3sC,EAAM4sC,YAAa,EAInB5sC,EAAM6sC,gBAAiB,EAIvB7sC,EAAM8sC,iBAAkB,EAExB9sC,EAAM+sC,0BAA2B,EAIjC/sC,EAAMgtC,WAAY,EAIlBhtC,EAAMitC,yBAA0B,EAEhCjtC,EAAMktC,aAAe,WAErBltC,EAAMmtC,aAAe,IAErBntC,EAAMotC,aAAe,WAErBptC,EAAMqtC,aAAe,GAErBrtC,EAAMstC,gCAAiC,EAEvCttC,EAAMutC,qBAAsB,EAE5BvtC,EAAMwtC,wBAAyB,EAI/BxtC,EAAMytC,0BAA2B,EAIjCztC,EAAM0tC,uBAAwB,EAK9B1tC,EAAM2tC,cAAgB,KAKtB3tC,EAAM4tC,UAAY,IAAI,IAAQ,GAAK,EAAG,IAKtC5tC,EAAM6tC,gBAAkB,IAAI,IAAQ,EAAG,EAAG,GAM1C7tC,EAAM8tC,WAAa,EAKnB9tC,EAAM+tC,WAAa,IAAI,KAAO,EAAG,EAAG,EAAG,GAEvC/tC,EAAMguC,eAAiB,KAEvBhuC,EAAMiuC,YAAc,KACpBjuC,EAAMkuC,cAAgB,KACtBluC,EAAMmuC,sBAAuB,EAE7BnuC,EAAMouC,UAAY,EAElBpuC,EAAMquC,yBAA2B,IAAIhmD,MAErC2X,EAAMsuC,YAAa,EAEnBtuC,EAAMuuC,cAAgB,IAAIlmD,MAG1B2X,EAAMwuC,aAAe,CACjBC,KAAM,KACNC,QAAS,KACTC,kBAAmB,MAGvB3uC,EAAM4uC,wBAA0B,KAEhC5uC,EAAM6uC,wBAA0B,KAIhC7uC,EAAM8uC,oBAAsB,IAAI,KAChC9uC,EAAM+uC,2BAA6B,SAAUC,EAAaC,EAAaC,QAC9C,IAAjBA,IAA2BA,EAAe,MAC9CD,EAAY9uD,cAAc6f,EAAMgsC,8BAA8BH,mBAAmBsD,0BAA2BnvC,EAAMgsC,8BAA8BH,mBAAmBuD,4BAC/JpvC,EAAMgsC,8BAA8BH,mBAAmBuD,2BAA2B9sD,SAAW,uBAC7F0d,EAAMnR,SAAS1J,WAAW6a,EAAMgsC,8BAA8BH,mBAAmBuD,4BAEjFF,GACAlvC,EAAMosC,oBAAoBiD,gBAAgBH,GAE9ClvC,EAAMqsC,oCAAoCgD,gBAAgBrvC,EAAMnR,WAEpEmR,EAAMioB,WAAWqnB,QAAQtvC,GACzBA,EAAMuvC,sBAENvvC,EAAMwvC,eAAiB,IAAI,IAAcxvC,EAAMioB,WAAW0H,iBAAaxnB,OAAWA,EAAW+a,GAAOljB,EAAMioB,WAAW0H,YAAY8f,UACjIzvC,EAAM0vC,sBACC1vC,EAooEX,OA/yEA,QAAU+rC,EAAczC,GA6KxBllD,OAAOC,eAAe0nD,EAAc,qBAAsB,CAItDznD,IAAK,WACD,OAAO,wBAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAc,kBAAmB,CAEnDznD,IAAK,WACD,OAAO,qBAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAc,kBAAmB,CAEnDznD,IAAK,WACD,OAAO,qBAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAc,kBAAmB,CAEnDznD,IAAK,WACD,OAAO,qBAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAc,oBAAqB,CAErDznD,IAAK,WACD,OAAO,uBAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAc,6BAA8B,CAE9DznD,IAAK,WACD,OAAO,gCAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,UAAW,CAKrDkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BrB,WAAWf,SAEzDplD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,2BAA4B,CAKtEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BrB,WAAWd,0BAEzDrpD,IAAK,SAAU6yC,GACXl1C,KAAK6tD,8BAA8BrB,WAAWd,yBAA2BxW,GAE7E7uC,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,wBAAyB,CAMnEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BrB,WAAWb,uBAEzDtpD,IAAK,SAAUmvD,GACXxxD,KAAK6tD,8BAA8BrB,WAAWb,sBAAwB6F,GAE1EnrD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,sBAAuB,CAOjEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BrB,WAAWR,gBAEzD3pD,IAAK,SAAUovD,GACXzxD,KAAK6tD,8BAA8BrB,WAAWR,eAAiByF,GAEnEprD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,qBAAsB,CAOhEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BrB,WAAWkF,oBAEzDrvD,IAAK,SAAUsvD,GACX3xD,KAAK6tD,8BAA8BrB,WAAWkF,mBAAqBC,GAEvEtrD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,sBAAuB,CAEjEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BT,sBAE9C/qD,IAAK,SAAUuvD,GACX5xD,KAAK6tD,8BAA8BT,qBAAuBwE,GAE9DvrD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,qBAAsB,CAKhEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BrB,WAAWZ,kBAEzDvlD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,qBAAsB,CAKhEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BR,qBAE9ChrD,IAAK,SAAUsB,GACP3D,KAAK6tD,8BAA8BR,sBAAwB1pD,IAG/D3D,KAAK6tD,8BAA8BR,oBAAsB1pD,EACzD3D,KAAK6xD,wCAETxrD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,8BAA+B,CAKzEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BN,8BAE9ClrD,IAAK,SAAUsB,GACP3D,KAAK6tD,8BAA8BN,+BAAiC5pD,IAGxE3D,KAAK6tD,8BAA8BN,6BAA+B5pD,EAClE3D,KAAK8xD,oCAETzrD,YAAY,EACZC,cAAc,IAGlBsnD,EAAa3tD,UAAU4xD,oCAAsC,aAK7DjE,EAAa3tD,UAAU8xD,8BAAgC,SAAUpuD,GAC7D,QAAKwnD,EAAOlrD,UAAU8xD,8BAA8B1G,KAAKrrD,KAAM2D,KAG/D3D,KAAKgyD,6BACE,IAEX/rD,OAAOC,eAAe0nD,EAAa3tD,UAAW,YAAa,CAEvDoC,IAAK,SAAU4vD,GACPjyD,KAAK6tD,8BAA8BH,mBAAmBwE,oBACtDlyD,KAAKiuD,oBAAoBkE,OAAOnyD,KAAK6tD,8BAA8BH,mBAAmBwE,oBAE1FlyD,KAAK6tD,8BAA8BH,mBAAmBwE,mBAAqBlyD,KAAKiuD,oBAAoBpsD,IAAIowD,IAE5G5rD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,4BAA6B,CAEvEoC,IAAK,SAAU4vD,GACPjyD,KAAK6tD,8BAA8BH,mBAAmB0E,oCACtDpyD,KAAKkuD,oCAAoCiE,OAAOnyD,KAAK6tD,8BAA8BH,mBAAmB0E,oCAE1GpyD,KAAK6tD,8BAA8BH,mBAAmB0E,mCAAqCpyD,KAAKkuD,oCAAoCrsD,IAAIowD,IAE5I5rD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,aAAc,CAIxDkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BpB,aAK9CpqD,IAAK,SAAUsB,GACX,GAAI3D,KAAK6tD,8BAA8BpB,cAAgB9oD,EAAvD,CAGA,IAAI0uD,EAAWryD,KAAK6tD,8BAA8BpB,YAClDzsD,KAAK6tD,8BAA8BpB,YAAc9oD,GAC/B,IAAb0uD,GAA4B,IAAV1uD,GAA8B,IAAb0uD,GAA4B,IAAV1uD,IACtD3D,KAAKgyD,8BAGb3rD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,mBAAoB,CAK9DkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BP,mBAE9CjrD,IAAK,SAAUsB,GACX3D,KAAK6tD,8BAA8BP,kBAAoB3pD,GAE3D0C,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,WAAY,CAEtDkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BL,WAE9CnrD,IAAK,SAAUsB,GACP3D,KAAK6tD,8BAA8BL,YAAc7pD,IAIjD3D,KAAK6tD,8BAA8BL,WAAaxtD,KAAK6tD,8BAA8BL,UAAU8E,UAC7FtyD,KAAK6tD,8BAA8BL,UAAU8E,QAAQtyD,KAAKuyD,eAAYvoC,GAE1EhqB,KAAK6tD,8BAA8BL,UAAY7pD,EAC3CA,GAASA,EAAM2uD,UACf3uD,EAAM2uD,QAAQtyD,KAAKuyD,UAAYvyD,MAE/BA,KAAKmuD,4BAA4BqE,gBACjCxyD,KAAKmuD,4BAA4B+C,gBAAgBlxD,MAEhDA,KAAKyyD,YAGVzyD,KAAK0yD,iBACL1yD,KAAK2yD,mBAETtsD,YAAY,EACZC,cAAc,IAOlBsnD,EAAa3tD,UAAU2yD,yBAA2B,SAAUC,GACxD,IAAI9oD,EACJ,OAA4E,QAApEA,EAAK/J,KAAK6tD,8BAA8BiF,8BAA2C,IAAP/oD,OAAgB,EAASA,EAAG8oD,IAOpHjF,EAAa3tD,UAAU8yD,yBAA2B,SAAUF,EAAcjd,GACtE51C,KAAK0yD,eAAeG,GACf7yD,KAAK6tD,8BAA8BiF,yBACpC9yD,KAAK6tD,8BAA8BiF,uBAAyB,IAEhE9yD,KAAK6tD,8BAA8BiF,uBAAuBD,GAAgBjd,GAE9E3vC,OAAOC,eAAe0nD,EAAa3tD,UAAW,iBAAkB,CAK5DkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BtB,iBAE9ClqD,IAAK,SAAUsB,GACP3D,KAAK6tD,8BAA8BtB,kBAAoB5oD,IAG3D3D,KAAK6tD,8BAA8BtB,gBAAkB5oD,EACrD3D,KAAKgzD,+BAET3sD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,iBAAkB,CAE5DkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8B1B,iBAE9C9pD,IAAK,SAAUsB,GACP3D,KAAK6tD,8BAA8B1B,kBAAoBxoD,IAG3D3D,KAAK6tD,8BAA8B1B,gBAAkBxoD,EACrD3D,KAAK8xD,kCACL9xD,KAAKgyD,8BAET3rD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,kBAAmB,CAE7DkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BzB,kBAE9C/pD,IAAK,SAAUsB,GACP3D,KAAK6tD,8BAA8BzB,mBAAqBzoD,IAG5D3D,KAAK6tD,8BAA8BzB,iBAAmBzoD,EACtD3D,KAAK8xD,oCAETzrD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,2BAA4B,CAItEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BjB,2BAE9CvqD,IAAK,SAAUsB,GACP3D,KAAK6tD,8BAA8BjB,4BAA8BjpD,IAGrE3D,KAAK6tD,8BAA8BjB,0BAA4BjpD,EAC/D3D,KAAK8xD,oCAETzrD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,qBAAsB,CAEhEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BxB,qBAE9ChqD,IAAK,SAAUsB,GACP3D,KAAK6tD,8BAA8BxB,sBAAwB1oD,IAG/D3D,KAAK6tD,8BAA8BxB,oBAAsB1oD,EACzD3D,KAAK8xD,oCAETzrD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,WAAY,CAEtDkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BvB,WAE9CjqD,IAAK,SAAUsB,GACP3D,KAAK6tD,8BAA8BvB,YAAc3oD,IAGrD3D,KAAK6tD,8BAA8BvB,UAAY3oD,EAC/C3D,KAAKgyD,8BAET3rD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,uBAAwB,CAElEkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BF,uBAE9CtrD,IAAK,SAAUsB,GACX3D,KAAK6tD,8BAA8BF,sBAAwBhqD,GAE/D0C,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,YAAa,CAKvDkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BlB,YAE9CtqD,IAAK,SAAUsB,GACPA,IAAU3D,KAAK6tD,8BAA8BlB,aAGjD3sD,KAAK6tD,8BAA8BlB,WAAahpD,EAChD3D,KAAKoxD,wBAET/qD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,gBAAiB,CAK3DkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BH,mBAAmBuF,gBAEjE5wD,IAAK,SAAU6wD,GACXlzD,KAAK6tD,8BAA8BH,mBAAmBuF,eAAkB14C,MAAM24C,IAAgB,EAARA,GAE1F7sD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,oBAAqB,CAO/DkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BH,mBAAmByF,oBAEjE9wD,IAAK,SAAU+wD,GACXpzD,KAAK6tD,8BAA8BH,mBAAmByF,mBAAqBC,GAE/E/sD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,iBAAkB,CAK5DkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BH,mBAAmB2F,iBAEjEhxD,IAAK,SAAU6wD,GACXlzD,KAAK6tD,8BAA8BH,mBAAmB2F,gBAAmB94C,MAAM24C,IAAgB,EAARA,GAE3F7sD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,oBAAqB,CAU/DkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BH,mBAAmB4F,oBAEjEjxD,IAAK,SAAUkxD,GACXvzD,KAAK6tD,8BAA8BH,mBAAmB4F,mBAAqBC,GAE/EltD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,eAAgB,CAE1DkG,IAAK,WACD,OAAOnG,KAAKowD,eAEhB/pD,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,aAAc,CAExDkG,IAAK,WACD,OAAO,MAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,WAAY,CACtDkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BnB,WAM9CrqD,IAAK,SAAUsB,GACX,IAAI6vD,EAAWxzD,KAAK6tD,8BAA8BnB,UAC9C8G,GAAYA,EAASC,uBACrBD,EAASE,8BAA8B1zD,MAEvC2D,GAASA,EAAM8vD,uBACf9vD,EAAMgwD,4BAA4B3zD,MAEtCA,KAAK6tD,8BAA8BnB,UAAY/oD,EAC1C3D,KAAK6tD,8BAA8BnB,YACpC1sD,KAAKywD,wBAA0B,MAEnCzwD,KAAK8xD,mCAETzrD,YAAY,EACZC,cAAc,IAElBsnD,EAAa3tD,UAAUsxD,oBAAsB,WACzCvxD,KAAKqxD,eAAeuC,WAAW,QAAS,IACxC5zD,KAAKqxD,eAAeuC,WAAW,aAAc,GAC7C5zD,KAAKqxD,eAAewC,UAMxBjG,EAAa3tD,UAAU6zD,iBAAmB,SAAU3tC,GAChD,IAAI4tC,EAAM/zD,KAAKqxD,eACf0C,EAAIC,aAAa,QAAS7tC,GAC1B4tC,EAAIE,YAAY,aAAcj0D,KAAK6tD,8BAA8BpB,aACjEsH,EAAIjhD,UAMR86C,EAAa3tD,UAAUi0D,qBAAuB,WAC1C,OAAOl0D,KAAKqxD,gBAMhBzD,EAAa3tD,UAAUE,aAAe,WAClC,MAAO,gBAOXytD,EAAa3tD,UAAUC,SAAW,SAAUi0D,GACxC,IAAIC,EAAM,SAAWp0D,KAAK+kC,KAAO,kBAA4C,kBAAxB/kC,KAAKG,eAAqC,MAAQ,MACvGi0D,GAAO,sBAAwBp0D,KAAKyyD,UAAYzyD,KAAKyyD,UAAUtuD,OAAS,GACxE,IAAIqvD,EAAWxzD,KAAK6tD,8BAA8BnB,UAQlD,OAPI8G,IACAY,GAAO,eAAiBZ,EAASzuB,MAEjCovB,IACAC,GAAO,qBAAuB,CAAC,OAAQ,IAAK,IAAK,KAAM,IAAK,KAAM,KAAM,OAAOp0D,KAAKq0D,eACpFD,GAAO,uBAAyBp0D,KAAKs0D,sBAAwBt0D,KAAKqwD,aAAaG,kBAAoB,MAAQ,OAExG4D,GAKXxG,EAAa3tD,UAAUs0D,oBAAsB,WACzC,OAAIv0D,KAAK8vD,aAAe9vD,KAAKq0D,gBAAkB,uBACpCr0D,KAAK8vD,YAET3E,EAAOlrD,UAAUs0D,oBAAoBlJ,KAAKrrD,OAOrD4tD,EAAa3tD,UAAUu0D,4BAA8B,SAAUC,EAASC,GAEpE,QADoB,IAAhBA,IAA0BA,GAAc,GACxC10D,KAAKwvD,gBAAkBkF,GAAe10D,KAAKwvD,cAAcmF,aAAc,CACvE,IAAIF,EAMA,OAAOz0D,KAAKwvD,cALZ,GAAIxvD,KAAKwvD,cAAcoF,mBAAmBH,GACtC,OAAOz0D,KAAKwvD,cAOxB,OAAKxvD,KAAK+xC,OAGH/xC,KAAK+xC,OAAOyiB,4BAA4BC,GAAS,GAF7C,MASf7G,EAAa3tD,UAAU40D,SAAW,SAAU1K,GAMxC,QALgB,IAAZA,IAAsBA,GAAU,GACpCnqD,KAAK2wD,oBAAoBO,gBAAgBlxD,MACZ,OAAzBA,KAAKquD,kBACLruD,KAAKquD,gBAAkB,MAEtBruD,KAAKyyD,UAGV,IAAK,IAAIzoD,EAAK,EAAGD,EAAK/J,KAAKyyD,UAAWzoD,EAAKD,EAAG5F,OAAQ6F,IAAM,CAC1CD,EAAGC,GACT6qD,aAIhBjH,EAAa3tD,UAAUmxD,oBAAsB,WACzCpxD,KAAKowD,cAAcjsD,OAAS,EAC5B,IAAK,IAAI6F,EAAK,EAAGD,EAAK/J,KAAK8pC,WAAWgrB,OAAQ9qD,EAAKD,EAAG5F,OAAQ6F,IAAM,CAChE,IAAI+qD,EAAQhrD,EAAGC,GACV+qD,EAAMC,cAGPD,EAAME,cAAcj1D,OACpBA,KAAKowD,cAAc/nD,KAAK0sD,IAGhC/0D,KAAKgzD,8BAMTpF,EAAa3tD,UAAUi1D,mBAAqB,SAAUH,GAClD,IAAII,EAAOJ,EAAMC,aAAeD,EAAME,cAAcj1D,MAChDQ,EAAQR,KAAKowD,cAAcgF,QAAQL,GACnCM,GAAU,EACd,IAAe,IAAX70D,EAAc,CACd,IAAK20D,EACD,OAEJn1D,KAAKowD,cAAc/nD,KAAK0sD,OAEvB,CACD,GAAII,EACA,OAEJE,GAAU,EACVr1D,KAAKowD,cAAckF,OAAO90D,EAAO,GAErCR,KAAKgzD,2BAA2BqC,IAGpCzH,EAAa3tD,UAAU0yD,cAAgB,WACnC,IAAK,IAAI3oD,EAAK,EAAGD,EAAK/J,KAAKyyD,UAAWzoD,EAAKD,EAAG5F,OAAQ6F,IAAM,CAC1CD,EAAGC,GACTurD,UAAU,QAQ1B3H,EAAa3tD,UAAUu1D,mBAAqB,SAAUT,EAAO5K,GACzD,IAAI3pD,EAAQR,KAAKowD,cAAcgF,QAAQL,IACxB,IAAXv0D,IAGJR,KAAKowD,cAAckF,OAAO90D,EAAO,GACjCR,KAAKgzD,2BAA2B7I,KAEpCyD,EAAa3tD,UAAUw1D,sBAAwB,SAAUC,GACrD,GAAK11D,KAAKyyD,UAGV,IAAK,IAAIzoD,EAAK,EAAGD,EAAK/J,KAAKyyD,UAAWzoD,EAAKD,EAAG5F,OAAQ6F,IAElD,IADA,IAAI2rD,EAAU5rD,EAAGC,GACRgC,EAAI,EAAGA,EAAI2pD,EAAQC,cAAczxD,SAAU6H,EAAG,CACnD,IAAI6pD,EAAcF,EAAQC,cAAc5pD,GACnC6pD,GAAgBA,EAAYC,SAAYD,EAAYC,QAAQC,gBAGjEL,EAAKG,EAAYC,WAQ7BlI,EAAa3tD,UAAU+yD,2BAA6B,SAAU7I,QAC1C,IAAZA,IAAsBA,GAAU,GACpCnqD,KAAKy1D,uBAAsB,SAAUK,GAAW,OAAOA,EAAQE,iBAAiB7L,OAGpFyD,EAAa3tD,UAAU6xD,gCAAkC,WACrD9xD,KAAKy1D,uBAAsB,SAAUK,GAAW,OAAOA,EAAQG,4BAGnErI,EAAa3tD,UAAU+xD,0BAA4B,WAC/ChyD,KAAKy1D,uBAAsB,SAAUK,GAAW,OAAOA,EAAQI,sBAQnEtI,EAAa3tD,UAAUk2D,YAAc,SAAUC,GAG3C,OAFAp2D,KAAKq2D,iBAAmBhsD,OAAOC,UAC/BtK,KAAK0f,UAAW,EACT1f,MAMX4tD,EAAa3tD,UAAUyyD,eAAiB,SAAU4D,GAC9C,GAAKt2D,KAAKyyD,UAGV,IAAK,IAAIzoD,EAAK,EAAGD,EAAK/J,KAAKyyD,UAAWzoD,EAAKD,EAAG5F,OAAQ6F,IAAM,CAC1CD,EAAGC,GACT0oD,eAAe4D,KAG/BrwD,OAAOC,eAAe0nD,EAAa3tD,UAAW,YAAa,CAKvDkG,IAAK,WACD,OAAO,GAEXE,YAAY,EACZC,cAAc,IAQlBsnD,EAAa3tD,UAAUs2D,OAAS,SAAU1sB,GACtC,OAAO7pC,MAMX4tD,EAAa3tD,UAAUu2D,iBAAmB,WACtC,OAAO,GAMX5I,EAAa3tD,UAAUw2D,gBAAkB,WACrC,OAAO,GAMX7I,EAAa3tD,UAAU0pC,WAAa,WAChC,OAAO,MAQXikB,EAAa3tD,UAAU2pC,gBAAkB,SAAU2c,GAC/C,OAAO,MA0BXqH,EAAa3tD,UAAUy2D,gBAAkB,SAAUnQ,EAAM56B,EAAMyZ,EAAWt7B,GACtE,OAAO9J,MAwBX4tD,EAAa3tD,UAAUu1C,mBAAqB,SAAU+Q,EAAM56B,EAAMgrC,EAAeC,GAC7E,OAAO52D,MAUX4tD,EAAa3tD,UAAU42D,WAAa,SAAUvtD,EAASwtD,GACnD,OAAO92D,MAQX4tD,EAAa3tD,UAAU82D,sBAAwB,SAAUxQ,GACrD,OAAO,GAQXqH,EAAa3tD,UAAUk7C,gBAAkB,WACrC,OAAIn7C,KAAK8vD,YACE9vD,KAAK8vD,YAAY3U,mBAExBn7C,KAAKgwD,uBACLhwD,KAAKgwD,sBAAuB,EAE5BhwD,KAAKg3D,uBAGFh3D,KAAK+vD,gBAOhBnC,EAAa3tD,UAAUg3D,gBAAkB,SAAUC,GAE/C,OADAl3D,KAAK+vD,cAAgBmH,EACdl3D,MAEXiG,OAAOC,eAAe0nD,EAAa3tD,UAAW,kBAAmB,CAI7DkG,IAAK,WACD,OAA8B,OAAvBnG,KAAK+vD,eAEhB1pD,YAAY,EACZC,cAAc,IASlBsnD,EAAa3tD,UAAUq7C,kBAAoB,SAAU7xC,EAASC,EAASytD,GAEnE,OADAn3D,KAAK+vD,cAAgB,IAAI,IAAatmD,EAASC,EAASytD,GACjDn3D,KAAK+vD,eAShBnC,EAAa3tD,UAAUm3D,oBAAsB,SAAUC,EAAoBC,EAAgBC,GAGvF,YAF2B,IAAvBF,IAAiCA,GAAqB,QACnC,IAAnBC,IAA6BA,GAAiB,GAC3CnM,EAAOlrD,UAAUm3D,oBAAoB/L,KAAKrrD,KAAMq3D,EAAoBC,EAAgBC,IAE/FtxD,OAAOC,eAAe0nD,EAAa3tD,UAAW,WAAY,CAEtDkG,IAAK,WACD,OAASnG,KAAKwzD,UACVxzD,KAAK8pC,WAAW0tB,kBAChBx3D,KAAK+2D,sBAAsB,0BAC3B/2D,KAAK+2D,sBAAsB,0BAEnC1wD,YAAY,EACZC,cAAc,IAGlBsnD,EAAa3tD,UAAUw3D,aAAe,aAMtC7J,EAAa3tD,UAAUy3D,qCAAuC,SAAUC,KAOxE/J,EAAa3tD,UAAU23D,UAAY,SAAUD,EAAUE,GAEnD,OADA73D,KAAKiwD,UAAY0H,GACV,GAGX/J,EAAa3tD,UAAU63D,cAAgB,aAIvClK,EAAa3tD,UAAU83D,QAAU,aAIjCnK,EAAa3tD,UAAU+3D,UAAY,aAOnCpK,EAAa3tD,UAAUgqC,eAAiB,WACpC,OAAIjqC,KAAK8vD,aAAe9vD,KAAKq0D,gBAAkB,uBACpCr0D,KAAK8vD,YAAY7lB,iBAErBkhB,EAAOlrD,UAAUgqC,eAAeohB,KAAKrrD,OAGhD4tD,EAAa3tD,UAAUg4D,2BAA6B,WAChD,OAAIj4D,KAAK8vD,YACE9vD,KAAK8vD,YAAYmI,6BAErB9M,EAAOlrD,UAAUg4D,2BAA2B5M,KAAKrrD,OAE5DiG,OAAOC,eAAe0nD,EAAa3tD,UAAW,eAAgB,CAI1DkG,IAAK,WACD,OAAO,GAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,eAAgB,CAI1DkG,IAAK,WACD,OAAO,GAEXE,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,mBAAoB,CAI9DkG,IAAK,WACD,OAAO,GAEXE,YAAY,EACZC,cAAc,IAYlBsnD,EAAa3tD,UAAUi4D,QAAU,SAAUC,EAAaC,EAAUC,GAE9D,OADAr4D,KAAK0Q,SAAS1J,WAAWhH,KAAKs4D,YAAYH,EAAaC,EAAUC,IAC1Dr4D,MAWX4tD,EAAa3tD,UAAUq4D,YAAc,SAAUH,EAAaC,EAAUC,GAClE,IAAIE,EAAY,IAAI,MACAv4D,KAAK02B,mBAAqB12B,KAAK02B,mBAAqB,0BAAgC12B,KAAK0pB,SAAShhB,EAAG1I,KAAK0pB,SAAS7lB,EAAG7D,KAAK0pB,SAAS/gB,IAC1IuM,iBAAiBqjD,GAC/B,IAAIC,EAAmB,WACnBC,EAAiBz4D,KAAKouD,sBAAwB,EAAI,EAEtD,OADA,wCAA4C+J,EAAcM,EAAgBL,EAAUC,EAAgBI,EAAgBF,EAAWC,GACxHA,GAWX5K,EAAa3tD,UAAUy4D,UAAY,SAAUC,EAAUC,EAAgBC,GAEnE,OADA74D,KAAK0pB,SAAS1iB,WAAWhH,KAAK84D,cAAcH,EAAUC,EAAgBC,IAC/D74D,MAUX4tD,EAAa3tD,UAAU64D,cAAgB,SAAUH,EAAUC,EAAgBC,GACvE,IAAIJ,EAAiBz4D,KAAKouD,qBAAuB,GAAK,EACtD,OAAO,IAAI,IAAQuK,EAAWF,EAAgBG,EAAgBC,EAAYJ,IAS9E7K,EAAa3tD,UAAU84D,oBAAsB,SAAUC,EAAeC,GAGlE,YAFsB,IAAlBD,IAA4BA,GAAgB,QAC7B,IAAfC,IAAyBA,GAAa,GACtCj5D,KAAK+vD,eAAiB/vD,KAAK+vD,cAAcmJ,UAG7Cl5D,KAAKm5D,qBAAqBn5D,KAAKo5D,iBAAiBJ,EAAeC,GAAa,MAFjEj5D,MAUf4tD,EAAa3tD,UAAUk5D,qBAAuB,SAAUxtC,EAAMvhB,GAC1D,GAAIuhB,EAAM,CACN,IAAI0tC,GAAS,OAAiB1tC,EAAM,EAAG3rB,KAAKw2D,mBAAoBpsD,GAC5DpK,KAAK+vD,cACL/vD,KAAK+vD,cAAc3U,YAAYie,EAAO5vD,QAAS4vD,EAAO3vD,SAGtD1J,KAAK+vD,cAAgB,IAAI,IAAasJ,EAAO5vD,QAAS4vD,EAAO3vD,SAGrE,GAAI1J,KAAKyyD,UACL,IAAK,IAAIjyD,EAAQ,EAAGA,EAAQR,KAAKyyD,UAAUtuD,OAAQ3D,IAC/CR,KAAKyyD,UAAUjyD,GAAOu4D,oBAAoBptC,GAGlD3rB,KAAKg3D,uBASTpJ,EAAa3tD,UAAUq5D,SAAW,SAAUN,EAAeC,EAAYttC,EAAM46B,GAKzE,QAJsB,IAAlByS,IAA4BA,GAAgB,QAC7B,IAAfC,IAAyBA,GAAa,QAC7B,IAAT1S,IAAmBA,EAAO,mBAC9B56B,EAAOA,QAAmCA,EAAO3rB,KAAK4pC,gBAAgB2c,GAAMh0C,UAChE0mD,GAAcj5D,KAAKu5D,mBAG3B,IAFA,IAAIC,EAAiB,EACjBC,EAAgB,EACXC,EAAc,EAAGA,EAAc/tC,EAAKxnB,OAAQu1D,IAAe,CAChE,IAAK,IAAIC,EAAc,EAAGA,EAAc35D,KAAKu5D,mBAAmBK,WAAYD,IAAe,CACvF,IAAIE,EAAc75D,KAAKu5D,mBAAmBO,UAAUH,GAChDI,EAAYF,EAAYE,UAC5B,GAAIA,EAAY,EAAK,CACjB,IAAIC,EAAuBH,EAAYI,eACnCD,IACAruC,EAAK+tC,KAAiBM,EAAqBN,GAAe/tC,EAAK+tC,IAAgBK,IAK3F,GADAP,IACIjT,IAAS,kBACLvmD,KAAKytD,YAAiC,IAAnB+L,EAAsB,CAEzCA,EAAiB,EACjB,IAAIh5D,EAAwB,EAAhBi5D,EACZz5D,KAAKytD,WAAWgM,KAAiBr3D,eAAeupB,EAAKnrB,GAAQmrB,EAAKnrB,EAAQ,GAAImrB,EAAKnrB,EAAQ,KAK3G,GAAImrB,GAAQqtC,GAAiBh5D,KAAKwzD,SAAU,CACxC,IAAI0G,EAAsBl6D,KAAK4pC,gBAAgB,yBAC3CuwB,EAAsBn6D,KAAK4pC,gBAAgB,yBAC/C,GAAIuwB,GAAuBD,EACvB,KAAIE,EAAap6D,KAAKq6D,mBAAqB,EACvCC,EAA2BF,EAAap6D,KAAK4pC,gBAAgB,8BAAyC,KACtG2wB,EAA2BH,EAAap6D,KAAK4pC,gBAAgB,8BAAyC,KACtG4wB,EAAmBx6D,KAAKwzD,SAASiH,qBAAqBz6D,MACtD06D,EAAa,gBACbC,EAAc,eACdC,EAAa,eACbC,EAAe,EACnB,IAASr6D,EAAQ,EAAGA,EAAQmrB,EAAKxnB,OAAQ3D,GAAS,EAAGq6D,GAAgB,EAAG,CACpEF,EAAYlpC,QACZ,IAAIqpC,OAAM,EACNC,OAAS,EACb,IAAKD,EAAM,EAAGA,EAAM,EAAGA,KACnBC,EAASZ,EAAoBU,EAAeC,IAC/B,IACT,iCAAmCN,EAAkBh4D,KAAKgI,MAAgD,GAA1C0vD,EAAoBW,EAAeC,IAAYC,EAAQH,GACvHD,EAAY/oC,UAAUgpC,IAG9B,GAAIR,EACA,IAAKU,EAAM,EAAGA,EAAM,EAAGA,KACnBC,EAASR,EAAyBM,EAAeC,IACpC,IACT,iCAAmCN,EAAkBh4D,KAAKgI,MAAqD,GAA/C8vD,EAAyBO,EAAeC,IAAYC,EAAQH,GAC5HD,EAAY/oC,UAAUgpC,IAI9BrU,IAAS,eACT,mCAAuC56B,EAAKnrB,GAAQmrB,EAAKnrB,EAAQ,GAAImrB,EAAKnrB,EAAQ,GAAIm6D,EAAaD,GAGnG,wCAA4C/uC,EAAKnrB,GAAQmrB,EAAKnrB,EAAQ,GAAImrB,EAAKnrB,EAAQ,GAAIm6D,EAAaD,GAE5GA,EAAWp6D,QAAQqrB,EAAMnrB,GACrB+lD,IAAS,kBAA6BvmD,KAAKytD,YAC3CztD,KAAKytD,WAAWjtD,EAAQ,GAAG0B,SAASw4D,KAKpD,OAAO/uC,GAQXiiC,EAAa3tD,UAAU+6D,eAAiB,SAAUhC,EAAeC,GAG7D,YAFsB,IAAlBD,IAA4BA,GAAgB,QAC7B,IAAfC,IAAyBA,GAAa,GACnCj5D,KAAKs5D,SAASN,EAAeC,EAAY,KAAM,iBAS1DrL,EAAa3tD,UAAUg7D,gBAAkB,SAAUjC,EAAeC,EAAYttC,GAG1E,YAFsB,IAAlBqtC,IAA4BA,GAAgB,QAC7B,IAAfC,IAAyBA,GAAa,GACnCj5D,KAAKs5D,SAASN,EAAeC,EAAYttC,EAAM,mBAO1DiiC,EAAa3tD,UAAUm5D,iBAAmB,SAAUJ,EAAeC,GAC/D,IAAIlvD,EACA4hB,EAAO3rB,KAAK4pC,gBAAgB,kBAIhC,GAHI5pC,KAAK6tD,8BAA8BJ,aACnCztD,KAAK6tD,8BAA8BJ,WAAa,MAEhD9hC,IAAUqtC,GAAiBh5D,KAAKwzD,UAAcyF,GAAcj5D,KAAKu5D,oBAAsB,CAGvF,GAFA5tC,EAAOA,EAAKpZ,QACZvS,KAAKk7D,uBACDl7D,KAAKytD,WAAY,CACjB,IAAI9d,EAAM3vC,KAAKytD,WACfztD,KAAK6tD,8BAA8BJ,WAAa,IAAIvjD,MAAMylC,EAAIxrC,QAC9D,IAAK,IAAI6H,EAAI,EAAGA,EAAI2jC,EAAIxrC,OAAQ6H,IAC5BhM,KAAK6tD,8BAA8BJ,WAAWzhD,IAAwB,QAAjBjC,EAAK4lC,EAAI3jC,UAAuB,IAAPjC,OAAgB,EAASA,EAAG9H,UAAY,IAAI,IAGlI,OAAOjC,KAAKi7D,gBAAgBjC,EAAeC,EAAYttC,GAE3D,OAAOA,GAGXiiC,EAAa3tD,UAAU+2D,oBAAsB,WAQzC,OAPIh3D,KAAK+vD,cACL/vD,KAAK+vD,cAAcj9C,OAAO9S,KAAKm7D,sBAG/Bn7D,KAAK+vD,cAAgB,IAAI,IAAa,WAAgB,WAAgB/vD,KAAKm7D,sBAE/En7D,KAAKo7D,6BAA6Bp7D,KAAKm7D,sBAChCn7D,MAMX4tD,EAAa3tD,UAAUm7D,6BAA+B,SAAUx0C,GAC5D,IAAK5mB,KAAKyyD,UACN,OAAOzyD,KAGX,IADA,IAAIwH,EAAQxH,KAAKyyD,UAAUtuD,OAClBk3D,EAAW,EAAGA,EAAW7zD,EAAO6zD,IAAY,CACjD,IAAI1F,EAAU31D,KAAKyyD,UAAU4I,IACzB7zD,EAAQ,IAAMmuD,EAAQ2F,WACtB3F,EAAQ4F,mBAAmB30C,GAGnC,OAAO5mB,MAGX4tD,EAAa3tD,UAAUu7D,yBAA2B,WAC1Cx7D,KAAKuvD,wBAITvvD,KAAKgwD,sBAAuB,IAQhCpC,EAAa3tD,UAAUw7D,YAAc,SAAUrzD,GAC3C,OAAOpI,KAAKm7C,kBAAkBsgB,YAAYrzD,EAAepI,KAAK+tD,kBAQlEH,EAAa3tD,UAAUy7D,sBAAwB,SAAUtzD,GACrD,OAAOpI,KAAKm7C,kBAAkBugB,sBAAsBtzD,IASxDwlD,EAAa3tD,UAAU07D,eAAiB,SAAU9gB,EAAM+gB,EAASvE,QAC7C,IAAZuE,IAAsBA,GAAU,GACpC,IAAI1E,EAAel3D,KAAKm7C,kBACpB0gB,EAAoBhhB,EAAKM,kBAC7B,GAAI+b,EAAa4E,WAAWD,EAAmBD,GAC3C,OAAO,EAEX,GAAIvE,EACA,IAAK,IAAIrtD,EAAK,EAAGD,EAAK/J,KAAK+7D,iBAAkB/xD,EAAKD,EAAG5F,OAAQ6F,IAAM,CAE/D,GADYD,EAAGC,GACL2xD,eAAe9gB,EAAM+gB,GAAS,GACpC,OAAO,EAInB,OAAO,GAOXhO,EAAa3tD,UAAU+7D,gBAAkB,SAAU9wD,GAC/C,OAAOlL,KAAKm7C,kBAAkB6gB,gBAAgB9wD,IAElDjF,OAAOC,eAAe0nD,EAAa3tD,UAAW,kBAAmB,CAM7DkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BH,mBAAmBuO,kBAEjE55D,IAAK,SAAU65D,GACXl8D,KAAK6tD,8BAA8BH,mBAAmBuO,iBAAmBC,GAE7E71D,YAAY,EACZC,cAAc,IAElBL,OAAOC,eAAe0nD,EAAa3tD,UAAW,WAAY,CAKtDkG,IAAK,WACD,OAAOnG,KAAK6tD,8BAA8BH,mBAAmByO,WAEjE91D,YAAY,EACZC,cAAc,IAQlBsnD,EAAa3tD,UAAUm8D,mBAAqB,SAAUC,GAC7Br8D,KAAKs8D,sBACXx6D,SAAS9B,KAAK0vD,gBAAiB1vD,KAAK6tD,8BAA8BH,mBAAmBsD,2BACpG,IAAIuL,EAAcv8D,KAAK8pC,WAAW0yB,qBAMlC,OALKx8D,KAAK6tD,8BAA8BH,mBAAmByO,YACvDn8D,KAAK6tD,8BAA8BH,mBAAmByO,UAAYI,EAAYE,kBAElFz8D,KAAK6tD,8BAA8BH,mBAAmByO,UAAUn1B,QAAUhnC,KAAKyvD,UAC/E8M,EAAYG,eAAe18D,KAAK6tD,8BAA8BH,mBAAmBsD,0BAA2BqL,EAAcr8D,KAAK6tD,8BAA8BH,mBAAmByO,UAAWn8D,KAAK28D,oBAAqB38D,KAAMA,KAAK4wD,2BAA4B5wD,KAAKuyD,UAC1PvyD,MASX4tD,EAAa3tD,UAAU28D,mBAAqB,SAAUjH,EAAStrB,EAAiBwyB,GAC5E,IAAI9yD,EAEJ,GADA/J,KAAKk7D,wBACAl7D,KAAKytD,WACN,OAAOztD,KAGX,IAAK21D,EAAQmH,6BAA+BnH,EAAQoH,6BAA6B17D,OAAOgpC,GAAkB,CACtGsrB,EAAQoH,6BAA+B1yB,EAAgBpoC,QACvD0zD,EAAQmH,2BAA6B,GACrCnH,EAAQqH,gBAAkB,GAG1B,IAFA,IAAIx4D,EAAQmxD,EAAQsH,cAChBx4D,EAAMkxD,EAAQsH,cAAgBtH,EAAQ7W,cACjC9yC,EAAIxH,EAAOwH,EAAIvH,EAAKuH,IACzB2pD,EAAQmH,2BAA2Bz0D,KAAK,yBAA6BrI,KAAKytD,WAAWzhD,GAAIq+B,IAKjG,OADAwyB,EAASK,SAASvH,EAAQqH,gBAAiBrH,EAAQmH,2BAA4B98D,KAAK2pC,aAAcgsB,EAAQpsD,WAAYosD,EAAQpsD,WAAaosD,EAAQnsD,WAAYmsD,EAAQsH,gBAAiBtH,EAAQwH,cAAen9D,KAAMA,KAAKo9D,oBAAyG,KAAlD,QAAhCrzD,EAAK4rD,EAAQwH,qBAAkC,IAAPpzD,OAAgB,EAASA,EAAGszD,WAC9Sr9D,MAOX4tD,EAAa3tD,UAAUq9D,+BAAiC,SAAUT,EAAUxyB,GAGxE,IAFA,IAAIooB,EAAYzyD,KAAKu9D,OAAOC,8BAA8Bx9D,KAAM68D,GAC5Dt+C,EAAMk0C,EAAUtuD,OACX3D,EAAQ,EAAGA,EAAQ+d,EAAK/d,IAAS,CACtC,IAAIm1D,EAAUlD,EAAU9mC,KAAKnrB,GAEzB+d,EAAM,IAAMo3C,EAAQ8H,gBAAgBZ,IAGxC78D,KAAK48D,mBAAmBjH,EAAStrB,EAAiBwyB,GAEtD,OAAO78D,MAGX4tD,EAAa3tD,UAAUm9D,kBAAoB,WACvC,OAAO,GAMXxP,EAAa3tD,UAAUw9D,gBAAkB,SAAUZ,GAE/C,IAAK78D,KAAKm7C,kBAAkBsiB,gBAAgBZ,GACxC,OAAO78D,KAGX,IAAI09D,EAA0B,eAC1BC,EAA4B,eAIhC,OAHA,kBAAoB,EAAMd,EAAS71B,QAAQnjC,EAAG,EAAMg5D,EAAS71B,QAAQt+B,EAAG,EAAMm0D,EAAS71B,QAAQr+B,EAAG+0D,GAClG19D,KAAKm7D,qBAAqBh6D,cAAcu8D,EAAyBC,GACjE39D,KAAKs9D,+BAA+BT,EAAUc,GACvC39D,MAIX4tD,EAAa3tD,UAAUi7D,qBAAuB,WAC1C,OAAO,GAaXtN,EAAa3tD,UAAU67D,WAAa,SAAU8B,EAAKC,EAAWC,EAAmBC,EAAkBC,EAAYC,QAClF,IAArBF,IAA+BA,GAAmB,QAC7B,IAArBE,IAA+BA,GAAmB,GACtD,IAAIC,EAAc,IAAI,IAClBC,EAAgD,uBAAxBn+D,KAAKG,gBAAmE,cAAxBH,KAAKG,eAAiCH,KAAKm+D,sBAAwB,EAC3IjH,EAAel3D,KAAKm7C,kBACxB,IAAKn7C,KAAKyyD,UACN,OAAOyL,EAEX,KAAKD,GACCL,EAAIQ,iBAAiBlH,EAAamH,eAAgBF,IAA2BP,EAAIU,cAAcpH,EAAaqH,YAAaJ,IAC3H,OAAOD,EAEX,GAAIH,EAKA,OAJAG,EAAYM,KAAMP,EAClBC,EAAYO,WAAaR,EAAmB,KAAOj+D,KACnDk+D,EAAY5rD,SAAW2rD,EAAmB,EAAI,aAAiBL,EAAI5yD,OAAQksD,EAAamH,eAAevmD,QACvGomD,EAAYQ,UAAY,EACjBR,EAEX,IAAKl+D,KAAKk7D,uBACN,OAAOgD,EAQX,IANA,IAAIS,EAAgB,KAChBlM,EAAYzyD,KAAKu9D,OAAOqB,iCAAiC5+D,KAAM49D,GAC/Dr/C,EAAMk0C,EAAUtuD,OAGhB06D,GAA6B,EACxBr+D,EAAQ,EAAGA,EAAQ+d,EAAK/d,IAAS,CACtC,IACIo1C,GADA+f,EAAUlD,EAAU9mC,KAAKnrB,IACN28D,cACvB,GAAKvnB,IAGoB,GAArBA,EAASynB,UACY,GAArBznB,EAASynB,UACY,GAArBznB,EAASynB,UACY,GAArBznB,EAASynB,UACY,GAArBznB,EAASynB,UAAe,CACxBwB,GAA6B,EAC7B,OAIR,IAAKA,EAKD,OAJAX,EAAYM,KAAM,EAClBN,EAAYO,WAAaz+D,KACzBk+D,EAAY5rD,SAAW,aAAiBsrD,EAAI5yD,OAAQksD,EAAamH,eAAevmD,QAChFomD,EAAYQ,WAAa,EAClBR,EAGX,IAAS19D,EAAQ,EAAGA,EAAQ+d,EAAK/d,IAAS,CACtC,IAAIm1D,EAAUlD,EAAU9mC,KAAKnrB,GAE7B,KAAI+d,EAAM,IAAMo3C,EAAQmJ,cAAclB,GAAtC,CAGA,IAAImB,EAAuBpJ,EAAQmG,WAAW8B,EAAK59D,KAAKytD,WAAYztD,KAAK2pC,aAAck0B,EAAWC,GAClG,GAAIiB,IACIlB,IAAcc,GAAiBI,EAAqBzsD,SAAWqsD,EAAcrsD,aAC7EqsD,EAAgBI,GACFL,UAAYl+D,EACtBq9D,GACA,OAKhB,GAAIc,EAAe,CAEf,IAAIx4C,EAAQ63C,QAA+CA,EAAah+D,KAAKiqC,iBACzE+0B,EAAc,gBACdrlD,EAAY,gBAChB,8BAAkCikD,EAAI5yD,OAAQmb,EAAO64C,GACrDpB,EAAIjkD,UAAUnY,WAAWm9D,EAAcrsD,SAAUqH,GACjD,IACIslD,EADiB,oBAAwBtlD,EAAWwM,GACvBnf,WAAWg4D,GAW5C,OATAd,EAAYM,KAAM,EAClBN,EAAY5rD,SAAW,aAAiB0sD,EAAaC,GACrDf,EAAYe,YAAcA,EAC1Bf,EAAYO,WAAaz+D,KACzBk+D,EAAYgB,GAAKP,EAAcO,IAAM,EACrChB,EAAYiB,GAAKR,EAAcQ,IAAM,EACrCjB,EAAYkB,cAAgBT,EAAcU,OAC1CnB,EAAYmB,OAASV,EAAcU,OAAS5M,EAAU9mC,KAAKgzC,EAAcD,WAAWn1D,aAA4D,IAA9CvJ,KAAKG,eAAei1D,QAAQ,aAAsB,EAAI,GACxJ8I,EAAYQ,UAAYC,EAAcD,UAC/BR,EAEX,OAAOA,GAUXtQ,EAAa3tD,UAAUgC,MAAQ,SAAU8iC,EAAMu6B,EAAWC,GACtD,OAAO,MAMX3R,EAAa3tD,UAAUu/D,iBAAmB,WACtC,GAAIx/D,KAAKyyD,UACL,KAAOzyD,KAAKyyD,UAAUtuD,QAClBnE,KAAKyyD,UAAU,GAAGtI,eAItBnqD,KAAKyyD,UAAY,IAAIvoD,MAEzB,OAAOlK,MAOX4tD,EAAa3tD,UAAUkqD,QAAU,SAAUsV,EAAcC,GACrD,IAEIl/D,EAFAqhB,EAAQ7hB,KAyBZ,SAxBmC,IAA/B0/D,IAAyCA,GAA6B,GAGtE1/D,KAAKu9D,OAAOoC,oBAER3/D,KAAK6tD,8BAA8BL,WAAaxtD,KAAK6tD,8BAA8BL,UAAU8E,UAC7FtyD,KAAK6tD,8BAA8BL,UAAU8E,QAAQtyD,KAAKuyD,eAAYvoC,GAI9EhqB,KAAK8pC,WAAW81B,mBAChB5/D,KAAK8pC,WAAW+1B,2BAEW71C,IAAvBhqB,KAAKwvD,eAAsD,OAAvBxvD,KAAKwvD,gBACzCxvD,KAAKwvD,cAAcrF,UACnBnqD,KAAKwvD,cAAgB,MAGzBxvD,KAAK6tD,8BAA8BnB,UAAY,KAC3C1sD,KAAK0wD,0BACL1wD,KAAK0wD,wBAAwBvG,UAC7BnqD,KAAK0wD,wBAA0B,MAG9BlwD,EAAQ,EAAGA,EAAQR,KAAKkwD,yBAAyB/rD,OAAQ3D,IAAS,CACnE,IAAIkK,EAAQ1K,KAAKkwD,yBAAyB1vD,GACtCmvC,EAAMjlC,EAAMwlD,yBAAyBkF,QAAQp1D,MACjD0K,EAAMwlD,yBAAyBoF,OAAO3lB,EAAK,GAE/C3vC,KAAKkwD,yBAA2B,GAEnBlwD,KAAK8pC,WAAWgrB,OACtB/yC,SAAQ,SAAUgzC,GACrB,IAAI+K,EAAY/K,EAAMgL,mBAAmB3K,QAAQvzC,IAC9B,IAAfi+C,GACA/K,EAAMgL,mBAAmBzK,OAAOwK,EAAW,IAG5B,KADnBA,EAAY/K,EAAMiL,eAAe5K,QAAQvzC,KAErCkzC,EAAMiL,eAAe1K,OAAOwK,EAAW,GAG3C,IAAIG,EAAYlL,EAAMmL,qBACtB,GAAID,EAAW,CACX,IAAIE,EAAYF,EAAUG,eACtBD,GAAaA,EAAUE,aAEJ,KADnBP,EAAYK,EAAUE,WAAWjL,QAAQvzC,KAErCs+C,EAAUE,WAAW/K,OAAOwK,EAAW,OAM3B,kBAAxB9/D,KAAKG,gBAA8D,uBAAxBH,KAAKG,gBAChDH,KAAKw/D,mBAGT,IAAIc,EAAStgE,KAAK8pC,WAAW0H,YAU7B,GAT6B,OAAzBxxC,KAAKquD,kBACLruD,KAAKugE,4BAA6B,EAClCD,EAAOE,YAAYxgE,KAAKquD,iBACxBruD,KAAKquD,gBAAkB,MAG3BiS,EAAOG,aAEPzgE,KAAK8pC,WAAW42B,WAAW1gE,MACvBA,KAAK2gE,iBAAkB,CACvB,IAAIC,EAAU5gE,KAAK2gE,iBAAiBpN,OAAO6B,QAAQp1D,MAC/C4gE,GAAW,GACX5gE,KAAK2gE,iBAAiBpN,OAAO+B,OAAOsL,EAAS,GAEjD5gE,KAAK2gE,iBAAmB,KAY5B,GAVIjB,GACI1/D,KAAK41C,WACgC,kBAAjC51C,KAAK41C,SAASz1C,eACdH,KAAK41C,SAASuU,SAAQ,GAAO,GAAM,GAGnCnqD,KAAK41C,SAASuU,SAAQ,GAAO,KAIpCsV,EAED,IAAKj/D,EAAQ,EAAGA,EAAQR,KAAK8pC,WAAW+2B,gBAAgB18D,OAAQ3D,IACxDR,KAAK8pC,WAAW+2B,gBAAgBrgE,GAAOsgE,UAAY9gE,OACnDA,KAAK8pC,WAAW+2B,gBAAgBrgE,GAAO2pD,UACvC3pD,KAKRR,KAAK6tD,8BAA8BrB,WAAWZ,kBAC9C5rD,KAAK+gE,mBAET/gE,KAAKqxD,eAAelH,UACpBnqD,KAAKghE,mCAAmCC,QACxCjhE,KAAKiuD,oBAAoBgT,QACzBjhE,KAAKkuD,oCAAoC+S,QACzCjhE,KAAK2wD,oBAAoBsQ,QACzB9V,EAAOlrD,UAAUkqD,QAAQkB,KAAKrrD,KAAMy/D,EAAcC,IAQtD9R,EAAa3tD,UAAUihE,SAAW,SAAUrmB,EAAMsmB,GAG9C,YAF4B,IAAxBA,IAAkCA,GAAsB,GAC5DtmB,EAAKumB,UAAUphE,KAAMmhE,GACdnhE,MAQX4tD,EAAa3tD,UAAUohE,YAAc,SAAUxmB,EAAMsmB,GAGjD,YAF4B,IAAxBA,IAAkCA,GAAsB,GAC5DtmB,EAAKumB,UAAU,KAAMD,GACdnhE,MAIX4tD,EAAa3tD,UAAUqhE,eAAiB,WACpC,IAAI31C,EAAO3rB,KAAK6tD,8BAA8BrB,WACzC7gC,EAAK41C,eACN51C,EAAK41C,aAAe,IAAIr3D,OAEvByhB,EAAK61C,iBACN71C,EAAK61C,eAAiB,IAAIt3D,OAEzByhB,EAAK81C,oBACN91C,EAAK81C,kBAAoB,IAAIv3D,OAEjCyhB,EAAK8/B,QAAWzrD,KAAK2pC,aAAaxlC,OAAS,EAAK,EAChDwnB,EAAK+/B,yBAA2B//B,EAAK+/B,yBAA2B//B,EAAK+/B,yBAA2B,GAChG//B,EAAKggC,sBAAwBhgC,EAAKggC,sBAAwBhgC,EAAKggC,sBAAwB,KACvF,IAAK,IAAI1tB,EAAI,EAAGA,EAAItS,EAAK8/B,QAASxtB,IAC9BtS,EAAK41C,aAAatjC,GAAK,WACvBtS,EAAK61C,eAAevjC,GAAK,WAG7B,OADAtS,EAAKigC,kBAAmB,EACjB5rD,MASX4tD,EAAa3tD,UAAUyhE,gBAAkB,WACrC,IAAI/1C,EAAO3rB,KAAK6tD,8BAA8BrB,WACzC7gC,EAAKigC,kBACN5rD,KAAKshE,iBAET,IAAIj4D,EAAYrJ,KAAK4pC,gBAAgB,kBACjCtgC,EAAUtJ,KAAK2pC,aACfzG,EAAUljC,KAAK4pC,gBAAgB,gBAC/B+3B,EAAQ3hE,KAAKm7C,kBACjB,GAAIxvB,EAAKqgC,iBAAmBrgC,EAAKsgC,sBAAuB,CAGpD,GADAtgC,EAAKsgC,uBAAwB,EACzB3iD,aAAmBs4D,YACnBj2C,EAAKk2C,mBAAqB,IAAID,YAAYt4D,QAEzC,GAAIA,aAAmB68C,YACxBx6B,EAAKk2C,mBAAqB,IAAI1b,YAAY78C,OAEzC,CAED,IADA,IAAIw4D,GAAc,EACT91D,EAAI,EAAGA,EAAI1C,EAAQnF,OAAQ6H,IAChC,GAAI1C,EAAQ0C,GAAK,MAAO,CACpB81D,GAAc,EACd,MAIJn2C,EAAKk2C,mBADLC,EAC0B,IAAI3b,YAAY78C,GAGhB,IAAIs4D,YAAYt4D,GAMlD,GAHAqiB,EAAKo2C,uBAAyB,SAAUl2D,EAAIC,GACxC,OAAOA,EAAGk2D,WAAan2D,EAAGm2D,aAEzBr2C,EAAK+lC,mBAAoB,CAC1B,IAAI7nB,EAAS7pC,KAAK8pC,WAAWC,aAC7Bpe,EAAK+lC,mBAAqB7nB,EAASA,EAAOn5B,SAAW,WAEzDib,EAAKs2C,kBAAoB,GACzB,IAAK,IAAIhkC,EAAI,EAAGA,EAAItS,EAAK8/B,QAASxtB,IAAK,CACnC,IAAIikC,EAAmB,CAAEC,IAAS,EAAJlkC,EAAO+jC,WAAY,GACjDr2C,EAAKs2C,kBAAkB55D,KAAK65D,GAEhCv2C,EAAKhT,eAAiB,gBACtBgT,EAAKy2C,qBAAuB,WAEhCz2C,EAAKmgC,OAAOjoD,EAAI89D,EAAMj4D,QAAQ7F,EAAI89D,EAAMl4D,QAAQ5F,EAAI,KAAU89D,EAAMj4D,QAAQ7F,EAAI89D,EAAMl4D,QAAQ5F,EAAI,KAClG8nB,EAAKmgC,OAAOpjD,EAAIi5D,EAAMj4D,QAAQhB,EAAIi5D,EAAMl4D,QAAQf,EAAI,KAAUi5D,EAAMj4D,QAAQhB,EAAIi5D,EAAMl4D,QAAQf,EAAI,KAClGijB,EAAKmgC,OAAOnjD,EAAIg5D,EAAMj4D,QAAQf,EAAIg5D,EAAMl4D,QAAQd,EAAI,KAAUg5D,EAAMj4D,QAAQf,EAAIg5D,EAAMl4D,QAAQd,EAAI,KAClG,IAAI05D,EAAY12C,EAAKmgC,OAAOjoD,EAAI8nB,EAAKmgC,OAAOpjD,EAAIijB,EAAKmgC,OAAOjoD,EAAI8nB,EAAKmgC,OAAOpjD,EA4B5E,GA3BA25D,EAAYA,EAAY12C,EAAKmgC,OAAOnjD,EAAI05D,EAAY12C,EAAKmgC,OAAOnjD,EAChEgjB,EAAKogC,OAAOnqD,IAAM+pB,EAAK+/B,yBACvB//B,EAAKogC,OAAOtsD,EAAI+C,KAAKgI,MAAOmhB,EAAKogC,OAAOnqD,IAAM+pB,EAAKmgC,OAAOjoD,EAAKw+D,GAC/D12C,EAAKogC,OAAOrsD,EAAI8C,KAAKgI,MAAOmhB,EAAKogC,OAAOnqD,IAAM+pB,EAAKmgC,OAAOpjD,EAAK25D,GAC/D12C,EAAKogC,OAAOpsD,EAAI6C,KAAKgI,MAAOmhB,EAAKogC,OAAOnqD,IAAM+pB,EAAKmgC,OAAOnjD,EAAK05D,GAC/D12C,EAAKogC,OAAOtsD,EAAIksB,EAAKogC,OAAOtsD,EAAI,EAAI,EAAIksB,EAAKogC,OAAOtsD,EACpDksB,EAAKogC,OAAOrsD,EAAIisB,EAAKogC,OAAOrsD,EAAI,EAAI,EAAIisB,EAAKogC,OAAOrsD,EACpDisB,EAAKogC,OAAOpsD,EAAIgsB,EAAKogC,OAAOpsD,EAAI,EAAI,EAAIgsB,EAAKogC,OAAOpsD,EAEpDgsB,EAAKkgC,gBAAgB0V,aAAevhE,KAAKsiE,uBACzC32C,EAAKkgC,gBAAgB2V,eAAiBxhE,KAAKuiE,yBAC3C52C,EAAKkgC,gBAAgB4V,kBAAoBzhE,KAAKwiE,4BAC9C72C,EAAKkgC,gBAAgB8V,MAAQA,EAC7Bh2C,EAAKkgC,gBAAgBC,OAASngC,EAAKmgC,OACnCngC,EAAKkgC,gBAAgBE,OAASpgC,EAAKogC,OACnCpgC,EAAKkgC,gBAAgB2F,MAAQxxD,KAAK2rD,sBAClChgC,EAAKkgC,gBAAgB4W,UAAY92C,EAAKqgC,eAClCrgC,EAAKqgC,gBAAkBrgC,EAAKsgC,wBAC5BjsD,KAAK0iE,oBAAmB,GACxB1iE,KAAKq7C,aAAaxiC,YAAY8S,EAAKhT,gBACnC,8BAAkCgT,EAAK+lC,mBAAoB/lC,EAAKhT,eAAgBgT,EAAKy2C,sBACrFz2C,EAAKkgC,gBAAgB8W,WAAah3C,EAAKy2C,sBAE3Cz2C,EAAKkgC,gBAAgBoW,kBAAoBt2C,EAAKs2C,kBAC1C/+B,GACA,mBAA0B75B,EAAWC,EAAS45B,EAASvX,EAAKkgC,iBAE5DlgC,EAAKqgC,gBAAkBrgC,EAAKsgC,sBAAuB,CACnDtgC,EAAKs2C,kBAAkBxQ,KAAK9lC,EAAKo2C,wBACjC,IAAIhvD,EAAK4Y,EAAKk2C,mBAAmB19D,OAAS,EAAK,EAC/C,IAAS85B,EAAI,EAAGA,EAAIlrB,EAAGkrB,IAAK,CACxB,IAAI2kC,EAAOj3C,EAAKs2C,kBAAkBhkC,GAAGkkC,IACrCx2C,EAAKk2C,mBAAuB,EAAJ5jC,GAAS30B,EAAQs5D,GACzCj3C,EAAKk2C,mBAAuB,EAAJ5jC,EAAQ,GAAK30B,EAAQs5D,EAAO,GACpDj3C,EAAKk2C,mBAAuB,EAAJ5jC,EAAQ,GAAK30B,EAAQs5D,EAAO,GAExD5iE,KAAK6iE,cAAcl3C,EAAKk2C,wBAAoB73C,GAAW,GAE3D,OAAOhqB,MAQX4tD,EAAa3tD,UAAUqiE,qBAAuB,WAC1C,IAAIQ,EAAY9iE,KAAK6tD,8BAA8BrB,WAInD,OAHKsW,EAAUvB,cACXvhE,KAAK0hE,kBAEFoB,EAAUvB,cAQrB3T,EAAa3tD,UAAUsiE,uBAAyB,WAC5C,IAAIO,EAAY9iE,KAAK6tD,8BAA8BrB,WAInD,OAHKsW,EAAUtB,gBACXxhE,KAAK0hE,kBAEFoB,EAAUtB,gBAOrB5T,EAAa3tD,UAAUuiE,0BAA4B,WAC/C,IAAIM,EAAY9iE,KAAK6tD,8BAA8BrB,WAInD,OAHKsW,EAAUrB,mBACXzhE,KAAK0hE,kBAEFoB,EAAUrB,mBASrB7T,EAAa3tD,UAAU8iE,iBAAmB,SAAU/2D,GAChD,IAAI2jC,EAAM,WAEV,OADA3vC,KAAKgjE,sBAAsBh3D,EAAG2jC,GACvBA,GASXie,EAAa3tD,UAAU+iE,sBAAwB,SAAUh3D,EAAGmT,GACxD,IAAI8jD,EAAWjjE,KAAKuiE,yBAAyBv2D,GACzCma,EAAQnmB,KAAKiqC,iBAEjB,OADA,8BAAkCg5B,EAAU98C,EAAOhH,GAC5Cnf,MASX4tD,EAAa3tD,UAAUijE,eAAiB,SAAUl3D,GAC9C,IAAIwM,EAAO,WAEX,OADAxY,KAAKmjE,oBAAoBn3D,EAAGwM,GACrBA,GASXo1C,EAAa3tD,UAAUkjE,oBAAsB,SAAUn3D,EAAGmT,GACtD,IAAIikD,EAAYpjE,KAAKsiE,uBAAuBt2D,GAE5C,OADA,yBAA6Bo3D,EAAWpjE,KAAKiqC,iBAAkB9qB,GACxDnf,MAUX4tD,EAAa3tD,UAAUojE,4BAA8B,SAAUx/D,EAAG6E,EAAGC,GACjE,IAAIg5D,EAAQ3hE,KAAKm7C,kBACbxvB,EAAO3rB,KAAK6tD,8BAA8BrB,WAC1C8W,EAAK9gE,KAAKgI,OAAQ3G,EAAI89D,EAAMl4D,QAAQ5F,EAAI8nB,EAAKggC,uBAAyBhgC,EAAKogC,OAAOtsD,EAAIksB,EAAKggC,sBAAyBhgC,EAAKmgC,OAAOjoD,GAChI0/D,EAAK/gE,KAAKgI,OAAQ9B,EAAIi5D,EAAMl4D,QAAQf,EAAIijB,EAAKggC,uBAAyBhgC,EAAKogC,OAAOrsD,EAAIisB,EAAKggC,sBAAyBhgC,EAAKmgC,OAAOpjD,GAChI86D,EAAKhhE,KAAKgI,OAAQ7B,EAAIg5D,EAAMl4D,QAAQd,EAAIgjB,EAAKggC,uBAAyBhgC,EAAKogC,OAAOpsD,EAAIgsB,EAAKggC,sBAAyBhgC,EAAKmgC,OAAOnjD,GACpI,OAAI26D,EAAK,GAAKA,EAAK33C,EAAKogC,OAAOnqD,KAAO2hE,EAAK,GAAKA,EAAK53C,EAAKogC,OAAOnqD,KAAO4hE,EAAK,GAAKA,EAAK73C,EAAKogC,OAAOnqD,IACxF,KAEJ+pB,EAAK81C,kBAAkB6B,EAAK33C,EAAKogC,OAAOnqD,IAAM2hE,EAAK53C,EAAKogC,OAAOnqD,IAAM+pB,EAAKogC,OAAOnqD,IAAM4hE,IAalG5V,EAAa3tD,UAAUwjE,6BAA+B,SAAU5/D,EAAG6E,EAAGC,EAAG+6D,EAAWC,EAAWC,QACzE,IAAdD,IAAwBA,GAAY,QACzB,IAAXC,IAAqBA,GAAS,GAClC,IAAIz9C,EAAQnmB,KAAKiqC,iBACb45B,EAAS,eACb19C,EAAMtN,YAAYgrD,GAClB,IAAIC,EAAU,gBACd,wCAA4CjgE,EAAG6E,EAAGC,EAAGk7D,EAAQC,GAC7D,IAAIC,EAAU/jE,KAAKgkE,kCAAkCF,EAAQjgE,EAAGigE,EAAQp7D,EAAGo7D,EAAQn7D,EAAG+6D,EAAWC,EAAWC,GAK5G,OAJIF,GAEA,wCAA4CA,EAAU7/D,EAAG6/D,EAAUh7D,EAAGg7D,EAAU/6D,EAAGwd,EAAOu9C,GAEvFK,GAaXnW,EAAa3tD,UAAU+jE,kCAAoC,SAAUngE,EAAG6E,EAAGC,EAAG+6D,EAAWC,EAAWC,QAC9E,IAAdD,IAAwBA,GAAY,QACzB,IAAXC,IAAqBA,GAAS,GAClC,IAAIG,EAAU,KACVE,EAAO,EACPC,EAAO,EACPC,EAAO,EACPv7D,EAAI,EACJw7D,EAAK,EACLC,EAAQ,EACRC,EAAQ,EACRC,EAAQ,EAER/C,EAAiBxhE,KAAKuiE,yBACtBhB,EAAevhE,KAAKsiE,uBACpBkC,EAAgBxkE,KAAKqjE,4BAA4Bx/D,EAAG6E,EAAGC,GAC3D,IAAK67D,EACD,OAAO,KASX,IANA,IAEIC,EACAjsD,EACAqG,EAJA6lD,EAAWr6D,OAAOC,UAClBq6D,EAAcD,EAKTjwB,EAAM,EAAGA,EAAM+vB,EAAcrgE,OAAQswC,IAE1Cj8B,EAAO+oD,EADPkD,EAAMD,EAAc/vB,IAGpB7rC,GAAK/E,GADLgb,EAAK2iD,EAAeiD,IACR5gE,GAAK2U,EAAK3U,GAAK6E,EAAImW,EAAGnW,GAAK8P,EAAK9P,GAAKC,EAAIkW,EAAGlW,GAAK6P,EAAK7P,IAC7Dg7D,GAAcA,GAAaC,GAAUh7D,GAAK,GAAS+6D,IAAcC,GAAUh7D,GAAK,KAEjFA,EAAI4P,EAAK3U,EAAIgb,EAAGhb,EAAI2U,EAAK9P,EAAImW,EAAGnW,EAAI8P,EAAK7P,EAAIkW,EAAGlW,EAChDy7D,IAAO5rD,EAAK3U,EAAIA,EAAI2U,EAAK9P,EAAIA,EAAI8P,EAAK7P,EAAIA,EAAIC,IAAM4P,EAAK3U,EAAI2U,EAAK3U,EAAI2U,EAAK9P,EAAI8P,EAAK9P,EAAI8P,EAAK7P,EAAI6P,EAAK7P,IAOtGg8D,GAHAV,GAHAI,EAAQxgE,EAAI2U,EAAK3U,EAAIugE,GAGNvgE,GAGMogE,GAFrBC,GAHAI,EAAQ57D,EAAI8P,EAAK9P,EAAI07D,GAGN17D,GAEoBw7D,GADnCC,GAHAI,EAAQ57D,EAAI6P,EAAK7P,EAAIy7D,GAGNz7D,GACkCw7D,GAC/BO,IAEdA,EAAWC,EACXZ,EAAUU,EACNf,IACAA,EAAU7/D,EAAIwgE,EACdX,EAAUh7D,EAAI47D,EACdZ,EAAU/6D,EAAI47D,KAK9B,OAAOR,GAOXnW,EAAa3tD,UAAU07C,uBAAyB,WAC5C,OAAO37C,KAAK6tD,8BAA8BrB,WAAWX,iBAOzD+B,EAAa3tD,UAAU8gE,iBAAmB,WACtC,IAAI+B,EAAY9iE,KAAK6tD,8BAA8BrB,WASnD,OARIsW,EAAUlX,mBACVkX,EAAUlX,kBAAmB,EAC7BkX,EAAUtB,eAAiB,IAAIt3D,MAC/B44D,EAAUvB,aAAe,IAAIr3D,MAC7B44D,EAAUrB,kBAAoB,IAAIv3D,MAClC44D,EAAUjX,gBAAkB,KAC5BiX,EAAUjB,mBAAqB,IAAI1b,YAAY,IAE5CnmD,MAUX4tD,EAAa3tD,UAAU4iE,cAAgB,SAAUv5D,EAAS5I,EAAQkkE,GAE9D,YADsB,IAAlBA,IAA4BA,GAAgB,GACzC5kE,MAOX4tD,EAAa3tD,UAAU4kE,cAAgB,SAAUz/B,GAC7C,IAEIlC,EAFA75B,EAAYrJ,KAAK4pC,gBAAgB,kBACjCtgC,EAAUtJ,KAAK2pC,aAUnB,OAPIzG,EADAljC,KAAK+2D,sBAAsB,gBACjB/2D,KAAK4pC,gBAAgB,gBAGrB,GAEd,mBAA0BvgC,EAAWC,EAAS45B,EAAS,CAAE4hC,qBAAsB9kE,KAAK8pC,WAAWg7B,uBAC/F9kE,KAAK02D,gBAAgB,eAAyBxzB,EAASkC,GAChDplC,MAQX4tD,EAAa3tD,UAAU8kE,gBAAkB,SAAUt8D,EAAQu8D,GAClDA,IACDA,EAAc,QAElB,IAAIC,EAAQ,gBACRC,EAAQ,gBASZ,OARA,eAAmBF,EAAav8D,EAAQy8D,GACxC,eAAmBz8D,EAAQy8D,EAAOD,GAC9BjlE,KAAK02B,mBACL,qCAA2CuuC,EAAOx8D,EAAQy8D,EAAOllE,KAAK02B,oBAGtE,0BAA8BuuC,EAAOx8D,EAAQy8D,EAAOllE,KAAK0pB,UAEtD1pB,MAGX4tD,EAAa3tD,UAAUklE,qBAAuB,WAE1C,OAAO,GAMXvX,EAAa3tD,UAAUmlE,sBAAwB,WAC3C,MAAM,OAAY,kBAYtBxX,EAAa3tD,UAAUolE,qBAAuB,SAAUzrD,EAAS0rD,EAA+BriC,GAC5F,MAAM,OAAY,kBAMtB2qB,EAAa3tD,UAAUslE,4BAA8B,WACjD,IAAI1jD,EAAQ7hB,KACZ,OAAOA,KAAKu9D,OAAOsD,gBAAgBvxB,QAAO,SAAUk2B,GAAkB,OAAOA,EAAe1E,UAAYj/C,MAG5G+rC,EAAa6X,oBAAsB,EAEnC7X,EAAa8X,0BAA4B,EAEzC9X,EAAa+X,sBAAwB,EAErC/X,EAAagY,kCAAoC,EAEjDhY,EAAaiY,sCAAwC,EAOrDjY,EAAakY,yBAA2B,EAOxClY,EAAaI,oCAAsC,EAUnDJ,EAAamY,qCAAuC,EAUpDnY,EAAaoY,uDAAyD,EAC/DpY,EAhzEsB,CAizE/B,MAEF,OAAc,uBAAwBA","sources":["webpack:///../../../node_modules/@babylonjs/core/Maths/math.axis.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.color.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.constants.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.frustum.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.functions.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.isovector.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.path.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.plane.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.scalar.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.size.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.vector.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.vertexFormat.js","webpack:///../../../node_modules/@babylonjs/core/Maths/math.viewport.js","webpack:///../../../node_modules/@babylonjs/core/Maths/sphericalPolynomial.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/capsuleBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/geodesicBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/goldbergBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/hemisphereBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/tiledBoxBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/tiledPlaneBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/WebGPU/webgpuDataBuffer.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/abstractMesh.js"],"sourcesContent":["import { Vector3 } from \"./math.vector.js\";\n/** Defines supported spaces */\nexport var Space;\n(function (Space) {\n    /** Local (object) space */\n    Space[Space[\"LOCAL\"] = 0] = \"LOCAL\";\n    /** World space */\n    Space[Space[\"WORLD\"] = 1] = \"WORLD\";\n    /** Bone space */\n    Space[Space[\"BONE\"] = 2] = \"BONE\";\n})(Space || (Space = {}));\n/** Defines the 3 main axes */\nvar Axis = /** @class */ (function () {\n    function Axis() {\n    }\n    /** X axis */\n    Axis.X = new Vector3(1.0, 0.0, 0.0);\n    /** Y axis */\n    Axis.Y = new Vector3(0.0, 1.0, 0.0);\n    /** Z axis */\n    Axis.Z = new Vector3(0.0, 0.0, 1.0);\n    return Axis;\n}());\nexport { Axis };\n/**\n * Defines cartesian components.\n */\nexport var Coordinate;\n(function (Coordinate) {\n    /** X axis */\n    Coordinate[Coordinate[\"X\"] = 0] = \"X\";\n    /** Y axis */\n    Coordinate[Coordinate[\"Y\"] = 1] = \"Y\";\n    /** Z axis */\n    Coordinate[Coordinate[\"Z\"] = 2] = \"Z\";\n})(Coordinate || (Coordinate = {}));\n//# sourceMappingURL=math.axis.js.map","import { Scalar } from \"./math.scalar.js\";\nimport { ToLinearSpace, ToGammaSpace } from \"./math.constants.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * Class used to hold a RGB color\n */\nvar Color3 = /** @class */ (function () {\n    /**\n     * Creates a new Color3 object from red, green, blue values, all between 0 and 1\n     * @param r defines the red component (between 0 and 1, default is 0)\n     * @param g defines the green component (between 0 and 1, default is 0)\n     * @param b defines the blue component (between 0 and 1, default is 0)\n     */\n    function Color3(\n    /**\n     * Defines the red component (between 0 and 1, default is 0)\n     */\n    r, \n    /**\n     * Defines the green component (between 0 and 1, default is 0)\n     */\n    g, \n    /**\n     * Defines the blue component (between 0 and 1, default is 0)\n     */\n    b) {\n        if (r === void 0) { r = 0; }\n        if (g === void 0) { g = 0; }\n        if (b === void 0) { b = 0; }\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n    /**\n     * Creates a string with the Color3 current values\n     * @returns the string representation of the Color3 object\n     */\n    Color3.prototype.toString = function () {\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n    };\n    /**\n     * Returns the string \"Color3\"\n     * @returns \"Color3\"\n     */\n    Color3.prototype.getClassName = function () {\n        return \"Color3\";\n    };\n    /**\n     * Compute the Color3 hash code\n     * @returns an unique number that can be used to hash Color3 objects\n     */\n    Color3.prototype.getHashCode = function () {\n        var hash = (this.r * 255) | 0;\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\n        return hash;\n    };\n    // Operators\n    /**\n     * Stores in the given array from the given starting index the red, green, blue values as successive elements\n     * @param array defines the array where to store the r,g,b components\n     * @param index defines an optional index in the target array to define where to start storing values\n     * @returns the current Color3 object\n     */\n    Color3.prototype.toArray = function (array, index) {\n        if (index === void 0) { index = 0; }\n        array[index] = this.r;\n        array[index + 1] = this.g;\n        array[index + 2] = this.b;\n        return this;\n    };\n    /**\n     * Update the current color with values stored in an array from the starting index of the given array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns the current Color3 object\n     */\n    Color3.prototype.fromArray = function (array, offset) {\n        if (offset === void 0) { offset = 0; }\n        Color3.FromArrayToRef(array, offset, this);\n        return this;\n    };\n    /**\n     * Returns a new Color4 object from the current Color3 and the given alpha\n     * @param alpha defines the alpha component on the new Color4 object (default is 1)\n     * @returns a new Color4 object\n     */\n    Color3.prototype.toColor4 = function (alpha) {\n        if (alpha === void 0) { alpha = 1; }\n        return new Color4(this.r, this.g, this.b, alpha);\n    };\n    /**\n     * Returns a new array populated with 3 numeric elements : red, green and blue values\n     * @returns the new array\n     */\n    Color3.prototype.asArray = function () {\n        return [this.r, this.g, this.b];\n    };\n    /**\n     * Returns the luminance value\n     * @returns a float value\n     */\n    Color3.prototype.toLuminance = function () {\n        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n    };\n    /**\n     * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\n     * @param otherColor defines the second operand\n     * @returns the new Color3 object\n     */\n    Color3.prototype.multiply = function (otherColor) {\n        return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n    };\n    /**\n     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\n     * @param otherColor defines the second operand\n     * @param result defines the Color3 object where to store the result\n     * @returns the current Color3\n     */\n    Color3.prototype.multiplyToRef = function (otherColor, result) {\n        result.r = this.r * otherColor.r;\n        result.g = this.g * otherColor.g;\n        result.b = this.b * otherColor.b;\n        return this;\n    };\n    /**\n     * Determines equality between Color3 objects\n     * @param otherColor defines the second operand\n     * @returns true if the rgb values are equal to the given ones\n     */\n    Color3.prototype.equals = function (otherColor) {\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\n    };\n    /**\n     * Determines equality between the current Color3 object and a set of r,b,g values\n     * @param r defines the red component to check\n     * @param g defines the green component to check\n     * @param b defines the blue component to check\n     * @returns true if the rgb values are equal to the given ones\n     */\n    Color3.prototype.equalsFloats = function (r, g, b) {\n        return this.r === r && this.g === g && this.b === b;\n    };\n    /**\n     * Multiplies in place each rgb value by scale\n     * @param scale defines the scaling factor\n     * @returns the updated Color3\n     */\n    Color3.prototype.scale = function (scale) {\n        return new Color3(this.r * scale, this.g * scale, this.b * scale);\n    };\n    /**\n     * Multiplies the rgb values by scale and stores the result into \"result\"\n     * @param scale defines the scaling factor\n     * @param result defines the Color3 object where to store the result\n     * @returns the unmodified current Color3\n     */\n    Color3.prototype.scaleToRef = function (scale, result) {\n        result.r = this.r * scale;\n        result.g = this.g * scale;\n        result.b = this.b * scale;\n        return this;\n    };\n    /**\n     * Scale the current Color3 values by a factor and add the result to a given Color3\n     * @param scale defines the scale factor\n     * @param result defines color to store the result into\n     * @returns the unmodified current Color3\n     */\n    Color3.prototype.scaleAndAddToRef = function (scale, result) {\n        result.r += this.r * scale;\n        result.g += this.g * scale;\n        result.b += this.b * scale;\n        return this;\n    };\n    /**\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\n     * @param min defines minimum clamping value (default is 0)\n     * @param max defines maximum clamping value (default is 1)\n     * @param result defines color to store the result into\n     * @returns the original Color3\n     */\n    Color3.prototype.clampToRef = function (min, max, result) {\n        if (min === void 0) { min = 0; }\n        if (max === void 0) { max = 1; }\n        result.r = Scalar.Clamp(this.r, min, max);\n        result.g = Scalar.Clamp(this.g, min, max);\n        result.b = Scalar.Clamp(this.b, min, max);\n        return this;\n    };\n    /**\n     * Creates a new Color3 set with the added values of the current Color3 and of the given one\n     * @param otherColor defines the second operand\n     * @returns the new Color3\n     */\n    Color3.prototype.add = function (otherColor) {\n        return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n    };\n    /**\n     * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\n     * @param otherColor defines the second operand\n     * @param result defines Color3 object to store the result into\n     * @returns the unmodified current Color3\n     */\n    Color3.prototype.addToRef = function (otherColor, result) {\n        result.r = this.r + otherColor.r;\n        result.g = this.g + otherColor.g;\n        result.b = this.b + otherColor.b;\n        return this;\n    };\n    /**\n     * Returns a new Color3 set with the subtracted values of the given one from the current Color3\n     * @param otherColor defines the second operand\n     * @returns the new Color3\n     */\n    Color3.prototype.subtract = function (otherColor) {\n        return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n    };\n    /**\n     * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\n     * @param otherColor defines the second operand\n     * @param result defines Color3 object to store the result into\n     * @returns the unmodified current Color3\n     */\n    Color3.prototype.subtractToRef = function (otherColor, result) {\n        result.r = this.r - otherColor.r;\n        result.g = this.g - otherColor.g;\n        result.b = this.b - otherColor.b;\n        return this;\n    };\n    /**\n     * Copy the current object\n     * @returns a new Color3 copied the current one\n     */\n    Color3.prototype.clone = function () {\n        return new Color3(this.r, this.g, this.b);\n    };\n    /**\n     * Copies the rgb values from the source in the current Color3\n     * @param source defines the source Color3 object\n     * @returns the updated Color3 object\n     */\n    Color3.prototype.copyFrom = function (source) {\n        this.r = source.r;\n        this.g = source.g;\n        this.b = source.b;\n        return this;\n    };\n    /**\n     * Updates the Color3 rgb values from the given floats\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @returns the current Color3 object\n     */\n    Color3.prototype.copyFromFloats = function (r, g, b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        return this;\n    };\n    /**\n     * Updates the Color3 rgb values from the given floats\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @returns the current Color3 object\n     */\n    Color3.prototype.set = function (r, g, b) {\n        return this.copyFromFloats(r, g, b);\n    };\n    /**\n     * Compute the Color3 hexadecimal code as a string\n     * @returns a string containing the hexadecimal representation of the Color3 object\n     */\n    Color3.prototype.toHexString = function () {\n        var intR = Math.round(this.r * 255);\n        var intG = Math.round(this.g * 255);\n        var intB = Math.round(this.b * 255);\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n    };\n    /**\n     * Computes a new Color3 converted from the current one to linear space\n     * @returns a new Color3 object\n     */\n    Color3.prototype.toLinearSpace = function () {\n        var convertedColor = new Color3();\n        this.toLinearSpaceToRef(convertedColor);\n        return convertedColor;\n    };\n    /**\n     * Converts current color in rgb space to HSV values\n     * @returns a new color3 representing the HSV values\n     */\n    Color3.prototype.toHSV = function () {\n        var result = new Color3();\n        this.toHSVToRef(result);\n        return result;\n    };\n    /**\n     * Converts current color in rgb space to HSV values\n     * @param result defines the Color3 where to store the HSV values\n     */\n    Color3.prototype.toHSVToRef = function (result) {\n        var r = this.r;\n        var g = this.g;\n        var b = this.b;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h = 0;\n        var s = 0;\n        var v = max;\n        var dm = max - min;\n        if (max !== 0) {\n            s = dm / max;\n        }\n        if (max != min) {\n            if (max == r) {\n                h = (g - b) / dm;\n                if (g < b) {\n                    h += 6;\n                }\n            }\n            else if (max == g) {\n                h = (b - r) / dm + 2;\n            }\n            else if (max == b) {\n                h = (r - g) / dm + 4;\n            }\n            h *= 60;\n        }\n        result.r = h;\n        result.g = s;\n        result.b = v;\n    };\n    /**\n     * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color3 object where to store the linear space version\n     * @returns the unmodified Color3\n     */\n    Color3.prototype.toLinearSpaceToRef = function (convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\n        return this;\n    };\n    /**\n     * Computes a new Color3 converted from the current one to gamma space\n     * @returns a new Color3 object\n     */\n    Color3.prototype.toGammaSpace = function () {\n        var convertedColor = new Color3();\n        this.toGammaSpaceToRef(convertedColor);\n        return convertedColor;\n    };\n    /**\n     * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color3 object where to store the gamma space version\n     * @returns the unmodified Color3\n     */\n    Color3.prototype.toGammaSpaceToRef = function (convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\n        return this;\n    };\n    /**\n     * Convert Hue, saturation and value to a Color3 (RGB)\n     * @param hue defines the hue\n     * @param saturation defines the saturation\n     * @param value defines the value\n     * @param result defines the Color3 where to store the RGB values\n     */\n    Color3.HSVtoRGBToRef = function (hue, saturation, value, result) {\n        var chroma = value * saturation;\n        var h = hue / 60;\n        var x = chroma * (1 - Math.abs((h % 2) - 1));\n        var r = 0;\n        var g = 0;\n        var b = 0;\n        if (h >= 0 && h <= 1) {\n            r = chroma;\n            g = x;\n        }\n        else if (h >= 1 && h <= 2) {\n            r = x;\n            g = chroma;\n        }\n        else if (h >= 2 && h <= 3) {\n            g = chroma;\n            b = x;\n        }\n        else if (h >= 3 && h <= 4) {\n            g = x;\n            b = chroma;\n        }\n        else if (h >= 4 && h <= 5) {\n            r = x;\n            b = chroma;\n        }\n        else if (h >= 5 && h <= 6) {\n            r = chroma;\n            b = x;\n        }\n        var m = value - chroma;\n        result.set(r + m, g + m, b + m);\n    };\n    /**\n     * Creates a new Color3 from the string containing valid hexadecimal values\n     * @param hex defines a string containing valid hexadecimal values\n     * @returns a new Color3 object\n     */\n    Color3.FromHexString = function (hex) {\n        if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\n            return new Color3(0, 0, 0);\n        }\n        var r = parseInt(hex.substring(1, 3), 16);\n        var g = parseInt(hex.substring(3, 5), 16);\n        var b = parseInt(hex.substring(5, 7), 16);\n        return Color3.FromInts(r, g, b);\n    };\n    /**\n     * Creates a new Color3 from the starting index of the given array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns a new Color3 object\n     */\n    Color3.FromArray = function (array, offset) {\n        if (offset === void 0) { offset = 0; }\n        return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n    };\n    /**\n     * Creates a new Color3 from the starting index element of the given array\n     * @param array defines the source array to read from\n     * @param offset defines the offset in the source array\n     * @param result defines the target Color3 object\n     */\n    Color3.FromArrayToRef = function (array, offset, result) {\n        if (offset === void 0) { offset = 0; }\n        result.r = array[offset];\n        result.g = array[offset + 1];\n        result.b = array[offset + 2];\n    };\n    /**\n     * Creates a new Color3 from integer values (< 256)\n     * @param r defines the red component to read from (value between 0 and 255)\n     * @param g defines the green component to read from (value between 0 and 255)\n     * @param b defines the blue component to read from (value between 0 and 255)\n     * @returns a new Color3 object\n     */\n    Color3.FromInts = function (r, g, b) {\n        return new Color3(r / 255.0, g / 255.0, b / 255.0);\n    };\n    /**\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n     * @param start defines the start Color3 value\n     * @param end defines the end Color3 value\n     * @param amount defines the gradient value between start and end\n     * @returns a new Color3 object\n     */\n    Color3.Lerp = function (start, end, amount) {\n        var result = new Color3(0.0, 0.0, 0.0);\n        Color3.LerpToRef(start, end, amount, result);\n        return result;\n    };\n    /**\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n     * @param left defines the start value\n     * @param right defines the end value\n     * @param amount defines the gradient factor\n     * @param result defines the Color3 object where to store the result\n     */\n    Color3.LerpToRef = function (left, right, amount, result) {\n        result.r = left.r + (right.r - left.r) * amount;\n        result.g = left.g + (right.g - left.g) * amount;\n        result.b = left.b + (right.b - left.b) * amount;\n    };\n    /**\n     * Returns a new Color3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent Color3\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent Color3\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\n     * @returns the new Color3\n     */\n    Color3.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n        var squared = amount * amount;\n        var cubed = amount * squared;\n        var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        var part2 = -2.0 * cubed + 3.0 * squared;\n        var part3 = cubed - 2.0 * squared + amount;\n        var part4 = cubed - squared;\n        var r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n        var g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n        var b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n        return new Color3(r, g, b);\n    };\n    /**\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    Color3.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n        var result = Color3.Black();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    };\n    /**\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where to store the derivative\n     */\n    Color3.Hermite1stDerivativeToRef = function (value1, tangent1, value2, tangent2, time, result) {\n        var t2 = time * time;\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n    };\n    /**\n     * Returns a Color3 value containing a red color\n     * @returns a new Color3 object\n     */\n    Color3.Red = function () {\n        return new Color3(1, 0, 0);\n    };\n    /**\n     * Returns a Color3 value containing a green color\n     * @returns a new Color3 object\n     */\n    Color3.Green = function () {\n        return new Color3(0, 1, 0);\n    };\n    /**\n     * Returns a Color3 value containing a blue color\n     * @returns a new Color3 object\n     */\n    Color3.Blue = function () {\n        return new Color3(0, 0, 1);\n    };\n    /**\n     * Returns a Color3 value containing a black color\n     * @returns a new Color3 object\n     */\n    Color3.Black = function () {\n        return new Color3(0, 0, 0);\n    };\n    Object.defineProperty(Color3, \"BlackReadOnly\", {\n        /**\n         * Gets a Color3 value containing a black color that must not be updated\n         */\n        get: function () {\n            return Color3._BlackReadOnly;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns a Color3 value containing a white color\n     * @returns a new Color3 object\n     */\n    Color3.White = function () {\n        return new Color3(1, 1, 1);\n    };\n    /**\n     * Returns a Color3 value containing a purple color\n     * @returns a new Color3 object\n     */\n    Color3.Purple = function () {\n        return new Color3(0.5, 0, 0.5);\n    };\n    /**\n     * Returns a Color3 value containing a magenta color\n     * @returns a new Color3 object\n     */\n    Color3.Magenta = function () {\n        return new Color3(1, 0, 1);\n    };\n    /**\n     * Returns a Color3 value containing a yellow color\n     * @returns a new Color3 object\n     */\n    Color3.Yellow = function () {\n        return new Color3(1, 1, 0);\n    };\n    /**\n     * Returns a Color3 value containing a gray color\n     * @returns a new Color3 object\n     */\n    Color3.Gray = function () {\n        return new Color3(0.5, 0.5, 0.5);\n    };\n    /**\n     * Returns a Color3 value containing a teal color\n     * @returns a new Color3 object\n     */\n    Color3.Teal = function () {\n        return new Color3(0, 1.0, 1.0);\n    };\n    /**\n     * Returns a Color3 value containing a random color\n     * @returns a new Color3 object\n     */\n    Color3.Random = function () {\n        return new Color3(Math.random(), Math.random(), Math.random());\n    };\n    // Statics\n    Color3._BlackReadOnly = Color3.Black();\n    return Color3;\n}());\nexport { Color3 };\n/**\n * Class used to hold a RBGA color\n */\nvar Color4 = /** @class */ (function () {\n    /**\n     * Creates a new Color4 object from red, green, blue values, all between 0 and 1\n     * @param r defines the red component (between 0 and 1, default is 0)\n     * @param g defines the green component (between 0 and 1, default is 0)\n     * @param b defines the blue component (between 0 and 1, default is 0)\n     * @param a defines the alpha component (between 0 and 1, default is 1)\n     */\n    function Color4(\n    /**\n     * Defines the red component (between 0 and 1, default is 0)\n     */\n    r, \n    /**\n     * Defines the green component (between 0 and 1, default is 0)\n     */\n    g, \n    /**\n     * Defines the blue component (between 0 and 1, default is 0)\n     */\n    b, \n    /**\n     * Defines the alpha component (between 0 and 1, default is 1)\n     */\n    a) {\n        if (r === void 0) { r = 0; }\n        if (g === void 0) { g = 0; }\n        if (b === void 0) { b = 0; }\n        if (a === void 0) { a = 1; }\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    // Operators\n    /**\n     * Adds in place the given Color4 values to the current Color4 object\n     * @param right defines the second operand\n     * @returns the current updated Color4 object\n     */\n    Color4.prototype.addInPlace = function (right) {\n        this.r += right.r;\n        this.g += right.g;\n        this.b += right.b;\n        this.a += right.a;\n        return this;\n    };\n    /**\n     * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\n     * @returns the new array\n     */\n    Color4.prototype.asArray = function () {\n        return [this.r, this.g, this.b, this.a];\n    };\n    /**\n     * Stores from the starting index in the given array the Color4 successive values\n     * @param array defines the array where to store the r,g,b components\n     * @param index defines an optional index in the target array to define where to start storing values\n     * @returns the current Color4 object\n     */\n    Color4.prototype.toArray = function (array, index) {\n        if (index === void 0) { index = 0; }\n        array[index] = this.r;\n        array[index + 1] = this.g;\n        array[index + 2] = this.b;\n        array[index + 3] = this.a;\n        return this;\n    };\n    /**\n     * Update the current color with values stored in an array from the starting index of the given array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns the current Color4 object\n     */\n    Color4.prototype.fromArray = function (array, offset) {\n        if (offset === void 0) { offset = 0; }\n        Color4.FromArrayToRef(array, offset, this);\n        return this;\n    };\n    /**\n     * Determines equality between Color4 objects\n     * @param otherColor defines the second operand\n     * @returns true if the rgba values are equal to the given ones\n     */\n    Color4.prototype.equals = function (otherColor) {\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\n    };\n    /**\n     * Creates a new Color4 set with the added values of the current Color4 and of the given one\n     * @param right defines the second operand\n     * @returns a new Color4 object\n     */\n    Color4.prototype.add = function (right) {\n        return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n    };\n    /**\n     * Creates a new Color4 set with the subtracted values of the given one from the current Color4\n     * @param right defines the second operand\n     * @returns a new Color4 object\n     */\n    Color4.prototype.subtract = function (right) {\n        return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n    };\n    /**\n     * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\n     * @param right defines the second operand\n     * @param result defines the Color4 object where to store the result\n     * @returns the current Color4 object\n     */\n    Color4.prototype.subtractToRef = function (right, result) {\n        result.r = this.r - right.r;\n        result.g = this.g - right.g;\n        result.b = this.b - right.b;\n        result.a = this.a - right.a;\n        return this;\n    };\n    /**\n     * Creates a new Color4 with the current Color4 values multiplied by scale\n     * @param scale defines the scaling factor to apply\n     * @returns a new Color4 object\n     */\n    Color4.prototype.scale = function (scale) {\n        return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n    };\n    /**\n     * Multiplies the current Color4 values by scale and stores the result in \"result\"\n     * @param scale defines the scaling factor to apply\n     * @param result defines the Color4 object where to store the result\n     * @returns the current unmodified Color4\n     */\n    Color4.prototype.scaleToRef = function (scale, result) {\n        result.r = this.r * scale;\n        result.g = this.g * scale;\n        result.b = this.b * scale;\n        result.a = this.a * scale;\n        return this;\n    };\n    /**\n     * Scale the current Color4 values by a factor and add the result to a given Color4\n     * @param scale defines the scale factor\n     * @param result defines the Color4 object where to store the result\n     * @returns the unmodified current Color4\n     */\n    Color4.prototype.scaleAndAddToRef = function (scale, result) {\n        result.r += this.r * scale;\n        result.g += this.g * scale;\n        result.b += this.b * scale;\n        result.a += this.a * scale;\n        return this;\n    };\n    /**\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\n     * @param min defines minimum clamping value (default is 0)\n     * @param max defines maximum clamping value (default is 1)\n     * @param result defines color to store the result into.\n     * @returns the current Color4\n     */\n    Color4.prototype.clampToRef = function (min, max, result) {\n        if (min === void 0) { min = 0; }\n        if (max === void 0) { max = 1; }\n        result.r = Scalar.Clamp(this.r, min, max);\n        result.g = Scalar.Clamp(this.g, min, max);\n        result.b = Scalar.Clamp(this.b, min, max);\n        result.a = Scalar.Clamp(this.a, min, max);\n        return this;\n    };\n    /**\n     * Multiply an Color4 value by another and return a new Color4 object\n     * @param color defines the Color4 value to multiply by\n     * @returns a new Color4 object\n     */\n    Color4.prototype.multiply = function (color) {\n        return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n    };\n    /**\n     * Multiply a Color4 value by another and push the result in a reference value\n     * @param color defines the Color4 value to multiply by\n     * @param result defines the Color4 to fill the result in\n     * @returns the result Color4\n     */\n    Color4.prototype.multiplyToRef = function (color, result) {\n        result.r = this.r * color.r;\n        result.g = this.g * color.g;\n        result.b = this.b * color.b;\n        result.a = this.a * color.a;\n        return result;\n    };\n    /**\n     * Creates a string with the Color4 current values\n     * @returns the string representation of the Color4 object\n     */\n    Color4.prototype.toString = function () {\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n    };\n    /**\n     * Returns the string \"Color4\"\n     * @returns \"Color4\"\n     */\n    Color4.prototype.getClassName = function () {\n        return \"Color4\";\n    };\n    /**\n     * Compute the Color4 hash code\n     * @returns an unique number that can be used to hash Color4 objects\n     */\n    Color4.prototype.getHashCode = function () {\n        var hash = (this.r * 255) | 0;\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\n        hash = (hash * 397) ^ ((this.a * 255) | 0);\n        return hash;\n    };\n    /**\n     * Creates a new Color4 copied from the current one\n     * @returns a new Color4 object\n     */\n    Color4.prototype.clone = function () {\n        return new Color4(this.r, this.g, this.b, this.a);\n    };\n    /**\n     * Copies the given Color4 values into the current one\n     * @param source defines the source Color4 object\n     * @returns the current updated Color4 object\n     */\n    Color4.prototype.copyFrom = function (source) {\n        this.r = source.r;\n        this.g = source.g;\n        this.b = source.b;\n        this.a = source.a;\n        return this;\n    };\n    /**\n     * Copies the given float values into the current one\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @param a defines the alpha component to read from\n     * @returns the current updated Color4 object\n     */\n    Color4.prototype.copyFromFloats = function (r, g, b, a) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        return this;\n    };\n    /**\n     * Copies the given float values into the current one\n     * @param r defines the red component to read from\n     * @param g defines the green component to read from\n     * @param b defines the blue component to read from\n     * @param a defines the alpha component to read from\n     * @returns the current updated Color4 object\n     */\n    Color4.prototype.set = function (r, g, b, a) {\n        return this.copyFromFloats(r, g, b, a);\n    };\n    /**\n     * Compute the Color4 hexadecimal code as a string\n     * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\n     * @returns a string containing the hexadecimal representation of the Color4 object\n     */\n    Color4.prototype.toHexString = function (returnAsColor3) {\n        if (returnAsColor3 === void 0) { returnAsColor3 = false; }\n        var intR = Math.round(this.r * 255);\n        var intG = Math.round(this.g * 255);\n        var intB = Math.round(this.b * 255);\n        if (returnAsColor3) {\n            return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n        }\n        var intA = Math.round(this.a * 255);\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);\n    };\n    /**\n     * Computes a new Color4 converted from the current one to linear space\n     * @returns a new Color4 object\n     */\n    Color4.prototype.toLinearSpace = function () {\n        var convertedColor = new Color4();\n        this.toLinearSpaceToRef(convertedColor);\n        return convertedColor;\n    };\n    /**\n     * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color4 object where to store the linear space version\n     * @returns the unmodified Color4\n     */\n    Color4.prototype.toLinearSpaceToRef = function (convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\n        convertedColor.a = this.a;\n        return this;\n    };\n    /**\n     * Computes a new Color4 converted from the current one to gamma space\n     * @returns a new Color4 object\n     */\n    Color4.prototype.toGammaSpace = function () {\n        var convertedColor = new Color4();\n        this.toGammaSpaceToRef(convertedColor);\n        return convertedColor;\n    };\n    /**\n     * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\n     * @param convertedColor defines the Color4 object where to store the gamma space version\n     * @returns the unmodified Color4\n     */\n    Color4.prototype.toGammaSpaceToRef = function (convertedColor) {\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\n        convertedColor.a = this.a;\n        return this;\n    };\n    // Statics\n    /**\n     * Creates a new Color4 from the string containing valid hexadecimal values.\n     *\n     * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.\n     *\n     * When a hex string without alpha is passed, the resulting Color4 has\n     * its alpha value set to 1.0.\n     *\n     * An invalid string results in a Color with all its channels set to 0.0,\n     * i.e. \"transparent black\".\n     *\n     * @param hex defines a string containing valid hexadecimal values\n     * @returns a new Color4 object\n     */\n    Color4.FromHexString = function (hex) {\n        if (hex.substring(0, 1) !== \"#\" || (hex.length !== 9 && hex.length !== 7)) {\n            return new Color4(0.0, 0.0, 0.0, 0.0);\n        }\n        var r = parseInt(hex.substring(1, 3), 16);\n        var g = parseInt(hex.substring(3, 5), 16);\n        var b = parseInt(hex.substring(5, 7), 16);\n        var a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;\n        return Color4.FromInts(r, g, b, a);\n    };\n    /**\n     * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n     * @param left defines the start value\n     * @param right defines the end value\n     * @param amount defines the gradient factor\n     * @returns a new Color4 object\n     */\n    Color4.Lerp = function (left, right, amount) {\n        var result = new Color4(0.0, 0.0, 0.0, 0.0);\n        Color4.LerpToRef(left, right, amount, result);\n        return result;\n    };\n    /**\n     * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n     * @param left defines the start value\n     * @param right defines the end value\n     * @param amount defines the gradient factor\n     * @param result defines the Color4 object where to store data\n     */\n    Color4.LerpToRef = function (left, right, amount, result) {\n        result.r = left.r + (right.r - left.r) * amount;\n        result.g = left.g + (right.g - left.g) * amount;\n        result.b = left.b + (right.b - left.b) * amount;\n        result.a = left.a + (right.a - left.a) * amount;\n    };\n    /**\n     * Interpolate between two Color4 using Hermite interpolation\n     * @param value1 defines first Color4\n     * @param tangent1 defines the incoming tangent\n     * @param value2 defines second Color4\n     * @param tangent2 defines the outgoing tangent\n     * @param amount defines the target Color4\n     * @returns the new interpolated Color4\n     */\n    Color4.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n        var squared = amount * amount;\n        var cubed = amount * squared;\n        var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        var part2 = -2.0 * cubed + 3.0 * squared;\n        var part3 = cubed - 2.0 * squared + amount;\n        var part4 = cubed - squared;\n        var r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n        var g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n        var b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n        var a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;\n        return new Color4(r, g, b, a);\n    };\n    /**\n     * Returns a new Color4 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    Color4.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n        var result = new Color4();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    };\n    /**\n     * Update a Color4 with the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where to store the derivative\n     */\n    Color4.Hermite1stDerivativeToRef = function (value1, tangent1, value2, tangent2, time, result) {\n        var t2 = time * time;\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n        result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;\n    };\n    /**\n     * Creates a new Color4 from a Color3 and an alpha value\n     * @param color3 defines the source Color3 to read from\n     * @param alpha defines the alpha component (1.0 by default)\n     * @returns a new Color4 object\n     */\n    Color4.FromColor3 = function (color3, alpha) {\n        if (alpha === void 0) { alpha = 1.0; }\n        return new Color4(color3.r, color3.g, color3.b, alpha);\n    };\n    /**\n     * Creates a new Color4 from the starting index element of the given array\n     * @param array defines the source array to read from\n     * @param offset defines the offset in the source array\n     * @returns a new Color4 object\n     */\n    Color4.FromArray = function (array, offset) {\n        if (offset === void 0) { offset = 0; }\n        return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    };\n    /**\n     * Creates a new Color4 from the starting index element of the given array\n     * @param array defines the source array to read from\n     * @param offset defines the offset in the source array\n     * @param result defines the target Color4 object\n     */\n    Color4.FromArrayToRef = function (array, offset, result) {\n        if (offset === void 0) { offset = 0; }\n        result.r = array[offset];\n        result.g = array[offset + 1];\n        result.b = array[offset + 2];\n        result.a = array[offset + 3];\n    };\n    /**\n     * Creates a new Color3 from integer values (< 256)\n     * @param r defines the red component to read from (value between 0 and 255)\n     * @param g defines the green component to read from (value between 0 and 255)\n     * @param b defines the blue component to read from (value between 0 and 255)\n     * @param a defines the alpha component to read from (value between 0 and 255)\n     * @returns a new Color3 object\n     */\n    Color4.FromInts = function (r, g, b, a) {\n        return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n    };\n    /**\n     * Check the content of a given array and convert it to an array containing RGBA data\n     * If the original array was already containing count * 4 values then it is returned directly\n     * @param colors defines the array to check\n     * @param count defines the number of RGBA data to expect\n     * @returns an array containing count * 4 values (RGBA)\n     */\n    Color4.CheckColors4 = function (colors, count) {\n        // Check if color3 was used\n        if (colors.length === count * 3) {\n            var colors4 = [];\n            for (var index = 0; index < colors.length; index += 3) {\n                var newIndex = (index / 3) * 4;\n                colors4[newIndex] = colors[index];\n                colors4[newIndex + 1] = colors[index + 1];\n                colors4[newIndex + 2] = colors[index + 2];\n                colors4[newIndex + 3] = 1.0;\n            }\n            return colors4;\n        }\n        return colors;\n    };\n    return Color4;\n}());\nexport { Color4 };\n/**\n * @hidden\n */\nvar TmpColors = /** @class */ (function () {\n    function TmpColors() {\n    }\n    TmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);\n    TmpColors.Color4 = ArrayTools.BuildArray(3, function () { return new Color4(0, 0, 0, 0); });\n    return TmpColors;\n}());\nexport { TmpColors };\nRegisterClass(\"BABYLON.Color3\", Color3);\nRegisterClass(\"BABYLON.Color4\", Color4);\n//# sourceMappingURL=math.color.js.map","/**\n * Constant used to convert a value to gamma space\n * @ignorenaming\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport var ToGammaSpace = 1 / 2.2;\n/**\n * Constant used to convert a value to linear space\n * @ignorenaming\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport var ToLinearSpace = 2.2;\n/**\n * Constant Golden Ratio value in Babylon.js\n * @ignorenaming\n */\nexport var PHI = (1 + Math.sqrt(5)) / 2;\n/**\n * Constant used to define the minimal number value in Babylon.js\n * @ignorenaming\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar Epsilon = 0.001;\nexport { Epsilon };\n//# sourceMappingURL=math.constants.js.map","import { Plane } from \"./math.plane.js\";\n/**\n * Represents a camera frustum\n */\nvar Frustum = /** @class */ (function () {\n    function Frustum() {\n    }\n    /**\n     * Gets the planes representing the frustum\n     * @param transform matrix to be applied to the returned planes\n     * @returns a new array of 6 Frustum planes computed by the given transformation matrix.\n     */\n    Frustum.GetPlanes = function (transform) {\n        var frustumPlanes = [];\n        for (var index = 0; index < 6; index++) {\n            frustumPlanes.push(new Plane(0.0, 0.0, 0.0, 0.0));\n        }\n        Frustum.GetPlanesToRef(transform, frustumPlanes);\n        return frustumPlanes;\n    };\n    /**\n     * Gets the near frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    Frustum.GetNearPlaneToRef = function (transform, frustumPlane) {\n        var m = transform.m;\n        frustumPlane.normal.x = m[3] + m[2];\n        frustumPlane.normal.y = m[7] + m[6];\n        frustumPlane.normal.z = m[11] + m[10];\n        frustumPlane.d = m[15] + m[14];\n        frustumPlane.normalize();\n    };\n    /**\n     * Gets the far frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    Frustum.GetFarPlaneToRef = function (transform, frustumPlane) {\n        var m = transform.m;\n        frustumPlane.normal.x = m[3] - m[2];\n        frustumPlane.normal.y = m[7] - m[6];\n        frustumPlane.normal.z = m[11] - m[10];\n        frustumPlane.d = m[15] - m[14];\n        frustumPlane.normalize();\n    };\n    /**\n     * Gets the left frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    Frustum.GetLeftPlaneToRef = function (transform, frustumPlane) {\n        var m = transform.m;\n        frustumPlane.normal.x = m[3] + m[0];\n        frustumPlane.normal.y = m[7] + m[4];\n        frustumPlane.normal.z = m[11] + m[8];\n        frustumPlane.d = m[15] + m[12];\n        frustumPlane.normalize();\n    };\n    /**\n     * Gets the right frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    Frustum.GetRightPlaneToRef = function (transform, frustumPlane) {\n        var m = transform.m;\n        frustumPlane.normal.x = m[3] - m[0];\n        frustumPlane.normal.y = m[7] - m[4];\n        frustumPlane.normal.z = m[11] - m[8];\n        frustumPlane.d = m[15] - m[12];\n        frustumPlane.normalize();\n    };\n    /**\n     * Gets the top frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    Frustum.GetTopPlaneToRef = function (transform, frustumPlane) {\n        var m = transform.m;\n        frustumPlane.normal.x = m[3] - m[1];\n        frustumPlane.normal.y = m[7] - m[5];\n        frustumPlane.normal.z = m[11] - m[9];\n        frustumPlane.d = m[15] - m[13];\n        frustumPlane.normalize();\n    };\n    /**\n     * Gets the bottom frustum plane transformed by the transform matrix\n     * @param transform transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane the resulting frustum plane\n     */\n    Frustum.GetBottomPlaneToRef = function (transform, frustumPlane) {\n        var m = transform.m;\n        frustumPlane.normal.x = m[3] + m[1];\n        frustumPlane.normal.y = m[7] + m[5];\n        frustumPlane.normal.z = m[11] + m[9];\n        frustumPlane.d = m[15] + m[13];\n        frustumPlane.normalize();\n    };\n    /**\n     * Sets the given array \"frustumPlanes\" with the 6 Frustum planes computed by the given transformation matrix.\n     * @param transform transformation matrix to be applied to the resulting frustum planes\n     * @param frustumPlanes the resulting frustum planes\n     */\n    Frustum.GetPlanesToRef = function (transform, frustumPlanes) {\n        // Near\n        Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);\n        // Far\n        Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);\n        // Left\n        Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);\n        // Right\n        Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);\n        // Top\n        Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);\n        // Bottom\n        Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);\n    };\n    return Frustum;\n}());\nexport { Frustum };\n//# sourceMappingURL=math.frustum.js.map","import { __decorate } from \"tslib\";\nimport { Vector3 } from \"./math.vector.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\nvar MathHelpers = /** @class */ (function () {\n    function MathHelpers() {\n    }\n    MathHelpers.extractMinAndMaxIndexed = function (positions, indices, indexStart, indexCount, minimum, maximum) {\n        for (var index = indexStart; index < indexStart + indexCount; index++) {\n            var offset = indices[index] * 3;\n            var x = positions[offset];\n            var y = positions[offset + 1];\n            var z = positions[offset + 2];\n            minimum.minimizeInPlaceFromFloats(x, y, z);\n            maximum.maximizeInPlaceFromFloats(x, y, z);\n        }\n    };\n    MathHelpers.extractMinAndMax = function (positions, start, count, stride, minimum, maximum) {\n        for (var index = start, offset = start * stride; index < start + count; index++, offset += stride) {\n            var x = positions[offset];\n            var y = positions[offset + 1];\n            var z = positions[offset + 2];\n            minimum.minimizeInPlaceFromFloats(x, y, z);\n            maximum.maximizeInPlaceFromFloats(x, y, z);\n        }\n    };\n    __decorate([\n        nativeOverride.filter(function () {\n            var _a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                _a[_i] = arguments[_i];\n            }\n            var positions = _a[0], indices = _a[1];\n            return !Array.isArray(positions) && !Array.isArray(indices);\n        })\n    ], MathHelpers, \"extractMinAndMaxIndexed\", null);\n    __decorate([\n        nativeOverride.filter(function () {\n            var _a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                _a[_i] = arguments[_i];\n            }\n            var positions = _a[0];\n            return !Array.isArray(positions);\n        })\n    ], MathHelpers, \"extractMinAndMax\", null);\n    return MathHelpers;\n}());\n/**\n * Extracts minimum and maximum values from a list of indexed positions\n * @param positions defines the positions to use\n * @param indices defines the indices to the positions\n * @param indexStart defines the start index\n * @param indexCount defines the end index\n * @param bias defines bias value to add to the result\n * @return minimum and maximum values\n */\nexport function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias) {\n    if (bias === void 0) { bias = null; }\n    var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\n    if (bias) {\n        minimum.x -= minimum.x * bias.x + bias.y;\n        minimum.y -= minimum.y * bias.x + bias.y;\n        minimum.z -= minimum.z * bias.x + bias.y;\n        maximum.x += maximum.x * bias.x + bias.y;\n        maximum.y += maximum.y * bias.x + bias.y;\n        maximum.z += maximum.z * bias.x + bias.y;\n    }\n    return {\n        minimum: minimum,\n        maximum: maximum,\n    };\n}\n/**\n * Extracts minimum and maximum values from a list of positions\n * @param positions defines the positions to use\n * @param start defines the start index in the positions array\n * @param count defines the number of positions to handle\n * @param bias defines bias value to add to the result\n * @param stride defines the stride size to use (distance between two positions in the positions array)\n * @return minimum and maximum values\n */\nexport function extractMinAndMax(positions, start, count, bias, stride) {\n    if (bias === void 0) { bias = null; }\n    var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    if (!stride) {\n        stride = 3;\n    }\n    MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\n    if (bias) {\n        minimum.x -= minimum.x * bias.x + bias.y;\n        minimum.y -= minimum.y * bias.x + bias.y;\n        minimum.z -= minimum.z * bias.x + bias.y;\n        maximum.x += maximum.x * bias.x + bias.y;\n        maximum.y += maximum.y * bias.x + bias.y;\n        maximum.z += maximum.z * bias.x + bias.y;\n    }\n    return {\n        minimum: minimum,\n        maximum: maximum,\n    };\n}\n//# sourceMappingURL=math.functions.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Vector3 } from \"./math.vector.js\";\n/**\n * Class representing an isovector a vector containing 2 INTEGER coordinates\n * x axis is horizontal\n * y axis is 60 deg counter clockwise from positive y axis\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar _IsoVector = /** @class */ (function () {\n    /**\n     * Creates a new isovector from the given x and y coordinates\n     * @param x defines the first coordinate, must be an integer\n     * @param y defines the second coordinate, must be an integer\n     */\n    function _IsoVector(\n    /** defines the first coordinate */\n    x, \n    /** defines the second coordinate */\n    y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        this.x = x;\n        this.y = y;\n        if (x !== Math.floor(x)) {\n            x === Math.floor(x);\n            Logger.Warn(\"x is not an integer, floor(x) used\");\n        }\n        if (y !== Math.floor(y)) {\n            y === Math.floor(y);\n            Logger.Warn(\"y is not an integer, floor(y) used\");\n        }\n    }\n    // Operators\n    /**\n     * Gets a new IsoVector copied from the IsoVector\n     * @returns a new IsoVector\n     */\n    _IsoVector.prototype.clone = function () {\n        return new _IsoVector(this.x, this.y);\n    };\n    /**\n     * Rotates one IsoVector 60 degrees counter clockwise about another\n     * Please note that this is an in place operation\n     * @param other an IsoVector a center of rotation\n     * @returns the rotated IsoVector\n     */\n    _IsoVector.prototype.rotate60About = function (other) {\n        //other IsoVector\n        var x = this.x;\n        this.x = other.x + other.y - this.y;\n        this.y = x + this.y - other.x;\n        return this;\n    };\n    /**\n     * Rotates one IsoVector 60 degrees clockwise about another\n     * Please note that this is an in place operation\n     * @param other an IsoVector as center of rotation\n     * @returns the rotated IsoVector\n     */\n    _IsoVector.prototype.rotateNeg60About = function (other) {\n        var x = this.x;\n        this.x = x + this.y - other.y;\n        this.y = other.x + other.y - x;\n        return this;\n    };\n    /**\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\n     * Rotates one IsoVector 120 degrees counter clockwise about the center of the triangle\n     * Please note that this is an in place operation\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\n     * @returns the rotated IsoVector\n     */\n    _IsoVector.prototype.rotate120 = function (m, n) {\n        //m, n integers\n        if (m !== Math.floor(m)) {\n            m === Math.floor(m);\n            Logger.Warn(\"m not an integer only floor(m) used\");\n        }\n        if (n !== Math.floor(n)) {\n            n === Math.floor(n);\n            Logger.Warn(\"n not an integer only floor(n) used\");\n        }\n        var x = this.x;\n        this.x = m - x - this.y;\n        this.y = n + x;\n        return this;\n    };\n    /**\n     * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)\n     * Rotates one IsoVector 120 degrees clockwise about the center of the triangle\n     * Please note that this is an in place operation\n     * @param m integer a measure a Primary triangle of order (m, n) m > n\n     * @param n >= 0 integer a measure for a Primary triangle of order (m, n)\n     * @returns the rotated IsoVector\n     */\n    _IsoVector.prototype.rotateNeg120 = function (m, n) {\n        //m, n integers\n        if (m !== Math.floor(m)) {\n            m === Math.floor(m);\n            Logger.Warn(\"m is not an integer, floor(m) used\");\n        }\n        if (n !== Math.floor(n)) {\n            n === Math.floor(n);\n            Logger.Warn(\"n is not an integer,   floor(n) used\");\n        }\n        var x = this.x;\n        this.x = this.y - n;\n        this.y = m + n - x - this.y;\n        return this;\n    };\n    /**\n     * Transforms an IsoVector to one in Cartesian 3D space based on an isovector\n     * @param origin an IsoVector\n     * @param isoGridSize\n     * @returns Point as a Vector3\n     */\n    _IsoVector.prototype.toCartesianOrigin = function (origin, isoGridSize) {\n        var point = Vector3.Zero();\n        point.x = origin.x + 2 * this.x * isoGridSize + this.y * isoGridSize;\n        point.y = origin.y + Math.sqrt(3) * this.y * isoGridSize;\n        return point;\n    };\n    // Statics\n    /**\n     * Gets a new IsoVector(0, 0)\n     * @returns a new IsoVector\n     */\n    _IsoVector.Zero = function () {\n        return new _IsoVector(0, 0);\n    };\n    return _IsoVector;\n}());\nexport { _IsoVector };\n//# sourceMappingURL=math.isovector.js.map","import { Scalar } from \"./math.scalar.js\";\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector.js\";\nimport { Epsilon } from \"./math.constants.js\";\n/**\n * Defines potential orientation for back face culling\n */\nexport var Orientation;\n(function (Orientation) {\n    /**\n     * Clockwise\n     */\n    Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n    /** Counter clockwise */\n    Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n})(Orientation || (Orientation = {}));\n/** Class used to represent a Bezier curve */\nvar BezierCurve = /** @class */ (function () {\n    function BezierCurve() {\n    }\n    /**\n     * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\n     * @param t defines the time\n     * @param x1 defines the left coordinate on X axis\n     * @param y1 defines the left coordinate on Y axis\n     * @param x2 defines the right coordinate on X axis\n     * @param y2 defines the right coordinate on Y axis\n     * @returns the interpolated value\n     */\n    BezierCurve.Interpolate = function (t, x1, y1, x2, y2) {\n        // Extract X (which is equal to time here)\n        var f0 = 1 - 3 * x2 + 3 * x1;\n        var f1 = 3 * x2 - 6 * x1;\n        var f2 = 3 * x1;\n        var refinedT = t;\n        for (var i = 0; i < 5; i++) {\n            var refinedT2 = refinedT * refinedT;\n            var refinedT3 = refinedT2 * refinedT;\n            var x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n            var slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n            refinedT -= (x - t) * slope;\n            refinedT = Math.min(1, Math.max(0, refinedT));\n        }\n        // Resolve cubic bezier for the given x\n        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\n    };\n    return BezierCurve;\n}());\nexport { BezierCurve };\n/**\n * Defines angle representation\n */\nvar Angle = /** @class */ (function () {\n    /**\n     * Creates an Angle object of \"radians\" radians (float).\n     * @param radians the angle in radians\n     */\n    function Angle(radians) {\n        this._radians = radians;\n        if (this._radians < 0.0) {\n            this._radians += 2.0 * Math.PI;\n        }\n    }\n    /**\n     * Get value in degrees\n     * @returns the Angle value in degrees (float)\n     */\n    Angle.prototype.degrees = function () {\n        return (this._radians * 180.0) / Math.PI;\n    };\n    /**\n     * Get value in radians\n     * @returns the Angle value in radians (float)\n     */\n    Angle.prototype.radians = function () {\n        return this._radians;\n    };\n    /**\n     * Gets a new Angle object valued with the gradient angle, in radians, of the line joining two points\n     * @param a defines first point as the origin\n     * @param b defines point\n     * @returns a new Angle\n     */\n    Angle.BetweenTwoPoints = function (a, b) {\n        var delta = b.subtract(a);\n        var theta = Math.atan2(delta.y, delta.x);\n        return new Angle(theta);\n    };\n    /**\n     * Gets a new Angle object from the given float in radians\n     * @param radians defines the angle value in radians\n     * @returns a new Angle\n     */\n    Angle.FromRadians = function (radians) {\n        return new Angle(radians);\n    };\n    /**\n     * Gets a new Angle object from the given float in degrees\n     * @param degrees defines the angle value in degrees\n     * @returns a new Angle\n     */\n    Angle.FromDegrees = function (degrees) {\n        return new Angle((degrees * Math.PI) / 180.0);\n    };\n    return Angle;\n}());\nexport { Angle };\n/**\n * This represents an arc in a 2d space.\n */\nvar Arc2 = /** @class */ (function () {\n    /**\n     * Creates an Arc object from the three given points : start, middle and end.\n     * @param startPoint Defines the start point of the arc\n     * @param midPoint Defines the middle point of the arc\n     * @param endPoint Defines the end point of the arc\n     */\n    function Arc2(\n    /** Defines the start point of the arc */\n    startPoint, \n    /** Defines the mid point of the arc */\n    midPoint, \n    /** Defines the end point of the arc */\n    endPoint) {\n        this.startPoint = startPoint;\n        this.midPoint = midPoint;\n        this.endPoint = endPoint;\n        var temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n        var startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\n        var midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\n        var det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n        this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);\n        this.radius = this.centerPoint.subtract(this.startPoint).length();\n        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n        var a1 = this.startAngle.degrees();\n        var a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n        var a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\n        // angles correction\n        if (a2 - a1 > +180.0) {\n            a2 -= 360.0;\n        }\n        if (a2 - a1 < -180.0) {\n            a2 += 360.0;\n        }\n        if (a3 - a2 > +180.0) {\n            a3 -= 360.0;\n        }\n        if (a3 - a2 < -180.0) {\n            a3 += 360.0;\n        }\n        this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\n        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\n    }\n    return Arc2;\n}());\nexport { Arc2 };\n/**\n * Represents a 2D path made up of multiple 2D points\n */\nvar Path2 = /** @class */ (function () {\n    /**\n     * Creates a Path2 object from the starting 2D coordinates x and y.\n     * @param x the starting points x value\n     * @param y the starting points y value\n     */\n    function Path2(x, y) {\n        this._points = new Array();\n        this._length = 0.0;\n        /**\n         * If the path start and end point are the same\n         */\n        this.closed = false;\n        this._points.push(new Vector2(x, y));\n    }\n    /**\n     * Adds a new segment until the given coordinates (x, y) to the current Path2.\n     * @param x the added points x value\n     * @param y the added points y value\n     * @returns the updated Path2.\n     */\n    Path2.prototype.addLineTo = function (x, y) {\n        if (this.closed) {\n            return this;\n        }\n        var newPoint = new Vector2(x, y);\n        var previousPoint = this._points[this._points.length - 1];\n        this._points.push(newPoint);\n        this._length += newPoint.subtract(previousPoint).length();\n        return this;\n    };\n    /**\n     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\n     * @param midX middle point x value\n     * @param midY middle point y value\n     * @param endX end point x value\n     * @param endY end point y value\n     * @param numberOfSegments (default: 36)\n     * @returns the updated Path2.\n     */\n    Path2.prototype.addArcTo = function (midX, midY, endX, endY, numberOfSegments) {\n        if (numberOfSegments === void 0) { numberOfSegments = 36; }\n        if (this.closed) {\n            return this;\n        }\n        var startPoint = this._points[this._points.length - 1];\n        var midPoint = new Vector2(midX, midY);\n        var endPoint = new Vector2(endX, endY);\n        var arc = new Arc2(startPoint, midPoint, endPoint);\n        var increment = arc.angle.radians() / numberOfSegments;\n        if (arc.orientation === Orientation.CW) {\n            increment *= -1;\n        }\n        var currentAngle = arc.startAngle.radians() + increment;\n        for (var i = 0; i < numberOfSegments; i++) {\n            var x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n            var y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n            this.addLineTo(x, y);\n            currentAngle += increment;\n        }\n        return this;\n    };\n    /**\n     * Closes the Path2.\n     * @returns the Path2.\n     */\n    Path2.prototype.close = function () {\n        this.closed = true;\n        return this;\n    };\n    /**\n     * Gets the sum of the distance between each sequential point in the path\n     * @returns the Path2 total length (float).\n     */\n    Path2.prototype.length = function () {\n        var result = this._length;\n        if (this.closed) {\n            var lastPoint = this._points[this._points.length - 1];\n            var firstPoint = this._points[0];\n            result += firstPoint.subtract(lastPoint).length();\n        }\n        return result;\n    };\n    /**\n     * Gets the points which construct the path\n     * @returns the Path2 internal array of points.\n     */\n    Path2.prototype.getPoints = function () {\n        return this._points;\n    };\n    /**\n     * Retreives the point at the distance aways from the starting point\n     * @param normalizedLengthPosition the length along the path to retrieve the point from\n     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\n     */\n    Path2.prototype.getPointAtLengthPosition = function (normalizedLengthPosition) {\n        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n            return Vector2.Zero();\n        }\n        var lengthPosition = normalizedLengthPosition * this.length();\n        var previousOffset = 0;\n        for (var i = 0; i < this._points.length; i++) {\n            var j = (i + 1) % this._points.length;\n            var a = this._points[i];\n            var b = this._points[j];\n            var bToA = b.subtract(a);\n            var nextOffset = bToA.length() + previousOffset;\n            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n                var dir = bToA.normalize();\n                var localOffset = lengthPosition - previousOffset;\n                return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\n            }\n            previousOffset = nextOffset;\n        }\n        return Vector2.Zero();\n    };\n    /**\n     * Creates a new path starting from an x and y position\n     * @param x starting x value\n     * @param y starting y value\n     * @returns a new Path2 starting at the coordinates (x, y).\n     */\n    Path2.StartingAt = function (x, y) {\n        return new Path2(x, y);\n    };\n    return Path2;\n}());\nexport { Path2 };\n/**\n * Represents a 3D path made up of multiple 3D points\n * @see https://doc.babylonjs.com/divingDeeper/mesh/path3D\n */\nvar Path3D = /** @class */ (function () {\n    /**\n     * new Path3D(path, normal, raw)\n     * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\n     * please read the description in the tutorial : https://doc.babylonjs.com/how_to/how_to_use_path3d\n     * @param path an array of Vector3, the curve axis of the Path3D\n     * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\n     * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\n     */\n    function Path3D(\n    /**\n     * an array of Vector3, the curve axis of the Path3D\n     */\n    path, firstNormal, raw, alignTangentsWithPath) {\n        if (firstNormal === void 0) { firstNormal = null; }\n        if (alignTangentsWithPath === void 0) { alignTangentsWithPath = false; }\n        this.path = path;\n        this._curve = new Array();\n        this._distances = new Array();\n        this._tangents = new Array();\n        this._normals = new Array();\n        this._binormals = new Array();\n        // holds interpolated point data\n        this._pointAtData = {\n            id: 0,\n            point: Vector3.Zero(),\n            previousPointArrayIndex: 0,\n            position: 0,\n            subPosition: 0,\n            interpolateReady: false,\n            interpolationMatrix: Matrix.Identity(),\n        };\n        for (var p = 0; p < path.length; p++) {\n            this._curve[p] = path[p].clone(); // hard copy\n        }\n        this._raw = raw || false;\n        this._alignTangentsWithPath = alignTangentsWithPath;\n        this._compute(firstNormal, alignTangentsWithPath);\n    }\n    /**\n     * Returns the Path3D array of successive Vector3 designing its curve.\n     * @returns the Path3D array of successive Vector3 designing its curve.\n     */\n    Path3D.prototype.getCurve = function () {\n        return this._curve;\n    };\n    /**\n     * Returns the Path3D array of successive Vector3 designing its curve.\n     * @returns the Path3D array of successive Vector3 designing its curve.\n     */\n    Path3D.prototype.getPoints = function () {\n        return this._curve;\n    };\n    /**\n     * @returns the computed length (float) of the path.\n     */\n    Path3D.prototype.length = function () {\n        return this._distances[this._distances.length - 1];\n    };\n    /**\n     * Returns an array populated with tangent vectors on each Path3D curve point.\n     * @returns an array populated with tangent vectors on each Path3D curve point.\n     */\n    Path3D.prototype.getTangents = function () {\n        return this._tangents;\n    };\n    /**\n     * Returns an array populated with normal vectors on each Path3D curve point.\n     * @returns an array populated with normal vectors on each Path3D curve point.\n     */\n    Path3D.prototype.getNormals = function () {\n        return this._normals;\n    };\n    /**\n     * Returns an array populated with binormal vectors on each Path3D curve point.\n     * @returns an array populated with binormal vectors on each Path3D curve point.\n     */\n    Path3D.prototype.getBinormals = function () {\n        return this._binormals;\n    };\n    /**\n     * Returns an array populated with distances (float) of the i-th point from the first curve point.\n     * @returns an array populated with distances (float) of the i-th point from the first curve point.\n     */\n    Path3D.prototype.getDistances = function () {\n        return this._distances;\n    };\n    /**\n     * Returns an interpolated point along this path\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @returns a new Vector3 as the point\n     */\n    Path3D.prototype.getPointAt = function (position) {\n        return this._updatePointAtData(position).point;\n    };\n    /**\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\n     * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\n     */\n    Path3D.prototype.getTangentAt = function (position, interpolated) {\n        if (interpolated === void 0) { interpolated = false; }\n        this._updatePointAtData(position, interpolated);\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\n    };\n    /**\n     * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\n     * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\n     */\n    Path3D.prototype.getNormalAt = function (position, interpolated) {\n        if (interpolated === void 0) { interpolated = false; }\n        this._updatePointAtData(position, interpolated);\n        return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\n    };\n    /**\n     * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\n     * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\n     */\n    Path3D.prototype.getBinormalAt = function (position, interpolated) {\n        if (interpolated === void 0) { interpolated = false; }\n        this._updatePointAtData(position, interpolated);\n        return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\n    };\n    /**\n     * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\n     * @param position the position of the point along this path, from 0.0 to 1.0\n     * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\n     */\n    Path3D.prototype.getDistanceAt = function (position) {\n        return this.length() * position;\n    };\n    /**\n     * Returns the array index of the previous point of an interpolated point along this path\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n     * @returns the array index\n     */\n    Path3D.prototype.getPreviousPointIndexAt = function (position) {\n        this._updatePointAtData(position);\n        return this._pointAtData.previousPointArrayIndex;\n    };\n    /**\n     * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\n     * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n     * @returns the sub position\n     */\n    Path3D.prototype.getSubPositionAt = function (position) {\n        this._updatePointAtData(position);\n        return this._pointAtData.subPosition;\n    };\n    /**\n     * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\n     * @param target the vector of which to get the closest position to\n     * @returns the position of the closest virtual point on this path to the target vector\n     */\n    Path3D.prototype.getClosestPositionTo = function (target) {\n        var smallestDistance = Number.MAX_VALUE;\n        var closestPosition = 0.0;\n        for (var i = 0; i < this._curve.length - 1; i++) {\n            var point = this._curve[i + 0];\n            var tangent = this._curve[i + 1].subtract(point).normalize();\n            var subLength = this._distances[i + 1] - this._distances[i + 0];\n            var subPosition = Math.min((Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target)) / subLength, 1.0);\n            var distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\n            if (distance < smallestDistance) {\n                smallestDistance = distance;\n                closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\n            }\n        }\n        return closestPosition;\n    };\n    /**\n     * Returns a sub path (slice) of this path\n     * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n     * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n     * @returns a sub path (slice) of this path\n     */\n    Path3D.prototype.slice = function (start, end) {\n        if (start === void 0) { start = 0.0; }\n        if (end === void 0) { end = 1.0; }\n        if (start < 0.0) {\n            start = 1 - ((start * -1.0) % 1.0);\n        }\n        if (end < 0.0) {\n            end = 1 - ((end * -1.0) % 1.0);\n        }\n        if (start > end) {\n            var _start = start;\n            start = end;\n            end = _start;\n        }\n        var curvePoints = this.getCurve();\n        var startPoint = this.getPointAt(start);\n        var startIndex = this.getPreviousPointIndexAt(start);\n        var endPoint = this.getPointAt(end);\n        var endIndex = this.getPreviousPointIndexAt(end) + 1;\n        var slicePoints = [];\n        if (start !== 0.0) {\n            startIndex++;\n            slicePoints.push(startPoint);\n        }\n        slicePoints.push.apply(slicePoints, curvePoints.slice(startIndex, endIndex));\n        if (end !== 1.0 || start === 1.0) {\n            slicePoints.push(endPoint);\n        }\n        return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\n    };\n    /**\n     * Forces the Path3D tangent, normal, binormal and distance recomputation.\n     * @param path path which all values are copied into the curves points\n     * @param firstNormal which should be projected onto the curve\n     * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\n     * @returns the same object updated.\n     */\n    Path3D.prototype.update = function (path, firstNormal, alignTangentsWithPath) {\n        if (firstNormal === void 0) { firstNormal = null; }\n        if (alignTangentsWithPath === void 0) { alignTangentsWithPath = false; }\n        for (var p = 0; p < path.length; p++) {\n            this._curve[p].x = path[p].x;\n            this._curve[p].y = path[p].y;\n            this._curve[p].z = path[p].z;\n        }\n        this._compute(firstNormal, alignTangentsWithPath);\n        return this;\n    };\n    // private function compute() : computes tangents, normals and binormals\n    Path3D.prototype._compute = function (firstNormal, alignTangentsWithPath) {\n        if (alignTangentsWithPath === void 0) { alignTangentsWithPath = false; }\n        var l = this._curve.length;\n        if (l < 2) {\n            return;\n        }\n        // first and last tangents\n        this._tangents[0] = this._getFirstNonNullVector(0);\n        if (!this._raw) {\n            this._tangents[0].normalize();\n        }\n        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n        if (!this._raw) {\n            this._tangents[l - 1].normalize();\n        }\n        // normals and binormals at first point : arbitrary vector with _normalVector()\n        var tg0 = this._tangents[0];\n        var pp0 = this._normalVector(tg0, firstNormal);\n        this._normals[0] = pp0;\n        if (!this._raw) {\n            this._normals[0].normalize();\n        }\n        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\n        if (!this._raw) {\n            this._binormals[0].normalize();\n        }\n        this._distances[0] = 0.0;\n        // normals and binormals : next points\n        var prev; // previous vector (segment)\n        var cur; // current vector (segment)\n        var curTang; // current tangent\n        // previous normal\n        var prevNor; // previous normal\n        var prevBinor; // previous binormal\n        for (var i = 1; i < l; i++) {\n            // tangents\n            prev = this._getLastNonNullVector(i);\n            if (i < l - 1) {\n                cur = this._getFirstNonNullVector(i);\n                this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\n                this._tangents[i].normalize();\n            }\n            this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();\n            // normals and binormals\n            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\n            curTang = this._tangents[i];\n            prevBinor = this._binormals[i - 1];\n            this._normals[i] = Vector3.Cross(prevBinor, curTang);\n            if (!this._raw) {\n                if (this._normals[i].length() === 0) {\n                    prevNor = this._normals[i - 1];\n                    this._normals[i] = prevNor.clone();\n                }\n                else {\n                    this._normals[i].normalize();\n                }\n            }\n            this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\n            if (!this._raw) {\n                this._binormals[i].normalize();\n            }\n        }\n        this._pointAtData.id = NaN;\n    };\n    // private function getFirstNonNullVector(index)\n    // returns the first non null vector from index : curve[index + N].subtract(curve[index])\n    Path3D.prototype._getFirstNonNullVector = function (index) {\n        var i = 1;\n        var nNVector = this._curve[index + i].subtract(this._curve[index]);\n        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\n            i++;\n            nNVector = this._curve[index + i].subtract(this._curve[index]);\n        }\n        return nNVector;\n    };\n    // private function getLastNonNullVector(index)\n    // returns the last non null vector from index : curve[index].subtract(curve[index - N])\n    Path3D.prototype._getLastNonNullVector = function (index) {\n        var i = 1;\n        var nLVector = this._curve[index].subtract(this._curve[index - i]);\n        while (nLVector.length() === 0 && index > i + 1) {\n            i++;\n            nLVector = this._curve[index].subtract(this._curve[index - i]);\n        }\n        return nLVector;\n    };\n    // private function normalVector(v0, vt, va) :\n    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\n    Path3D.prototype._normalVector = function (vt, va) {\n        var normal0;\n        var tgl = vt.length();\n        if (tgl === 0.0) {\n            tgl = 1.0;\n        }\n        if (va === undefined || va === null) {\n            var point = void 0;\n            if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\n                // search for a point in the plane\n                point = new Vector3(0.0, -1.0, 0.0);\n            }\n            else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\n                point = new Vector3(1.0, 0.0, 0.0);\n            }\n            else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\n                point = new Vector3(0.0, 0.0, 1.0);\n            }\n            else {\n                point = Vector3.Zero();\n            }\n            normal0 = Vector3.Cross(vt, point);\n        }\n        else {\n            normal0 = Vector3.Cross(vt, va);\n            Vector3.CrossToRef(normal0, vt, normal0);\n        }\n        normal0.normalize();\n        return normal0;\n    };\n    /**\n     * Updates the point at data for an interpolated point along this curve\n     * @param position the position of the point along this curve, from 0.0 to 1.0\n     * @param interpolateTNB\n     * @interpolateTNB whether to compute the interpolated tangent, normal and binormal\n     * @returns the (updated) point at data\n     */\n    Path3D.prototype._updatePointAtData = function (position, interpolateTNB) {\n        if (interpolateTNB === void 0) { interpolateTNB = false; }\n        // set an id for caching the result\n        if (this._pointAtData.id === position) {\n            if (!this._pointAtData.interpolateReady) {\n                this._updateInterpolationMatrix();\n            }\n            return this._pointAtData;\n        }\n        else {\n            this._pointAtData.id = position;\n        }\n        var curvePoints = this.getPoints();\n        // clamp position between 0.0 and 1.0\n        if (position <= 0.0) {\n            return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\n        }\n        else if (position >= 1.0) {\n            return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\n        }\n        var previousPoint = curvePoints[0];\n        var currentPoint;\n        var currentLength = 0.0;\n        var targetLength = position * this.length();\n        for (var i = 1; i < curvePoints.length; i++) {\n            currentPoint = curvePoints[i];\n            var distance = Vector3.Distance(previousPoint, currentPoint);\n            currentLength += distance;\n            if (currentLength === targetLength) {\n                return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\n            }\n            else if (currentLength > targetLength) {\n                var toLength = currentLength - targetLength;\n                var diff = toLength / distance;\n                var dir = previousPoint.subtract(currentPoint);\n                var point = currentPoint.add(dir.scaleInPlace(diff));\n                return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\n            }\n            previousPoint = currentPoint;\n        }\n        return this._pointAtData;\n    };\n    /**\n     * Updates the point at data from the specified parameters\n     * @param position where along the path the interpolated point is, from 0.0 to 1.0\n     * @param subPosition\n     * @param point the interpolated point\n     * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\n     * @param interpolateTNB\n     */\n    Path3D.prototype._setPointAtData = function (position, subPosition, point, parentIndex, interpolateTNB) {\n        this._pointAtData.point = point;\n        this._pointAtData.position = position;\n        this._pointAtData.subPosition = subPosition;\n        this._pointAtData.previousPointArrayIndex = parentIndex;\n        this._pointAtData.interpolateReady = interpolateTNB;\n        if (interpolateTNB) {\n            this._updateInterpolationMatrix();\n        }\n        return this._pointAtData;\n    };\n    /**\n     * Updates the point at interpolation matrix for the tangents, normals and binormals\n     */\n    Path3D.prototype._updateInterpolationMatrix = function () {\n        this._pointAtData.interpolationMatrix = Matrix.Identity();\n        var parentIndex = this._pointAtData.previousPointArrayIndex;\n        if (parentIndex !== this._tangents.length - 1) {\n            var index = parentIndex + 1;\n            var tangentFrom = this._tangents[parentIndex].clone();\n            var normalFrom = this._normals[parentIndex].clone();\n            var binormalFrom = this._binormals[parentIndex].clone();\n            var tangentTo = this._tangents[index].clone();\n            var normalTo = this._normals[index].clone();\n            var binormalTo = this._binormals[index].clone();\n            var quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\n            var quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\n            var quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\n            quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\n        }\n    };\n    return Path3D;\n}());\nexport { Path3D };\n/**\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n * A Curve3 is designed from a series of successive Vector3.\n * @see https://doc.babylonjs.com/how_to/how_to_use_curve3\n */\nvar Curve3 = /** @class */ (function () {\n    /**\n     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n     * A Curve3 is designed from a series of successive Vector3.\n     * Tuto : https://doc.babylonjs.com/how_to/how_to_use_curve3#curve3-object\n     * @param points points which make up the curve\n     */\n    function Curve3(points) {\n        this._length = 0.0;\n        this._points = points;\n        this._length = this._computeLength(points);\n    }\n    /**\n     * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#quadratic-bezier-curve\n     * @param v0 (Vector3) the origin point of the Quadratic Bezier\n     * @param v1 (Vector3) the control point\n     * @param v2 (Vector3) the end point of the Quadratic Bezier\n     * @param nbPoints (integer) the wanted number of points in the curve\n     * @returns the created Curve3\n     */\n    Curve3.CreateQuadraticBezier = function (v0, v1, v2, nbPoints) {\n        nbPoints = nbPoints > 2 ? nbPoints : 3;\n        var bez = new Array();\n        var equation = function (t, val0, val1, val2) {\n            var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n            return res;\n        };\n        for (var i = 0; i <= nbPoints; i++) {\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\n        }\n        return new Curve3(bez);\n    };\n    /**\n     * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#cubic-bezier-curve\n     * @param v0 (Vector3) the origin point of the Cubic Bezier\n     * @param v1 (Vector3) the first control point\n     * @param v2 (Vector3) the second control point\n     * @param v3 (Vector3) the end point of the Cubic Bezier\n     * @param nbPoints (integer) the wanted number of points in the curve\n     * @returns the created Curve3\n     */\n    Curve3.CreateCubicBezier = function (v0, v1, v2, v3, nbPoints) {\n        nbPoints = nbPoints > 3 ? nbPoints : 4;\n        var bez = new Array();\n        var equation = function (t, val0, val1, val2, val3) {\n            var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\n            return res;\n        };\n        for (var i = 0; i <= nbPoints; i++) {\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\n        }\n        return new Curve3(bez);\n    };\n    /**\n     * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#hermite-spline\n     * @param p1 (Vector3) the origin point of the Hermite Spline\n     * @param t1 (Vector3) the tangent vector at the origin point\n     * @param p2 (Vector3) the end point of the Hermite Spline\n     * @param t2 (Vector3) the tangent vector at the end point\n     * @param nbPoints (integer) the wanted number of points in the curve\n     * @returns the created Curve3\n     */\n    Curve3.CreateHermiteSpline = function (p1, t1, p2, t2, nbPoints) {\n        var hermite = new Array();\n        var step = 1.0 / nbPoints;\n        for (var i = 0; i <= nbPoints; i++) {\n            hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\n        }\n        return new Curve3(hermite);\n    };\n    /**\n     * Returns a Curve3 object along a CatmullRom Spline curve :\n     * @param points (array of Vector3) the points the spline must pass through. At least, four points required\n     * @param nbPoints (integer) the wanted number of points between each curve control points\n     * @param closed (boolean) optional with default false, when true forms a closed loop from the points\n     * @returns the created Curve3\n     */\n    Curve3.CreateCatmullRomSpline = function (points, nbPoints, closed) {\n        var catmullRom = new Array();\n        var step = 1.0 / nbPoints;\n        var amount = 0.0;\n        if (closed) {\n            var pointsCount = points.length;\n            for (var i = 0; i < pointsCount; i++) {\n                amount = 0;\n                for (var c = 0; c < nbPoints; c++) {\n                    catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\n                    amount += step;\n                }\n            }\n            catmullRom.push(catmullRom[0]);\n        }\n        else {\n            var totalPoints = new Array();\n            totalPoints.push(points[0].clone());\n            Array.prototype.push.apply(totalPoints, points);\n            totalPoints.push(points[points.length - 1].clone());\n            var i = 0;\n            for (; i < totalPoints.length - 3; i++) {\n                amount = 0;\n                for (var c = 0; c < nbPoints; c++) {\n                    catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n                    amount += step;\n                }\n            }\n            i--;\n            catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n        }\n        return new Curve3(catmullRom);\n    };\n    /**\n     * Returns a Curve3 object along an arc through three vector3 points:\n     * The three points should not be colinear. When they are the Curve3 is empty.\n     * @param first (Vector3) the first point the arc must pass through.\n     * @param second (Vector3) the second point the arc must pass through.\n     * @param third (Vector3) the third point the arc must pass through.\n     * @param steps (number) the larger the number of steps the more detailed the arc.\n     * @param closed (boolean) optional with default false, when true forms the chord from the first and third point\n     * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points\n     * @returns the created Curve3\n     */\n    Curve3.ArcThru3Points = function (first, second, third, steps, closed, fullCircle) {\n        if (steps === void 0) { steps = 32; }\n        if (closed === void 0) { closed = false; }\n        if (fullCircle === void 0) { fullCircle = false; }\n        var arc = new Array();\n        var vec1 = second.subtract(first);\n        var vec2 = third.subtract(second);\n        var vec3 = first.subtract(third);\n        var zAxis = Vector3.Cross(vec1, vec2);\n        var len4 = zAxis.length();\n        if (len4 < Math.pow(10, -8)) {\n            return new Curve3(arc); // colinear points arc is empty\n        }\n        var len1_sq = vec1.lengthSquared();\n        var len2_sq = vec2.lengthSquared();\n        var len3_sq = vec3.lengthSquared();\n        var len4_sq = zAxis.lengthSquared();\n        var len1 = vec1.length();\n        var len2 = vec2.length();\n        var len3 = vec3.length();\n        var radius = (0.5 * len1 * len2 * len3) / len4;\n        var dot1 = Vector3.Dot(vec1, vec3);\n        var dot2 = Vector3.Dot(vec1, vec2);\n        var dot3 = Vector3.Dot(vec2, vec3);\n        var a = (-0.5 * len2_sq * dot1) / len4_sq;\n        var b = (-0.5 * len3_sq * dot2) / len4_sq;\n        var c = (-0.5 * len1_sq * dot3) / len4_sq;\n        var center = first.scale(a).add(second.scale(b)).add(third.scale(c));\n        var radiusVec = first.subtract(center);\n        var xAxis = radiusVec.normalize();\n        var yAxis = Vector3.Cross(zAxis, xAxis).normalize();\n        if (fullCircle) {\n            var dStep = (2 * Math.PI) / steps;\n            for (var theta = 0; theta <= 2 * Math.PI; theta += dStep) {\n                arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));\n            }\n            arc.push(first);\n        }\n        else {\n            var dStep = 1 / steps;\n            var theta = 0;\n            var point = Vector3.Zero();\n            do {\n                point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));\n                arc.push(point);\n                theta += dStep;\n            } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));\n            arc.push(third);\n            if (closed) {\n                arc.push(first);\n            }\n        }\n        return new Curve3(arc);\n    };\n    /**\n     * @returns the Curve3 stored array of successive Vector3\n     */\n    Curve3.prototype.getPoints = function () {\n        return this._points;\n    };\n    /**\n     * @returns the computed length (float) of the curve.\n     */\n    Curve3.prototype.length = function () {\n        return this._length;\n    };\n    /**\n     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\n     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\n     * curveA and curveB keep unchanged.\n     * @param curve the curve to continue from this curve\n     * @returns the newly constructed curve\n     */\n    Curve3.prototype.continue = function (curve) {\n        var lastPoint = this._points[this._points.length - 1];\n        var continuedPoints = this._points.slice();\n        var curvePoints = curve.getPoints();\n        for (var i = 1; i < curvePoints.length; i++) {\n            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n        }\n        var continuedCurve = new Curve3(continuedPoints);\n        return continuedCurve;\n    };\n    Curve3.prototype._computeLength = function (path) {\n        var l = 0;\n        for (var i = 1; i < path.length; i++) {\n            l += path[i].subtract(path[i - 1]).length();\n        }\n        return l;\n    };\n    return Curve3;\n}());\nexport { Curve3 };\n//# sourceMappingURL=math.path.js.map","import { Vector3, Matrix } from \"./math.vector.js\";\n/**\n * Represents a plane by the equation ax + by + cz + d = 0\n */\nvar Plane = /** @class */ (function () {\n    /**\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\n     * @param a a component of the plane\n     * @param b b component of the plane\n     * @param c c component of the plane\n     * @param d d component of the plane\n     */\n    function Plane(a, b, c, d) {\n        this.normal = new Vector3(a, b, c);\n        this.d = d;\n    }\n    /**\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\n     */\n    Plane.prototype.asArray = function () {\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\n    };\n    // Methods\n    /**\n     * @returns a new plane copied from the current Plane.\n     */\n    Plane.prototype.clone = function () {\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n    };\n    /**\n     * @returns the string \"Plane\".\n     */\n    Plane.prototype.getClassName = function () {\n        return \"Plane\";\n    };\n    /**\n     * @returns the Plane hash code.\n     */\n    Plane.prototype.getHashCode = function () {\n        var hash = this.normal.getHashCode();\n        hash = (hash * 397) ^ (this.d | 0);\n        return hash;\n    };\n    /**\n     * Normalize the current Plane in place.\n     * @returns the updated Plane.\n     */\n    Plane.prototype.normalize = function () {\n        var norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\n        var magnitude = 0.0;\n        if (norm !== 0) {\n            magnitude = 1.0 / norm;\n        }\n        this.normal.x *= magnitude;\n        this.normal.y *= magnitude;\n        this.normal.z *= magnitude;\n        this.d *= magnitude;\n        return this;\n    };\n    /**\n     * Applies a transformation the plane and returns the result\n     * @param transformation the transformation matrix to be applied to the plane\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\n     */\n    Plane.prototype.transform = function (transformation) {\n        var invertedMatrix = Plane._TmpMatrix;\n        transformation.invertToRef(invertedMatrix);\n        var m = invertedMatrix.m;\n        var x = this.normal.x;\n        var y = this.normal.y;\n        var z = this.normal.z;\n        var d = this.d;\n        var normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\n        var normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\n        var normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\n        var finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\n        return new Plane(normalX, normalY, normalZ, finalD);\n    };\n    /**\n     * Compute the dot product between the point and the plane normal\n     * @param point point to calculate the dot product with\n     * @returns the dot product (float) of the point coordinates and the plane normal.\n     */\n    Plane.prototype.dotCoordinate = function (point) {\n        return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\n    };\n    /**\n     * Updates the current Plane from the plane defined by the three given points.\n     * @param point1 one of the points used to construct the plane\n     * @param point2 one of the points used to construct the plane\n     * @param point3 one of the points used to construct the plane\n     * @returns the updated Plane.\n     */\n    Plane.prototype.copyFromPoints = function (point1, point2, point3) {\n        var x1 = point2.x - point1.x;\n        var y1 = point2.y - point1.y;\n        var z1 = point2.z - point1.z;\n        var x2 = point3.x - point1.x;\n        var y2 = point3.y - point1.y;\n        var z2 = point3.z - point1.z;\n        var yz = y1 * z2 - z1 * y2;\n        var xz = z1 * x2 - x1 * z2;\n        var xy = x1 * y2 - y1 * x2;\n        var pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\n        var invPyth;\n        if (pyth !== 0) {\n            invPyth = 1.0 / pyth;\n        }\n        else {\n            invPyth = 0.0;\n        }\n        this.normal.x = yz * invPyth;\n        this.normal.y = xz * invPyth;\n        this.normal.z = xy * invPyth;\n        this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\n        return this;\n    };\n    /**\n     * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\n     * Note that for this function to work as expected you should make sure that:\n     *   - direction and the plane normal are normalized\n     *   - epsilon is a number just bigger than -1, something like -0.99 for eg\n     * @param direction the direction to check if the plane is facing\n     * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\n     * @returns True if the plane is facing the given direction\n     */\n    Plane.prototype.isFrontFacingTo = function (direction, epsilon) {\n        var dot = Vector3.Dot(this.normal, direction);\n        return dot <= epsilon;\n    };\n    /**\n     * Calculates the distance to a point\n     * @param point point to calculate distance to\n     * @returns the signed distance (float) from the given point to the Plane.\n     */\n    Plane.prototype.signedDistanceTo = function (point) {\n        return Vector3.Dot(point, this.normal) + this.d;\n    };\n    // Statics\n    /**\n     * Creates a plane from an  array\n     * @param array the array to create a plane from\n     * @returns a new Plane from the given array.\n     */\n    Plane.FromArray = function (array) {\n        return new Plane(array[0], array[1], array[2], array[3]);\n    };\n    /**\n     * Creates a plane from three points\n     * @param point1 point used to create the plane\n     * @param point2 point used to create the plane\n     * @param point3 point used to create the plane\n     * @returns a new Plane defined by the three given points.\n     */\n    Plane.FromPoints = function (point1, point2, point3) {\n        var result = new Plane(0.0, 0.0, 0.0, 0.0);\n        result.copyFromPoints(point1, point2, point3);\n        return result;\n    };\n    /**\n     * Creates a plane from an origin point and a normal\n     * @param origin origin of the plane to be constructed\n     * @param normal normal of the plane to be constructed\n     * @returns a new Plane the normal vector to this plane at the given origin point.\n     * Note : the vector \"normal\" is updated because normalized.\n     */\n    Plane.FromPositionAndNormal = function (origin, normal) {\n        var result = new Plane(0.0, 0.0, 0.0, 0.0);\n        normal.normalize();\n        result.normal = normal;\n        result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n        return result;\n    };\n    /**\n     * Calculates the distance from a plane and a point\n     * @param origin origin of the plane to be constructed\n     * @param normal normal of the plane to be constructed\n     * @param point point to calculate distance to\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\n     */\n    Plane.SignedDistanceToPlaneFromPositionAndNormal = function (origin, normal, point) {\n        var d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n        return Vector3.Dot(point, normal) + d;\n    };\n    Plane._TmpMatrix = Matrix.Identity();\n    return Plane;\n}());\nexport { Plane };\n//# sourceMappingURL=math.plane.js.map","/**\n * Scalar computation library\n */\nvar Scalar = /** @class */ (function () {\n    function Scalar() {\n    }\n    /**\n     * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n     * @param a number\n     * @param b number\n     * @param epsilon (default = 1.401298E-45)\n     * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n     */\n    Scalar.WithinEpsilon = function (a, b, epsilon) {\n        if (epsilon === void 0) { epsilon = 1.401298e-45; }\n        return Math.abs(a - b) <= epsilon;\n    };\n    /**\n     * Returns a string : the upper case translation of the number i to hexadecimal.\n     * @param i number\n     * @returns the upper case translation of the number i to hexadecimal.\n     */\n    Scalar.ToHex = function (i) {\n        var str = i.toString(16);\n        if (i <= 15) {\n            return (\"0\" + str).toUpperCase();\n        }\n        return str.toUpperCase();\n    };\n    /**\n     * Returns -1 if value is negative and +1 is value is positive.\n     * @param value the value\n     * @returns the value itself if it's equal to zero.\n     */\n    Scalar.Sign = function (value) {\n        value = +value; // convert to a number\n        if (value === 0 || isNaN(value)) {\n            return value;\n        }\n        return value > 0 ? 1 : -1;\n    };\n    /**\n     * Returns the value itself if it's between min and max.\n     * Returns min if the value is lower than min.\n     * Returns max if the value is greater than max.\n     * @param value the value to clmap\n     * @param min the min value to clamp to (default: 0)\n     * @param max the max value to clamp to (default: 1)\n     * @returns the clamped value\n     */\n    Scalar.Clamp = function (value, min, max) {\n        if (min === void 0) { min = 0; }\n        if (max === void 0) { max = 1; }\n        return Math.min(max, Math.max(min, value));\n    };\n    /**\n     * the log2 of value.\n     * @param value the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    Scalar.Log2 = function (value) {\n        return Math.log(value) * Math.LOG2E;\n    };\n    /**\n     * the floor part of a log2 value.\n     * @param value the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    Scalar.ILog2 = function (value) {\n        if (Math.log2) {\n            return Math.floor(Math.log2(value));\n        }\n        if (value < 0) {\n            return NaN;\n        }\n        else if (value === 0) {\n            return -Infinity;\n        }\n        var n = 0;\n        if (value < 1) {\n            while (value < 1) {\n                n++;\n                value = value * 2;\n            }\n            n = -n;\n        }\n        else if (value > 1) {\n            while (value > 1) {\n                n++;\n                value = Math.floor(value / 2);\n            }\n        }\n        return n;\n    };\n    /**\n     * Loops the value, so that it is never larger than length and never smaller than 0.\n     *\n     * This is similar to the modulo operator but it works with floating point numbers.\n     * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\n     * With t = 5 and length = 2.5, the result would be 0.0.\n     * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\n     * @param value the value\n     * @param length the length\n     * @returns the looped value\n     */\n    Scalar.Repeat = function (value, length) {\n        return value - Math.floor(value / length) * length;\n    };\n    /**\n     * Normalize the value between 0.0 and 1.0 using min and max values\n     * @param value value to normalize\n     * @param min max to normalize between\n     * @param max min to normalize between\n     * @returns the normalized value\n     */\n    Scalar.Normalize = function (value, min, max) {\n        return (value - min) / (max - min);\n    };\n    /**\n     * Denormalize the value from 0.0 and 1.0 using min and max values\n     * @param normalized value to denormalize\n     * @param min max to denormalize between\n     * @param max min to denormalize between\n     * @returns the denormalized value\n     */\n    Scalar.Denormalize = function (normalized, min, max) {\n        return normalized * (max - min) + min;\n    };\n    /**\n     * Calculates the shortest difference between two given angles given in degrees.\n     * @param current current angle in degrees\n     * @param target target angle in degrees\n     * @returns the delta\n     */\n    Scalar.DeltaAngle = function (current, target) {\n        var num = Scalar.Repeat(target - current, 360.0);\n        if (num > 180.0) {\n            num -= 360.0;\n        }\n        return num;\n    };\n    /**\n     * PingPongs the value t, so that it is never larger than length and never smaller than 0.\n     * @param tx value\n     * @param length length\n     * @returns The returned value will move back and forth between 0 and length\n     */\n    Scalar.PingPong = function (tx, length) {\n        var t = Scalar.Repeat(tx, length * 2.0);\n        return length - Math.abs(t - length);\n    };\n    /**\n     * Interpolates between min and max with smoothing at the limits.\n     *\n     * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\n     * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\n     * @param from from\n     * @param to to\n     * @param tx value\n     * @returns the smooth stepped value\n     */\n    Scalar.SmoothStep = function (from, to, tx) {\n        var t = Scalar.Clamp(tx);\n        t = -2.0 * t * t * t + 3.0 * t * t;\n        return to * t + from * (1.0 - t);\n    };\n    /**\n     * Moves a value current towards target.\n     *\n     * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\n     * Negative values of maxDelta pushes the value away from target.\n     * @param current current value\n     * @param target target value\n     * @param maxDelta max distance to move\n     * @returns resulting value\n     */\n    Scalar.MoveTowards = function (current, target, maxDelta) {\n        var result = 0;\n        if (Math.abs(target - current) <= maxDelta) {\n            result = target;\n        }\n        else {\n            result = current + Scalar.Sign(target - current) * maxDelta;\n        }\n        return result;\n    };\n    /**\n     * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\n     *\n     * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\n     *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\n     * @param current current value\n     * @param target target value\n     * @param maxDelta max distance to move\n     * @returns resulting angle\n     */\n    Scalar.MoveTowardsAngle = function (current, target, maxDelta) {\n        var num = Scalar.DeltaAngle(current, target);\n        var result = 0;\n        if (-maxDelta < num && num < maxDelta) {\n            result = target;\n        }\n        else {\n            target = current + num;\n            result = Scalar.MoveTowards(current, target, maxDelta);\n        }\n        return result;\n    };\n    /**\n     * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n     * @param start start value\n     * @param end target value\n     * @param amount amount to lerp between\n     * @returns the lerped value\n     */\n    Scalar.Lerp = function (start, end, amount) {\n        return start + (end - start) * amount;\n    };\n    /**\n     * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\n     * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\n     * @param start start value\n     * @param end target value\n     * @param amount amount to lerp between\n     * @returns the lerped value\n     */\n    Scalar.LerpAngle = function (start, end, amount) {\n        var num = Scalar.Repeat(end - start, 360.0);\n        if (num > 180.0) {\n            num -= 360.0;\n        }\n        return start + num * Scalar.Clamp(amount);\n    };\n    /**\n     * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\n     * @param a start value\n     * @param b target value\n     * @param value value between a and b\n     * @returns the inverseLerp value\n     */\n    Scalar.InverseLerp = function (a, b, value) {\n        var result = 0;\n        if (a != b) {\n            result = Scalar.Clamp((value - a) / (b - a));\n        }\n        else {\n            result = 0.0;\n        }\n        return result;\n    };\n    /**\n     * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n     * @see http://mathworld.wolfram.com/HermitePolynomial.html\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\n     * @returns hermite result\n     */\n    Scalar.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n        var squared = amount * amount;\n        var cubed = amount * squared;\n        var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        var part2 = -2.0 * cubed + 3.0 * squared;\n        var part3 = cubed - 2.0 * squared + amount;\n        var part4 = cubed - squared;\n        return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\n    };\n    /**\n     * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    Scalar.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n        var t2 = time * time;\n        return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\n    };\n    /**\n     * Returns a random float number between and min and max values\n     * @param min min value of random\n     * @param max max value of random\n     * @returns random value\n     */\n    Scalar.RandomRange = function (min, max) {\n        if (min === max) {\n            return min;\n        }\n        return Math.random() * (max - min) + min;\n    };\n    /**\n     * This function returns percentage of a number in a given range.\n     *\n     * RangeToPercent(40,20,60) will return 0.5 (50%)\n     * RangeToPercent(34,0,100) will return 0.34 (34%)\n     * @param number to convert to percentage\n     * @param min min range\n     * @param max max range\n     * @returns the percentage\n     */\n    Scalar.RangeToPercent = function (number, min, max) {\n        return (number - min) / (max - min);\n    };\n    /**\n     * This function returns number that corresponds to the percentage in a given range.\n     *\n     * PercentToRange(0.34,0,100) will return 34.\n     * @param percent to convert to number\n     * @param min min range\n     * @param max max range\n     * @returns the number\n     */\n    Scalar.PercentToRange = function (percent, min, max) {\n        return (max - min) * percent + min;\n    };\n    /**\n     * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n     * @param angle The angle to normalize in radian.\n     * @return The converted angle.\n     */\n    Scalar.NormalizeRadians = function (angle) {\n        // More precise but slower version kept for reference.\n        // angle = angle % Tools.TwoPi;\n        // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n        //if (angle > Math.PI) {\n        //\tangle -= Tools.TwoPi;\n        //}\n        angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\n        return angle;\n    };\n    /**\n     * Returns the highest common factor of two integers.\n     * @param a first parameter\n     * @param b second parameter\n     * @return HCF of a and b\n     */\n    Scalar.HCF = function (a, b) {\n        var r = a % b;\n        if (r === 0) {\n            return b;\n        }\n        return Scalar.HCF(b, r);\n    };\n    /**\n     * Two pi constants convenient for computation.\n     */\n    Scalar.TwoPi = Math.PI * 2;\n    return Scalar;\n}());\nexport { Scalar };\n//# sourceMappingURL=math.scalar.js.map","/**\n * Size containing width and height\n */\nvar Size = /** @class */ (function () {\n    /**\n     * Creates a Size object from the given width and height (floats).\n     * @param width width of the new size\n     * @param height height of the new size\n     */\n    function Size(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * Returns a string with the Size width and height\n     * @returns a string with the Size width and height\n     */\n    Size.prototype.toString = function () {\n        return \"{W: \".concat(this.width, \", H: \").concat(this.height, \"}\");\n    };\n    /**\n     * \"Size\"\n     * @returns the string \"Size\"\n     */\n    Size.prototype.getClassName = function () {\n        return \"Size\";\n    };\n    /**\n     * Returns the Size hash code.\n     * @returns a hash code for a unique width and height\n     */\n    Size.prototype.getHashCode = function () {\n        var hash = this.width | 0;\n        hash = (hash * 397) ^ (this.height | 0);\n        return hash;\n    };\n    /**\n     * Updates the current size from the given one.\n     * @param src the given size\n     */\n    Size.prototype.copyFrom = function (src) {\n        this.width = src.width;\n        this.height = src.height;\n    };\n    /**\n     * Updates in place the current Size from the given floats.\n     * @param width width of the new size\n     * @param height height of the new size\n     * @returns the updated Size.\n     */\n    Size.prototype.copyFromFloats = function (width, height) {\n        this.width = width;\n        this.height = height;\n        return this;\n    };\n    /**\n     * Updates in place the current Size from the given floats.\n     * @param width width to set\n     * @param height height to set\n     * @returns the updated Size.\n     */\n    Size.prototype.set = function (width, height) {\n        return this.copyFromFloats(width, height);\n    };\n    /**\n     * Multiplies the width and height by numbers\n     * @param w factor to multiple the width by\n     * @param h factor to multiple the height by\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\n     */\n    Size.prototype.multiplyByFloats = function (w, h) {\n        return new Size(this.width * w, this.height * h);\n    };\n    /**\n     * Clones the size\n     * @returns a new Size copied from the given one.\n     */\n    Size.prototype.clone = function () {\n        return new Size(this.width, this.height);\n    };\n    /**\n     * True if the current Size and the given one width and height are strictly equal.\n     * @param other the other size to compare against\n     * @returns True if the current Size and the given one width and height are strictly equal.\n     */\n    Size.prototype.equals = function (other) {\n        if (!other) {\n            return false;\n        }\n        return this.width === other.width && this.height === other.height;\n    };\n    Object.defineProperty(Size.prototype, \"surface\", {\n        /**\n         * The surface of the Size : width * height (float).\n         */\n        get: function () {\n            return this.width * this.height;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Create a new size of zero\n     * @returns a new Size set to (0.0, 0.0)\n     */\n    Size.Zero = function () {\n        return new Size(0.0, 0.0);\n    };\n    /**\n     * Sums the width and height of two sizes\n     * @param otherSize size to add to this size\n     * @returns a new Size set as the addition result of the current Size and the given one.\n     */\n    Size.prototype.add = function (otherSize) {\n        var r = new Size(this.width + otherSize.width, this.height + otherSize.height);\n        return r;\n    };\n    /**\n     * Subtracts the width and height of two\n     * @param otherSize size to subtract to this size\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\n     */\n    Size.prototype.subtract = function (otherSize) {\n        var r = new Size(this.width - otherSize.width, this.height - otherSize.height);\n        return r;\n    };\n    /**\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n     * @param start starting size to lerp between\n     * @param end end size to lerp between\n     * @param amount amount to lerp between the start and end values\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n     */\n    Size.Lerp = function (start, end, amount) {\n        var w = start.width + (end.width - start.width) * amount;\n        var h = start.height + (end.height - start.height) * amount;\n        return new Size(w, h);\n    };\n    return Size;\n}());\nexport { Size };\n//# sourceMappingURL=math.size.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Scalar } from \"./math.scalar.js\";\nimport { Epsilon } from \"./math.constants.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { PerformanceConfigurator } from \"../Engines/performanceConfigurator.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar _ExtractAsInt = function (value) {\n    return parseInt(value.toString().replace(/\\W/g, \"\"));\n};\n/**\n * Class representing a vector containing 2 coordinates\n */\nvar Vector2 = /** @class */ (function () {\n    /**\n     * Creates a new Vector2 from the given x and y coordinates\n     * @param x defines the first coordinate\n     * @param y defines the second coordinate\n     */\n    function Vector2(\n    /** defines the first coordinate */\n    x, \n    /** defines the second coordinate */\n    y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Gets a string with the Vector2 coordinates\n     * @returns a string with the Vector2 coordinates\n     */\n    Vector2.prototype.toString = function () {\n        return \"{X: \".concat(this.x, \" Y: \").concat(this.y, \"}\");\n    };\n    /**\n     * Gets class name\n     * @returns the string \"Vector2\"\n     */\n    Vector2.prototype.getClassName = function () {\n        return \"Vector2\";\n    };\n    /**\n     * Gets current vector hash code\n     * @returns the Vector2 hash code as a number\n     */\n    Vector2.prototype.getHashCode = function () {\n        var x = _ExtractAsInt(this.x);\n        var y = _ExtractAsInt(this.y);\n        var hash = x;\n        hash = (hash * 397) ^ y;\n        return hash;\n    };\n    // Operators\n    /**\n     * Sets the Vector2 coordinates in the given array or Float32Array from the given index.\n     * @param array defines the source array\n     * @param index defines the offset in source array\n     * @returns the current Vector2\n     */\n    Vector2.prototype.toArray = function (array, index) {\n        if (index === void 0) { index = 0; }\n        array[index] = this.x;\n        array[index + 1] = this.y;\n        return this;\n    };\n    /**\n     * Update the current vector from an array\n     * @param array defines the destination array\n     * @param index defines the offset in the destination array\n     * @returns the current Vector3\n     */\n    Vector2.prototype.fromArray = function (array, index) {\n        if (index === void 0) { index = 0; }\n        Vector2.FromArrayToRef(array, index, this);\n        return this;\n    };\n    /**\n     * Copy the current vector to an array\n     * @returns a new array with 2 elements: the Vector2 coordinates.\n     */\n    Vector2.prototype.asArray = function () {\n        var result = new Array();\n        this.toArray(result, 0);\n        return result;\n    };\n    /**\n     * Sets the Vector2 coordinates with the given Vector2 coordinates\n     * @param source defines the source Vector2\n     * @returns the current updated Vector2\n     */\n    Vector2.prototype.copyFrom = function (source) {\n        this.x = source.x;\n        this.y = source.y;\n        return this;\n    };\n    /**\n     * Sets the Vector2 coordinates with the given floats\n     * @param x defines the first coordinate\n     * @param y defines the second coordinate\n     * @returns the current updated Vector2\n     */\n    Vector2.prototype.copyFromFloats = function (x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    };\n    /**\n     * Sets the Vector2 coordinates with the given floats\n     * @param x defines the first coordinate\n     * @param y defines the second coordinate\n     * @returns the current updated Vector2\n     */\n    Vector2.prototype.set = function (x, y) {\n        return this.copyFromFloats(x, y);\n    };\n    /**\n     * Add another vector with the current one\n     * @param otherVector defines the other vector\n     * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates\n     */\n    Vector2.prototype.add = function (otherVector) {\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n    };\n    /**\n     * Sets the \"result\" coordinates with the addition of the current Vector2 and the given one coordinates\n     * @param otherVector defines the other vector\n     * @param result defines the target vector\n     * @returns the unmodified current Vector2\n     */\n    Vector2.prototype.addToRef = function (otherVector, result) {\n        result.x = this.x + otherVector.x;\n        result.y = this.y + otherVector.y;\n        return this;\n    };\n    /**\n     * Set the Vector2 coordinates by adding the given Vector2 coordinates\n     * @param otherVector defines the other vector\n     * @returns the current updated Vector2\n     */\n    Vector2.prototype.addInPlace = function (otherVector) {\n        this.x += otherVector.x;\n        this.y += otherVector.y;\n        return this;\n    };\n    /**\n     * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates\n     * @param otherVector defines the other vector\n     * @returns a new Vector2\n     */\n    Vector2.prototype.addVector3 = function (otherVector) {\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n    };\n    /**\n     * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2\n     * @param otherVector defines the other vector\n     * @returns a new Vector2\n     */\n    Vector2.prototype.subtract = function (otherVector) {\n        return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\n    };\n    /**\n     * Sets the \"result\" coordinates with the subtraction of the given one from the current Vector2 coordinates.\n     * @param otherVector defines the other vector\n     * @param result defines the target vector\n     * @returns the unmodified current Vector2\n     */\n    Vector2.prototype.subtractToRef = function (otherVector, result) {\n        result.x = this.x - otherVector.x;\n        result.y = this.y - otherVector.y;\n        return this;\n    };\n    /**\n     * Sets the current Vector2 coordinates by subtracting from it the given one coordinates\n     * @param otherVector defines the other vector\n     * @returns the current updated Vector2\n     */\n    Vector2.prototype.subtractInPlace = function (otherVector) {\n        this.x -= otherVector.x;\n        this.y -= otherVector.y;\n        return this;\n    };\n    /**\n     * Multiplies in place the current Vector2 coordinates by the given ones\n     * @param otherVector defines the other vector\n     * @returns the current updated Vector2\n     */\n    Vector2.prototype.multiplyInPlace = function (otherVector) {\n        this.x *= otherVector.x;\n        this.y *= otherVector.y;\n        return this;\n    };\n    /**\n     * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates\n     * @param otherVector defines the other vector\n     * @returns a new Vector2\n     */\n    Vector2.prototype.multiply = function (otherVector) {\n        return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\n    };\n    /**\n     * Sets \"result\" coordinates with the multiplication of the current Vector2 and the given one coordinates\n     * @param otherVector defines the other vector\n     * @param result defines the target vector\n     * @returns the unmodified current Vector2\n     */\n    Vector2.prototype.multiplyToRef = function (otherVector, result) {\n        result.x = this.x * otherVector.x;\n        result.y = this.y * otherVector.y;\n        return this;\n    };\n    /**\n     * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats\n     * @param x defines the first coordinate\n     * @param y defines the second coordinate\n     * @returns a new Vector2\n     */\n    Vector2.prototype.multiplyByFloats = function (x, y) {\n        return new Vector2(this.x * x, this.y * y);\n    };\n    /**\n     * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates\n     * @param otherVector defines the other vector\n     * @returns a new Vector2\n     */\n    Vector2.prototype.divide = function (otherVector) {\n        return new Vector2(this.x / otherVector.x, this.y / otherVector.y);\n    };\n    /**\n     * Sets the \"result\" coordinates with the Vector2 divided by the given one coordinates\n     * @param otherVector defines the other vector\n     * @param result defines the target vector\n     * @returns the unmodified current Vector2\n     */\n    Vector2.prototype.divideToRef = function (otherVector, result) {\n        result.x = this.x / otherVector.x;\n        result.y = this.y / otherVector.y;\n        return this;\n    };\n    /**\n     * Divides the current Vector2 coordinates by the given ones\n     * @param otherVector defines the other vector\n     * @returns the current updated Vector2\n     */\n    Vector2.prototype.divideInPlace = function (otherVector) {\n        return this.divideToRef(otherVector, this);\n    };\n    /**\n     * Gets a new Vector2 with current Vector2 negated coordinates\n     * @returns a new Vector2\n     */\n    Vector2.prototype.negate = function () {\n        return new Vector2(-this.x, -this.y);\n    };\n    /**\n     * Negate this vector in place\n     * @returns this\n     */\n    Vector2.prototype.negateInPlace = function () {\n        this.x *= -1;\n        this.y *= -1;\n        return this;\n    };\n    /**\n     * Negate the current Vector2 and stores the result in the given vector \"result\" coordinates\n     * @param result defines the Vector3 object where to store the result\n     * @returns the current Vector2\n     */\n    Vector2.prototype.negateToRef = function (result) {\n        return result.copyFromFloats(this.x * -1, this.y * -1);\n    };\n    /**\n     * Multiply the Vector2 coordinates by scale\n     * @param scale defines the scaling factor\n     * @returns the current updated Vector2\n     */\n    Vector2.prototype.scaleInPlace = function (scale) {\n        this.x *= scale;\n        this.y *= scale;\n        return this;\n    };\n    /**\n     * Returns a new Vector2 scaled by \"scale\" from the current Vector2\n     * @param scale defines the scaling factor\n     * @returns a new Vector2\n     */\n    Vector2.prototype.scale = function (scale) {\n        var result = new Vector2(0, 0);\n        this.scaleToRef(scale, result);\n        return result;\n    };\n    /**\n     * Scale the current Vector2 values by a factor to a given Vector2\n     * @param scale defines the scale factor\n     * @param result defines the Vector2 object where to store the result\n     * @returns the unmodified current Vector2\n     */\n    Vector2.prototype.scaleToRef = function (scale, result) {\n        result.x = this.x * scale;\n        result.y = this.y * scale;\n        return this;\n    };\n    /**\n     * Scale the current Vector2 values by a factor and add the result to a given Vector2\n     * @param scale defines the scale factor\n     * @param result defines the Vector2 object where to store the result\n     * @returns the unmodified current Vector2\n     */\n    Vector2.prototype.scaleAndAddToRef = function (scale, result) {\n        result.x += this.x * scale;\n        result.y += this.y * scale;\n        return this;\n    };\n    /**\n     * Gets a boolean if two vectors are equals\n     * @param otherVector defines the other vector\n     * @returns true if the given vector coordinates strictly equal the current Vector2 ones\n     */\n    Vector2.prototype.equals = function (otherVector) {\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y;\n    };\n    /**\n     * Gets a boolean if two vectors are equals (using an epsilon value)\n     * @param otherVector defines the other vector\n     * @param epsilon defines the minimal distance to consider equality\n     * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.\n     */\n    Vector2.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n        if (epsilon === void 0) { epsilon = Epsilon; }\n        return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);\n    };\n    /**\n     * Gets a new Vector2 from current Vector2 floored values\n     * eg (1.2, 2.31) returns (1, 2)\n     * @returns a new Vector2\n     */\n    Vector2.prototype.floor = function () {\n        return new Vector2(Math.floor(this.x), Math.floor(this.y));\n    };\n    /**\n     * Gets a new Vector2 from current Vector2 fractional values\n     * eg (1.2, 2.31) returns (0.2, 0.31)\n     * @returns a new Vector2\n     */\n    Vector2.prototype.fract = function () {\n        return new Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\n    };\n    /**\n     * Rotate the current vector into a given result vector\n     * @param angle defines the rotation angle\n     * @param result defines the result vector where to store the rotated vector\n     * @returns the current vector\n     */\n    Vector2.prototype.rotateToRef = function (angle, result) {\n        var cos = Math.cos(angle);\n        var sin = Math.sin(angle);\n        result.x = cos * this.x - sin * this.y;\n        result.y = sin * this.x + cos * this.y;\n        return this;\n    };\n    // Properties\n    /**\n     * Gets the length of the vector\n     * @returns the vector length (float)\n     */\n    Vector2.prototype.length = function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    };\n    /**\n     * Gets the vector squared length\n     * @returns the vector squared length (float)\n     */\n    Vector2.prototype.lengthSquared = function () {\n        return this.x * this.x + this.y * this.y;\n    };\n    // Methods\n    /**\n     * Normalize the vector\n     * @returns the current updated Vector2\n     */\n    Vector2.prototype.normalize = function () {\n        Vector2.NormalizeToRef(this, this);\n        return this;\n    };\n    /**\n     * Gets a new Vector2 copied from the Vector2\n     * @returns a new Vector2\n     */\n    Vector2.prototype.clone = function () {\n        return new Vector2(this.x, this.y);\n    };\n    // Statics\n    /**\n     * Gets a new Vector2(0, 0)\n     * @returns a new Vector2\n     */\n    Vector2.Zero = function () {\n        return new Vector2(0, 0);\n    };\n    /**\n     * Gets a new Vector2(1, 1)\n     * @returns a new Vector2\n     */\n    Vector2.One = function () {\n        return new Vector2(1, 1);\n    };\n    /**\n     * Gets a new Vector2 set from the given index element of the given array\n     * @param array defines the data source\n     * @param offset defines the offset in the data source\n     * @returns a new Vector2\n     */\n    Vector2.FromArray = function (array, offset) {\n        if (offset === void 0) { offset = 0; }\n        return new Vector2(array[offset], array[offset + 1]);\n    };\n    /**\n     * Sets \"result\" from the given index element of the given array\n     * @param array defines the data source\n     * @param offset defines the offset in the data source\n     * @param result defines the target vector\n     */\n    Vector2.FromArrayToRef = function (array, offset, result) {\n        result.x = array[offset];\n        result.y = array[offset + 1];\n    };\n    /**\n     * Gets a new Vector2 located for \"amount\" (float) on the CatmullRom spline defined by the given four Vector2\n     * @param value1 defines 1st point of control\n     * @param value2 defines 2nd point of control\n     * @param value3 defines 3rd point of control\n     * @param value4 defines 4th point of control\n     * @param amount defines the interpolation factor\n     * @returns a new Vector2\n     */\n    Vector2.CatmullRom = function (value1, value2, value3, value4, amount) {\n        var squared = amount * amount;\n        var cubed = amount * squared;\n        var x = 0.5 *\n            (2.0 * value2.x +\n                (-value1.x + value3.x) * amount +\n                (2.0 * value1.x - 5.0 * value2.x + 4.0 * value3.x - value4.x) * squared +\n                (-value1.x + 3.0 * value2.x - 3.0 * value3.x + value4.x) * cubed);\n        var y = 0.5 *\n            (2.0 * value2.y +\n                (-value1.y + value3.y) * amount +\n                (2.0 * value1.y - 5.0 * value2.y + 4.0 * value3.y - value4.y) * squared +\n                (-value1.y + 3.0 * value2.y - 3.0 * value3.y + value4.y) * cubed);\n        return new Vector2(x, y);\n    };\n    /**\n     * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\n     * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\n     * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate\n     * @param value defines the value to clamp\n     * @param min defines the lower limit\n     * @param max defines the upper limit\n     * @returns a new Vector2\n     */\n    Vector2.Clamp = function (value, min, max) {\n        var x = value.x;\n        x = x > max.x ? max.x : x;\n        x = x < min.x ? min.x : x;\n        var y = value.y;\n        y = y > max.y ? max.y : y;\n        y = y < min.y ? min.y : y;\n        return new Vector2(x, y);\n    };\n    /**\n     * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\"\n     * @param value1 defines the 1st control point\n     * @param tangent1 defines the outgoing tangent\n     * @param value2 defines the 2nd control point\n     * @param tangent2 defines the incoming tangent\n     * @param amount defines the interpolation factor\n     * @returns a new Vector2\n     */\n    Vector2.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n        var squared = amount * amount;\n        var cubed = amount * squared;\n        var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        var part2 = -2.0 * cubed + 3.0 * squared;\n        var part3 = cubed - 2.0 * squared + amount;\n        var part4 = cubed - squared;\n        var x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;\n        var y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;\n        return new Vector2(x, y);\n    };\n    /**\n     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    Vector2.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n        var result = Vector2.Zero();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    };\n    /**\n     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where the derivative will be stored\n     */\n    Vector2.Hermite1stDerivativeToRef = function (value1, tangent1, value2, tangent2, time, result) {\n        var t2 = time * time;\n        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\n        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\n    };\n    /**\n     * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\n     * @param start defines the start vector\n     * @param end defines the end vector\n     * @param amount defines the interpolation factor\n     * @returns a new Vector2\n     */\n    Vector2.Lerp = function (start, end, amount) {\n        var x = start.x + (end.x - start.x) * amount;\n        var y = start.y + (end.y - start.y) * amount;\n        return new Vector2(x, y);\n    };\n    /**\n     * Gets the dot product of the vector \"left\" and the vector \"right\"\n     * @param left defines first vector\n     * @param right defines second vector\n     * @returns the dot product (float)\n     */\n    Vector2.Dot = function (left, right) {\n        return left.x * right.x + left.y * right.y;\n    };\n    /**\n     * Returns a new Vector2 equal to the normalized given vector\n     * @param vector defines the vector to normalize\n     * @returns a new Vector2\n     */\n    Vector2.Normalize = function (vector) {\n        var newVector = Vector2.Zero();\n        this.NormalizeToRef(vector, newVector);\n        return newVector;\n    };\n    /**\n     * Normalize a given vector into a second one\n     * @param vector defines the vector to normalize\n     * @param result defines the vector where to store the result\n     */\n    Vector2.NormalizeToRef = function (vector, result) {\n        var len = vector.length();\n        if (len === 0) {\n            return;\n        }\n        result.x = vector.x / len;\n        result.y = vector.y / len;\n    };\n    /**\n     * Gets a new Vector2 set with the minimal coordinate values from the \"left\" and \"right\" vectors\n     * @param left defines 1st vector\n     * @param right defines 2nd vector\n     * @returns a new Vector2\n     */\n    Vector2.Minimize = function (left, right) {\n        var x = left.x < right.x ? left.x : right.x;\n        var y = left.y < right.y ? left.y : right.y;\n        return new Vector2(x, y);\n    };\n    /**\n     * Gets a new Vector2 set with the maximal coordinate values from the \"left\" and \"right\" vectors\n     * @param left defines 1st vector\n     * @param right defines 2nd vector\n     * @returns a new Vector2\n     */\n    Vector2.Maximize = function (left, right) {\n        var x = left.x > right.x ? left.x : right.x;\n        var y = left.y > right.y ? left.y : right.y;\n        return new Vector2(x, y);\n    };\n    /**\n     * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix\n     * @param vector defines the vector to transform\n     * @param transformation defines the matrix to apply\n     * @returns a new Vector2\n     */\n    Vector2.Transform = function (vector, transformation) {\n        var r = Vector2.Zero();\n        Vector2.TransformToRef(vector, transformation, r);\n        return r;\n    };\n    /**\n     * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector \"result\" coordinates\n     * @param vector defines the vector to transform\n     * @param transformation defines the matrix to apply\n     * @param result defines the target vector\n     */\n    Vector2.TransformToRef = function (vector, transformation, result) {\n        var m = transformation.m;\n        var x = vector.x * m[0] + vector.y * m[4] + m[12];\n        var y = vector.x * m[1] + vector.y * m[5] + m[13];\n        result.x = x;\n        result.y = y;\n    };\n    /**\n     * Determines if a given vector is included in a triangle\n     * @param p defines the vector to test\n     * @param p0 defines 1st triangle point\n     * @param p1 defines 2nd triangle point\n     * @param p2 defines 3rd triangle point\n     * @returns true if the point \"p\" is in the triangle defined by the vectors \"p0\", \"p1\", \"p2\"\n     */\n    Vector2.PointInTriangle = function (p, p0, p1, p2) {\n        var a = (1 / 2) * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);\n        var sign = a < 0 ? -1 : 1;\n        var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;\n        var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;\n        return s > 0 && t > 0 && s + t < 2 * a * sign;\n    };\n    /**\n     * Gets the distance between the vectors \"value1\" and \"value2\"\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @returns the distance between vectors\n     */\n    Vector2.Distance = function (value1, value2) {\n        return Math.sqrt(Vector2.DistanceSquared(value1, value2));\n    };\n    /**\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @returns the squared distance between vectors\n     */\n    Vector2.DistanceSquared = function (value1, value2) {\n        var x = value1.x - value2.x;\n        var y = value1.y - value2.y;\n        return x * x + y * y;\n    };\n    /**\n     * Gets a new Vector2 located at the center of the vectors \"value1\" and \"value2\"\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @returns a new Vector2\n     */\n    Vector2.Center = function (value1, value2) {\n        return Vector2.CenterToRef(value1, value2, Vector2.Zero());\n    };\n    /**\n     * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @param ref defines third vector\n     * @returns ref\n     */\n    Vector2.CenterToRef = function (value1, value2, ref) {\n        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);\n    };\n    /**\n     * Gets the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\n     * @param p defines the middle point\n     * @param segA defines one point of the segment\n     * @param segB defines the other point of the segment\n     * @returns the shortest distance\n     */\n    Vector2.DistanceOfPointFromSegment = function (p, segA, segB) {\n        var l2 = Vector2.DistanceSquared(segA, segB);\n        if (l2 === 0.0) {\n            return Vector2.Distance(p, segA);\n        }\n        var v = segB.subtract(segA);\n        var t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\n        var proj = segA.add(v.multiplyByFloats(t, t));\n        return Vector2.Distance(p, proj);\n    };\n    return Vector2;\n}());\nexport { Vector2 };\n/**\n * Class used to store (x,y,z) vector representation\n * A Vector3 is the main object used in 3D geometry\n * It can represent either the coordinates of a point the space, either a direction\n * Reminder: js uses a left handed forward facing system\n */\nvar Vector3 = /** @class */ (function () {\n    /**\n     * Creates a new Vector3 object from the given x, y, z (floats) coordinates.\n     * @param x defines the first coordinates (on X axis)\n     * @param y defines the second coordinates (on Y axis)\n     * @param z defines the third coordinates (on Z axis)\n     */\n    function Vector3(x, y, z) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (z === void 0) { z = 0; }\n        /** @hidden */\n        this._isDirty = true;\n        this._x = x;\n        this._y = y;\n        this._z = z;\n    }\n    Object.defineProperty(Vector3.prototype, \"x\", {\n        /** Gets or sets the x coordinate */\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            this._x = value;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Vector3.prototype, \"y\", {\n        /** Gets or sets the y coordinate */\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            this._y = value;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Vector3.prototype, \"z\", {\n        /** Gets or sets the z coordinate */\n        get: function () {\n            return this._z;\n        },\n        set: function (value) {\n            this._z = value;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Creates a string representation of the Vector3\n     * @returns a string with the Vector3 coordinates.\n     */\n    Vector3.prototype.toString = function () {\n        return \"{X: \".concat(this._x, \" Y: \").concat(this._y, \" Z: \").concat(this._z, \"}\");\n    };\n    /**\n     * Gets the class name\n     * @returns the string \"Vector3\"\n     */\n    Vector3.prototype.getClassName = function () {\n        return \"Vector3\";\n    };\n    /**\n     * Creates the Vector3 hash code\n     * @returns a number which tends to be unique between Vector3 instances\n     */\n    Vector3.prototype.getHashCode = function () {\n        var x = _ExtractAsInt(this._x);\n        var y = _ExtractAsInt(this._y);\n        var z = _ExtractAsInt(this._z);\n        var hash = x;\n        hash = (hash * 397) ^ y;\n        hash = (hash * 397) ^ z;\n        return hash;\n    };\n    // Operators\n    /**\n     * Creates an array containing three elements : the coordinates of the Vector3\n     * @returns a new array of numbers\n     */\n    Vector3.prototype.asArray = function () {\n        var result = [];\n        this.toArray(result, 0);\n        return result;\n    };\n    /**\n     * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3\n     * @param array defines the destination array\n     * @param index defines the offset in the destination array\n     * @returns the current Vector3\n     */\n    Vector3.prototype.toArray = function (array, index) {\n        if (index === void 0) { index = 0; }\n        array[index] = this._x;\n        array[index + 1] = this._y;\n        array[index + 2] = this._z;\n        return this;\n    };\n    /**\n     * Update the current vector from an array\n     * @param array defines the destination array\n     * @param index defines the offset in the destination array\n     * @returns the current Vector3\n     */\n    Vector3.prototype.fromArray = function (array, index) {\n        if (index === void 0) { index = 0; }\n        Vector3.FromArrayToRef(array, index, this);\n        return this;\n    };\n    /**\n     * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)\n     * @returns a new Quaternion object, computed from the Vector3 coordinates\n     */\n    Vector3.prototype.toQuaternion = function () {\n        return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);\n    };\n    /**\n     * Adds the given vector to the current Vector3\n     * @param otherVector defines the second operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.addInPlace = function (otherVector) {\n        return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);\n    };\n    /**\n     * Adds the given coordinates to the current Vector3\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.addInPlaceFromFloats = function (x, y, z) {\n        this.x += x;\n        this.y += y;\n        this.z += z;\n        return this;\n    };\n    /**\n     * Gets a new Vector3, result of the addition the current Vector3 and the given vector\n     * @param otherVector defines the second operand\n     * @returns the resulting Vector3\n     */\n    Vector3.prototype.add = function (otherVector) {\n        return new Vector3(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\n    };\n    /**\n     * Adds the current Vector3 to the given one and stores the result in the vector \"result\"\n     * @param otherVector defines the second operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    Vector3.prototype.addToRef = function (otherVector, result) {\n        return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);\n    };\n    /**\n     * Subtract the given vector from the current Vector3\n     * @param otherVector defines the second operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.subtractInPlace = function (otherVector) {\n        this.x -= otherVector._x;\n        this.y -= otherVector._y;\n        this.z -= otherVector._z;\n        return this;\n    };\n    /**\n     * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3\n     * @param otherVector defines the second operand\n     * @returns the resulting Vector3\n     */\n    Vector3.prototype.subtract = function (otherVector) {\n        return new Vector3(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);\n    };\n    /**\n     * Subtracts the given vector from the current Vector3 and stores the result in the vector \"result\".\n     * @param otherVector defines the second operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    Vector3.prototype.subtractToRef = function (otherVector, result) {\n        return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);\n    };\n    /**\n     * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the resulting Vector3\n     */\n    Vector3.prototype.subtractFromFloats = function (x, y, z) {\n        return new Vector3(this._x - x, this._y - y, this._z - z);\n    };\n    /**\n     * Subtracts the given floats from the current Vector3 coordinates and set the given vector \"result\" with this result\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    Vector3.prototype.subtractFromFloatsToRef = function (x, y, z, result) {\n        return result.copyFromFloats(this._x - x, this._y - y, this._z - z);\n    };\n    /**\n     * Gets a new Vector3 set with the current Vector3 negated coordinates\n     * @returns a new Vector3\n     */\n    Vector3.prototype.negate = function () {\n        return new Vector3(-this._x, -this._y, -this._z);\n    };\n    /**\n     * Negate this vector in place\n     * @returns this\n     */\n    Vector3.prototype.negateInPlace = function () {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    };\n    /**\n     * Negate the current Vector3 and stores the result in the given vector \"result\" coordinates\n     * @param result defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    Vector3.prototype.negateToRef = function (result) {\n        return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);\n    };\n    /**\n     * Multiplies the Vector3 coordinates by the float \"scale\"\n     * @param scale defines the multiplier factor\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.scaleInPlace = function (scale) {\n        this.x *= scale;\n        this.y *= scale;\n        this.z *= scale;\n        return this;\n    };\n    /**\n     * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\"\n     * @param scale defines the multiplier factor\n     * @returns a new Vector3\n     */\n    Vector3.prototype.scale = function (scale) {\n        return new Vector3(this._x * scale, this._y * scale, this._z * scale);\n    };\n    /**\n     * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the given vector \"result\" coordinates\n     * @param scale defines the multiplier factor\n     * @param result defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    Vector3.prototype.scaleToRef = function (scale, result) {\n        return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);\n    };\n    /**\n     * Rotates the vector using the given unit quaternion and stores the new vector in result\n     * @param q the unit quaternion representing the rotation\n     * @param result the output vector\n     * @returns the current Vector3\n     */\n    Vector3.prototype.applyRotationQuaternionToRef = function (q, result) {\n        var ix = q.w * this.x + q.y * this.z - q.z * this.y;\n        var iy = q.w * this.y + q.z * this.x - q.x * this.z;\n        var iz = q.w * this.z + q.x * this.y - q.y * this.x;\n        var iw = -q.x * this.x - q.y * this.y - q.z * this.z;\n        result.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n        result.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n        result.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n        return result;\n    };\n    /**\n     * Rotates the vector in place using the given unit quaternion\n     * @param q the unit quaternion representing the rotation\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.applyRotationQuaternionInPlace = function (q) {\n        return this.applyRotationQuaternionToRef(q, this);\n    };\n    /**\n     * Rotates the vector using the given unit quaternion and returns the new vector\n     * @param q the unit quaternion representing the rotation\n     * @returns a new Vector3\n     */\n    Vector3.prototype.applyRotationQuaternion = function (q) {\n        return this.applyRotationQuaternionToRef(q, Vector3.Zero());\n    };\n    /**\n     * Scale the current Vector3 values by a factor and add the result to a given Vector3\n     * @param scale defines the scale factor\n     * @param result defines the Vector3 object where to store the result\n     * @returns the unmodified current Vector3\n     */\n    Vector3.prototype.scaleAndAddToRef = function (scale, result) {\n        return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);\n    };\n    /**\n     * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\n     * @param plane defines the plane to project to\n     * @param origin defines the origin of the projection ray\n     * @returns the projected vector3\n     */\n    Vector3.prototype.projectOnPlane = function (plane, origin) {\n        var result = Vector3.Zero();\n        this.projectOnPlaneToRef(plane, origin, result);\n        return result;\n    };\n    /**\n     * Projects the current vector3 to a plane along a ray starting from a specified origin and directed towards the point.\n     * @param plane defines the plane to project to\n     * @param origin defines the origin of the projection ray\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.prototype.projectOnPlaneToRef = function (plane, origin, result) {\n        var n = plane.normal;\n        var d = plane.d;\n        var V = MathTmp.Vector3[0];\n        // ray direction\n        this.subtractToRef(origin, V);\n        V.normalize();\n        var denom = Vector3.Dot(V, n);\n        var t = -(Vector3.Dot(origin, n) + d) / denom;\n        // P = P0 + t*V\n        var scaledV = V.scaleInPlace(t);\n        origin.addToRef(scaledV, result);\n    };\n    /**\n     * Returns true if the current Vector3 and the given vector coordinates are strictly equal\n     * @param otherVector defines the second operand\n     * @returns true if both vectors are equals\n     */\n    Vector3.prototype.equals = function (otherVector) {\n        return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;\n    };\n    /**\n     * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon\n     * @param otherVector defines the second operand\n     * @param epsilon defines the minimal distance to define values as equals\n     * @returns true if both vectors are distant less than epsilon\n     */\n    Vector3.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n        if (epsilon === void 0) { epsilon = Epsilon; }\n        return (otherVector &&\n            Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) &&\n            Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) &&\n            Scalar.WithinEpsilon(this._z, otherVector._z, epsilon));\n    };\n    /**\n     * Returns true if the current Vector3 coordinates equals the given floats\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns true if both vectors are equals\n     */\n    Vector3.prototype.equalsToFloats = function (x, y, z) {\n        return this._x === x && this._y === y && this._z === z;\n    };\n    /**\n     * Multiplies the current Vector3 coordinates by the given ones\n     * @param otherVector defines the second operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.multiplyInPlace = function (otherVector) {\n        this.x *= otherVector._x;\n        this.y *= otherVector._y;\n        this.z *= otherVector._z;\n        return this;\n    };\n    /**\n     * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector\n     * @param otherVector defines the second operand\n     * @returns the new Vector3\n     */\n    Vector3.prototype.multiply = function (otherVector) {\n        return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);\n    };\n    /**\n     * Multiplies the current Vector3 by the given one and stores the result in the given vector \"result\"\n     * @param otherVector defines the second operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    Vector3.prototype.multiplyToRef = function (otherVector, result) {\n        return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);\n    };\n    /**\n     * Returns a new Vector3 set with the result of the multiplication of the current Vector3 coordinates by the given floats\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the new Vector3\n     */\n    Vector3.prototype.multiplyByFloats = function (x, y, z) {\n        return new Vector3(this._x * x, this._y * y, this._z * z);\n    };\n    /**\n     * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones\n     * @param otherVector defines the second operand\n     * @returns the new Vector3\n     */\n    Vector3.prototype.divide = function (otherVector) {\n        return new Vector3(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\n    };\n    /**\n     * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector \"result\"\n     * @param otherVector defines the second operand\n     * @param result defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    Vector3.prototype.divideToRef = function (otherVector, result) {\n        return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);\n    };\n    /**\n     * Divides the current Vector3 coordinates by the given ones.\n     * @param otherVector defines the second operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.divideInPlace = function (otherVector) {\n        return this.divideToRef(otherVector, this);\n    };\n    /**\n     * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones\n     * @param other defines the second operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.minimizeInPlace = function (other) {\n        return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);\n    };\n    /**\n     * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.\n     * @param other defines the second operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.maximizeInPlace = function (other) {\n        return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);\n    };\n    /**\n     * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.minimizeInPlaceFromFloats = function (x, y, z) {\n        if (x < this._x) {\n            this.x = x;\n        }\n        if (y < this._y) {\n            this.y = y;\n        }\n        if (z < this._z) {\n            this.z = z;\n        }\n        return this;\n    };\n    /**\n     * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.maximizeInPlaceFromFloats = function (x, y, z) {\n        if (x > this._x) {\n            this.x = x;\n        }\n        if (y > this._y) {\n            this.y = y;\n        }\n        if (z > this._z) {\n            this.z = z;\n        }\n        return this;\n    };\n    /**\n     * Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction\n     * Check if is non uniform within a certain amount of decimal places to account for this\n     * @param epsilon the amount the values can differ\n     * @returns if the the vector is non uniform to a certain number of decimal places\n     */\n    Vector3.prototype.isNonUniformWithinEpsilon = function (epsilon) {\n        var absX = Math.abs(this._x);\n        var absY = Math.abs(this._y);\n        if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {\n            return true;\n        }\n        var absZ = Math.abs(this._z);\n        if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {\n            return true;\n        }\n        if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {\n            return true;\n        }\n        return false;\n    };\n    Object.defineProperty(Vector3.prototype, \"isNonUniform\", {\n        /**\n         * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same\n         */\n        get: function () {\n            var absX = Math.abs(this._x);\n            var absY = Math.abs(this._y);\n            if (absX !== absY) {\n                return true;\n            }\n            var absZ = Math.abs(this._z);\n            if (absX !== absZ) {\n                return true;\n            }\n            return false;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Gets a new Vector3 from current Vector3 floored values\n     * @returns a new Vector3\n     */\n    Vector3.prototype.floor = function () {\n        return new Vector3(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));\n    };\n    /**\n     * Gets a new Vector3 from current Vector3 floored values\n     * @returns a new Vector3\n     */\n    Vector3.prototype.fract = function () {\n        return new Vector3(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));\n    };\n    // Properties\n    /**\n     * Gets the length of the Vector3\n     * @returns the length of the Vector3\n     */\n    Vector3.prototype.length = function () {\n        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);\n    };\n    /**\n     * Gets the squared length of the Vector3\n     * @returns squared length of the Vector3\n     */\n    Vector3.prototype.lengthSquared = function () {\n        return this._x * this._x + this._y * this._y + this._z * this._z;\n    };\n    Object.defineProperty(Vector3.prototype, \"hasAZeroComponent\", {\n        /**\n         * Gets a boolean indicating if the vector contains a zero in one of its components\n         */\n        get: function () {\n            return this._x * this._y * this._z === 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Normalize the current Vector3.\n     * Please note that this is an in place operation.\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.normalize = function () {\n        return this.normalizeFromLength(this.length());\n    };\n    /**\n     * Reorders the x y z properties of the vector in place\n     * @param order new ordering of the properties (eg. for vector 1,2,3 with \"ZYX\" will produce 3,2,1)\n     * @returns the current updated vector\n     */\n    Vector3.prototype.reorderInPlace = function (order) {\n        var _this = this;\n        order = order.toLowerCase();\n        if (order === \"xyz\") {\n            return this;\n        }\n        MathTmp.Vector3[0].copyFrom(this);\n        [\"x\", \"y\", \"z\"].forEach(function (val, i) {\n            _this[val] = MathTmp.Vector3[0][order[i]];\n        });\n        return this;\n    };\n    /**\n     * Rotates the vector around 0,0,0 by a quaternion\n     * @param quaternion the rotation quaternion\n     * @param result vector to store the result\n     * @returns the resulting vector\n     */\n    Vector3.prototype.rotateByQuaternionToRef = function (quaternion, result) {\n        quaternion.toRotationMatrix(MathTmp.Matrix[0]);\n        Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);\n        return result;\n    };\n    /**\n     * Rotates a vector around a given point\n     * @param quaternion the rotation quaternion\n     * @param point the point to rotate around\n     * @param result vector to store the result\n     * @returns the resulting vector\n     */\n    Vector3.prototype.rotateByQuaternionAroundPointToRef = function (quaternion, point, result) {\n        this.subtractToRef(point, MathTmp.Vector3[0]);\n        MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);\n        point.addToRef(MathTmp.Vector3[0], result);\n        return result;\n    };\n    /**\n     * Returns a new Vector3 as the cross product of the current vector and the \"other\" one\n     * The cross product is then orthogonal to both current and \"other\"\n     * @param other defines the right operand\n     * @returns the cross product\n     */\n    Vector3.prototype.cross = function (other) {\n        return Vector3.Cross(this, other);\n    };\n    /**\n     * Normalize the current Vector3 with the given input length.\n     * Please note that this is an in place operation.\n     * @param len the length of the vector\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.normalizeFromLength = function (len) {\n        if (len === 0 || len === 1.0) {\n            return this;\n        }\n        return this.scaleInPlace(1.0 / len);\n    };\n    /**\n     * Normalize the current Vector3 to a new vector\n     * @returns the new Vector3\n     */\n    Vector3.prototype.normalizeToNew = function () {\n        var normalized = new Vector3(0, 0, 0);\n        this.normalizeToRef(normalized);\n        return normalized;\n    };\n    /**\n     * Normalize the current Vector3 to the reference\n     * @param reference define the Vector3 to update\n     * @returns the updated Vector3\n     */\n    Vector3.prototype.normalizeToRef = function (reference) {\n        var len = this.length();\n        if (len === 0 || len === 1.0) {\n            return reference.copyFromFloats(this._x, this._y, this._z);\n        }\n        return this.scaleToRef(1.0 / len, reference);\n    };\n    /**\n     * Creates a new Vector3 copied from the current Vector3\n     * @returns the new Vector3\n     */\n    Vector3.prototype.clone = function () {\n        return new Vector3(this._x, this._y, this._z);\n    };\n    /**\n     * Copies the given vector coordinates to the current Vector3 ones\n     * @param source defines the source Vector3\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.copyFrom = function (source) {\n        return this.copyFromFloats(source._x, source._y, source._z);\n    };\n    /**\n     * Copies the given floats to the current Vector3 coordinates\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.copyFromFloats = function (x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    };\n    /**\n     * Copies the given floats to the current Vector3 coordinates\n     * @param x defines the x coordinate of the operand\n     * @param y defines the y coordinate of the operand\n     * @param z defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.set = function (x, y, z) {\n        return this.copyFromFloats(x, y, z);\n    };\n    /**\n     * Copies the given float to the current Vector3 coordinates\n     * @param v defines the x, y and z coordinates of the operand\n     * @returns the current updated Vector3\n     */\n    Vector3.prototype.setAll = function (v) {\n        this.x = this.y = this.z = v;\n        return this;\n    };\n    // Statics\n    /**\n     * Get the clip factor between two vectors\n     * @param vector0 defines the first operand\n     * @param vector1 defines the second operand\n     * @param axis defines the axis to use\n     * @param size defines the size along the axis\n     * @returns the clip factor\n     */\n    Vector3.GetClipFactor = function (vector0, vector1, axis, size) {\n        var d0 = Vector3.Dot(vector0, axis) - size;\n        var d1 = Vector3.Dot(vector1, axis) - size;\n        var s = d0 / (d0 - d1);\n        return s;\n    };\n    /**\n     * Get angle between two vectors\n     * @param vector0 angle between vector0 and vector1\n     * @param vector1 angle between vector0 and vector1\n     * @param normal direction of the normal\n     * @return the angle between vector0 and vector1\n     */\n    Vector3.GetAngleBetweenVectors = function (vector0, vector1, normal) {\n        var v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);\n        var v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);\n        var dot = Vector3.Dot(v0, v1);\n        // Vectors are normalized so dot will be in [-1, 1] (aside precision issues enough to break the result which explains the below clamp)\n        dot = Scalar.Clamp(dot, -1, 1);\n        var angle = Math.acos(dot);\n        var n = MathTmp.Vector3[3];\n        Vector3.CrossToRef(v0, v1, n);\n        if (Vector3.Dot(n, normal) > 0) {\n            return isNaN(angle) ? 0 : angle;\n        }\n        return isNaN(angle) ? -Math.PI : -Math.acos(dot);\n    };\n    /**\n     * Get angle between two vectors projected on a plane\n     * @param vector0 angle between vector0 and vector1\n     * @param vector1 angle between vector0 and vector1\n     * @param normal Normal of the projection plane\n     * @returns the angle between vector0 and vector1 projected on the plane with the specified normal\n     */\n    Vector3.GetAngleBetweenVectorsOnPlane = function (vector0, vector1, normal) {\n        MathTmp.Vector3[0].copyFrom(vector0);\n        var v0 = MathTmp.Vector3[0];\n        MathTmp.Vector3[1].copyFrom(vector1);\n        var v1 = MathTmp.Vector3[1];\n        MathTmp.Vector3[2].copyFrom(normal);\n        var vNormal = MathTmp.Vector3[2];\n        var right = MathTmp.Vector3[3];\n        var forward = MathTmp.Vector3[4];\n        v0.normalize();\n        v1.normalize();\n        vNormal.normalize();\n        Vector3.CrossToRef(vNormal, v0, right);\n        Vector3.CrossToRef(right, vNormal, forward);\n        var angle = Math.atan2(Vector3.Dot(v1, right), Vector3.Dot(v1, forward));\n        return Scalar.NormalizeRadians(angle);\n    };\n    /**\n     * Slerp between two vectors. See also `SmoothToRef`\n     * @param vector0 Start vector\n     * @param vector1 End vector\n     * @param slerp amount (will be clamped between 0 and 1)\n     * @param result The slerped vector\n     */\n    Vector3.SlerpToRef = function (vector0, vector1, slerp, result) {\n        slerp = Scalar.Clamp(slerp, 0, 1);\n        var vector0Dir = MathTmp.Vector3[0];\n        var vector1Dir = MathTmp.Vector3[1];\n        vector0Dir.copyFrom(vector0);\n        var vector0Length = vector0Dir.length();\n        vector0Dir.normalizeFromLength(vector0Length);\n        vector1Dir.copyFrom(vector1);\n        var vector1Length = vector1Dir.length();\n        vector1Dir.normalizeFromLength(vector1Length);\n        var dot = Vector3.Dot(vector0Dir, vector1Dir);\n        var scale0;\n        var scale1;\n        if (dot < 1 - Epsilon) {\n            var omega = Math.acos(dot);\n            var invSin = 1 / Math.sin(omega);\n            scale0 = Math.sin((1 - slerp) * omega) * invSin;\n            scale1 = Math.sin(slerp * omega) * invSin;\n        }\n        else {\n            // Use linear interpolation\n            scale0 = 1 - slerp;\n            scale1 = slerp;\n        }\n        vector0Dir.scaleInPlace(scale0);\n        vector1Dir.scaleInPlace(scale1);\n        result.copyFrom(vector0Dir).addInPlace(vector1Dir);\n        result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));\n    };\n    /**\n     * Smooth interpolation between two vectors using Slerp\n     * @param source source vector\n     * @param goal goal vector\n     * @param deltaTime current interpolation frame\n     * @param lerpTime total interpolation time\n     * @param result the smoothed vector\n     */\n    Vector3.SmoothToRef = function (source, goal, deltaTime, lerpTime, result) {\n        Vector3.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);\n    };\n    /**\n     * Returns a new Vector3 set from the index \"offset\" of the given array\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @returns the new Vector3\n     */\n    Vector3.FromArray = function (array, offset) {\n        if (offset === void 0) { offset = 0; }\n        return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\n    };\n    /**\n     * Returns a new Vector3 set from the index \"offset\" of the given Float32Array\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @returns the new Vector3\n     * @deprecated Please use FromArray instead.\n     */\n    Vector3.FromFloatArray = function (array, offset) {\n        return Vector3.FromArray(array, offset);\n    };\n    /**\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given array\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.FromArrayToRef = function (array, offset, result) {\n        result.x = array[offset];\n        result.y = array[offset + 1];\n        result.z = array[offset + 2];\n    };\n    /**\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given Float32Array\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @param result defines the Vector3 where to store the result\n     * @deprecated Please use FromArrayToRef instead.\n     */\n    Vector3.FromFloatArrayToRef = function (array, offset, result) {\n        return Vector3.FromArrayToRef(array, offset, result);\n    };\n    /**\n     * Sets the given vector \"result\" with the given floats.\n     * @param x defines the x coordinate of the source\n     * @param y defines the y coordinate of the source\n     * @param z defines the z coordinate of the source\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.FromFloatsToRef = function (x, y, z, result) {\n        result.copyFromFloats(x, y, z);\n    };\n    /**\n     * Returns a new Vector3 set to (0.0, 0.0, 0.0)\n     * @returns a new empty Vector3\n     */\n    Vector3.Zero = function () {\n        return new Vector3(0.0, 0.0, 0.0);\n    };\n    /**\n     * Returns a new Vector3 set to (1.0, 1.0, 1.0)\n     * @returns a new unit Vector3\n     */\n    Vector3.One = function () {\n        return new Vector3(1.0, 1.0, 1.0);\n    };\n    /**\n     * Returns a new Vector3 set to (0.0, 1.0, 0.0)\n     * @returns a new up Vector3\n     */\n    Vector3.Up = function () {\n        return new Vector3(0.0, 1.0, 0.0);\n    };\n    Object.defineProperty(Vector3, \"UpReadOnly\", {\n        /**\n         * Gets a up Vector3 that must not be updated\n         */\n        get: function () {\n            return Vector3._UpReadOnly;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Vector3, \"RightReadOnly\", {\n        /**\n         * Gets a right Vector3 that must not be updated\n         */\n        get: function () {\n            return Vector3._RightReadOnly;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Vector3, \"LeftReadOnly\", {\n        /**\n         * Gets a left Vector3 that must not be updated\n         */\n        get: function () {\n            return Vector3._LeftReadOnly;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Vector3, \"LeftHandedForwardReadOnly\", {\n        /**\n         * Gets a forward Vector3 that must not be updated\n         */\n        get: function () {\n            return Vector3._LeftHandedForwardReadOnly;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Vector3, \"RightHandedForwardReadOnly\", {\n        /**\n         * Gets a forward Vector3 that must not be updated\n         */\n        get: function () {\n            return Vector3._RightHandedForwardReadOnly;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Vector3, \"ZeroReadOnly\", {\n        /**\n         * Gets a zero Vector3 that must not be updated\n         */\n        get: function () {\n            return Vector3._ZeroReadOnly;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns a new Vector3 set to (0.0, -1.0, 0.0)\n     * @returns a new down Vector3\n     */\n    Vector3.Down = function () {\n        return new Vector3(0.0, -1.0, 0.0);\n    };\n    /**\n     * Returns a new Vector3 set to (0.0, 0.0, 1.0)\n     * @param rightHandedSystem is the scene right-handed (negative z)\n     * @returns a new forward Vector3\n     */\n    Vector3.Forward = function (rightHandedSystem) {\n        if (rightHandedSystem === void 0) { rightHandedSystem = false; }\n        return new Vector3(0.0, 0.0, rightHandedSystem ? -1.0 : 1.0);\n    };\n    /**\n     * Returns a new Vector3 set to (0.0, 0.0, -1.0)\n     * @param rightHandedSystem is the scene right-handed (negative-z)\n     * @returns a new forward Vector3\n     */\n    Vector3.Backward = function (rightHandedSystem) {\n        if (rightHandedSystem === void 0) { rightHandedSystem = false; }\n        return new Vector3(0.0, 0.0, rightHandedSystem ? 1.0 : -1.0);\n    };\n    /**\n     * Returns a new Vector3 set to (1.0, 0.0, 0.0)\n     * @returns a new right Vector3\n     */\n    Vector3.Right = function () {\n        return new Vector3(1.0, 0.0, 0.0);\n    };\n    /**\n     * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\n     * @returns a new left Vector3\n     */\n    Vector3.Left = function () {\n        return new Vector3(-1.0, 0.0, 0.0);\n    };\n    /**\n     * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.\n     * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @returns the transformed Vector3\n     */\n    Vector3.TransformCoordinates = function (vector, transformation) {\n        var result = Vector3.Zero();\n        Vector3.TransformCoordinatesToRef(vector, transformation, result);\n        return result;\n    };\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\n     * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.TransformCoordinatesToRef = function (vector, transformation, result) {\n        Vector3.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n    };\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\n     * This method computes transformed coordinates only, not transformed direction vectors\n     * @param x define the x coordinate of the source vector\n     * @param y define the y coordinate of the source vector\n     * @param z define the z coordinate of the source vector\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.TransformCoordinatesFromFloatsToRef = function (x, y, z, transformation, result) {\n        var m = transformation.m;\n        var rx = x * m[0] + y * m[4] + z * m[8] + m[12];\n        var ry = x * m[1] + y * m[5] + z * m[9] + m[13];\n        var rz = x * m[2] + y * m[6] + z * m[10] + m[14];\n        var rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\n        result.x = rx * rw;\n        result.y = ry * rw;\n        result.z = rz * rw;\n    };\n    /**\n     * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @returns the new Vector3\n     */\n    Vector3.TransformNormal = function (vector, transformation) {\n        var result = Vector3.Zero();\n        Vector3.TransformNormalToRef(vector, transformation, result);\n        return result;\n    };\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.TransformNormalToRef = function (vector, transformation, result) {\n        this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n    };\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z)\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n     * @param x define the x coordinate of the source vector\n     * @param y define the y coordinate of the source vector\n     * @param z define the z coordinate of the source vector\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.TransformNormalFromFloatsToRef = function (x, y, z, transformation, result) {\n        var m = transformation.m;\n        result.x = x * m[0] + y * m[4] + z * m[8];\n        result.y = x * m[1] + y * m[5] + z * m[9];\n        result.z = x * m[2] + y * m[6] + z * m[10];\n    };\n    /**\n     * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\"\n     * @param value1 defines the first control point\n     * @param value2 defines the second control point\n     * @param value3 defines the third control point\n     * @param value4 defines the fourth control point\n     * @param amount defines the amount on the spline to use\n     * @returns the new Vector3\n     */\n    Vector3.CatmullRom = function (value1, value2, value3, value4, amount) {\n        var squared = amount * amount;\n        var cubed = amount * squared;\n        var x = 0.5 *\n            (2.0 * value2._x +\n                (-value1._x + value3._x) * amount +\n                (2.0 * value1._x - 5.0 * value2._x + 4.0 * value3._x - value4._x) * squared +\n                (-value1._x + 3.0 * value2._x - 3.0 * value3._x + value4._x) * cubed);\n        var y = 0.5 *\n            (2.0 * value2._y +\n                (-value1._y + value3._y) * amount +\n                (2.0 * value1._y - 5.0 * value2._y + 4.0 * value3._y - value4._y) * squared +\n                (-value1._y + 3.0 * value2._y - 3.0 * value3._y + value4._y) * cubed);\n        var z = 0.5 *\n            (2.0 * value2._z +\n                (-value1._z + value3._z) * amount +\n                (2.0 * value1._z - 5.0 * value2._z + 4.0 * value3._z - value4._z) * squared +\n                (-value1._z + 3.0 * value2._z - 3.0 * value3._z + value4._z) * cubed);\n        return new Vector3(x, y, z);\n    };\n    /**\n     * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n     * @param value defines the current value\n     * @param min defines the lower range value\n     * @param max defines the upper range value\n     * @returns the new Vector3\n     */\n    Vector3.Clamp = function (value, min, max) {\n        var v = new Vector3();\n        Vector3.ClampToRef(value, min, max, v);\n        return v;\n    };\n    /**\n     * Sets the given vector \"result\" with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n     * @param value defines the current value\n     * @param min defines the lower range value\n     * @param max defines the upper range value\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.ClampToRef = function (value, min, max, result) {\n        var x = value._x;\n        x = x > max._x ? max._x : x;\n        x = x < min._x ? min._x : x;\n        var y = value._y;\n        y = y > max._y ? max._y : y;\n        y = y < min._y ? min._y : y;\n        var z = value._z;\n        z = z > max._z ? max._z : z;\n        z = z < min._z ? min._z : z;\n        result.copyFromFloats(x, y, z);\n    };\n    /**\n     * Checks if a given vector is inside a specific range\n     * @param v defines the vector to test\n     * @param min defines the minimum range\n     * @param max defines the maximum range\n     */\n    Vector3.CheckExtends = function (v, min, max) {\n        min.minimizeInPlace(v);\n        max.maximizeInPlace(v);\n    };\n    /**\n     * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent vector\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent vector\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\n     * @returns the new Vector3\n     */\n    Vector3.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n        var squared = amount * amount;\n        var cubed = amount * squared;\n        var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        var part2 = -2.0 * cubed + 3.0 * squared;\n        var part3 = cubed - 2.0 * squared + amount;\n        var part4 = cubed - squared;\n        var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\n        var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\n        var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\n        return new Vector3(x, y, z);\n    };\n    /**\n     * Returns a new Vector3 which is the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    Vector3.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n        var result = Vector3.Zero();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    };\n    /**\n     * Update a Vector3 with the 1st derivative of the Hermite spline defined by the vectors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where to store the derivative\n     */\n    Vector3.Hermite1stDerivativeToRef = function (value1, tangent1, value2, tangent2, time, result) {\n        var t2 = time * time;\n        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\n        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\n        result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;\n    };\n    /**\n     * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\"\n     * @param start defines the start value\n     * @param end defines the end value\n     * @param amount max defines amount between both (between 0 and 1)\n     * @returns the new Vector3\n     */\n    Vector3.Lerp = function (start, end, amount) {\n        var result = new Vector3(0, 0, 0);\n        Vector3.LerpToRef(start, end, amount, result);\n        return result;\n    };\n    /**\n     * Sets the given vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\"\n     * @param start defines the start value\n     * @param end defines the end value\n     * @param amount max defines amount between both (between 0 and 1)\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.LerpToRef = function (start, end, amount, result) {\n        result.x = start._x + (end._x - start._x) * amount;\n        result.y = start._y + (end._y - start._y) * amount;\n        result.z = start._z + (end._z - start._z) * amount;\n    };\n    /**\n     * Returns the dot product (float) between the vectors \"left\" and \"right\"\n     * @param left defines the left operand\n     * @param right defines the right operand\n     * @returns the dot product\n     */\n    Vector3.Dot = function (left, right) {\n        return left._x * right._x + left._y * right._y + left._z * right._z;\n    };\n    /**\n     * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\"\n     * The cross product is then orthogonal to both \"left\" and \"right\"\n     * @param left defines the left operand\n     * @param right defines the right operand\n     * @returns the cross product\n     */\n    Vector3.Cross = function (left, right) {\n        var result = Vector3.Zero();\n        Vector3.CrossToRef(left, right, result);\n        return result;\n    };\n    /**\n     * Sets the given vector \"result\" with the cross product of \"left\" and \"right\"\n     * The cross product is then orthogonal to both \"left\" and \"right\"\n     * @param left defines the left operand\n     * @param right defines the right operand\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.CrossToRef = function (left, right, result) {\n        var x = left._y * right._z - left._z * right._y;\n        var y = left._z * right._x - left._x * right._z;\n        var z = left._x * right._y - left._y * right._x;\n        result.copyFromFloats(x, y, z);\n    };\n    /**\n     * Returns a new Vector3 as the normalization of the given vector\n     * @param vector defines the Vector3 to normalize\n     * @returns the new Vector3\n     */\n    Vector3.Normalize = function (vector) {\n        var result = Vector3.Zero();\n        Vector3.NormalizeToRef(vector, result);\n        return result;\n    };\n    /**\n     * Sets the given vector \"result\" with the normalization of the given first vector\n     * @param vector defines the Vector3 to normalize\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.NormalizeToRef = function (vector, result) {\n        vector.normalizeToRef(result);\n    };\n    /**\n     * Project a Vector3 onto screen space\n     * @param vector defines the Vector3 to project\n     * @param world defines the world matrix to use\n     * @param transform defines the transform (view x projection) matrix to use\n     * @param viewport defines the screen viewport to use\n     * @returns the new Vector3\n     */\n    Vector3.Project = function (vector, world, transform, viewport) {\n        var result = new Vector3();\n        Vector3.ProjectToRef(vector, world, transform, viewport, result);\n        return result;\n    };\n    /**\n     * Project a Vector3 onto screen space to reference\n     * @param vector defines the Vector3 to project\n     * @param world defines the world matrix to use\n     * @param transform defines the transform (view x projection) matrix to use\n     * @param viewport defines the screen viewport to use\n     * @param result the vector in which the screen space will be stored\n     * @returns the new Vector3\n     */\n    Vector3.ProjectToRef = function (vector, world, transform, viewport, result) {\n        var cw = viewport.width;\n        var ch = viewport.height;\n        var cx = viewport.x;\n        var cy = viewport.y;\n        var viewportMatrix = MathTmp.Matrix[1];\n        Matrix.FromValuesToRef(cw / 2.0, 0, 0, 0, 0, -ch / 2.0, 0, 0, 0, 0, 0.5, 0, cx + cw / 2.0, ch / 2.0 + cy, 0.5, 1, viewportMatrix);\n        var matrix = MathTmp.Matrix[0];\n        world.multiplyToRef(transform, matrix);\n        matrix.multiplyToRef(viewportMatrix, matrix);\n        Vector3.TransformCoordinatesToRef(vector, matrix, result);\n        return result;\n    };\n    /**\n     * @param source\n     * @param matrix\n     * @param result\n     * @hidden\n     */\n    Vector3._UnprojectFromInvertedMatrixToRef = function (source, matrix, result) {\n        Vector3.TransformCoordinatesToRef(source, matrix, result);\n        var m = matrix.m;\n        var num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];\n        if (Scalar.WithinEpsilon(num, 1.0)) {\n            result.scaleInPlace(1.0 / num);\n        }\n    };\n    /**\n     * Unproject from screen space to object space\n     * @param source defines the screen space Vector3 to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param transform defines the transform (view x projection) matrix to use\n     * @returns the new Vector3\n     */\n    Vector3.UnprojectFromTransform = function (source, viewportWidth, viewportHeight, world, transform) {\n        return this.Unproject(source, viewportWidth, viewportHeight, world, transform, Matrix.IdentityReadOnly);\n    };\n    /**\n     * Unproject from screen space to object space\n     * @param source defines the screen space Vector3 to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param view defines the view matrix to use\n     * @param projection defines the projection matrix to use\n     * @returns the new Vector3\n     */\n    Vector3.Unproject = function (source, viewportWidth, viewportHeight, world, view, projection) {\n        var result = Vector3.Zero();\n        Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);\n        return result;\n    };\n    /**\n     * Unproject from screen space to object space\n     * @param source defines the screen space Vector3 to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param view defines the view matrix to use\n     * @param projection defines the projection matrix to use\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.UnprojectToRef = function (source, viewportWidth, viewportHeight, world, view, projection, result) {\n        Vector3.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);\n    };\n    /**\n     * Unproject from screen space to object space\n     * @param sourceX defines the screen space x coordinate to use\n     * @param sourceY defines the screen space y coordinate to use\n     * @param sourceZ defines the screen space z coordinate to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param view defines the view matrix to use\n     * @param projection defines the projection matrix to use\n     * @param result defines the Vector3 where to store the result\n     */\n    Vector3.UnprojectFloatsToRef = function (sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {\n        var _a;\n        var matrix = MathTmp.Matrix[0];\n        world.multiplyToRef(view, matrix);\n        matrix.multiplyToRef(projection, matrix);\n        matrix.invert();\n        var screenSource = MathTmp.Vector3[0];\n        screenSource.x = (sourceX / viewportWidth) * 2 - 1;\n        screenSource.y = -((sourceY / viewportHeight) * 2 - 1);\n        if ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) {\n            screenSource.z = sourceZ;\n        }\n        else {\n            screenSource.z = 2 * sourceZ - 1.0;\n        }\n        Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);\n    };\n    /**\n     * Gets the minimal coordinate values between two Vector3\n     * @param left defines the first operand\n     * @param right defines the second operand\n     * @returns the new Vector3\n     */\n    Vector3.Minimize = function (left, right) {\n        var min = left.clone();\n        min.minimizeInPlace(right);\n        return min;\n    };\n    /**\n     * Gets the maximal coordinate values between two Vector3\n     * @param left defines the first operand\n     * @param right defines the second operand\n     * @returns the new Vector3\n     */\n    Vector3.Maximize = function (left, right) {\n        var max = left.clone();\n        max.maximizeInPlace(right);\n        return max;\n    };\n    /**\n     * Returns the distance between the vectors \"value1\" and \"value2\"\n     * @param value1 defines the first operand\n     * @param value2 defines the second operand\n     * @returns the distance\n     */\n    Vector3.Distance = function (value1, value2) {\n        return Math.sqrt(Vector3.DistanceSquared(value1, value2));\n    };\n    /**\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\n     * @param value1 defines the first operand\n     * @param value2 defines the second operand\n     * @returns the squared distance\n     */\n    Vector3.DistanceSquared = function (value1, value2) {\n        var x = value1._x - value2._x;\n        var y = value1._y - value2._y;\n        var z = value1._z - value2._z;\n        return x * x + y * y + z * z;\n    };\n    /**\n     * Projects \"vector\" on the triangle determined by its extremities \"p0\", \"p1\" and \"p2\", stores the result in \"ref\"\n     * and returns the distance to the projected point.\n     * From http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4264&rep=rep1&type=pdf\n     *\n     * @param vector the vector to get distance from\n     * @param p0 extremity of the triangle\n     * @param p1 extremity of the triangle\n     * @param p2 extremity of the triangle\n     * @param ref variable to store the result to\n     * @returns The distance between \"ref\" and \"vector\"\n     */\n    Vector3.ProjectOnTriangleToRef = function (vector, p0, p1, p2, ref) {\n        var p1p0 = MathTmp.Vector3[0];\n        var p2p0 = MathTmp.Vector3[1];\n        var p2p1 = MathTmp.Vector3[2];\n        var normal = MathTmp.Vector3[3];\n        var vectorp0 = MathTmp.Vector3[4];\n        // Triangle vectors\n        p1.subtractToRef(p0, p1p0);\n        p2.subtractToRef(p0, p2p0);\n        p2.subtractToRef(p1, p2p1);\n        var p1p0L = p1p0.length();\n        var p2p0L = p2p0.length();\n        var p2p1L = p2p1.length();\n        if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {\n            // This is a degenerate triangle. As we assume this is part of a non-degenerate mesh,\n            // we will find a better intersection later.\n            // Let's just return one of the extremities\n            ref.copyFrom(p0);\n            return Vector3.Distance(vector, p0);\n        }\n        // Compute normal and vector to p0\n        vector.subtractToRef(p0, vectorp0);\n        Vector3.CrossToRef(p1p0, p2p0, normal);\n        var nl = normal.length();\n        if (nl < Epsilon) {\n            // Extremities are aligned, we are back on the case of a degenerate triangle\n            ref.copyFrom(p0);\n            return Vector3.Distance(vector, p0);\n        }\n        normal.normalizeFromLength(nl);\n        var l = vectorp0.length();\n        if (l < Epsilon) {\n            // Vector is p0\n            ref.copyFrom(p0);\n            return 0;\n        }\n        vectorp0.normalizeFromLength(l);\n        // Project to \"proj\" that lies on the triangle plane\n        var cosA = Vector3.Dot(normal, vectorp0);\n        var projVector = MathTmp.Vector3[5];\n        var proj = MathTmp.Vector3[6];\n        projVector.copyFrom(normal).scaleInPlace(-l * cosA);\n        proj.copyFrom(vector).addInPlace(projVector);\n        // Compute barycentric coordinates (v0, v1 and v2 are axis from barycenter to extremities)\n        var v0 = MathTmp.Vector3[4];\n        var v1 = MathTmp.Vector3[5];\n        var v2 = MathTmp.Vector3[7];\n        var tmp = MathTmp.Vector3[8];\n        v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);\n        tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);\n        v0.addInPlace(tmp).scaleInPlace(-1);\n        v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);\n        tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);\n        v1.addInPlace(tmp).scaleInPlace(-1);\n        v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);\n        tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);\n        v2.addInPlace(tmp).scaleInPlace(-1);\n        // Determines which edge of the triangle is closest to \"proj\"\n        var projP = MathTmp.Vector3[9];\n        var dot;\n        projP.copyFrom(proj).subtractInPlace(p0);\n        Vector3.CrossToRef(v0, projP, tmp);\n        dot = Vector3.Dot(tmp, normal);\n        var s0 = dot;\n        projP.copyFrom(proj).subtractInPlace(p1);\n        Vector3.CrossToRef(v1, projP, tmp);\n        dot = Vector3.Dot(tmp, normal);\n        var s1 = dot;\n        projP.copyFrom(proj).subtractInPlace(p2);\n        Vector3.CrossToRef(v2, projP, tmp);\n        dot = Vector3.Dot(tmp, normal);\n        var s2 = dot;\n        var edge = MathTmp.Vector3[10];\n        var e0, e1;\n        if (s0 > 0 && s1 < 0) {\n            edge.copyFrom(p1p0);\n            e0 = p0;\n            e1 = p1;\n        }\n        else if (s1 > 0 && s2 < 0) {\n            edge.copyFrom(p2p1);\n            e0 = p1;\n            e1 = p2;\n        }\n        else {\n            edge.copyFrom(p2p0).scaleInPlace(-1);\n            e0 = p2;\n            e1 = p0;\n        }\n        // Determines if \"proj\" lies inside the triangle\n        var tmp2 = MathTmp.Vector3[9];\n        var tmp3 = MathTmp.Vector3[4];\n        e0.subtractToRef(proj, tmp);\n        e1.subtractToRef(proj, tmp2);\n        Vector3.CrossToRef(tmp, tmp2, tmp3);\n        var isOutside = Vector3.Dot(tmp3, normal) < 0;\n        // If inside, we already found the projected point, \"proj\"\n        if (!isOutside) {\n            ref.copyFrom(proj);\n            return Math.abs(l * cosA);\n        }\n        // If outside, we find \"triProj\", the closest point from \"proj\" on the closest edge\n        var r = MathTmp.Vector3[5];\n        Vector3.CrossToRef(edge, tmp3, r);\n        r.normalize();\n        var e0proj = MathTmp.Vector3[9];\n        e0proj.copyFrom(e0).subtractInPlace(proj);\n        var e0projL = e0proj.length();\n        if (e0projL < Epsilon) {\n            // Proj is e0\n            ref.copyFrom(e0);\n            return Vector3.Distance(vector, e0);\n        }\n        e0proj.normalizeFromLength(e0projL);\n        var cosG = Vector3.Dot(r, e0proj);\n        var triProj = MathTmp.Vector3[7];\n        triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG));\n        // Now we clamp \"triProj\" so it lies between e0 and e1\n        tmp.copyFrom(triProj).subtractInPlace(e0);\n        l = edge.length();\n        edge.normalizeFromLength(l);\n        var t = Vector3.Dot(tmp, edge) / Math.max(l, Epsilon);\n        t = Scalar.Clamp(t, 0, 1);\n        triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));\n        ref.copyFrom(triProj);\n        return Vector3.Distance(vector, triProj);\n    };\n    /**\n     * Returns a new Vector3 located at the center between \"value1\" and \"value2\"\n     * @param value1 defines the first operand\n     * @param value2 defines the second operand\n     * @returns the new Vector3\n     */\n    Vector3.Center = function (value1, value2) {\n        return Vector3.CenterToRef(value1, value2, Vector3.Zero());\n    };\n    /**\n     * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @param ref defines third vector\n     * @returns ref\n     */\n    Vector3.CenterToRef = function (value1, value2, ref) {\n        return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);\n    };\n    /**\n     * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\n     * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\n     * to something in order to rotate it from its local system to the given target system\n     * Note: axis1, axis2 and axis3 are normalized during this operation\n     * @param axis1 defines the first axis\n     * @param axis2 defines the second axis\n     * @param axis3 defines the third axis\n     * @returns a new Vector3\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/target_align\n     */\n    Vector3.RotationFromAxis = function (axis1, axis2, axis3) {\n        var rotation = Vector3.Zero();\n        Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\n        return rotation;\n    };\n    /**\n     * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3\n     * @param axis1 defines the first axis\n     * @param axis2 defines the second axis\n     * @param axis3 defines the third axis\n     * @param ref defines the Vector3 where to store the result\n     */\n    Vector3.RotationFromAxisToRef = function (axis1, axis2, axis3, ref) {\n        var quat = MathTmp.Quaternion[0];\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n        quat.toEulerAnglesToRef(ref);\n    };\n    Vector3._UpReadOnly = Vector3.Up();\n    Vector3._LeftHandedForwardReadOnly = Vector3.Forward(false);\n    Vector3._RightHandedForwardReadOnly = Vector3.Forward(true);\n    Vector3._RightReadOnly = Vector3.Right();\n    Vector3._LeftReadOnly = Vector3.Left();\n    Vector3._ZeroReadOnly = Vector3.Zero();\n    return Vector3;\n}());\nexport { Vector3 };\n/**\n * Vector4 class created for EulerAngle class conversion to Quaternion\n */\nvar Vector4 = /** @class */ (function () {\n    /**\n     * Creates a Vector4 object from the given floats.\n     * @param x x value of the vector\n     * @param y y value of the vector\n     * @param z z value of the vector\n     * @param w w value of the vector\n     */\n    function Vector4(\n    /** x value of the vector */\n    x, \n    /** y value of the vector */\n    y, \n    /** z value of the vector */\n    z, \n    /** w value of the vector */\n    w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    /**\n     * Returns the string with the Vector4 coordinates.\n     * @returns a string containing all the vector values\n     */\n    Vector4.prototype.toString = function () {\n        return \"{X: \".concat(this.x, \" Y: \").concat(this.y, \" Z: \").concat(this.z, \" W: \").concat(this.w, \"}\");\n    };\n    /**\n     * Returns the string \"Vector4\".\n     * @returns \"Vector4\"\n     */\n    Vector4.prototype.getClassName = function () {\n        return \"Vector4\";\n    };\n    /**\n     * Returns the Vector4 hash code.\n     * @returns a unique hash code\n     */\n    Vector4.prototype.getHashCode = function () {\n        var x = _ExtractAsInt(this.x);\n        var y = _ExtractAsInt(this.y);\n        var z = _ExtractAsInt(this.z);\n        var w = _ExtractAsInt(this.w);\n        var hash = x;\n        hash = (hash * 397) ^ y;\n        hash = (hash * 397) ^ z;\n        hash = (hash * 397) ^ w;\n        return hash;\n    };\n    // Operators\n    /**\n     * Returns a new array populated with 4 elements : the Vector4 coordinates.\n     * @returns the resulting array\n     */\n    Vector4.prototype.asArray = function () {\n        var result = new Array();\n        this.toArray(result, 0);\n        return result;\n    };\n    /**\n     * Populates the given array from the given index with the Vector4 coordinates.\n     * @param array array to populate\n     * @param index index of the array to start at (default: 0)\n     * @returns the Vector4.\n     */\n    Vector4.prototype.toArray = function (array, index) {\n        if (index === undefined) {\n            index = 0;\n        }\n        array[index] = this.x;\n        array[index + 1] = this.y;\n        array[index + 2] = this.z;\n        array[index + 3] = this.w;\n        return this;\n    };\n    /**\n     * Update the current vector from an array\n     * @param array defines the destination array\n     * @param index defines the offset in the destination array\n     * @returns the current Vector3\n     */\n    Vector4.prototype.fromArray = function (array, index) {\n        if (index === void 0) { index = 0; }\n        Vector4.FromArrayToRef(array, index, this);\n        return this;\n    };\n    /**\n     * Adds the given vector to the current Vector4.\n     * @param otherVector the vector to add\n     * @returns the updated Vector4.\n     */\n    Vector4.prototype.addInPlace = function (otherVector) {\n        this.x += otherVector.x;\n        this.y += otherVector.y;\n        this.z += otherVector.z;\n        this.w += otherVector.w;\n        return this;\n    };\n    /**\n     * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.\n     * @param otherVector the vector to add\n     * @returns the resulting vector\n     */\n    Vector4.prototype.add = function (otherVector) {\n        return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\n    };\n    /**\n     * Updates the given vector \"result\" with the result of the addition of the current Vector4 and the given one.\n     * @param otherVector the vector to add\n     * @param result the vector to store the result\n     * @returns the current Vector4.\n     */\n    Vector4.prototype.addToRef = function (otherVector, result) {\n        result.x = this.x + otherVector.x;\n        result.y = this.y + otherVector.y;\n        result.z = this.z + otherVector.z;\n        result.w = this.w + otherVector.w;\n        return this;\n    };\n    /**\n     * Subtract in place the given vector from the current Vector4.\n     * @param otherVector the vector to subtract\n     * @returns the updated Vector4.\n     */\n    Vector4.prototype.subtractInPlace = function (otherVector) {\n        this.x -= otherVector.x;\n        this.y -= otherVector.y;\n        this.z -= otherVector.z;\n        this.w -= otherVector.w;\n        return this;\n    };\n    /**\n     * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.\n     * @param otherVector the vector to add\n     * @returns the new vector with the result\n     */\n    Vector4.prototype.subtract = function (otherVector) {\n        return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\n    };\n    /**\n     * Sets the given vector \"result\" with the result of the subtraction of the given vector from the current Vector4.\n     * @param otherVector the vector to subtract\n     * @param result the vector to store the result\n     * @returns the current Vector4.\n     */\n    Vector4.prototype.subtractToRef = function (otherVector, result) {\n        result.x = this.x - otherVector.x;\n        result.y = this.y - otherVector.y;\n        result.z = this.z - otherVector.z;\n        result.w = this.w - otherVector.w;\n        return this;\n    };\n    /**\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n     */\n    /**\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n     * @param x value to subtract\n     * @param y value to subtract\n     * @param z value to subtract\n     * @param w value to subtract\n     * @returns new vector containing the result\n     */\n    Vector4.prototype.subtractFromFloats = function (x, y, z, w) {\n        return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\n    };\n    /**\n     * Sets the given vector \"result\" set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n     * @param x value to subtract\n     * @param y value to subtract\n     * @param z value to subtract\n     * @param w value to subtract\n     * @param result the vector to store the result in\n     * @returns the current Vector4.\n     */\n    Vector4.prototype.subtractFromFloatsToRef = function (x, y, z, w, result) {\n        result.x = this.x - x;\n        result.y = this.y - y;\n        result.z = this.z - z;\n        result.w = this.w - w;\n        return this;\n    };\n    /**\n     * Returns a new Vector4 set with the current Vector4 negated coordinates.\n     * @returns a new vector with the negated values\n     */\n    Vector4.prototype.negate = function () {\n        return new Vector4(-this.x, -this.y, -this.z, -this.w);\n    };\n    /**\n     * Negate this vector in place\n     * @returns this\n     */\n    Vector4.prototype.negateInPlace = function () {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        this.w *= -1;\n        return this;\n    };\n    /**\n     * Negate the current Vector4 and stores the result in the given vector \"result\" coordinates\n     * @param result defines the Vector3 object where to store the result\n     * @returns the current Vector4\n     */\n    Vector4.prototype.negateToRef = function (result) {\n        return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);\n    };\n    /**\n     * Multiplies the current Vector4 coordinates by scale (float).\n     * @param scale the number to scale with\n     * @returns the updated Vector4.\n     */\n    Vector4.prototype.scaleInPlace = function (scale) {\n        this.x *= scale;\n        this.y *= scale;\n        this.z *= scale;\n        this.w *= scale;\n        return this;\n    };\n    /**\n     * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\n     * @param scale the number to scale with\n     * @returns a new vector with the result\n     */\n    Vector4.prototype.scale = function (scale) {\n        return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\n    };\n    /**\n     * Sets the given vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\n     * @param scale the number to scale with\n     * @param result a vector to store the result in\n     * @returns the current Vector4.\n     */\n    Vector4.prototype.scaleToRef = function (scale, result) {\n        result.x = this.x * scale;\n        result.y = this.y * scale;\n        result.z = this.z * scale;\n        result.w = this.w * scale;\n        return this;\n    };\n    /**\n     * Scale the current Vector4 values by a factor and add the result to a given Vector4\n     * @param scale defines the scale factor\n     * @param result defines the Vector4 object where to store the result\n     * @returns the unmodified current Vector4\n     */\n    Vector4.prototype.scaleAndAddToRef = function (scale, result) {\n        result.x += this.x * scale;\n        result.y += this.y * scale;\n        result.z += this.z * scale;\n        result.w += this.w * scale;\n        return this;\n    };\n    /**\n     * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.\n     * @param otherVector the vector to compare against\n     * @returns true if they are equal\n     */\n    Vector4.prototype.equals = function (otherVector) {\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;\n    };\n    /**\n     * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the given vector ones.\n     * @param otherVector vector to compare against\n     * @param epsilon (Default: very small number)\n     * @returns true if they are equal\n     */\n    Vector4.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n        if (epsilon === void 0) { epsilon = Epsilon; }\n        return (otherVector &&\n            Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) &&\n            Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) &&\n            Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) &&\n            Scalar.WithinEpsilon(this.w, otherVector.w, epsilon));\n    };\n    /**\n     * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.\n     * @param x x value to compare against\n     * @param y y value to compare against\n     * @param z z value to compare against\n     * @param w w value to compare against\n     * @returns true if equal\n     */\n    Vector4.prototype.equalsToFloats = function (x, y, z, w) {\n        return this.x === x && this.y === y && this.z === z && this.w === w;\n    };\n    /**\n     * Multiplies in place the current Vector4 by the given one.\n     * @param otherVector vector to multiple with\n     * @returns the updated Vector4.\n     */\n    Vector4.prototype.multiplyInPlace = function (otherVector) {\n        this.x *= otherVector.x;\n        this.y *= otherVector.y;\n        this.z *= otherVector.z;\n        this.w *= otherVector.w;\n        return this;\n    };\n    /**\n     * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.\n     * @param otherVector vector to multiple with\n     * @returns resulting new vector\n     */\n    Vector4.prototype.multiply = function (otherVector) {\n        return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\n    };\n    /**\n     * Updates the given vector \"result\" with the multiplication result of the current Vector4 and the given one.\n     * @param otherVector vector to multiple with\n     * @param result vector to store the result\n     * @returns the current Vector4.\n     */\n    Vector4.prototype.multiplyToRef = function (otherVector, result) {\n        result.x = this.x * otherVector.x;\n        result.y = this.y * otherVector.y;\n        result.z = this.z * otherVector.z;\n        result.w = this.w * otherVector.w;\n        return this;\n    };\n    /**\n     * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.\n     * @param x x value multiply with\n     * @param y y value multiply with\n     * @param z z value multiply with\n     * @param w w value multiply with\n     * @returns resulting new vector\n     */\n    Vector4.prototype.multiplyByFloats = function (x, y, z, w) {\n        return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\n    };\n    /**\n     * Returns a new Vector4 set with the division result of the current Vector4 by the given one.\n     * @param otherVector vector to devide with\n     * @returns resulting new vector\n     */\n    Vector4.prototype.divide = function (otherVector) {\n        return new Vector4(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\n    };\n    /**\n     * Updates the given vector \"result\" with the division result of the current Vector4 by the given one.\n     * @param otherVector vector to devide with\n     * @param result vector to store the result\n     * @returns the current Vector4.\n     */\n    Vector4.prototype.divideToRef = function (otherVector, result) {\n        result.x = this.x / otherVector.x;\n        result.y = this.y / otherVector.y;\n        result.z = this.z / otherVector.z;\n        result.w = this.w / otherVector.w;\n        return this;\n    };\n    /**\n     * Divides the current Vector3 coordinates by the given ones.\n     * @param otherVector vector to devide with\n     * @returns the updated Vector3.\n     */\n    Vector4.prototype.divideInPlace = function (otherVector) {\n        return this.divideToRef(otherVector, this);\n    };\n    /**\n     * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones\n     * @param other defines the second operand\n     * @returns the current updated Vector4\n     */\n    Vector4.prototype.minimizeInPlace = function (other) {\n        if (other.x < this.x) {\n            this.x = other.x;\n        }\n        if (other.y < this.y) {\n            this.y = other.y;\n        }\n        if (other.z < this.z) {\n            this.z = other.z;\n        }\n        if (other.w < this.w) {\n            this.w = other.w;\n        }\n        return this;\n    };\n    /**\n     * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones\n     * @param other defines the second operand\n     * @returns the current updated Vector4\n     */\n    Vector4.prototype.maximizeInPlace = function (other) {\n        if (other.x > this.x) {\n            this.x = other.x;\n        }\n        if (other.y > this.y) {\n            this.y = other.y;\n        }\n        if (other.z > this.z) {\n            this.z = other.z;\n        }\n        if (other.w > this.w) {\n            this.w = other.w;\n        }\n        return this;\n    };\n    /**\n     * Gets a new Vector4 from current Vector4 floored values\n     * @returns a new Vector4\n     */\n    Vector4.prototype.floor = function () {\n        return new Vector4(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\n    };\n    /**\n     * Gets a new Vector4 from current Vector3 floored values\n     * @returns a new Vector4\n     */\n    Vector4.prototype.fract = function () {\n        return new Vector4(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\n    };\n    // Properties\n    /**\n     * Returns the Vector4 length (float).\n     * @returns the length\n     */\n    Vector4.prototype.length = function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    };\n    /**\n     * Returns the Vector4 squared length (float).\n     * @returns the length squared\n     */\n    Vector4.prototype.lengthSquared = function () {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    };\n    // Methods\n    /**\n     * Normalizes in place the Vector4.\n     * @returns the updated Vector4.\n     */\n    Vector4.prototype.normalize = function () {\n        var len = this.length();\n        if (len === 0) {\n            return this;\n        }\n        return this.scaleInPlace(1.0 / len);\n    };\n    /**\n     * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\n     * @returns this converted to a new vector3\n     */\n    Vector4.prototype.toVector3 = function () {\n        return new Vector3(this.x, this.y, this.z);\n    };\n    /**\n     * Returns a new Vector4 copied from the current one.\n     * @returns the new cloned vector\n     */\n    Vector4.prototype.clone = function () {\n        return new Vector4(this.x, this.y, this.z, this.w);\n    };\n    /**\n     * Updates the current Vector4 with the given one coordinates.\n     * @param source the source vector to copy from\n     * @returns the updated Vector4.\n     */\n    Vector4.prototype.copyFrom = function (source) {\n        this.x = source.x;\n        this.y = source.y;\n        this.z = source.z;\n        this.w = source.w;\n        return this;\n    };\n    /**\n     * Updates the current Vector4 coordinates with the given floats.\n     * @param x float to copy from\n     * @param y float to copy from\n     * @param z float to copy from\n     * @param w float to copy from\n     * @returns the updated Vector4.\n     */\n    Vector4.prototype.copyFromFloats = function (x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    };\n    /**\n     * Updates the current Vector4 coordinates with the given floats.\n     * @param x float to set from\n     * @param y float to set from\n     * @param z float to set from\n     * @param w float to set from\n     * @returns the updated Vector4.\n     */\n    Vector4.prototype.set = function (x, y, z, w) {\n        return this.copyFromFloats(x, y, z, w);\n    };\n    /**\n     * Copies the given float to the current Vector3 coordinates\n     * @param v defines the x, y, z and w coordinates of the operand\n     * @returns the current updated Vector3\n     */\n    Vector4.prototype.setAll = function (v) {\n        this.x = this.y = this.z = this.w = v;\n        return this;\n    };\n    // Statics\n    /**\n     * Returns a new Vector4 set from the starting index of the given array.\n     * @param array the array to pull values from\n     * @param offset the offset into the array to start at\n     * @returns the new vector\n     */\n    Vector4.FromArray = function (array, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    };\n    /**\n     * Updates the given vector \"result\" from the starting index of the given array.\n     * @param array the array to pull values from\n     * @param offset the offset into the array to start at\n     * @param result the vector to store the result in\n     */\n    Vector4.FromArrayToRef = function (array, offset, result) {\n        result.x = array[offset];\n        result.y = array[offset + 1];\n        result.z = array[offset + 2];\n        result.w = array[offset + 3];\n    };\n    /**\n     * Updates the given vector \"result\" from the starting index of the given Float32Array.\n     * @param array the array to pull values from\n     * @param offset the offset into the array to start at\n     * @param result the vector to store the result in\n     */\n    Vector4.FromFloatArrayToRef = function (array, offset, result) {\n        Vector4.FromArrayToRef(array, offset, result);\n    };\n    /**\n     * Updates the given vector \"result\" coordinates from the given floats.\n     * @param x float to set from\n     * @param y float to set from\n     * @param z float to set from\n     * @param w float to set from\n     * @param result the vector to the floats in\n     */\n    Vector4.FromFloatsToRef = function (x, y, z, w, result) {\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n    };\n    /**\n     * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\n     * @returns the new vector\n     */\n    Vector4.Zero = function () {\n        return new Vector4(0.0, 0.0, 0.0, 0.0);\n    };\n    /**\n     * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\n     * @returns the new vector\n     */\n    Vector4.One = function () {\n        return new Vector4(1.0, 1.0, 1.0, 1.0);\n    };\n    /**\n     * Returns a new normalized Vector4 from the given one.\n     * @param vector the vector to normalize\n     * @returns the vector\n     */\n    Vector4.Normalize = function (vector) {\n        var result = Vector4.Zero();\n        Vector4.NormalizeToRef(vector, result);\n        return result;\n    };\n    /**\n     * Updates the given vector \"result\" from the normalization of the given one.\n     * @param vector the vector to normalize\n     * @param result the vector to store the result in\n     */\n    Vector4.NormalizeToRef = function (vector, result) {\n        result.copyFrom(vector);\n        result.normalize();\n    };\n    /**\n     * Returns a vector with the minimum values from the left and right vectors\n     * @param left left vector to minimize\n     * @param right right vector to minimize\n     * @returns a new vector with the minimum of the left and right vector values\n     */\n    Vector4.Minimize = function (left, right) {\n        var min = left.clone();\n        min.minimizeInPlace(right);\n        return min;\n    };\n    /**\n     * Returns a vector with the maximum values from the left and right vectors\n     * @param left left vector to maximize\n     * @param right right vector to maximize\n     * @returns a new vector with the maximum of the left and right vector values\n     */\n    Vector4.Maximize = function (left, right) {\n        var max = left.clone();\n        max.maximizeInPlace(right);\n        return max;\n    };\n    /**\n     * Returns the distance (float) between the vectors \"value1\" and \"value2\".\n     * @param value1 value to calulate the distance between\n     * @param value2 value to calulate the distance between\n     * @return the distance between the two vectors\n     */\n    Vector4.Distance = function (value1, value2) {\n        return Math.sqrt(Vector4.DistanceSquared(value1, value2));\n    };\n    /**\n     * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\n     * @param value1 value to calulate the distance between\n     * @param value2 value to calulate the distance between\n     * @return the distance between the two vectors squared\n     */\n    Vector4.DistanceSquared = function (value1, value2) {\n        var x = value1.x - value2.x;\n        var y = value1.y - value2.y;\n        var z = value1.z - value2.z;\n        var w = value1.w - value2.w;\n        return x * x + y * y + z * z + w * w;\n    };\n    /**\n     * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\n     * @param value1 value to calulate the center between\n     * @param value2 value to calulate the center between\n     * @return the center between the two vectors\n     */\n    Vector4.Center = function (value1, value2) {\n        return Vector4.CenterToRef(value1, value2, Vector4.Zero());\n    };\n    /**\n     * Gets the center of the vectors \"value1\" and \"value2\" and stores the result in the vector \"ref\"\n     * @param value1 defines first vector\n     * @param value2 defines second vector\n     * @param ref defines third vector\n     * @returns ref\n     */\n    Vector4.CenterToRef = function (value1, value2, ref) {\n        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);\n    };\n    /**\n     * Returns a new Vector4 set with the result of the transformation by the given matrix of the given vector.\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * The difference with Vector3.TransformCoordinates is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @returns the transformed Vector4\n     */\n    Vector4.TransformCoordinates = function (vector, transformation) {\n        var result = Vector4.Zero();\n        Vector4.TransformCoordinatesToRef(vector, transformation, result);\n        return result;\n    };\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * The difference with Vector3.TransformCoordinatesToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\n     * @param vector defines the Vector3 to transform\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector4 where to store the result\n     */\n    Vector4.TransformCoordinatesToRef = function (vector, transformation, result) {\n        Vector4.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);\n    };\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\n     * This method computes tranformed coordinates only, not transformed direction vectors\n     * The difference with Vector3.TransformCoordinatesFromFloatsToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead\n     * @param x define the x coordinate of the source vector\n     * @param y define the y coordinate of the source vector\n     * @param z define the z coordinate of the source vector\n     * @param transformation defines the transformation matrix\n     * @param result defines the Vector4 where to store the result\n     */\n    Vector4.TransformCoordinatesFromFloatsToRef = function (x, y, z, transformation, result) {\n        var m = transformation.m;\n        var rx = x * m[0] + y * m[4] + z * m[8] + m[12];\n        var ry = x * m[1] + y * m[5] + z * m[9] + m[13];\n        var rz = x * m[2] + y * m[6] + z * m[10] + m[14];\n        var rw = x * m[3] + y * m[7] + z * m[11] + m[15];\n        result.x = rx;\n        result.y = ry;\n        result.z = rz;\n        result.w = rw;\n    };\n    /**\n     * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.\n     * This methods computes transformed normalized direction vectors only.\n     * @param vector the vector to transform\n     * @param transformation the transformation matrix to apply\n     * @returns the new vector\n     */\n    Vector4.TransformNormal = function (vector, transformation) {\n        var result = Vector4.Zero();\n        Vector4.TransformNormalToRef(vector, transformation, result);\n        return result;\n    };\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector.\n     * This methods computes transformed normalized direction vectors only.\n     * @param vector the vector to transform\n     * @param transformation the transformation matrix to apply\n     * @param result the vector to store the result in\n     */\n    Vector4.TransformNormalToRef = function (vector, transformation, result) {\n        var m = transformation.m;\n        var x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];\n        var y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];\n        var z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = vector.w;\n    };\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).\n     * This methods computes transformed normalized direction vectors only.\n     * @param x value to transform\n     * @param y value to transform\n     * @param z value to transform\n     * @param w value to transform\n     * @param transformation the transformation matrix to apply\n     * @param result the vector to store the results in\n     */\n    Vector4.TransformNormalFromFloatsToRef = function (x, y, z, w, transformation, result) {\n        var m = transformation.m;\n        result.x = x * m[0] + y * m[4] + z * m[8];\n        result.y = x * m[1] + y * m[5] + z * m[9];\n        result.z = x * m[2] + y * m[6] + z * m[10];\n        result.w = w;\n    };\n    /**\n     * Creates a new Vector4 from a Vector3\n     * @param source defines the source data\n     * @param w defines the 4th component (default is 0)\n     * @returns a new Vector4\n     */\n    Vector4.FromVector3 = function (source, w) {\n        if (w === void 0) { w = 0; }\n        return new Vector4(source._x, source._y, source._z, w);\n    };\n    return Vector4;\n}());\nexport { Vector4 };\n/**\n * Class used to store quaternion data\n * @see https://en.wikipedia.org/wiki/Quaternion\n * @see https://doc.babylonjs.com/features/position,_rotation,_scaling\n */\nvar Quaternion = /** @class */ (function () {\n    /**\n     * Creates a new Quaternion from the given floats\n     * @param x defines the first component (0 by default)\n     * @param y defines the second component (0 by default)\n     * @param z defines the third component (0 by default)\n     * @param w defines the fourth component (1.0 by default)\n     */\n    function Quaternion(x, y, z, w) {\n        if (x === void 0) { x = 0.0; }\n        if (y === void 0) { y = 0.0; }\n        if (z === void 0) { z = 0.0; }\n        if (w === void 0) { w = 1.0; }\n        /** @hidden */\n        this._isDirty = true;\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._w = w;\n    }\n    Object.defineProperty(Quaternion.prototype, \"x\", {\n        /** Gets or sets the x coordinate */\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            this._x = value;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Quaternion.prototype, \"y\", {\n        /** Gets or sets the y coordinate */\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            this._y = value;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Quaternion.prototype, \"z\", {\n        /** Gets or sets the z coordinate */\n        get: function () {\n            return this._z;\n        },\n        set: function (value) {\n            this._z = value;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Quaternion.prototype, \"w\", {\n        /** Gets or sets the w coordinate */\n        get: function () {\n            return this._w;\n        },\n        set: function (value) {\n            this._w = value;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Gets a string representation for the current quaternion\n     * @returns a string with the Quaternion coordinates\n     */\n    Quaternion.prototype.toString = function () {\n        return \"{X: \".concat(this._x, \" Y: \").concat(this._y, \" Z: \").concat(this._z, \" W: \").concat(this._w, \"}\");\n    };\n    /**\n     * Gets the class name of the quaternion\n     * @returns the string \"Quaternion\"\n     */\n    Quaternion.prototype.getClassName = function () {\n        return \"Quaternion\";\n    };\n    /**\n     * Gets a hash code for this quaternion\n     * @returns the quaternion hash code\n     */\n    Quaternion.prototype.getHashCode = function () {\n        var x = _ExtractAsInt(this._x);\n        var y = _ExtractAsInt(this._y);\n        var z = _ExtractAsInt(this._z);\n        var w = _ExtractAsInt(this._w);\n        var hash = x;\n        hash = (hash * 397) ^ y;\n        hash = (hash * 397) ^ z;\n        hash = (hash * 397) ^ w;\n        return hash;\n    };\n    /**\n     * Copy the quaternion to an array\n     * @returns a new array populated with 4 elements from the quaternion coordinates\n     */\n    Quaternion.prototype.asArray = function () {\n        return [this._x, this._y, this._z, this._w];\n    };\n    /**\n     * Check if two quaternions are equals\n     * @param otherQuaternion defines the second operand\n     * @return true if the current quaternion and the given one coordinates are strictly equals\n     */\n    Quaternion.prototype.equals = function (otherQuaternion) {\n        return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;\n    };\n    /**\n     * Gets a boolean if two quaternions are equals (using an epsilon value)\n     * @param otherQuaternion defines the other quaternion\n     * @param epsilon defines the minimal distance to consider equality\n     * @returns true if the given quaternion coordinates are close to the current ones by a distance of epsilon.\n     */\n    Quaternion.prototype.equalsWithEpsilon = function (otherQuaternion, epsilon) {\n        if (epsilon === void 0) { epsilon = Epsilon; }\n        return (otherQuaternion &&\n            Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) &&\n            Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) &&\n            Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) &&\n            Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon));\n    };\n    /**\n     * Clone the current quaternion\n     * @returns a new quaternion copied from the current one\n     */\n    Quaternion.prototype.clone = function () {\n        return new Quaternion(this._x, this._y, this._z, this._w);\n    };\n    /**\n     * Copy a quaternion to the current one\n     * @param other defines the other quaternion\n     * @returns the updated current quaternion\n     */\n    Quaternion.prototype.copyFrom = function (other) {\n        this.x = other._x;\n        this.y = other._y;\n        this.z = other._z;\n        this.w = other._w;\n        return this;\n    };\n    /**\n     * Updates the current quaternion with the given float coordinates\n     * @param x defines the x coordinate\n     * @param y defines the y coordinate\n     * @param z defines the z coordinate\n     * @param w defines the w coordinate\n     * @returns the updated current quaternion\n     */\n    Quaternion.prototype.copyFromFloats = function (x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    };\n    /**\n     * Updates the current quaternion from the given float coordinates\n     * @param x defines the x coordinate\n     * @param y defines the y coordinate\n     * @param z defines the z coordinate\n     * @param w defines the w coordinate\n     * @returns the updated current quaternion\n     */\n    Quaternion.prototype.set = function (x, y, z, w) {\n        return this.copyFromFloats(x, y, z, w);\n    };\n    /**\n     * Adds two quaternions\n     * @param other defines the second operand\n     * @returns a new quaternion as the addition result of the given one and the current quaternion\n     */\n    Quaternion.prototype.add = function (other) {\n        return new Quaternion(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);\n    };\n    /**\n     * Add a quaternion to the current one\n     * @param other defines the quaternion to add\n     * @returns the current quaternion\n     */\n    Quaternion.prototype.addInPlace = function (other) {\n        this._x += other._x;\n        this._y += other._y;\n        this._z += other._z;\n        this._w += other._w;\n        return this;\n    };\n    /**\n     * Subtract two quaternions\n     * @param other defines the second operand\n     * @returns a new quaternion as the subtraction result of the given one from the current one\n     */\n    Quaternion.prototype.subtract = function (other) {\n        return new Quaternion(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);\n    };\n    /**\n     * Subtract a quaternion to the current one\n     * @param other defines the quaternion to subtract\n     * @returns the current quaternion\n     */\n    Quaternion.prototype.subtractInPlace = function (other) {\n        this._x -= other._x;\n        this._y -= other._y;\n        this._z -= other._z;\n        this._w -= other._w;\n        return this;\n    };\n    /**\n     * Multiplies the current quaternion by a scale factor\n     * @param value defines the scale factor\n     * @returns a new quaternion set by multiplying the current quaternion coordinates by the float \"scale\"\n     */\n    Quaternion.prototype.scale = function (value) {\n        return new Quaternion(this._x * value, this._y * value, this._z * value, this._w * value);\n    };\n    /**\n     * Scale the current quaternion values by a factor and stores the result to a given quaternion\n     * @param scale defines the scale factor\n     * @param result defines the Quaternion object where to store the result\n     * @returns the unmodified current quaternion\n     */\n    Quaternion.prototype.scaleToRef = function (scale, result) {\n        result.x = this._x * scale;\n        result.y = this._y * scale;\n        result.z = this._z * scale;\n        result.w = this._w * scale;\n        return this;\n    };\n    /**\n     * Multiplies in place the current quaternion by a scale factor\n     * @param value defines the scale factor\n     * @returns the current modified quaternion\n     */\n    Quaternion.prototype.scaleInPlace = function (value) {\n        this.x *= value;\n        this.y *= value;\n        this.z *= value;\n        this.w *= value;\n        return this;\n    };\n    /**\n     * Scale the current quaternion values by a factor and add the result to a given quaternion\n     * @param scale defines the scale factor\n     * @param result defines the Quaternion object where to store the result\n     * @returns the unmodified current quaternion\n     */\n    Quaternion.prototype.scaleAndAddToRef = function (scale, result) {\n        result.x += this._x * scale;\n        result.y += this._y * scale;\n        result.z += this._z * scale;\n        result.w += this._w * scale;\n        return this;\n    };\n    /**\n     * Multiplies two quaternions\n     * @param q1 defines the second operand\n     * @returns a new quaternion set as the multiplication result of the current one with the given one \"q1\"\n     */\n    Quaternion.prototype.multiply = function (q1) {\n        var result = new Quaternion(0, 0, 0, 1.0);\n        this.multiplyToRef(q1, result);\n        return result;\n    };\n    /**\n     * Sets the given \"result\" as the the multiplication result of the current one with the given one \"q1\"\n     * @param q1 defines the second operand\n     * @param result defines the target quaternion\n     * @returns the current quaternion\n     */\n    Quaternion.prototype.multiplyToRef = function (q1, result) {\n        var x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;\n        var y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;\n        var z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;\n        var w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;\n        result.copyFromFloats(x, y, z, w);\n        return this;\n    };\n    /**\n     * Updates the current quaternion with the multiplication of itself with the given one \"q1\"\n     * @param q1 defines the second operand\n     * @returns the currentupdated quaternion\n     */\n    Quaternion.prototype.multiplyInPlace = function (q1) {\n        this.multiplyToRef(q1, this);\n        return this;\n    };\n    /**\n     * Conjugates (1-q) the current quaternion and stores the result in the given quaternion\n     * @param ref defines the target quaternion\n     * @returns the current quaternion\n     */\n    Quaternion.prototype.conjugateToRef = function (ref) {\n        ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);\n        return this;\n    };\n    /**\n     * Conjugates in place (1-q) the current quaternion\n     * @returns the current updated quaternion\n     */\n    Quaternion.prototype.conjugateInPlace = function () {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    };\n    /**\n     * Conjugates in place (1-q) the current quaternion\n     * @returns a new quaternion\n     */\n    Quaternion.prototype.conjugate = function () {\n        return new Quaternion(-this._x, -this._y, -this._z, this._w);\n    };\n    /**\n     * Returns the inverse of the current quaternion\n     * @returns a new quaternion\n     */\n    Quaternion.prototype.invert = function () {\n        var conjugate = this.conjugate();\n        var lengthSquared = this.lengthSquared();\n        if (lengthSquared == 0 || lengthSquared == 1) {\n            return conjugate;\n        }\n        conjugate.scaleInPlace(1 / lengthSquared);\n        return conjugate;\n    };\n    /**\n     * Invert in place the current quaternion\n     * @returns this quaternion\n     */\n    Quaternion.prototype.invertInPlace = function () {\n        this.conjugateInPlace();\n        var lengthSquared = this.lengthSquared();\n        if (lengthSquared == 0 || lengthSquared == 1) {\n            return this;\n        }\n        this.scaleInPlace(1 / lengthSquared);\n        return this;\n    };\n    /**\n     * Gets squared length of current quaternion\n     * @returns the quaternion length (float)\n     */\n    Quaternion.prototype.lengthSquared = function () {\n        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    };\n    /**\n     * Gets length of current quaternion\n     * @returns the quaternion length (float)\n     */\n    Quaternion.prototype.length = function () {\n        return Math.sqrt(this.lengthSquared());\n    };\n    /**\n     * Normalize in place the current quaternion\n     * @returns the current updated quaternion\n     */\n    Quaternion.prototype.normalize = function () {\n        var len = this.length();\n        if (len === 0) {\n            return this;\n        }\n        var inv = 1.0 / len;\n        this.scaleInPlace(inv);\n        return this;\n    };\n    /**\n     * Normalize a copy of the current quaternion\n     * @returns the normalized quaternion\n     */\n    Quaternion.prototype.normalizeToNew = function () {\n        var len = this.length();\n        if (len === 0) {\n            return this.clone();\n        }\n        var inv = 1.0 / len;\n        return this.scale(inv);\n    };\n    /**\n     * Returns a new Vector3 set with the Euler angles translated from the current quaternion\n     * @returns a new Vector3 containing the Euler angles\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions\n     */\n    Quaternion.prototype.toEulerAngles = function () {\n        var result = Vector3.Zero();\n        this.toEulerAnglesToRef(result);\n        return result;\n    };\n    /**\n     * Sets the given vector3 \"result\" with the Euler angles translated from the current quaternion\n     * @param result defines the vector which will be filled with the Euler angles\n     * @returns the current unchanged quaternion\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions\n     */\n    Quaternion.prototype.toEulerAnglesToRef = function (result) {\n        var qz = this._z;\n        var qx = this._x;\n        var qy = this._y;\n        var qw = this._w;\n        var zAxisY = qy * qz - qx * qw;\n        var limit = 0.4999999;\n        if (zAxisY < -limit) {\n            result.y = 2 * Math.atan2(qy, qw);\n            result.x = Math.PI / 2;\n            result.z = 0;\n        }\n        else if (zAxisY > limit) {\n            result.y = 2 * Math.atan2(qy, qw);\n            result.x = -Math.PI / 2;\n            result.z = 0;\n        }\n        else {\n            var sqw = qw * qw;\n            var sqz = qz * qz;\n            var sqx = qx * qx;\n            var sqy = qy * qy;\n            result.z = Math.atan2(2.0 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);\n            result.x = Math.asin(-2.0 * zAxisY);\n            result.y = Math.atan2(2.0 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);\n        }\n        return this;\n    };\n    /**\n     * Updates the given rotation matrix with the current quaternion values\n     * @param result defines the target matrix\n     * @returns the current unchanged quaternion\n     */\n    Quaternion.prototype.toRotationMatrix = function (result) {\n        Matrix.FromQuaternionToRef(this, result);\n        return this;\n    };\n    /**\n     * Updates the current quaternion from the given rotation matrix values\n     * @param matrix defines the source matrix\n     * @returns the current updated quaternion\n     */\n    Quaternion.prototype.fromRotationMatrix = function (matrix) {\n        Quaternion.FromRotationMatrixToRef(matrix, this);\n        return this;\n    };\n    // Statics\n    /**\n     * Creates a new quaternion from a rotation matrix\n     * @param matrix defines the source matrix\n     * @returns a new quaternion created from the given rotation matrix values\n     */\n    Quaternion.FromRotationMatrix = function (matrix) {\n        var result = new Quaternion();\n        Quaternion.FromRotationMatrixToRef(matrix, result);\n        return result;\n    };\n    /**\n     * Updates the given quaternion with the given rotation matrix values\n     * @param matrix defines the source matrix\n     * @param result defines the target quaternion\n     */\n    Quaternion.FromRotationMatrixToRef = function (matrix, result) {\n        var data = matrix.m;\n        var m11 = data[0], m12 = data[4], m13 = data[8];\n        var m21 = data[1], m22 = data[5], m23 = data[9];\n        var m31 = data[2], m32 = data[6], m33 = data[10];\n        var trace = m11 + m22 + m33;\n        var s;\n        if (trace > 0) {\n            s = 0.5 / Math.sqrt(trace + 1.0);\n            result.w = 0.25 / s;\n            result.x = (m32 - m23) * s;\n            result.y = (m13 - m31) * s;\n            result.z = (m21 - m12) * s;\n        }\n        else if (m11 > m22 && m11 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n            result.w = (m32 - m23) / s;\n            result.x = 0.25 * s;\n            result.y = (m12 + m21) / s;\n            result.z = (m13 + m31) / s;\n        }\n        else if (m22 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n            result.w = (m13 - m31) / s;\n            result.x = (m12 + m21) / s;\n            result.y = 0.25 * s;\n            result.z = (m23 + m32) / s;\n        }\n        else {\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n            result.w = (m21 - m12) / s;\n            result.x = (m13 + m31) / s;\n            result.y = (m23 + m32) / s;\n            result.z = 0.25 * s;\n        }\n    };\n    /**\n     * Returns the dot product (float) between the quaternions \"left\" and \"right\"\n     * @param left defines the left operand\n     * @param right defines the right operand\n     * @returns the dot product\n     */\n    Quaternion.Dot = function (left, right) {\n        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\n    };\n    /**\n     * Checks if the two quaternions are close to each other\n     * @param quat0 defines the first quaternion to check\n     * @param quat1 defines the second quaternion to check\n     * @returns true if the two quaternions are close to each other\n     */\n    Quaternion.AreClose = function (quat0, quat1) {\n        var dot = Quaternion.Dot(quat0, quat1);\n        return dot >= 0;\n    };\n    /**\n     * Smooth interpolation between two quaternions using Slerp\n     *\n     * @param source source quaternion\n     * @param goal goal quaternion\n     * @param deltaTime current interpolation frame\n     * @param lerpTime total interpolation time\n     * @param result the smoothed quaternion\n     */\n    Quaternion.SmoothToRef = function (source, goal, deltaTime, lerpTime, result) {\n        var slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;\n        slerp = Scalar.Clamp(slerp, 0, 1);\n        Quaternion.SlerpToRef(source, goal, slerp, result);\n    };\n    /**\n     * Creates an empty quaternion\n     * @returns a new quaternion set to (0.0, 0.0, 0.0)\n     */\n    Quaternion.Zero = function () {\n        return new Quaternion(0.0, 0.0, 0.0, 0.0);\n    };\n    /**\n     * Inverse a given quaternion\n     * @param q defines the source quaternion\n     * @returns a new quaternion as the inverted current quaternion\n     */\n    Quaternion.Inverse = function (q) {\n        return new Quaternion(-q._x, -q._y, -q._z, q._w);\n    };\n    /**\n     * Inverse a given quaternion\n     * @param q defines the source quaternion\n     * @param result the quaternion the result will be stored in\n     * @returns the result quaternion\n     */\n    Quaternion.InverseToRef = function (q, result) {\n        result.set(-q._x, -q._y, -q._z, q._w);\n        return result;\n    };\n    /**\n     * Creates an identity quaternion\n     * @returns the identity quaternion\n     */\n    Quaternion.Identity = function () {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    };\n    /**\n     * Gets a boolean indicating if the given quaternion is identity\n     * @param quaternion defines the quaternion to check\n     * @returns true if the quaternion is identity\n     */\n    Quaternion.IsIdentity = function (quaternion) {\n        return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;\n    };\n    /**\n     * Creates a quaternion from a rotation around an axis\n     * @param axis defines the axis to use\n     * @param angle defines the angle to use\n     * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)\n     */\n    Quaternion.RotationAxis = function (axis, angle) {\n        return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());\n    };\n    /**\n     * Creates a rotation around an axis and stores it into the given quaternion\n     * @param axis defines the axis to use\n     * @param angle defines the angle to use\n     * @param result defines the target quaternion\n     * @returns the target quaternion\n     */\n    Quaternion.RotationAxisToRef = function (axis, angle, result) {\n        var sin = Math.sin(angle / 2);\n        axis.normalize();\n        result.w = Math.cos(angle / 2);\n        result.x = axis._x * sin;\n        result.y = axis._y * sin;\n        result.z = axis._z * sin;\n        return result;\n    };\n    /**\n     * Creates a new quaternion from data stored into an array\n     * @param array defines the data source\n     * @param offset defines the offset in the source array where the data starts\n     * @returns a new quaternion\n     */\n    Quaternion.FromArray = function (array, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    };\n    /**\n     * Updates the given quaternion \"result\" from the starting index of the given array.\n     * @param array the array to pull values from\n     * @param offset the offset into the array to start at\n     * @param result the quaternion to store the result in\n     */\n    Quaternion.FromArrayToRef = function (array, offset, result) {\n        result.x = array[offset];\n        result.y = array[offset + 1];\n        result.z = array[offset + 2];\n        result.w = array[offset + 3];\n    };\n    /**\n     * Create a quaternion from Euler rotation angles\n     * @param x Pitch\n     * @param y Yaw\n     * @param z Roll\n     * @returns the new Quaternion\n     */\n    Quaternion.FromEulerAngles = function (x, y, z) {\n        var q = new Quaternion();\n        Quaternion.RotationYawPitchRollToRef(y, x, z, q);\n        return q;\n    };\n    /**\n     * Updates a quaternion from Euler rotation angles\n     * @param x Pitch\n     * @param y Yaw\n     * @param z Roll\n     * @param result the quaternion to store the result\n     * @returns the updated quaternion\n     */\n    Quaternion.FromEulerAnglesToRef = function (x, y, z, result) {\n        Quaternion.RotationYawPitchRollToRef(y, x, z, result);\n        return result;\n    };\n    /**\n     * Create a quaternion from Euler rotation vector\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\n     * @returns the new Quaternion\n     */\n    Quaternion.FromEulerVector = function (vec) {\n        var q = new Quaternion();\n        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);\n        return q;\n    };\n    /**\n     * Updates a quaternion from Euler rotation vector\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\n     * @param result the quaternion to store the result\n     * @returns the updated quaternion\n     */\n    Quaternion.FromEulerVectorToRef = function (vec, result) {\n        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);\n        return result;\n    };\n    /**\n     * Updates a quaternion so that it rotates vector vecFrom to vector vecTo\n     * @param vecFrom defines the direction vector from which to rotate\n     * @param vecTo defines the direction vector to which to rotate\n     * @param result the quaternion to store the result\n     * @returns the updated quaternion\n     */\n    Quaternion.FromUnitVectorsToRef = function (vecFrom, vecTo, result) {\n        var r = Vector3.Dot(vecFrom, vecTo) + 1;\n        if (r < Epsilon) {\n            if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {\n                result.set(-vecFrom.y, vecFrom.x, 0, 0);\n            }\n            else {\n                result.set(0, -vecFrom.z, vecFrom.y, 0);\n            }\n        }\n        else {\n            Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);\n            result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);\n        }\n        return result.normalize();\n    };\n    /**\n     * Creates a new quaternion from the given Euler float angles (y, x, z)\n     * @param yaw defines the rotation around Y axis\n     * @param pitch defines the rotation around X axis\n     * @param roll defines the rotation around Z axis\n     * @returns the new quaternion\n     */\n    Quaternion.RotationYawPitchRoll = function (yaw, pitch, roll) {\n        var q = new Quaternion();\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\n        return q;\n    };\n    /**\n     * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion\n     * @param yaw defines the rotation around Y axis\n     * @param pitch defines the rotation around X axis\n     * @param roll defines the rotation around Z axis\n     * @param result defines the target quaternion\n     */\n    Quaternion.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n        // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)\n        var halfRoll = roll * 0.5;\n        var halfPitch = pitch * 0.5;\n        var halfYaw = yaw * 0.5;\n        var sinRoll = Math.sin(halfRoll);\n        var cosRoll = Math.cos(halfRoll);\n        var sinPitch = Math.sin(halfPitch);\n        var cosPitch = Math.cos(halfPitch);\n        var sinYaw = Math.sin(halfYaw);\n        var cosYaw = Math.cos(halfYaw);\n        result.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;\n        result.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;\n        result.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;\n        result.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;\n    };\n    /**\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation\n     * @param alpha defines the rotation around first axis\n     * @param beta defines the rotation around second axis\n     * @param gamma defines the rotation around third axis\n     * @returns the new quaternion\n     */\n    Quaternion.RotationAlphaBetaGamma = function (alpha, beta, gamma) {\n        var result = new Quaternion();\n        Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\n        return result;\n    };\n    /**\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion\n     * @param alpha defines the rotation around first axis\n     * @param beta defines the rotation around second axis\n     * @param gamma defines the rotation around third axis\n     * @param result defines the target quaternion\n     */\n    Quaternion.RotationAlphaBetaGammaToRef = function (alpha, beta, gamma, result) {\n        // Produces a quaternion from Euler angles in the z-x-z orientation\n        var halfGammaPlusAlpha = (gamma + alpha) * 0.5;\n        var halfGammaMinusAlpha = (gamma - alpha) * 0.5;\n        var halfBeta = beta * 0.5;\n        result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\n        result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\n        result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\n        result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\n    };\n    /**\n     * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)\n     * @param axis1 defines the first axis\n     * @param axis2 defines the second axis\n     * @param axis3 defines the third axis\n     * @returns the new quaternion\n     */\n    Quaternion.RotationQuaternionFromAxis = function (axis1, axis2, axis3) {\n        var quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n        return quat;\n    };\n    /**\n     * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion\n     * @param axis1 defines the first axis\n     * @param axis2 defines the second axis\n     * @param axis3 defines the third axis\n     * @param ref defines the target quaternion\n     */\n    Quaternion.RotationQuaternionFromAxisToRef = function (axis1, axis2, axis3, ref) {\n        var rotMat = MathTmp.Matrix[0];\n        Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\n        Quaternion.FromRotationMatrixToRef(rotMat, ref);\n    };\n    /**\n     * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like \"up\".\n     * This function works in left handed mode\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @returns A new quaternion oriented toward the specified forward and up.\n     */\n    Quaternion.FromLookDirectionLH = function (forward, up) {\n        var quat = new Quaternion();\n        Quaternion.FromLookDirectionLHToRef(forward, up, quat);\n        return quat;\n    };\n    /**\n     * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like \"up\", and stores it in the target quaternion.\n     * This function works in left handed mode\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @param ref defines the target quaternion.\n     */\n    Quaternion.FromLookDirectionLHToRef = function (forward, up, ref) {\n        var rotMat = MathTmp.Matrix[0];\n        Matrix.LookDirectionLHToRef(forward, up, rotMat);\n        Quaternion.FromRotationMatrixToRef(rotMat, ref);\n    };\n    /**\n     * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like \"up\".\n     * This function works in right handed mode\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @returns A new quaternion oriented toward the specified forward and up.\n     */\n    Quaternion.FromLookDirectionRH = function (forward, up) {\n        var quat = new Quaternion();\n        Quaternion.FromLookDirectionRHToRef(forward, up, quat);\n        return quat;\n    };\n    /**\n     * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like \"up\", and stores it in the target quaternion.\n     * This function works in right handed mode\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @param ref defines the target quaternion.\n     */\n    Quaternion.FromLookDirectionRHToRef = function (forward, up, ref) {\n        var rotMat = MathTmp.Matrix[0];\n        Matrix.LookDirectionRHToRef(forward, up, rotMat);\n        return Quaternion.FromRotationMatrixToRef(rotMat, ref);\n    };\n    /**\n     * Interpolates between two quaternions\n     * @param left defines first quaternion\n     * @param right defines second quaternion\n     * @param amount defines the gradient to use\n     * @returns the new interpolated quaternion\n     */\n    Quaternion.Slerp = function (left, right, amount) {\n        var result = Quaternion.Identity();\n        Quaternion.SlerpToRef(left, right, amount, result);\n        return result;\n    };\n    /**\n     * Interpolates between two quaternions and stores it into a target quaternion\n     * @param left defines first quaternion\n     * @param right defines second quaternion\n     * @param amount defines the gradient to use\n     * @param result defines the target quaternion\n     */\n    Quaternion.SlerpToRef = function (left, right, amount, result) {\n        var num2;\n        var num3;\n        var num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;\n        var flag = false;\n        if (num4 < 0) {\n            flag = true;\n            num4 = -num4;\n        }\n        if (num4 > 0.999999) {\n            num3 = 1 - amount;\n            num2 = flag ? -amount : amount;\n        }\n        else {\n            var num5 = Math.acos(num4);\n            var num6 = 1.0 / Math.sin(num5);\n            num3 = Math.sin((1.0 - amount) * num5) * num6;\n            num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;\n        }\n        result.x = num3 * left._x + num2 * right._x;\n        result.y = num3 * left._y + num2 * right._y;\n        result.z = num3 * left._z + num2 * right._z;\n        result.w = num3 * left._w + num2 * right._w;\n    };\n    /**\n     * Interpolate between two quaternions using Hermite interpolation\n     * @param value1 defines first quaternion\n     * @param tangent1 defines the incoming tangent\n     * @param value2 defines second quaternion\n     * @param tangent2 defines the outgoing tangent\n     * @param amount defines the target quaternion\n     * @returns the new interpolated quaternion\n     */\n    Quaternion.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n        var squared = amount * amount;\n        var cubed = amount * squared;\n        var part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        var part2 = -2.0 * cubed + 3.0 * squared;\n        var part3 = cubed - 2.0 * squared + amount;\n        var part4 = cubed - squared;\n        var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;\n        var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;\n        var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;\n        var w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;\n        return new Quaternion(x, y, z, w);\n    };\n    /**\n     * Returns a new Quaternion which is the 1st derivative of the Hermite spline defined by the quaternions \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @returns 1st derivative\n     */\n    Quaternion.Hermite1stDerivative = function (value1, tangent1, value2, tangent2, time) {\n        var result = Quaternion.Zero();\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n        return result;\n    };\n    /**\n     * Update a Quaternion with the 1st derivative of the Hermite spline defined by the quaternions \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n     * @param value1 defines the first control point\n     * @param tangent1 defines the first tangent\n     * @param value2 defines the second control point\n     * @param tangent2 defines the second tangent\n     * @param time define where the derivative must be done\n     * @param result define where to store the derivative\n     */\n    Quaternion.Hermite1stDerivativeToRef = function (value1, tangent1, value2, tangent2, time, result) {\n        var t2 = time * time;\n        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;\n        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;\n        result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;\n        result.w = (t2 - time) * 6 * value1.w + (3 * t2 - 4 * time + 1) * tangent1.w + (-t2 + time) * 6 * value2.w + (3 * t2 - 2 * time) * tangent2.w;\n    };\n    return Quaternion;\n}());\nexport { Quaternion };\n/**\n * Class used to store matrix data (4x4)\n */\nvar Matrix = /** @class */ (function () {\n    /**\n     * Creates an empty matrix (filled with zeros)\n     */\n    function Matrix() {\n        this._isIdentity = false;\n        this._isIdentityDirty = true;\n        this._isIdentity3x2 = true;\n        this._isIdentity3x2Dirty = true;\n        /**\n         * Gets the update flag of the matrix which is an unique number for the matrix.\n         * It will be incremented every time the matrix data change.\n         * You can use it to speed the comparison between two versions of the same matrix.\n         */\n        this.updateFlag = -1;\n        if (PerformanceConfigurator.MatrixTrackPrecisionChange) {\n            PerformanceConfigurator.MatrixTrackedMatrices.push(this);\n        }\n        this._m = new PerformanceConfigurator.MatrixCurrentType(16);\n        this.markAsUpdated();\n    }\n    Object.defineProperty(Matrix, \"Use64Bits\", {\n        /**\n         * Gets the precision of matrix computations\n         */\n        get: function () {\n            return PerformanceConfigurator.MatrixUse64Bits;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"m\", {\n        /**\n         * Gets the internal data of the matrix\n         */\n        get: function () {\n            return this._m;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Update the updateFlag to indicate that the matrix has been updated\n     */\n    Matrix.prototype.markAsUpdated = function () {\n        this.updateFlag = Matrix._UpdateFlagSeed++;\n        this._isIdentity = false;\n        this._isIdentity3x2 = false;\n        this._isIdentityDirty = true;\n        this._isIdentity3x2Dirty = true;\n    };\n    Matrix.prototype._updateIdentityStatus = function (isIdentity, isIdentityDirty, isIdentity3x2, isIdentity3x2Dirty) {\n        if (isIdentityDirty === void 0) { isIdentityDirty = false; }\n        if (isIdentity3x2 === void 0) { isIdentity3x2 = false; }\n        if (isIdentity3x2Dirty === void 0) { isIdentity3x2Dirty = true; }\n        this._isIdentity = isIdentity;\n        this._isIdentity3x2 = isIdentity || isIdentity3x2;\n        this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;\n        this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;\n    };\n    // Properties\n    /**\n     * Check if the current matrix is identity\n     * @returns true is the matrix is the identity matrix\n     */\n    Matrix.prototype.isIdentity = function () {\n        if (this._isIdentityDirty) {\n            this._isIdentityDirty = false;\n            var m = this._m;\n            this._isIdentity =\n                m[0] === 1.0 &&\n                    m[1] === 0.0 &&\n                    m[2] === 0.0 &&\n                    m[3] === 0.0 &&\n                    m[4] === 0.0 &&\n                    m[5] === 1.0 &&\n                    m[6] === 0.0 &&\n                    m[7] === 0.0 &&\n                    m[8] === 0.0 &&\n                    m[9] === 0.0 &&\n                    m[10] === 1.0 &&\n                    m[11] === 0.0 &&\n                    m[12] === 0.0 &&\n                    m[13] === 0.0 &&\n                    m[14] === 0.0 &&\n                    m[15] === 1.0;\n        }\n        return this._isIdentity;\n    };\n    /**\n     * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)\n     * @returns true is the matrix is the identity matrix\n     */\n    Matrix.prototype.isIdentityAs3x2 = function () {\n        if (this._isIdentity3x2Dirty) {\n            this._isIdentity3x2Dirty = false;\n            if (this._m[0] !== 1.0 || this._m[5] !== 1.0 || this._m[15] !== 1.0) {\n                this._isIdentity3x2 = false;\n            }\n            else if (this._m[1] !== 0.0 ||\n                this._m[2] !== 0.0 ||\n                this._m[3] !== 0.0 ||\n                this._m[4] !== 0.0 ||\n                this._m[6] !== 0.0 ||\n                this._m[7] !== 0.0 ||\n                this._m[8] !== 0.0 ||\n                this._m[9] !== 0.0 ||\n                this._m[10] !== 0.0 ||\n                this._m[11] !== 0.0 ||\n                this._m[12] !== 0.0 ||\n                this._m[13] !== 0.0 ||\n                this._m[14] !== 0.0) {\n                this._isIdentity3x2 = false;\n            }\n            else {\n                this._isIdentity3x2 = true;\n            }\n        }\n        return this._isIdentity3x2;\n    };\n    /**\n     * Gets the determinant of the matrix\n     * @returns the matrix determinant\n     */\n    Matrix.prototype.determinant = function () {\n        if (this._isIdentity === true) {\n            return 1;\n        }\n        var m = this._m;\n        var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\n        var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\n        var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\n        var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\n        // https://en.wikipedia.org/wiki/Laplace_expansion\n        // to compute the deterrminant of a 4x4 Matrix we compute the cofactors of any row or column,\n        // then we multiply each Cofactor by its corresponding matrix value and sum them all to get the determinant\n        // Cofactor(i, j) = sign(i,j) * det(Minor(i, j))\n        // where\n        //  - sign(i,j) = (i+j) % 2 === 0 ? 1 : -1\n        //  - Minor(i, j) is the 3x3 matrix we get by removing row i and column j from current Matrix\n        //\n        // Here we do that for the 1st row.\n        var det_22_33 = m22 * m33 - m32 * m23;\n        var det_21_33 = m21 * m33 - m31 * m23;\n        var det_21_32 = m21 * m32 - m31 * m22;\n        var det_20_33 = m20 * m33 - m30 * m23;\n        var det_20_32 = m20 * m32 - m22 * m30;\n        var det_20_31 = m20 * m31 - m30 * m21;\n        var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n        var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n        var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n        var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n    };\n    // Methods\n    /**\n     * Returns the matrix as a Float32Array or Array<number>\n     * @returns the matrix underlying array\n     */\n    Matrix.prototype.toArray = function () {\n        return this._m;\n    };\n    /**\n     * Returns the matrix as a Float32Array or Array<number>\n     * @returns the matrix underlying array.\n     */\n    Matrix.prototype.asArray = function () {\n        return this._m;\n    };\n    /**\n     * Inverts the current matrix in place\n     * @returns the current inverted matrix\n     */\n    Matrix.prototype.invert = function () {\n        this.invertToRef(this);\n        return this;\n    };\n    /**\n     * Sets all the matrix elements to zero\n     * @returns the current matrix\n     */\n    Matrix.prototype.reset = function () {\n        Matrix.FromValuesToRef(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, this);\n        this._updateIdentityStatus(false);\n        return this;\n    };\n    /**\n     * Adds the current matrix with a second one\n     * @param other defines the matrix to add\n     * @returns a new matrix as the addition of the current matrix and the given one\n     */\n    Matrix.prototype.add = function (other) {\n        var result = new Matrix();\n        this.addToRef(other, result);\n        return result;\n    };\n    /**\n     * Sets the given matrix \"result\" to the addition of the current matrix and the given one\n     * @param other defines the matrix to add\n     * @param result defines the target matrix\n     * @returns the current matrix\n     */\n    Matrix.prototype.addToRef = function (other, result) {\n        var m = this._m;\n        var resultM = result._m;\n        var otherM = other.m;\n        for (var index = 0; index < 16; index++) {\n            resultM[index] = m[index] + otherM[index];\n        }\n        result.markAsUpdated();\n        return this;\n    };\n    /**\n     * Adds in place the given matrix to the current matrix\n     * @param other defines the second operand\n     * @returns the current updated matrix\n     */\n    Matrix.prototype.addToSelf = function (other) {\n        var m = this._m;\n        var otherM = other.m;\n        for (var index = 0; index < 16; index++) {\n            m[index] += otherM[index];\n        }\n        this.markAsUpdated();\n        return this;\n    };\n    /**\n     * Sets the given matrix to the current inverted Matrix\n     * @param other defines the target matrix\n     * @returns the unmodified current matrix\n     */\n    Matrix.prototype.invertToRef = function (other) {\n        if (this._isIdentity === true) {\n            Matrix.IdentityToRef(other);\n            return this;\n        }\n        // the inverse of a Matrix is the transpose of cofactor matrix divided by the determinant\n        var m = this._m;\n        var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\n        var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\n        var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\n        var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\n        var det_22_33 = m22 * m33 - m32 * m23;\n        var det_21_33 = m21 * m33 - m31 * m23;\n        var det_21_32 = m21 * m32 - m31 * m22;\n        var det_20_33 = m20 * m33 - m30 * m23;\n        var det_20_32 = m20 * m32 - m22 * m30;\n        var det_20_31 = m20 * m31 - m30 * m21;\n        var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n        var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n        var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n        var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n        var det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n        if (det === 0) {\n            // not invertible\n            other.copyFrom(this);\n            return this;\n        }\n        var detInv = 1 / det;\n        var det_12_33 = m12 * m33 - m32 * m13;\n        var det_11_33 = m11 * m33 - m31 * m13;\n        var det_11_32 = m11 * m32 - m31 * m12;\n        var det_10_33 = m10 * m33 - m30 * m13;\n        var det_10_32 = m10 * m32 - m30 * m12;\n        var det_10_31 = m10 * m31 - m30 * m11;\n        var det_12_23 = m12 * m23 - m22 * m13;\n        var det_11_23 = m11 * m23 - m21 * m13;\n        var det_11_22 = m11 * m22 - m21 * m12;\n        var det_10_23 = m10 * m23 - m20 * m13;\n        var det_10_22 = m10 * m22 - m20 * m12;\n        var det_10_21 = m10 * m21 - m20 * m11;\n        var cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);\n        var cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);\n        var cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);\n        var cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);\n        var cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);\n        var cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);\n        var cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);\n        var cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);\n        var cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);\n        var cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);\n        var cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);\n        var cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);\n        Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);\n        return this;\n    };\n    /**\n     * add a value at the specified position in the current Matrix\n     * @param index the index of the value within the matrix. between 0 and 15.\n     * @param value the value to be added\n     * @returns the current updated matrix\n     */\n    Matrix.prototype.addAtIndex = function (index, value) {\n        this._m[index] += value;\n        this.markAsUpdated();\n        return this;\n    };\n    /**\n     * mutiply the specified position in the current Matrix by a value\n     * @param index the index of the value within the matrix. between 0 and 15.\n     * @param value the value to be added\n     * @returns the current updated matrix\n     */\n    Matrix.prototype.multiplyAtIndex = function (index, value) {\n        this._m[index] *= value;\n        this.markAsUpdated();\n        return this;\n    };\n    /**\n     * Inserts the translation vector (using 3 floats) in the current matrix\n     * @param x defines the 1st component of the translation\n     * @param y defines the 2nd component of the translation\n     * @param z defines the 3rd component of the translation\n     * @returns the current updated matrix\n     */\n    Matrix.prototype.setTranslationFromFloats = function (x, y, z) {\n        this._m[12] = x;\n        this._m[13] = y;\n        this._m[14] = z;\n        this.markAsUpdated();\n        return this;\n    };\n    /**\n     * Adds the translation vector (using 3 floats) in the current matrix\n     * @param x defines the 1st component of the translation\n     * @param y defines the 2nd component of the translation\n     * @param z defines the 3rd component of the translation\n     * @returns the current updated matrix\n     */\n    Matrix.prototype.addTranslationFromFloats = function (x, y, z) {\n        this._m[12] += x;\n        this._m[13] += y;\n        this._m[14] += z;\n        this.markAsUpdated();\n        return this;\n    };\n    /**\n     * Inserts the translation vector in the current matrix\n     * @param vector3 defines the translation to insert\n     * @returns the current updated matrix\n     */\n    Matrix.prototype.setTranslation = function (vector3) {\n        return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);\n    };\n    /**\n     * Gets the translation value of the current matrix\n     * @returns a new Vector3 as the extracted translation from the matrix\n     */\n    Matrix.prototype.getTranslation = function () {\n        return new Vector3(this._m[12], this._m[13], this._m[14]);\n    };\n    /**\n     * Fill a Vector3 with the extracted translation from the matrix\n     * @param result defines the Vector3 where to store the translation\n     * @returns the current matrix\n     */\n    Matrix.prototype.getTranslationToRef = function (result) {\n        result.x = this._m[12];\n        result.y = this._m[13];\n        result.z = this._m[14];\n        return this;\n    };\n    /**\n     * Remove rotation and scaling part from the matrix\n     * @returns the updated matrix\n     */\n    Matrix.prototype.removeRotationAndScaling = function () {\n        var m = this.m;\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, m[12], m[13], m[14], m[15], this);\n        this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);\n        return this;\n    };\n    /**\n     * Multiply two matrices\n     * @param other defines the second operand\n     * @returns a new matrix set with the multiplication result of the current Matrix and the given one\n     */\n    Matrix.prototype.multiply = function (other) {\n        var result = new Matrix();\n        this.multiplyToRef(other, result);\n        return result;\n    };\n    /**\n     * Copy the current matrix from the given one\n     * @param other defines the source matrix\n     * @returns the current updated matrix\n     */\n    Matrix.prototype.copyFrom = function (other) {\n        other.copyToArray(this._m);\n        var o = other;\n        this.updateFlag = o.updateFlag;\n        this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);\n        return this;\n    };\n    /**\n     * Populates the given array from the starting index with the current matrix values\n     * @param array defines the target array\n     * @param offset defines the offset in the target array where to start storing values\n     * @returns the current matrix\n     */\n    Matrix.prototype.copyToArray = function (array, offset) {\n        if (offset === void 0) { offset = 0; }\n        var source = this._m;\n        array[offset] = source[0];\n        array[offset + 1] = source[1];\n        array[offset + 2] = source[2];\n        array[offset + 3] = source[3];\n        array[offset + 4] = source[4];\n        array[offset + 5] = source[5];\n        array[offset + 6] = source[6];\n        array[offset + 7] = source[7];\n        array[offset + 8] = source[8];\n        array[offset + 9] = source[9];\n        array[offset + 10] = source[10];\n        array[offset + 11] = source[11];\n        array[offset + 12] = source[12];\n        array[offset + 13] = source[13];\n        array[offset + 14] = source[14];\n        array[offset + 15] = source[15];\n        return this;\n    };\n    /**\n     * Sets the given matrix \"result\" with the multiplication result of the current Matrix and the given one\n     * @param other defines the second operand\n     * @param result defines the matrix where to store the multiplication\n     * @returns the current matrix\n     */\n    Matrix.prototype.multiplyToRef = function (other, result) {\n        if (this._isIdentity) {\n            result.copyFrom(other);\n            return this;\n        }\n        if (other._isIdentity) {\n            result.copyFrom(this);\n            return this;\n        }\n        this.multiplyToArray(other, result._m, 0);\n        result.markAsUpdated();\n        return this;\n    };\n    /**\n     * Sets the Float32Array \"result\" from the given index \"offset\" with the multiplication of the current matrix and the given one\n     * @param other defines the second operand\n     * @param result defines the array where to store the multiplication\n     * @param offset defines the offset in the target array where to start storing values\n     * @returns the current matrix\n     */\n    Matrix.prototype.multiplyToArray = function (other, result, offset) {\n        var m = this._m;\n        var otherM = other.m;\n        var tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];\n        var tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];\n        var tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];\n        var tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];\n        var om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];\n        var om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];\n        var om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];\n        var om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];\n        result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\n        result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\n        result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\n        result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\n        result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\n        result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\n        result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\n        result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\n        result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\n        result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\n        result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\n        result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\n        result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\n        result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\n        result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\n        result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\n        return this;\n    };\n    /**\n     * Check equality between this matrix and a second one\n     * @param value defines the second matrix to compare\n     * @returns true is the current matrix and the given one values are strictly equal\n     */\n    Matrix.prototype.equals = function (value) {\n        var other = value;\n        if (!other) {\n            return false;\n        }\n        if (this._isIdentity || other._isIdentity) {\n            if (!this._isIdentityDirty && !other._isIdentityDirty) {\n                return this._isIdentity && other._isIdentity;\n            }\n        }\n        var m = this.m;\n        var om = other.m;\n        return (m[0] === om[0] &&\n            m[1] === om[1] &&\n            m[2] === om[2] &&\n            m[3] === om[3] &&\n            m[4] === om[4] &&\n            m[5] === om[5] &&\n            m[6] === om[6] &&\n            m[7] === om[7] &&\n            m[8] === om[8] &&\n            m[9] === om[9] &&\n            m[10] === om[10] &&\n            m[11] === om[11] &&\n            m[12] === om[12] &&\n            m[13] === om[13] &&\n            m[14] === om[14] &&\n            m[15] === om[15]);\n    };\n    /**\n     * Clone the current matrix\n     * @returns a new matrix from the current matrix\n     */\n    Matrix.prototype.clone = function () {\n        var matrix = new Matrix();\n        matrix.copyFrom(this);\n        return matrix;\n    };\n    /**\n     * Returns the name of the current matrix class\n     * @returns the string \"Matrix\"\n     */\n    Matrix.prototype.getClassName = function () {\n        return \"Matrix\";\n    };\n    /**\n     * Gets the hash code of the current matrix\n     * @returns the hash code\n     */\n    Matrix.prototype.getHashCode = function () {\n        var hash = _ExtractAsInt(this._m[0]);\n        for (var i = 1; i < 16; i++) {\n            hash = (hash * 397) ^ _ExtractAsInt(this._m[i]);\n        }\n        return hash;\n    };\n    /**\n     * Decomposes the current Matrix into a translation, rotation and scaling components of the provided node\n     * @param node the node to decompose the matrix to\n     * @returns true if operation was successful\n     */\n    Matrix.prototype.decomposeToTransformNode = function (node) {\n        node.rotationQuaternion = node.rotationQuaternion || new Quaternion();\n        return this.decompose(node.scaling, node.rotationQuaternion, node.position);\n    };\n    /**\n     * Decomposes the current Matrix into a translation, rotation and scaling components\n     * @param scale defines the scale vector3 given as a reference to update\n     * @param rotation defines the rotation quaternion given as a reference to update\n     * @param translation defines the translation vector3 given as a reference to update\n     * @param preserveScalingNode Use scaling sign coming from this node. Otherwise scaling sign might change.\n     * @returns true if operation was successful\n     */\n    Matrix.prototype.decompose = function (scale, rotation, translation, preserveScalingNode) {\n        if (this._isIdentity) {\n            if (translation) {\n                translation.setAll(0);\n            }\n            if (scale) {\n                scale.setAll(1);\n            }\n            if (rotation) {\n                rotation.copyFromFloats(0, 0, 0, 1);\n            }\n            return true;\n        }\n        var m = this._m;\n        if (translation) {\n            translation.copyFromFloats(m[12], m[13], m[14]);\n        }\n        scale = scale || MathTmp.Vector3[0];\n        scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\n        scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\n        scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\n        if (preserveScalingNode) {\n            var signX = preserveScalingNode.scaling.x < 0 ? -1 : 1;\n            var signY = preserveScalingNode.scaling.y < 0 ? -1 : 1;\n            var signZ = preserveScalingNode.scaling.z < 0 ? -1 : 1;\n            scale.x *= signX;\n            scale.y *= signY;\n            scale.z *= signZ;\n        }\n        else {\n            if (this.determinant() <= 0) {\n                scale.y *= -1;\n            }\n        }\n        if (scale._x === 0 || scale._y === 0 || scale._z === 0) {\n            if (rotation) {\n                rotation.copyFromFloats(0.0, 0.0, 0.0, 1.0);\n            }\n            return false;\n        }\n        if (rotation) {\n            var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;\n            Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, MathTmp.Matrix[0]);\n            Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);\n        }\n        return true;\n    };\n    /**\n     * Gets specific row of the matrix\n     * @param index defines the number of the row to get\n     * @returns the index-th row of the current matrix as a new Vector4\n     */\n    Matrix.prototype.getRow = function (index) {\n        if (index < 0 || index > 3) {\n            return null;\n        }\n        var i = index * 4;\n        return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);\n    };\n    /**\n     * Sets the index-th row of the current matrix to the vector4 values\n     * @param index defines the number of the row to set\n     * @param row defines the target vector4\n     * @returns the updated current matrix\n     */\n    Matrix.prototype.setRow = function (index, row) {\n        return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);\n    };\n    /**\n     * Compute the transpose of the matrix\n     * @returns the new transposed matrix\n     */\n    Matrix.prototype.transpose = function () {\n        return Matrix.Transpose(this);\n    };\n    /**\n     * Compute the transpose of the matrix and store it in a given matrix\n     * @param result defines the target matrix\n     * @returns the current matrix\n     */\n    Matrix.prototype.transposeToRef = function (result) {\n        Matrix.TransposeToRef(this, result);\n        return this;\n    };\n    /**\n     * Sets the index-th row of the current matrix with the given 4 x float values\n     * @param index defines the row index\n     * @param x defines the x component to set\n     * @param y defines the y component to set\n     * @param z defines the z component to set\n     * @param w defines the w component to set\n     * @returns the updated current matrix\n     */\n    Matrix.prototype.setRowFromFloats = function (index, x, y, z, w) {\n        if (index < 0 || index > 3) {\n            return this;\n        }\n        var i = index * 4;\n        this._m[i + 0] = x;\n        this._m[i + 1] = y;\n        this._m[i + 2] = z;\n        this._m[i + 3] = w;\n        this.markAsUpdated();\n        return this;\n    };\n    /**\n     * Compute a new matrix set with the current matrix values multiplied by scale (float)\n     * @param scale defines the scale factor\n     * @returns a new matrix\n     */\n    Matrix.prototype.scale = function (scale) {\n        var result = new Matrix();\n        this.scaleToRef(scale, result);\n        return result;\n    };\n    /**\n     * Scale the current matrix values by a factor to a given result matrix\n     * @param scale defines the scale factor\n     * @param result defines the matrix to store the result\n     * @returns the current matrix\n     */\n    Matrix.prototype.scaleToRef = function (scale, result) {\n        for (var index = 0; index < 16; index++) {\n            result._m[index] = this._m[index] * scale;\n        }\n        result.markAsUpdated();\n        return this;\n    };\n    /**\n     * Scale the current matrix values by a factor and add the result to a given matrix\n     * @param scale defines the scale factor\n     * @param result defines the Matrix to store the result\n     * @returns the current matrix\n     */\n    Matrix.prototype.scaleAndAddToRef = function (scale, result) {\n        for (var index = 0; index < 16; index++) {\n            result._m[index] += this._m[index] * scale;\n        }\n        result.markAsUpdated();\n        return this;\n    };\n    /**\n     * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).\n     * @param ref matrix to store the result\n     */\n    Matrix.prototype.toNormalMatrix = function (ref) {\n        var tmp = MathTmp.Matrix[0];\n        this.invertToRef(tmp);\n        tmp.transposeToRef(ref);\n        var m = ref._m;\n        Matrix.FromValuesToRef(m[0], m[1], m[2], 0.0, m[4], m[5], m[6], 0.0, m[8], m[9], m[10], 0.0, 0.0, 0.0, 0.0, 1.0, ref);\n    };\n    /**\n     * Gets only rotation part of the current matrix\n     * @returns a new matrix sets to the extracted rotation matrix from the current one\n     */\n    Matrix.prototype.getRotationMatrix = function () {\n        var result = new Matrix();\n        this.getRotationMatrixToRef(result);\n        return result;\n    };\n    /**\n     * Extracts the rotation matrix from the current one and sets it as the given \"result\"\n     * @param result defines the target matrix to store data to\n     * @returns the current matrix\n     */\n    Matrix.prototype.getRotationMatrixToRef = function (result) {\n        var scale = MathTmp.Vector3[0];\n        if (!this.decompose(scale)) {\n            Matrix.IdentityToRef(result);\n            return this;\n        }\n        var m = this._m;\n        var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;\n        Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        return this;\n    };\n    /**\n     * Toggles model matrix from being right handed to left handed in place and vice versa\n     */\n    Matrix.prototype.toggleModelMatrixHandInPlace = function () {\n        var m = this._m;\n        m[2] *= -1;\n        m[6] *= -1;\n        m[8] *= -1;\n        m[9] *= -1;\n        m[14] *= -1;\n        this.markAsUpdated();\n    };\n    /**\n     * Toggles projection matrix from being right handed to left handed in place and vice versa\n     */\n    Matrix.prototype.toggleProjectionMatrixHandInPlace = function () {\n        var m = this._m;\n        m[8] *= -1;\n        m[9] *= -1;\n        m[10] *= -1;\n        m[11] *= -1;\n        this.markAsUpdated();\n    };\n    // Statics\n    /**\n     * Creates a matrix from an array\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @returns a new Matrix set from the starting index of the given array\n     */\n    Matrix.FromArray = function (array, offset) {\n        if (offset === void 0) { offset = 0; }\n        var result = new Matrix();\n        Matrix.FromArrayToRef(array, offset, result);\n        return result;\n    };\n    /**\n     * Copy the content of an array into a given matrix\n     * @param array defines the source array\n     * @param offset defines an offset in the source array\n     * @param result defines the target matrix\n     */\n    Matrix.FromArrayToRef = function (array, offset, result) {\n        for (var index = 0; index < 16; index++) {\n            result._m[index] = array[index + offset];\n        }\n        result.markAsUpdated();\n    };\n    /**\n     * Stores an array into a matrix after having multiplied each component by a given factor\n     * @param array defines the source array\n     * @param offset defines the offset in the source array\n     * @param scale defines the scaling factor\n     * @param result defines the target matrix\n     */\n    Matrix.FromFloat32ArrayToRefScaled = function (array, offset, scale, result) {\n        for (var index = 0; index < 16; index++) {\n            result._m[index] = array[index + offset] * scale;\n        }\n        result.markAsUpdated();\n    };\n    Object.defineProperty(Matrix, \"IdentityReadOnly\", {\n        /**\n         * Gets an identity matrix that must not be updated\n         */\n        get: function () {\n            return Matrix._IdentityReadOnly;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Stores a list of values (16) inside a given matrix\n     * @param initialM11 defines 1st value of 1st row\n     * @param initialM12 defines 2nd value of 1st row\n     * @param initialM13 defines 3rd value of 1st row\n     * @param initialM14 defines 4th value of 1st row\n     * @param initialM21 defines 1st value of 2nd row\n     * @param initialM22 defines 2nd value of 2nd row\n     * @param initialM23 defines 3rd value of 2nd row\n     * @param initialM24 defines 4th value of 2nd row\n     * @param initialM31 defines 1st value of 3rd row\n     * @param initialM32 defines 2nd value of 3rd row\n     * @param initialM33 defines 3rd value of 3rd row\n     * @param initialM34 defines 4th value of 3rd row\n     * @param initialM41 defines 1st value of 4th row\n     * @param initialM42 defines 2nd value of 4th row\n     * @param initialM43 defines 3rd value of 4th row\n     * @param initialM44 defines 4th value of 4th row\n     * @param result defines the target matrix\n     */\n    Matrix.FromValuesToRef = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {\n        var m = result._m;\n        m[0] = initialM11;\n        m[1] = initialM12;\n        m[2] = initialM13;\n        m[3] = initialM14;\n        m[4] = initialM21;\n        m[5] = initialM22;\n        m[6] = initialM23;\n        m[7] = initialM24;\n        m[8] = initialM31;\n        m[9] = initialM32;\n        m[10] = initialM33;\n        m[11] = initialM34;\n        m[12] = initialM41;\n        m[13] = initialM42;\n        m[14] = initialM43;\n        m[15] = initialM44;\n        result.markAsUpdated();\n    };\n    /**\n     * Creates new matrix from a list of values (16)\n     * @param initialM11 defines 1st value of 1st row\n     * @param initialM12 defines 2nd value of 1st row\n     * @param initialM13 defines 3rd value of 1st row\n     * @param initialM14 defines 4th value of 1st row\n     * @param initialM21 defines 1st value of 2nd row\n     * @param initialM22 defines 2nd value of 2nd row\n     * @param initialM23 defines 3rd value of 2nd row\n     * @param initialM24 defines 4th value of 2nd row\n     * @param initialM31 defines 1st value of 3rd row\n     * @param initialM32 defines 2nd value of 3rd row\n     * @param initialM33 defines 3rd value of 3rd row\n     * @param initialM34 defines 4th value of 3rd row\n     * @param initialM41 defines 1st value of 4th row\n     * @param initialM42 defines 2nd value of 4th row\n     * @param initialM43 defines 3rd value of 4th row\n     * @param initialM44 defines 4th value of 4th row\n     * @returns the new matrix\n     */\n    Matrix.FromValues = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {\n        var result = new Matrix();\n        var m = result._m;\n        m[0] = initialM11;\n        m[1] = initialM12;\n        m[2] = initialM13;\n        m[3] = initialM14;\n        m[4] = initialM21;\n        m[5] = initialM22;\n        m[6] = initialM23;\n        m[7] = initialM24;\n        m[8] = initialM31;\n        m[9] = initialM32;\n        m[10] = initialM33;\n        m[11] = initialM34;\n        m[12] = initialM41;\n        m[13] = initialM42;\n        m[14] = initialM43;\n        m[15] = initialM44;\n        result.markAsUpdated();\n        return result;\n    };\n    /**\n     * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n     * @param scale defines the scale vector3\n     * @param rotation defines the rotation quaternion\n     * @param translation defines the translation vector3\n     * @returns a new matrix\n     */\n    Matrix.Compose = function (scale, rotation, translation) {\n        var result = new Matrix();\n        Matrix.ComposeToRef(scale, rotation, translation, result);\n        return result;\n    };\n    /**\n     * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n     * @param scale defines the scale vector3\n     * @param rotation defines the rotation quaternion\n     * @param translation defines the translation vector3\n     * @param result defines the target matrix\n     */\n    Matrix.ComposeToRef = function (scale, rotation, translation, result) {\n        var m = result._m;\n        var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;\n        var x2 = x + x, y2 = y + y, z2 = z + z;\n        var xx = x * x2, xy = x * y2, xz = x * z2;\n        var yy = y * y2, yz = y * z2, zz = z * z2;\n        var wx = w * x2, wy = w * y2, wz = w * z2;\n        var sx = scale._x, sy = scale._y, sz = scale._z;\n        m[0] = (1 - (yy + zz)) * sx;\n        m[1] = (xy + wz) * sx;\n        m[2] = (xz - wy) * sx;\n        m[3] = 0;\n        m[4] = (xy - wz) * sy;\n        m[5] = (1 - (xx + zz)) * sy;\n        m[6] = (yz + wx) * sy;\n        m[7] = 0;\n        m[8] = (xz + wy) * sz;\n        m[9] = (yz - wx) * sz;\n        m[10] = (1 - (xx + yy)) * sz;\n        m[11] = 0;\n        m[12] = translation._x;\n        m[13] = translation._y;\n        m[14] = translation._z;\n        m[15] = 1;\n        result.markAsUpdated();\n    };\n    /**\n     * Creates a new identity matrix\n     * @returns a new identity matrix\n     */\n    Matrix.Identity = function () {\n        var identity = Matrix.FromValues(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n        identity._updateIdentityStatus(true);\n        return identity;\n    };\n    /**\n     * Creates a new identity matrix and stores the result in a given matrix\n     * @param result defines the target matrix\n     */\n    Matrix.IdentityToRef = function (result) {\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(true);\n    };\n    /**\n     * Creates a new zero matrix\n     * @returns a new zero matrix\n     */\n    Matrix.Zero = function () {\n        var zero = Matrix.FromValues(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n        zero._updateIdentityStatus(false);\n        return zero;\n    };\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the X axis\n     * @param angle defines the angle (in radians) to use\n     * @return the new matrix\n     */\n    Matrix.RotationX = function (angle) {\n        var result = new Matrix();\n        Matrix.RotationXToRef(angle, result);\n        return result;\n    };\n    /**\n     * Creates a new matrix as the invert of a given matrix\n     * @param source defines the source matrix\n     * @returns the new matrix\n     */\n    Matrix.Invert = function (source) {\n        var result = new Matrix();\n        source.invertToRef(result);\n        return result;\n    };\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the X axis and stores it in a given matrix\n     * @param angle defines the angle (in radians) to use\n     * @param result defines the target matrix\n     */\n    Matrix.RotationXToRef = function (angle, result) {\n        var s = Math.sin(angle);\n        var c = Math.cos(angle);\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(c === 1 && s === 0);\n    };\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis\n     * @param angle defines the angle (in radians) to use\n     * @return the new matrix\n     */\n    Matrix.RotationY = function (angle) {\n        var result = new Matrix();\n        Matrix.RotationYToRef(angle, result);\n        return result;\n    };\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis and stores it in a given matrix\n     * @param angle defines the angle (in radians) to use\n     * @param result defines the target matrix\n     */\n    Matrix.RotationYToRef = function (angle, result) {\n        var s = Math.sin(angle);\n        var c = Math.cos(angle);\n        Matrix.FromValuesToRef(c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(c === 1 && s === 0);\n    };\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis\n     * @param angle defines the angle (in radians) to use\n     * @return the new matrix\n     */\n    Matrix.RotationZ = function (angle) {\n        var result = new Matrix();\n        Matrix.RotationZToRef(angle, result);\n        return result;\n    };\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis and stores it in a given matrix\n     * @param angle defines the angle (in radians) to use\n     * @param result defines the target matrix\n     */\n    Matrix.RotationZToRef = function (angle, result) {\n        var s = Math.sin(angle);\n        var c = Math.cos(angle);\n        Matrix.FromValuesToRef(c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(c === 1 && s === 0);\n    };\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the given axis\n     * @param axis defines the axis to use\n     * @param angle defines the angle (in radians) to use\n     * @return the new matrix\n     */\n    Matrix.RotationAxis = function (axis, angle) {\n        var result = new Matrix();\n        Matrix.RotationAxisToRef(axis, angle, result);\n        return result;\n    };\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the given axis and stores it in a given matrix\n     * @param axis defines the axis to use\n     * @param angle defines the angle (in radians) to use\n     * @param result defines the target matrix\n     */\n    Matrix.RotationAxisToRef = function (axis, angle, result) {\n        var s = Math.sin(-angle);\n        var c = Math.cos(-angle);\n        var c1 = 1 - c;\n        axis.normalize();\n        var m = result._m;\n        m[0] = axis._x * axis._x * c1 + c;\n        m[1] = axis._x * axis._y * c1 - axis._z * s;\n        m[2] = axis._x * axis._z * c1 + axis._y * s;\n        m[3] = 0.0;\n        m[4] = axis._y * axis._x * c1 + axis._z * s;\n        m[5] = axis._y * axis._y * c1 + c;\n        m[6] = axis._y * axis._z * c1 - axis._x * s;\n        m[7] = 0.0;\n        m[8] = axis._z * axis._x * c1 - axis._y * s;\n        m[9] = axis._z * axis._y * c1 + axis._x * s;\n        m[10] = axis._z * axis._z * c1 + c;\n        m[11] = 0.0;\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n        result.markAsUpdated();\n    };\n    /**\n     * Takes normalised vectors and returns a rotation matrix to align \"from\" with \"to\".\n     * Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm\n     * @param from defines the vector to align\n     * @param to defines the vector to align to\n     * @param result defines the target matrix\n     */\n    Matrix.RotationAlignToRef = function (from, to, result) {\n        var c = Vector3.Dot(to, from);\n        var m = result._m;\n        if (c < -1 + Epsilon) {\n            // from and to are colinear and opposite direction.\n            // compute a PI rotation on Z axis\n            m[0] = -1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = -1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n        }\n        else {\n            var v = Vector3.Cross(to, from);\n            var k = 1 / (1 + c);\n            m[0] = v._x * v._x * k + c;\n            m[1] = v._y * v._x * k - v._z;\n            m[2] = v._z * v._x * k + v._y;\n            m[3] = 0;\n            m[4] = v._x * v._y * k + v._z;\n            m[5] = v._y * v._y * k + c;\n            m[6] = v._z * v._y * k - v._x;\n            m[7] = 0;\n            m[8] = v._x * v._z * k - v._y;\n            m[9] = v._y * v._z * k + v._x;\n            m[10] = v._z * v._z * k + c;\n            m[11] = 0;\n        }\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n        result.markAsUpdated();\n    };\n    /**\n     * Creates a rotation matrix\n     * @param yaw defines the yaw angle in radians (Y axis)\n     * @param pitch defines the pitch angle in radians (X axis)\n     * @param roll defines the roll angle in radians (Z axis)\n     * @returns the new rotation matrix\n     */\n    Matrix.RotationYawPitchRoll = function (yaw, pitch, roll) {\n        var result = new Matrix();\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\n        return result;\n    };\n    /**\n     * Creates a rotation matrix and stores it in a given matrix\n     * @param yaw defines the yaw angle in radians (Y axis)\n     * @param pitch defines the pitch angle in radians (X axis)\n     * @param roll defines the roll angle in radians (Z axis)\n     * @param result defines the target matrix\n     */\n    Matrix.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);\n        MathTmp.Quaternion[0].toRotationMatrix(result);\n    };\n    /**\n     * Creates a scaling matrix\n     * @param x defines the scale factor on X axis\n     * @param y defines the scale factor on Y axis\n     * @param z defines the scale factor on Z axis\n     * @returns the new matrix\n     */\n    Matrix.Scaling = function (x, y, z) {\n        var result = new Matrix();\n        Matrix.ScalingToRef(x, y, z, result);\n        return result;\n    };\n    /**\n     * Creates a scaling matrix and stores it in a given matrix\n     * @param x defines the scale factor on X axis\n     * @param y defines the scale factor on Y axis\n     * @param z defines the scale factor on Z axis\n     * @param result defines the target matrix\n     */\n    Matrix.ScalingToRef = function (x, y, z, result) {\n        Matrix.FromValuesToRef(x, 0.0, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 0.0, z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(x === 1 && y === 1 && z === 1);\n    };\n    /**\n     * Creates a translation matrix\n     * @param x defines the translation on X axis\n     * @param y defines the translation on Y axis\n     * @param z defines the translationon Z axis\n     * @returns the new matrix\n     */\n    Matrix.Translation = function (x, y, z) {\n        var result = new Matrix();\n        Matrix.TranslationToRef(x, y, z, result);\n        return result;\n    };\n    /**\n     * Creates a translation matrix and stores it in a given matrix\n     * @param x defines the translation on X axis\n     * @param y defines the translation on Y axis\n     * @param z defines the translationon Z axis\n     * @param result defines the target matrix\n     */\n    Matrix.TranslationToRef = function (x, y, z, result) {\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0, result);\n        result._updateIdentityStatus(x === 0 && y === 0 && z === 0);\n    };\n    /**\n     * Returns a new Matrix whose values are the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n     * @param startValue defines the start value\n     * @param endValue defines the end value\n     * @param gradient defines the gradient factor\n     * @returns the new matrix\n     */\n    Matrix.Lerp = function (startValue, endValue, gradient) {\n        var result = new Matrix();\n        Matrix.LerpToRef(startValue, endValue, gradient, result);\n        return result;\n    };\n    /**\n     * Set the given matrix \"result\" as the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n     * @param startValue defines the start value\n     * @param endValue defines the end value\n     * @param gradient defines the gradient factor\n     * @param result defines the Matrix object where to store data\n     */\n    Matrix.LerpToRef = function (startValue, endValue, gradient, result) {\n        var resultM = result._m;\n        var startM = startValue.m;\n        var endM = endValue.m;\n        for (var index = 0; index < 16; index++) {\n            resultM[index] = startM[index] * (1.0 - gradient) + endM[index] * gradient;\n        }\n        result.markAsUpdated();\n    };\n    /**\n     * Builds a new matrix whose values are computed by:\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n     * @param startValue defines the first matrix\n     * @param endValue defines the second matrix\n     * @param gradient defines the gradient between the two matrices\n     * @returns the new matrix\n     */\n    Matrix.DecomposeLerp = function (startValue, endValue, gradient) {\n        var result = new Matrix();\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n        return result;\n    };\n    /**\n     * Update a matrix to values which are computed by:\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n     * @param startValue defines the first matrix\n     * @param endValue defines the second matrix\n     * @param gradient defines the gradient between the two matrices\n     * @param result defines the target matrix\n     */\n    Matrix.DecomposeLerpToRef = function (startValue, endValue, gradient, result) {\n        var startScale = MathTmp.Vector3[0];\n        var startRotation = MathTmp.Quaternion[0];\n        var startTranslation = MathTmp.Vector3[1];\n        startValue.decompose(startScale, startRotation, startTranslation);\n        var endScale = MathTmp.Vector3[2];\n        var endRotation = MathTmp.Quaternion[1];\n        var endTranslation = MathTmp.Vector3[3];\n        endValue.decompose(endScale, endRotation, endTranslation);\n        var resultScale = MathTmp.Vector3[4];\n        Vector3.LerpToRef(startScale, endScale, gradient, resultScale);\n        var resultRotation = MathTmp.Quaternion[2];\n        Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);\n        var resultTranslation = MathTmp.Vector3[5];\n        Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);\n        Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);\n    };\n    /**\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\n     * This function works in left handed mode\n     * @param eye defines the final position of the entity\n     * @param target defines where the entity should look at\n     * @param up defines the up vector for the entity\n     * @returns the new matrix\n     */\n    Matrix.LookAtLH = function (eye, target, up) {\n        var result = new Matrix();\n        Matrix.LookAtLHToRef(eye, target, up, result);\n        return result;\n    };\n    /**\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\n     * This function works in left handed mode\n     * @param eye defines the final position of the entity\n     * @param target defines where the entity should look at\n     * @param up defines the up vector for the entity\n     * @param result defines the target matrix\n     */\n    Matrix.LookAtLHToRef = function (eye, target, up, result) {\n        var xAxis = MathTmp.Vector3[0];\n        var yAxis = MathTmp.Vector3[1];\n        var zAxis = MathTmp.Vector3[2];\n        // Z axis\n        target.subtractToRef(eye, zAxis);\n        zAxis.normalize();\n        // X axis\n        Vector3.CrossToRef(up, zAxis, xAxis);\n        var xSquareLength = xAxis.lengthSquared();\n        if (xSquareLength === 0) {\n            xAxis.x = 1.0;\n        }\n        else {\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n        }\n        // Y axis\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\n        yAxis.normalize();\n        // Eye angles\n        var ex = -Vector3.Dot(xAxis, eye);\n        var ey = -Vector3.Dot(yAxis, eye);\n        var ez = -Vector3.Dot(zAxis, eye);\n        Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\n    };\n    /**\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\n     * This function works in right handed mode\n     * @param eye defines the final position of the entity\n     * @param target defines where the entity should look at\n     * @param up defines the up vector for the entity\n     * @returns the new matrix\n     */\n    Matrix.LookAtRH = function (eye, target, up) {\n        var result = new Matrix();\n        Matrix.LookAtRHToRef(eye, target, up, result);\n        return result;\n    };\n    /**\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\n     * This function works in right handed mode\n     * @param eye defines the final position of the entity\n     * @param target defines where the entity should look at\n     * @param up defines the up vector for the entity\n     * @param result defines the target matrix\n     */\n    Matrix.LookAtRHToRef = function (eye, target, up, result) {\n        var xAxis = MathTmp.Vector3[0];\n        var yAxis = MathTmp.Vector3[1];\n        var zAxis = MathTmp.Vector3[2];\n        // Z axis\n        eye.subtractToRef(target, zAxis);\n        zAxis.normalize();\n        // X axis\n        Vector3.CrossToRef(up, zAxis, xAxis);\n        var xSquareLength = xAxis.lengthSquared();\n        if (xSquareLength === 0) {\n            xAxis.x = 1.0;\n        }\n        else {\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n        }\n        // Y axis\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\n        yAxis.normalize();\n        // Eye angles\n        var ex = -Vector3.Dot(xAxis, eye);\n        var ey = -Vector3.Dot(yAxis, eye);\n        var ez = -Vector3.Dot(zAxis, eye);\n        Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0.0, xAxis._y, yAxis._y, zAxis._y, 0.0, xAxis._z, yAxis._z, zAxis._z, 0.0, ex, ey, ez, 1.0, result);\n    };\n    /**\n     * Gets a new rotation matrix used to rotate an entity so as it looks in the direction specified by forward from the eye position, the up direction being oriented like \"up\".\n     * This function works in left handed mode\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @returns the new matrix\n     */\n    Matrix.LookDirectionLH = function (forward, up) {\n        var result = new Matrix();\n        Matrix.LookDirectionLHToRef(forward, up, result);\n        return result;\n    };\n    /**\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks in the direction of forward, the up direction being oriented like \"up\".\n     * This function works in left handed mode\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @param result defines the target matrix\n     */\n    Matrix.LookDirectionLHToRef = function (forward, up, result) {\n        var back = MathTmp.Vector3[0];\n        back.copyFrom(forward);\n        back.scaleInPlace(-1);\n        var left = MathTmp.Vector3[1];\n        Vector3.CrossToRef(up, back, left);\n        // Generate the rotation matrix.\n        Matrix.FromValuesToRef(left._x, left._y, left._z, 0.0, up._x, up._y, up._z, 0.0, back._x, back._y, back._z, 0.0, 0, 0, 0, 1.0, result);\n    };\n    /**\n     * Gets a new rotation matrix used to rotate an entity so as it looks in the direction specified by forward from the eye position, the up Vector3 being oriented like \"up\".\n     * This function works in right handed mode\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @returns the new matrix\n     */\n    Matrix.LookDirectionRH = function (forward, up) {\n        var result = new Matrix();\n        Matrix.LookDirectionRHToRef(forward, up, result);\n        return result;\n    };\n    /**\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks in the direction of forward, the up vector3 being oriented like \"up\".\n     * This function works in right handed mode\n     * @param forward defines the forward direction - Must be normalized and orthogonal to up.\n     * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.\n     * @param result defines the target matrix\n     */\n    Matrix.LookDirectionRHToRef = function (forward, up, result) {\n        var right = MathTmp.Vector3[2];\n        Vector3.CrossToRef(up, forward, right);\n        // Generate the rotation matrix.\n        Matrix.FromValuesToRef(right._x, right._y, right._z, 0.0, up._x, up._y, up._z, 0.0, forward._x, forward._y, forward._z, 0.0, 0, 0, 0, 1.0, result);\n    };\n    /**\n     * Create a left-handed orthographic projection matrix\n     * @param width defines the viewport width\n     * @param height defines the viewport height\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @returns a new matrix as a left-handed orthographic projection matrix\n     */\n    Matrix.OrthoLH = function (width, height, znear, zfar, halfZRange) {\n        var matrix = new Matrix();\n        Matrix.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);\n        return matrix;\n    };\n    /**\n     * Store a left-handed orthographic projection to a given matrix\n     * @param width defines the viewport width\n     * @param height defines the viewport height\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param result defines the target matrix\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     */\n    Matrix.OrthoLHToRef = function (width, height, znear, zfar, result, halfZRange) {\n        var n = znear;\n        var f = zfar;\n        var a = 2.0 / width;\n        var b = 2.0 / height;\n        var c = 2.0 / (f - n);\n        var d = -(f + n) / (f - n);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, 0.0, 0.0, d, 1.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);\n    };\n    /**\n     * Create a left-handed orthographic projection matrix\n     * @param left defines the viewport left coordinate\n     * @param right defines the viewport right coordinate\n     * @param bottom defines the viewport bottom coordinate\n     * @param top defines the viewport top coordinate\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @returns a new matrix as a left-handed orthographic projection matrix\n     */\n    Matrix.OrthoOffCenterLH = function (left, right, bottom, top, znear, zfar, halfZRange) {\n        var matrix = new Matrix();\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);\n        return matrix;\n    };\n    /**\n     * Stores a left-handed orthographic projection into a given matrix\n     * @param left defines the viewport left coordinate\n     * @param right defines the viewport right coordinate\n     * @param bottom defines the viewport bottom coordinate\n     * @param top defines the viewport top coordinate\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param result defines the target matrix\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     */\n    Matrix.OrthoOffCenterLHToRef = function (left, right, bottom, top, znear, zfar, result, halfZRange) {\n        var n = znear;\n        var f = zfar;\n        var a = 2.0 / (right - left);\n        var b = 2.0 / (top - bottom);\n        var c = 2.0 / (f - n);\n        var d = -(f + n) / (f - n);\n        var i0 = (left + right) / (left - right);\n        var i1 = (top + bottom) / (bottom - top);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, i0, i1, d, 1.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result.markAsUpdated();\n    };\n    /**\n     * Creates a right-handed orthographic projection matrix\n     * @param left defines the viewport left coordinate\n     * @param right defines the viewport right coordinate\n     * @param bottom defines the viewport bottom coordinate\n     * @param top defines the viewport top coordinate\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @returns a new matrix as a right-handed orthographic projection matrix\n     */\n    Matrix.OrthoOffCenterRH = function (left, right, bottom, top, znear, zfar, halfZRange) {\n        var matrix = new Matrix();\n        Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);\n        return matrix;\n    };\n    /**\n     * Stores a right-handed orthographic projection into a given matrix\n     * @param left defines the viewport left coordinate\n     * @param right defines the viewport right coordinate\n     * @param bottom defines the viewport bottom coordinate\n     * @param top defines the viewport top coordinate\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param result defines the target matrix\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     */\n    Matrix.OrthoOffCenterRHToRef = function (left, right, bottom, top, znear, zfar, result, halfZRange) {\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);\n        result._m[10] *= -1; // No need to call markAsUpdated as previous function already called it and let _isIdentityDirty to true\n    };\n    /**\n     * Creates a left-handed perspective projection matrix\n     * @param width defines the viewport width\n     * @param height defines the viewport height\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @returns a new matrix as a left-handed perspective projection matrix\n     */\n    Matrix.PerspectiveLH = function (width, height, znear, zfar, halfZRange, projectionPlaneTilt) {\n        if (projectionPlaneTilt === void 0) { projectionPlaneTilt = 0; }\n        var matrix = new Matrix();\n        var n = znear;\n        var f = zfar;\n        var a = (2.0 * n) / width;\n        var b = (2.0 * n) / height;\n        var c = (f + n) / (f - n);\n        var d = (-2.0 * f * n) / (f - n);\n        var rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, matrix);\n        if (halfZRange) {\n            matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);\n        }\n        matrix._updateIdentityStatus(false);\n        return matrix;\n    };\n    /**\n     * Creates a left-handed perspective projection matrix\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n     * @returns a new matrix as a left-handed perspective projection matrix\n     */\n    Matrix.PerspectiveFovLH = function (fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {\n        if (projectionPlaneTilt === void 0) { projectionPlaneTilt = 0; }\n        if (reverseDepthBufferMode === void 0) { reverseDepthBufferMode = false; }\n        var matrix = new Matrix();\n        Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);\n        return matrix;\n    };\n    /**\n     * Stores a left-handed perspective projection into a given matrix\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n     * @param result defines the target matrix\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n     */\n    Matrix.PerspectiveFovLHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {\n        if (isVerticalFovFixed === void 0) { isVerticalFovFixed = true; }\n        if (projectionPlaneTilt === void 0) { projectionPlaneTilt = 0; }\n        if (reverseDepthBufferMode === void 0) { reverseDepthBufferMode = false; }\n        var n = znear;\n        var f = zfar;\n        var t = 1.0 / Math.tan(fov * 0.5);\n        var a = isVerticalFovFixed ? t / aspect : t;\n        var b = isVerticalFovFixed ? t : t * aspect;\n        var c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;\n        var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? (-2.0 * f * n) / (f - n) : -2 * n;\n        var rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(false);\n    };\n    /**\n     * Stores a left-handed perspective projection into a given matrix with depth reversed\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar not used as infinity is used as far clip\n     * @param result defines the target matrix\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     */\n    Matrix.PerspectiveFovReverseLHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {\n        if (isVerticalFovFixed === void 0) { isVerticalFovFixed = true; }\n        if (projectionPlaneTilt === void 0) { projectionPlaneTilt = 0; }\n        var t = 1.0 / Math.tan(fov * 0.5);\n        var a = isVerticalFovFixed ? t / aspect : t;\n        var b = isVerticalFovFixed ? t : t * aspect;\n        var rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, -znear, 1.0, 0.0, 0.0, 1.0, 0.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(false);\n    };\n    /**\n     * Creates a right-handed perspective projection matrix\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n     * @returns a new matrix as a right-handed perspective projection matrix\n     */\n    Matrix.PerspectiveFovRH = function (fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {\n        if (projectionPlaneTilt === void 0) { projectionPlaneTilt = 0; }\n        if (reverseDepthBufferMode === void 0) { reverseDepthBufferMode = false; }\n        var matrix = new Matrix();\n        Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);\n        return matrix;\n    };\n    /**\n     * Stores a right-handed perspective projection into a given matrix\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane. If 0, assume we are in \"infinite zfar\" mode\n     * @param result defines the target matrix\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)\n     */\n    Matrix.PerspectiveFovRHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {\n        //alternatively this could be expressed as:\n        //    m = PerspectiveFovLHToRef\n        //    m[10] *= -1.0;\n        //    m[11] *= -1.0;\n        if (isVerticalFovFixed === void 0) { isVerticalFovFixed = true; }\n        if (projectionPlaneTilt === void 0) { projectionPlaneTilt = 0; }\n        if (reverseDepthBufferMode === void 0) { reverseDepthBufferMode = false; }\n        var n = znear;\n        var f = zfar;\n        var t = 1.0 / Math.tan(fov * 0.5);\n        var a = isVerticalFovFixed ? t / aspect : t;\n        var b = isVerticalFovFixed ? t : t * aspect;\n        var c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;\n        var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? (-2 * f * n) / (f - n) : -2 * n;\n        var rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, c, -1.0, 0.0, 0.0, d, 0.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(false);\n    };\n    /**\n     * Stores a right-handed perspective projection into a given matrix\n     * @param fov defines the horizontal field of view\n     * @param aspect defines the aspect ratio\n     * @param znear defines the near clip plane\n     * @param zfar not used as infinity is used as far clip\n     * @param result defines the target matrix\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     */\n    Matrix.PerspectiveFovReverseRHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {\n        if (isVerticalFovFixed === void 0) { isVerticalFovFixed = true; }\n        if (projectionPlaneTilt === void 0) { projectionPlaneTilt = 0; }\n        var t = 1.0 / Math.tan(fov * 0.5);\n        var a = isVerticalFovFixed ? t / aspect : t;\n        var b = isVerticalFovFixed ? t : t * aspect;\n        var rot = Math.tan(projectionPlaneTilt);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, rot, 0.0, 0.0, -znear, -1.0, 0.0, 0.0, -1.0, 0.0, result);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result._updateIdentityStatus(false);\n    };\n    /**\n     * Stores a perspective projection for WebVR info a given matrix\n     * @param fov defines the field of view\n     * @param fov.upDegrees\n     * @param fov.downDegrees\n     * @param fov.leftDegrees\n     * @param fov.rightDegrees\n     * @param znear defines the near clip plane\n     * @param zfar defines the far clip plane\n     * @param result defines the target matrix\n     * @param rightHanded defines if the matrix must be in right-handed mode (false by default)\n     * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)\n     * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)\n     */\n    Matrix.PerspectiveFovWebVRToRef = function (fov, znear, zfar, result, rightHanded, halfZRange, projectionPlaneTilt) {\n        if (rightHanded === void 0) { rightHanded = false; }\n        if (projectionPlaneTilt === void 0) { projectionPlaneTilt = 0; }\n        var rightHandedFactor = rightHanded ? -1 : 1;\n        var upTan = Math.tan((fov.upDegrees * Math.PI) / 180.0);\n        var downTan = Math.tan((fov.downDegrees * Math.PI) / 180.0);\n        var leftTan = Math.tan((fov.leftDegrees * Math.PI) / 180.0);\n        var rightTan = Math.tan((fov.rightDegrees * Math.PI) / 180.0);\n        var xScale = 2.0 / (leftTan + rightTan);\n        var yScale = 2.0 / (upTan + downTan);\n        var rot = Math.tan(projectionPlaneTilt);\n        var m = result._m;\n        m[0] = xScale;\n        m[1] = m[2] = m[3] = m[4] = 0.0;\n        m[5] = yScale;\n        m[6] = 0.0;\n        m[7] = rot;\n        m[8] = (leftTan - rightTan) * xScale * 0.5;\n        m[9] = -((upTan - downTan) * yScale * 0.5);\n        m[10] = -zfar / (znear - zfar);\n        m[11] = 1.0 * rightHandedFactor;\n        m[12] = m[13] = m[15] = 0.0;\n        m[14] = -(2.0 * zfar * znear) / (zfar - znear);\n        if (halfZRange) {\n            result.multiplyToRef(mtxConvertNDCToHalfZRange, result);\n        }\n        result.markAsUpdated();\n    };\n    /**\n     * Computes a complete transformation matrix\n     * @param viewport defines the viewport to use\n     * @param world defines the world matrix\n     * @param view defines the view matrix\n     * @param projection defines the projection matrix\n     * @param zmin defines the near clip plane\n     * @param zmax defines the far clip plane\n     * @returns the transformation matrix\n     */\n    Matrix.GetFinalMatrix = function (viewport, world, view, projection, zmin, zmax) {\n        var cw = viewport.width;\n        var ch = viewport.height;\n        var cx = viewport.x;\n        var cy = viewport.y;\n        var viewportMatrix = Matrix.FromValues(cw / 2.0, 0.0, 0.0, 0.0, 0.0, -ch / 2.0, 0.0, 0.0, 0.0, 0.0, zmax - zmin, 0.0, cx + cw / 2.0, ch / 2.0 + cy, zmin, 1.0);\n        var matrix = MathTmp.Matrix[0];\n        world.multiplyToRef(view, matrix);\n        matrix.multiplyToRef(projection, matrix);\n        return matrix.multiply(viewportMatrix);\n    };\n    /**\n     * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array\n     * @param matrix defines the matrix to use\n     * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix\n     */\n    Matrix.GetAsMatrix2x2 = function (matrix) {\n        var m = matrix.m;\n        var arr = [m[0], m[1], m[4], m[5]];\n        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\n    };\n    /**\n     * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array\n     * @param matrix defines the matrix to use\n     * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix\n     */\n    Matrix.GetAsMatrix3x3 = function (matrix) {\n        var m = matrix.m;\n        var arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];\n        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);\n    };\n    /**\n     * Compute the transpose of a given matrix\n     * @param matrix defines the matrix to transpose\n     * @returns the new matrix\n     */\n    Matrix.Transpose = function (matrix) {\n        var result = new Matrix();\n        Matrix.TransposeToRef(matrix, result);\n        return result;\n    };\n    /**\n     * Compute the transpose of a matrix and store it in a target matrix\n     * @param matrix defines the matrix to transpose\n     * @param result defines the target matrix\n     */\n    Matrix.TransposeToRef = function (matrix, result) {\n        var rm = result._m;\n        var mm = matrix.m;\n        rm[0] = mm[0];\n        rm[1] = mm[4];\n        rm[2] = mm[8];\n        rm[3] = mm[12];\n        rm[4] = mm[1];\n        rm[5] = mm[5];\n        rm[6] = mm[9];\n        rm[7] = mm[13];\n        rm[8] = mm[2];\n        rm[9] = mm[6];\n        rm[10] = mm[10];\n        rm[11] = mm[14];\n        rm[12] = mm[3];\n        rm[13] = mm[7];\n        rm[14] = mm[11];\n        rm[15] = mm[15];\n        result.markAsUpdated();\n        // identity-ness does not change when transposing\n        result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);\n    };\n    /**\n     * Computes a reflection matrix from a plane\n     * @param plane defines the reflection plane\n     * @returns a new matrix\n     */\n    Matrix.Reflection = function (plane) {\n        var matrix = new Matrix();\n        Matrix.ReflectionToRef(plane, matrix);\n        return matrix;\n    };\n    /**\n     * Computes a reflection matrix from a plane\n     * @param plane defines the reflection plane\n     * @param result defines the target matrix\n     */\n    Matrix.ReflectionToRef = function (plane, result) {\n        plane.normalize();\n        var x = plane.normal.x;\n        var y = plane.normal.y;\n        var z = plane.normal.z;\n        var temp = -2 * x;\n        var temp2 = -2 * y;\n        var temp3 = -2 * z;\n        Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0.0, temp * y, temp2 * y + 1, temp3 * y, 0.0, temp * z, temp2 * z, temp3 * z + 1, 0.0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1.0, result);\n    };\n    /**\n     * Sets the given matrix as a rotation matrix composed from the 3 left handed axes\n     * @param xaxis defines the value of the 1st axis\n     * @param yaxis defines the value of the 2nd axis\n     * @param zaxis defines the value of the 3rd axis\n     * @param result defines the target matrix\n     */\n    Matrix.FromXYZAxesToRef = function (xaxis, yaxis, zaxis, result) {\n        Matrix.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0.0, yaxis._x, yaxis._y, yaxis._z, 0.0, zaxis._x, zaxis._y, zaxis._z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n    };\n    /**\n     * Creates a rotation matrix from a quaternion and stores it in a target matrix\n     * @param quat defines the quaternion to use\n     * @param result defines the target matrix\n     */\n    Matrix.FromQuaternionToRef = function (quat, result) {\n        var xx = quat._x * quat._x;\n        var yy = quat._y * quat._y;\n        var zz = quat._z * quat._z;\n        var xy = quat._x * quat._y;\n        var zw = quat._z * quat._w;\n        var zx = quat._z * quat._x;\n        var yw = quat._y * quat._w;\n        var yz = quat._y * quat._z;\n        var xw = quat._x * quat._w;\n        result._m[0] = 1.0 - 2.0 * (yy + zz);\n        result._m[1] = 2.0 * (xy + zw);\n        result._m[2] = 2.0 * (zx - yw);\n        result._m[3] = 0.0;\n        result._m[4] = 2.0 * (xy - zw);\n        result._m[5] = 1.0 - 2.0 * (zz + xx);\n        result._m[6] = 2.0 * (yz + xw);\n        result._m[7] = 0.0;\n        result._m[8] = 2.0 * (zx + yw);\n        result._m[9] = 2.0 * (yz - xw);\n        result._m[10] = 1.0 - 2.0 * (yy + xx);\n        result._m[11] = 0.0;\n        result._m[12] = 0.0;\n        result._m[13] = 0.0;\n        result._m[14] = 0.0;\n        result._m[15] = 1.0;\n        result.markAsUpdated();\n    };\n    Matrix._UpdateFlagSeed = 0;\n    Matrix._IdentityReadOnly = Matrix.Identity();\n    return Matrix;\n}());\nexport { Matrix };\n/**\n * @hidden\n * Same as Tmp but not exported to keep it only for math functions to avoid conflicts\n */\nvar MathTmp = /** @class */ (function () {\n    function MathTmp() {\n    }\n    MathTmp.Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);\n    MathTmp.Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);\n    MathTmp.Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);\n    return MathTmp;\n}());\n/**\n * @hidden\n */\nvar TmpVectors = /** @class */ (function () {\n    function TmpVectors() {\n    }\n    TmpVectors.Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero); // 3 temp Vector2 at once should be enough\n    TmpVectors.Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero); // 13 temp Vector3 at once should be enough\n    TmpVectors.Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero); // 3 temp Vector4 at once should be enough\n    TmpVectors.Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero); // 2 temp Quaternion at once should be enough\n    TmpVectors.Matrix = ArrayTools.BuildTuple(8, Matrix.Identity); // 8 temp Matrices at once should be enough\n    return TmpVectors;\n}());\nexport { TmpVectors };\nRegisterClass(\"BABYLON.Vector2\", Vector2);\nRegisterClass(\"BABYLON.Vector3\", Vector3);\nRegisterClass(\"BABYLON.Vector4\", Vector4);\nRegisterClass(\"BABYLON.Matrix\", Matrix);\nvar mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);\n//# sourceMappingURL=math.vector.js.map","import { Vector3, Vector2 } from \"./math.vector.js\";\n/**\n * Contains position and normal vectors for a vertex\n */\nvar PositionNormalVertex = /** @class */ (function () {\n    /**\n     * Creates a PositionNormalVertex\n     * @param position the position of the vertex (defaut: 0,0,0)\n     * @param normal the normal of the vertex (defaut: 0,1,0)\n     */\n    function PositionNormalVertex(\n    /** the position of the vertex (defaut: 0,0,0) */\n    position, \n    /** the normal of the vertex (defaut: 0,1,0) */\n    normal) {\n        if (position === void 0) { position = Vector3.Zero(); }\n        if (normal === void 0) { normal = Vector3.Up(); }\n        this.position = position;\n        this.normal = normal;\n    }\n    /**\n     * Clones the PositionNormalVertex\n     * @returns the cloned PositionNormalVertex\n     */\n    PositionNormalVertex.prototype.clone = function () {\n        return new PositionNormalVertex(this.position.clone(), this.normal.clone());\n    };\n    return PositionNormalVertex;\n}());\nexport { PositionNormalVertex };\n/**\n * Contains position, normal and uv vectors for a vertex\n */\nvar PositionNormalTextureVertex = /** @class */ (function () {\n    /**\n     * Creates a PositionNormalTextureVertex\n     * @param position the position of the vertex (defaut: 0,0,0)\n     * @param normal the normal of the vertex (defaut: 0,1,0)\n     * @param uv the uv of the vertex (default: 0,0)\n     */\n    function PositionNormalTextureVertex(\n    /** the position of the vertex (defaut: 0,0,0) */\n    position, \n    /** the normal of the vertex (defaut: 0,1,0) */\n    normal, \n    /** the uv of the vertex (default: 0,0) */\n    uv) {\n        if (position === void 0) { position = Vector3.Zero(); }\n        if (normal === void 0) { normal = Vector3.Up(); }\n        if (uv === void 0) { uv = Vector2.Zero(); }\n        this.position = position;\n        this.normal = normal;\n        this.uv = uv;\n    }\n    /**\n     * Clones the PositionNormalTextureVertex\n     * @returns the cloned PositionNormalTextureVertex\n     */\n    PositionNormalTextureVertex.prototype.clone = function () {\n        return new PositionNormalTextureVertex(this.position.clone(), this.normal.clone(), this.uv.clone());\n    };\n    return PositionNormalTextureVertex;\n}());\nexport { PositionNormalTextureVertex };\n//# sourceMappingURL=math.vertexFormat.js.map","/**\n * Class used to represent a viewport on screen\n */\nvar Viewport = /** @class */ (function () {\n    /**\n     * Creates a Viewport object located at (x, y) and sized (width, height)\n     * @param x defines viewport left coordinate\n     * @param y defines viewport top coordinate\n     * @param width defines the viewport width\n     * @param height defines the viewport height\n     */\n    function Viewport(\n    /** viewport left coordinate */\n    x, \n    /** viewport top coordinate */\n    y, \n    /**viewport width */\n    width, \n    /** viewport height */\n    height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * Creates a new viewport using absolute sizing (from 0-> width, 0-> height instead of 0->1)\n     * @param renderWidth defines the rendering width\n     * @param renderHeight defines the rendering height\n     * @returns a new Viewport\n     */\n    Viewport.prototype.toGlobal = function (renderWidth, renderHeight) {\n        return new Viewport(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);\n    };\n    /**\n     * Stores absolute viewport value into a target viewport (from 0-> width, 0-> height instead of 0->1)\n     * @param renderWidth defines the rendering width\n     * @param renderHeight defines the rendering height\n     * @param ref defines the target viewport\n     * @returns the current viewport\n     */\n    Viewport.prototype.toGlobalToRef = function (renderWidth, renderHeight, ref) {\n        ref.x = this.x * renderWidth;\n        ref.y = this.y * renderHeight;\n        ref.width = this.width * renderWidth;\n        ref.height = this.height * renderHeight;\n        return this;\n    };\n    /**\n     * Returns a new Viewport copied from the current one\n     * @returns a new Viewport\n     */\n    Viewport.prototype.clone = function () {\n        return new Viewport(this.x, this.y, this.width, this.height);\n    };\n    return Viewport;\n}());\nexport { Viewport };\n//# sourceMappingURL=math.viewport.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { TmpVectors } from \"./math.js\";\n// https://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/\n// http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\n// https://www.ppsloan.org/publications/StupidSH36.pdf\n// http://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n// https://www.ppsloan.org/publications/SHJCGT.pdf\n// https://www.ppsloan.org/publications/shdering.pdf\n// https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics\n// https://patapom.com/blog/SHPortal/\n// https://imdoingitwrong.wordpress.com/2011/04/14/spherical-harmonics-wtf/\n// Using real SH basis:\n//  m>0             m   m\n// y   = sqrt(2) * K * P * cos(m*phi) * cos(theta)\n//  l               l   l\n//\n//  m<0             m   |m|\n// y   = sqrt(2) * K * P * sin(m*phi) * cos(theta)\n//  l               l   l\n//\n//  m=0   0   0\n// y   = K * P * trigono terms\n//  l     l   l\n//\n//  m       (2l + 1)(l - |m|)!\n// K = sqrt(------------------)\n//  l           4pi(l + |m|)!\n//\n// and P by recursion:\n//\n// P00(x) = 1\n// P01(x) = x\n// Pll(x) = (-1^l)(2l - 1)!!(1-x*x)^(1/2)\n//          ((2l - 1)x[Pl-1/m]-(l + m - 1)[Pl-2/m])\n// Plm(x) = ---------------------------------------\n//                         l - m\n// Leaving the trigonometric terms aside we can precompute the constants to :\nvar SH3ylmBasisConstants = [\n    Math.sqrt(1 / (4 * Math.PI)),\n    -Math.sqrt(3 / (4 * Math.PI)),\n    Math.sqrt(3 / (4 * Math.PI)),\n    -Math.sqrt(3 / (4 * Math.PI)),\n    Math.sqrt(15 / (4 * Math.PI)),\n    -Math.sqrt(15 / (4 * Math.PI)),\n    Math.sqrt(5 / (16 * Math.PI)),\n    -Math.sqrt(15 / (4 * Math.PI)),\n    Math.sqrt(15 / (16 * Math.PI)), // l22\n];\n// cm = cos(m * phi)\n// sm = sin(m * phi)\n// {x,y,z} = {cos(phi)sin(theta), sin(phi)sin(theta), cos(theta)}\n// By recursion on using trigo identities:\nvar SH3ylmBasisTrigonometricTerms = [\n    function () { return 1; },\n    function (direction) { return direction.y; },\n    function (direction) { return direction.z; },\n    function (direction) { return direction.x; },\n    function (direction) { return direction.x * direction.y; },\n    function (direction) { return direction.y * direction.z; },\n    function (direction) { return 3 * direction.z * direction.z - 1; },\n    function (direction) { return direction.x * direction.z; },\n    function (direction) { return direction.x * direction.x - direction.y * direction.y; },\n];\n// Wrap the full compute\nvar applySH3 = function (lm, direction) {\n    return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);\n};\n// Derived from the integration of the a kernel convolution to SH.\n// Great explanation here: https://patapom.com/blog/SHPortal/#about-distant-radiance-and-irradiance-environments\nvar SHCosKernelConvolution = [Math.PI, (2 * Math.PI) / 3, (2 * Math.PI) / 3, (2 * Math.PI) / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];\n/**\n * Class representing spherical harmonics coefficients to the 3rd degree\n */\nvar SphericalHarmonics = /** @class */ (function () {\n    function SphericalHarmonics() {\n        /**\n         * Defines whether or not the harmonics have been prescaled for rendering.\n         */\n        this.preScaled = false;\n        /**\n         * The l0,0 coefficients of the spherical harmonics\n         */\n        this.l00 = Vector3.Zero();\n        /**\n         * The l1,-1 coefficients of the spherical harmonics\n         */\n        this.l1_1 = Vector3.Zero();\n        /**\n         * The l1,0 coefficients of the spherical harmonics\n         */\n        this.l10 = Vector3.Zero();\n        /**\n         * The l1,1 coefficients of the spherical harmonics\n         */\n        this.l11 = Vector3.Zero();\n        /**\n         * The l2,-2 coefficients of the spherical harmonics\n         */\n        this.l2_2 = Vector3.Zero();\n        /**\n         * The l2,-1 coefficients of the spherical harmonics\n         */\n        this.l2_1 = Vector3.Zero();\n        /**\n         * The l2,0 coefficients of the spherical harmonics\n         */\n        this.l20 = Vector3.Zero();\n        /**\n         * The l2,1 coefficients of the spherical harmonics\n         */\n        this.l21 = Vector3.Zero();\n        /**\n         * The l2,2 coefficients of the spherical harmonics\n         */\n        this.l22 = Vector3.Zero();\n    }\n    /**\n     * Adds a light to the spherical harmonics\n     * @param direction the direction of the light\n     * @param color the color of the light\n     * @param deltaSolidAngle the delta solid angle of the light\n     */\n    SphericalHarmonics.prototype.addLight = function (direction, color, deltaSolidAngle) {\n        TmpVectors.Vector3[0].set(color.r, color.g, color.b);\n        var colorVector = TmpVectors.Vector3[0];\n        var c = TmpVectors.Vector3[1];\n        colorVector.scaleToRef(deltaSolidAngle, c);\n        c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);\n        this.l00.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);\n        this.l1_1.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);\n        this.l10.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);\n        this.l11.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);\n        this.l2_2.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);\n        this.l2_1.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);\n        this.l20.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);\n        this.l21.addInPlace(TmpVectors.Vector3[2]);\n        c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);\n        this.l22.addInPlace(TmpVectors.Vector3[2]);\n    };\n    /**\n     * Scales the spherical harmonics by the given amount\n     * @param scale the amount to scale\n     */\n    SphericalHarmonics.prototype.scaleInPlace = function (scale) {\n        this.l00.scaleInPlace(scale);\n        this.l1_1.scaleInPlace(scale);\n        this.l10.scaleInPlace(scale);\n        this.l11.scaleInPlace(scale);\n        this.l2_2.scaleInPlace(scale);\n        this.l2_1.scaleInPlace(scale);\n        this.l20.scaleInPlace(scale);\n        this.l21.scaleInPlace(scale);\n        this.l22.scaleInPlace(scale);\n    };\n    /**\n     * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.\n     *\n     * ```\n     * E_lm = A_l * L_lm\n     * ```\n     *\n     * In spherical harmonics this convolution amounts to scaling factors for each frequency band.\n     * This corresponds to equation 5 in \"An Efficient Representation for Irradiance Environment Maps\", where\n     * the scaling factors are given in equation 9.\n     */\n    SphericalHarmonics.prototype.convertIncidentRadianceToIrradiance = function () {\n        // Constant (Band 0)\n        this.l00.scaleInPlace(SHCosKernelConvolution[0]);\n        // Linear (Band 1)\n        this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);\n        this.l10.scaleInPlace(SHCosKernelConvolution[2]);\n        this.l11.scaleInPlace(SHCosKernelConvolution[3]);\n        // Quadratic (Band 2)\n        this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);\n        this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);\n        this.l20.scaleInPlace(SHCosKernelConvolution[6]);\n        this.l21.scaleInPlace(SHCosKernelConvolution[7]);\n        this.l22.scaleInPlace(SHCosKernelConvolution[8]);\n    };\n    /**\n     * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.\n     *\n     * ```\n     * L = (1/pi) * E * rho\n     * ```\n     *\n     * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.\n     */\n    SphericalHarmonics.prototype.convertIrradianceToLambertianRadiance = function () {\n        this.scaleInPlace(1.0 / Math.PI);\n        // The resultant SH now represents outgoing radiance, so includes the Lambert 1/pi normalisation factor but without albedo (rho) applied\n        // (The pixel shader must apply albedo after texture fetches, etc).\n    };\n    /**\n     * Integrates the reconstruction coefficients directly in to the SH preventing further\n     * required operations at run time.\n     *\n     * This is simply done by scaling back the SH with Ylm constants parameter.\n     * The trigonometric part being applied by the shader at run time.\n     */\n    SphericalHarmonics.prototype.preScaleForRendering = function () {\n        this.preScaled = true;\n        this.l00.scaleInPlace(SH3ylmBasisConstants[0]);\n        this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);\n        this.l10.scaleInPlace(SH3ylmBasisConstants[2]);\n        this.l11.scaleInPlace(SH3ylmBasisConstants[3]);\n        this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);\n        this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);\n        this.l20.scaleInPlace(SH3ylmBasisConstants[6]);\n        this.l21.scaleInPlace(SH3ylmBasisConstants[7]);\n        this.l22.scaleInPlace(SH3ylmBasisConstants[8]);\n    };\n    /**\n     * update the spherical harmonics coefficients from the given array\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\n     * @returns the spherical harmonics (this)\n     */\n    SphericalHarmonics.prototype.updateFromArray = function (data) {\n        Vector3.FromArrayToRef(data[0], 0, this.l00);\n        Vector3.FromArrayToRef(data[1], 0, this.l1_1);\n        Vector3.FromArrayToRef(data[2], 0, this.l10);\n        Vector3.FromArrayToRef(data[3], 0, this.l11);\n        Vector3.FromArrayToRef(data[4], 0, this.l2_2);\n        Vector3.FromArrayToRef(data[5], 0, this.l2_1);\n        Vector3.FromArrayToRef(data[6], 0, this.l20);\n        Vector3.FromArrayToRef(data[7], 0, this.l21);\n        Vector3.FromArrayToRef(data[8], 0, this.l22);\n        return this;\n    };\n    /**\n     * update the spherical harmonics coefficients from the given floats array\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\n     * @returns the spherical harmonics (this)\n     */\n    SphericalHarmonics.prototype.updateFromFloatsArray = function (data) {\n        Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);\n        Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);\n        Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);\n        Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);\n        Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);\n        Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);\n        Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);\n        Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);\n        Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);\n        return this;\n    };\n    /**\n     * Constructs a spherical harmonics from an array.\n     * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\n     * @returns the spherical harmonics\n     */\n    SphericalHarmonics.FromArray = function (data) {\n        var sh = new SphericalHarmonics();\n        return sh.updateFromArray(data);\n    };\n    // Keep for references.\n    /**\n     * Gets the spherical harmonics from polynomial\n     * @param polynomial the spherical polynomial\n     * @returns the spherical harmonics\n     */\n    SphericalHarmonics.FromPolynomial = function (polynomial) {\n        var result = new SphericalHarmonics();\n        result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));\n        result.l1_1 = polynomial.y.scale(0.977204);\n        result.l10 = polynomial.z.scale(0.977204);\n        result.l11 = polynomial.x.scale(0.977204);\n        result.l2_2 = polynomial.xy.scale(1.16538);\n        result.l2_1 = polynomial.yz.scale(1.16538);\n        result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));\n        result.l21 = polynomial.zx.scale(1.16538);\n        result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));\n        result.l1_1.scaleInPlace(-1);\n        result.l11.scaleInPlace(-1);\n        result.l2_1.scaleInPlace(-1);\n        result.l21.scaleInPlace(-1);\n        result.scaleInPlace(Math.PI);\n        return result;\n    };\n    return SphericalHarmonics;\n}());\nexport { SphericalHarmonics };\n/**\n * Class representing spherical polynomial coefficients to the 3rd degree\n */\nvar SphericalPolynomial = /** @class */ (function () {\n    function SphericalPolynomial() {\n        /**\n         * The x coefficients of the spherical polynomial\n         */\n        this.x = Vector3.Zero();\n        /**\n         * The y coefficients of the spherical polynomial\n         */\n        this.y = Vector3.Zero();\n        /**\n         * The z coefficients of the spherical polynomial\n         */\n        this.z = Vector3.Zero();\n        /**\n         * The xx coefficients of the spherical polynomial\n         */\n        this.xx = Vector3.Zero();\n        /**\n         * The yy coefficients of the spherical polynomial\n         */\n        this.yy = Vector3.Zero();\n        /**\n         * The zz coefficients of the spherical polynomial\n         */\n        this.zz = Vector3.Zero();\n        /**\n         * The xy coefficients of the spherical polynomial\n         */\n        this.xy = Vector3.Zero();\n        /**\n         * The yz coefficients of the spherical polynomial\n         */\n        this.yz = Vector3.Zero();\n        /**\n         * The zx coefficients of the spherical polynomial\n         */\n        this.zx = Vector3.Zero();\n    }\n    Object.defineProperty(SphericalPolynomial.prototype, \"preScaledHarmonics\", {\n        /**\n         * The spherical harmonics used to create the polynomials.\n         */\n        get: function () {\n            if (!this._harmonics) {\n                this._harmonics = SphericalHarmonics.FromPolynomial(this);\n            }\n            if (!this._harmonics.preScaled) {\n                this._harmonics.preScaleForRendering();\n            }\n            return this._harmonics;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Adds an ambient color to the spherical polynomial\n     * @param color the color to add\n     */\n    SphericalPolynomial.prototype.addAmbient = function (color) {\n        TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);\n        var colorVector = TmpVectors.Vector3[0];\n        this.xx.addInPlace(colorVector);\n        this.yy.addInPlace(colorVector);\n        this.zz.addInPlace(colorVector);\n    };\n    /**\n     * Scales the spherical polynomial by the given amount\n     * @param scale the amount to scale\n     */\n    SphericalPolynomial.prototype.scaleInPlace = function (scale) {\n        this.x.scaleInPlace(scale);\n        this.y.scaleInPlace(scale);\n        this.z.scaleInPlace(scale);\n        this.xx.scaleInPlace(scale);\n        this.yy.scaleInPlace(scale);\n        this.zz.scaleInPlace(scale);\n        this.yz.scaleInPlace(scale);\n        this.zx.scaleInPlace(scale);\n        this.xy.scaleInPlace(scale);\n    };\n    /**\n     * Updates the spherical polynomial from harmonics\n     * @param harmonics the spherical harmonics\n     * @returns the spherical polynomial\n     */\n    SphericalPolynomial.prototype.updateFromHarmonics = function (harmonics) {\n        this._harmonics = harmonics;\n        this.x.copyFrom(harmonics.l11);\n        this.x.scaleInPlace(1.02333).scaleInPlace(-1);\n        this.y.copyFrom(harmonics.l1_1);\n        this.y.scaleInPlace(1.02333).scaleInPlace(-1);\n        this.z.copyFrom(harmonics.l10);\n        this.z.scaleInPlace(1.02333);\n        this.xx.copyFrom(harmonics.l00);\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);\n        TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);\n        this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);\n        this.yy.copyFrom(harmonics.l00);\n        this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);\n        this.zz.copyFrom(harmonics.l00);\n        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);\n        this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);\n        this.yz.copyFrom(harmonics.l2_1);\n        this.yz.scaleInPlace(0.858086).scaleInPlace(-1);\n        this.zx.copyFrom(harmonics.l21);\n        this.zx.scaleInPlace(0.858086).scaleInPlace(-1);\n        this.xy.copyFrom(harmonics.l2_2);\n        this.xy.scaleInPlace(0.858086);\n        this.scaleInPlace(1.0 / Math.PI);\n        return this;\n    };\n    /**\n     * Gets the spherical polynomial from harmonics\n     * @param harmonics the spherical harmonics\n     * @returns the spherical polynomial\n     */\n    SphericalPolynomial.FromHarmonics = function (harmonics) {\n        var result = new SphericalPolynomial();\n        return result.updateFromHarmonics(harmonics);\n    };\n    /**\n     * Constructs a spherical polynomial from an array.\n     * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)\n     * @returns the spherical polynomial\n     */\n    SphericalPolynomial.FromArray = function (data) {\n        var sp = new SphericalPolynomial();\n        Vector3.FromArrayToRef(data[0], 0, sp.x);\n        Vector3.FromArrayToRef(data[1], 0, sp.y);\n        Vector3.FromArrayToRef(data[2], 0, sp.z);\n        Vector3.FromArrayToRef(data[3], 0, sp.xx);\n        Vector3.FromArrayToRef(data[4], 0, sp.yy);\n        Vector3.FromArrayToRef(data[5], 0, sp.zz);\n        Vector3.FromArrayToRef(data[6], 0, sp.yz);\n        Vector3.FromArrayToRef(data[7], 0, sp.zx);\n        Vector3.FromArrayToRef(data[8], 0, sp.xy);\n        return sp;\n    };\n    return SphericalPolynomial;\n}());\nexport { SphericalPolynomial };\n//# sourceMappingURL=sphericalPolynomial.js.map","import { Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a box\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * size sets the width, height and depth of the box to the value of size, optional default 1\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @returns the VertexData of the box\n */\nexport function CreateBoxVertexData(options) {\n    var nbFaces = 6;\n    var indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n    var normals = [\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\n    ];\n    var uvs = [];\n    var positions = [];\n    var width = options.width || options.size || 1;\n    var height = options.height || options.size || 1;\n    var depth = options.depth || options.size || 1;\n    var wrap = options.wrap || false;\n    var topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\n    var bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\n    var topOrder = [2, 0, 3, 1];\n    var bottomOrder = [2, 0, 1, 3];\n    var topIndex = topOrder[topBaseAt];\n    var bottomIndex = bottomOrder[bottomBaseAt];\n    var basePositions = [\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\n    ];\n    if (wrap) {\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\n        basePositions = [\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\n        ];\n        var topFaceBase = [\n            [1, 1, 1],\n            [-1, 1, 1],\n            [-1, 1, -1],\n            [1, 1, -1],\n        ];\n        var bottomFaceBase = [\n            [-1, -1, 1],\n            [1, -1, 1],\n            [1, -1, -1],\n            [-1, -1, -1],\n        ];\n        var topFaceOrder = [17, 18, 19, 16];\n        var bottomFaceOrder = [22, 23, 20, 21];\n        while (topIndex > 0) {\n            topFaceBase.unshift(topFaceBase.pop());\n            topFaceOrder.unshift(topFaceOrder.pop());\n            topIndex--;\n        }\n        while (bottomIndex > 0) {\n            bottomFaceBase.unshift(bottomFaceBase.pop());\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\n            bottomIndex--;\n        }\n        topFaceBase = topFaceBase.flat();\n        bottomFaceBase = bottomFaceBase.flat();\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\n    }\n    var scaleArray = [width / 2, height / 2, depth / 2];\n    positions = basePositions.reduce(function (accumulator, currentValue, currentIndex) { return accumulator.concat(currentValue * scaleArray[currentIndex % 3]); }, []);\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    var faceUV = options.faceUV || new Array(6);\n    var faceColors = options.faceColors;\n    var colors = [];\n    // default face colors and UV if undefined\n    for (var f = 0; f < 6; f++) {\n        if (faceUV[f] === undefined) {\n            faceUV[f] = new Vector4(0, 0, 1, 1);\n        }\n        if (faceColors && faceColors[f] === undefined) {\n            faceColors[f] = new Color4(1, 1, 1, 1);\n        }\n    }\n    // Create each face in turn.\n    for (var index = 0; index < nbFaces; index++) {\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n        if (faceColors) {\n            for (var c = 0; c < 4; c++) {\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n            }\n        }\n    }\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors) {\n        var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n        vertexData.colors = totalColors;\n    }\n    return vertexData;\n}\n/**\n * Creates a box mesh\n * * The parameter `size` sets the size (float) of each box side (default 1)\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\n * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/how_to/set_shapes#box\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateBox(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    if (scene === void 0) { scene = null; }\n    var box = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    box._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateBoxVertexData(options);\n    vertexData.applyToMesh(box, options.updatable);\n    return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateBox directly\n */\nexport var BoxBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateBox: CreateBox,\n};\n// Side effects\nVertexData.CreateBox = CreateBoxVertexData;\nMesh.CreateBox = function (name, size, scene, updatable, sideOrientation) {\n    if (scene === void 0) { scene = null; }\n    var options = {\n        size: size,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreateBox(name, options, scene);\n};\n//# sourceMappingURL=boxBuilder.js.map","import { VertexData } from \"../mesh.vertexData.js\";\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n * @param options the constructors options used to shape the mesh.\n * @returns the capsule VertexData\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/capsule\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCapsuleVertexData(options) {\n    if (options === void 0) { options = {\n        subdivisions: 2,\n        tessellation: 16,\n        height: 1,\n        radius: 0.25,\n        capSubdivisions: 6,\n    }; }\n    var subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\n    var tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\n    var height = Math.max(options.height ? options.height : 1, 0);\n    var radius = Math.max(options.radius ? options.radius : 0.25, 0);\n    var capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\n    var radialSegments = tessellation;\n    var heightSegments = subdivisions;\n    var radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\n    var radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\n    var heightMinusCaps = height - (radiusTop + radiusBottom);\n    var thetaStart = 0.0;\n    var thetaLength = 2.0 * Math.PI;\n    var capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\n    var capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\n    var alpha = Math.acos((radiusBottom - radiusTop) / height);\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n    var index = 0;\n    var indexArray = [], halfHeight = heightMinusCaps * 0.5;\n    var pi2 = Math.PI * 0.5;\n    var x, y;\n    var normal = Vector3.Zero();\n    var vertex = Vector3.Zero();\n    var cosAlpha = Math.cos(alpha);\n    var sinAlpha = Math.sin(alpha);\n    var coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha)\n        .subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha))\n        .length();\n    // Total length for v texture coord\n    var vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\n    var v = 0;\n    for (y = 0; y <= capsTopSegments; y++) {\n        var indexRow = [];\n        var a = pi2 - alpha * (y / capsTopSegments);\n        v += (radiusTop * alpha) / capsTopSegments;\n        var cosA = Math.cos(a);\n        var sinA = Math.sin(a);\n        // calculate the radius of the current row\n        var _radius = cosA * radiusTop;\n        for (x = 0; x <= radialSegments; x++) {\n            var u = x / radialSegments;\n            var theta = u * thetaLength + thetaStart;\n            var sinTheta = Math.sin(theta);\n            var cosTheta = Math.cos(theta);\n            // vertex\n            vertex.x = _radius * sinTheta;\n            vertex.y = halfHeight + sinA * radiusTop;\n            vertex.z = _radius * cosTheta;\n            vertices.push(vertex.x, vertex.y, vertex.z);\n            // normal\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n            normals.push(normal.x, normal.y, normal.z);\n            // uv\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n            // save index of vertex in respective row\n            indexRow.push(index);\n            // increase index\n            index++;\n        }\n        // now save vertices of the row in our index array\n        indexArray.push(indexRow);\n    }\n    var coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\n    var slope = (sinAlpha * (radiusBottom - radiusTop)) / coneHeight;\n    for (y = 1; y <= heightSegments; y++) {\n        var indexRow = [];\n        v += coneLength / heightSegments;\n        // calculate the radius of the current row\n        var _radius = sinAlpha * ((y * (radiusBottom - radiusTop)) / heightSegments + radiusTop);\n        for (x = 0; x <= radialSegments; x++) {\n            var u = x / radialSegments;\n            var theta = u * thetaLength + thetaStart;\n            var sinTheta = Math.sin(theta);\n            var cosTheta = Math.cos(theta);\n            // vertex\n            vertex.x = _radius * sinTheta;\n            vertex.y = halfHeight + cosAlpha * radiusTop - (y * coneHeight) / heightSegments;\n            vertex.z = _radius * cosTheta;\n            vertices.push(vertex.x, vertex.y, vertex.z);\n            // normal\n            normal.set(sinTheta, slope, cosTheta).normalize();\n            normals.push(normal.x, normal.y, normal.z);\n            // uv\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n            // save index of vertex in respective row\n            indexRow.push(index);\n            // increase index\n            index++;\n        }\n        // now save vertices of the row in our index array\n        indexArray.push(indexRow);\n    }\n    for (y = 1; y <= capsBottomSegments; y++) {\n        var indexRow = [];\n        var a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\n        v += (radiusBottom * alpha) / capsBottomSegments;\n        var cosA = Math.cos(a);\n        var sinA = Math.sin(a);\n        // calculate the radius of the current row\n        var _radius = cosA * radiusBottom;\n        for (x = 0; x <= radialSegments; x++) {\n            var u = x / radialSegments;\n            var theta = u * thetaLength + thetaStart;\n            var sinTheta = Math.sin(theta);\n            var cosTheta = Math.cos(theta);\n            // vertex\n            vertex.x = _radius * sinTheta;\n            vertex.y = -halfHeight + sinA * radiusBottom;\n            vertex.z = _radius * cosTheta;\n            vertices.push(vertex.x, vertex.y, vertex.z);\n            // normal\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n            normals.push(normal.x, normal.y, normal.z);\n            // uv\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n            // save index of vertex in respective row\n            indexRow.push(index);\n            // increase index\n            index++;\n        }\n        // now save vertices of the row in our index array\n        indexArray.push(indexRow);\n    }\n    // generate indices\n    for (x = 0; x < radialSegments; x++) {\n        for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\n            // we use the index array to access the correct indices\n            var i1 = indexArray[y][x];\n            var i2 = indexArray[y + 1][x];\n            var i3 = indexArray[y + 1][x + 1];\n            var i4 = indexArray[y][x + 1];\n            // face one\n            indices.push(i1);\n            indices.push(i2);\n            indices.push(i4);\n            // face two\n            indices.push(i2);\n            indices.push(i3);\n            indices.push(i4);\n        }\n    }\n    indices = indices.reverse();\n    if (options.orientation && !options.orientation.equals(Vector3.Up())) {\n        var m = new Matrix();\n        options.orientation\n            .clone()\n            .scale(Math.PI * 0.5)\n            .cross(Vector3.Up())\n            .toQuaternion()\n            .toRotationMatrix(m);\n        var v_1 = Vector3.Zero();\n        for (var i = 0; i < vertices.length; i += 3) {\n            v_1.set(vertices[i], vertices[i + 1], vertices[i + 2]);\n            Vector3.TransformCoordinatesToRef(v_1.clone(), m, v_1);\n            vertices[i] = v_1.x;\n            vertices[i + 1] = v_1.y;\n            vertices[i + 2] = v_1.z;\n        }\n    }\n    var vDat = new VertexData();\n    vDat.positions = vertices;\n    vDat.normals = normals;\n    vDat.uvs = uvs;\n    vDat.indices = indices;\n    return vDat;\n}\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh\n * @param options The constructors options.\n * @param scene The scene the mesh is scoped to.\n * @returns Capsule Mesh\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCapsule(name, options, scene) {\n    if (options === void 0) { options = {\n        orientation: Vector3.Up(),\n        subdivisions: 2,\n        tessellation: 16,\n        height: 1,\n        radius: 0.25,\n        capSubdivisions: 6,\n        updatable: false,\n    }; }\n    if (scene === void 0) { scene = null; }\n    var capsule = new Mesh(name, scene);\n    var vertexData = CreateCapsuleVertexData(options);\n    vertexData.applyToMesh(capsule, options.updatable);\n    return capsule;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateCapsule directly\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport var CapsuleBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateCapsule: CreateCapsule,\n};\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh.\n * @param options the constructors options used to shape the mesh.\n * @param scene defines the scene the mesh is scoped to.\n * @returns the capsule mesh\n * @see https://doc.babylonjs.com/how_to/capsule_shape\n */\nMesh.CreateCapsule = function (name, options, scene) {\n    return CreateCapsule(name, options, scene);\n};\nVertexData.CreateCapsule = CreateCapsuleVertexData;\n//# sourceMappingURL=capsuleBuilder.js.map","import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Scene } from \"../../scene.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a cylinder, cone or prism\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * height sets the height (y direction) of the cylinder, optional, default 2\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.height\n * @param options.diameterTop\n * @param options.diameterBottom\n * @param options.diameter\n * @param options.tessellation\n * @param options.subdivisions\n * @param options.arc\n * @param options.faceColors\n * @param options.faceUV\n * @param options.hasRings\n * @param options.enclose\n * @param options.cap\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the cylinder, cone or prism\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCylinderVertexData(options) {\n    var height = options.height || 2;\n    var diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\n    var diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\n    var tessellation = options.tessellation || 24;\n    var subdivisions = options.subdivisions || 1;\n    var hasRings = options.hasRings ? true : false;\n    var enclose = options.enclose ? true : false;\n    var cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\n    var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    var faceUV = options.faceUV || new Array(3);\n    var faceColors = options.faceColors;\n    // default face colors and UV if undefined\n    var quadNb = arc !== 1 && enclose ? 2 : 0;\n    var ringNb = hasRings ? subdivisions : 1;\n    var surfaceNb = 2 + (1 + quadNb) * ringNb;\n    var f;\n    for (f = 0; f < surfaceNb; f++) {\n        if (faceColors && faceColors[f] === undefined) {\n            faceColors[f] = new Color4(1, 1, 1, 1);\n        }\n    }\n    for (f = 0; f < surfaceNb; f++) {\n        if (faceUV && faceUV[f] === undefined) {\n            faceUV[f] = new Vector4(0, 0, 1, 1);\n        }\n    }\n    var indices = new Array();\n    var positions = new Array();\n    var normals = new Array();\n    var uvs = new Array();\n    var colors = new Array();\n    var angleStep = (Math.PI * 2 * arc) / tessellation;\n    var angle;\n    var h;\n    var radius;\n    var tan = (diameterBottom - diameterTop) / 2 / height;\n    var ringVertex = Vector3.Zero();\n    var ringNormal = Vector3.Zero();\n    var ringFirstVertex = Vector3.Zero();\n    var ringFirstNormal = Vector3.Zero();\n    var quadNormal = Vector3.Zero();\n    var Y = Axis.Y;\n    // positions, normals, uvs\n    var i;\n    var j;\n    var r;\n    var ringIdx = 1;\n    var s = 1; // surface index\n    var cs = 0;\n    var v = 0;\n    for (i = 0; i <= subdivisions; i++) {\n        h = i / subdivisions;\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\n        for (r = 0; r < ringIdx; r++) {\n            if (hasRings) {\n                s += r;\n            }\n            if (enclose) {\n                s += 2 * r;\n            }\n            for (j = 0; j <= tessellation; j++) {\n                angle = j * angleStep;\n                // position\n                ringVertex.x = Math.cos(-angle) * radius;\n                ringVertex.y = -height / 2 + h * height;\n                ringVertex.z = Math.sin(-angle) * radius;\n                // normal\n                if (diameterTop === 0 && i === subdivisions) {\n                    // if no top cap, reuse former normals\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\n                }\n                else {\n                    ringNormal.x = ringVertex.x;\n                    ringNormal.z = ringVertex.z;\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\n                    ringNormal.normalize();\n                }\n                // keep first ring vertex values for enclose\n                if (j === 0) {\n                    ringFirstVertex.copyFrom(ringVertex);\n                    ringFirstNormal.copyFrom(ringNormal);\n                }\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\n                if (hasRings) {\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\n                }\n                else {\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\n                }\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                if (faceColors) {\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\n                }\n            }\n            // if enclose, add four vertices and their dedicated normals\n            if (arc !== 1 && enclose) {\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n                positions.push(0, ringVertex.y, 0);\n                positions.push(0, ringVertex.y, 0);\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\n                quadNormal.normalize();\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\n                quadNormal.normalize();\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n                if (hasRings) {\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\n                }\n                else {\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\n                }\n                uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                if (hasRings) {\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\n                }\n                else {\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\n                }\n                uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n                if (faceColors) {\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n                }\n            }\n            if (cs !== s) {\n                cs = s;\n            }\n        }\n    }\n    // indices\n    var e = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\n    i = 0;\n    for (s = 0; s < subdivisions; s++) {\n        var i0 = 0;\n        var i1 = 0;\n        var i2 = 0;\n        var i3 = 0;\n        for (j = 0; j < tessellation; j++) {\n            i0 = i * (e + 1) + j;\n            i1 = (i + 1) * (e + 1) + j;\n            i2 = i * (e + 1) + (j + 1);\n            i3 = (i + 1) * (e + 1) + (j + 1);\n            indices.push(i0, i1, i2);\n            indices.push(i3, i2, i1);\n        }\n        if (arc !== 1 && enclose) {\n            // if enclose, add two quads\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\n        }\n        i = hasRings ? i + 2 : i + 1;\n    }\n    // Caps\n    var createCylinderCap = function (isTop) {\n        var radius = isTop ? diameterTop / 2 : diameterBottom / 2;\n        if (radius === 0) {\n            return;\n        }\n        // Cap positions, normals & uvs\n        var angle;\n        var circleVector;\n        var i;\n        var u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\n        var c = null;\n        if (faceColors) {\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\n        }\n        // cap center\n        var vbase = positions.length / 3;\n        var offset = isTop ? height / 2 : -height / 2;\n        var center = new Vector3(0, offset, 0);\n        positions.push(center.x, center.y, center.z);\n        normals.push(0, isTop ? 1 : -1, 0);\n        var v = u.y + (u.w - u.y) * 0.5;\n        uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        if (c) {\n            colors.push(c.r, c.g, c.b, c.a);\n        }\n        var textureScale = new Vector2(0.5, 0.5);\n        for (i = 0; i <= tessellation; i++) {\n            angle = (Math.PI * 2 * i * arc) / tessellation;\n            var cos = Math.cos(-angle);\n            var sin = Math.sin(-angle);\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\n            var textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\n            normals.push(0, isTop ? 1 : -1, 0);\n            var v_1 = u.y + (u.w - u.y) * textureCoordinate.y;\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v_1 : v_1);\n            if (c) {\n                colors.push(c.r, c.g, c.b, c.a);\n            }\n        }\n        // Cap indices\n        for (i = 0; i < tessellation; i++) {\n            if (!isTop) {\n                indices.push(vbase);\n                indices.push(vbase + (i + 1));\n                indices.push(vbase + (i + 2));\n            }\n            else {\n                indices.push(vbase);\n                indices.push(vbase + (i + 2));\n                indices.push(vbase + (i + 1));\n            }\n        }\n    };\n    // add caps to geometry based on cap parameter\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\n        createCylinderCap(false);\n    }\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\n        createCylinderCap(true);\n    }\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors) {\n        vertexData.colors = colors;\n    }\n    return vertexData;\n}\n/**\n * Creates a cylinder or a cone mesh\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\n * * If `enclose` is false, a ring surface is one element.\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.height\n * @param options.diameterTop\n * @param options.diameterBottom\n * @param options.diameter\n * @param options.tessellation\n * @param options.subdivisions\n * @param options.arc\n * @param options.faceColors\n * @param options.faceUV\n * @param options.updatable\n * @param options.hasRings\n * @param options.enclose\n * @param options.cap\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the cylinder mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone\n */\nexport function CreateCylinder(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    var cylinder = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateCylinderVertexData(options);\n    vertexData.applyToMesh(cylinder, options.updatable);\n    return cylinder;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated Please use CreateCylinder directly\n */\nexport var CylinderBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateCylinder: CreateCylinder,\n};\nVertexData.CreateCylinder = CreateCylinderVertexData;\nMesh.CreateCylinder = function (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {\n    if (scene === undefined || !(scene instanceof Scene)) {\n        if (scene !== undefined) {\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\n            updatable = scene;\n        }\n        scene = subdivisions;\n        subdivisions = 1;\n    }\n    var options = {\n        height: height,\n        diameterTop: diameterTop,\n        diameterBottom: diameterBottom,\n        tessellation: tessellation,\n        subdivisions: subdivisions,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreateCylinder(name, options, scene);\n};\n//# sourceMappingURL=cylinderBuilder.js.map","import { Vector3, Matrix, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { PositionNormalTextureVertex } from \"../../Maths/math.vertexFormat.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates a decal mesh.\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\n * @param name defines the name of the mesh\n * @param sourceMesh defines the mesh where the decal must be applied\n * @param options defines the options used to create the mesh\n * @param options.position\n * @param options.normal\n * @param options.size\n * @param options.angle\n * @param options.captureUVS\n * @returns the decal mesh\n * @see https://doc.babylonjs.com/how_to/decals\n */\nexport function CreateDecal(name, sourceMesh, options) {\n    var indices = sourceMesh.getIndices();\n    var positions = sourceMesh.getVerticesData(VertexBuffer.PositionKind);\n    var normals = sourceMesh.getVerticesData(VertexBuffer.NormalKind);\n    var uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\n    var position = options.position || Vector3.Zero();\n    var normal = options.normal || Vector3.Up();\n    var size = options.size || Vector3.One();\n    var angle = options.angle || 0;\n    // Getting correct rotation\n    if (!normal) {\n        var target = new Vector3(0, 0, 1);\n        var camera = sourceMesh.getScene().activeCamera;\n        var cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\n        normal = camera.globalPosition.subtract(cameraWorldTarget);\n    }\n    var yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n    var len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n    var pitch = Math.atan2(normal.y, len);\n    // Matrix\n    var decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\n    var inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\n    var meshWorldMatrix = sourceMesh.getWorldMatrix();\n    var transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\n    var vertexData = new VertexData();\n    vertexData.indices = [];\n    vertexData.positions = [];\n    vertexData.normals = [];\n    vertexData.uvs = [];\n    var currentVertexDataIndex = 0;\n    var extractDecalVector3 = function (indexId) {\n        var result = new PositionNormalTextureVertex();\n        if (!indices || !positions || !normals) {\n            return result;\n        }\n        var vertexId = indices[indexId];\n        result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\n        // Send vector to decal local world\n        result.position = Vector3.TransformCoordinates(result.position, transformMatrix);\n        // Get normal\n        result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\n        result.normal = Vector3.TransformNormal(result.normal, transformMatrix);\n        if (options.captureUVS && uvs) {\n            var v = uvs[vertexId * 2 + 1];\n            result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        }\n        return result;\n    }; // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\n    var clip = function (vertices, axis) {\n        if (vertices.length === 0) {\n            return vertices;\n        }\n        var clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\n        var clipVertices = function (v0, v1) {\n            var clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\n            return new PositionNormalTextureVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor));\n        };\n        var result = new Array();\n        for (var index = 0; index < vertices.length; index += 3) {\n            var total = 0;\n            var nV1 = null;\n            var nV2 = null;\n            var nV3 = null;\n            var nV4 = null;\n            var d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\n            var d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\n            var d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\n            var v1Out = d1 > 0;\n            var v2Out = d2 > 0;\n            var v3Out = d3 > 0;\n            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n            switch (total) {\n                case 0:\n                    result.push(vertices[index]);\n                    result.push(vertices[index + 1]);\n                    result.push(vertices[index + 2]);\n                    break;\n                case 1:\n                    if (v1Out) {\n                        nV1 = vertices[index + 1];\n                        nV2 = vertices[index + 2];\n                        nV3 = clipVertices(vertices[index], nV1);\n                        nV4 = clipVertices(vertices[index], nV2);\n                    }\n                    if (v2Out) {\n                        nV1 = vertices[index];\n                        nV2 = vertices[index + 2];\n                        nV3 = clipVertices(vertices[index + 1], nV1);\n                        nV4 = clipVertices(vertices[index + 1], nV2);\n                        result.push(nV3);\n                        result.push(nV2.clone());\n                        result.push(nV1.clone());\n                        result.push(nV2.clone());\n                        result.push(nV3.clone());\n                        result.push(nV4);\n                        break;\n                    }\n                    if (v3Out) {\n                        nV1 = vertices[index];\n                        nV2 = vertices[index + 1];\n                        nV3 = clipVertices(vertices[index + 2], nV1);\n                        nV4 = clipVertices(vertices[index + 2], nV2);\n                    }\n                    if (nV1 && nV2 && nV3 && nV4) {\n                        result.push(nV1.clone());\n                        result.push(nV2.clone());\n                        result.push(nV3);\n                        result.push(nV4);\n                        result.push(nV3.clone());\n                        result.push(nV2.clone());\n                    }\n                    break;\n                case 2:\n                    if (!v1Out) {\n                        nV1 = vertices[index].clone();\n                        nV2 = clipVertices(nV1, vertices[index + 1]);\n                        nV3 = clipVertices(nV1, vertices[index + 2]);\n                        result.push(nV1);\n                        result.push(nV2);\n                        result.push(nV3);\n                    }\n                    if (!v2Out) {\n                        nV1 = vertices[index + 1].clone();\n                        nV2 = clipVertices(nV1, vertices[index + 2]);\n                        nV3 = clipVertices(nV1, vertices[index]);\n                        result.push(nV1);\n                        result.push(nV2);\n                        result.push(nV3);\n                    }\n                    if (!v3Out) {\n                        nV1 = vertices[index + 2].clone();\n                        nV2 = clipVertices(nV1, vertices[index]);\n                        nV3 = clipVertices(nV1, vertices[index + 1]);\n                        result.push(nV1);\n                        result.push(nV2);\n                        result.push(nV3);\n                    }\n                    break;\n                case 3:\n                    break;\n            }\n        }\n        return result;\n    };\n    for (var index = 0; index < indices.length; index += 3) {\n        var faceVertices = new Array();\n        faceVertices.push(extractDecalVector3(index));\n        faceVertices.push(extractDecalVector3(index + 1));\n        faceVertices.push(extractDecalVector3(index + 2));\n        // Clip\n        faceVertices = clip(faceVertices, new Vector3(1, 0, 0));\n        faceVertices = clip(faceVertices, new Vector3(-1, 0, 0));\n        faceVertices = clip(faceVertices, new Vector3(0, 1, 0));\n        faceVertices = clip(faceVertices, new Vector3(0, -1, 0));\n        faceVertices = clip(faceVertices, new Vector3(0, 0, 1));\n        faceVertices = clip(faceVertices, new Vector3(0, 0, -1));\n        if (faceVertices.length === 0) {\n            continue;\n        }\n        // Add UVs and get back to world\n        for (var vIndex = 0; vIndex < faceVertices.length; vIndex++) {\n            var vertex = faceVertices[vIndex];\n            //TODO check for Int32Array | Uint32Array | Uint16Array\n            vertexData.indices.push(currentVertexDataIndex);\n            vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\n            vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\n            if (!options.captureUVS) {\n                vertexData.uvs.push(0.5 + vertex.position.x / size.x);\n                var v = 0.5 + vertex.position.y / size.y;\n                vertexData.uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n            }\n            else {\n                vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\n            }\n            currentVertexDataIndex++;\n        }\n    }\n    // Return mesh\n    var decal = new Mesh(name, sourceMesh.getScene());\n    vertexData.applyToMesh(decal);\n    decal.position = position.clone();\n    decal.rotation = new Vector3(pitch, yaw, angle);\n    return decal;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport var DecalBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateDecal: CreateDecal,\n};\nMesh.CreateDecal = function (name, sourceMesh, position, normal, size, angle) {\n    var options = {\n        position: position,\n        normal: normal,\n        size: size,\n        angle: angle,\n    };\n    return CreateDecal(name, sourceMesh, options);\n};\n//# sourceMappingURL=decalBuilder.js.map","import { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData of the Disc or regular Polygon\n * @param options an object used to set the following optional parameters for the disc, required but can be empty\n * * radius the radius of the disc, optional default 0.5\n * * tessellation the number of polygon sides, optional, default 64\n * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.radius\n * @param options.tessellation\n * @param options.arc\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the box\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction CreateDiscVertexData(options) {\n    var positions = new Array();\n    var indices = new Array();\n    var normals = new Array();\n    var uvs = new Array();\n    var radius = options.radius || 0.5;\n    var tessellation = options.tessellation || 64;\n    var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // positions and uvs\n    positions.push(0, 0, 0); // disc center first\n    uvs.push(0.5, 0.5);\n    var theta = Math.PI * 2 * arc;\n    var step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\n    var a = 0;\n    for (var t = 0; t < tessellation; t++) {\n        var x = Math.cos(a);\n        var y = Math.sin(a);\n        var u = (x + 1) / 2;\n        var v = (1 - y) / 2;\n        positions.push(radius * x, radius * y, 0);\n        uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        a += step;\n    }\n    if (arc === 1) {\n        positions.push(positions[3], positions[4], positions[5]); // close the circle\n        uvs.push(uvs[2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);\n    }\n    //indices\n    var vertexNb = positions.length / 3;\n    for (var i = 1; i < vertexNb - 1; i++) {\n        indices.push(i + 1, 0, i);\n    }\n    // result\n    VertexData.ComputeNormals(positions, indices, normals);\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a plane polygonal mesh.  By default, this is a disc\n * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\n * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\n * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.radius\n * @param options.tessellation\n * @param options.arc\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the plane polygonal mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon\n */\nexport function CreateDisc(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    if (scene === void 0) { scene = null; }\n    var disc = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    disc._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateDiscVertexData(options);\n    vertexData.applyToMesh(disc, options.updatable);\n    return disc;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateDisc directly\n */\nexport var DiscBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateDisc: CreateDisc,\n};\nVertexData.CreateDisc = CreateDiscVertexData;\nMesh.CreateDisc = function (name, radius, tessellation, scene, updatable, sideOrientation) {\n    if (scene === void 0) { scene = null; }\n    var options = {\n        radius: radius,\n        tessellation: tessellation,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreateDisc(name, options, scene);\n};\n//# sourceMappingURL=discBuilder.js.map","import { CreatePolyhedron } from \"./polyhedronBuilder.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh.js\";\n/**\n * Creates the Mesh for a Geodesic Polyhedron\n * @see https://en.wikipedia.org/wiki/Geodesic_polyhedron\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/polyhedra/geodesic_poly\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * * m number of horizontal steps along an isogrid\n * * n number of angled steps along an isogrid\n * * size the size of the Geodesic, optional default 1\n * * sizeX allows stretching in the x direction, optional, default size\n * * sizeY allows stretching in the y direction, optional, default size\n * * sizeZ allows stretching in the z direction, optional, default size\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * * flat when true creates a flat shaded mesh, optional, default true\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.n\n * @param options.size\n * @param options.sizeX\n * @param options.sizeY\n * @param options.sizeZ\n * @param options.faceUV\n * @param options.faceColors\n * @param options.flat\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.m\n * @param scene defines the hosting scene\n * @returns Geodesic mesh\n */\nexport function CreateGeodesic(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var m = options.m || 1;\n    if (m !== Math.floor(m)) {\n        m === Math.floor(m);\n        Logger.Warn(\"m not an integer only floor(m) used\");\n    }\n    var n = options.n || 0;\n    if (n !== Math.floor(n)) {\n        n === Math.floor(n);\n        Logger.Warn(\"n not an integer only floor(n) used\");\n    }\n    if (n > m) {\n        var temp = n;\n        n = m;\n        m = temp;\n        Logger.Warn(\"n > m therefore m and n swapped\");\n    }\n    var primTri = new _PrimaryIsoTriangle();\n    primTri.build(m, n);\n    var geodesicData = GeodesicData.BuildGeodesicData(primTri);\n    var geoOptions = {\n        custom: geodesicData,\n        size: options.size,\n        sizeX: options.sizeX,\n        sizeY: options.sizeY,\n        sizeZ: options.sizeZ,\n        faceUV: options.faceUV,\n        faceColors: options.faceColors,\n        flat: options.flat,\n        updatable: options.updatable,\n        sideOrientation: options.sideOrientation,\n        frontUVs: options.frontUVs,\n        backUVs: options.backUVs,\n    };\n    var geodesic = CreatePolyhedron(name, geoOptions, scene);\n    return geodesic;\n}\n//# sourceMappingURL=geodesicBuilder.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh.js\";\nimport { GoldbergMesh } from \"../goldbergMesh.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the Mesh for a Goldberg Polyhedron\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * @param goldbergData polyhedronData defining the Goldberg polyhedron\n * @returns GoldbergSphere mesh\n */\nexport function CreateGoldbergVertexData(options, goldbergData) {\n    var size = options.size;\n    var sizeX = options.sizeX || size || 1;\n    var sizeY = options.sizeY || size || 1;\n    var sizeZ = options.sizeZ || size || 1;\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    var positions = new Array();\n    var indices = new Array();\n    var normals = new Array();\n    var uvs = new Array();\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    for (var v = 0; v < goldbergData.vertex.length; v++) {\n        minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);\n        maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);\n        minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);\n        maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);\n    }\n    var index = 0;\n    for (var f = 0; f < goldbergData.face.length; f++) {\n        var verts = goldbergData.face[f];\n        var a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\n        var b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\n        var c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\n        var ba = b.subtract(a);\n        var ca = c.subtract(a);\n        var norm = Vector3.Cross(ca, ba).normalize();\n        for (var v = 0; v < verts.length; v++) {\n            normals.push(norm.x, norm.y, norm.z);\n            var pdata = goldbergData.vertex[verts[v]];\n            positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);\n            var vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);\n            uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - vCoord : vCoord);\n        }\n        for (var v = 0; v < verts.length - 2; v++) {\n            indices.push(index, index + v + 2, index + v + 1);\n        }\n        index += verts.length;\n    }\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\n    var vertexData = new VertexData();\n    vertexData.positions = positions;\n    vertexData.indices = indices;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/polyhedra/goldberg_poly\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * @param scene defines the hosting scene\n * @returns Goldberg mesh\n */\nexport function CreateGoldberg(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var size = options.size;\n    var sizeX = options.sizeX || size || 1;\n    var sizeY = options.sizeY || size || 1;\n    var sizeZ = options.sizeZ || size || 1;\n    var m = options.m || 1;\n    if (m !== Math.floor(m)) {\n        m === Math.floor(m);\n        Logger.Warn(\"m not an integer only floor(m) used\");\n    }\n    var n = options.n || 0;\n    if (n !== Math.floor(n)) {\n        n === Math.floor(n);\n        Logger.Warn(\"n not an integer only floor(n) used\");\n    }\n    if (n > m) {\n        var temp = n;\n        n = m;\n        m = temp;\n        Logger.Warn(\"n > m therefore m and n swapped\");\n    }\n    var primTri = new _PrimaryIsoTriangle();\n    primTri.build(m, n);\n    var geodesicData = GeodesicData.BuildGeodesicData(primTri);\n    var goldbergData = geodesicData.toGoldbergPolyhedronData();\n    var goldberg = new GoldbergMesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    goldberg._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateGoldbergVertexData(options, goldbergData);\n    vertexData.applyToMesh(goldberg, options.updatable);\n    goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;\n    goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;\n    goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;\n    goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;\n    goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;\n    for (var f = 0; f < geodesicData.vertex.length; f++) {\n        goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));\n        goldberg.goldbergData.faceCenters[f].x *= sizeX;\n        goldberg.goldbergData.faceCenters[f].y *= sizeY;\n        goldberg.goldbergData.faceCenters[f].z *= sizeZ;\n        goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));\n    }\n    for (var f = 0; f < goldbergData.face.length; f++) {\n        var verts = goldbergData.face[f];\n        var a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\n        var b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\n        var c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\n        var ba = b.subtract(a);\n        var ca = c.subtract(a);\n        var norm = Vector3.Cross(ca, ba).normalize();\n        var z = Vector3.Cross(ca, norm).normalize();\n        goldberg.goldbergData.faceXaxis.push(ca.normalize());\n        goldberg.goldbergData.faceYaxis.push(norm);\n        goldberg.goldbergData.faceZaxis.push(z);\n    }\n    return goldberg;\n}\nMesh.CreateGoldberg = CreateGoldberg;\n//# sourceMappingURL=goldbergBuilder.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { GroundMesh } from \"../groundMesh.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Ground\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n *  - width the width (x direction) of the ground, optional, default 1\n *  - height the height (z direction) of the ground, optional, default 1\n *  - subdivisions the number of subdivisions per side, optional, default 1\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.subdivisionsX\n * @param options.subdivisionsY\n * @returns the VertexData of the Ground\n */\nexport function CreateGroundVertexData(options) {\n    var indices = [];\n    var positions = [];\n    var normals = [];\n    var uvs = [];\n    var row, col;\n    var width = options.width || 1;\n    var height = options.height || 1;\n    var subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n    var subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n    for (row = 0; row <= subdivisionsY; row++) {\n        for (col = 0; col <= subdivisionsX; col++) {\n            var position = new Vector3((col * width) / subdivisionsX - width / 2.0, 0, ((subdivisionsY - row) * height) / subdivisionsY - height / 2.0);\n            var normal = new Vector3(0, 1.0, 0);\n            positions.push(position.x, position.y, position.z);\n            normals.push(normal.x, normal.y, normal.z);\n            uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\n        }\n    }\n    for (row = 0; row < subdivisionsY; row++) {\n        for (col = 0; col < subdivisionsX; col++) {\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n            indices.push(col + 1 + row * (subdivisionsX + 1));\n            indices.push(col + row * (subdivisionsX + 1));\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n            indices.push(col + row * (subdivisionsX + 1));\n        }\n    }\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n * * xmin the ground minimum X coordinate, optional, default -1\n * * zmin the ground minimum Z coordinate, optional, default -1\n * * xmax the ground maximum X coordinate, optional, default 1\n * * zmax the ground maximum Z coordinate, optional, default 1\n * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n * @param options.xmin\n * @param options.zmin\n * @param options.xmax\n * @param options.zmax\n * @param options.subdivisions\n * @param options.subdivisions.w\n * @param options.subdivisions.h\n * @param options.precision\n * @param options.precision.w\n * @param options.precision.h\n * @returns the VertexData of the TiledGround\n */\nexport function CreateTiledGroundVertexData(options) {\n    var xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\n    var zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\n    var xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\n    var zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\n    var subdivisions = options.subdivisions || { w: 1, h: 1 };\n    var precision = options.precision || { w: 1, h: 1 };\n    var indices = new Array();\n    var positions = new Array();\n    var normals = new Array();\n    var uvs = new Array();\n    var row, col, tileRow, tileCol;\n    subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\n    subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\n    precision.w = precision.w < 1 ? 1 : precision.w;\n    precision.h = precision.h < 1 ? 1 : precision.h;\n    var tileSize = {\n        w: (xmax - xmin) / subdivisions.w,\n        h: (zmax - zmin) / subdivisions.h,\n    };\n    function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {\n        // Indices\n        var base = positions.length / 3;\n        var rowLength = precision.w + 1;\n        for (row = 0; row < precision.h; row++) {\n            for (col = 0; col < precision.w; col++) {\n                var square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\n                indices.push(square[1]);\n                indices.push(square[2]);\n                indices.push(square[3]);\n                indices.push(square[0]);\n                indices.push(square[1]);\n                indices.push(square[3]);\n            }\n        }\n        // Position, normals and uvs\n        var position = Vector3.Zero();\n        var normal = new Vector3(0, 1.0, 0);\n        for (row = 0; row <= precision.h; row++) {\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\n            for (col = 0; col <= precision.w; col++) {\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\n                position.y = 0;\n                positions.push(position.x, position.y, position.z);\n                normals.push(normal.x, normal.y, normal.z);\n                uvs.push(col / precision.w, row / precision.h);\n            }\n        }\n    }\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\n            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\n        }\n    }\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates the VertexData of the Ground designed from a heightmap\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n * * width the width (x direction) of the ground\n * * height the height (z direction) of the ground\n * * subdivisions the number of subdivisions per side\n * * minHeight the minimum altitude on the ground, optional, default 0\n * * maxHeight the maximum altitude on the ground, optional default 1\n * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n * * buffer the array holding the image color data\n * * bufferWidth the width of image\n * * bufferHeight the height of image\n * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.minHeight\n * @param options.maxHeight\n * @param options.colorFilter\n * @param options.buffer\n * @param options.bufferWidth\n * @param options.bufferHeight\n * @param options.alphaFilter\n * @returns the VertexData of the Ground designed from a heightmap\n */\nexport function CreateGroundFromHeightMapVertexData(options) {\n    var indices = [];\n    var positions = [];\n    var normals = [];\n    var uvs = [];\n    var row, col;\n    var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n    var alphaFilter = options.alphaFilter || 0.0;\n    var invert = false;\n    if (options.minHeight > options.maxHeight) {\n        invert = true;\n        var temp = options.maxHeight;\n        options.maxHeight = options.minHeight;\n        options.minHeight = temp;\n    }\n    // Vertices\n    for (row = 0; row <= options.subdivisions; row++) {\n        for (col = 0; col <= options.subdivisions; col++) {\n            var position = new Vector3((col * options.width) / options.subdivisions - options.width / 2.0, 0, ((options.subdivisions - row) * options.height) / options.subdivisions - options.height / 2.0);\n            // Compute height\n            var heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\n            var heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\n            var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\n            var r = options.buffer[pos] / 255.0;\n            var g = options.buffer[pos + 1] / 255.0;\n            var b = options.buffer[pos + 2] / 255.0;\n            var a = options.buffer[pos + 3] / 255.0;\n            if (invert) {\n                r = 1.0 - r;\n                g = 1.0 - g;\n                b = 1.0 - b;\n            }\n            var gradient = r * filter.r + g * filter.g + b * filter.b;\n            // If our alpha channel is not within our filter then we will assign a 'special' height\n            // Then when building the indices, we will ignore any vertex that is using the special height\n            if (a >= alphaFilter) {\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\n            }\n            else {\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\n            }\n            // Add  vertex\n            positions.push(position.x, position.y, position.z);\n            normals.push(0, 0, 0);\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\n        }\n    }\n    // Indices\n    for (row = 0; row < options.subdivisions; row++) {\n        for (col = 0; col < options.subdivisions; col++) {\n            // Calculate Indices\n            var idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\n            var idx2 = col + 1 + row * (options.subdivisions + 1);\n            var idx3 = col + row * (options.subdivisions + 1);\n            var idx4 = col + (row + 1) * (options.subdivisions + 1);\n            // Check that all indices are visible (based on our special height)\n            // Only display the vertex if all Indices are visible\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\n            var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\n            var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\n            var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\n                indices.push(idx1);\n                indices.push(idx2);\n                indices.push(idx3);\n            }\n            var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\n                indices.push(idx4);\n                indices.push(idx1);\n                indices.push(idx3);\n            }\n        }\n    }\n    // Normals\n    VertexData.ComputeNormals(positions, indices, normals);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a ground mesh\n * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\n * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.subdivisionsX\n * @param options.subdivisionsY\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#ground\n */\nexport function CreateGround(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    var ground = new GroundMesh(name, scene);\n    ground._setReady(false);\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n    ground._width = options.width || 1;\n    ground._height = options.height || 1;\n    ground._maxX = ground._width / 2;\n    ground._maxZ = ground._height / 2;\n    ground._minX = -ground._maxX;\n    ground._minZ = -ground._maxZ;\n    var vertexData = CreateGroundVertexData(options);\n    vertexData.applyToMesh(ground, options.updatable);\n    ground._setReady(true);\n    return ground;\n}\n/**\n * Creates a tiled ground mesh\n * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\n * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\n * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\n * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.xmin\n * @param options.zmin\n * @param options.xmax\n * @param options.zmax\n * @param options.subdivisions\n * @param options.subdivisions.w\n * @param options.subdivisions.h\n * @param options.precision\n * @param options.precision.w\n * @param options.precision.h\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the tiled ground mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\n */\nexport function CreateTiledGround(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var tiledGround = new Mesh(name, scene);\n    var vertexData = CreateTiledGroundVertexData(options);\n    vertexData.applyToMesh(tiledGround, options.updatable);\n    return tiledGround;\n}\n/**\n * Creates a ground mesh from a height map\n * * The parameter `url` sets the URL of the height map image resource.\n * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\n * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\n * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\n * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\n * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\n * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\n * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param url defines the url to the height map\n * @param options defines the options used to create the mesh\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.minHeight\n * @param options.maxHeight\n * @param options.colorFilter\n * @param options.alphaFilter\n * @param options.updatable\n * @param options.onReady\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/babylon101/height_map\n * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\n */\nexport function CreateGroundFromHeightMap(name, url, options, scene) {\n    if (options === void 0) { options = {}; }\n    if (scene === void 0) { scene = null; }\n    var width = options.width || 10.0;\n    var height = options.height || 10.0;\n    var subdivisions = options.subdivisions || 1 | 0;\n    var minHeight = options.minHeight || 0.0;\n    var maxHeight = options.maxHeight || 1.0;\n    var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n    var alphaFilter = options.alphaFilter || 0.0;\n    var updatable = options.updatable;\n    var onReady = options.onReady;\n    scene = scene || EngineStore.LastCreatedScene;\n    var ground = new GroundMesh(name, scene);\n    ground._subdivisionsX = subdivisions;\n    ground._subdivisionsY = subdivisions;\n    ground._width = width;\n    ground._height = height;\n    ground._maxX = ground._width / 2.0;\n    ground._maxZ = ground._height / 2.0;\n    ground._minX = -ground._maxX;\n    ground._minZ = -ground._maxZ;\n    ground._setReady(false);\n    var onload = function (img) {\n        var bufferWidth = img.width;\n        var bufferHeight = img.height;\n        if (scene.isDisposed) {\n            return;\n        }\n        var buffer = scene === null || scene === void 0 ? void 0 : scene.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\n        var vertexData = CreateGroundFromHeightMapVertexData({\n            width: width,\n            height: height,\n            subdivisions: subdivisions,\n            minHeight: minHeight,\n            maxHeight: maxHeight,\n            colorFilter: filter,\n            buffer: buffer,\n            bufferWidth: bufferWidth,\n            bufferHeight: bufferHeight,\n            alphaFilter: alphaFilter,\n        });\n        vertexData.applyToMesh(ground, updatable);\n        //execute ready callback, if set\n        if (onReady) {\n            onReady(ground);\n        }\n        ground._setReady(true);\n    };\n    Tools.LoadImage(url, onload, function () { }, scene.offlineProvider);\n    return ground;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport var GroundBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateGround: CreateGround,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateGroundFromHeightMap: CreateGroundFromHeightMap,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTiledGround: CreateTiledGround,\n};\nVertexData.CreateGround = CreateGroundVertexData;\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\nMesh.CreateGround = function (name, width, height, subdivisions, scene, updatable) {\n    var options = {\n        width: width,\n        height: height,\n        subdivisions: subdivisions,\n        updatable: updatable,\n    };\n    return CreateGround(name, options, scene);\n};\nMesh.CreateTiledGround = function (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {\n    var options = {\n        xmin: xmin,\n        zmin: zmin,\n        xmax: xmax,\n        zmax: zmax,\n        subdivisions: subdivisions,\n        precision: precision,\n        updatable: updatable,\n    };\n    return CreateTiledGround(name, options, scene);\n};\nMesh.CreateGroundFromHeightMap = function (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {\n    var options = {\n        width: width,\n        height: height,\n        subdivisions: subdivisions,\n        minHeight: minHeight,\n        maxHeight: maxHeight,\n        updatable: updatable,\n        onReady: onReady,\n        alphaFilter: alphaFilter,\n    };\n    return CreateGroundFromHeightMap(name, url, options, scene);\n};\n//# sourceMappingURL=groundBuilder.js.map","import { Mesh } from \"../mesh.js\";\nimport { CreateSphere } from \"../Builders/sphereBuilder.js\";\nimport { CreateDisc } from \"./discBuilder.js\";\n/**\n * Creates a hemisphere mesh\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.segments\n * @param options.diameter\n * @param options.sideOrientation\n * @param scene defines the hosting scene\n * @returns the hemisphere mesh\n */\nexport function CreateHemisphere(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    if (!options.diameter) {\n        options.diameter = 1;\n    }\n    if (!options.segments) {\n        options.segments = 16;\n    }\n    var halfSphere = CreateSphere(\"\", { slice: 0.5, diameter: options.diameter, segments: options.segments }, scene);\n    var disc = CreateDisc(\"\", { radius: options.diameter / 2, tessellation: options.segments * 3 + (4 - options.segments) }, scene);\n    disc.rotation.x = -Math.PI / 2;\n    disc.parent = halfSphere;\n    var merged = Mesh.MergeMeshes([disc, halfSphere], true);\n    merged.name = name;\n    return merged;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport var HemisphereBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateHemisphere: CreateHemisphere,\n};\n/**\n * Creates a hemispheric light\n * @param name\n * @param segments\n * @param diameter\n * @param scene\n */\nMesh.CreateHemisphere = function (name, segments, diameter, scene) {\n    var options = {\n        segments: segments,\n        diameter: diameter,\n    };\n    return CreateHemisphere(name, options, scene);\n};\n//# sourceMappingURL=hemisphereBuilder.js.map","import { Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData of the IcoSphere\n * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\n * * radius the radius of the IcoSphere, optional default 1\n * * radiusX allows stretching in the x direction, optional, default radius\n * * radiusY allows stretching in the y direction, optional, default radius\n * * radiusZ allows stretching in the z direction, optional, default radius\n * * flat when true creates a flat shaded mesh, optional, default true\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.radius\n * @param options.radiusX\n * @param options.radiusY\n * @param options.radiusZ\n * @param options.flat\n * @param options.subdivisions\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the IcoSphere\n */\nexport function CreateIcoSphereVertexData(options) {\n    var sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;\n    var radius = options.radius || 1;\n    var flat = options.flat === undefined ? true : options.flat;\n    var subdivisions = options.subdivisions || 4;\n    var radiusX = options.radiusX || radius;\n    var radiusY = options.radiusY || radius;\n    var radiusZ = options.radiusZ || radius;\n    var t = (1 + Math.sqrt(5)) / 2;\n    // 12 vertex x,y,z\n    var icoVertices = [\n        -1,\n        t,\n        -0,\n        1,\n        t,\n        0,\n        -1,\n        -t,\n        0,\n        1,\n        -t,\n        0,\n        0,\n        -1,\n        -t,\n        0,\n        1,\n        -t,\n        0,\n        -1,\n        t,\n        0,\n        1,\n        t,\n        t,\n        0,\n        1,\n        t,\n        0,\n        -1,\n        -t,\n        0,\n        1,\n        -t,\n        0,\n        -1, // v8-11\n    ];\n    // index of 3 vertex makes a face of icopshere\n    var ico_indices = [\n        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17,\n        23, 6, 13, 22, 19, 6, 18, 9, 8, 1,\n    ];\n    // vertex for uv have aliased position, not for UV\n    var vertices_unalias_id = [\n        0,\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        // vertex alias\n        0,\n        2,\n        3,\n        3,\n        3,\n        4,\n        7,\n        8,\n        9,\n        9,\n        10,\n        11, // 23: B + 12\n    ];\n    // uv as integer step (not pixels !)\n    var ico_vertexuv = [\n        5,\n        1,\n        3,\n        1,\n        6,\n        4,\n        0,\n        0,\n        5,\n        3,\n        4,\n        2,\n        2,\n        2,\n        4,\n        0,\n        2,\n        0,\n        1,\n        1,\n        6,\n        0,\n        6,\n        2,\n        // vertex alias (for same vertex on different faces)\n        0,\n        4,\n        3,\n        3,\n        4,\n        4,\n        3,\n        1,\n        4,\n        2,\n        4,\n        4,\n        0,\n        2,\n        1,\n        1,\n        2,\n        2,\n        3,\n        3,\n        1,\n        3,\n        2,\n        4, // 23: B + 12\n    ];\n    // Vertices[0, 1, ...9, A, B] : position on UV plane\n    // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\n    // First island of uv mapping\n    // v = 4h          3+  2\n    // v = 3h        9+  4\n    // v = 2h      9+  5   B\n    // v = 1h    9   1   0\n    // v = 0h  3   8   7   A\n    //     u = 0 1 2 3 4 5 6  *a\n    // Second island of uv mapping\n    // v = 4h  0+  B+  4+\n    // v = 3h    A+  2+\n    // v = 2h  7+  6   3+\n    // v = 1h    8+  3+\n    // v = 0h\n    //     u = 0 1 2 3 4 5 6  *a\n    // Face layout on texture UV mapping\n    // ============\n    // \\ 4  /\\ 16 /   ======\n    //  \\  /  \\  /   /\\ 11 /\n    //   \\/ 7  \\/   /  \\  /\n    //    =======  / 10 \\/\n    //   /\\ 17 /\\  =======\n    //  /  \\  /  \\ \\ 15 /\\\n    // / 8  \\/ 12 \\ \\  /  \\\n    // ============  \\/ 6  \\\n    // \\ 18 /\\  ============\n    //  \\  /  \\ \\ 5  /\\ 0  /\n    //   \\/ 13 \\ \\  /  \\  /\n    //   =======  \\/ 1  \\/\n    //       =============\n    //      /\\ 19 /\\  2 /\\\n    //     /  \\  /  \\  /  \\\n    //    / 14 \\/ 9  \\/  3 \\\n    //   ===================\n    // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\n    var ustep = 138 / 1024;\n    var vstep = 239 / 1024;\n    var uoffset = 60 / 1024;\n    var voffset = 26 / 1024;\n    // Second island should have margin, not to touch the first island\n    // avoid any borderline artefact in pixel rounding\n    var island_u_offset = -40 / 1024;\n    var island_v_offset = +20 / 1024;\n    // face is either island 0 or 1 :\n    // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\n    var island = [\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        1,\n        1,\n        0,\n        0,\n        0,\n        1,\n        1,\n        0,\n        0,\n        1,\n        1,\n        1,\n        0, //  15 - 19\n    ];\n    var indices = new Array();\n    var positions = new Array();\n    var normals = new Array();\n    var uvs = new Array();\n    var current_indice = 0;\n    // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\n    var face_vertex_pos = new Array(3);\n    var face_vertex_uv = new Array(3);\n    var v012;\n    for (v012 = 0; v012 < 3; v012++) {\n        face_vertex_pos[v012] = Vector3.Zero();\n        face_vertex_uv[v012] = Vector2.Zero();\n    }\n    // create all with normals\n    for (var face = 0; face < 20; face++) {\n        // 3 vertex per face\n        for (v012 = 0; v012 < 3; v012++) {\n            // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\n            var v_id = ico_indices[3 * face + v012];\n            // vertex have 3D position (x,y,z)\n            face_vertex_pos[v012].copyFromFloats(icoVertices[3 * vertices_unalias_id[v_id]], icoVertices[3 * vertices_unalias_id[v_id] + 1], icoVertices[3 * vertices_unalias_id[v_id] + 2]);\n            // Normalize to get normal, then scale to radius\n            face_vertex_pos[v012].normalize().scaleInPlace(radius);\n            // uv Coordinates from vertex ID\n            face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);\n        }\n        // Subdivide the face (interpolate pos, norm, uv)\n        // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\n        // - norm is linear interpolation of vertex corner normal\n        //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\n        // - uv is linear interpolation\n        //\n        // Topology is as below for sub-divide by 2\n        // vertex shown as v0,v1,v2\n        // interp index is i1 to progress in range [v0,v1[\n        // interp index is i2 to progress in range [v0,v2[\n        // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\n        //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\n        //\n        //\n        //                    i2    v2\n        //                    ^    ^\n        //                   /    / \\\n        //                  /    /   \\\n        //                 /    /     \\\n        //                /    / (0,1) \\\n        //               /    #---------\\\n        //              /    / \\ (0,0)'/ \\\n        //             /    /   \\     /   \\\n        //            /    /     \\   /     \\\n        //           /    / (0,0) \\ / (1,0) \\\n        //          /    #---------#---------\\\n        //              v0                    v1\n        //\n        //              --------------------> i1\n        //\n        // interp of (i1,i2):\n        //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\n        //  along i1 :  lerp(x0,x1, i1/(S-i2))\n        //\n        // centroid of triangle is needed to get help normal computation\n        //  (c1,c2) are used for centroid location\n        var interp_vertex = function (i1, i2, c1, c2) {\n            // vertex is interpolated from\n            //   - face_vertex_pos[0..2]\n            //   - face_vertex_uv[0..2]\n            var pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\n            var pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\n            var pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\n            pos_interp.normalize();\n            var vertex_normal;\n            if (flat) {\n                // in flat mode, recalculate normal as face centroid normal\n                var centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\n                var centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\n                vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\n            }\n            else {\n                // in smooth mode, recalculate normal from each single vertex position\n                vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);\n            }\n            // Vertex normal need correction due to X,Y,Z radius scaling\n            vertex_normal.x /= radiusX;\n            vertex_normal.y /= radiusY;\n            vertex_normal.z /= radiusZ;\n            vertex_normal.normalize();\n            var uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\n            var uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\n            var uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\n            positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\n            normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\n            uvs.push(uv_interp.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - uv_interp.y : uv_interp.y);\n            // push each vertex has member of a face\n            // Same vertex can belong to multiple face, it is pushed multiple time (duplicate vertex are present)\n            indices.push(current_indice);\n            current_indice++;\n        };\n        for (var i2 = 0; i2 < subdivisions; i2++) {\n            for (var i1 = 0; i1 + i2 < subdivisions; i1++) {\n                // face : (i1,i2)  for /\\  :\n                // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\n                interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\n                interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\n                interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\n                if (i1 + i2 + 1 < subdivisions) {\n                    // face : (i1,i2)' for \\/  :\n                    // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\n                    interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\n                    interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\n                    interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\n                }\n            }\n        }\n    }\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\n * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\n * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\n * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\n * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.radius\n * @param options.radiusX\n * @param options.radiusY\n * @param options.radiusZ\n * @param options.flat\n * @param options.subdivisions\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the icosahedron mesh\n * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere\n */\nexport function CreateIcoSphere(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    if (scene === void 0) { scene = null; }\n    var sphere = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateIcoSphereVertexData(options);\n    vertexData.applyToMesh(sphere, options.updatable);\n    return sphere;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport var IcoSphereBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateIcoSphere: CreateIcoSphere,\n};\nVertexData.CreateIcoSphere = CreateIcoSphereVertexData;\nMesh.CreateIcoSphere = function (name, options, scene) {\n    return CreateIcoSphere(name, options, scene);\n};\n//# sourceMappingURL=icoSphereBuilder.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\n/**\n * Creates lathe mesh.\n * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\n * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\n * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\n * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\n * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\n * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.radius\n * @param options.tessellation\n * @param options.clip\n * @param options.arc\n * @param options.closed\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.cap\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the lathe mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe\n */\nexport function CreateLathe(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var arc = options.arc ? (options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc) : 1.0;\n    var closed = options.closed === undefined ? true : options.closed;\n    var shape = options.shape;\n    var radius = options.radius || 1;\n    var tessellation = options.tessellation || 64;\n    var clip = options.clip || 0;\n    var updatable = options.updatable;\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    var cap = options.cap || Mesh.NO_CAP;\n    var pi2 = Math.PI * 2;\n    var paths = new Array();\n    var invertUV = options.invertUV || false;\n    var i = 0;\n    var p = 0;\n    var step = (pi2 / tessellation) * arc;\n    var rotated;\n    var path;\n    for (i = 0; i <= tessellation - clip; i++) {\n        path = [];\n        if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\n            path.push(new Vector3(0, shape[0].y, 0));\n            path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\n        }\n        for (p = 0; p < shape.length; p++) {\n            rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\n            path.push(rotated);\n        }\n        if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\n            path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\n            path.push(new Vector3(0, shape[shape.length - 1].y, 0));\n        }\n        paths.push(path);\n    }\n    // lathe ribbon\n    var lathe = CreateRibbon(name, { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);\n    return lathe;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function direction from the module\n */\nexport var LatheBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateLathe: CreateLathe,\n};\nMesh.CreateLathe = function (name, shape, radius, tessellation, scene, updatable, sideOrientation) {\n    var options = {\n        shape: shape,\n        radius: radius,\n        tessellation: tessellation,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreateLathe(name, options, scene);\n};\n//# sourceMappingURL=latheBuilder.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { _CreationDataStorage, Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { LinesMesh } from \"../../Meshes/linesMesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Creates the VertexData of the LineSystem\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n *  - lines an array of lines, each line being an array of successive Vector3\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n * @param options.lines\n * @param options.colors\n * @returns the VertexData of the LineSystem\n */\nexport function CreateLineSystemVertexData(options) {\n    var indices = [];\n    var positions = [];\n    var lines = options.lines;\n    var colors = options.colors;\n    var vertexColors = [];\n    var idx = 0;\n    for (var l = 0; l < lines.length; l++) {\n        var points = lines[l];\n        for (var index = 0; index < points.length; index++) {\n            positions.push(points[index].x, points[index].y, points[index].z);\n            if (colors) {\n                var color = colors[l];\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\n            }\n            if (index > 0) {\n                indices.push(idx - 1);\n                indices.push(idx);\n            }\n            idx++;\n        }\n    }\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    if (colors) {\n        vertexData.colors = vertexColors;\n    }\n    return vertexData;\n}\n/**\n * Create the VertexData for a DashedLines\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n *  - points an array successive Vector3\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n *  - dashNb the intended total number of dashes, optional, default 200\n * @param options.points\n * @param options.dashSize\n * @param options.gapSize\n * @param options.dashNb\n * @returns the VertexData for the DashedLines\n */\nexport function CreateDashedLinesVertexData(options) {\n    var dashSize = options.dashSize || 3;\n    var gapSize = options.gapSize || 1;\n    var dashNb = options.dashNb || 200;\n    var points = options.points;\n    var positions = new Array();\n    var indices = new Array();\n    var curvect = Vector3.Zero();\n    var lg = 0;\n    var nb = 0;\n    var shft = 0;\n    var dashshft = 0;\n    var curshft = 0;\n    var idx = 0;\n    var i = 0;\n    for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        lg += curvect.length();\n    }\n    shft = lg / dashNb;\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\n    for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        nb = Math.floor(curvect.length() / shft);\n        curvect.normalize();\n        for (var j = 0; j < nb; j++) {\n            curshft = shft * j;\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\n            indices.push(idx, idx + 1);\n            idx += 2;\n        }\n    }\n    // Result\n    var vertexData = new VertexData();\n    vertexData.positions = positions;\n    vertexData.indices = indices;\n    return vertexData;\n}\n/**\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param options.lines\n * @param options.updatable\n * @param options.instance\n * @param options.colors\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns a new line system mesh\n */\nexport function CreateLineSystem(name, options, scene) {\n    var instance = options.instance;\n    var lines = options.lines;\n    var colors = options.colors;\n    if (instance) {\n        // lines update\n        var positions = instance.getVerticesData(VertexBuffer.PositionKind);\n        var vertexColor = void 0;\n        var lineColors = void 0;\n        if (colors) {\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);\n        }\n        var i = 0;\n        var c = 0;\n        for (var l = 0; l < lines.length; l++) {\n            var points = lines[l];\n            for (var p = 0; p < points.length; p++) {\n                positions[i] = points[p].x;\n                positions[i + 1] = points[p].y;\n                positions[i + 2] = points[p].z;\n                if (colors && vertexColor) {\n                    lineColors = colors[l];\n                    vertexColor[c] = lineColors[p].r;\n                    vertexColor[c + 1] = lineColors[p].g;\n                    vertexColor[c + 2] = lineColors[p].b;\n                    vertexColor[c + 3] = lineColors[p].a;\n                    c += 4;\n                }\n                i += 3;\n            }\n        }\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n        if (colors && vertexColor) {\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\n        }\n        return instance;\n    }\n    // line system creation\n    var useVertexColor = colors ? true : false;\n    var lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\n    var vertexData = CreateLineSystemVertexData(options);\n    vertexData.applyToMesh(lineSystem, options.updatable);\n    return lineSystem;\n}\n/**\n * Creates a line mesh\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\n * * The optional parameter `colors` is an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param options.points\n * @param options.updatable\n * @param options.instance\n * @param options.colors\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns a new line mesh\n */\nexport function CreateLines(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var colors = options.colors ? [options.colors] : null;\n    var lines = CreateLineSystem(name, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material }, scene);\n    return lines;\n}\n/**\n * Creates a dashed line mesh\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.points\n * @param options.dashSize\n * @param options.gapSize\n * @param options.dashNb\n * @param options.updatable\n * @param options.instance\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns the dashed line mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\n */\nexport function CreateDashedLines(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var points = options.points;\n    var instance = options.instance;\n    var gapSize = options.gapSize || 1;\n    var dashSize = options.dashSize || 3;\n    if (instance) {\n        //  dashed lines update\n        var positionFunction = function (positions) {\n            var curvect = Vector3.Zero();\n            var nbSeg = positions.length / 6;\n            var lg = 0;\n            var nb = 0;\n            var shft = 0;\n            var dashshft = 0;\n            var curshft = 0;\n            var p = 0;\n            var i = 0;\n            var j = 0;\n            for (i = 0; i < points.length - 1; i++) {\n                points[i + 1].subtractToRef(points[i], curvect);\n                lg += curvect.length();\n            }\n            shft = lg / nbSeg;\n            var dashSize = instance._creationDataStorage.dashSize;\n            var gapSize = instance._creationDataStorage.gapSize;\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\n            for (i = 0; i < points.length - 1; i++) {\n                points[i + 1].subtractToRef(points[i], curvect);\n                nb = Math.floor(curvect.length() / shft);\n                curvect.normalize();\n                j = 0;\n                while (j < nb && p < positions.length) {\n                    curshft = shft * j;\n                    positions[p] = points[i].x + curshft * curvect.x;\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\n                    p += 6;\n                    j++;\n                }\n            }\n            while (p < positions.length) {\n                positions[p] = points[i].x;\n                positions[p + 1] = points[i].y;\n                positions[p + 2] = points[i].z;\n                p += 3;\n            }\n        };\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\n        }\n        instance.updateMeshPositions(positionFunction, false);\n        return instance;\n    }\n    // dashed lines creation\n    var dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\n    var vertexData = CreateDashedLinesVertexData(options);\n    vertexData.applyToMesh(dashedLines, options.updatable);\n    dashedLines._creationDataStorage = new _CreationDataStorage();\n    dashedLines._creationDataStorage.dashSize = dashSize;\n    dashedLines._creationDataStorage.gapSize = gapSize;\n    return dashedLines;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport var LinesBuilder = {\n    CreateDashedLines: CreateDashedLines,\n    CreateLineSystem: CreateLineSystem,\n    CreateLines: CreateLines,\n};\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\nMesh.CreateLines = function (name, points, scene, updatable, instance) {\n    if (scene === void 0) { scene = null; }\n    if (updatable === void 0) { updatable = false; }\n    if (instance === void 0) { instance = null; }\n    var options = {\n        points: points,\n        updatable: updatable,\n        instance: instance,\n    };\n    return CreateLines(name, options, scene);\n};\nMesh.CreateDashedLines = function (name, points, dashSize, gapSize, dashNb, scene, updatable, instance) {\n    if (scene === void 0) { scene = null; }\n    var options = {\n        points: points,\n        dashSize: dashSize,\n        gapSize: gapSize,\n        dashNb: dashNb,\n        updatable: updatable,\n        instance: instance,\n    };\n    return CreateDashedLines(name, options, scene);\n};\n//# sourceMappingURL=linesBuilder.js.map","import { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Plane\n * @param options an object used to set the following optional parameters for the plane, required but can be empty\n * * size sets the width and height of the plane to the value of size, optional default 1\n * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the box\n */\nexport function CreatePlaneVertexData(options) {\n    var indices = [];\n    var positions = [];\n    var normals = [];\n    var uvs = [];\n    var width = options.width || options.size || 1;\n    var height = options.height || options.size || 1;\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // Vertices\n    var halfWidth = width / 2.0;\n    var halfHeight = height / 2.0;\n    positions.push(-halfWidth, -halfHeight, 0);\n    normals.push(0, 0, -1.0);\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\n    positions.push(halfWidth, -halfHeight, 0);\n    normals.push(0, 0, -1.0);\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\n    positions.push(halfWidth, halfHeight, 0);\n    normals.push(0, 0, -1.0);\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\n    positions.push(-halfWidth, halfHeight, 0);\n    normals.push(0, 0, -1.0);\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\n    // Indices\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a plane mesh\n * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\n * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\n * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param options.sourcePlane\n * @param scene defines the hosting scene\n * @returns the plane mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#plane\n */\nexport function CreatePlane(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    if (scene === void 0) { scene = null; }\n    var plane = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    plane._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreatePlaneVertexData(options);\n    vertexData.applyToMesh(plane, options.updatable);\n    if (options.sourcePlane) {\n        plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\n        plane.setDirection(options.sourcePlane.normal.scale(-1));\n    }\n    return plane;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport var PlaneBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreatePlane: CreatePlane,\n};\nVertexData.CreatePlane = CreatePlaneVertexData;\nMesh.CreatePlane = function (name, size, scene, updatable, sideOrientation) {\n    var options = {\n        size: size,\n        width: size,\n        height: size,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreatePlane(name, options, scene);\n};\n//# sourceMappingURL=planeBuilder.js.map","import { Vector2, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { PolygonMeshBuilder } from \"../polygonMesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\n * All parameters are provided by CreatePolygon as needed\n * @param polygon a mesh built from polygonTriangulation.build()\n * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param wrp a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\n * @returns the VertexData of the Polygon\n */\nexport function CreatePolygonVertexData(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {\n    var faceUV = fUV || new Array(3);\n    var faceColors = fColors;\n    var colors = [];\n    var wrap = wrp || false;\n    // default face colors and UV if undefined\n    for (var f = 0; f < 3; f++) {\n        if (faceUV[f] === undefined) {\n            faceUV[f] = new Vector4(0, 0, 1, 1);\n        }\n        if (faceColors && faceColors[f] === undefined) {\n            faceColors[f] = new Color4(1, 1, 1, 1);\n        }\n    }\n    var positions = polygon.getVerticesData(VertexBuffer.PositionKind);\n    var normals = polygon.getVerticesData(VertexBuffer.NormalKind);\n    var uvs = polygon.getVerticesData(VertexBuffer.UVKind);\n    var indices = polygon.getIndices();\n    var startIndex = positions.length / 9;\n    var disp = 0;\n    var distX = 0;\n    var distZ = 0;\n    var dist = 0;\n    var totalLen = 0;\n    var cumulate = [0];\n    if (wrap) {\n        for (var idx_1 = startIndex; idx_1 < positions.length / 3; idx_1 += 4) {\n            distX = positions[3 * (idx_1 + 2)] - positions[3 * idx_1];\n            distZ = positions[3 * (idx_1 + 2) + 2] - positions[3 * idx_1 + 2];\n            dist = Math.sqrt(distX * distX + distZ * distZ);\n            totalLen += dist;\n            cumulate.push(totalLen);\n        }\n    }\n    // set face colours and textures\n    var idx = 0;\n    var face = 0;\n    for (var index = 0; index < normals.length; index += 3) {\n        //Edge Face  no. 1\n        if (Math.abs(normals[index + 1]) < 0.001) {\n            face = 1;\n        }\n        //Top Face  no. 0\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\n            face = 0;\n        }\n        //Bottom Face  no. 2\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\n            face = 2;\n        }\n        idx = index / 3;\n        if (face === 1) {\n            disp = idx - startIndex;\n            if (disp % 4 < 1.5) {\n                if (wrap) {\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)]) / totalLen;\n                }\n                else {\n                    uvs[2 * idx] = faceUV[face].x;\n                }\n            }\n            else {\n                if (wrap) {\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1]) / totalLen;\n                }\n                else {\n                    uvs[2 * idx] = faceUV[face].z;\n                }\n            }\n            if (disp % 2 === 0) {\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].w : faceUV[face].w;\n            }\n            else {\n                uvs[2 * idx + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[face].y : faceUV[face].y;\n            }\n        }\n        else {\n            uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\n            uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                uvs[2 * idx + 1] = 1.0 - uvs[2 * idx + 1];\n            }\n        }\n        if (faceColors) {\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\n        }\n    }\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors) {\n        var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n        vertexData.colors = totalColors;\n    }\n    return vertexData;\n}\n/**\n * Creates a polygon mesh\n * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\n * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\n * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\n * * Remember you can only change the shape positions, not their number when updating a polygon\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.holes\n * @param options.depth\n * @param options.smoothingThreshold\n * @param options.faceUV\n * @param options.faceColors\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param scene defines the hosting scene\n * @param earcutInjection can be used to inject your own earcut reference\n * @returns the polygon mesh\n */\nexport function CreatePolygon(name, options, scene, earcutInjection) {\n    if (scene === void 0) { scene = null; }\n    if (earcutInjection === void 0) { earcutInjection = earcut; }\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    var shape = options.shape;\n    var holes = options.holes || [];\n    var depth = options.depth || 0;\n    var smoothingThreshold = options.smoothingThreshold || 2;\n    var contours = [];\n    var hole = [];\n    for (var i = 0; i < shape.length; i++) {\n        contours[i] = new Vector2(shape[i].x, shape[i].z);\n    }\n    var epsilon = 0.00000001;\n    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\n        contours.pop();\n    }\n    var polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene, earcutInjection);\n    for (var hNb = 0; hNb < holes.length; hNb++) {\n        hole = [];\n        for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\n            hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\n        }\n        polygonTriangulation.addHole(hole);\n    }\n    //updatability is set during applyToMesh; setting to true in triangulation build produces errors\n    var polygon = polygonTriangulation.build(false, depth, smoothingThreshold);\n    polygon._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\n    vertexData.applyToMesh(polygon, options.updatable);\n    return polygon;\n}\n/**\n * Creates an extruded polygon mesh, with depth in the Y direction.\n * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\n * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.holes\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param scene defines the hosting scene\n * @param earcutInjection can be used to inject your own earcut reference\n * @returns the polygon mesh\n */\nexport function ExtrudePolygon(name, options, scene, earcutInjection) {\n    if (scene === void 0) { scene = null; }\n    if (earcutInjection === void 0) { earcutInjection = earcut; }\n    return CreatePolygon(name, options, scene, earcutInjection);\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport var PolygonBuilder = {\n    ExtrudePolygon: ExtrudePolygon,\n    CreatePolygon: CreatePolygon,\n};\nVertexData.CreatePolygon = CreatePolygonVertexData;\nMesh.CreatePolygon = function (name, shape, scene, holes, updatable, sideOrientation, earcutInjection) {\n    if (earcutInjection === void 0) { earcutInjection = earcut; }\n    var options = {\n        shape: shape,\n        holes: holes,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n    };\n    return CreatePolygon(name, options, scene, earcutInjection);\n};\nMesh.ExtrudePolygon = function (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {\n    if (earcutInjection === void 0) { earcutInjection = earcut; }\n    var options = {\n        shape: shape,\n        holes: holes,\n        depth: depth,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n    };\n    return ExtrudePolygon(name, options, scene, earcutInjection);\n};\n//# sourceMappingURL=polygonBuilder.js.map","import { Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n// inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n/**\n * Creates the VertexData for a Polyhedron\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * * type provided types are:\n *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n * * size the size of the IcoSphere, optional default 1\n * * sizeX allows stretching in the x direction, optional, default size\n * * sizeY allows stretching in the y direction, optional, default size\n * * sizeZ allows stretching in the z direction, optional, default size\n * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * * flat when true creates a flat shaded mesh, optional, default true\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.type\n * @param options.size\n * @param options.sizeX\n * @param options.sizeY\n * @param options.sizeZ\n * @param options.custom\n * @param options.faceUV\n * @param options.faceColors\n * @param options.flat\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the Polyhedron\n */\nexport function CreatePolyhedronVertexData(options) {\n    // provided polyhedron types :\n    // 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n    // 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n    var polyhedra = [];\n    polyhedra[0] = {\n        vertex: [\n            [0, 0, 1.732051],\n            [1.632993, 0, -0.5773503],\n            [-0.8164966, 1.414214, -0.5773503],\n            [-0.8164966, -1.414214, -0.5773503],\n        ],\n        face: [\n            [0, 1, 2],\n            [0, 2, 3],\n            [0, 3, 1],\n            [1, 3, 2],\n        ],\n    };\n    polyhedra[1] = {\n        vertex: [\n            [0, 0, 1.414214],\n            [1.414214, 0, 0],\n            [0, 1.414214, 0],\n            [-1.414214, 0, 0],\n            [0, -1.414214, 0],\n            [0, 0, -1.414214],\n        ],\n        face: [\n            [0, 1, 2],\n            [0, 2, 3],\n            [0, 3, 4],\n            [0, 4, 1],\n            [1, 4, 5],\n            [1, 5, 2],\n            [2, 5, 3],\n            [3, 5, 4],\n        ],\n    };\n    polyhedra[2] = {\n        vertex: [\n            [0, 0, 1.070466],\n            [0.7136442, 0, 0.7978784],\n            [-0.3568221, 0.618034, 0.7978784],\n            [-0.3568221, -0.618034, 0.7978784],\n            [0.7978784, 0.618034, 0.3568221],\n            [0.7978784, -0.618034, 0.3568221],\n            [-0.9341724, 0.381966, 0.3568221],\n            [0.1362939, 1, 0.3568221],\n            [0.1362939, -1, 0.3568221],\n            [-0.9341724, -0.381966, 0.3568221],\n            [0.9341724, 0.381966, -0.3568221],\n            [0.9341724, -0.381966, -0.3568221],\n            [-0.7978784, 0.618034, -0.3568221],\n            [-0.1362939, 1, -0.3568221],\n            [-0.1362939, -1, -0.3568221],\n            [-0.7978784, -0.618034, -0.3568221],\n            [0.3568221, 0.618034, -0.7978784],\n            [0.3568221, -0.618034, -0.7978784],\n            [-0.7136442, 0, -0.7978784],\n            [0, 0, -1.070466],\n        ],\n        face: [\n            [0, 1, 4, 7, 2],\n            [0, 2, 6, 9, 3],\n            [0, 3, 8, 5, 1],\n            [1, 5, 11, 10, 4],\n            [2, 7, 13, 12, 6],\n            [3, 9, 15, 14, 8],\n            [4, 10, 16, 13, 7],\n            [5, 8, 14, 17, 11],\n            [6, 12, 18, 15, 9],\n            [10, 11, 17, 19, 16],\n            [12, 13, 16, 19, 18],\n            [14, 15, 18, 19, 17],\n        ],\n    };\n    polyhedra[3] = {\n        vertex: [\n            [0, 0, 1.175571],\n            [1.051462, 0, 0.5257311],\n            [0.3249197, 1, 0.5257311],\n            [-0.8506508, 0.618034, 0.5257311],\n            [-0.8506508, -0.618034, 0.5257311],\n            [0.3249197, -1, 0.5257311],\n            [0.8506508, 0.618034, -0.5257311],\n            [0.8506508, -0.618034, -0.5257311],\n            [-0.3249197, 1, -0.5257311],\n            [-1.051462, 0, -0.5257311],\n            [-0.3249197, -1, -0.5257311],\n            [0, 0, -1.175571],\n        ],\n        face: [\n            [0, 1, 2],\n            [0, 2, 3],\n            [0, 3, 4],\n            [0, 4, 5],\n            [0, 5, 1],\n            [1, 5, 7],\n            [1, 7, 6],\n            [1, 6, 2],\n            [2, 6, 8],\n            [2, 8, 3],\n            [3, 8, 9],\n            [3, 9, 4],\n            [4, 9, 10],\n            [4, 10, 5],\n            [5, 10, 7],\n            [6, 7, 11],\n            [6, 11, 8],\n            [7, 10, 11],\n            [8, 11, 9],\n            [9, 11, 10],\n        ],\n    };\n    polyhedra[4] = {\n        vertex: [\n            [0, 0, 1.070722],\n            [0.7148135, 0, 0.7971752],\n            [-0.104682, 0.7071068, 0.7971752],\n            [-0.6841528, 0.2071068, 0.7971752],\n            [-0.104682, -0.7071068, 0.7971752],\n            [0.6101315, 0.7071068, 0.5236279],\n            [1.04156, 0.2071068, 0.1367736],\n            [0.6101315, -0.7071068, 0.5236279],\n            [-0.3574067, 1, 0.1367736],\n            [-0.7888348, -0.5, 0.5236279],\n            [-0.9368776, 0.5, 0.1367736],\n            [-0.3574067, -1, 0.1367736],\n            [0.3574067, 1, -0.1367736],\n            [0.9368776, -0.5, -0.1367736],\n            [0.7888348, 0.5, -0.5236279],\n            [0.3574067, -1, -0.1367736],\n            [-0.6101315, 0.7071068, -0.5236279],\n            [-1.04156, -0.2071068, -0.1367736],\n            [-0.6101315, -0.7071068, -0.5236279],\n            [0.104682, 0.7071068, -0.7971752],\n            [0.6841528, -0.2071068, -0.7971752],\n            [0.104682, -0.7071068, -0.7971752],\n            [-0.7148135, 0, -0.7971752],\n            [0, 0, -1.070722],\n        ],\n        face: [\n            [0, 2, 3],\n            [1, 6, 5],\n            [4, 9, 11],\n            [7, 15, 13],\n            [8, 16, 10],\n            [12, 14, 19],\n            [17, 22, 18],\n            [20, 21, 23],\n            [0, 1, 5, 2],\n            [0, 3, 9, 4],\n            [0, 4, 7, 1],\n            [1, 7, 13, 6],\n            [2, 5, 12, 8],\n            [2, 8, 10, 3],\n            [3, 10, 17, 9],\n            [4, 11, 15, 7],\n            [5, 6, 14, 12],\n            [6, 13, 20, 14],\n            [8, 12, 19, 16],\n            [9, 17, 18, 11],\n            [10, 16, 22, 17],\n            [11, 18, 21, 15],\n            [13, 15, 21, 20],\n            [14, 20, 23, 19],\n            [16, 19, 23, 22],\n            [18, 22, 23, 21],\n        ],\n    };\n    polyhedra[5] = {\n        vertex: [\n            [0, 0, 1.322876],\n            [1.309307, 0, 0.1889822],\n            [-0.9819805, 0.8660254, 0.1889822],\n            [0.1636634, -1.299038, 0.1889822],\n            [0.3273268, 0.8660254, -0.9449112],\n            [-0.8183171, -0.4330127, -0.9449112],\n        ],\n        face: [\n            [0, 3, 1],\n            [2, 4, 5],\n            [0, 1, 4, 2],\n            [0, 2, 5, 3],\n            [1, 3, 5, 4],\n        ],\n    };\n    polyhedra[6] = {\n        vertex: [\n            [0, 0, 1.159953],\n            [1.013464, 0, 0.5642542],\n            [-0.3501431, 0.9510565, 0.5642542],\n            [-0.7715208, -0.6571639, 0.5642542],\n            [0.6633206, 0.9510565, -0.03144481],\n            [0.8682979, -0.6571639, -0.3996071],\n            [-1.121664, 0.2938926, -0.03144481],\n            [-0.2348831, -1.063314, -0.3996071],\n            [0.5181548, 0.2938926, -0.9953061],\n            [-0.5850262, -0.112257, -0.9953061],\n        ],\n        face: [\n            [0, 1, 4, 2],\n            [0, 2, 6, 3],\n            [1, 5, 8, 4],\n            [3, 6, 9, 7],\n            [5, 7, 9, 8],\n            [0, 3, 7, 5, 1],\n            [2, 4, 8, 9, 6],\n        ],\n    };\n    polyhedra[7] = {\n        vertex: [\n            [0, 0, 1.118034],\n            [0.8944272, 0, 0.6708204],\n            [-0.2236068, 0.8660254, 0.6708204],\n            [-0.7826238, -0.4330127, 0.6708204],\n            [0.6708204, 0.8660254, 0.2236068],\n            [1.006231, -0.4330127, -0.2236068],\n            [-1.006231, 0.4330127, 0.2236068],\n            [-0.6708204, -0.8660254, -0.2236068],\n            [0.7826238, 0.4330127, -0.6708204],\n            [0.2236068, -0.8660254, -0.6708204],\n            [-0.8944272, 0, -0.6708204],\n            [0, 0, -1.118034],\n        ],\n        face: [\n            [0, 1, 4, 2],\n            [0, 2, 6, 3],\n            [1, 5, 8, 4],\n            [3, 6, 10, 7],\n            [5, 9, 11, 8],\n            [7, 10, 11, 9],\n            [0, 3, 7, 9, 5, 1],\n            [2, 4, 8, 11, 10, 6],\n        ],\n    };\n    polyhedra[8] = {\n        vertex: [\n            [-0.729665, 0.670121, 0.319155],\n            [-0.655235, -0.29213, -0.754096],\n            [-0.093922, -0.607123, 0.537818],\n            [0.702196, 0.595691, 0.485187],\n            [0.776626, -0.36656, -0.588064],\n        ],\n        face: [\n            [1, 4, 2],\n            [0, 1, 2],\n            [3, 0, 2],\n            [4, 3, 2],\n            [4, 1, 0, 3],\n        ],\n    };\n    polyhedra[9] = {\n        vertex: [\n            [-0.868849, -0.100041, 0.61257],\n            [-0.329458, 0.976099, 0.28078],\n            [-0.26629, -0.013796, -0.477654],\n            [-0.13392, -1.034115, 0.229829],\n            [0.738834, 0.707117, -0.307018],\n            [0.859683, -0.535264, -0.338508],\n        ],\n        face: [\n            [3, 0, 2],\n            [5, 3, 2],\n            [4, 5, 2],\n            [1, 4, 2],\n            [0, 1, 2],\n            [0, 3, 5, 4, 1],\n        ],\n    };\n    polyhedra[10] = {\n        vertex: [\n            [-0.610389, 0.243975, 0.531213],\n            [-0.187812, -0.48795, -0.664016],\n            [-0.187812, 0.9759, -0.664016],\n            [0.187812, -0.9759, 0.664016],\n            [0.798201, 0.243975, 0.132803],\n        ],\n        face: [\n            [1, 3, 0],\n            [3, 4, 0],\n            [3, 1, 4],\n            [0, 2, 1],\n            [0, 4, 2],\n            [2, 4, 1],\n        ],\n    };\n    polyhedra[11] = {\n        vertex: [\n            [-1.028778, 0.392027, -0.048786],\n            [-0.640503, -0.646161, 0.621837],\n            [-0.125162, -0.395663, -0.540059],\n            [0.004683, 0.888447, -0.651988],\n            [0.125161, 0.395663, 0.540059],\n            [0.632925, -0.791376, 0.433102],\n            [1.031672, 0.157063, -0.354165],\n        ],\n        face: [\n            [3, 2, 0],\n            [2, 1, 0],\n            [2, 5, 1],\n            [0, 4, 3],\n            [0, 1, 4],\n            [4, 1, 5],\n            [2, 3, 6],\n            [3, 4, 6],\n            [5, 2, 6],\n            [4, 5, 6],\n        ],\n    };\n    polyhedra[12] = {\n        vertex: [\n            [-0.669867, 0.334933, -0.529576],\n            [-0.669867, 0.334933, 0.529577],\n            [-0.4043, 1.212901, 0],\n            [-0.334933, -0.669867, -0.529576],\n            [-0.334933, -0.669867, 0.529577],\n            [0.334933, 0.669867, -0.529576],\n            [0.334933, 0.669867, 0.529577],\n            [0.4043, -1.212901, 0],\n            [0.669867, -0.334933, -0.529576],\n            [0.669867, -0.334933, 0.529577],\n        ],\n        face: [\n            [8, 9, 7],\n            [6, 5, 2],\n            [3, 8, 7],\n            [5, 0, 2],\n            [4, 3, 7],\n            [0, 1, 2],\n            [9, 4, 7],\n            [1, 6, 2],\n            [9, 8, 5, 6],\n            [8, 3, 0, 5],\n            [3, 4, 1, 0],\n            [4, 9, 6, 1],\n        ],\n    };\n    polyhedra[13] = {\n        vertex: [\n            [-0.931836, 0.219976, -0.264632],\n            [-0.636706, 0.318353, 0.692816],\n            [-0.613483, -0.735083, -0.264632],\n            [-0.326545, 0.979634, 0],\n            [-0.318353, -0.636706, 0.692816],\n            [-0.159176, 0.477529, -0.856368],\n            [0.159176, -0.477529, -0.856368],\n            [0.318353, 0.636706, 0.692816],\n            [0.326545, -0.979634, 0],\n            [0.613482, 0.735082, -0.264632],\n            [0.636706, -0.318353, 0.692816],\n            [0.931835, -0.219977, -0.264632],\n        ],\n        face: [\n            [11, 10, 8],\n            [7, 9, 3],\n            [6, 11, 8],\n            [9, 5, 3],\n            [2, 6, 8],\n            [5, 0, 3],\n            [4, 2, 8],\n            [0, 1, 3],\n            [10, 4, 8],\n            [1, 7, 3],\n            [10, 11, 9, 7],\n            [11, 6, 5, 9],\n            [6, 2, 0, 5],\n            [2, 4, 1, 0],\n            [4, 10, 7, 1],\n        ],\n    };\n    polyhedra[14] = {\n        vertex: [\n            [-0.93465, 0.300459, -0.271185],\n            [-0.838689, -0.260219, -0.516017],\n            [-0.711319, 0.717591, 0.128359],\n            [-0.710334, -0.156922, 0.080946],\n            [-0.599799, 0.556003, -0.725148],\n            [-0.503838, -0.004675, -0.969981],\n            [-0.487004, 0.26021, 0.48049],\n            [-0.460089, -0.750282, -0.512622],\n            [-0.376468, 0.973135, -0.325605],\n            [-0.331735, -0.646985, 0.084342],\n            [-0.254001, 0.831847, 0.530001],\n            [-0.125239, -0.494738, -0.966586],\n            [0.029622, 0.027949, 0.730817],\n            [0.056536, -0.982543, -0.262295],\n            [0.08085, 1.087391, 0.076037],\n            [0.125583, -0.532729, 0.485984],\n            [0.262625, 0.599586, 0.780328],\n            [0.391387, -0.726999, -0.716259],\n            [0.513854, -0.868287, 0.139347],\n            [0.597475, 0.85513, 0.326364],\n            [0.641224, 0.109523, 0.783723],\n            [0.737185, -0.451155, 0.538891],\n            [0.848705, -0.612742, -0.314616],\n            [0.976075, 0.365067, 0.32976],\n            [1.072036, -0.19561, 0.084927],\n        ],\n        face: [\n            [15, 18, 21],\n            [12, 20, 16],\n            [6, 10, 2],\n            [3, 0, 1],\n            [9, 7, 13],\n            [2, 8, 4, 0],\n            [0, 4, 5, 1],\n            [1, 5, 11, 7],\n            [7, 11, 17, 13],\n            [13, 17, 22, 18],\n            [18, 22, 24, 21],\n            [21, 24, 23, 20],\n            [20, 23, 19, 16],\n            [16, 19, 14, 10],\n            [10, 14, 8, 2],\n            [15, 9, 13, 18],\n            [12, 15, 21, 20],\n            [6, 12, 16, 10],\n            [3, 6, 2, 0],\n            [9, 3, 1, 7],\n            [9, 15, 12, 6, 3],\n            [22, 17, 11, 5, 4, 8, 14, 19, 23, 24],\n        ],\n    };\n    var type = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;\n    var size = options.size;\n    var sizeX = options.sizeX || size || 1;\n    var sizeY = options.sizeY || size || 1;\n    var sizeZ = options.sizeZ || size || 1;\n    var data = options.custom || polyhedra[type];\n    var nbfaces = data.face.length;\n    var faceUV = options.faceUV || new Array(nbfaces);\n    var faceColors = options.faceColors;\n    var flat = options.flat === undefined ? true : options.flat;\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    var positions = new Array();\n    var indices = new Array();\n    var normals = new Array();\n    var uvs = new Array();\n    var colors = new Array();\n    var index = 0;\n    var faceIdx = 0; // face cursor in the array \"indexes\"\n    var indexes = new Array();\n    var i = 0;\n    var f = 0;\n    var u, v, ang, x, y, tmp;\n    // default face colors and UV if undefined\n    if (flat) {\n        for (f = 0; f < nbfaces; f++) {\n            if (faceColors && faceColors[f] === undefined) {\n                faceColors[f] = new Color4(1, 1, 1, 1);\n            }\n            if (faceUV && faceUV[f] === undefined) {\n                faceUV[f] = new Vector4(0, 0, 1, 1);\n            }\n        }\n    }\n    if (!flat) {\n        for (i = 0; i < data.vertex.length; i++) {\n            positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);\n            uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0);\n        }\n        for (f = 0; f < nbfaces; f++) {\n            for (i = 0; i < data.face[f].length - 2; i++) {\n                indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);\n            }\n        }\n    }\n    else {\n        for (f = 0; f < nbfaces; f++) {\n            var fl = data.face[f].length; // number of vertices of the current face\n            ang = (2 * Math.PI) / fl;\n            x = 0.5 * Math.tan(ang / 2);\n            y = 0.5;\n            // positions, uvs, colors\n            for (i = 0; i < fl; i++) {\n                // positions\n                positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);\n                indexes.push(index);\n                index++;\n                // uvs\n                u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);\n                v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);\n                uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\n                tmp = x * Math.cos(ang) - y * Math.sin(ang);\n                y = x * Math.sin(ang) + y * Math.cos(ang);\n                x = tmp;\n                // colors\n                if (faceColors) {\n                    colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n                }\n            }\n            // indices from indexes\n            for (i = 0; i < fl - 2; i++) {\n                indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);\n            }\n            faceIdx += fl;\n        }\n    }\n    VertexData.ComputeNormals(positions, indices, normals);\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    var vertexData = new VertexData();\n    vertexData.positions = positions;\n    vertexData.indices = indices;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors && flat) {\n        vertexData.colors = colors;\n    }\n    return vertexData;\n}\n/**\n * Creates a polyhedron mesh\n * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type\n * * The parameter `size` (positive float, default 1) sets the polygon size\n * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)\n * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overrides the parameter `type`\n * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\n * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)\n * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\n * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.type\n * @param options.size\n * @param options.sizeX\n * @param options.sizeY\n * @param options.sizeZ\n * @param options.custom\n * @param options.faceUV\n * @param options.faceColors\n * @param options.flat\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the polyhedron mesh\n * @see https://doc.babylonjs.com/how_to/polyhedra_shapes\n */\nexport function CreatePolyhedron(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    if (scene === void 0) { scene = null; }\n    var polyhedron = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    polyhedron._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreatePolyhedronVertexData(options);\n    vertexData.applyToMesh(polyhedron, options.updatable);\n    return polyhedron;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport var PolyhedronBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreatePolyhedron: CreatePolyhedron,\n};\nVertexData.CreatePolyhedron = CreatePolyhedronVertexData;\nMesh.CreatePolyhedron = function (name, options, scene) {\n    return CreatePolyhedron(name, options, scene);\n};\n//# sourceMappingURL=polyhedronBuilder.js.map","import { TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Mesh, _CreationDataStorage } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Ribbon\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\n * * pathArray array of paths, each of which an array of successive Vector3\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\n * @param options.pathArray\n * @param options.closeArray\n * @param options.closePath\n * @param options.offset\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.invertUV\n * @param options.uvs\n * @param options.colors\n * @returns the VertexData of the ribbon\n */\nexport function CreateRibbonVertexData(options) {\n    var pathArray = options.pathArray;\n    var closeArray = options.closeArray || false;\n    var closePath = options.closePath || false;\n    var invertUV = options.invertUV || false;\n    var defaultOffset = Math.floor(pathArray[0].length / 2);\n    var offset = options.offset || defaultOffset;\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    var customUV = options.uvs;\n    var customColors = options.colors;\n    var positions = [];\n    var indices = [];\n    var normals = [];\n    var uvs = [];\n    var us = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\n    var vs = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\n    var uTotalDistance = []; // uTotalDistance[p] : total distance of path p\n    var vTotalDistance = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\n    var minlg; // minimal length among all paths from pathArray\n    var lg = []; // array of path lengths : nb of vertex per path\n    var idx = []; // array of path indexes : index of each path (first vertex) in the total vertex number\n    var p; // path iterator\n    var i; // point iterator\n    var j; // point iterator\n    // if single path in pathArray\n    if (pathArray.length < 2) {\n        var ar1 = [];\n        var ar2 = [];\n        for (i = 0; i < pathArray[0].length - offset; i++) {\n            ar1.push(pathArray[0][i]);\n            ar2.push(pathArray[0][i + offset]);\n        }\n        pathArray = [ar1, ar2];\n    }\n    // positions and horizontal distances (u)\n    var idc = 0;\n    var closePathCorr = closePath ? 1 : 0; // the final index will be +1 if closePath\n    var path;\n    var l;\n    minlg = pathArray[0].length;\n    var vectlg;\n    var dist;\n    for (p = 0; p < pathArray.length; p++) {\n        uTotalDistance[p] = 0;\n        us[p] = [0];\n        path = pathArray[p];\n        l = path.length;\n        minlg = minlg < l ? minlg : l;\n        j = 0;\n        while (j < l) {\n            positions.push(path[j].x, path[j].y, path[j].z);\n            if (j > 0) {\n                vectlg = path[j].subtract(path[j - 1]).length();\n                dist = vectlg + uTotalDistance[p];\n                us[p].push(dist);\n                uTotalDistance[p] = dist;\n            }\n            j++;\n        }\n        if (closePath) {\n            // an extra hidden vertex is added in the \"positions\" array\n            j--;\n            positions.push(path[0].x, path[0].y, path[0].z);\n            vectlg = path[j].subtract(path[0]).length();\n            dist = vectlg + uTotalDistance[p];\n            us[p].push(dist);\n            uTotalDistance[p] = dist;\n        }\n        lg[p] = l + closePathCorr;\n        idx[p] = idc;\n        idc += l + closePathCorr;\n    }\n    // vertical distances (v)\n    var path1;\n    var path2;\n    var vertex1 = null;\n    var vertex2 = null;\n    for (i = 0; i < minlg + closePathCorr; i++) {\n        vTotalDistance[i] = 0;\n        vs[i] = [0];\n        for (p = 0; p < pathArray.length - 1; p++) {\n            path1 = pathArray[p];\n            path2 = pathArray[p + 1];\n            if (i === minlg) {\n                // closePath\n                vertex1 = path1[0];\n                vertex2 = path2[0];\n            }\n            else {\n                vertex1 = path1[i];\n                vertex2 = path2[i];\n            }\n            vectlg = vertex2.subtract(vertex1).length();\n            dist = vectlg + vTotalDistance[i];\n            vs[i].push(dist);\n            vTotalDistance[i] = dist;\n        }\n        if (closeArray && vertex2 && vertex1) {\n            path1 = pathArray[p];\n            path2 = pathArray[0];\n            if (i === minlg) {\n                // closePath\n                vertex2 = path2[0];\n            }\n            vectlg = vertex2.subtract(vertex1).length();\n            dist = vectlg + vTotalDistance[i];\n            vTotalDistance[i] = dist;\n        }\n    }\n    // uvs\n    var u;\n    var v;\n    if (customUV) {\n        for (p = 0; p < customUV.length; p++) {\n            uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\n        }\n    }\n    else {\n        for (p = 0; p < pathArray.length; p++) {\n            for (i = 0; i < minlg + closePathCorr; i++) {\n                u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\n                v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\n                if (invertUV) {\n                    uvs.push(v, u);\n                }\n                else {\n                    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\n                }\n            }\n        }\n    }\n    // indices\n    p = 0; // path index\n    var pi = 0; // positions array index\n    var l1 = lg[p] - 1; // path1 length\n    var l2 = lg[p + 1] - 1; // path2 length\n    var min = l1 < l2 ? l1 : l2; // current path stop index\n    var shft = idx[1] - idx[0]; // shift\n    var path1nb = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\n    while (pi <= min && p < path1nb) {\n        //  stay under min and don't go over next to last path\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\n        indices.push(pi, pi + shft, pi + 1);\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\n        pi += 1;\n        if (pi === min) {\n            // if end of one of two consecutive paths reached, go to next existing path\n            p++;\n            if (p === lg.length - 1) {\n                // last path of pathArray reached <=> closeArray == true\n                shft = idx[0] - idx[p];\n                l1 = lg[p] - 1;\n                l2 = lg[0] - 1;\n            }\n            else {\n                shft = idx[p + 1] - idx[p];\n                l1 = lg[p] - 1;\n                l2 = lg[p + 1] - 1;\n            }\n            pi = idx[p];\n            min = l1 < l2 ? l1 + pi : l2 + pi;\n        }\n    }\n    // normals\n    VertexData.ComputeNormals(positions, indices, normals);\n    if (closePath) {\n        // update both the first and last vertex normals to their average value\n        var indexFirst = 0;\n        var indexLast = 0;\n        for (p = 0; p < pathArray.length; p++) {\n            indexFirst = idx[p] * 3;\n            if (p + 1 < pathArray.length) {\n                indexLast = (idx[p + 1] - 1) * 3;\n            }\n            else {\n                indexLast = normals.length - 3;\n            }\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n            normals[indexLast] = normals[indexFirst];\n            normals[indexLast + 1] = normals[indexFirst + 1];\n            normals[indexLast + 2] = normals[indexFirst + 2];\n        }\n    }\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Colors\n    var colors = null;\n    if (customColors) {\n        colors = new Float32Array(customColors.length * 4);\n        for (var c = 0; c < customColors.length; c++) {\n            colors[c * 4] = customColors[c].r;\n            colors[c * 4 + 1] = customColors[c].g;\n            colors[c * 4 + 2] = customColors[c].b;\n            colors[c * 4 + 3] = customColors[c].a;\n        }\n    }\n    // Result\n    var vertexData = new VertexData();\n    var positions32 = new Float32Array(positions);\n    var normals32 = new Float32Array(normals);\n    var uvs32 = new Float32Array(uvs);\n    vertexData.indices = indices;\n    vertexData.positions = positions32;\n    vertexData.normals = normals32;\n    vertexData.uvs = uvs32;\n    if (colors) {\n        vertexData.set(colors, VertexBuffer.ColorKind);\n    }\n    if (closePath) {\n        vertexData._idx = idx;\n    }\n    return vertexData;\n}\n/**\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.pathArray\n * @param options.closeArray\n * @param options.closePath\n * @param options.offset\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param options.uvs\n * @param options.colors\n * @param scene defines the hosting scene\n * @returns the ribbon mesh\n * @see https://doc.babylonjs.com/how_to/ribbon_tutorial\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\n */\nexport function CreateRibbon(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var pathArray = options.pathArray;\n    var closeArray = options.closeArray;\n    var closePath = options.closePath;\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    var instance = options.instance;\n    var updatable = options.updatable;\n    if (instance) {\n        // existing ribbon instance update\n        // positionFunction : ribbon case\n        // only pathArray and sideOrientation parameters are taken into account for positions update\n        var minimum_1 = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\n        var maximum_1 = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\n        var positionFunction = function (positions) {\n            var minlg = pathArray[0].length;\n            var mesh = instance;\n            var i = 0;\n            var ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\n            for (var si = 1; si <= ns; ++si) {\n                for (var p = 0; p < pathArray.length; ++p) {\n                    var path = pathArray[p];\n                    var l = path.length;\n                    minlg = minlg < l ? minlg : l;\n                    for (var j = 0; j < minlg; ++j) {\n                        var pathPoint = path[j];\n                        positions[i] = pathPoint.x;\n                        positions[i + 1] = pathPoint.y;\n                        positions[i + 2] = pathPoint.z;\n                        minimum_1.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n                        maximum_1.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n                        i += 3;\n                    }\n                    if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\n                        var pathPoint = path[0];\n                        positions[i] = pathPoint.x;\n                        positions[i + 1] = pathPoint.y;\n                        positions[i + 2] = pathPoint.z;\n                        i += 3;\n                    }\n                }\n            }\n        };\n        var positions = instance.getVerticesData(VertexBuffer.PositionKind);\n        positionFunction(positions);\n        if (instance.hasBoundingInfo) {\n            instance.getBoundingInfo().reConstruct(minimum_1, maximum_1, instance._worldMatrix);\n        }\n        else {\n            instance.buildBoundingInfo(minimum_1, maximum_1, instance._worldMatrix);\n        }\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n        if (options.colors) {\n            var colors = instance.getVerticesData(VertexBuffer.ColorKind);\n            for (var c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\n                var color = options.colors[c];\n                colors[colorIndex] = color.r;\n                colors[colorIndex + 1] = color.g;\n                colors[colorIndex + 2] = color.b;\n                colors[colorIndex + 3] = color.a;\n            }\n            instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\n        }\n        if (options.uvs) {\n            var uvs = instance.getVerticesData(VertexBuffer.UVKind);\n            for (var i = 0; i < options.uvs.length; i++) {\n                uvs[i * 2] = options.uvs[i].x;\n                uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\n            }\n            instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\n        }\n        if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\n            var indices = instance.getIndices();\n            var normals = instance.getVerticesData(VertexBuffer.NormalKind);\n            var params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\n            VertexData.ComputeNormals(positions, indices, normals, params);\n            if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\n                var indexFirst = 0;\n                var indexLast = 0;\n                for (var p = 0; p < pathArray.length; p++) {\n                    indexFirst = instance._creationDataStorage.idx[p] * 3;\n                    if (p + 1 < pathArray.length) {\n                        indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;\n                    }\n                    else {\n                        indexLast = normals.length - 3;\n                    }\n                    normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n                    normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n                    normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n                    normals[indexLast] = normals[indexFirst];\n                    normals[indexLast + 1] = normals[indexFirst + 1];\n                    normals[indexLast + 2] = normals[indexFirst + 2];\n                }\n            }\n            if (!instance.areNormalsFrozen) {\n                instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n            }\n        }\n        return instance;\n    }\n    else {\n        // new ribbon creation\n        var ribbon = new Mesh(name, scene);\n        ribbon._originalBuilderSideOrientation = sideOrientation;\n        ribbon._creationDataStorage = new _CreationDataStorage();\n        var vertexData = CreateRibbonVertexData(options);\n        if (closePath) {\n            ribbon._creationDataStorage.idx = vertexData._idx;\n        }\n        ribbon._creationDataStorage.closePath = closePath;\n        ribbon._creationDataStorage.closeArray = closeArray;\n        vertexData.applyToMesh(ribbon, updatable);\n        return ribbon;\n    }\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateRibbon directly\n */\nexport var RibbonBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateRibbon: CreateRibbon,\n};\nVertexData.CreateRibbon = CreateRibbonVertexData;\nMesh.CreateRibbon = function (name, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {\n    if (closeArray === void 0) { closeArray = false; }\n    if (updatable === void 0) { updatable = false; }\n    return CreateRibbon(name, {\n        pathArray: pathArray,\n        closeArray: closeArray,\n        closePath: closePath,\n        offset: offset,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n        instance: instance,\n    }, scene);\n};\n//# sourceMappingURL=ribbonBuilder.js.map","import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\nimport { Path3D } from \"../../Maths/math.path.js\";\n/**\n * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\n * * The parameter `scale` (float, default 1) is the value to scale the shape.\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.path\n * @param options.scale\n * @param options.rotation\n * @param options.closeShape\n * @param options.closePath\n * @param options.cap\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the extruded shape mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\n */\nexport function ExtrudeShape(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var path = options.path;\n    var shape = options.shape;\n    var scale = options.scale || 1;\n    var rotation = options.rotation || 0;\n    var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n    var updatable = options.updatable;\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    var instance = options.instance || null;\n    var invertUV = options.invertUV || false;\n    var closeShape = options.closeShape || false;\n    var closePath = options.closePath || false;\n    return _ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, closePath, closeShape, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);\n}\n/**\n * Creates an custom extruded shape mesh.\n * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\n * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\n * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\n * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path\n * * It must returns a float value that will be the scale value applied to the shape on each path point\n * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.\n * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.\n * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape\n * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\n * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.path\n * @param options.scaleFunction\n * @param options.rotationFunction\n * @param options.ribbonCloseArray\n * @param options.ribbonClosePath\n * @param options.closeShape\n * @param options.closePath\n * @param options.cap\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the custom extruded shape mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\n */\nexport function ExtrudeShapeCustom(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var path = options.path;\n    var shape = options.shape;\n    var scaleFunction = options.scaleFunction ||\n        (function () {\n            return 1;\n        });\n    var rotationFunction = options.rotationFunction ||\n        (function () {\n            return 0;\n        });\n    var ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;\n    var ribbonClosePath = options.closeShape || options.ribbonClosePath || false;\n    var cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;\n    var updatable = options.updatable;\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    var instance = options.instance;\n    var invertUV = options.invertUV || false;\n    return _ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);\n}\nfunction _ExtrudeShapeGeneric(name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs) {\n    // extrusion geometry\n    var extrusionPathArray = function (shape, curve, path3D, shapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom) {\n        var tangents = path3D.getTangents();\n        var normals = path3D.getNormals();\n        var binormals = path3D.getBinormals();\n        var distances = path3D.getDistances();\n        var angle = 0;\n        var returnScale = function () {\n            return scale !== null ? scale : 1;\n        };\n        var returnRotation = function () {\n            return rotation !== null ? rotation : 0;\n        };\n        var rotate = custom && rotateFunction ? rotateFunction : returnRotation;\n        var scl = custom && scaleFunction ? scaleFunction : returnScale;\n        var index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n        var rotationMatrix = TmpVectors.Matrix[0];\n        for (var i = 0; i < curve.length; i++) {\n            var shapePath = new Array();\n            var angleStep = rotate(i, distances[i]);\n            var scaleRatio = scl(i, distances[i]);\n            for (var p = 0; p < shape.length; p++) {\n                Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\n                var planed = tangents[i].scale(shape[p].z).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y));\n                var rotated = shapePath[p] ? shapePath[p] : Vector3.Zero();\n                Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\n                rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\n                shapePath[p] = rotated;\n            }\n            shapePaths[index] = shapePath;\n            angle += angleStep;\n            index++;\n        }\n        // cap\n        var capPath = function (shapePath) {\n            var pointCap = Array();\n            var barycenter = Vector3.Zero();\n            var i;\n            for (i = 0; i < shapePath.length; i++) {\n                barycenter.addInPlace(shapePath[i]);\n            }\n            barycenter.scaleInPlace(1.0 / shapePath.length);\n            for (i = 0; i < shapePath.length; i++) {\n                pointCap.push(barycenter);\n            }\n            return pointCap;\n        };\n        switch (cap) {\n            case Mesh.NO_CAP:\n                break;\n            case Mesh.CAP_START:\n                shapePaths[0] = capPath(shapePaths[2]);\n                shapePaths[1] = shapePaths[2];\n                break;\n            case Mesh.CAP_END:\n                shapePaths[index] = shapePaths[index - 1];\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n                break;\n            case Mesh.CAP_ALL:\n                shapePaths[0] = capPath(shapePaths[2]);\n                shapePaths[1] = shapePaths[2];\n                shapePaths[index] = shapePaths[index - 1];\n                shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n                break;\n            default:\n                break;\n        }\n        return shapePaths;\n    };\n    var path3D;\n    var pathArray;\n    if (instance) {\n        // instance update\n        var storage = instance._creationDataStorage;\n        path3D = storage.path3D.update(curve);\n        pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\n        instance = CreateRibbon(\"\", { pathArray: pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance: instance }, scene || undefined);\n        return instance;\n    }\n    // extruded shape creation\n    path3D = new Path3D(curve);\n    var newShapePaths = new Array();\n    cap = cap < 0 || cap > 3 ? 0 : cap;\n    pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\n    var extrudedGeneric = CreateRibbon(name, {\n        pathArray: pathArray,\n        closeArray: rbCA,\n        closePath: rbCP,\n        updatable: updtbl,\n        sideOrientation: side,\n        invertUV: invertUV,\n        frontUVs: frontUVs || undefined,\n        backUVs: backUVs || undefined,\n    }, scene);\n    extrudedGeneric._creationDataStorage.pathArray = pathArray;\n    extrudedGeneric._creationDataStorage.path3D = path3D;\n    extrudedGeneric._creationDataStorage.cap = cap;\n    return extrudedGeneric;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use the functions directly from the module\n */\nexport var ShapeBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ExtrudeShape: ExtrudeShape,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ExtrudeShapeCustom: ExtrudeShapeCustom,\n};\nMesh.ExtrudeShape = function (name, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {\n    if (scene === void 0) { scene = null; }\n    var options = {\n        shape: shape,\n        path: path,\n        scale: scale,\n        rotation: rotation,\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n        sideOrientation: sideOrientation,\n        instance: instance,\n        updatable: updatable,\n    };\n    return ExtrudeShape(name, options, scene);\n};\nMesh.ExtrudeShapeCustom = function (name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {\n    var options = {\n        shape: shape,\n        path: path,\n        scaleFunction: scaleFunction,\n        rotationFunction: rotationFunction,\n        ribbonCloseArray: ribbonCloseArray,\n        ribbonClosePath: ribbonClosePath,\n        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,\n        sideOrientation: sideOrientation,\n        instance: instance,\n        updatable: updatable,\n    };\n    return ExtrudeShapeCustom(name, options, scene);\n};\n//# sourceMappingURL=shapeBuilder.js.map","import { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for an ellipsoid, defaults to a sphere\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * segments sets the number of horizontal strips optional, default 32\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.segments\n * @param options.diameter\n * @param options.diameterX\n * @param options.diameterY\n * @param options.diameterZ\n * @param options.arc\n * @param options.slice\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.dedupTopBottomIndices\n * @returns the VertexData of the ellipsoid\n */\nexport function CreateSphereVertexData(options) {\n    var segments = options.segments || 32;\n    var diameterX = options.diameterX || options.diameter || 1;\n    var diameterY = options.diameterY || options.diameter || 1;\n    var diameterZ = options.diameterZ || options.diameter || 1;\n    var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n    var slice = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    var dedupTopBottomIndices = !!options.dedupTopBottomIndices;\n    var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\n    var totalZRotationSteps = 2 + segments;\n    var totalYRotationSteps = 2 * totalZRotationSteps;\n    var indices = [];\n    var positions = [];\n    var normals = [];\n    var uvs = [];\n    for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n        var normalizedZ = zRotationStep / totalZRotationSteps;\n        var angleZ = normalizedZ * Math.PI * slice;\n        for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n            var normalizedY = yRotationStep / totalYRotationSteps;\n            var angleY = normalizedY * Math.PI * 2 * arc;\n            var rotationZ = Matrix.RotationZ(-angleZ);\n            var rotationY = Matrix.RotationY(angleY);\n            var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\n            var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\n            var vertex = complete.multiply(radius);\n            var normal = complete.divide(radius).normalize();\n            positions.push(vertex.x, vertex.y, vertex.z);\n            normals.push(normal.x, normal.y, normal.z);\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\n        }\n        if (zRotationStep > 0) {\n            var verticesCount = positions.length / 3;\n            for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\n                if (dedupTopBottomIndices) {\n                    if (zRotationStep > 1) {\n                        indices.push(firstIndex);\n                        indices.push(firstIndex + 1);\n                        indices.push(firstIndex + totalYRotationSteps + 1);\n                    }\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\n                        indices.push(firstIndex + totalYRotationSteps + 1);\n                        indices.push(firstIndex + 1);\n                        indices.push(firstIndex + totalYRotationSteps + 2);\n                    }\n                }\n                else {\n                    indices.push(firstIndex);\n                    indices.push(firstIndex + 1);\n                    indices.push(firstIndex + totalYRotationSteps + 1);\n                    indices.push(firstIndex + totalYRotationSteps + 1);\n                    indices.push(firstIndex + 1);\n                    indices.push(firstIndex + totalYRotationSteps + 2);\n                }\n            }\n        }\n    }\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a sphere mesh\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.segments\n * @param options.diameter\n * @param options.diameterX\n * @param options.diameterY\n * @param options.diameterZ\n * @param options.arc\n * @param options.slice\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the sphere mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\n */\nexport function CreateSphere(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    if (scene === void 0) { scene = null; }\n    var sphere = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateSphereVertexData(options);\n    vertexData.applyToMesh(sphere, options.updatable);\n    return sphere;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateSphere directly\n */\nexport var SphereBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateSphere: CreateSphere,\n};\nVertexData.CreateSphere = CreateSphereVertexData;\nMesh.CreateSphere = function (name, segments, diameter, scene, updatable, sideOrientation) {\n    var options = {\n        segments: segments,\n        diameterX: diameter,\n        diameterY: diameter,\n        diameterZ: diameter,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreateSphere(name, options, scene);\n};\n//# sourceMappingURL=sphereBuilder.js.map","import { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a tiled box\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_box\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * @param options.pattern\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.faceUV\n * @param options.faceColors\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @returns the VertexData of the TiledBox\n */\nexport function CreateTiledBoxVertexData(options) {\n    var nbFaces = 6;\n    var faceUV = options.faceUV || new Array(6);\n    var faceColors = options.faceColors;\n    var flipTile = options.pattern || Mesh.NO_FLIP;\n    var width = options.width || options.size || 1;\n    var height = options.height || options.size || 1;\n    var depth = options.depth || options.size || 1;\n    var tileWidth = options.tileWidth || options.tileSize || 1;\n    var tileHeight = options.tileHeight || options.tileSize || 1;\n    var alignH = options.alignHorizontal || 0;\n    var alignV = options.alignVertical || 0;\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // default face colors and UV if undefined\n    for (var f = 0; f < nbFaces; f++) {\n        if (faceUV[f] === undefined) {\n            faceUV[f] = new Vector4(0, 0, 1, 1);\n        }\n        if (faceColors && faceColors[f] === undefined) {\n            faceColors[f] = new Color4(1, 1, 1, 1);\n        }\n    }\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var halfDepth = depth / 2;\n    var faceVertexData = [];\n    for (var f = 0; f < 2; f++) {\n        //front and back\n        faceVertexData[f] = CreateTiledPlaneVertexData({\n            pattern: flipTile,\n            tileWidth: tileWidth,\n            tileHeight: tileHeight,\n            width: width,\n            height: height,\n            alignVertical: alignV,\n            alignHorizontal: alignH,\n            sideOrientation: sideOrientation,\n        });\n    }\n    for (var f = 2; f < 4; f++) {\n        //sides\n        faceVertexData[f] = CreateTiledPlaneVertexData({\n            pattern: flipTile,\n            tileWidth: tileWidth,\n            tileHeight: tileHeight,\n            width: depth,\n            height: height,\n            alignVertical: alignV,\n            alignHorizontal: alignH,\n            sideOrientation: sideOrientation,\n        });\n    }\n    var baseAlignV = alignV;\n    if (alignV === Mesh.BOTTOM) {\n        baseAlignV = Mesh.TOP;\n    }\n    else if (alignV === Mesh.TOP) {\n        baseAlignV = Mesh.BOTTOM;\n    }\n    for (var f = 4; f < 6; f++) {\n        //top and bottom\n        faceVertexData[f] = CreateTiledPlaneVertexData({\n            pattern: flipTile,\n            tileWidth: tileWidth,\n            tileHeight: tileHeight,\n            width: width,\n            height: depth,\n            alignVertical: baseAlignV,\n            alignHorizontal: alignH,\n            sideOrientation: sideOrientation,\n        });\n    }\n    var positions = [];\n    var normals = [];\n    var uvs = [];\n    var indices = [];\n    var colors = [];\n    var facePositions = [];\n    var faceNormals = [];\n    var newFaceUV = [];\n    var lu = 0;\n    var li = 0;\n    for (var f = 0; f < nbFaces; f++) {\n        var len = faceVertexData[f].positions.length;\n        facePositions[f] = [];\n        faceNormals[f] = [];\n        for (var p = 0; p < len / 3; p++) {\n            facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));\n            faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));\n        }\n        // uvs\n        lu = faceVertexData[f].uvs.length;\n        newFaceUV[f] = [];\n        for (var i = 0; i < lu; i += 2) {\n            newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];\n            newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\n            }\n        }\n        uvs = uvs.concat(newFaceUV[f]);\n        indices = indices.concat(faceVertexData[f].indices.map(function (x) { return x + li; }));\n        li += facePositions[f].length;\n        if (faceColors) {\n            for (var c = 0; c < 4; c++) {\n                colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n            }\n        }\n    }\n    var vec0 = new Vector3(0, 0, halfDepth);\n    var mtrx0 = Matrix.RotationY(Math.PI);\n    positions = facePositions[0]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx0).add(vec0); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []);\n    normals = faceNormals[0]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx0); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []);\n    positions = positions.concat(facePositions[1]\n        .map(function (entry) { return entry.subtract(vec0); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    normals = normals.concat(faceNormals[1].map(function (entry) { return [entry.x, entry.y, entry.z]; }).reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    var vec2 = new Vector3(halfWidth, 0, 0);\n    var mtrx2 = Matrix.RotationY(-Math.PI / 2);\n    positions = positions.concat(facePositions[2]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx2).add(vec2); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    normals = normals.concat(faceNormals[2]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx2); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    var mtrx3 = Matrix.RotationY(Math.PI / 2);\n    positions = positions.concat(facePositions[3]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx3).subtract(vec2); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    normals = normals.concat(faceNormals[3]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx3); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    var vec4 = new Vector3(0, halfHeight, 0);\n    var mtrx4 = Matrix.RotationX(Math.PI / 2);\n    positions = positions.concat(facePositions[4]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx4).add(vec4); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    normals = normals.concat(faceNormals[4]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx4); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    var mtrx5 = Matrix.RotationX(-Math.PI / 2);\n    positions = positions.concat(facePositions[5]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx5).subtract(vec4); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    normals = normals.concat(faceNormals[5]\n        .map(function (entry) { return Vector3.TransformNormal(entry, mtrx5); })\n        .map(function (entry) { return [entry.x, entry.y, entry.z]; })\n        .reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []));\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    if (faceColors) {\n        var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n        vertexData.colors = totalColors;\n    }\n    return vertexData;\n}\n/**\n * Creates a tiled box mesh\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_box\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @param options.pattern\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateTiledBox(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var box = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    box._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateTiledBoxVertexData(options);\n    vertexData.applyToMesh(box, options.updatable);\n    return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledBox instead\n */\nexport var TiledBoxBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTiledBox: CreateTiledBox,\n};\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;\n//# sourceMappingURL=tiledBoxBuilder.js.map","import { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\n/**\n * Creates the VertexData for a tiled plane\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_plane\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @returns the VertexData of the tiled plane\n */\nexport function CreateTiledPlaneVertexData(options) {\n    var flipTile = options.pattern || Mesh.NO_FLIP;\n    var tileWidth = options.tileWidth || options.tileSize || 1;\n    var tileHeight = options.tileHeight || options.tileSize || 1;\n    var alignH = options.alignHorizontal || 0;\n    var alignV = options.alignVertical || 0;\n    var width = options.width || options.size || 1;\n    var tilesX = Math.floor(width / tileWidth);\n    var offsetX = width - tilesX * tileWidth;\n    var height = options.height || options.size || 1;\n    var tilesY = Math.floor(height / tileHeight);\n    var offsetY = height - tilesY * tileHeight;\n    var halfWidth = (tileWidth * tilesX) / 2;\n    var halfHeight = (tileHeight * tilesY) / 2;\n    var adjustX = 0;\n    var adjustY = 0;\n    var startX = 0;\n    var startY = 0;\n    var endX = 0;\n    var endY = 0;\n    //Part Tiles\n    if (offsetX > 0 || offsetY > 0) {\n        startX = -halfWidth;\n        startY = -halfHeight;\n        endX = halfWidth;\n        endY = halfHeight;\n        switch (alignH) {\n            case Mesh.CENTER:\n                offsetX /= 2;\n                startX -= offsetX;\n                endX += offsetX;\n                break;\n            case Mesh.LEFT:\n                endX += offsetX;\n                adjustX = -offsetX / 2;\n                break;\n            case Mesh.RIGHT:\n                startX -= offsetX;\n                adjustX = offsetX / 2;\n                break;\n        }\n        switch (alignV) {\n            case Mesh.CENTER:\n                offsetY /= 2;\n                startY -= offsetY;\n                endY += offsetY;\n                break;\n            case Mesh.BOTTOM:\n                endY += offsetY;\n                adjustY = -offsetY / 2;\n                break;\n            case Mesh.TOP:\n                startY -= offsetY;\n                adjustY = offsetY / 2;\n                break;\n        }\n    }\n    var positions = [];\n    var normals = [];\n    var uvBase = [];\n    uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\n    uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\n    if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\n    }\n    if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\n    }\n    if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\n    }\n    var uvs = [];\n    var colors = [];\n    var indices = [];\n    var index = 0;\n    for (var y = 0; y < tilesY; y++) {\n        for (var x = 0; x < tilesX; x++) {\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                uvs = uvs.concat(uvBase[((x % 2) + (y % 2)) % 2]);\n            }\n            else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvs = uvs.concat(uvBase[y % 2]);\n            }\n            else {\n                uvs = uvs.concat(uvBase[0]);\n            }\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            index += 4;\n        }\n    }\n    //Part Tiles\n    if (offsetX > 0 || offsetY > 0) {\n        var partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\n        var partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\n        var partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\n        var partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\n        var uvPart = [];\n        var a = void 0, b = void 0, c = void 0, d = void 0;\n        //corners\n        if (partialBottomRow && partialLeftCol) {\n            //bottom left corner\n            positions.push(startX + adjustX, startY + adjustY, 0);\n            positions.push(-halfWidth + adjustX, startY + adjustY, 0);\n            positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\n            positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            index += 4;\n            a = 1 - offsetX / tileWidth;\n            b = 1 - offsetY / tileHeight;\n            c = 1;\n            d = 1;\n            uvPart = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_ROW) {\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_ROW) {\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            uvs = uvs.concat(uvPart);\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n        }\n        if (partialBottomRow && partialRightCol) {\n            //bottom right corner\n            positions.push(halfWidth + adjustX, startY + adjustY, 0);\n            positions.push(endX + adjustX, startY + adjustY, 0);\n            positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\n            positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            index += 4;\n            a = 0;\n            b = 1 - offsetY / tileHeight;\n            c = offsetX / tileWidth;\n            d = 1;\n            uvPart = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_ROW || (flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0)) {\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_ROW || (flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0)) {\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0)) {\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            uvs = uvs.concat(uvPart);\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n        }\n        if (partialTopRow && partialLeftCol) {\n            //top left corner\n            positions.push(startX + adjustX, halfHeight + adjustY, 0);\n            positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\n            positions.push(-halfWidth + adjustX, endY + adjustY, 0);\n            positions.push(startX + adjustX, endY + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            index += 4;\n            a = 1 - offsetX / tileWidth;\n            b = 0;\n            c = 1;\n            d = offsetY / tileHeight;\n            uvPart = [a, b, c, b, c, d, a, d];\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0)) {\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0)) {\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0)) {\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            uvs = uvs.concat(uvPart);\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n        }\n        if (partialTopRow && partialRightCol) {\n            //top right corner\n            positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\n            positions.push(endX + adjustX, halfHeight + adjustY, 0);\n            positions.push(endX + adjustX, endY + adjustY, 0);\n            positions.push(halfWidth + adjustX, endY + adjustY, 0);\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n            index += 4;\n            a = 0;\n            b = 0;\n            c = offsetX / tileWidth;\n            d = offsetY / tileHeight;\n            uvPart = [a, b, c, b, c, d, a, d];\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1)) {\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            uvs = uvs.concat(uvPart);\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n        }\n        //part rows\n        if (partialBottomRow) {\n            var uvBaseBR = [];\n            a = 0;\n            b = 1 - offsetY / tileHeight;\n            c = 1;\n            d = 1;\n            uvBaseBR[0] = [a, b, c, b, c, d, a, d];\n            uvBaseBR[1] = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n                uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n                uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            for (var x = 0; x < tilesX; x++) {\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n                index += 4;\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                    uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\n                }\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                    uvs = uvs.concat(uvBaseBR[1]);\n                }\n                else {\n                    uvs = uvs.concat(uvBaseBR[0]);\n                }\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            }\n        }\n        if (partialTopRow) {\n            var uvBaseTR = [];\n            a = 0;\n            b = 0;\n            c = 1;\n            d = offsetY / tileHeight;\n            uvBaseTR[0] = [a, b, c, b, c, d, a, d];\n            uvBaseTR[1] = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n                uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n                uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            for (var x = 0; x < tilesX; x++) {\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n                index += 4;\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                    uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\n                }\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                    uvs = uvs.concat(uvBaseTR[tilesY % 2]);\n                }\n                else {\n                    uvs = uvs.concat(uvBaseTR[0]);\n                }\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            }\n        }\n        if (partialLeftCol) {\n            var uvBaseLC = [];\n            a = 1 - offsetX / tileWidth;\n            b = 0;\n            c = 1;\n            d = 1;\n            uvBaseLC[0] = [a, b, c, b, c, d, a, d];\n            uvBaseLC[1] = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n                uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n                uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            for (var y = 0; y < tilesY; y++) {\n                positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n                positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n                positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n                positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n                index += 4;\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                    uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\n                }\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                    uvs = uvs.concat(uvBaseLC[y % 2]);\n                }\n                else {\n                    uvs = uvs.concat(uvBaseLC[0]);\n                }\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            }\n        }\n        if (partialRightCol) {\n            var uvBaseRC = [];\n            a = 0;\n            b = 0;\n            c = offsetX / tileHeight;\n            d = 1;\n            uvBaseRC[0] = [a, b, c, b, c, d, a, d];\n            uvBaseRC[1] = [a, b, c, b, c, d, a, d];\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n                uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n            }\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n                uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n            }\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n            }\n            for (var y = 0; y < tilesY; y++) {\n                positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n                positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n                positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n                positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n                index += 4;\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n                    uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\n                }\n                else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n                    uvs = uvs.concat(uvBaseRC[y % 2]);\n                }\n                else {\n                    uvs = uvs.concat(uvBaseRC[0]);\n                }\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n            }\n        }\n    }\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n    return vertexData;\n}\n/**\n * Creates a tiled plane mesh\n * @see https://doc.babylonjs.com/divingDeeper/mesh/creation/set/tiled_plane\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateTiledPlane(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var plane = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    plane._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateTiledPlaneVertexData(options);\n    vertexData.applyToMesh(plane, options.updatable);\n    return plane;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledPlane instead\n */\nexport var TiledPlaneBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTiledPlane: CreateTiledPlane,\n};\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;\n//# sourceMappingURL=tiledPlaneBuilder.js.map","import { Matrix, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a torus\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * diameter the diameter of the torus, optional default 1\n * * thickness the diameter of the tube forming the torus, optional default 0.5\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.diameter\n * @param options.thickness\n * @param options.tessellation\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the torus\n */\nexport function CreateTorusVertexData(options) {\n    var indices = [];\n    var positions = [];\n    var normals = [];\n    var uvs = [];\n    var diameter = options.diameter || 1;\n    var thickness = options.thickness || 0.5;\n    var tessellation = options.tessellation || 16;\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    var stride = tessellation + 1;\n    for (var i = 0; i <= tessellation; i++) {\n        var u = i / tessellation;\n        var outerAngle = (i * Math.PI * 2.0) / tessellation - Math.PI / 2.0;\n        var transform = Matrix.Translation(diameter / 2.0, 0, 0).multiply(Matrix.RotationY(outerAngle));\n        for (var j = 0; j <= tessellation; j++) {\n            var v = 1 - j / tessellation;\n            var innerAngle = (j * Math.PI * 2.0) / tessellation + Math.PI;\n            var dx = Math.cos(innerAngle);\n            var dy = Math.sin(innerAngle);\n            // Create a vertex.\n            var normal = new Vector3(dx, dy, 0);\n            var position = normal.scale(thickness / 2);\n            var textureCoordinate = new Vector2(u, v);\n            position = Vector3.TransformCoordinates(position, transform);\n            normal = Vector3.TransformNormal(normal, transform);\n            positions.push(position.x, position.y, position.z);\n            normals.push(normal.x, normal.y, normal.z);\n            uvs.push(textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - textureCoordinate.y : textureCoordinate.y);\n            // And create indices for two triangles.\n            var nextI = (i + 1) % stride;\n            var nextJ = (j + 1) % stride;\n            indices.push(i * stride + j);\n            indices.push(i * stride + nextJ);\n            indices.push(nextI * stride + j);\n            indices.push(i * stride + nextJ);\n            indices.push(nextI * stride + nextJ);\n            indices.push(nextI * stride + j);\n        }\n    }\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a torus mesh\n * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)\n * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\n * * The parameter `tessellation` sets the number of torus sides (positive integer, default 16)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.diameter\n * @param options.thickness\n * @param options.tessellation\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the torus mesh\n * @see https://doc.babylonjs.com/how_to/set_shapes#torus\n */\nexport function CreateTorus(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    var torus = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    torus._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateTorusVertexData(options);\n    vertexData.applyToMesh(torus, options.updatable);\n    return torus;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTorus instead\n */\nexport var TorusBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTorus: CreateTorus,\n};\nVertexData.CreateTorus = CreateTorusVertexData;\nMesh.CreateTorus = function (name, diameter, thickness, tessellation, scene, updatable, sideOrientation) {\n    var options = {\n        diameter: diameter,\n        thickness: thickness,\n        tessellation: tessellation,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreateTorus(name, options, scene);\n};\n//# sourceMappingURL=torusBuilder.js.map","import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n/**\n * Creates the VertexData for a TorusKnot\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n * * radius the radius of the torus knot, optional, default 2\n * * tube the thickness of the tube, optional, default 0.5\n * * radialSegments the number of sides on each tube segments, optional, default 32\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n * * p the number of windings around the z axis, optional,  default 2\n * * q the number of windings around the x axis, optional,  default 3\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the Torus Knot\n */\nexport function CreateTorusKnotVertexData(options) {\n    var indices = new Array();\n    var positions = new Array();\n    var normals = new Array();\n    var uvs = new Array();\n    var radius = options.radius || 2;\n    var tube = options.tube || 0.5;\n    var radialSegments = options.radialSegments || 32;\n    var tubularSegments = options.tubularSegments || 32;\n    var p = options.p || 2;\n    var q = options.q || 3;\n    var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n    // Helper\n    var getPos = function (angle) {\n        var cu = Math.cos(angle);\n        var su = Math.sin(angle);\n        var quOverP = (q / p) * angle;\n        var cs = Math.cos(quOverP);\n        var tx = radius * (2 + cs) * 0.5 * cu;\n        var ty = radius * (2 + cs) * su * 0.5;\n        var tz = radius * Math.sin(quOverP) * 0.5;\n        return new Vector3(tx, ty, tz);\n    };\n    // Vertices\n    var i;\n    var j;\n    for (i = 0; i <= radialSegments; i++) {\n        var modI = i % radialSegments;\n        var u = (modI / radialSegments) * 2 * p * Math.PI;\n        var p1 = getPos(u);\n        var p2 = getPos(u + 0.01);\n        var tang = p2.subtract(p1);\n        var n = p2.add(p1);\n        var bitan = Vector3.Cross(tang, n);\n        n = Vector3.Cross(bitan, tang);\n        bitan.normalize();\n        n.normalize();\n        for (j = 0; j < tubularSegments; j++) {\n            var modJ = j % tubularSegments;\n            var v = (modJ / tubularSegments) * 2 * Math.PI;\n            var cx = -tube * Math.cos(v);\n            var cy = tube * Math.sin(v);\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\n            uvs.push(i / radialSegments);\n            uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\n        }\n    }\n    for (i = 0; i < radialSegments; i++) {\n        for (j = 0; j < tubularSegments; j++) {\n            var jNext = (j + 1) % tubularSegments;\n            var a = i * tubularSegments + j;\n            var b = (i + 1) * tubularSegments + j;\n            var c = (i + 1) * tubularSegments + jNext;\n            var d = i * tubularSegments + jNext;\n            indices.push(d);\n            indices.push(b);\n            indices.push(a);\n            indices.push(d);\n            indices.push(c);\n            indices.push(b);\n        }\n    }\n    // Normals\n    VertexData.ComputeNormals(positions, indices, normals);\n    // Sides\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n    // Result\n    var vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.normals = normals;\n    vertexData.uvs = uvs;\n    return vertexData;\n}\n/**\n * Creates a torus knot mesh\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the torus knot mesh\n * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\n */\nexport function CreateTorusKnot(name, options, scene) {\n    if (options === void 0) { options = {}; }\n    var torusKnot = new Mesh(name, scene);\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\n    var vertexData = CreateTorusKnotVertexData(options);\n    vertexData.applyToMesh(torusKnot, options.updatable);\n    return torusKnot;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTorusKnot instead\n */\nexport var TorusKnotBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTorusKnot: CreateTorusKnot,\n};\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\nMesh.CreateTorusKnot = function (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {\n    var options = {\n        radius: radius,\n        tube: tube,\n        radialSegments: radialSegments,\n        tubularSegments: tubularSegments,\n        p: p,\n        q: q,\n        sideOrientation: sideOrientation,\n        updatable: updatable,\n    };\n    return CreateTorusKnot(name, options, scene);\n};\n//# sourceMappingURL=torusKnotBuilder.js.map","import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\nimport { Path3D } from \"../../Maths/math.path.js\";\n/**\n * Creates a tube mesh.\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.path\n * @param options.radius\n * @param options.tessellation\n * @param options.radiusFunction\n * @param options.cap\n * @param options.arc\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the tube mesh\n * @see https://doc.babylonjs.com/how_to/parametric_shapes\n * @see https://doc.babylonjs.com/how_to/set_shapes#tube\n */\nexport function CreateTube(name, options, scene) {\n    if (scene === void 0) { scene = null; }\n    var path = options.path;\n    var instance = options.instance;\n    var radius = 1.0;\n    if (options.radius !== undefined) {\n        radius = options.radius;\n    }\n    else if (instance) {\n        radius = instance._creationDataStorage.radius;\n    }\n    var tessellation = options.tessellation || 64 | 0;\n    var radiusFunction = options.radiusFunction || null;\n    var cap = options.cap || Mesh.NO_CAP;\n    var invertUV = options.invertUV || false;\n    var updatable = options.updatable;\n    var sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n    options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\n    // tube geometry\n    var tubePathArray = function (path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) {\n        var tangents = path3D.getTangents();\n        var normals = path3D.getNormals();\n        var distances = path3D.getDistances();\n        var pi2 = Math.PI * 2;\n        var step = (pi2 / tessellation) * arc;\n        var returnRadius = function () { return radius; };\n        var radiusFunctionFinal = radiusFunction || returnRadius;\n        var circlePath;\n        var rad;\n        var normal;\n        var rotated;\n        var rotationMatrix = TmpVectors.Matrix[0];\n        var index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n        for (var i = 0; i < path.length; i++) {\n            rad = radiusFunctionFinal(i, distances[i]); // current radius\n            circlePath = Array(); // current circle array\n            normal = normals[i]; // current normal\n            for (var t = 0; t < tessellation; t++) {\n                Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\n                rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\n                Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\n                rotated.scaleInPlace(rad).addInPlace(path[i]);\n                circlePath[t] = rotated;\n            }\n            circlePaths[index] = circlePath;\n            index++;\n        }\n        // cap\n        var capPath = function (nbPoints, pathIndex) {\n            var pointCap = Array();\n            for (var i = 0; i < nbPoints; i++) {\n                pointCap.push(path[pathIndex]);\n            }\n            return pointCap;\n        };\n        switch (cap) {\n            case Mesh.NO_CAP:\n                break;\n            case Mesh.CAP_START:\n                circlePaths[0] = capPath(tessellation, 0);\n                circlePaths[1] = circlePaths[2].slice(0);\n                break;\n            case Mesh.CAP_END:\n                circlePaths[index] = circlePaths[index - 1].slice(0);\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n                break;\n            case Mesh.CAP_ALL:\n                circlePaths[0] = capPath(tessellation, 0);\n                circlePaths[1] = circlePaths[2].slice(0);\n                circlePaths[index] = circlePaths[index - 1].slice(0);\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n                break;\n            default:\n                break;\n        }\n        return circlePaths;\n    };\n    var path3D;\n    var pathArray;\n    if (instance) {\n        // tube update\n        var storage = instance._creationDataStorage;\n        var arc = options.arc || storage.arc;\n        path3D = storage.path3D.update(path);\n        pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\n        instance = CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\n        // Update mode, no need to recreate the storage.\n        storage.path3D = path3D;\n        storage.pathArray = pathArray;\n        storage.arc = arc;\n        storage.radius = radius;\n        return instance;\n    }\n    // tube creation\n    path3D = new Path3D(path);\n    var newPathArray = new Array();\n    cap = cap < 0 || cap > 3 ? 0 : cap;\n    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\n    var tube = CreateRibbon(name, {\n        pathArray: pathArray,\n        closePath: true,\n        closeArray: false,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n        invertUV: invertUV,\n        frontUVs: options.frontUVs,\n        backUVs: options.backUVs,\n    }, scene);\n    tube._creationDataStorage.pathArray = pathArray;\n    tube._creationDataStorage.path3D = path3D;\n    tube._creationDataStorage.tessellation = tessellation;\n    tube._creationDataStorage.cap = cap;\n    tube._creationDataStorage.arc = options.arc;\n    tube._creationDataStorage.radius = radius;\n    return tube;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTube directly\n */\nexport var TubeBuilder = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CreateTube: CreateTube,\n};\nMesh.CreateTube = function (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {\n    var options = {\n        path: path,\n        radius: radius,\n        tessellation: tessellation,\n        radiusFunction: radiusFunction,\n        arc: 1,\n        cap: cap,\n        updatable: updatable,\n        sideOrientation: sideOrientation,\n        instance: instance,\n    };\n    return CreateTube(name, options, scene);\n};\n//# sourceMappingURL=tubeBuilder.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Tools } from \"../../Misc/tools.js\";\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\nfunction createDecoderAsync(wasmBinary) {\n    return new Promise(function (resolve) {\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then(function (module) {\n            resolve({ module: module });\n        });\n    });\n}\nfunction decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData, dividers) {\n    var buffer = new decoderModule.DecoderBuffer();\n    buffer.Init(dataView, dataView.byteLength);\n    var decoder = new decoderModule.Decoder();\n    var geometry;\n    var status;\n    try {\n        var type = decoder.GetEncodedGeometryType(buffer);\n        switch (type) {\n            case decoderModule.TRIANGULAR_MESH:\n                geometry = new decoderModule.Mesh();\n                status = decoder.DecodeBufferToMesh(buffer, geometry);\n                break;\n            case decoderModule.POINT_CLOUD:\n                geometry = new decoderModule.PointCloud();\n                status = decoder.DecodeBufferToPointCloud(buffer, geometry);\n                break;\n            default:\n                throw new Error(\"Invalid geometry type \".concat(type));\n        }\n        if (!status.ok() || !geometry.ptr) {\n            throw new Error(status.error_msg());\n        }\n        if (type === decoderModule.TRIANGULAR_MESH) {\n            var numFaces = geometry.num_faces();\n            var numIndices = numFaces * 3;\n            var byteLength = numIndices * 4;\n            var ptr = decoderModule._malloc(byteLength);\n            try {\n                decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\n                var indices = new Uint32Array(numIndices);\n                indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n                onIndicesData(indices);\n            }\n            finally {\n                decoderModule._free(ptr);\n            }\n        }\n        var processAttribute = function (kind, attribute, divider) {\n            if (divider === void 0) { divider = 1; }\n            var numComponents = attribute.num_components();\n            var numPoints = geometry.num_points();\n            var numValues = numPoints * numComponents;\n            var byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\n            var ptr = decoderModule._malloc(byteLength);\n            try {\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\n                var values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\n                if (kind === \"color\" && numComponents === 3) {\n                    var babylonData = new Float32Array(numPoints * 4);\n                    for (var i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\n                        babylonData[i + 0] = values[j + 0];\n                        babylonData[i + 1] = values[j + 1];\n                        babylonData[i + 2] = values[j + 2];\n                        babylonData[i + 3] = 1;\n                    }\n                    onAttributeData(kind, babylonData);\n                }\n                else {\n                    var babylonData = new Float32Array(numValues);\n                    babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\n                    if (divider !== 1) {\n                        for (var i = 0; i < babylonData.length; i++) {\n                            babylonData[i] = babylonData[i] / divider;\n                        }\n                    }\n                    onAttributeData(kind, babylonData);\n                }\n            }\n            finally {\n                decoderModule._free(ptr);\n            }\n        };\n        if (attributes) {\n            for (var kind in attributes) {\n                var id = attributes[kind];\n                var attribute = decoder.GetAttributeByUniqueId(geometry, id);\n                var divider = (dividers && dividers[kind]) || 1;\n                processAttribute(kind, attribute, divider);\n            }\n        }\n        else {\n            var nativeAttributeTypes = {\n                position: \"POSITION\",\n                normal: \"NORMAL\",\n                color: \"COLOR\",\n                uv: \"TEX_COORD\",\n            };\n            for (var kind in nativeAttributeTypes) {\n                var id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\n                if (id !== -1) {\n                    var attribute = decoder.GetAttribute(geometry, id);\n                    processAttribute(kind, attribute);\n                }\n            }\n        }\n    }\n    finally {\n        if (geometry) {\n            decoderModule.destroy(geometry);\n        }\n        decoderModule.destroy(decoder);\n        decoderModule.destroy(buffer);\n    }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n */\nfunction worker() {\n    var decoderPromise;\n    onmessage = function (event) {\n        var data = event.data;\n        switch (data.id) {\n            case \"init\": {\n                var decoder = data.decoder;\n                if (decoder.url) {\n                    importScripts(decoder.url);\n                    decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });\n                }\n                postMessage(\"done\");\n                break;\n            }\n            case \"decodeMesh\": {\n                if (!decoderPromise) {\n                    throw new Error(\"Draco decoder module is not available\");\n                }\n                decoderPromise.then(function (decoder) {\n                    decodeMesh(decoder, data.dataView, data.attributes, function (indices) {\n                        postMessage({ id: \"indices\", value: indices }, [indices.buffer]);\n                    }, function (kind, data) {\n                        postMessage({ id: kind, value: data }, [data.buffer]);\n                    });\n                    postMessage(\"done\");\n                });\n                break;\n            }\n        }\n    };\n}\n/**\n * Draco compression (https://google.github.io/draco/)\n *\n * This class wraps the Draco module.\n *\n * **Encoder**\n *\n * The encoder is not currently implemented.\n *\n * **Decoder**\n *\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     DracoCompression.Configuration = {\n *         decoder: {\n *             wasmUrl: \"<url to the WebAssembly library>\",\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\n *         }\n *     };\n * ```\n *\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\n *\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\n * ```javascript\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\n * ```\n *\n * @see https://playground.babylonjs.com/#DMZIBD#0\n */\nvar DracoCompression = /** @class */ (function () {\n    /**\n     * Constructor\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\n     */\n    function DracoCompression(numWorkers) {\n        if (numWorkers === void 0) { numWorkers = DracoCompression.DefaultNumWorkers; }\n        var decoder = DracoCompression.Configuration.decoder;\n        var decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\"\n            ? {\n                url: Tools.GetAbsoluteUrl(decoder.wasmUrl),\n                wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetAbsoluteUrl(decoder.wasmBinaryUrl)),\n            }\n            : {\n                url: Tools.GetAbsoluteUrl(decoder.fallbackUrl),\n                wasmBinaryPromise: Promise.resolve(undefined),\n            };\n        if (numWorkers && typeof Worker === \"function\") {\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n                var workerContent = \"\".concat(decodeMesh, \"(\").concat(worker, \")()\");\n                var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\n                return new AutoReleaseWorkerPool(numWorkers, function () {\n                    return new Promise(function (resolve, reject) {\n                        var worker = new Worker(workerBlobUrl);\n                        var onError = function (error) {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            reject(error);\n                        };\n                        var onMessage = function (message) {\n                            if (message.data === \"done\") {\n                                worker.removeEventListener(\"error\", onError);\n                                worker.removeEventListener(\"message\", onMessage);\n                                resolve(worker);\n                            }\n                        };\n                        worker.addEventListener(\"error\", onError);\n                        worker.addEventListener(\"message\", onMessage);\n                        worker.postMessage({\n                            id: \"init\",\n                            decoder: {\n                                url: decoderInfo.url,\n                                wasmBinary: decoderWasmBinary,\n                            },\n                        });\n                    });\n                });\n            });\n        }\n        else {\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(function (decoderWasmBinary) {\n                if (!decoderInfo.url) {\n                    throw new Error(\"Draco decoder module is not available\");\n                }\n                return Tools.LoadScriptAsync(decoderInfo.url).then(function () {\n                    return createDecoderAsync(decoderWasmBinary);\n                });\n            });\n        }\n    }\n    Object.defineProperty(DracoCompression, \"DecoderAvailable\", {\n        /**\n         * Returns true if the decoder configuration is available.\n         */\n        get: function () {\n            var decoder = DracoCompression.Configuration.decoder;\n            return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DracoCompression.GetDefaultNumWorkers = function () {\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n            return 1;\n        }\n        // Use 50% of the available logical processors but capped at 4.\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n    };\n    Object.defineProperty(DracoCompression, \"Default\", {\n        /**\n         * Default instance for the draco compression object.\n         */\n        get: function () {\n            if (!DracoCompression._Default) {\n                DracoCompression._Default = new DracoCompression();\n            }\n            return DracoCompression._Default;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Stop all async operations and release resources.\n     */\n    DracoCompression.prototype.dispose = function () {\n        if (this._workerPoolPromise) {\n            this._workerPoolPromise.then(function (workerPool) {\n                workerPool.dispose();\n            });\n        }\n        delete this._workerPoolPromise;\n        delete this._decoderModulePromise;\n    };\n    /**\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\n     * @returns a promise that resolves when ready\n     */\n    DracoCompression.prototype.whenReadyAsync = function () {\n        if (this._workerPoolPromise) {\n            return this._workerPoolPromise.then(function () { });\n        }\n        if (this._decoderModulePromise) {\n            return this._decoderModulePromise.then(function () { });\n        }\n        return Promise.resolve();\n    };\n    /**\n     * Decode Draco compressed mesh data to vertex data.\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n     * @param dividers a list of optional dividers for normalization\n     * @returns A promise that resolves with the decoded vertex data\n     */\n    DracoCompression.prototype.decodeMeshAsync = function (data, attributes, dividers) {\n        var dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        if (this._workerPoolPromise) {\n            return this._workerPoolPromise.then(function (workerPool) {\n                return new Promise(function (resolve, reject) {\n                    workerPool.push(function (worker, onComplete) {\n                        var vertexData = new VertexData();\n                        var onError = function (error) {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            reject(error);\n                            onComplete();\n                        };\n                        var onMessage = function (message) {\n                            if (message.data === \"done\") {\n                                worker.removeEventListener(\"error\", onError);\n                                worker.removeEventListener(\"message\", onMessage);\n                                resolve(vertexData);\n                                onComplete();\n                            }\n                            else if (message.data.id === \"indices\") {\n                                vertexData.indices = message.data.value;\n                            }\n                            else {\n                                // check normalization\n                                var divider = dividers && dividers[message.data.id] ? dividers[message.data.id] : 1;\n                                if (divider !== 1) {\n                                    // normalize\n                                    for (var i = 0; i < message.data.value.length; i++) {\n                                        message.data.value[i] = message.data.value[i] / divider;\n                                    }\n                                }\n                                vertexData.set(message.data.value, message.data.id);\n                            }\n                        };\n                        worker.addEventListener(\"error\", onError);\n                        worker.addEventListener(\"message\", onMessage);\n                        var dataViewCopy = new Uint8Array(dataView.byteLength);\n                        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\n                    });\n                });\n            });\n        }\n        if (this._decoderModulePromise) {\n            return this._decoderModulePromise.then(function (decoder) {\n                var vertexData = new VertexData();\n                decodeMesh(decoder.module, dataView, attributes, function (indices) {\n                    vertexData.indices = indices;\n                }, function (kind, data) {\n                    vertexData.set(data, kind);\n                }, dividers);\n                return vertexData;\n            });\n        }\n        throw new Error(\"Draco decoder module is not available\");\n    };\n    /**\n     * The configuration. Defaults to the following urls:\n     * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\n     * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\n     * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n     */\n    DracoCompression.Configuration = {\n        decoder: {\n            wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\n            wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\n            fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\",\n        },\n    };\n    /**\n     * Default number of workers to create when creating the draco compression object.\n     */\n    DracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\n    DracoCompression._Default = null;\n    return DracoCompression;\n}());\nexport { DracoCompression };\n//# sourceMappingURL=dracoCompression.js.map","import { Tools } from \"../../Misc/tools.js\";\n/**\n * Meshopt compression (https://github.com/zeux/meshoptimizer)\n *\n * This class wraps the meshopt library from https://github.com/zeux/meshoptimizer/tree/master/js.\n *\n * **Encoder**\n *\n * The encoder is not currently implemented.\n *\n * **Decoder**\n *\n * By default, the configuration points to a copy of the meshopt files on the Babylon.js preview CDN (e.g. https://preview.babylonjs.com/meshopt_decoder.js).\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     MeshoptCompression.Configuration = {\n *         decoder: {\n *             url: \"<url to the meshopt decoder library>\"\n *         }\n *     };\n * ```\n */\nvar MeshoptCompression = /** @class */ (function () {\n    /**\n     * Constructor\n     */\n    function MeshoptCompression() {\n        var decoder = MeshoptCompression.Configuration.decoder;\n        this._decoderModulePromise = Tools.LoadScriptAsync(Tools.GetAbsoluteUrl(decoder.url)).then(function () {\n            // Wait for WebAssembly compilation before resolving promise\n            return MeshoptDecoder.ready;\n        });\n    }\n    Object.defineProperty(MeshoptCompression, \"Default\", {\n        /**\n         * Default instance for the meshoptimizer object.\n         */\n        get: function () {\n            if (!MeshoptCompression._Default) {\n                MeshoptCompression._Default = new MeshoptCompression();\n            }\n            return MeshoptCompression._Default;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Stop all async operations and release resources.\n     */\n    MeshoptCompression.prototype.dispose = function () {\n        delete this._decoderModulePromise;\n    };\n    /**\n     * Decode meshopt data.\n     * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder\n     * @param source The input data.\n     * @param count The number of elements.\n     * @param stride The stride in bytes.\n     * @param mode The compression mode.\n     * @param filter The compression filter.\n     * @returns a Promise<Uint8Array> that resolves to the decoded data\n     */\n    MeshoptCompression.prototype.decodeGltfBufferAsync = function (source, count, stride, mode, filter) {\n        return this._decoderModulePromise.then(function () {\n            var result = new Uint8Array(count * stride);\n            MeshoptDecoder.decodeGltfBuffer(result, count, stride, source, mode, filter);\n            return result;\n        });\n    };\n    /**\n     * The configuration. Defaults to the following:\n     * ```javascript\n     * decoder: {\n     *   url: \"https://preview.babylonjs.com/meshopt_decoder.js\"\n     * }\n     * ```\n     */\n    MeshoptCompression.Configuration = {\n        decoder: {\n            url: \"https://preview.babylonjs.com/meshopt_decoder.js\",\n        },\n    };\n    MeshoptCompression._Default = null;\n    return MeshoptCompression;\n}());\nexport { MeshoptCompression };\n//# sourceMappingURL=meshoptCompression.js.map","import { __extends } from \"tslib\";\nimport { DataBuffer } from \"../../Buffers/dataBuffer.js\";\n/** @hidden */\nvar WebGLDataBuffer = /** @class */ (function (_super) {\n    __extends(WebGLDataBuffer, _super);\n    function WebGLDataBuffer(resource) {\n        var _this = _super.call(this) || this;\n        _this._buffer = resource;\n        return _this;\n    }\n    Object.defineProperty(WebGLDataBuffer.prototype, \"underlyingResource\", {\n        get: function () {\n            return this._buffer;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return WebGLDataBuffer;\n}(DataBuffer));\nexport { WebGLDataBuffer };\n//# sourceMappingURL=webGLDataBuffer.js.map","import { __extends } from \"tslib\";\nimport { DataBuffer } from \"../../Buffers/dataBuffer.js\";\n/** @hidden */\nvar WebGPUDataBuffer = /** @class */ (function (_super) {\n    __extends(WebGPUDataBuffer, _super);\n    function WebGPUDataBuffer(resource) {\n        var _this = _super.call(this) || this;\n        _this._buffer = resource;\n        return _this;\n    }\n    Object.defineProperty(WebGPUDataBuffer.prototype, \"underlyingResource\", {\n        get: function () {\n            return this._buffer;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return WebGPUDataBuffer;\n}(DataBuffer));\nexport { WebGPUDataBuffer };\n//# sourceMappingURL=webgpuDataBuffer.js.map","import { __extends } from \"tslib\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\n\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { _MeshCollisionData } from \"../Collisions/meshCollisionData.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { extractMinAndMax } from \"../Maths/math.functions.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/** @hidden */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar _FacetDataStorage = /** @class */ (function () {\n    function _FacetDataStorage() {\n        this.facetNb = 0; // facet number\n        this.partitioningSubdivisions = 10; // number of subdivisions per axis in the partitioning space\n        this.partitioningBBoxRatio = 1.01; // the partitioning array space is by default 1% bigger than the bounding box\n        this.facetDataEnabled = false; // is the facet data feature enabled on this mesh ?\n        this.facetParameters = {}; // keep a reference to the object parameters to avoid memory re-allocation\n        this.bbSize = Vector3.Zero(); // bbox size approximated for facet data\n        this.subDiv = {\n            // actual number of subdivisions per axis for ComputeNormals()\n            max: 1,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            X: 1,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            Y: 1,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            Z: 1,\n        };\n        this.facetDepthSort = false; // is the facet depth sort to be computed\n        this.facetDepthSortEnabled = false; // is the facet depth sort initialized\n    }\n    return _FacetDataStorage;\n}());\n/**\n * @hidden\n **/\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar _InternalAbstractMeshDataInfo = /** @class */ (function () {\n    function _InternalAbstractMeshDataInfo() {\n        this._hasVertexAlpha = false;\n        this._useVertexColors = true;\n        this._numBoneInfluencers = 4;\n        this._applyFog = true;\n        this._receiveShadows = false;\n        this._facetData = new _FacetDataStorage();\n        this._visibility = 1.0;\n        this._skeleton = null;\n        this._layerMask = 0x0fffffff;\n        this._computeBonesUsingShaders = true;\n        this._isActive = false;\n        this._onlyForInstances = false;\n        this._isActiveIntermediate = false;\n        this._onlyForInstancesIntermediate = false;\n        this._actAsRegularMesh = false;\n        this._currentLOD = null;\n        this._currentLODIsUpToDate = false;\n        this._collisionRetryCount = 3;\n        this._morphTargetManager = null;\n        this._renderingGroupId = 0;\n        this._bakedVertexAnimationManager = null;\n        this._material = null;\n        this._positions = null;\n        // Collisions\n        this._meshCollisionData = new _MeshCollisionData();\n        this._enableDistantPicking = false;\n    }\n    return _InternalAbstractMeshDataInfo;\n}());\n/**\n * Class used to store all common mesh properties\n */\nvar AbstractMesh = /** @class */ (function (_super) {\n    __extends(AbstractMesh, _super);\n    // Constructor\n    /**\n     * Creates a new AbstractMesh\n     * @param name defines the name of the mesh\n     * @param scene defines the hosting scene\n     */\n    function AbstractMesh(name, scene) {\n        if (scene === void 0) { scene = null; }\n        var _this = _super.call(this, name, scene, false) || this;\n        // Internal data\n        /** @hidden */\n        _this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();\n        /** @hidden */\n        _this._waitingMaterialId = null;\n        /**\n         * The culling strategy to use to check whether the mesh must be rendered or not.\n         * This value can be changed at any time and will be used on the next render mesh selection.\n         * The possible values are :\n         * - AbstractMesh.CULLINGSTRATEGY_STANDARD\n         * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n         * Please read each static variable documentation to get details about the culling process.\n         * */\n        _this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\n        // Events\n        /**\n         * An event triggered when this mesh collides with another one\n         */\n        _this.onCollideObservable = new Observable();\n        /**\n         * An event triggered when the collision's position changes\n         */\n        _this.onCollisionPositionChangeObservable = new Observable();\n        /**\n         * An event triggered when material is changed\n         */\n        _this.onMaterialChangedObservable = new Observable();\n        // Properties\n        /**\n         * Gets or sets the orientation for POV movement & rotation\n         */\n        _this.definedFacingForward = true;\n        /** @hidden */\n        _this._occlusionQuery = null;\n        /** @hidden */\n        _this._renderingGroup = null;\n        /** Gets or sets the alpha index used to sort transparent meshes\n         * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index\n         */\n        _this.alphaIndex = Number.MAX_VALUE;\n        /**\n         * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true\n         */\n        _this.isVisible = true;\n        /**\n         * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\n         */\n        _this.isPickable = true;\n        /**\n         * Gets or sets a boolean indicating if the mesh can be near picked. Default is false\n         */\n        _this.isNearPickable = false;\n        /**\n         * Gets or sets a boolean indicating if the mesh can be near grabbed. Default is false\n         */\n        _this.isNearGrabbable = false;\n        /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */\n        _this.showSubMeshesBoundingBox = false;\n        /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)\n         * @see https://doc.babylonjs.com/how_to/how_to_use_lens_flares\n         */\n        _this.isBlocker = false;\n        /**\n         * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)\n         */\n        _this.enablePointerMoveEvents = false;\n        /** Defines color to use when rendering outline */\n        _this.outlineColor = Color3.Red();\n        /** Define width to use when rendering outline */\n        _this.outlineWidth = 0.02;\n        /** Defines color to use when rendering overlay */\n        _this.overlayColor = Color3.Red();\n        /** Defines alpha to use when rendering overlay */\n        _this.overlayAlpha = 0.5;\n        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */\n        _this.useOctreeForRenderingSelection = true;\n        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */\n        _this.useOctreeForPicking = true;\n        /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */\n        _this.useOctreeForCollisions = true;\n        /**\n         * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)\n         */\n        _this.alwaysSelectAsActiveMesh = false;\n        /**\n         * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)\n         */\n        _this.doNotSyncBoundingInfo = false;\n        /**\n         * Gets or sets the current action manager\n         * @see https://doc.babylonjs.com/how_to/how_to_use_actions\n         */\n        _this.actionManager = null;\n        /**\n         * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))\n         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n         */\n        _this.ellipsoid = new Vector3(0.5, 1, 0.5);\n        /**\n         * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))\n         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n         */\n        _this.ellipsoidOffset = new Vector3(0, 0, 0);\n        // Edges\n        /**\n         * Defines edge width used when edgesRenderer is enabled\n         * @see https://www.babylonjs-playground.com/#10OJSG#13\n         */\n        _this.edgesWidth = 1;\n        /**\n         * Defines edge color used when edgesRenderer is enabled\n         * @see https://www.babylonjs-playground.com/#10OJSG#13\n         */\n        _this.edgesColor = new Color4(1, 0, 0, 1);\n        /** @hidden */\n        _this._edgesRenderer = null;\n        /** @hidden */\n        _this._masterMesh = null;\n        _this._boundingInfo = null;\n        _this._boundingInfoIsDirty = true;\n        /** @hidden */\n        _this._renderId = 0;\n        /** @hidden */\n        _this._intersectionsInProgress = new Array();\n        /** @hidden */\n        _this._unIndexed = false;\n        /** @hidden */\n        _this._lightSources = new Array();\n        // Loading properties\n        /** @hidden */\n        _this._waitingData = {\n            lods: null,\n            actions: null,\n            freezeWorldMatrix: null,\n        };\n        /** @hidden */\n        _this._bonesTransformMatrices = null;\n        /** @hidden */\n        _this._transformMatrixTexture = null;\n        /**\n         * An event triggered when the mesh is rebuilt.\n         */\n        _this.onRebuildObservable = new Observable();\n        _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n            if (collidedMesh === void 0) { collidedMesh = null; }\n            newPosition.subtractToRef(_this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, _this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);\n            if (_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {\n                _this.position.addInPlace(_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);\n            }\n            if (collidedMesh) {\n                _this.onCollideObservable.notifyObservers(collidedMesh);\n            }\n            _this.onCollisionPositionChangeObservable.notifyObservers(_this.position);\n        };\n        _this.getScene().addMesh(_this);\n        _this._resyncLightSources();\n        // Mesh Uniform Buffer.\n        _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine(), undefined, undefined, name, !_this.getScene().getEngine().isWebGPU);\n        _this._buildUniformLayout();\n        return _this;\n    }\n    Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_NONE\", {\n        /**\n         * No billboard\n         */\n        get: function () {\n            return TransformNode.BILLBOARDMODE_NONE;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_X\", {\n        /** Billboard on X axis */\n        get: function () {\n            return TransformNode.BILLBOARDMODE_X;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Y\", {\n        /** Billboard on Y axis */\n        get: function () {\n            return TransformNode.BILLBOARDMODE_Y;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Z\", {\n        /** Billboard on Z axis */\n        get: function () {\n            return TransformNode.BILLBOARDMODE_Z;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_ALL\", {\n        /** Billboard on all axes */\n        get: function () {\n            return TransformNode.BILLBOARDMODE_ALL;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_USE_POSITION\", {\n        /** Billboard on using position instead of orientation */\n        get: function () {\n            return TransformNode.BILLBOARDMODE_USE_POSITION;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"facetNb\", {\n        /**\n         * Gets the number of facets in the mesh\n         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._facetData.facetNb;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"partitioningSubdivisions\", {\n        /**\n         * Gets or set the number (integer) of subdivisions per axis in the partitioning space\n         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;\n        },\n        set: function (nb) {\n            this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"partitioningBBoxRatio\", {\n        /**\n         * The ratio (float) to apply to the bounding box size to set to the partitioning space.\n         * Ex : 1.01 (default) the partitioning space is 1% bigger than the bounding box\n         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;\n        },\n        set: function (ratio) {\n            this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"mustDepthSortFacets\", {\n        /**\n         * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.\n         * Works only for updatable meshes.\n         * Doesn't work with multi-materials\n         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;\n        },\n        set: function (sort) {\n            this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"facetDepthSortFrom\", {\n        /**\n         * The location (Vector3) where the facet depth sort must be computed from.\n         * By default, the active camera position.\n         * Used only when facet depth sort is enabled\n         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;\n        },\n        set: function (location) {\n            this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"collisionRetryCount\", {\n        /** number of collision detection tries. Change this value if not all collisions are detected and handled properly */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._collisionRetryCount;\n        },\n        set: function (retryCount) {\n            this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"isFacetDataEnabled\", {\n        /**\n         * gets a boolean indicating if facetData is enabled\n         * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"morphTargetManager\", {\n        /**\n         * Gets or sets the morph target manager\n         * @see https://doc.babylonjs.com/how_to/how_to_use_morphtargets\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._morphTargetManager;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {\n                return;\n            }\n            this._internalAbstractMeshDataInfo._morphTargetManager = value;\n            this._syncGeometryWithMorphTargetManager();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"bakedVertexAnimationManager\", {\n        /**\n         * Gets or sets the baked vertex animation manager\n         * @see https://doc.babylonjs.com/divingDeeper/animation/baked_texture_animations\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {\n                return;\n            }\n            this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;\n            this._markSubMeshesAsAttributesDirty();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** @hidden */\n    AbstractMesh.prototype._syncGeometryWithMorphTargetManager = function () { };\n    /**\n     * @param value\n     * @hidden\n     */\n    AbstractMesh.prototype._updateNonUniformScalingState = function (value) {\n        if (!_super.prototype._updateNonUniformScalingState.call(this, value)) {\n            return false;\n        }\n        this._markSubMeshesAsMiscDirty();\n        return true;\n    };\n    Object.defineProperty(AbstractMesh.prototype, \"onCollide\", {\n        /** Set a function to call when this mesh collides with another one */\n        set: function (callback) {\n            if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {\n                this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);\n            }\n            this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"onCollisionPositionChange\", {\n        /** Set a function to call when the collision's position changes */\n        set: function (callback) {\n            if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {\n                this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);\n            }\n            this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"visibility\", {\n        /**\n         * Gets or sets mesh visibility between 0 and 1 (default is 1)\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._visibility;\n        },\n        /**\n         * Gets or sets mesh visibility between 0 and 1 (default is 1)\n         */\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._visibility === value) {\n                return;\n            }\n            var oldValue = this._internalAbstractMeshDataInfo._visibility;\n            this._internalAbstractMeshDataInfo._visibility = value;\n            if ((oldValue === 1 && value !== 1) || (oldValue !== 1 && value === 1)) {\n                this._markSubMeshesAsMiscDirty();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"renderingGroupId\", {\n        /**\n         * Specifies the rendering group id for this mesh (0 by default)\n         * @see https://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._renderingGroupId;\n        },\n        set: function (value) {\n            this._internalAbstractMeshDataInfo._renderingGroupId = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"material\", {\n        /** Gets or sets current material */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._material;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._material === value) {\n                return;\n            }\n            // remove from material mesh map id needed\n            if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\n                this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\n            }\n            this._internalAbstractMeshDataInfo._material = value;\n            if (value && value.meshMap) {\n                value.meshMap[this.uniqueId] = this;\n            }\n            if (this.onMaterialChangedObservable.hasObservers()) {\n                this.onMaterialChangedObservable.notifyObservers(this);\n            }\n            if (!this.subMeshes) {\n                return;\n            }\n            this.resetDrawCache();\n            this._unBindEffect();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Gets the material used to render the mesh in a specific render pass\n     * @param renderPassId render pass id\n     * @returns material used for the render pass. If no specific material is used for this render pass, undefined is returned (meaning mesh.material is used for this pass)\n     */\n    AbstractMesh.prototype.getMaterialForRenderPass = function (renderPassId) {\n        var _a;\n        return (_a = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[renderPassId];\n    };\n    /**\n     * Sets the material to be used to render the mesh in a specific render pass\n     * @param renderPassId render pass id\n     * @param material material to use for this render pass. If undefined is passed, no specific material will be used for this render pass but the regular material will be used instead (mesh.material)\n     */\n    AbstractMesh.prototype.setMaterialForRenderPass = function (renderPassId, material) {\n        this.resetDrawCache(renderPassId);\n        if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {\n            this._internalAbstractMeshDataInfo._materialForRenderPass = [];\n        }\n        this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;\n    };\n    Object.defineProperty(AbstractMesh.prototype, \"receiveShadows\", {\n        /**\n         * Gets or sets a boolean indicating that this mesh can receive realtime shadows\n         * @see https://doc.babylonjs.com/babylon101/shadows\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._receiveShadows;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._receiveShadows === value) {\n                return;\n            }\n            this._internalAbstractMeshDataInfo._receiveShadows = value;\n            this._markSubMeshesAsLightDirty();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"hasVertexAlpha\", {\n        /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._hasVertexAlpha;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {\n                return;\n            }\n            this._internalAbstractMeshDataInfo._hasVertexAlpha = value;\n            this._markSubMeshesAsAttributesDirty();\n            this._markSubMeshesAsMiscDirty();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"useVertexColors\", {\n        /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._useVertexColors;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._useVertexColors === value) {\n                return;\n            }\n            this._internalAbstractMeshDataInfo._useVertexColors = value;\n            this._markSubMeshesAsAttributesDirty();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"computeBonesUsingShaders\", {\n        /**\n         * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n                return;\n            }\n            this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n            this._markSubMeshesAsAttributesDirty();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"numBoneInfluencers\", {\n        /** Gets or sets the number of allowed bone influences per vertex (4 by default) */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._numBoneInfluencers;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {\n                return;\n            }\n            this._internalAbstractMeshDataInfo._numBoneInfluencers = value;\n            this._markSubMeshesAsAttributesDirty();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"applyFog\", {\n        /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._applyFog;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._applyFog === value) {\n                return;\n            }\n            this._internalAbstractMeshDataInfo._applyFog = value;\n            this._markSubMeshesAsMiscDirty();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"enableDistantPicking\", {\n        /** When enabled, decompose picking matrices for better precision with large values for mesh position and scling */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._enableDistantPicking;\n        },\n        set: function (value) {\n            this._internalAbstractMeshDataInfo._enableDistantPicking = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"layerMask\", {\n        /**\n         * Gets or sets the current layer mask (default is 0x0FFFFFFF)\n         * @see https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._layerMask;\n        },\n        set: function (value) {\n            if (value === this._internalAbstractMeshDataInfo._layerMask) {\n                return;\n            }\n            this._internalAbstractMeshDataInfo._layerMask = value;\n            this._resyncLightSources();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"collisionMask\", {\n        /**\n         * Gets or sets a collision mask used to mask collisions (default is -1).\n         * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;\n        },\n        set: function (mask) {\n            this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"collisionResponse\", {\n        /**\n         * Gets or sets a collision response flag (default is true).\n         * when collisionResponse is false, events are still triggered but colliding entity has no response\n         * This helps creating trigger volume when user wants collision feedback events but not position/velocity\n         * to respond to the collision.\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;\n        },\n        set: function (response) {\n            this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"collisionGroup\", {\n        /**\n         * Gets or sets the current collision group mask (-1 by default).\n         * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;\n        },\n        set: function (mask) {\n            this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"surroundingMeshes\", {\n        /**\n         * Gets or sets current surrounding meshes (null by default).\n         *\n         * By default collision detection is tested against every mesh in the scene.\n         * It is possible to set surroundingMeshes to a defined list of meshes and then only these specified\n         * meshes will be tested for the collision.\n         *\n         * Note: if set to an empty array no collision will happen when this mesh is moved.\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;\n        },\n        set: function (meshes) {\n            this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"lightSources\", {\n        /** Gets the list of lights affecting that mesh */\n        get: function () {\n            return this._lightSources;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"_positions\", {\n        /** @hidden */\n        get: function () {\n            return null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"skeleton\", {\n        get: function () {\n            return this._internalAbstractMeshDataInfo._skeleton;\n        },\n        /**\n         * Gets or sets a skeleton to apply skinning transformations\n         * @see https://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons\n         */\n        set: function (value) {\n            var skeleton = this._internalAbstractMeshDataInfo._skeleton;\n            if (skeleton && skeleton.needInitialSkinMatrix) {\n                skeleton._unregisterMeshWithPoseMatrix(this);\n            }\n            if (value && value.needInitialSkinMatrix) {\n                value._registerMeshWithPoseMatrix(this);\n            }\n            this._internalAbstractMeshDataInfo._skeleton = value;\n            if (!this._internalAbstractMeshDataInfo._skeleton) {\n                this._bonesTransformMatrices = null;\n            }\n            this._markSubMeshesAsAttributesDirty();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    AbstractMesh.prototype._buildUniformLayout = function () {\n        this._uniformBuffer.addUniform(\"world\", 16);\n        this._uniformBuffer.addUniform(\"visibility\", 1);\n        this._uniformBuffer.create();\n    };\n    /**\n     * Transfer the mesh values to its UBO.\n     * @param world The world matrix associated with the mesh\n     */\n    AbstractMesh.prototype.transferToEffect = function (world) {\n        var ubo = this._uniformBuffer;\n        ubo.updateMatrix(\"world\", world);\n        ubo.updateFloat(\"visibility\", this._internalAbstractMeshDataInfo._visibility);\n        ubo.update();\n    };\n    /**\n     * Gets the mesh uniform buffer.\n     * @return the uniform buffer of the mesh.\n     */\n    AbstractMesh.prototype.getMeshUniformBuffer = function () {\n        return this._uniformBuffer;\n    };\n    /**\n     * Returns the string \"AbstractMesh\"\n     * @returns \"AbstractMesh\"\n     */\n    AbstractMesh.prototype.getClassName = function () {\n        return \"AbstractMesh\";\n    };\n    /**\n     * Gets a string representation of the current mesh\n     * @param fullDetails defines a boolean indicating if full details must be included\n     * @returns a string representation of the current mesh\n     */\n    AbstractMesh.prototype.toString = function (fullDetails) {\n        var ret = \"Name: \" + this.name + \", isInstance: \" + (this.getClassName() !== \"InstancedMesh\" ? \"YES\" : \"NO\");\n        ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\n        var skeleton = this._internalAbstractMeshDataInfo._skeleton;\n        if (skeleton) {\n            ret += \", skeleton: \" + skeleton.name;\n        }\n        if (fullDetails) {\n            ret += \", billboard mode: \" + [\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"][this.billboardMode];\n            ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? \"YES\" : \"NO\");\n        }\n        return ret;\n    };\n    /**\n     * @hidden\n     */\n    AbstractMesh.prototype._getEffectiveParent = function () {\n        if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\n            return this._masterMesh;\n        }\n        return _super.prototype._getEffectiveParent.call(this);\n    };\n    /**\n     * @param trigger\n     * @param initialCall\n     * @hidden\n     */\n    AbstractMesh.prototype._getActionManagerForTrigger = function (trigger, initialCall) {\n        if (initialCall === void 0) { initialCall = true; }\n        if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {\n            if (trigger) {\n                if (this.actionManager.hasSpecificTrigger(trigger)) {\n                    return this.actionManager;\n                }\n            }\n            else {\n                return this.actionManager;\n            }\n        }\n        if (!this.parent) {\n            return null;\n        }\n        return this.parent._getActionManagerForTrigger(trigger, false);\n    };\n    /**\n     * @param dispose\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype._rebuild = function (dispose) {\n        if (dispose === void 0) { dispose = false; }\n        this.onRebuildObservable.notifyObservers(this);\n        if (this._occlusionQuery !== null) {\n            this._occlusionQuery = null;\n        }\n        if (!this.subMeshes) {\n            return;\n        }\n        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n            var subMesh = _a[_i];\n            subMesh._rebuild();\n        }\n    };\n    /** @hidden */\n    AbstractMesh.prototype._resyncLightSources = function () {\n        this._lightSources.length = 0;\n        for (var _i = 0, _a = this.getScene().lights; _i < _a.length; _i++) {\n            var light = _a[_i];\n            if (!light.isEnabled()) {\n                continue;\n            }\n            if (light.canAffectMesh(this)) {\n                this._lightSources.push(light);\n            }\n        }\n        this._markSubMeshesAsLightDirty();\n    };\n    /**\n     * @param light\n     * @hidden\n     */\n    AbstractMesh.prototype._resyncLightSource = function (light) {\n        var isIn = light.isEnabled() && light.canAffectMesh(this);\n        var index = this._lightSources.indexOf(light);\n        var removed = false;\n        if (index === -1) {\n            if (!isIn) {\n                return;\n            }\n            this._lightSources.push(light);\n        }\n        else {\n            if (isIn) {\n                return;\n            }\n            removed = true;\n            this._lightSources.splice(index, 1);\n        }\n        this._markSubMeshesAsLightDirty(removed);\n    };\n    /** @hidden */\n    AbstractMesh.prototype._unBindEffect = function () {\n        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n            var subMesh = _a[_i];\n            subMesh.setEffect(null);\n        }\n    };\n    /**\n     * @param light\n     * @param dispose\n     * @hidden\n     */\n    AbstractMesh.prototype._removeLightSource = function (light, dispose) {\n        var index = this._lightSources.indexOf(light);\n        if (index === -1) {\n            return;\n        }\n        this._lightSources.splice(index, 1);\n        this._markSubMeshesAsLightDirty(dispose);\n    };\n    AbstractMesh.prototype._markSubMeshesAsDirty = function (func) {\n        if (!this.subMeshes) {\n            return;\n        }\n        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n            var subMesh = _a[_i];\n            for (var i = 0; i < subMesh._drawWrappers.length; ++i) {\n                var drawWrapper = subMesh._drawWrappers[i];\n                if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {\n                    continue;\n                }\n                func(drawWrapper.defines);\n            }\n        }\n    };\n    /**\n     * @param dispose\n     * @hidden\n     */\n    AbstractMesh.prototype._markSubMeshesAsLightDirty = function (dispose) {\n        if (dispose === void 0) { dispose = false; }\n        this._markSubMeshesAsDirty(function (defines) { return defines.markAsLightDirty(dispose); });\n    };\n    /** @hidden */\n    AbstractMesh.prototype._markSubMeshesAsAttributesDirty = function () {\n        this._markSubMeshesAsDirty(function (defines) { return defines.markAsAttributesDirty(); });\n    };\n    /** @hidden */\n    AbstractMesh.prototype._markSubMeshesAsMiscDirty = function () {\n        this._markSubMeshesAsDirty(function (defines) { return defines.markAsMiscDirty(); });\n    };\n    /**\n     * Flag the AbstractMesh as dirty (Forcing it to update everything)\n     * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\n     * @returns this AbstractMesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.markAsDirty = function (property) {\n        this._currentRenderId = Number.MAX_VALUE;\n        this._isDirty = true;\n        return this;\n    };\n    /**\n     * Resets the draw wrappers cache for all submeshes of this abstract mesh\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n     */\n    AbstractMesh.prototype.resetDrawCache = function (passId) {\n        if (!this.subMeshes) {\n            return;\n        }\n        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n            var subMesh = _a[_i];\n            subMesh.resetDrawCache(passId);\n        }\n    };\n    Object.defineProperty(AbstractMesh.prototype, \"isBlocked\", {\n        // Methods\n        /**\n         * Returns true if the mesh is blocked. Implemented by child classes\n         */\n        get: function () {\n            return false;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the mesh itself by default. Implemented by child classes\n     * @param camera defines the camera to use to pick the right LOD level\n     * @returns the currentAbstractMesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.getLOD = function (camera) {\n        return this;\n    };\n    /**\n     * Returns 0 by default. Implemented by child classes\n     * @returns an integer\n     */\n    AbstractMesh.prototype.getTotalVertices = function () {\n        return 0;\n    };\n    /**\n     * Returns a positive integer : the total number of indices in this mesh geometry.\n     * @returns the number of indices or zero if the mesh has no geometry.\n     */\n    AbstractMesh.prototype.getTotalIndices = function () {\n        return 0;\n    };\n    /**\n     * Returns null by default. Implemented by child classes\n     * @returns null\n     */\n    AbstractMesh.prototype.getIndices = function () {\n        return null;\n    };\n    /**\n     * Returns the array of the requested vertex data kind. Implemented by child classes\n     * @param kind defines the vertex data kind to use\n     * @returns null\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.getVerticesData = function (kind) {\n        return null;\n    };\n    /**\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n     * Note that a new underlying VertexBuffer object is created each call.\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n     * @param kind defines vertex data kind:\n     * * VertexBuffer.PositionKind\n     * * VertexBuffer.UVKind\n     * * VertexBuffer.UV2Kind\n     * * VertexBuffer.UV3Kind\n     * * VertexBuffer.UV4Kind\n     * * VertexBuffer.UV5Kind\n     * * VertexBuffer.UV6Kind\n     * * VertexBuffer.ColorKind\n     * * VertexBuffer.MatricesIndicesKind\n     * * VertexBuffer.MatricesIndicesExtraKind\n     * * VertexBuffer.MatricesWeightsKind\n     * * VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updatable defines if the data must be flagged as updatable (or static)\n     * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind\n     * @returns the current mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n        return this;\n    };\n    /**\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n     * If the mesh has no geometry, it is simply returned as it is.\n     * @param kind defines vertex data kind:\n     * * VertexBuffer.PositionKind\n     * * VertexBuffer.UVKind\n     * * VertexBuffer.UV2Kind\n     * * VertexBuffer.UV3Kind\n     * * VertexBuffer.UV4Kind\n     * * VertexBuffer.UV5Kind\n     * * VertexBuffer.UV6Kind\n     * * VertexBuffer.ColorKind\n     * * VertexBuffer.MatricesIndicesKind\n     * * VertexBuffer.MatricesIndicesExtraKind\n     * * VertexBuffer.MatricesWeightsKind\n     * * VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed\n     * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh\n     * @returns the current mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n        return this;\n    };\n    /**\n     * Sets the mesh indices,\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n     * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)\n     * @param totalVertices Defines the total number of vertices\n     * @returns the current mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.setIndices = function (indices, totalVertices) {\n        return this;\n    };\n    /**\n     * Gets a boolean indicating if specific vertex data is present\n     * @param kind defines the vertex data kind to use\n     * @returns true is data kind is present\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.isVerticesDataPresent = function (kind) {\n        return false;\n    };\n    /**\n     * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.\n     * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).\n     * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.\n     * @returns a BoundingInfo\n     */\n    AbstractMesh.prototype.getBoundingInfo = function () {\n        if (this._masterMesh) {\n            return this._masterMesh.getBoundingInfo();\n        }\n        if (this._boundingInfoIsDirty) {\n            this._boundingInfoIsDirty = false;\n            // this._boundingInfo is being created if undefined\n            this._updateBoundingInfo();\n        }\n        // cannot be null.\n        return this._boundingInfo;\n    };\n    /**\n     * Overwrite the current bounding info\n     * @param boundingInfo defines the new bounding info\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.setBoundingInfo = function (boundingInfo) {\n        this._boundingInfo = boundingInfo;\n        return this;\n    };\n    Object.defineProperty(AbstractMesh.prototype, \"hasBoundingInfo\", {\n        /**\n         * Returns true if there is already a bounding info\n         */\n        get: function () {\n            return this._boundingInfo !== null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Creates a new bounding info for the mesh\n     * @param minimum min vector of the bounding box/sphere\n     * @param maximum max vector of the bounding box/sphere\n     * @param worldMatrix defines the new world matrix\n     * @returns the new bounding info\n     */\n    AbstractMesh.prototype.buildBoundingInfo = function (minimum, maximum, worldMatrix) {\n        this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);\n        return this._boundingInfo;\n    };\n    /**\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.normalizeToUnitCube = function (includeDescendants, ignoreRotation, predicate) {\n        if (includeDescendants === void 0) { includeDescendants = true; }\n        if (ignoreRotation === void 0) { ignoreRotation = false; }\n        return _super.prototype.normalizeToUnitCube.call(this, includeDescendants, ignoreRotation, predicate);\n    };\n    Object.defineProperty(AbstractMesh.prototype, \"useBones\", {\n        /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */\n        get: function () {\n            return ((this.skeleton &&\n                this.getScene().skeletonsEnabled &&\n                this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) &&\n                this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** @hidden */\n    AbstractMesh.prototype._preActivate = function () { };\n    /**\n     * @param renderId\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype._preActivateForIntermediateRendering = function (renderId) { };\n    /**\n     * @param renderId\n     * @param intermediateRendering\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype._activate = function (renderId, intermediateRendering) {\n        this._renderId = renderId;\n        return true;\n    };\n    /** @hidden */\n    AbstractMesh.prototype._postActivate = function () {\n        // Do nothing\n    };\n    /** @hidden */\n    AbstractMesh.prototype._freeze = function () {\n        // Do nothing\n    };\n    /** @hidden */\n    AbstractMesh.prototype._unFreeze = function () {\n        // Do nothing\n    };\n    /**\n     * Gets the current world matrix\n     * @returns a Matrix\n     */\n    AbstractMesh.prototype.getWorldMatrix = function () {\n        if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {\n            return this._masterMesh.getWorldMatrix();\n        }\n        return _super.prototype.getWorldMatrix.call(this);\n    };\n    /** @hidden */\n    AbstractMesh.prototype._getWorldMatrixDeterminant = function () {\n        if (this._masterMesh) {\n            return this._masterMesh._getWorldMatrixDeterminant();\n        }\n        return _super.prototype._getWorldMatrixDeterminant.call(this);\n    };\n    Object.defineProperty(AbstractMesh.prototype, \"isAnInstance\", {\n        /**\n         * Gets a boolean indicating if this mesh is an instance or a regular mesh\n         */\n        get: function () {\n            return false;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"hasInstances\", {\n        /**\n         * Gets a boolean indicating if this mesh has instances\n         */\n        get: function () {\n            return false;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"hasThinInstances\", {\n        /**\n         * Gets a boolean indicating if this mesh has thin instances\n         */\n        get: function () {\n            return false;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // ================================== Point of View Movement =================================\n    /**\n     * Perform relative position change from the point of view of behind the front of the mesh.\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\n     * Supports definition of mesh facing forward or backward\n     * @param amountRight defines the distance on the right axis\n     * @param amountUp defines the distance on the up axis\n     * @param amountForward defines the distance on the forward axis\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.movePOV = function (amountRight, amountUp, amountForward) {\n        this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\n        return this;\n    };\n    /**\n     * Calculate relative position change from the point of view of behind the front of the mesh.\n     * This is performed taking into account the meshes current rotation, so you do not have to care.\n     * Supports definition of mesh facing forward or backward\n     * @param amountRight defines the distance on the right axis\n     * @param amountUp defines the distance on the up axis\n     * @param amountForward defines the distance on the forward axis\n     * @returns the new displacement vector\n     */\n    AbstractMesh.prototype.calcMovePOV = function (amountRight, amountUp, amountForward) {\n        var rotMatrix = new Matrix();\n        var rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n        rotQuaternion.toRotationMatrix(rotMatrix);\n        var translationDelta = Vector3.Zero();\n        var defForwardMult = this.definedFacingForward ? -1 : 1;\n        Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\n        return translationDelta;\n    };\n    // ================================== Point of View Rotation =================================\n    /**\n     * Perform relative rotation change from the point of view of behind the front of the mesh.\n     * Supports definition of mesh facing forward or backward\n     * @param flipBack defines the flip\n     * @param twirlClockwise defines the twirl\n     * @param tiltRight defines the tilt\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.rotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n        this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\n        return this;\n    };\n    /**\n     * Calculate relative rotation change from the point of view of behind the front of the mesh.\n     * Supports definition of mesh facing forward or backward.\n     * @param flipBack defines the flip\n     * @param twirlClockwise defines the twirl\n     * @param tiltRight defines the tilt\n     * @returns the new rotation vector\n     */\n    AbstractMesh.prototype.calcRotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n        var defForwardMult = this.definedFacingForward ? 1 : -1;\n        return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\n    };\n    /**\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n     * This means the mesh underlying bounding box and sphere are recomputed.\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.refreshBoundingInfo = function (applySkeleton, applyMorph) {\n        if (applySkeleton === void 0) { applySkeleton = false; }\n        if (applyMorph === void 0) { applyMorph = false; }\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\n            return this;\n        }\n        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), null);\n        return this;\n    };\n    /**\n     * @param data\n     * @param bias\n     * @hidden\n     */\n    AbstractMesh.prototype._refreshBoundingInfo = function (data, bias) {\n        if (data) {\n            var extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);\n            if (this._boundingInfo) {\n                this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n            }\n            else {\n                this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n            }\n        }\n        if (this.subMeshes) {\n            for (var index = 0; index < this.subMeshes.length; index++) {\n                this.subMeshes[index].refreshBoundingInfo(data);\n            }\n        }\n        this._updateBoundingInfo();\n    };\n    /**\n     * Internal function to get buffer data and possibly apply morphs and normals\n     * @param applySkeleton\n     * @param applyMorph\n     * @param data\n     * @param kind the kind of data you want. Can be Normal or Position\n     */\n    AbstractMesh.prototype._getData = function (applySkeleton, applyMorph, data, kind) {\n        if (applySkeleton === void 0) { applySkeleton = false; }\n        if (applyMorph === void 0) { applyMorph = false; }\n        if (kind === void 0) { kind = VertexBuffer.PositionKind; }\n        data = data !== null && data !== void 0 ? data : this.getVerticesData(kind).slice();\n        if (data && applyMorph && this.morphTargetManager) {\n            var faceIndexCount = 0;\n            var positionIndex = 0;\n            for (var vertexCount = 0; vertexCount < data.length; vertexCount++) {\n                for (var targetCount = 0; targetCount < this.morphTargetManager.numTargets; targetCount++) {\n                    var targetMorph = this.morphTargetManager.getTarget(targetCount);\n                    var influence = targetMorph.influence;\n                    if (influence > 0.0) {\n                        var morphTargetPositions = targetMorph.getPositions();\n                        if (morphTargetPositions) {\n                            data[vertexCount] += (morphTargetPositions[vertexCount] - data[vertexCount]) * influence;\n                        }\n                    }\n                }\n                faceIndexCount++;\n                if (kind === VertexBuffer.PositionKind) {\n                    if (this._positions && faceIndexCount === 3) {\n                        // We want to merge into positions every 3 indices starting (but not 0)\n                        faceIndexCount = 0;\n                        var index = positionIndex * 3;\n                        this._positions[positionIndex++].copyFromFloats(data[index], data[index + 1], data[index + 2]);\n                    }\n                }\n            }\n        }\n        if (data && applySkeleton && this.skeleton) {\n            var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n            var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n            if (matricesWeightsData && matricesIndicesData) {\n                var needExtras = this.numBoneInfluencers > 4;\n                var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n                var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n                var skeletonMatrices = this.skeleton.getTransformMatrices(this);\n                var tempVector = TmpVectors.Vector3[0];\n                var finalMatrix = TmpVectors.Matrix[0];\n                var tempMatrix = TmpVectors.Matrix[1];\n                var matWeightIdx = 0;\n                for (var index = 0; index < data.length; index += 3, matWeightIdx += 4) {\n                    finalMatrix.reset();\n                    var inf = void 0;\n                    var weight = void 0;\n                    for (inf = 0; inf < 4; inf++) {\n                        weight = matricesWeightsData[matWeightIdx + inf];\n                        if (weight > 0) {\n                            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                            finalMatrix.addToSelf(tempMatrix);\n                        }\n                    }\n                    if (needExtras) {\n                        for (inf = 0; inf < 4; inf++) {\n                            weight = matricesWeightsExtraData[matWeightIdx + inf];\n                            if (weight > 0) {\n                                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                                finalMatrix.addToSelf(tempMatrix);\n                            }\n                        }\n                    }\n                    if (kind === VertexBuffer.NormalKind) {\n                        Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\n                    }\n                    else {\n                        Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);\n                    }\n                    tempVector.toArray(data, index);\n                    if (kind === VertexBuffer.PositionKind && this._positions) {\n                        this._positions[index / 3].copyFrom(tempVector);\n                    }\n                }\n            }\n        }\n        return data;\n    };\n    /**\n     * Get the normals vertex data and optionally apply skeleton and morphing.\n     * @param applySkeleton defines whether to apply the skeleton\n     * @param applyMorph  defines whether to apply the morph target\n     * @returns the normals data\n     */\n    AbstractMesh.prototype.getNormalsData = function (applySkeleton, applyMorph) {\n        if (applySkeleton === void 0) { applySkeleton = false; }\n        if (applyMorph === void 0) { applyMorph = false; }\n        return this._getData(applySkeleton, applyMorph, null, VertexBuffer.NormalKind);\n    };\n    /**\n     * Get the position vertex data and optionally apply skeleton and morphing.\n     * @param applySkeleton defines whether to apply the skeleton\n     * @param applyMorph  defines whether to apply the morph target\n     * @param data defines the position data to apply the skeleton and morph to\n     * @returns the position data\n     */\n    AbstractMesh.prototype.getPositionData = function (applySkeleton, applyMorph, data) {\n        if (applySkeleton === void 0) { applySkeleton = false; }\n        if (applyMorph === void 0) { applyMorph = false; }\n        return this._getData(applySkeleton, applyMorph, data, VertexBuffer.PositionKind);\n    };\n    /**\n     * @param applySkeleton\n     * @param applyMorph\n     * @hidden\n     */\n    AbstractMesh.prototype._getPositionData = function (applySkeleton, applyMorph) {\n        var _a;\n        var data = this.getVerticesData(VertexBuffer.PositionKind);\n        if (this._internalAbstractMeshDataInfo._positions) {\n            this._internalAbstractMeshDataInfo._positions = null;\n        }\n        if (data && ((applySkeleton && this.skeleton) || (applyMorph && this.morphTargetManager))) {\n            data = data.slice();\n            this._generatePointsArray();\n            if (this._positions) {\n                var pos = this._positions;\n                this._internalAbstractMeshDataInfo._positions = new Array(pos.length);\n                for (var i = 0; i < pos.length; i++) {\n                    this._internalAbstractMeshDataInfo._positions[i] = ((_a = pos[i]) === null || _a === void 0 ? void 0 : _a.clone()) || new Vector3();\n                }\n            }\n            return this.getPositionData(applySkeleton, applyMorph, data);\n        }\n        return data;\n    };\n    /** @hidden */\n    AbstractMesh.prototype._updateBoundingInfo = function () {\n        if (this._boundingInfo) {\n            this._boundingInfo.update(this.worldMatrixFromCache);\n        }\n        else {\n            this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);\n        }\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n        return this;\n    };\n    /**\n     * @param matrix\n     * @hidden\n     */\n    AbstractMesh.prototype._updateSubMeshesBoundingInfo = function (matrix) {\n        if (!this.subMeshes) {\n            return this;\n        }\n        var count = this.subMeshes.length;\n        for (var subIndex = 0; subIndex < count; subIndex++) {\n            var subMesh = this.subMeshes[subIndex];\n            if (count > 1 || !subMesh.IsGlobal) {\n                subMesh.updateBoundingInfo(matrix);\n            }\n        }\n        return this;\n    };\n    /** @hidden */\n    AbstractMesh.prototype._afterComputeWorldMatrix = function () {\n        if (this.doNotSyncBoundingInfo) {\n            return;\n        }\n        // Bounding info\n        this._boundingInfoIsDirty = true;\n    };\n    /**\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n     * A mesh is in the frustum if its bounding box intersects the frustum\n     * @param frustumPlanes defines the frustum to test\n     * @returns true if the mesh is in the frustum planes\n     */\n    AbstractMesh.prototype.isInFrustum = function (frustumPlanes) {\n        return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);\n    };\n    /**\n     * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\n     * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\n     * @param frustumPlanes defines the frustum to test\n     * @returns true if the mesh is completely in the frustum planes\n     */\n    AbstractMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n        return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);\n    };\n    /**\n     * True if the mesh intersects another mesh or a SolidParticle object\n     * @param mesh defines a target mesh or SolidParticle to test\n     * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\n     * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes\n     * @returns true if there is an intersection\n     */\n    AbstractMesh.prototype.intersectsMesh = function (mesh, precise, includeDescendants) {\n        if (precise === void 0) { precise = false; }\n        var boundingInfo = this.getBoundingInfo();\n        var otherBoundingInfo = mesh.getBoundingInfo();\n        if (boundingInfo.intersects(otherBoundingInfo, precise)) {\n            return true;\n        }\n        if (includeDescendants) {\n            for (var _i = 0, _a = this.getChildMeshes(); _i < _a.length; _i++) {\n                var child = _a[_i];\n                if (child.intersectsMesh(mesh, precise, true)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * Returns true if the passed point (Vector3) is inside the mesh bounding box\n     * @param point defines the point to test\n     * @returns true if there is an intersection\n     */\n    AbstractMesh.prototype.intersectsPoint = function (point) {\n        return this.getBoundingInfo().intersectsPoint(point);\n    };\n    Object.defineProperty(AbstractMesh.prototype, \"checkCollisions\", {\n        // Collisions\n        /**\n         * Gets or sets a boolean indicating that this mesh can be used in the collision engine\n         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;\n        },\n        set: function (collisionEnabled) {\n            this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AbstractMesh.prototype, \"collider\", {\n        /**\n         * Gets Collider object used to compute collisions (not physics)\n         * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n         */\n        get: function () {\n            return this._internalAbstractMeshDataInfo._meshCollisionData._collider;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Move the mesh using collision engine\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     * @param displacement defines the requested displacement vector\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.moveWithCollisions = function (displacement) {\n        var globalPosition = this.getAbsolutePosition();\n        globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);\n        var coordinator = this.getScene().collisionCoordinator;\n        if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {\n            this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();\n        }\n        this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;\n        coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);\n        return this;\n    };\n    // Collisions\n    /**\n     * @param subMesh\n     * @param transformMatrix\n     * @param collider\n     * @hidden\n     */\n    AbstractMesh.prototype._collideForSubMesh = function (subMesh, transformMatrix, collider) {\n        var _a;\n        this._generatePointsArray();\n        if (!this._positions) {\n            return this;\n        }\n        // Transformation\n        if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {\n            subMesh._lastColliderTransformMatrix = transformMatrix.clone();\n            subMesh._lastColliderWorldVertices = [];\n            subMesh._trianglePlanes = [];\n            var start = subMesh.verticesStart;\n            var end = subMesh.verticesStart + subMesh.verticesCount;\n            for (var i = start; i < end; i++) {\n                subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));\n            }\n        }\n        // Collide\n        collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.fillMode) === 7);\n        return this;\n    };\n    /**\n     * @param collider\n     * @param transformMatrix\n     * @hidden\n     */\n    AbstractMesh.prototype._processCollisionsForSubMeshes = function (collider, transformMatrix) {\n        var subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);\n        var len = subMeshes.length;\n        for (var index = 0; index < len; index++) {\n            var subMesh = subMeshes.data[index];\n            // Bounding test\n            if (len > 1 && !subMesh._checkCollision(collider)) {\n                continue;\n            }\n            this._collideForSubMesh(subMesh, transformMatrix, collider);\n        }\n        return this;\n    };\n    /** @hidden */\n    AbstractMesh.prototype._shouldConvertRHS = function () {\n        return false;\n    };\n    /**\n     * @param collider\n     * @hidden\n     */\n    AbstractMesh.prototype._checkCollision = function (collider) {\n        // Bounding box test\n        if (!this.getBoundingInfo()._checkCollision(collider)) {\n            return this;\n        }\n        // Transformation matrix\n        var collisionsScalingMatrix = TmpVectors.Matrix[0];\n        var collisionsTransformMatrix = TmpVectors.Matrix[1];\n        Matrix.ScalingToRef(1.0 / collider._radius.x, 1.0 / collider._radius.y, 1.0 / collider._radius.z, collisionsScalingMatrix);\n        this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);\n        this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);\n        return this;\n    };\n    // Picking\n    /** @hidden */\n    AbstractMesh.prototype._generatePointsArray = function () {\n        return false;\n    };\n    /**\n     * Checks if the passed Ray intersects with the mesh\n     * @param ray defines the ray to use\n     * @param fastCheck defines if fast mode (but less precise) must be used (false by default)\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n     * @returns the picking info\n     * @see https://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh\n     */\n    AbstractMesh.prototype.intersects = function (ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo) {\n        if (onlyBoundingInfo === void 0) { onlyBoundingInfo = false; }\n        if (skipBoundingInfo === void 0) { skipBoundingInfo = false; }\n        var pickingInfo = new PickingInfo();\n        var intersectionThreshold = this.getClassName() === \"InstancedLinesMesh\" || this.getClassName() === \"LinesMesh\" ? this.intersectionThreshold : 0;\n        var boundingInfo = this.getBoundingInfo();\n        if (!this.subMeshes) {\n            return pickingInfo;\n        }\n        if (!skipBoundingInfo &&\n            (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {\n            return pickingInfo;\n        }\n        if (onlyBoundingInfo) {\n            pickingInfo.hit = skipBoundingInfo ? false : true;\n            pickingInfo.pickedMesh = skipBoundingInfo ? null : this;\n            pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n            pickingInfo.subMeshId = 0;\n            return pickingInfo;\n        }\n        if (!this._generatePointsArray()) {\n            return pickingInfo;\n        }\n        var intersectInfo = null;\n        var subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);\n        var len = subMeshes.length;\n        // Check if all submeshes are using a material that don't allow picking (point/lines rendering)\n        // if no submesh can be picked that way, then fallback to BBox picking\n        var anySubmeshSupportIntersect = false;\n        for (var index = 0; index < len; index++) {\n            var subMesh = subMeshes.data[index];\n            var material = subMesh.getMaterial();\n            if (!material) {\n                continue;\n            }\n            if (material.fillMode == 7 ||\n                material.fillMode == 0 ||\n                material.fillMode == 1 ||\n                material.fillMode == 2 ||\n                material.fillMode == 4) {\n                anySubmeshSupportIntersect = true;\n                break;\n            }\n        }\n        // no sub mesh support intersection, fallback to BBox that has already be done\n        if (!anySubmeshSupportIntersect) {\n            pickingInfo.hit = true;\n            pickingInfo.pickedMesh = this;\n            pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n            pickingInfo.subMeshId = -1;\n            return pickingInfo;\n        }\n        // at least 1 submesh supports intersection, keep going\n        for (var index = 0; index < len; index++) {\n            var subMesh = subMeshes.data[index];\n            // Bounding test\n            if (len > 1 && !subMesh.canIntersects(ray)) {\n                continue;\n            }\n            var currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);\n            if (currentIntersectInfo) {\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n                    intersectInfo = currentIntersectInfo;\n                    intersectInfo.subMeshId = index;\n                    if (fastCheck) {\n                        break;\n                    }\n                }\n            }\n        }\n        if (intersectInfo) {\n            // Get picked point\n            var world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.getWorldMatrix();\n            var worldOrigin = TmpVectors.Vector3[0];\n            var direction = TmpVectors.Vector3[1];\n            Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);\n            ray.direction.scaleToRef(intersectInfo.distance, direction);\n            var worldDirection = Vector3.TransformNormal(direction, world);\n            var pickedPoint = worldDirection.addInPlace(worldOrigin);\n            // Return result\n            pickingInfo.hit = true;\n            pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);\n            pickingInfo.pickedPoint = pickedPoint;\n            pickingInfo.pickedMesh = this;\n            pickingInfo.bu = intersectInfo.bu || 0;\n            pickingInfo.bv = intersectInfo.bv || 0;\n            pickingInfo.subMeshFaceId = intersectInfo.faceId;\n            pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf(\"LinesMesh\") !== -1 ? 2 : 3);\n            pickingInfo.subMeshId = intersectInfo.subMeshId;\n            return pickingInfo;\n        }\n        return pickingInfo;\n    };\n    /**\n     * Clones the current mesh\n     * @param name defines the mesh name\n     * @param newParent defines the new mesh parent\n     * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)\n     * @returns the new mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n        return null;\n    };\n    /**\n     * Disposes all the submeshes of the current meshnp\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.releaseSubMeshes = function () {\n        if (this.subMeshes) {\n            while (this.subMeshes.length) {\n                this.subMeshes[0].dispose();\n            }\n        }\n        else {\n            this.subMeshes = new Array();\n        }\n        return this;\n    };\n    /**\n     * Releases resources associated with this abstract mesh.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    AbstractMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n        var _this = this;\n        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }\n        var index;\n        // mesh map release.\n        if (this._scene.useMaterialMeshMap) {\n            // remove from material mesh map id needed\n            if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {\n                this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = undefined;\n            }\n        }\n        // Smart Array Retainers.\n        this.getScene().freeActiveMeshes();\n        this.getScene().freeRenderingGroups();\n        // Action manager\n        if (this.actionManager !== undefined && this.actionManager !== null) {\n            this.actionManager.dispose();\n            this.actionManager = null;\n        }\n        // Skeleton\n        this._internalAbstractMeshDataInfo._skeleton = null;\n        if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n            this._transformMatrixTexture = null;\n        }\n        // Intersections in progress\n        for (index = 0; index < this._intersectionsInProgress.length; index++) {\n            var other = this._intersectionsInProgress[index];\n            var pos = other._intersectionsInProgress.indexOf(this);\n            other._intersectionsInProgress.splice(pos, 1);\n        }\n        this._intersectionsInProgress = [];\n        // Lights\n        var lights = this.getScene().lights;\n        lights.forEach(function (light) {\n            var meshIndex = light.includedOnlyMeshes.indexOf(_this);\n            if (meshIndex !== -1) {\n                light.includedOnlyMeshes.splice(meshIndex, 1);\n            }\n            meshIndex = light.excludedMeshes.indexOf(_this);\n            if (meshIndex !== -1) {\n                light.excludedMeshes.splice(meshIndex, 1);\n            }\n            // Shadow generators\n            var generator = light.getShadowGenerator();\n            if (generator) {\n                var shadowMap = generator.getShadowMap();\n                if (shadowMap && shadowMap.renderList) {\n                    meshIndex = shadowMap.renderList.indexOf(_this);\n                    if (meshIndex !== -1) {\n                        shadowMap.renderList.splice(meshIndex, 1);\n                    }\n                }\n            }\n        });\n        // SubMeshes\n        if (this.getClassName() !== \"InstancedMesh\" || this.getClassName() !== \"InstancedLinesMesh\") {\n            this.releaseSubMeshes();\n        }\n        // Query\n        var engine = this.getScene().getEngine();\n        if (this._occlusionQuery !== null) {\n            this.isOcclusionQueryInProgress = false;\n            engine.deleteQuery(this._occlusionQuery);\n            this._occlusionQuery = null;\n        }\n        // Engine\n        engine.wipeCaches();\n        // Remove from scene\n        this.getScene().removeMesh(this);\n        if (this._parentContainer) {\n            var index_1 = this._parentContainer.meshes.indexOf(this);\n            if (index_1 > -1) {\n                this._parentContainer.meshes.splice(index_1, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (disposeMaterialAndTextures) {\n            if (this.material) {\n                if (this.material.getClassName() === \"MultiMaterial\") {\n                    this.material.dispose(false, true, true);\n                }\n                else {\n                    this.material.dispose(false, true);\n                }\n            }\n        }\n        if (!doNotRecurse) {\n            // Particles\n            for (index = 0; index < this.getScene().particleSystems.length; index++) {\n                if (this.getScene().particleSystems[index].emitter === this) {\n                    this.getScene().particleSystems[index].dispose();\n                    index--;\n                }\n            }\n        }\n        // facet data\n        if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {\n            this.disableFacetData();\n        }\n        this._uniformBuffer.dispose();\n        this.onAfterWorldMatrixUpdateObservable.clear();\n        this.onCollideObservable.clear();\n        this.onCollisionPositionChangeObservable.clear();\n        this.onRebuildObservable.clear();\n        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n    };\n    /**\n     * Adds the passed mesh as a child to the current mesh\n     * @param mesh defines the child mesh\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.addChild = function (mesh, preserveScalingSign) {\n        if (preserveScalingSign === void 0) { preserveScalingSign = false; }\n        mesh.setParent(this, preserveScalingSign);\n        return this;\n    };\n    /**\n     * Removes the passed mesh from the current mesh children list\n     * @param mesh defines the child mesh\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.removeChild = function (mesh, preserveScalingSign) {\n        if (preserveScalingSign === void 0) { preserveScalingSign = false; }\n        mesh.setParent(null, preserveScalingSign);\n        return this;\n    };\n    // Facet data\n    /** @hidden */\n    AbstractMesh.prototype._initFacetData = function () {\n        var data = this._internalAbstractMeshDataInfo._facetData;\n        if (!data.facetNormals) {\n            data.facetNormals = new Array();\n        }\n        if (!data.facetPositions) {\n            data.facetPositions = new Array();\n        }\n        if (!data.facetPartitioning) {\n            data.facetPartitioning = new Array();\n        }\n        data.facetNb = (this.getIndices().length / 3) | 0;\n        data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10; // default nb of partitioning subdivisions = 10\n        data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01; // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\n        for (var f = 0; f < data.facetNb; f++) {\n            data.facetNormals[f] = Vector3.Zero();\n            data.facetPositions[f] = Vector3.Zero();\n        }\n        data.facetDataEnabled = true;\n        return this;\n    };\n    /**\n     * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\n     * This method can be called within the render loop.\n     * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation\n     * @returns the current mesh\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.updateFacetData = function () {\n        var data = this._internalAbstractMeshDataInfo._facetData;\n        if (!data.facetDataEnabled) {\n            this._initFacetData();\n        }\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\n        var indices = this.getIndices();\n        var normals = this.getVerticesData(VertexBuffer.NormalKind);\n        var bInfo = this.getBoundingInfo();\n        if (data.facetDepthSort && !data.facetDepthSortEnabled) {\n            // init arrays, matrix and sort function on first call\n            data.facetDepthSortEnabled = true;\n            if (indices instanceof Uint16Array) {\n                data.depthSortedIndices = new Uint16Array(indices);\n            }\n            else if (indices instanceof Uint32Array) {\n                data.depthSortedIndices = new Uint32Array(indices);\n            }\n            else {\n                var needs32bits = false;\n                for (var i = 0; i < indices.length; i++) {\n                    if (indices[i] > 65535) {\n                        needs32bits = true;\n                        break;\n                    }\n                }\n                if (needs32bits) {\n                    data.depthSortedIndices = new Uint32Array(indices);\n                }\n                else {\n                    data.depthSortedIndices = new Uint16Array(indices);\n                }\n            }\n            data.facetDepthSortFunction = function (f1, f2) {\n                return f2.sqDistance - f1.sqDistance;\n            };\n            if (!data.facetDepthSortFrom) {\n                var camera = this.getScene().activeCamera;\n                data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();\n            }\n            data.depthSortedFacets = [];\n            for (var f = 0; f < data.facetNb; f++) {\n                var depthSortedFacet = { ind: f * 3, sqDistance: 0.0 };\n                data.depthSortedFacets.push(depthSortedFacet);\n            }\n            data.invertedMatrix = Matrix.Identity();\n            data.facetDepthSortOrigin = Vector3.Zero();\n        }\n        data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;\n        data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;\n        data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;\n        var bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;\n        bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;\n        data.subDiv.max = data.partitioningSubdivisions;\n        data.subDiv.X = Math.floor((data.subDiv.max * data.bbSize.x) / bbSizeMax); // adjust the number of subdivisions per axis\n        data.subDiv.Y = Math.floor((data.subDiv.max * data.bbSize.y) / bbSizeMax); // according to each bbox size per axis\n        data.subDiv.Z = Math.floor((data.subDiv.max * data.bbSize.z) / bbSizeMax);\n        data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X; // at least one subdivision\n        data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;\n        data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;\n        // set the parameters for ComputeNormals()\n        data.facetParameters.facetNormals = this.getFacetLocalNormals();\n        data.facetParameters.facetPositions = this.getFacetLocalPositions();\n        data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\n        data.facetParameters.bInfo = bInfo;\n        data.facetParameters.bbSize = data.bbSize;\n        data.facetParameters.subDiv = data.subDiv;\n        data.facetParameters.ratio = this.partitioningBBoxRatio;\n        data.facetParameters.depthSort = data.facetDepthSort;\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\n            this.computeWorldMatrix(true);\n            this._worldMatrix.invertToRef(data.invertedMatrix);\n            Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);\n            data.facetParameters.distanceTo = data.facetDepthSortOrigin;\n        }\n        data.facetParameters.depthSortedFacets = data.depthSortedFacets;\n        if (normals) {\n            VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);\n        }\n        if (data.facetDepthSort && data.facetDepthSortEnabled) {\n            data.depthSortedFacets.sort(data.facetDepthSortFunction);\n            var l = (data.depthSortedIndices.length / 3) | 0;\n            for (var f = 0; f < l; f++) {\n                var sind = data.depthSortedFacets[f].ind;\n                data.depthSortedIndices[f * 3] = indices[sind];\n                data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];\n                data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];\n            }\n            this.updateIndices(data.depthSortedIndices, undefined, true);\n        }\n        return this;\n    };\n    /**\n     * Returns the facetLocalNormals array.\n     * The normals are expressed in the mesh local spac\n     * @returns an array of Vector3\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getFacetLocalNormals = function () {\n        var facetData = this._internalAbstractMeshDataInfo._facetData;\n        if (!facetData.facetNormals) {\n            this.updateFacetData();\n        }\n        return facetData.facetNormals;\n    };\n    /**\n     * Returns the facetLocalPositions array.\n     * The facet positions are expressed in the mesh local space\n     * @returns an array of Vector3\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getFacetLocalPositions = function () {\n        var facetData = this._internalAbstractMeshDataInfo._facetData;\n        if (!facetData.facetPositions) {\n            this.updateFacetData();\n        }\n        return facetData.facetPositions;\n    };\n    /**\n     * Returns the facetLocalPartitioning array\n     * @returns an array of array of numbers\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getFacetLocalPartitioning = function () {\n        var facetData = this._internalAbstractMeshDataInfo._facetData;\n        if (!facetData.facetPartitioning) {\n            this.updateFacetData();\n        }\n        return facetData.facetPartitioning;\n    };\n    /**\n     * Returns the i-th facet position in the world system.\n     * This method allocates a new Vector3 per call\n     * @param i defines the facet index\n     * @returns a new Vector3\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getFacetPosition = function (i) {\n        var pos = Vector3.Zero();\n        this.getFacetPositionToRef(i, pos);\n        return pos;\n    };\n    /**\n     * Sets the reference Vector3 with the i-th facet position in the world system\n     * @param i defines the facet index\n     * @param ref defines the target vector\n     * @returns the current mesh\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getFacetPositionToRef = function (i, ref) {\n        var localPos = this.getFacetLocalPositions()[i];\n        var world = this.getWorldMatrix();\n        Vector3.TransformCoordinatesToRef(localPos, world, ref);\n        return this;\n    };\n    /**\n     * Returns the i-th facet normal in the world system.\n     * This method allocates a new Vector3 per call\n     * @param i defines the facet index\n     * @returns a new Vector3\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getFacetNormal = function (i) {\n        var norm = Vector3.Zero();\n        this.getFacetNormalToRef(i, norm);\n        return norm;\n    };\n    /**\n     * Sets the reference Vector3 with the i-th facet normal in the world system\n     * @param i defines the facet index\n     * @param ref defines the target vector\n     * @returns the current mesh\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getFacetNormalToRef = function (i, ref) {\n        var localNorm = this.getFacetLocalNormals()[i];\n        Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\n        return this;\n    };\n    /**\n     * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)\n     * @param x defines x coordinate\n     * @param y defines y coordinate\n     * @param z defines z coordinate\n     * @returns the array of facet indexes\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getFacetsAtLocalCoordinates = function (x, y, z) {\n        var bInfo = this.getBoundingInfo();\n        var data = this._internalAbstractMeshDataInfo._facetData;\n        var ox = Math.floor(((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio) / data.bbSize.x);\n        var oy = Math.floor(((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio) / data.bbSize.y);\n        var oz = Math.floor(((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio) / data.bbSize.z);\n        if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {\n            return null;\n        }\n        return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];\n    };\n    /**\n     * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found\n     * @param x defines x coordinate\n     * @param y defines y coordinate\n     * @param z defines z coordinate\n     * @param projected sets as the (x,y,z) world projection on the facet\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\n     * @returns the face index if found (or null instead)\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getClosestFacetAtCoordinates = function (x, y, z, projected, checkFace, facing) {\n        if (checkFace === void 0) { checkFace = false; }\n        if (facing === void 0) { facing = true; }\n        var world = this.getWorldMatrix();\n        var invMat = TmpVectors.Matrix[5];\n        world.invertToRef(invMat);\n        var invVect = TmpVectors.Vector3[8];\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect); // transform (x,y,z) to coordinates in the mesh local space\n        var closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\n        if (projected) {\n            // transform the local computed projected vector to world coordinates\n            Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\n        }\n        return closest;\n    };\n    /**\n     * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found\n     * @param x defines x coordinate\n     * @param y defines y coordinate\n     * @param z defines z coordinate\n     * @param projected sets as the (x,y,z) local projection on the facet\n     * @param checkFace if true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned\n     * @param facing if facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position\n     * @returns the face index if found (or null instead)\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getClosestFacetAtLocalCoordinates = function (x, y, z, projected, checkFace, facing) {\n        if (checkFace === void 0) { checkFace = false; }\n        if (facing === void 0) { facing = true; }\n        var closest = null;\n        var tmpx = 0.0;\n        var tmpy = 0.0;\n        var tmpz = 0.0;\n        var d = 0.0; // tmp dot facet normal * facet position\n        var t0 = 0.0;\n        var projx = 0.0;\n        var projy = 0.0;\n        var projz = 0.0;\n        // Get all the facets in the same partitioning block than (x, y, z)\n        var facetPositions = this.getFacetLocalPositions();\n        var facetNormals = this.getFacetLocalNormals();\n        var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\n        if (!facetsInBlock) {\n            return null;\n        }\n        // Get the closest facet to (x, y, z)\n        var shortest = Number.MAX_VALUE; // init distance vars\n        var tmpDistance = shortest;\n        var fib; // current facet in the block\n        var norm; // current facet normal\n        var p0; // current facet barycenter position\n        // loop on all the facets in the current partitioning block\n        for (var idx = 0; idx < facetsInBlock.length; idx++) {\n            fib = facetsInBlock[idx];\n            norm = facetNormals[fib];\n            p0 = facetPositions[fib];\n            d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\n            if (!checkFace || (checkFace && facing && d >= 0.0) || (checkFace && !facing && d <= 0.0)) {\n                // compute (x,y,z) projection on the facet = (projx, projy, projz)\n                d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\n                t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\n                projx = x + norm.x * t0;\n                projy = y + norm.y * t0;\n                projz = z + norm.z * t0;\n                tmpx = projx - x;\n                tmpy = projy - y;\n                tmpz = projz - z;\n                tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz; // compute length between (x, y, z) and its projection on the facet\n                if (tmpDistance < shortest) {\n                    // just keep the closest facet to (x, y, z)\n                    shortest = tmpDistance;\n                    closest = fib;\n                    if (projected) {\n                        projected.x = projx;\n                        projected.y = projy;\n                        projected.z = projz;\n                    }\n                }\n            }\n        }\n        return closest;\n    };\n    /**\n     * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\n     * @returns the parameters\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.getFacetDataParameters = function () {\n        return this._internalAbstractMeshDataInfo._facetData.facetParameters;\n    };\n    /**\n     * Disables the feature FacetData and frees the related memory\n     * @returns the current mesh\n     * @see https://doc.babylonjs.com/how_to/how_to_use_facetdata\n     */\n    AbstractMesh.prototype.disableFacetData = function () {\n        var facetData = this._internalAbstractMeshDataInfo._facetData;\n        if (facetData.facetDataEnabled) {\n            facetData.facetDataEnabled = false;\n            facetData.facetPositions = new Array();\n            facetData.facetNormals = new Array();\n            facetData.facetPartitioning = new Array();\n            facetData.facetParameters = null;\n            facetData.depthSortedIndices = new Uint32Array(0);\n        }\n        return this;\n    };\n    /**\n     * Updates the AbstractMesh indices array\n     * @param indices defines the data source\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n     * @returns the current mesh\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\n        if (gpuMemoryOnly === void 0) { gpuMemoryOnly = false; }\n        return this;\n    };\n    /**\n     * Creates new normals data for the mesh\n     * @param updatable defines if the normal vertex buffer must be flagged as updatable\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.createNormals = function (updatable) {\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\n        var indices = this.getIndices();\n        var normals;\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n            normals = this.getVerticesData(VertexBuffer.NormalKind);\n        }\n        else {\n            normals = [];\n        }\n        VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);\n        return this;\n    };\n    /**\n     * Align the mesh with a normal\n     * @param normal defines the normal to use\n     * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)\n     * @returns the current mesh\n     */\n    AbstractMesh.prototype.alignWithNormal = function (normal, upDirection) {\n        if (!upDirection) {\n            upDirection = Axis.Y;\n        }\n        var axisX = TmpVectors.Vector3[0];\n        var axisZ = TmpVectors.Vector3[1];\n        Vector3.CrossToRef(upDirection, normal, axisZ);\n        Vector3.CrossToRef(normal, axisZ, axisX);\n        if (this.rotationQuaternion) {\n            Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);\n        }\n        else {\n            Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);\n        }\n        return this;\n    };\n    /** @hidden */\n    AbstractMesh.prototype._checkOcclusionQuery = function () {\n        // Will be replaced by correct code if Occlusion queries are referenced\n        return false;\n    };\n    /**\n     * Disables the mesh edge rendering mode\n     * @returns the currentAbstractMesh\n     */\n    AbstractMesh.prototype.disableEdgesRendering = function () {\n        throw _WarnImport(\"EdgesRenderer\");\n    };\n    /**\n     * Enables the edge rendering mode on the mesh.\n     * This mode makes the mesh edges visible\n     * @param epsilon defines the maximal distance between two angles to detect a face\n     * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces\n     * @param options options to the edge renderer\n     * @returns the currentAbstractMesh\n     * @see https://www.babylonjs-playground.com/#19O9TU#0\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    AbstractMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices, options) {\n        throw _WarnImport(\"EdgesRenderer\");\n    };\n    /**\n     * This function returns all of the particle systems in the scene that use the mesh as an emitter.\n     * @returns an array of particle systems in the scene that use the mesh as an emitter\n     */\n    AbstractMesh.prototype.getConnectedParticleSystems = function () {\n        var _this = this;\n        return this._scene.particleSystems.filter(function (particleSystem) { return particleSystem.emitter === _this; });\n    };\n    /** No occlusion */\n    AbstractMesh.OCCLUSION_TYPE_NONE = 0;\n    /** Occlusion set to optimistic */\n    AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC = 1;\n    /** Occlusion set to strict */\n    AbstractMesh.OCCLUSION_TYPE_STRICT = 2;\n    /** Use an accurate occlusion algorithm */\n    AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;\n    /** Use a conservative occlusion algorithm */\n    AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;\n    /** Default culling strategy : this is an exclusion test and it's the more accurate.\n     *  Test order :\n     *  Is the bounding sphere outside the frustum ?\n     *  If not, are the bounding box vertices outside the frustum ?\n     *  It not, then the cullable object is in the frustum.\n     */\n    AbstractMesh.CULLINGSTRATEGY_STANDARD = 0;\n    /** Culling strategy : Bounding Sphere Only.\n     *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\n     *  It's also less accurate than the standard because some not visible objects can still be selected.\n     *  Test : is the bounding sphere outside the frustum ?\n     *  If not, then the cullable object is in the frustum.\n     */\n    AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;\n    /** Culling strategy : Optimistic Inclusion.\n     *  This in an inclusion test first, then the standard exclusion test.\n     *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\n     *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\n     *  Anyway, it's as accurate as the standard strategy.\n     *  Test :\n     *  Is the cullable object bounding sphere center in the frustum ?\n     *  If not, apply the default culling strategy.\n     */\n    AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;\n    /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\n     *  This in an inclusion test first, then the bounding sphere only exclusion test.\n     *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\n     *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\n     *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\n     *  Test :\n     *  Is the cullable object bounding sphere center in the frustum ?\n     *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\n     */\n    AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;\n    return AbstractMesh;\n}(TransformNode));\nexport { AbstractMesh };\nRegisterClass(\"BABYLON.AbstractMesh\", AbstractMesh);\n//# sourceMappingURL=abstractMesh.js.map"],"names":["Space","Coordinate","Axis","X","Y","Z","Color3","r","g","b","this","prototype","toString","getClassName","getHashCode","hash","toArray","array","index","fromArray","offset","FromArrayToRef","toColor4","alpha","Color4","asArray","toLuminance","multiply","otherColor","multiplyToRef","result","equals","equalsFloats","scale","scaleToRef","scaleAndAddToRef","clampToRef","min","max","add","addToRef","subtract","subtractToRef","clone","copyFrom","source","copyFromFloats","set","toHexString","intR","Math","round","intG","intB","toLinearSpace","convertedColor","toLinearSpaceToRef","toHSV","toHSVToRef","h","s","v","dm","pow","toGammaSpace","toGammaSpaceToRef","HSVtoRGBToRef","hue","saturation","value","chroma","x","abs","m","FromHexString","hex","substring","length","parseInt","FromInts","FromArray","Lerp","start","end","amount","LerpToRef","left","right","Hermite","value1","tangent1","value2","tangent2","squared","cubed","part1","part2","part3","part4","Hermite1stDerivative","time","Black","Hermite1stDerivativeToRef","t2","Red","Green","Blue","Object","defineProperty","get","_BlackReadOnly","enumerable","configurable","White","Purple","Magenta","Yellow","Gray","Teal","Random","random","a","addInPlace","color","returnAsColor3","intA","FromColor3","color3","CheckColors4","colors","count","colors4","newIndex","TmpColors","ToGammaSpace","ToLinearSpace","PHI","sqrt","Epsilon","Frustum","GetPlanes","transform","frustumPlanes","push","GetPlanesToRef","GetNearPlaneToRef","frustumPlane","normal","y","z","d","normalize","GetFarPlaneToRef","GetLeftPlaneToRef","GetRightPlaneToRef","GetTopPlaneToRef","GetBottomPlaneToRef","MathHelpers","extractMinAndMaxIndexed","positions","indices","indexStart","indexCount","minimum","maximum","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","extractMinAndMax","stride","_a","_i","arguments","Array","isArray","bias","Number","MAX_VALUE","_IsoVector","floor","rotate60About","other","rotateNeg60About","rotate120","n","rotateNeg120","toCartesianOrigin","origin","isoGridSize","point","Zero","Orientation","BezierCurve","Interpolate","t","x1","y1","x2","y2","f0","f1","f2","refinedT","i","refinedT2","Angle","radians","_radians","PI","degrees","BetweenTwoPoints","delta","atan2","FromRadians","FromDegrees","Arc2","startPoint","midPoint","endPoint","temp","startToMid","midToEnd","det","centerPoint","radius","startAngle","a1","a2","a3","orientation","CW","CCW","angle","Path2","_points","_length","closed","addLineTo","newPoint","previousPoint","addArcTo","midX","midY","endX","endY","numberOfSegments","arc","increment","currentAngle","cos","sin","close","lastPoint","getPoints","getPointAtLengthPosition","normalizedLengthPosition","lengthPosition","previousOffset","j","bToA","nextOffset","dir","localOffset","StartingAt","Path3D","path","firstNormal","raw","alignTangentsWithPath","_curve","_distances","_tangents","_normals","_binormals","_pointAtData","id","previousPointArrayIndex","position","subPosition","interpolateReady","interpolationMatrix","p","_raw","_alignTangentsWithPath","_compute","getCurve","getTangents","getNormals","getBinormals","getDistances","getPointAt","_updatePointAtData","getTangentAt","interpolated","getNormalAt","getBinormalAt","getDistanceAt","getPreviousPointIndexAt","getSubPositionAt","getClosestPositionTo","target","smallestDistance","closestPosition","tangent","subLength","distance","slice","_start","curvePoints","startIndex","endIndex","slicePoints","apply","update","l","_getFirstNonNullVector","prev","cur","curTang","prevNor","prevBinor","tg0","pp0","_normalVector","_getLastNonNullVector","NaN","nNVector","nLVector","vt","va","normal0","tgl","interpolateTNB","_updateInterpolationMatrix","_setPointAtData","currentPoint","currentLength","targetLength","diff","scaleInPlace","parentIndex","tangentFrom","normalFrom","binormalFrom","tangentTo","normalTo","binormalTo","quatFrom","quatTo","toRotationMatrix","Curve3","points","_computeLength","CreateQuadraticBezier","v0","v1","v2","nbPoints","bez","equation","val0","val1","val2","CreateCubicBezier","v3","val3","CreateHermiteSpline","p1","t1","p2","hermite","step","CreateCatmullRomSpline","catmullRom","pointsCount","c","totalPoints","ArcThru3Points","first","second","third","steps","fullCircle","vec1","vec2","vec3","zAxis","len4","len1_sq","lengthSquared","len2_sq","len3_sq","len4_sq","center","xAxis","yAxis","dStep","theta","equalsWithEpsilon","continue","curve","continuedPoints","Plane","norm","magnitude","transformation","invertedMatrix","_TmpMatrix","invertToRef","dotCoordinate","copyFromPoints","point1","point2","point3","invPyth","z1","z2","yz","xz","xy","pyth","isFrontFacingTo","direction","epsilon","signedDistanceTo","FromPoints","FromPositionAndNormal","SignedDistanceToPlaneFromPositionAndNormal","Scalar","WithinEpsilon","ToHex","str","toUpperCase","Sign","isNaN","Clamp","Log2","log","LOG2E","ILog2","log2","Infinity","Repeat","Normalize","Denormalize","normalized","DeltaAngle","current","num","PingPong","tx","SmoothStep","from","to","MoveTowards","maxDelta","MoveTowardsAngle","LerpAngle","InverseLerp","RandomRange","RangeToPercent","number","PercentToRange","percent","NormalizeRadians","TwoPi","HCF","Size","width","height","concat","src","multiplyByFloats","w","otherSize","_ExtractAsInt","replace","Vector2","otherVector","addVector3","subtractInPlace","multiplyInPlace","divide","divideToRef","divideInPlace","negate","negateInPlace","negateToRef","fract","rotateToRef","NormalizeToRef","One","CatmullRom","value3","value4","Dot","vector","newVector","len","Minimize","Maximize","Transform","TransformToRef","PointInTriangle","p0","sign","Distance","DistanceSquared","Center","CenterToRef","ref","DistanceOfPointFromSegment","segA","segB","l2","proj","Vector3","_isDirty","_x","_y","_z","toQuaternion","Quaternion","RotationYawPitchRoll","addInPlaceFromFloats","subtractFromFloatsToRef","subtractFromFloats","applyRotationQuaternionToRef","q","ix","iy","iz","iw","applyRotationQuaternionInPlace","applyRotationQuaternion","projectOnPlane","plane","projectOnPlaneToRef","V","MathTmp","denom","scaledV","equalsToFloats","minimizeInPlace","maximizeInPlace","isNonUniformWithinEpsilon","absX","absY","absZ","normalizeFromLength","reorderInPlace","order","_this","toLowerCase","forEach","val","rotateByQuaternionToRef","quaternion","Matrix","TransformCoordinatesToRef","rotateByQuaternionAroundPointToRef","cross","Cross","normalizeToNew","normalizeToRef","reference","setAll","GetClipFactor","vector0","vector1","axis","size","d0","GetAngleBetweenVectors","dot","acos","CrossToRef","GetAngleBetweenVectorsOnPlane","vNormal","forward","SlerpToRef","slerp","vector0Dir","vector1Dir","vector0Length","vector1Length","scale0","scale1","omega","invSin","SmoothToRef","goal","deltaTime","lerpTime","FromFloatArray","FromFloatArrayToRef","FromFloatsToRef","Up","_UpReadOnly","_RightReadOnly","_LeftReadOnly","_LeftHandedForwardReadOnly","_RightHandedForwardReadOnly","_ZeroReadOnly","Down","Forward","rightHandedSystem","Backward","Right","Left","TransformCoordinates","TransformCoordinatesFromFloatsToRef","rx","ry","rz","rw","TransformNormal","TransformNormalToRef","TransformNormalFromFloatsToRef","ClampToRef","CheckExtends","Project","world","viewport","ProjectToRef","cw","ch","cx","cy","viewportMatrix","FromValuesToRef","matrix","_UnprojectFromInvertedMatrixToRef","UnprojectFromTransform","viewportWidth","viewportHeight","Unproject","IdentityReadOnly","view","projection","UnprojectToRef","UnprojectFloatsToRef","sourceX","sourceY","sourceZ","invert","screenSource","isNDCHalfZRange","ProjectOnTriangleToRef","p1p0","p2p0","p2p1","vectorp0","p1p0L","p2p0L","p2p1L","nl","cosA","projVector","tmp","projP","s0","s1","e0","e1","s2","edge","tmp2","tmp3","e0proj","e0projL","cosG","triProj","RotationFromAxis","axis1","axis2","axis3","rotation","RotationFromAxisToRef","quat","RotationQuaternionFromAxisToRef","toEulerAnglesToRef","Vector4","undefined","toVector3","FromVector3","_w","otherQuaternion","q1","conjugateToRef","conjugateInPlace","conjugate","invertInPlace","inv","toEulerAngles","qz","qx","qy","qw","zAxisY","limit","sqw","sqz","sqx","sqy","asin","FromQuaternionToRef","fromRotationMatrix","FromRotationMatrixToRef","FromRotationMatrix","data","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","AreClose","quat0","quat1","Inverse","InverseToRef","Identity","IsIdentity","RotationAxis","RotationAxisToRef","FromEulerAngles","RotationYawPitchRollToRef","FromEulerAnglesToRef","FromEulerVector","vec","FromEulerVectorToRef","FromUnitVectorsToRef","vecFrom","vecTo","TmpVectors","yaw","pitch","roll","halfRoll","halfPitch","halfYaw","sinRoll","cosRoll","sinPitch","cosPitch","sinYaw","cosYaw","RotationAlphaBetaGamma","beta","gamma","RotationAlphaBetaGammaToRef","halfGammaPlusAlpha","halfGammaMinusAlpha","halfBeta","RotationQuaternionFromAxis","rotMat","FromXYZAxesToRef","FromLookDirectionLH","up","FromLookDirectionLHToRef","LookDirectionLHToRef","FromLookDirectionRH","FromLookDirectionRHToRef","LookDirectionRHToRef","Slerp","num2","num3","num4","flag","num5","num6","_isIdentity","_isIdentityDirty","_isIdentity3x2","_isIdentity3x2Dirty","updateFlag","_m","markAsUpdated","_UpdateFlagSeed","_updateIdentityStatus","isIdentity","isIdentityDirty","isIdentity3x2","isIdentity3x2Dirty","isIdentityAs3x2","determinant","m00","m01","m02","m03","m10","m20","m30","det_22_33","det_21_33","det_21_32","det_20_33","det_20_32","det_20_31","reset","resultM","otherM","addToSelf","IdentityToRef","cofact_00","cofact_01","cofact_02","cofact_03","detInv","det_12_33","det_11_33","det_11_32","det_10_33","det_10_32","det_10_31","det_12_23","det_11_23","det_11_22","det_10_23","det_10_22","det_10_21","cofact_10","cofact_11","cofact_12","cofact_13","cofact_20","cofact_21","cofact_22","cofact_23","cofact_30","cofact_31","cofact_32","cofact_33","addAtIndex","multiplyAtIndex","setTranslationFromFloats","addTranslationFromFloats","setTranslation","vector3","getTranslation","getTranslationToRef","removeRotationAndScaling","copyToArray","o","multiplyToArray","tm0","tm1","tm2","tm3","tm4","tm5","tm6","tm7","tm8","tm9","tm10","tm11","tm12","tm13","tm14","tm15","om0","om1","om2","om3","om4","om5","om6","om7","om8","om9","om10","om11","om12","om13","om14","om15","om","decomposeToTransformNode","node","rotationQuaternion","decompose","scaling","translation","preserveScalingNode","signX","signY","signZ","sx","sy","sz","getRow","setRow","row","setRowFromFloats","transpose","Transpose","transposeToRef","TransposeToRef","toNormalMatrix","getRotationMatrix","getRotationMatrixToRef","toggleModelMatrixHandInPlace","toggleProjectionMatrixHandInPlace","FromFloat32ArrayToRefScaled","_IdentityReadOnly","initialM11","initialM12","initialM13","initialM14","initialM21","initialM22","initialM23","initialM24","initialM31","initialM32","initialM33","initialM34","initialM41","initialM42","initialM43","initialM44","FromValues","Compose","ComposeToRef","xx","yy","zz","wx","wy","wz","identity","zero","RotationX","RotationXToRef","Invert","RotationY","RotationYToRef","RotationZ","RotationZToRef","c1","RotationAlignToRef","k","Scaling","ScalingToRef","Translation","TranslationToRef","startValue","endValue","gradient","startM","endM","DecomposeLerp","DecomposeLerpToRef","startScale","startRotation","startTranslation","endScale","endRotation","endTranslation","resultScale","resultRotation","resultTranslation","LookAtLH","eye","LookAtLHToRef","xSquareLength","ex","ey","ez","LookAtRH","LookAtRHToRef","LookDirectionLH","back","LookDirectionRH","OrthoLH","znear","zfar","halfZRange","OrthoLHToRef","mtxConvertNDCToHalfZRange","OrthoOffCenterLH","bottom","top","OrthoOffCenterLHToRef","i0","i1","OrthoOffCenterRH","OrthoOffCenterRHToRef","PerspectiveLH","projectionPlaneTilt","rot","tan","PerspectiveFovLH","fov","aspect","reverseDepthBufferMode","PerspectiveFovLHToRef","isVerticalFovFixed","f","PerspectiveFovReverseLHToRef","PerspectiveFovRH","PerspectiveFovRHToRef","PerspectiveFovReverseRHToRef","PerspectiveFovWebVRToRef","rightHanded","rightHandedFactor","upTan","upDegrees","downTan","downDegrees","leftTan","leftDegrees","rightTan","rightDegrees","xScale","yScale","GetFinalMatrix","zmin","zmax","GetAsMatrix2x2","arr","Float32Array","GetAsMatrix3x3","rm","mm","Reflection","ReflectionToRef","temp2","temp3","xaxis","yaxis","zaxis","zw","zx","yw","xw","PositionNormalVertex","PositionNormalTextureVertex","uv","Viewport","toGlobal","renderWidth","renderHeight","toGlobalToRef","SH3ylmBasisConstants","SH3ylmBasisTrigonometricTerms","applySH3","lm","SHCosKernelConvolution","SphericalHarmonics","preScaled","l00","l1_1","l10","l11","l2_2","l2_1","l20","l21","l22","addLight","deltaSolidAngle","colorVector","convertIncidentRadianceToIrradiance","convertIrradianceToLambertianRadiance","preScaleForRendering","updateFromArray","updateFromFloatsArray","FromPolynomial","polynomial","SphericalPolynomial","_harmonics","addAmbient","updateFromHarmonics","harmonics","FromHarmonics","sp","CreateBoxVertexData","options","normals","uvs","depth","wrap","topBaseAt","bottomBaseAt","topIndex","bottomIndex","basePositions","topFaceBase","bottomFaceBase","topFaceOrder","bottomFaceOrder","unshift","pop","flat","scaleArray","reduce","accumulator","currentValue","currentIndex","sideOrientation","faceUV","faceColors","frontUVs","backUVs","vertexData","totalColors","CreateBox","name","scene","box","_originalBuilderSideOrientation","applyToMesh","updatable","BoxBuilder","CreateCapsuleVertexData","subdivisions","tessellation","capSubdivisions","capDetail","radialSegments","heightSegments","radiusTop","radiusBottom","heightMinusCaps","thetaLength","capsTopSegments","topCapSubdivisions","capsBottomSegments","bottomCapSubdivisions","vertices","indexArray","halfHeight","pi2","vertex","cosAlpha","sinAlpha","coneLength","vl","indexRow","sinA","_radius","u","sinTheta","cosTheta","coneHeight","slope","i2","i3","i4","reverse","v_1","vDat","CreateCapsule","capsule","CapsuleBuilder","CreateCylinderVertexData","diameterTop","diameter","diameterBottom","hasRings","enclose","cap","surfaceNb","angleStep","ringVertex","ringNormal","ringFirstVertex","ringFirstNormal","quadNormal","ringIdx","cs","e","createCylinderCap","isTop","circleVector","vbase","textureScale","textureCoordinate","CreateCylinder","cylinder","CylinderBuilder","CreateDecal","sourceMesh","getIndices","getVerticesData","camera","getScene","activeCamera","cameraWorldTarget","getWorldMatrix","globalPosition","decalWorldMatrix","inverseDecalWorldMatrix","transformMatrix","currentVertexDataIndex","extractDecalVector3","indexId","vertexId","captureUVS","clip","clipSize","clipVertices","clipFactor","nV1","nV2","nV3","nV4","v1Out","v2Out","v3Out","faceVertices","vIndex","decal","DecalBuilder","CreateDiscVertexData","vertexNb","CreateDisc","disc","DiscBuilder","CreateGeodesic","primTri","build","geoOptions","custom","sizeX","sizeY","sizeZ","CreateGoldbergVertexData","goldbergData","minX","maxX","minY","maxY","face","verts","ba","ca","pdata","vCoord","CreateGoldberg","geodesicData","toGoldbergPolyhedronData","goldberg","nbSharedFaces","sharedNodes","nbUnsharedFaces","poleNodes","adjacentFaces","nbFaces","nbFacesAtPole","faceCenters","faceXaxis","faceYaxis","faceZaxis","CreateGroundVertexData","col","subdivisionsX","subdivisionsY","CreateTiledGroundVertexData","tileRow","tileCol","xmin","xmax","precision","tileSize","applyTile","xTileMin","zTileMin","xTileMax","zTileMax","base","rowLength","square","CreateGroundFromHeightMapVertexData","filter","colorFilter","alphaFilter","minHeight","maxHeight","pos","bufferWidth","bufferHeight","buffer","idx1","idx2","idx3","idx4","isVisibleIdx1","isVisibleIdx2","isVisibleIdx3","CreateGround","ground","_setReady","_subdivisionsX","_subdivisionsY","_width","_height","_maxX","_maxZ","_minX","_minZ","CreateTiledGround","tiledGround","CreateGroundFromHeightMap","url","onReady","img","isDisposed","getEngine","resizeImageBitmap","offlineProvider","GroundBuilder","CreateHemisphere","segments","halfSphere","parent","merged","HemisphereBuilder","CreateIcoSphereVertexData","v012","radiusX","radiusY","radiusZ","icoVertices","ico_indices","vertices_unalias_id","ico_vertexuv","island","current_indice","face_vertex_pos","face_vertex_uv","v_id","interp_vertex","c2","vertex_normal","pos_x0","pos_x1","pos_interp","centroid_x0","centroid_x1","uv_x0","uv_x1","uv_interp","CreateIcoSphere","sphere","IcoSphereBuilder","CreateLathe","rotated","shape","paths","invertUV","pathArray","closeArray","LatheBuilder","CreateLineSystemVertexData","lines","vertexColors","idx","CreateDashedLinesVertexData","shft","dashshft","dashSize","gapSize","dashNb","curvect","lg","nb","curshft","CreateLineSystem","instance","vertexColor","lineColors","updateVerticesData","useVertexColor","lineSystem","useVertexAlpha","material","CreateLines","CreateDashedLines","updateMeshPositions","nbSeg","_creationDataStorage","dashedLines","LinesBuilder","CreatePlaneVertexData","halfWidth","CreatePlane","sourcePlane","translate","setDirection","PlaneBuilder","CreatePolygonVertexData","polygon","fUV","fColors","wrp","disp","distX","distZ","totalLen","cumulate","idx_1","CreatePolygon","earcutInjection","earcut","holes","smoothingThreshold","contours","hole","polygonTriangulation","hNb","hPoint","addHole","ExtrudePolygon","PolygonBuilder","CreatePolyhedronVertexData","polyhedra","ang","type","nbfaces","faceIdx","indexes","fl","CreatePolyhedron","polyhedron","PolyhedronBuilder","CreateRibbonVertexData","closePath","defaultOffset","minlg","customUV","customColors","us","vs","uTotalDistance","vTotalDistance","ar1","ar2","dist","path1","path2","idc","closePathCorr","vertex1","vertex2","pi","l1","path1nb","indexFirst","indexLast","positions32","normals32","uvs32","_idx","CreateRibbon","minimum_1","maximum_1","mesh","ns","si","pathPoint","positionFunction","hasBoundingInfo","getBoundingInfo","reConstruct","_worldMatrix","buildBoundingInfo","colorIndex","areNormalsFrozen","isFacetDataEnabled","params","getFacetDataParameters","ribbon","RibbonBuilder","ExtrudeShape","closeShape","_ExtrudeShapeGeneric","ExtrudeShapeCustom","scaleFunction","rotationFunction","ribbonCloseArray","ribbonClosePath","rotateFunction","rbCA","rbCP","updtbl","side","path3D","extrusionPathArray","shapePaths","tangents","binormals","distances","rotate","scl","rotationMatrix","shapePath","scaleRatio","planed","capPath","pointCap","barycenter","storage","extrudedGeneric","ShapeBuilder","CreateSphereVertexData","diameterX","diameterY","diameterZ","dedupTopBottomIndices","totalZRotationSteps","totalYRotationSteps","zRotationStep","normalizedZ","angleZ","yRotationStep","normalizedY","angleY","rotationZ","rotationY","afterRotZ","complete","verticesCount","firstIndex","CreateSphere","SphereBuilder","CreateTiledBoxVertexData","flipTile","pattern","tileWidth","tileHeight","alignH","alignHorizontal","alignV","alignVertical","halfDepth","faceVertexData","baseAlignV","facePositions","faceNormals","newFaceUV","lu","li","map","vec0","mtrx0","entry","mtrx2","mtrx3","vec4","mtrx4","mtrx5","CreateTiledBox","TiledBoxBuilder","CreateTiledPlaneVertexData","tilesX","offsetX","tilesY","offsetY","adjustX","adjustY","startX","startY","uvBase","partialBottomRow","partialTopRow","partialLeftCol","partialRightCol","uvPart","uvBaseBR","uvBaseTR","uvBaseLC","uvBaseRC","CreateTiledPlane","TiledPlaneBuilder","CreateTorusVertexData","thickness","outerAngle","innerAngle","dx","dy","nextI","nextJ","CreateTorus","torus","TorusBuilder","CreateTorusKnotVertexData","tube","tubularSegments","getPos","cu","su","quOverP","ty","tz","tang","bitan","jNext","CreateTorusKnot","torusKnot","TorusKnotBuilder","CreateTube","radiusFunction","tubePathArray","circlePaths","circlePath","rad","radiusFunctionFinal","pathIndex","TubeBuilder","decodeMesh","decoderModule","dataView","attributes","onIndicesData","onAttributeData","dividers","DecoderBuffer","Init","byteLength","geometry","status","decoder","Decoder","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","Error","ok","ptr","error_msg","numIndices","num_faces","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","_free","processAttribute","kind","attribute","divider","numComponents","num_components","numPoints","num_points","numValues","BYTES_PER_ELEMENT","GetAttributeDataArrayForAllPoints","DT_FLOAT32","values","babylonData","GetAttributeByUniqueId","nativeAttributeTypes","GetAttributeId","GetAttribute","destroy","worker","decoderPromise","onmessage","event","importScripts","DracoDecoderModule","wasmBinary","postMessage","then","DracoCompression","numWorkers","DefaultNumWorkers","Configuration","decoderInfo","wasmUrl","wasmBinaryUrl","WebAssembly","wasmBinaryPromise","fallbackUrl","Promise","resolve","Worker","_workerPoolPromise","decoderWasmBinary","workerContent","workerBlobUrl","URL","createObjectURL","Blob","reject","onError","error","removeEventListener","onMessage","message","addEventListener","_decoderModulePromise","module","GetDefaultNumWorkers","navigator","hardwareConcurrency","_Default","dispose","workerPool","whenReadyAsync","decodeMeshAsync","ArrayBuffer","Uint8Array","onComplete","dataViewCopy","byteOffset","MeshoptCompression","MeshoptDecoder","ready","decodeGltfBufferAsync","mode","decodeGltfBuffer","WebGLDataBuffer","_super","resource","call","_buffer","WebGPUDataBuffer","_FacetDataStorage","facetNb","partitioningSubdivisions","partitioningBBoxRatio","facetDataEnabled","facetParameters","bbSize","subDiv","facetDepthSort","facetDepthSortEnabled","_InternalAbstractMeshDataInfo","_hasVertexAlpha","_useVertexColors","_numBoneInfluencers","_applyFog","_receiveShadows","_facetData","_visibility","_skeleton","_layerMask","_computeBonesUsingShaders","_isActive","_onlyForInstances","_isActiveIntermediate","_onlyForInstancesIntermediate","_actAsRegularMesh","_currentLOD","_currentLODIsUpToDate","_collisionRetryCount","_morphTargetManager","_renderingGroupId","_bakedVertexAnimationManager","_material","_positions","_meshCollisionData","_enableDistantPicking","AbstractMesh","_internalAbstractMeshDataInfo","_waitingMaterialId","cullingStrategy","CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY","onCollideObservable","onCollisionPositionChangeObservable","onMaterialChangedObservable","definedFacingForward","_occlusionQuery","_renderingGroup","alphaIndex","isVisible","isPickable","isNearPickable","isNearGrabbable","showSubMeshesBoundingBox","isBlocker","enablePointerMoveEvents","outlineColor","outlineWidth","overlayColor","overlayAlpha","useOctreeForRenderingSelection","useOctreeForPicking","useOctreeForCollisions","alwaysSelectAsActiveMesh","doNotSyncBoundingInfo","actionManager","ellipsoid","ellipsoidOffset","edgesWidth","edgesColor","_edgesRenderer","_masterMesh","_boundingInfo","_boundingInfoIsDirty","_renderId","_intersectionsInProgress","_unIndexed","_lightSources","_waitingData","lods","actions","freezeWorldMatrix","_bonesTransformMatrices","_transformMatrixTexture","onRebuildObservable","_onCollisionPositionChange","collisionId","newPosition","collidedMesh","_oldPositionForCollisions","_diffPositionForCollisions","notifyObservers","addMesh","_resyncLightSources","_uniformBuffer","isWebGPU","_buildUniformLayout","ratio","sort","facetDepthSortFrom","location","retryCount","_syncGeometryWithMorphTargetManager","_markSubMeshesAsAttributesDirty","_updateNonUniformScalingState","_markSubMeshesAsMiscDirty","callback","_onCollideObserver","remove","_onCollisionPositionChangeObserver","oldValue","meshMap","uniqueId","hasObservers","subMeshes","resetDrawCache","_unBindEffect","getMaterialForRenderPass","renderPassId","_materialForRenderPass","setMaterialForRenderPass","_markSubMeshesAsLightDirty","_collisionMask","mask","_collisionResponse","response","_collisionGroup","_surroundingMeshes","meshes","skeleton","needInitialSkinMatrix","_unregisterMeshWithPoseMatrix","_registerMeshWithPoseMatrix","addUniform","create","transferToEffect","ubo","updateMatrix","updateFloat","getMeshUniformBuffer","fullDetails","ret","billboardMode","_isWorldMatrixFrozen","_getEffectiveParent","_getActionManagerForTrigger","trigger","initialCall","isRecursive","hasSpecificTrigger","_rebuild","lights","light","isEnabled","canAffectMesh","_resyncLightSource","isIn","indexOf","removed","splice","setEffect","_removeLightSource","_markSubMeshesAsDirty","func","subMesh","_drawWrappers","drawWrapper","defines","markAllAsDirty","markAsLightDirty","markAsAttributesDirty","markAsMiscDirty","markAsDirty","property","_currentRenderId","passId","getLOD","getTotalVertices","getTotalIndices","setVerticesData","updateExtends","makeItUnique","setIndices","totalVertices","isVerticesDataPresent","_updateBoundingInfo","setBoundingInfo","boundingInfo","worldMatrix","normalizeToUnitCube","includeDescendants","ignoreRotation","predicate","skeletonsEnabled","_preActivate","_preActivateForIntermediateRendering","renderId","_activate","intermediateRendering","_postActivate","_freeze","_unFreeze","_getWorldMatrixDeterminant","movePOV","amountRight","amountUp","amountForward","calcMovePOV","rotMatrix","translationDelta","defForwardMult","rotatePOV","flipBack","twirlClockwise","tiltRight","calcRotatePOV","refreshBoundingInfo","applySkeleton","applyMorph","isLocked","_refreshBoundingInfo","_getPositionData","extend","_getData","morphTargetManager","faceIndexCount","positionIndex","vertexCount","targetCount","numTargets","targetMorph","getTarget","influence","morphTargetPositions","getPositions","matricesIndicesData","matricesWeightsData","needExtras","numBoneInfluencers","matricesIndicesExtraData","matricesWeightsExtraData","skeletonMatrices","getTransformMatrices","tempVector","finalMatrix","tempMatrix","matWeightIdx","inf","weight","getNormalsData","getPositionData","_generatePointsArray","worldMatrixFromCache","_updateSubMeshesBoundingInfo","subIndex","IsGlobal","updateBoundingInfo","_afterComputeWorldMatrix","isInFrustum","isCompletelyInFrustum","intersectsMesh","precise","otherBoundingInfo","intersects","getChildMeshes","intersectsPoint","_checkCollisions","collisionEnabled","_collider","moveWithCollisions","displacement","getAbsolutePosition","coordinator","collisionCoordinator","createCollider","getNewPosition","collisionRetryCount","_collideForSubMesh","collider","_lastColliderWorldVertices","_lastColliderTransformMatrix","_trianglePlanes","verticesStart","_collide","getMaterial","_shouldConvertRHS","fillMode","_processCollisionsForSubMeshes","_scene","getCollidingSubMeshCandidates","_checkCollision","collisionsScalingMatrix","collisionsTransformMatrix","ray","fastCheck","trianglePredicate","onlyBoundingInfo","worldToUse","skipBoundingInfo","pickingInfo","intersectionThreshold","intersectsSphere","boundingSphere","intersectsBox","boundingBox","hit","pickedMesh","subMeshId","intersectInfo","getIntersectingSubMeshCandidates","anySubmeshSupportIntersect","canIntersects","currentIntersectInfo","worldOrigin","pickedPoint","bu","bv","subMeshFaceId","faceId","newParent","doNotCloneChildren","releaseSubMeshes","doNotRecurse","disposeMaterialAndTextures","useMaterialMeshMap","freeActiveMeshes","freeRenderingGroups","meshIndex","includedOnlyMeshes","excludedMeshes","generator","getShadowGenerator","shadowMap","getShadowMap","renderList","engine","isOcclusionQueryInProgress","deleteQuery","wipeCaches","removeMesh","_parentContainer","index_1","particleSystems","emitter","disableFacetData","onAfterWorldMatrixUpdateObservable","clear","addChild","preserveScalingSign","setParent","removeChild","_initFacetData","facetNormals","facetPositions","facetPartitioning","updateFacetData","bInfo","Uint16Array","depthSortedIndices","needs32bits","facetDepthSortFunction","sqDistance","depthSortedFacets","depthSortedFacet","ind","facetDepthSortOrigin","bbSizeMax","getFacetLocalNormals","getFacetLocalPositions","getFacetLocalPartitioning","depthSort","computeWorldMatrix","distanceTo","sind","updateIndices","facetData","getFacetPosition","getFacetPositionToRef","localPos","getFacetNormal","getFacetNormalToRef","localNorm","getFacetsAtLocalCoordinates","ox","oy","oz","getClosestFacetAtCoordinates","projected","checkFace","facing","invMat","invVect","closest","getClosestFacetAtLocalCoordinates","tmpx","tmpy","tmpz","t0","projx","projy","projz","facetsInBlock","fib","shortest","tmpDistance","gpuMemoryOnly","createNormals","useRightHandedSystem","alignWithNormal","upDirection","axisX","axisZ","_checkOcclusionQuery","disableEdgesRendering","enableEdgesRendering","checkVerticesInsteadOfIndices","getConnectedParticleSystems","particleSystem","OCCLUSION_TYPE_NONE","OCCLUSION_TYPE_OPTIMISTIC","OCCLUSION_TYPE_STRICT","OCCLUSION_ALGORITHM_TYPE_ACCURATE","OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE","CULLINGSTRATEGY_STANDARD","CULLINGSTRATEGY_OPTIMISTIC_INCLUSION","CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY"],"sourceRoot":""}