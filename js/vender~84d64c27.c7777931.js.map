{"version":3,"file":"js/vender~84d64c27.c7777931.js","mappings":"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","sources":["webpack:///../../../node_modules/cesium/Source/Scene/AlphaMode.js","webpack:///../../../node_modules/cesium/Source/Scene/Appearance.js","webpack:///../../../node_modules/cesium/Source/Scene/ArcGisMapServerImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/AttributeType.js","webpack:///../../../node_modules/cesium/Source/Scene/AutoExposure.js","webpack:///../../../node_modules/cesium/Source/Scene/Axis.js","webpack:///../../../node_modules/cesium/Source/Scene/B3dmParser.js","webpack:///../../../node_modules/cesium/Source/Scene/BatchTable.js","webpack:///../../../node_modules/cesium/Source/Scene/BatchTableHierarchy.js","webpack:///../../../node_modules/cesium/Source/Scene/BatchTexture.js","webpack:///../../../node_modules/cesium/Source/Scene/Batched3DModel3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/Billboard.js","webpack:///../../../node_modules/cesium/Source/Scene/BillboardCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/BingMapsImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/BingMapsStyle.js","webpack:///../../../node_modules/cesium/Source/Scene/BlendEquation.js","webpack:///../../../node_modules/cesium/Source/Scene/BlendFunction.js","webpack:///../../../node_modules/cesium/Source/Scene/BlendOption.js","webpack:///../../../node_modules/cesium/Source/Scene/BlendingState.js","webpack:///../../../node_modules/cesium/Source/Scene/BoxEmitter.js","webpack:///../../../node_modules/cesium/Source/Scene/BrdfLutGenerator.js","webpack:///../../../node_modules/cesium/Source/Scene/BufferLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/Camera.js","webpack:///../../../node_modules/cesium/Source/Scene/CameraEventAggregator.js","webpack:///../../../node_modules/cesium/Source/Scene/CameraEventType.js","webpack:///../../../node_modules/cesium/Source/Scene/CameraFlightPath.js","webpack:///../../../node_modules/cesium/Source/Scene/Cesium3DContentGroup.js","webpack:///../../../node_modules/cesium/Source/Scene/Cesium3DTileBatchTable.js","webpack:///../../../node_modules/cesium/Source/Scene/Cesium3DTileColorBlendMode.js","webpack:///../../../node_modules/cesium/Source/Scene/Cesium3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/Cesium3DTileContentFactory.js","webpack:///../../../node_modules/cesium/Source/Scene/Cesium3DTileContentState.js","webpack:///../../../node_modules/cesium/Source/Scene/Cesium3DTileContentType.js","webpack:///../../../node_modules/cesium/Source/Scene/Cesium3DTileFeature.js","webpack:///../../../node_modules/cesium/Source/Scene/Cesium3DTileFeatureTable.js"],"sourcesContent":["/**\n * The alpha rendering mode of the material.\n *\n * @enum {String}\n * @private\n */\nconst AlphaMode = {\n  /**\n   * The alpha value is ignored and the rendered output is fully opaque.\n   *\n   * @type {String}\n   * @constant\n   */\n  OPAQUE: \"OPAQUE\",\n\n  /**\n   * The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value.\n   *\n   * @type {String}\n   * @constant\n   */\n  MASK: \"MASK\",\n\n  /**\n   * The rendered output is composited onto the destination with alpha blending.\n   *\n   * @type {String}\n   * @constant\n   */\n  BLEND: \"BLEND\",\n};\n\nexport default Object.freeze(AlphaMode);\n","import clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\n\n/**\n * An appearance defines the full GLSL vertex and fragment shaders and the\n * render state used to draw a {@link Primitive}.  All appearances implement\n * this base <code>Appearance</code> interface.\n *\n * @alias Appearance\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link Appearance#renderState} has alpha blending enabled.\n * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link Appearance#renderState} has backface culling enabled.\n * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n * @param {Object} [options.renderState] Optional render state to override the default render state.\n *\n * @see MaterialAppearance\n * @see EllipsoidSurfaceAppearance\n * @see PerInstanceColorAppearance\n * @see DebugAppearance\n * @see PolylineColorAppearance\n * @see PolylineMaterialAppearance\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n */\nfunction Appearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The material used to determine the fragment color.  Unlike other {@link Appearance}\n   * properties, this is not read-only, so an appearance's material can change on the fly.\n   *\n   * @type Material\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n  this.material = options.material;\n\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.translucent = defaultValue(options.translucent, true);\n\n  this._vertexShaderSource = options.vertexShaderSource;\n  this._fragmentShaderSource = options.fragmentShaderSource;\n  this._renderState = options.renderState;\n  this._closed = defaultValue(options.closed, false);\n}\n\nObject.defineProperties(Appearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    },\n  },\n\n  /**\n   * The GLSL source code for the fragment shader.  The full fragment shader\n   * source is built procedurally taking into account the {@link Appearance#material}.\n   * Use {@link Appearance#getFragmentShaderSource} to get the full source.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be closed.\n   *\n   * @memberof Appearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    },\n  },\n});\n\n/**\n * Procedurally creates the full GLSL fragment shader source for this appearance\n * taking into account {@link Appearance#fragmentShaderSource} and {@link Appearance#material}.\n *\n * @returns {String} The full GLSL fragment shader source.\n */\nAppearance.prototype.getFragmentShaderSource = function () {\n  const parts = [];\n  if (this.flat) {\n    parts.push(\"#define FLAT\");\n  }\n  if (this.faceForward) {\n    parts.push(\"#define FACE_FORWARD\");\n  }\n  if (defined(this.material)) {\n    parts.push(this.material.shaderSource);\n  }\n  parts.push(this.fragmentShaderSource);\n\n  return parts.join(\"\\n\");\n};\n\n/**\n * Determines if the geometry is translucent based on {@link Appearance#translucent} and {@link Material#isTranslucent}.\n *\n * @returns {Boolean} <code>true</code> if the appearance is translucent.\n */\nAppearance.prototype.isTranslucent = function () {\n  return (\n    (defined(this.material) && this.material.isTranslucent()) ||\n    (!defined(this.material) && this.translucent)\n  );\n};\n\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @returns {Object} The render state.\n */\nAppearance.prototype.getRenderState = function () {\n  const translucent = this.isTranslucent();\n  const rs = clone(this.renderState, false);\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  } else {\n    rs.depthMask = true;\n  }\n  return rs;\n};\n\n/**\n * @private\n */\nAppearance.getDefaultRenderState = function (translucent, closed, existing) {\n  let rs = {\n    depthTest: {\n      enabled: true,\n    },\n  };\n\n  if (translucent) {\n    rs.depthMask = false;\n    rs.blending = BlendingState.ALPHA_BLEND;\n  }\n\n  if (closed) {\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK,\n    };\n  }\n\n  if (defined(existing)) {\n    rs = combine(existing, rs, true);\n  }\n\n  return rs;\n};\nexport default Appearance;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport DiscardMissingTileImagePolicy from \"./DiscardMissingTileImagePolicy.js\";\nimport ImageryLayerFeatureInfo from \"./ImageryLayerFeatureInfo.js\";\nimport ImageryProvider from \"./ImageryProvider.js\";\n\n/**\n * @typedef {Object} ArcGisMapServerImageryProvider.ConstructorOptions\n *\n * Initialization options for the ArcGisMapServerImageryProvider constructor\n *\n * @property {Resource|String} url The URL of the ArcGIS MapServer service.\n * @property {String} [token] The ArcGIS token used to authenticate with the ArcGIS MapServer service.\n * @property {TileDiscardPolicy} [tileDiscardPolicy] The policy that determines if a tile\n *        is invalid and should be discarded.  If this value is not specified, a default\n *        {@link DiscardMissingTileImagePolicy} is used for tiled map servers, and a\n *        {@link NeverTileDiscardPolicy} is used for non-tiled map servers.  In the former case,\n *        we request tile 0,0 at the maximum tile level and check pixels (0,0), (200,20), (20,200),\n *        (80,110), and (160, 130).  If all of these pixels are transparent, the discard check is\n *        disabled and no tiles are discarded.  If any of them have a non-transparent color, any\n *        tile that has the same values in these pixel locations is discarded.  The end result of\n *        these defaults should be correct tile discarding for a standard ArcGIS Server.  To ensure\n *        that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this\n *        parameter.\n * @property {Boolean} [usePreCachedTilesIfAvailable=true] If true, the server's pre-cached\n *        tiles are used if they are available.  If false, any pre-cached tiles are ignored and the\n *        'export' service is used.\n * @property {String} [layers] A comma-separated list of the layers to show, or undefined if all layers should be shown.\n * @property {Boolean} [enablePickFeatures=true] If true, {@link ArcGisMapServerImageryProvider#pickFeatures} will invoke\n *        the Identify service on the MapServer and return the features included in the response.  If false,\n *        {@link ArcGisMapServerImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)\n *        without communicating with the server.  Set this property to false if you don't want this provider's features to\n *        be pickable. Can be overridden by setting the {@link ArcGisMapServerImageryProvider#enablePickFeatures} property on the object.\n * @property {Rectangle} [rectangle=Rectangle.MAX_VALUE] The rectangle of the layer.  This parameter is ignored when accessing\n *                    a tiled layer.\n * @property {TilingScheme} [tilingScheme=new GeographicTilingScheme()] The tiling scheme to use to divide the world into tiles.\n *                       This parameter is ignored when accessing a tiled server.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If the tilingScheme is specified and used,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n *                    parameter is specified, the WGS84 ellipsoid is used.\n * @property {Credit|String} [credit] A credit for the data source, which is displayed on the canvas.  This parameter is ignored when accessing a tiled server.\n * @property {Number} [tileWidth=256] The width of each tile in pixels.  This parameter is ignored when accessing a tiled server.\n * @property {Number} [tileHeight=256] The height of each tile in pixels.  This parameter is ignored when accessing a tiled server.\n * @property {Number} [maximumLevel] The maximum tile level to request, or undefined if there is no maximum.  This parameter is ignored when accessing\n *                                        a tiled server.\n */\n\n/**\n * Provides tiled imagery hosted by an ArcGIS MapServer.  By default, the server's pre-cached tiles are\n * used, if available.\n *\n * @alias ArcGisMapServerImageryProvider\n * @constructor\n *\n * @param {ArcGisMapServerImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n *\n *\n * @example\n * const esri = new Cesium.ArcGisMapServerImageryProvider({\n *     url : 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'\n * });\n *\n * @see {@link https://developers.arcgis.com/rest/|ArcGIS Server REST API}\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nfunction ArcGisMapServerImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  const resource = Resource.createIfNeeded(options.url);\n  resource.appendForwardSlash();\n\n  if (defined(options.token)) {\n    resource.setQueryParameters({\n      token: options.token,\n    });\n  }\n\n  this._resource = resource;\n  this._tileDiscardPolicy = options.tileDiscardPolicy;\n\n  this._tileWidth = defaultValue(options.tileWidth, 256);\n  this._tileHeight = defaultValue(options.tileHeight, 256);\n  this._maximumLevel = options.maximumLevel;\n  this._tilingScheme = defaultValue(\n    options.tilingScheme,\n    new GeographicTilingScheme({ ellipsoid: options.ellipsoid })\n  );\n  this._useTiles = defaultValue(options.usePreCachedTilesIfAvailable, true);\n  this._rectangle = defaultValue(\n    options.rectangle,\n    this._tilingScheme.rectangle\n  );\n  this._layers = options.layers;\n\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  /**\n   * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link ArcGisMapServerImageryProvider#pickFeatures} will\n   * invoke the \"identify\" operation on the ArcGIS server and return the features included in the response.  If false,\n   * {@link ArcGisMapServerImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)\n   * without communicating with the server.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enablePickFeatures = defaultValue(options.enablePickFeatures, true);\n\n  this._errorEvent = new Event();\n\n  this._ready = false;\n  this._readyPromise = defer();\n\n  // Grab the details of this MapServer.\n  const that = this;\n  let metadataError;\n\n  function metadataSuccess(data) {\n    const tileInfo = data.tileInfo;\n    if (!defined(tileInfo)) {\n      that._useTiles = false;\n    } else {\n      that._tileWidth = tileInfo.rows;\n      that._tileHeight = tileInfo.cols;\n\n      if (\n        tileInfo.spatialReference.wkid === 102100 ||\n        tileInfo.spatialReference.wkid === 102113\n      ) {\n        that._tilingScheme = new WebMercatorTilingScheme({\n          ellipsoid: options.ellipsoid,\n        });\n      } else if (data.tileInfo.spatialReference.wkid === 4326) {\n        that._tilingScheme = new GeographicTilingScheme({\n          ellipsoid: options.ellipsoid,\n        });\n      } else {\n        const message = `Tile spatial reference WKID ${data.tileInfo.spatialReference.wkid} is not supported.`;\n        metadataError = TileProviderError.handleError(\n          metadataError,\n          that,\n          that._errorEvent,\n          message,\n          undefined,\n          undefined,\n          undefined,\n          requestMetadata\n        );\n        if (!metadataError.retry) {\n          that._readyPromise.reject(new RuntimeError(message));\n        }\n        return;\n      }\n      that._maximumLevel = data.tileInfo.lods.length - 1;\n\n      if (defined(data.fullExtent)) {\n        if (\n          defined(data.fullExtent.spatialReference) &&\n          defined(data.fullExtent.spatialReference.wkid)\n        ) {\n          if (\n            data.fullExtent.spatialReference.wkid === 102100 ||\n            data.fullExtent.spatialReference.wkid === 102113\n          ) {\n            const projection = new WebMercatorProjection();\n            const extent = data.fullExtent;\n            const sw = projection.unproject(\n              new Cartesian3(\n                Math.max(\n                  extent.xmin,\n                  -that._tilingScheme.ellipsoid.maximumRadius * Math.PI\n                ),\n                Math.max(\n                  extent.ymin,\n                  -that._tilingScheme.ellipsoid.maximumRadius * Math.PI\n                ),\n                0.0\n              )\n            );\n            const ne = projection.unproject(\n              new Cartesian3(\n                Math.min(\n                  extent.xmax,\n                  that._tilingScheme.ellipsoid.maximumRadius * Math.PI\n                ),\n                Math.min(\n                  extent.ymax,\n                  that._tilingScheme.ellipsoid.maximumRadius * Math.PI\n                ),\n                0.0\n              )\n            );\n            that._rectangle = new Rectangle(\n              sw.longitude,\n              sw.latitude,\n              ne.longitude,\n              ne.latitude\n            );\n          } else if (data.fullExtent.spatialReference.wkid === 4326) {\n            that._rectangle = Rectangle.fromDegrees(\n              data.fullExtent.xmin,\n              data.fullExtent.ymin,\n              data.fullExtent.xmax,\n              data.fullExtent.ymax\n            );\n          } else {\n            const extentMessage = `fullExtent.spatialReference WKID ${data.fullExtent.spatialReference.wkid} is not supported.`;\n            metadataError = TileProviderError.handleError(\n              metadataError,\n              that,\n              that._errorEvent,\n              extentMessage,\n              undefined,\n              undefined,\n              undefined,\n              requestMetadata\n            );\n            if (!metadataError.retry) {\n              that._readyPromise.reject(new RuntimeError(extentMessage));\n            }\n            return;\n          }\n        }\n      } else {\n        that._rectangle = that._tilingScheme.rectangle;\n      }\n\n      // Install the default tile discard policy if none has been supplied.\n      if (!defined(that._tileDiscardPolicy)) {\n        that._tileDiscardPolicy = new DiscardMissingTileImagePolicy({\n          missingImageUrl: buildImageResource(that, 0, 0, that._maximumLevel)\n            .url,\n          pixelsToCheck: [\n            new Cartesian2(0, 0),\n            new Cartesian2(200, 20),\n            new Cartesian2(20, 200),\n            new Cartesian2(80, 110),\n            new Cartesian2(160, 130),\n          ],\n          disableCheckIfAllPixelsAreTransparent: true,\n        });\n      }\n\n      that._useTiles = true;\n    }\n\n    if (defined(data.copyrightText) && data.copyrightText.length > 0) {\n      that._credit = new Credit(data.copyrightText);\n    }\n\n    that._ready = true;\n    that._readyPromise.resolve(true);\n    TileProviderError.handleSuccess(metadataError);\n  }\n\n  function metadataFailure(e) {\n    const message = `An error occurred while accessing ${that._resource.url}.`;\n    metadataError = TileProviderError.handleError(\n      metadataError,\n      that,\n      that._errorEvent,\n      message,\n      undefined,\n      undefined,\n      undefined,\n      requestMetadata\n    );\n    that._readyPromise.reject(new RuntimeError(message));\n  }\n\n  function requestMetadata() {\n    const resource = that._resource.getDerivedResource({\n      queryParameters: {\n        f: \"json\",\n      },\n    });\n    resource\n      .fetchJsonp()\n      .then(function (result) {\n        metadataSuccess(result);\n      })\n      .catch(function (e) {\n        metadataFailure(e);\n      });\n  }\n\n  if (this._useTiles) {\n    requestMetadata();\n  } else {\n    this._ready = true;\n    this._readyPromise.resolve(true);\n  }\n}\n\nfunction buildImageResource(imageryProvider, x, y, level, request) {\n  let resource;\n  if (imageryProvider._useTiles) {\n    resource = imageryProvider._resource.getDerivedResource({\n      url: `tile/${level}/${y}/${x}`,\n      request: request,\n    });\n  } else {\n    const nativeRectangle = imageryProvider._tilingScheme.tileXYToNativeRectangle(\n      x,\n      y,\n      level\n    );\n    const bbox = `${nativeRectangle.west},${nativeRectangle.south},${nativeRectangle.east},${nativeRectangle.north}`;\n\n    const query = {\n      bbox: bbox,\n      size: `${imageryProvider._tileWidth},${imageryProvider._tileHeight}`,\n      format: \"png32\",\n      transparent: true,\n      f: \"image\",\n    };\n\n    if (\n      imageryProvider._tilingScheme.projection instanceof GeographicProjection\n    ) {\n      query.bboxSR = 4326;\n      query.imageSR = 4326;\n    } else {\n      query.bboxSR = 3857;\n      query.imageSR = 3857;\n    }\n    if (imageryProvider.layers) {\n      query.layers = `show:${imageryProvider.layers}`;\n    }\n\n    resource = imageryProvider._resource.getDerivedResource({\n      url: \"export\",\n      request: request,\n      queryParameters: query,\n    });\n  }\n\n  return resource;\n}\n\nObject.defineProperties(ArcGisMapServerImageryProvider.prototype, {\n  /**\n   * Gets the URL of the ArcGIS MapServer.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._resource._url;\n    },\n  },\n\n  /**\n   * Gets the ArcGIS token used to authenticate with the ArcGis MapServer service.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  token: {\n    get: function () {\n      return this._resource.queryParameters.token;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._resource.proxy;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileWidth must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"maximumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"minimumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"rectangle must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileDiscardPolicy must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether this imagery provider is using pre-cached tiles from the\n   * ArcGIS MapServer.  If the imagery provider is not yet ready ({@link ArcGisMapServerImageryProvider#ready}), this function\n   * will return the value of `options.usePreCachedTilesIfAvailable`, even if the MapServer does\n   * not have pre-cached tiles.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   * @default true\n   */\n  usingPrecachedTiles: {\n    get: function () {\n      return this._useTiles;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   * @default true\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return true;\n    },\n  },\n\n  /**\n   * Gets the comma-separated list of layer IDs to show.\n   * @memberof ArcGisMapServerImageryProvider.prototype\n   *\n   * @type {String}\n   */\n  layers: {\n    get: function () {\n      return this._layers;\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nArcGisMapServerImageryProvider.prototype.getTileCredits = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nArcGisMapServerImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestImage must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return ImageryProvider.loadImage(\n    this,\n    buildImageResource(this, x, y, level, request)\n  );\n};\n\n/**\n    /**\n     * Asynchronously determines what features, if any, are located at a given longitude and latitude within\n     * a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.\n     *\n     * @param {Number} x The tile X coordinate.\n     * @param {Number} y The tile Y coordinate.\n     * @param {Number} level The tile level.\n     * @param {Number} longitude The longitude at which to pick features.\n     * @param {Number} latitude  The latitude at which to pick features.\n     * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n     *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n     *                   instances.  The array may be empty if no features are found at the given location.\n     *\n     * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.\n     */\nArcGisMapServerImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"pickFeatures must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!this.enablePickFeatures) {\n    return undefined;\n  }\n\n  const rectangle = this._tilingScheme.tileXYToNativeRectangle(x, y, level);\n\n  let horizontal;\n  let vertical;\n  let sr;\n  if (this._tilingScheme.projection instanceof GeographicProjection) {\n    horizontal = CesiumMath.toDegrees(longitude);\n    vertical = CesiumMath.toDegrees(latitude);\n    sr = \"4326\";\n  } else {\n    const projected = this._tilingScheme.projection.project(\n      new Cartographic(longitude, latitude, 0.0)\n    );\n    horizontal = projected.x;\n    vertical = projected.y;\n    sr = \"3857\";\n  }\n\n  let layers = \"visible\";\n  if (defined(this._layers)) {\n    layers += `:${this._layers}`;\n  }\n\n  const query = {\n    f: \"json\",\n    tolerance: 2,\n    geometryType: \"esriGeometryPoint\",\n    geometry: `${horizontal},${vertical}`,\n    mapExtent: `${rectangle.west},${rectangle.south},${rectangle.east},${rectangle.north}`,\n    imageDisplay: `${this._tileWidth},${this._tileHeight},96`,\n    sr: sr,\n    layers: layers,\n  };\n\n  const resource = this._resource.getDerivedResource({\n    url: \"identify\",\n    queryParameters: query,\n  });\n\n  return resource.fetchJson().then(function (json) {\n    const result = [];\n\n    const features = json.results;\n    if (!defined(features)) {\n      return result;\n    }\n\n    for (let i = 0; i < features.length; ++i) {\n      const feature = features[i];\n\n      const featureInfo = new ImageryLayerFeatureInfo();\n      featureInfo.data = feature;\n      featureInfo.name = feature.value;\n      featureInfo.properties = feature.attributes;\n      featureInfo.configureDescriptionFromProperties(feature.attributes);\n\n      // If this is a point feature, use the coordinates of the point.\n      if (feature.geometryType === \"esriGeometryPoint\" && feature.geometry) {\n        const wkid =\n          feature.geometry.spatialReference &&\n          feature.geometry.spatialReference.wkid\n            ? feature.geometry.spatialReference.wkid\n            : 4326;\n        if (wkid === 4326 || wkid === 4283) {\n          featureInfo.position = Cartographic.fromDegrees(\n            feature.geometry.x,\n            feature.geometry.y,\n            feature.geometry.z\n          );\n        } else if (wkid === 102100 || wkid === 900913 || wkid === 3857) {\n          const projection = new WebMercatorProjection();\n          featureInfo.position = projection.unproject(\n            new Cartesian3(\n              feature.geometry.x,\n              feature.geometry.y,\n              feature.geometry.z\n            )\n          );\n        }\n      }\n\n      result.push(featureInfo);\n    }\n\n    return result;\n  });\n};\nexport default ArcGisMapServerImageryProvider;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\n\n/**\n * An enum describing the attribute type for glTF and 3D Tiles.\n *\n * @enum {String}\n *\n * @private\n */\nconst AttributeType = {\n  /**\n   * The attribute is a single component.\n   *\n   * @type {String}\n   * @constant\n   */\n  SCALAR: \"SCALAR\",\n\n  /**\n   * The attribute is a two-component vector.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC2: \"VEC2\",\n\n  /**\n   * The attribute is a three-component vector.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC3: \"VEC3\",\n\n  /**\n   * The attribute is a four-component vector.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC4: \"VEC4\",\n\n  /**\n   * The attribute is a 2x2 matrix.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT2: \"MAT2\",\n\n  /**\n   * The attribute is a 3x3 matrix.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT3: \"MAT3\",\n\n  /**\n   * The attribute is a 4x4 matrix.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT4: \"MAT4\",\n};\n\n/**\n * Gets the scalar, vector, or matrix type for the attribute type.\n *\n * @param {AttributeType} attributeType The attribute type.\n * @returns {*} The math type.\n *\n * @private\n */\nAttributeType.getMathType = function (attributeType) {\n  switch (attributeType) {\n    case AttributeType.SCALAR:\n      return Number;\n    case AttributeType.VEC2:\n      return Cartesian2;\n    case AttributeType.VEC3:\n      return Cartesian3;\n    case AttributeType.VEC4:\n      return Cartesian4;\n    case AttributeType.MAT2:\n      return Matrix2;\n    case AttributeType.MAT3:\n      return Matrix3;\n    case AttributeType.MAT4:\n      return Matrix4;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"attributeType is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the number of components per attribute.\n *\n * @param {AttributeType} attributeType The attribute type.\n * @returns {Number} The number of components.\n *\n * @private\n */\nAttributeType.getNumberOfComponents = function (attributeType) {\n  switch (attributeType) {\n    case AttributeType.SCALAR:\n      return 1;\n    case AttributeType.VEC2:\n      return 2;\n    case AttributeType.VEC3:\n      return 3;\n    case AttributeType.VEC4:\n    case AttributeType.MAT2:\n      return 4;\n    case AttributeType.MAT3:\n      return 9;\n    case AttributeType.MAT4:\n      return 16;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"attributeType is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Get the number of attribute locations needed to fit this attribute. Most\n * types require one, but matrices require multiple attribute locations.\n *\n * @param {AttributeType} attributeType The attribute type.\n * @returns {Number} The number of attribute locations needed in the shader\n *\n * @private\n */\nAttributeType.getAttributeLocationCount = function (attributeType) {\n  switch (attributeType) {\n    case AttributeType.SCALAR:\n    case AttributeType.VEC2:\n    case AttributeType.VEC3:\n    case AttributeType.VEC4:\n      return 1;\n    case AttributeType.MAT2:\n      return 2;\n    case AttributeType.MAT3:\n      return 3;\n    case AttributeType.MAT4:\n      return 4;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"attributeType is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the GLSL type for the attribute type.\n *\n * @param {AttributeType} attributeType The attribute type.\n * @returns {String} The GLSL type for the attribute type.\n *\n * @private\n */\nAttributeType.getGlslType = function (attributeType) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"attributeType\", attributeType);\n  //>>includeEnd('debug');\n\n  switch (attributeType) {\n    case AttributeType.SCALAR:\n      return \"float\";\n    case AttributeType.VEC2:\n      return \"vec2\";\n    case AttributeType.VEC3:\n      return \"vec3\";\n    case AttributeType.VEC4:\n      return \"vec4\";\n    case AttributeType.MAT2:\n      return \"mat2\";\n    case AttributeType.MAT3:\n      return \"mat3\";\n    case AttributeType.MAT4:\n      return \"mat4\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"attributeType is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\nexport default Object.freeze(AttributeType);\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\n\n/**\n * A post process stage that will get the luminance value at each pixel and\n * uses parallel reduction to compute the average luminance in a 1x1 texture.\n * This texture can be used as input for tone mapping.\n *\n * @constructor\n * @private\n */\nfunction AutoExposure() {\n  this._uniformMap = undefined;\n  this._command = undefined;\n\n  this._colorTexture = undefined;\n  this._depthTexture = undefined;\n\n  this._ready = false;\n\n  this._name = \"czm_autoexposure\";\n\n  this._logDepthChanged = undefined;\n  this._useLogDepth = undefined;\n\n  this._framebuffers = undefined;\n  this._previousLuminance = new FramebufferManager();\n\n  this._commands = undefined;\n  this._clearCommand = undefined;\n\n  this._minMaxLuminance = new Cartesian2();\n\n  /**\n   * Whether or not to execute this post-process stage when ready.\n   *\n   * @type {Boolean}\n   */\n  this.enabled = true;\n  this._enabled = true;\n\n  /**\n   * The minimum value used to clamp the luminance.\n   *\n   * @type {Number}\n   * @default 0.1\n   */\n  this.minimumLuminance = 0.1;\n\n  /**\n   * The maximum value used to clamp the luminance.\n   *\n   * @type {Number}\n   * @default 10.0\n   */\n  this.maximumLuminance = 10.0;\n}\n\nObject.defineProperties(AutoExposure.prototype, {\n  /**\n   * Determines if this post-process stage is ready to be executed. A stage is only executed when both <code>ready</code>\n   * and {@link AutoExposure#enabled} are <code>true</code>. A stage will not be ready while it is waiting on textures\n   * to load.\n   *\n   * @memberof AutoExposure.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n  /**\n   * The unique name of this post-process stage for reference by other stages.\n   *\n   * @memberof AutoExposure.prototype\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * A reference to the texture written to when executing this post process stage.\n   *\n   * @memberof AutoExposure.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  outputTexture: {\n    get: function () {\n      const framebuffers = this._framebuffers;\n      if (!defined(framebuffers)) {\n        return undefined;\n      }\n      return framebuffers[framebuffers.length - 1].getColorTexture(0);\n    },\n  },\n});\n\nfunction destroyFramebuffers(autoexposure) {\n  const framebuffers = autoexposure._framebuffers;\n  if (!defined(framebuffers)) {\n    return;\n  }\n\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    framebuffers[i].destroy();\n  }\n  autoexposure._framebuffers = undefined;\n\n  autoexposure._previousLuminance.destroy();\n  autoexposure._previousLuminance = undefined;\n}\n\nfunction createFramebuffers(autoexposure, context) {\n  destroyFramebuffers(autoexposure);\n\n  let width = autoexposure._width;\n  let height = autoexposure._height;\n\n  const pixelDatatype = context.halfFloatingPointTexture\n    ? PixelDatatype.HALF_FLOAT\n    : PixelDatatype.FLOAT;\n\n  const length = Math.ceil(Math.log(Math.max(width, height)) / Math.log(3.0));\n  const framebuffers = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    width = Math.max(Math.ceil(width / 3.0), 1.0);\n    height = Math.max(Math.ceil(height / 3.0), 1.0);\n    framebuffers[i] = new FramebufferManager();\n    framebuffers[i].update(context, width, height, 1, pixelDatatype);\n  }\n\n  const lastTexture = framebuffers[length - 1].getColorTexture(0);\n  autoexposure._previousLuminance.update(\n    context,\n    lastTexture.width,\n    lastTexture.height,\n    1,\n    pixelDatatype\n  );\n  autoexposure._framebuffers = framebuffers;\n}\n\nfunction destroyCommands(autoexposure) {\n  const commands = autoexposure._commands;\n  if (!defined(commands)) {\n    return;\n  }\n\n  const length = commands.length;\n  for (let i = 0; i < length; ++i) {\n    commands[i].shaderProgram.destroy();\n  }\n  autoexposure._commands = undefined;\n}\n\nfunction createUniformMap(autoexposure, index) {\n  let uniforms;\n  if (index === 0) {\n    uniforms = {\n      colorTexture: function () {\n        return autoexposure._colorTexture;\n      },\n      colorTextureDimensions: function () {\n        return autoexposure._colorTexture.dimensions;\n      },\n    };\n  } else {\n    const texture = autoexposure._framebuffers[index - 1].getColorTexture(0);\n    uniforms = {\n      colorTexture: function () {\n        return texture;\n      },\n      colorTextureDimensions: function () {\n        return texture.dimensions;\n      },\n    };\n  }\n\n  uniforms.minMaxLuminance = function () {\n    return autoexposure._minMaxLuminance;\n  };\n  uniforms.previousLuminance = function () {\n    return autoexposure._previousLuminance.getColorTexture(0);\n  };\n\n  return uniforms;\n}\n\nfunction getShaderSource(index, length) {\n  let source =\n    \"uniform sampler2D colorTexture; \\n\" +\n    \"varying vec2 v_textureCoordinates; \\n\" +\n    \"float sampleTexture(vec2 offset) { \\n\";\n\n  if (index === 0) {\n    source +=\n      \"    vec4 color = texture2D(colorTexture, v_textureCoordinates + offset); \\n\" +\n      \"    return czm_luminance(color.rgb); \\n\";\n  } else {\n    source +=\n      \"    return texture2D(colorTexture, v_textureCoordinates + offset).r; \\n\";\n  }\n\n  source += \"}\\n\\n\";\n\n  source +=\n    \"uniform vec2 colorTextureDimensions; \\n\" +\n    \"uniform vec2 minMaxLuminance; \\n\" +\n    \"uniform sampler2D previousLuminance; \\n\" +\n    \"void main() { \\n\" +\n    \"    float color = 0.0; \\n\" +\n    \"    float xStep = 1.0 / colorTextureDimensions.x; \\n\" +\n    \"    float yStep = 1.0 / colorTextureDimensions.y; \\n\" +\n    \"    int count = 0; \\n\" +\n    \"    for (int i = 0; i < 3; ++i) { \\n\" +\n    \"        for (int j = 0; j < 3; ++j) { \\n\" +\n    \"            vec2 offset; \\n\" +\n    \"            offset.x = -xStep + float(i) * xStep; \\n\" +\n    \"            offset.y = -yStep + float(j) * yStep; \\n\" +\n    \"            if (offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0) { \\n\" +\n    \"                continue; \\n\" +\n    \"            } \\n\" +\n    \"            color += sampleTexture(offset); \\n\" +\n    \"            ++count; \\n\" +\n    \"        } \\n\" +\n    \"    } \\n\" +\n    \"    if (count > 0) { \\n\" +\n    \"        color /= float(count); \\n\" +\n    \"    } \\n\";\n\n  if (index === length - 1) {\n    source +=\n      \"    float previous = texture2D(previousLuminance, vec2(0.5)).r; \\n\" +\n      \"    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); \\n\" +\n      \"    color = previous + (color - previous) / (60.0 * 1.5); \\n\" +\n      \"    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); \\n\";\n  }\n\n  source += \"    gl_FragColor = vec4(color); \\n\" + \"} \\n\";\n  return source;\n}\n\nfunction createCommands(autoexposure, context) {\n  destroyCommands(autoexposure);\n  const framebuffers = autoexposure._framebuffers;\n  const length = framebuffers.length;\n\n  const commands = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    commands[i] = context.createViewportQuadCommand(\n      getShaderSource(i, length),\n      {\n        framebuffer: framebuffers[i].framebuffer,\n        uniformMap: createUniformMap(autoexposure, i),\n      }\n    );\n  }\n  autoexposure._commands = commands;\n}\n\n/**\n * A function that will be called before execute. Used to clear any textures attached to framebuffers.\n * @param {Context} context The context.\n * @private\n */\nAutoExposure.prototype.clear = function (context) {\n  const framebuffers = this._framebuffers;\n  if (!defined(framebuffers)) {\n    return;\n  }\n\n  let clearCommand = this._clearCommand;\n  if (!defined(clearCommand)) {\n    clearCommand = this._clearCommand = new ClearCommand({\n      color: new Color(0.0, 0.0, 0.0, 0.0),\n      framebuffer: undefined,\n    });\n  }\n\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    framebuffers[i].clear(context, clearCommand);\n  }\n};\n\n/**\n * A function that will be called before execute. Used to create WebGL resources and load any textures.\n * @param {Context} context The context.\n * @private\n */\nAutoExposure.prototype.update = function (context) {\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n\n  if (width !== this._width || height !== this._height) {\n    this._width = width;\n    this._height = height;\n\n    createFramebuffers(this, context);\n    createCommands(this, context);\n\n    if (!this._ready) {\n      this._ready = true;\n    }\n  }\n\n  this._minMaxLuminance.x = this.minimumLuminance;\n  this._minMaxLuminance.y = this.maximumLuminance;\n\n  const framebuffers = this._framebuffers;\n  const temp = framebuffers[framebuffers.length - 1];\n  framebuffers[framebuffers.length - 1] = this._previousLuminance;\n  this._commands[\n    this._commands.length - 1\n  ].framebuffer = this._previousLuminance.framebuffer;\n  this._previousLuminance = temp;\n};\n\n/**\n * Executes the post-process stage. The color texture is the texture rendered to by the scene or from the previous stage.\n * @param {Context} context The context.\n * @param {Texture} colorTexture The input color texture.\n * @private\n */\nAutoExposure.prototype.execute = function (context, colorTexture) {\n  this._colorTexture = colorTexture;\n\n  const commands = this._commands;\n  if (!defined(commands)) {\n    return;\n  }\n\n  const length = commands.length;\n  for (let i = 0; i < length; ++i) {\n    commands[i].execute(context);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see AutoExposure#destroy\n */\nAutoExposure.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see AutoExposure#isDestroyed\n */\nAutoExposure.prototype.destroy = function () {\n  destroyFramebuffers(this);\n  destroyCommands(this);\n  return destroyObject(this);\n};\nexport default AutoExposure;\n","import Check from \"../Core/Check.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\n\n/**\n * An enum describing the x, y, and z axes and helper conversion functions.\n *\n * @enum {Number}\n */\nconst Axis = {\n  /**\n   * Denotes the x-axis.\n   *\n   * @type {Number}\n   * @constant\n   */\n  X: 0,\n\n  /**\n   * Denotes the y-axis.\n   *\n   * @type {Number}\n   * @constant\n   */\n  Y: 1,\n\n  /**\n   * Denotes the z-axis.\n   *\n   * @type {Number}\n   * @constant\n   */\n  Z: 2,\n};\n\n/**\n * Matrix used to convert from y-up to z-up\n *\n * @type {Matrix4}\n * @constant\n */\nAxis.Y_UP_TO_Z_UP = Matrix4.fromRotationTranslation(\n  Matrix3.fromRotationX(CesiumMath.PI_OVER_TWO)\n);\n\n/**\n * Matrix used to convert from z-up to y-up\n *\n * @type {Matrix4}\n * @constant\n */\nAxis.Z_UP_TO_Y_UP = Matrix4.fromRotationTranslation(\n  Matrix3.fromRotationX(-CesiumMath.PI_OVER_TWO)\n);\n\n/**\n * Matrix used to convert from x-up to z-up\n *\n * @type {Matrix4}\n * @constant\n */\nAxis.X_UP_TO_Z_UP = Matrix4.fromRotationTranslation(\n  Matrix3.fromRotationY(-CesiumMath.PI_OVER_TWO)\n);\n\n/**\n * Matrix used to convert from z-up to x-up\n *\n * @type {Matrix4}\n * @constant\n */\nAxis.Z_UP_TO_X_UP = Matrix4.fromRotationTranslation(\n  Matrix3.fromRotationY(CesiumMath.PI_OVER_TWO)\n);\n\n/**\n * Matrix used to convert from x-up to y-up\n *\n * @type {Matrix4}\n * @constant\n */\nAxis.X_UP_TO_Y_UP = Matrix4.fromRotationTranslation(\n  Matrix3.fromRotationZ(CesiumMath.PI_OVER_TWO)\n);\n\n/**\n * Matrix used to convert from y-up to x-up\n *\n * @type {Matrix4}\n * @constant\n */\nAxis.Y_UP_TO_X_UP = Matrix4.fromRotationTranslation(\n  Matrix3.fromRotationZ(-CesiumMath.PI_OVER_TWO)\n);\n\n/**\n * Gets the axis by name\n *\n * @param {String} name The name of the axis.\n * @returns {Number} The axis enum.\n */\nAxis.fromName = function (name) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  return Axis[name];\n};\n\nexport default Object.freeze(Axis);\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * Handles parsing of a Batched 3D Model.\n *\n * @namespace B3dmParser\n * @private\n */\nconst B3dmParser = {};\nB3dmParser._deprecationWarning = deprecationWarning;\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\n/**\n * Parses the contents of a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel|Batched 3D Model}.\n *\n * @private\n *\n * @param {ArrayBuffer} arrayBuffer The array buffer containing the b3dm.\n * @param {Number} [byteOffset=0] The byte offset of the beginning of the b3dm in the array buffer.\n * @returns {Object} Returns an object with the batch length, feature table (binary and json), batch table (binary and json) and glTF parts of the b3dm.\n */\nB3dmParser.parse = function (arrayBuffer, byteOffset) {\n  const byteStart = defaultValue(byteOffset, 0);\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  byteOffset = byteStart;\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Batched 3D Model version 1 is supported.  Version ${version} is not.`\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  let batchLength;\n\n  // Legacy header #1: [batchLength] [batchTableByteLength]\n  // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]\n  // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]\n  // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.\n  // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table JSON will exceed this length.\n  // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead\n  if (batchTableJsonByteLength >= 570425344) {\n    // First legacy check\n    byteOffset -= sizeOfUint32 * 2;\n    batchLength = featureTableJsonByteLength;\n    batchTableJsonByteLength = featureTableBinaryByteLength;\n    batchTableBinaryByteLength = 0;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    B3dmParser._deprecationWarning(\n      \"b3dm-legacy-header\",\n      \"This b3dm header is using the legacy format [batchLength] [batchTableByteLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel.\"\n    );\n  } else if (batchTableBinaryByteLength >= 570425344) {\n    // Second legacy check\n    byteOffset -= sizeOfUint32;\n    batchLength = batchTableJsonByteLength;\n    batchTableJsonByteLength = featureTableJsonByteLength;\n    batchTableBinaryByteLength = featureTableBinaryByteLength;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    B3dmParser._deprecationWarning(\n      \"b3dm-legacy-header\",\n      \"This b3dm header is using the legacy format [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]. The new format is [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength] from https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel.\"\n    );\n  }\n\n  let featureTableJson;\n  if (featureTableJsonByteLength === 0) {\n    featureTableJson = {\n      BATCH_LENGTH: defaultValue(batchLength, 0),\n    };\n  } else {\n    featureTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      featureTableJsonByteLength\n    );\n    byteOffset += featureTableJsonByteLength;\n  }\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJsonByteLength\n    );\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength\n      );\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  const gltfByteLength = byteStart + byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new RuntimeError(\"glTF byte length must be greater than 0.\");\n  }\n\n  let gltfView;\n  if (byteOffset % 4 === 0) {\n    gltfView = new Uint8Array(arrayBuffer, byteOffset, gltfByteLength);\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    B3dmParser._deprecationWarning(\n      \"b3dm-glb-unaligned\",\n      \"The embedded glb is not aligned to a 4-byte boundary.\"\n    );\n    gltfView = new Uint8Array(\n      uint8Array.subarray(byteOffset, byteOffset + gltfByteLength)\n    );\n  }\n\n  return {\n    batchLength: batchLength,\n    featureTableJson: featureTableJson,\n    featureTableBinary: featureTableBinary,\n    batchTableJson: batchTableJson,\n    batchTableBinary: batchTableBinary,\n    gltf: gltfView,\n  };\n};\n\nexport default B3dmParser;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * Creates a texture to look up per instance attributes for batched primitives. For example, store each primitive's pick color in the texture.\n *\n * @alias BatchTable\n * @constructor\n * @private\n *\n * @param {Context} context The context in which the batch table is created.\n * @param {Object[]} attributes An array of objects describing a per instance attribute. Each object contains a datatype, components per attributes, whether it is normalized and a function name\n *     to retrieve the value in the vertex shader.\n * @param {Number} numberOfInstances The number of instances in a batch table.\n *\n * @example\n * // create the batch table\n * const attributes = [{\n *     functionName : 'getShow',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 1\n * }, {\n *     functionName : 'getPickColor',\n *     componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n *     componentsPerAttribute : 4,\n *     normalize : true\n * }];\n * const batchTable = new BatchTable(context, attributes, 5);\n *\n * // when creating the draw commands, update the uniform map and the vertex shader\n * vertexShaderSource = batchTable.getVertexShaderCallback()(vertexShaderSource);\n * const shaderProgram = ShaderProgram.fromCache({\n *    // ...\n *    vertexShaderSource : vertexShaderSource,\n * });\n *\n * drawCommand.shaderProgram = shaderProgram;\n * drawCommand.uniformMap = batchTable.getUniformMapCallback()(uniformMap);\n *\n * // use the attribute function names in the shader to retrieve the instance values\n * // ...\n * attribute float batchId;\n *\n * void main() {\n *     // ...\n *     float show = getShow(batchId);\n *     vec3 pickColor = getPickColor(batchId);\n *     // ...\n * }\n */\nfunction BatchTable(context, attributes, numberOfInstances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required\");\n  }\n  if (!defined(attributes)) {\n    throw new DeveloperError(\"attributes is required\");\n  }\n  if (!defined(numberOfInstances)) {\n    throw new DeveloperError(\"numberOfInstances is required\");\n  }\n  //>>includeEnd('debug');\n\n  this._attributes = attributes;\n  this._numberOfInstances = numberOfInstances;\n\n  if (attributes.length === 0) {\n    return;\n  }\n\n  // PERFORMANCE_IDEA: We may be able to arrange the attributes so they can be packing into fewer texels.\n  // Right now, an attribute with one component uses an entire texel when 4 single component attributes can\n  // be packed into a texel.\n  //\n  // Packing floats into unsigned byte textures makes the problem worse. A single component float attribute\n  // will be packed into a single texel leaving 3 texels unused. 4 texels are reserved for each float attribute\n  // regardless of how many components it has.\n  const pixelDatatype = getDatatype(attributes);\n  const textureFloatSupported = context.floatingPointTexture;\n  const packFloats =\n    pixelDatatype === PixelDatatype.FLOAT && !textureFloatSupported;\n  const offsets = createOffsets(attributes, packFloats);\n\n  const stride = getStride(offsets, attributes, packFloats);\n  const maxNumberOfInstancesPerRow = Math.floor(\n    ContextLimits.maximumTextureSize / stride\n  );\n\n  const instancesPerWidth = Math.min(\n    numberOfInstances,\n    maxNumberOfInstancesPerRow\n  );\n  const width = stride * instancesPerWidth;\n  const height = Math.ceil(numberOfInstances / instancesPerWidth);\n\n  const stepX = 1.0 / width;\n  const centerX = stepX * 0.5;\n  const stepY = 1.0 / height;\n  const centerY = stepY * 0.5;\n\n  this._textureDimensions = new Cartesian2(width, height);\n  this._textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  this._pixelDatatype = !packFloats\n    ? pixelDatatype\n    : PixelDatatype.UNSIGNED_BYTE;\n  this._packFloats = packFloats;\n  this._offsets = offsets;\n  this._stride = stride;\n  this._texture = undefined;\n\n  const batchLength = 4 * width * height;\n  this._batchValues =\n    pixelDatatype === PixelDatatype.FLOAT && !packFloats\n      ? new Float32Array(batchLength)\n      : new Uint8Array(batchLength);\n  this._batchValuesDirty = false;\n}\n\nObject.defineProperties(BatchTable.prototype, {\n  /**\n   * The attribute descriptions.\n   * @memberOf BatchTable.prototype\n   * @type {Object[]}\n   * @readonly\n   */\n  attributes: {\n    get: function () {\n      return this._attributes;\n    },\n  },\n  /**\n   * The number of instances.\n   * @memberOf BatchTable.prototype\n   * @type {Number}\n   * @readonly\n   */\n  numberOfInstances: {\n    get: function () {\n      return this._numberOfInstances;\n    },\n  },\n});\n\nfunction getDatatype(attributes) {\n  let foundFloatDatatype = false;\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    if (attributes[i].componentDatatype !== ComponentDatatype.UNSIGNED_BYTE) {\n      foundFloatDatatype = true;\n      break;\n    }\n  }\n  return foundFloatDatatype ? PixelDatatype.FLOAT : PixelDatatype.UNSIGNED_BYTE;\n}\n\nfunction getAttributeType(attributes, attributeIndex) {\n  const componentsPerAttribute =\n    attributes[attributeIndex].componentsPerAttribute;\n  if (componentsPerAttribute === 2) {\n    return Cartesian2;\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3;\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4;\n  }\n  return Number;\n}\n\nfunction createOffsets(attributes, packFloats) {\n  const offsets = new Array(attributes.length);\n\n  let currentOffset = 0;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    const componentDatatype = attribute.componentDatatype;\n\n    offsets[i] = currentOffset;\n\n    if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n      currentOffset += 4;\n    } else {\n      ++currentOffset;\n    }\n  }\n\n  return offsets;\n}\n\nfunction getStride(offsets, attributes, packFloats) {\n  const length = offsets.length;\n  const lastOffset = offsets[length - 1];\n  const lastAttribute = attributes[length - 1];\n  const componentDatatype = lastAttribute.componentDatatype;\n\n  if (componentDatatype !== ComponentDatatype.UNSIGNED_BYTE && packFloats) {\n    return lastOffset + 4;\n  }\n  return lastOffset + 1;\n}\n\nconst scratchPackedFloatCartesian4 = new Cartesian4();\n\nfunction getPackedFloat(array, index, result) {\n  let packed = Cartesian4.unpack(array, index, scratchPackedFloatCartesian4);\n  const x = Cartesian4.unpackFloat(packed);\n\n  packed = Cartesian4.unpack(array, index + 4, scratchPackedFloatCartesian4);\n  const y = Cartesian4.unpackFloat(packed);\n\n  packed = Cartesian4.unpack(array, index + 8, scratchPackedFloatCartesian4);\n  const z = Cartesian4.unpackFloat(packed);\n\n  packed = Cartesian4.unpack(array, index + 12, scratchPackedFloatCartesian4);\n  const w = Cartesian4.unpackFloat(packed);\n\n  return Cartesian4.fromElements(x, y, z, w, result);\n}\n\nfunction setPackedAttribute(value, array, index) {\n  let packed = Cartesian4.packFloat(value.x, scratchPackedFloatCartesian4);\n  Cartesian4.pack(packed, array, index);\n\n  packed = Cartesian4.packFloat(value.y, packed);\n  Cartesian4.pack(packed, array, index + 4);\n\n  packed = Cartesian4.packFloat(value.z, packed);\n  Cartesian4.pack(packed, array, index + 8);\n\n  packed = Cartesian4.packFloat(value.w, packed);\n  Cartesian4.pack(packed, array, index + 12);\n}\n\nconst scratchGetAttributeCartesian4 = new Cartesian4();\n\n/**\n * Gets the value of an attribute in the table.\n *\n * @param {Number} instanceIndex The index of the instance.\n * @param {Number} attributeIndex The index of the attribute.\n * @param {undefined|Cartesian2|Cartesian3|Cartesian4} [result] The object onto which to store the result. The type is dependent on the attribute's number of components.\n * @returns {Number|Cartesian2|Cartesian3|Cartesian4} The attribute value stored for the instance.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\nBatchTable.prototype.getBatchedAttribute = function (\n  instanceIndex,\n  attributeIndex,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = this._attributes;\n  const offset = this._offsets[attributeIndex];\n  const stride = this._stride;\n\n  const index = 4 * stride * instanceIndex + 4 * offset;\n  let value;\n\n  if (\n    this._packFloats &&\n    attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE\n  ) {\n    value = getPackedFloat(\n      this._batchValues,\n      index,\n      scratchGetAttributeCartesian4\n    );\n  } else {\n    value = Cartesian4.unpack(\n      this._batchValues,\n      index,\n      scratchGetAttributeCartesian4\n    );\n  }\n\n  const attributeType = getAttributeType(attributes, attributeIndex);\n  if (defined(attributeType.fromCartesian4)) {\n    return attributeType.fromCartesian4(value, result);\n  } else if (defined(attributeType.clone)) {\n    return attributeType.clone(value, result);\n  }\n\n  return value.x;\n};\n\nconst setAttributeScratchValues = [\n  undefined,\n  undefined,\n  new Cartesian2(),\n  new Cartesian3(),\n  new Cartesian4(),\n];\nconst setAttributeScratchCartesian4 = new Cartesian4();\n\n/**\n * Sets the value of an attribute in the table.\n *\n * @param {Number} instanceIndex The index of the instance.\n * @param {Number} attributeIndex The index of the attribute.\n * @param {Number|Cartesian2|Cartesian3|Cartesian4} value The value to be stored in the table. The type of value will depend on the number of components of the attribute.\n *\n * @exception {DeveloperError} instanceIndex is out of range.\n * @exception {DeveloperError} attributeIndex is out of range.\n */\nBatchTable.prototype.setBatchedAttribute = function (\n  instanceIndex,\n  attributeIndex,\n  value\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (instanceIndex < 0 || instanceIndex >= this._numberOfInstances) {\n    throw new DeveloperError(\"instanceIndex is out of range.\");\n  }\n  if (attributeIndex < 0 || attributeIndex >= this._attributes.length) {\n    throw new DeveloperError(\"attributeIndex is out of range\");\n  }\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = this._attributes;\n  const result =\n    setAttributeScratchValues[\n      attributes[attributeIndex].componentsPerAttribute\n    ];\n  const currentAttribute = this.getBatchedAttribute(\n    instanceIndex,\n    attributeIndex,\n    result\n  );\n  const attributeType = getAttributeType(this._attributes, attributeIndex);\n  const entriesEqual = defined(attributeType.equals)\n    ? attributeType.equals(currentAttribute, value)\n    : currentAttribute === value;\n  if (entriesEqual) {\n    return;\n  }\n\n  const attributeValue = setAttributeScratchCartesian4;\n  attributeValue.x = defined(value.x) ? value.x : value;\n  attributeValue.y = defined(value.y) ? value.y : 0.0;\n  attributeValue.z = defined(value.z) ? value.z : 0.0;\n  attributeValue.w = defined(value.w) ? value.w : 0.0;\n\n  const offset = this._offsets[attributeIndex];\n  const stride = this._stride;\n  const index = 4 * stride * instanceIndex + 4 * offset;\n\n  if (\n    this._packFloats &&\n    attributes[attributeIndex].componentDatatype !== PixelDatatype.UNSIGNED_BYTE\n  ) {\n    setPackedAttribute(attributeValue, this._batchValues, index);\n  } else {\n    Cartesian4.pack(attributeValue, this._batchValues, index);\n  }\n\n  this._batchValuesDirty = true;\n};\n\nfunction createTexture(batchTable, context) {\n  const dimensions = batchTable._textureDimensions;\n  batchTable._texture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: batchTable._pixelDatatype,\n    width: dimensions.x,\n    height: dimensions.y,\n    sampler: Sampler.NEAREST,\n    flipY: false,\n  });\n}\n\nfunction updateTexture(batchTable) {\n  const dimensions = batchTable._textureDimensions;\n  batchTable._texture.copyFrom({\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: batchTable._batchValues,\n    },\n  });\n}\n\n/**\n * Creates/updates the batch table texture.\n * @param {FrameState} frameState The frame state.\n *\n * @exception {RuntimeError} The floating point texture extension is required but not supported.\n */\nBatchTable.prototype.update = function (frameState) {\n  if (\n    (defined(this._texture) && !this._batchValuesDirty) ||\n    this._attributes.length === 0\n  ) {\n    return;\n  }\n\n  this._batchValuesDirty = false;\n\n  if (!defined(this._texture)) {\n    createTexture(this, frameState.context);\n  }\n  updateTexture(this);\n};\n\n/**\n * Gets a function that will update a uniform map to contain values for looking up values in the batch table.\n *\n * @returns {BatchTable.updateUniformMapCallback} A callback for updating uniform maps.\n */\nBatchTable.prototype.getUniformMapCallback = function () {\n  const that = this;\n  return function (uniformMap) {\n    if (that._attributes.length === 0) {\n      return uniformMap;\n    }\n\n    const batchUniformMap = {\n      batchTexture: function () {\n        return that._texture;\n      },\n      batchTextureDimensions: function () {\n        return that._textureDimensions;\n      },\n      batchTextureStep: function () {\n        return that._textureStep;\n      },\n    };\n    return combine(uniformMap, batchUniformMap);\n  };\n};\n\nfunction getGlslComputeSt(batchTable) {\n  const stride = batchTable._stride;\n\n  // GLSL batchId is zero-based: [0, numberOfInstances - 1]\n  if (batchTable._textureDimensions.y === 1) {\n    return (\n      `${\n        \"uniform vec4 batchTextureStep; \\n\" +\n        \"vec2 computeSt(float batchId) \\n\" +\n        \"{ \\n\" +\n        \"    float stepX = batchTextureStep.x; \\n\" +\n        \"    float centerX = batchTextureStep.y; \\n\" +\n        \"    float numberOfAttributes = float(\"\n      }${stride}); \\n` +\n      `    return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); \\n` +\n      `} \\n`\n    );\n  }\n\n  return (\n    `${\n      \"uniform vec4 batchTextureStep; \\n\" +\n      \"uniform vec2 batchTextureDimensions; \\n\" +\n      \"vec2 computeSt(float batchId) \\n\" +\n      \"{ \\n\" +\n      \"    float stepX = batchTextureStep.x; \\n\" +\n      \"    float centerX = batchTextureStep.y; \\n\" +\n      \"    float stepY = batchTextureStep.z; \\n\" +\n      \"    float centerY = batchTextureStep.w; \\n\" +\n      \"    float numberOfAttributes = float(\"\n    }${stride}); \\n` +\n    `    float xId = mod(batchId * numberOfAttributes, batchTextureDimensions.x); \\n` +\n    `    float yId = floor(batchId * numberOfAttributes / batchTextureDimensions.x); \\n` +\n    `    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n` +\n    `} \\n`\n  );\n}\n\nfunction getComponentType(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \"float\";\n  }\n  return `vec${componentsPerAttribute}`;\n}\n\nfunction getComponentSwizzle(componentsPerAttribute) {\n  if (componentsPerAttribute === 1) {\n    return \".x\";\n  } else if (componentsPerAttribute === 2) {\n    return \".xy\";\n  } else if (componentsPerAttribute === 3) {\n    return \".xyz\";\n  }\n  return \"\";\n}\n\nfunction getGlslAttributeFunction(batchTable, attributeIndex) {\n  const attributes = batchTable._attributes;\n  const attribute = attributes[attributeIndex];\n  const componentsPerAttribute = attribute.componentsPerAttribute;\n  const functionName = attribute.functionName;\n  const functionReturnType = getComponentType(componentsPerAttribute);\n  const functionReturnValue = getComponentSwizzle(componentsPerAttribute);\n\n  const offset = batchTable._offsets[attributeIndex];\n\n  let glslFunction =\n    `${functionReturnType} ${functionName}(float batchId) \\n` +\n    `{ \\n` +\n    `    vec2 st = computeSt(batchId); \\n` +\n    `    st.x += batchTextureStep.x * float(${offset}); \\n`;\n\n  if (\n    batchTable._packFloats &&\n    attribute.componentDatatype !== PixelDatatype.UNSIGNED_BYTE\n  ) {\n    glslFunction +=\n      \"vec4 textureValue; \\n\" +\n      \"textureValue.x = czm_unpackFloat(texture2D(batchTexture, st)); \\n\" +\n      \"textureValue.y = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x, 0.0))); \\n\" +\n      \"textureValue.z = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 2.0, 0.0))); \\n\" +\n      \"textureValue.w = czm_unpackFloat(texture2D(batchTexture, st + vec2(batchTextureStep.x * 3.0, 0.0))); \\n\";\n  } else {\n    glslFunction += \"    vec4 textureValue = texture2D(batchTexture, st); \\n\";\n  }\n\n  glslFunction += `    ${functionReturnType} value = textureValue${functionReturnValue}; \\n`;\n\n  if (\n    batchTable._pixelDatatype === PixelDatatype.UNSIGNED_BYTE &&\n    attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE &&\n    !attribute.normalize\n  ) {\n    glslFunction += \"value *= 255.0; \\n\";\n  } else if (\n    batchTable._pixelDatatype === PixelDatatype.FLOAT &&\n    attribute.componentDatatype === ComponentDatatype.UNSIGNED_BYTE &&\n    attribute.normalize\n  ) {\n    glslFunction += \"value /= 255.0; \\n\";\n  }\n\n  glslFunction += \"    return value; \\n\" + \"} \\n\";\n  return glslFunction;\n}\n\n/**\n * Gets a function that will update a vertex shader to contain functions for looking up values in the batch table.\n *\n * @returns {BatchTable.updateVertexShaderSourceCallback} A callback for updating a vertex shader source.\n */\nBatchTable.prototype.getVertexShaderCallback = function () {\n  const attributes = this._attributes;\n  if (attributes.length === 0) {\n    return function (source) {\n      return source;\n    };\n  }\n\n  let batchTableShader = \"uniform highp sampler2D batchTexture; \\n\";\n  batchTableShader += `${getGlslComputeSt(this)}\\n`;\n\n  const length = attributes.length;\n  for (let i = 0; i < length; ++i) {\n    batchTableShader += getGlslAttributeFunction(this, i);\n  }\n\n  return function (source) {\n    const mainIndex = source.indexOf(\"void main\");\n    const beforeMain = source.substring(0, mainIndex);\n    const afterMain = source.substring(mainIndex);\n    return `${beforeMain}\\n${batchTableShader}\\n${afterMain}`;\n  };\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BatchTable#destroy\n */\nBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see BatchTable#isDestroyed\n */\nBatchTable.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * A callback for updating uniform maps.\n * @callback BatchTable.updateUniformMapCallback\n *\n * @param {Object} uniformMap The uniform map.\n * @returns {Object} The new uniform map with properties for retrieving values from the batch table.\n */\n\n/**\n * A callback for updating a vertex shader source.\n * @callback BatchTable.updateVertexShaderSourceCallback\n *\n * @param {String} vertexShaderSource The vertex shader source.\n * @returns {String} The new vertex shader source with the functions for retrieving batch table values injected.\n */\nexport default BatchTable;\n","import arrayFill from \"../Core/arrayFill.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * Object for handling the <code>3DTILES_batch_table_hierarchy</code> extension\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.extension The <code>3DTILES_batch_table_hierarchy</code> extension object.\n * @param {Uint8Array} [options.binaryBody] The binary body of the batch table\n *\n * @alias BatchTableHierarchy\n * @constructor\n *\n * @private\n */\nexport default function BatchTableHierarchy(options) {\n  this._classes = undefined;\n  this._classIds = undefined;\n  this._classIndexes = undefined;\n  this._parentCounts = undefined;\n  this._parentIndexes = undefined;\n  this._parentIds = undefined;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.extension\", options.extension);\n  //>>includeEnd('debug');\n\n  initialize(this, options.extension, options.binaryBody);\n\n  //>>includeStart('debug', pragmas.debug);\n  validateHierarchy(this);\n  //>>includeEnd('debug');\n}\n\n/**\n * Parse the batch table hierarchy from the\n * <code>3DTILES_batch_table_hierarchy</code> extension.\n *\n * @param {BatchTableHierarchy} hierarchy The hierarchy instance\n * @param {Object} hierarchyJson The JSON of the extension\n * @param {Uint8Array} [binaryBody] The binary body of the batch table for accessing binary properties\n * @private\n */\nfunction initialize(hierarchy, hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(\n      classIds.componentType,\n      ComponentDatatype.UNSIGNED_SHORT\n    );\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + classIds.byteOffset,\n      instancesLength\n    );\n  }\n\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(\n        parentCounts.componentType,\n        ComponentDatatype.UNSIGNED_SHORT\n      );\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(\n        binaryBody.buffer,\n        binaryBody.byteOffset + parentCounts.byteOffset,\n        instancesLength\n      );\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(\n      parentIds.componentType,\n      ComponentDatatype.UNSIGNED_SHORT\n    );\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + parentIds.byteOffset,\n      parentIdsLength\n    );\n  }\n\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(\n      classInstancesLength,\n      properties,\n      binaryBody\n    );\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  const classCounts = arrayFill(new Array(classesLength), 0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n\n  hierarchy._classes = classes;\n  hierarchy._classIds = classIds;\n  hierarchy._classIndexes = classIndexes;\n  hierarchy._parentCounts = parentCounts;\n  hierarchy._parentIndexes = parentIndexes;\n  hierarchy._parentIds = parentIds;\n}\n\nfunction getBinaryProperties(featuresLength, properties, binaryBody) {\n  let binaryProperties;\n  for (const name in properties) {\n    if (properties.hasOwnProperty(name)) {\n      const property = properties[name];\n      const byteOffset = property.byteOffset;\n      if (defined(byteOffset)) {\n        // This is a binary property\n        const componentType = property.componentType;\n        const type = property.type;\n        if (!defined(componentType)) {\n          throw new RuntimeError(\"componentType is required.\");\n        }\n        if (!defined(type)) {\n          throw new RuntimeError(\"type is required.\");\n        }\n        if (!defined(binaryBody)) {\n          throw new RuntimeError(\n            `Property ${name} requires a batch table binary.`\n          );\n        }\n\n        const binaryAccessor = getBinaryAccessor(property);\n        const componentCount = binaryAccessor.componentsPerAttribute;\n        const classType = binaryAccessor.classType;\n        const typedArray = binaryAccessor.createArrayBufferView(\n          binaryBody.buffer,\n          binaryBody.byteOffset + byteOffset,\n          featuresLength\n        );\n\n        if (!defined(binaryProperties)) {\n          binaryProperties = {};\n        }\n\n        // Store any information needed to access the binary data, including the typed array,\n        // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n        binaryProperties[name] = {\n          typedArray: typedArray,\n          componentCount: componentCount,\n          type: classType,\n        };\n      }\n    }\n  }\n  return binaryProperties;\n}\n\n//>>includeStart('debug', pragmas.debug);\nconst scratchValidateStack = [];\nfunction validateHierarchy(hierarchy) {\n  const stack = scratchValidateStack;\n  stack.length = 0;\n\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const classIds = hierarchy._classIds;\n  const instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n\n  if (instanceIndex >= instancesLength) {\n    throw new DeveloperError(\n      `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`\n    );\n  }\n  if (stack.indexOf(instanceIndex) > -1) {\n    throw new DeveloperError(\n      \"Circular dependency detected in the batch table hierarchy.\"\n    );\n  }\n\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts)\n    ? parentIndexes[instanceIndex]\n    : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n//>>includeEnd('debug');\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nconst scratchVisited = [];\nconst scratchStack = [];\nlet marker = 0;\nfunction traverseHierarchyMultipleParents(\n  hierarchy,\n  instanceIndex,\n  endConditionCallback\n) {\n  const classIds = hierarchy._classIds;\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  const parentIndexes = hierarchy._parentIndexes;\n  const instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n}\n\nfunction traverseHierarchySingleParent(\n  hierarchy,\n  instanceIndex,\n  endConditionCallback\n) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy._parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n}\n\nfunction traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  // Traverse over the hierarchy and process each instance with the endConditionCallback.\n  // When the endConditionCallback returns a value, the traversal stops and that value is returned.\n  const parentCounts = hierarchy._parentCounts;\n  const parentIds = hierarchy._parentIds;\n  if (!defined(parentIds)) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  } else if (defined(parentCounts)) {\n    return traverseHierarchyMultipleParents(\n      hierarchy,\n      instanceIndex,\n      endConditionCallback\n    );\n  }\n  return traverseHierarchySingleParent(\n    hierarchy,\n    instanceIndex,\n    endConditionCallback\n  );\n}\n\n/**\n * Returns whether the feature has this property.\n *\n * @param {Number} batchId the batch ID of the feature\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.hasProperty = function (batchId, propertyId) {\n  const result = traverseHierarchy(this, batchId, function (\n    hierarchy,\n    instanceIndex\n  ) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instances = hierarchy._classes[classId].instances;\n    if (defined(instances[propertyId])) {\n      return true;\n    }\n  });\n  return defined(result);\n};\n\n/**\n * Returns whether any feature has this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether any feature has this property.\n * @private\n */\nBatchTableHierarchy.prototype.propertyExists = function (propertyId) {\n  const classes = this._classes;\n  const classesLength = classes.length;\n  for (let i = 0; i < classesLength; ++i) {\n    const instances = classes[i].instances;\n    if (defined(instances[propertyId])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {Number} batchId the batch ID of the feature\n * @param {Number} index The index of the entity.\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nBatchTableHierarchy.prototype.getPropertyIds = function (batchId, results) {\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instances = hierarchy._classes[classId].instances;\n    for (const name in instances) {\n      if (instances.hasOwnProperty(name)) {\n        if (results.indexOf(name) === -1) {\n          results.push(name);\n        }\n      }\n    }\n  });\n\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n *\n * @param {Number} batchId the batch ID of the feature\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n * @private\n */\nBatchTableHierarchy.prototype.getProperty = function (batchId, propertyId) {\n  return traverseHierarchy(this, batchId, function (hierarchy, instanceIndex) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    const indexInClass = hierarchy._classIndexes[instanceIndex];\n    const propertyValues = instanceClass.instances[propertyId];\n    if (defined(propertyValues)) {\n      if (defined(propertyValues.typedArray)) {\n        return getBinaryProperty(propertyValues, indexInClass);\n      }\n      return clone(propertyValues[indexInClass], true);\n    }\n  });\n};\n\nfunction getBinaryProperty(binaryProperty, index) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\n\n/**\n * Sets the value of the property with the given ID. Only properties of the\n * instance may be set; parent properties may not be set.\n *\n * @param {Number} batchId The batchId of the feature\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} when setting an inherited property\n * @private\n */\nBatchTableHierarchy.prototype.setProperty = function (\n  batchId,\n  propertyId,\n  value\n) {\n  const result = traverseHierarchy(this, batchId, function (\n    hierarchy,\n    instanceIndex\n  ) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    const indexInClass = hierarchy._classIndexes[instanceIndex];\n    const propertyValues = instanceClass.instances[propertyId];\n    if (defined(propertyValues)) {\n      //>>includeStart('debug', pragmas.debug);\n      if (instanceIndex !== batchId) {\n        throw new DeveloperError(\n          `Inherited property \"${propertyId}\" is read-only.`\n        );\n      }\n      //>>includeEnd('debug');\n      if (defined(propertyValues.typedArray)) {\n        setBinaryProperty(propertyValues, indexInClass, value);\n      } else {\n        propertyValues[indexInClass] = clone(value, true);\n      }\n      return true;\n    }\n  });\n  return defined(result);\n};\n\nfunction setBinaryProperty(binaryProperty, index, value) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n}\n\n/**\n * Check if a feature belongs to a class with the given name\n *\n * @param {Number} batchId The batch ID of the feature\n * @param {String} className The name of the class\n * @return {Boolean} <code>true</code> if the feature belongs to the class given by className, or <code>false</code> otherwise\n * @private\n */\nBatchTableHierarchy.prototype.isClass = function (batchId, className) {\n  // PERFORMANCE_IDEA : cache results in the ancestor classes to speed up this check if this area becomes a hotspot\n  // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n  const result = traverseHierarchy(this, batchId, function (\n    hierarchy,\n    instanceIndex\n  ) {\n    const classId = hierarchy._classIds[instanceIndex];\n    const instanceClass = hierarchy._classes[classId];\n    if (instanceClass.name === className) {\n      return true;\n    }\n  });\n  return defined(result);\n};\n\n/**\n * Get the name of the class a given feature belongs to\n *\n * @param {Number} batchId The batch ID of the feature\n * @return {String} The name of the class this feature belongs to\n */\nBatchTableHierarchy.prototype.getClassName = function (batchId) {\n  const classId = this._classIds[batchId];\n  const instanceClass = this._classes[classId];\n  return instanceClass.name;\n};\n","import arrayFill from \"../Core/arrayFill.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n/**\n * An object that manages color, show/hide and picking textures for a batch\n * table or feature table.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} featuresLength The number of features in the batch table or feature table\n * @param {Cesium3DTileContent|ModelFeatureTable} owner The owner of this batch texture. For 3D Tiles, this will be a {@link Cesium3DTileContent}. For glTF models, this will be a {@link ModelFeatureTable}.\n * @param {Object} [statistics] The statistics object to update with information about the batch texture.\n * @param {Function} [colorChangedCallback] A callback function that is called whenever the color of a feature changes.\n *\n * @alias BatchTexture\n * @constructor\n *\n * @private\n */\nexport default function BatchTexture(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.featuresLength\", options.featuresLength);\n  Check.typeOf.object(\"options.owner\", options.owner);\n  //>>includeEnd('debug');\n\n  const featuresLength = options.featuresLength;\n\n  // PERFORMANCE_IDEA: These parallel arrays probably generate cache misses in get/set color/show\n  // and use A LOT of memory.  How can we use less memory?\n  this._showAlphaProperties = undefined; // [Show (0 or 255), Alpha (0 to 255)] property for each feature\n  this._batchValues = undefined; // Per-feature RGBA (A is based on the color's alpha and feature's show property)\n\n  this._batchValuesDirty = false;\n  this._batchTexture = undefined;\n  this._defaultTexture = undefined;\n\n  this._pickTexture = undefined;\n  this._pickIds = [];\n\n  // Dimensions for batch and pick textures\n  let textureDimensions;\n  let textureStep;\n\n  if (featuresLength > 0) {\n    // PERFORMANCE_IDEA: this can waste memory in the last row in the uncommon case\n    // when more than one row is needed (e.g., > 16K features in one tile)\n    const width = Math.min(featuresLength, ContextLimits.maximumTextureSize);\n    const height = Math.ceil(featuresLength / ContextLimits.maximumTextureSize);\n    const stepX = 1.0 / width;\n    const centerX = stepX * 0.5;\n    const stepY = 1.0 / height;\n    const centerY = stepY * 0.5;\n\n    textureDimensions = new Cartesian2(width, height);\n    textureStep = new Cartesian4(stepX, centerX, stepY, centerY);\n  }\n\n  this._translucentFeaturesLength = 0;\n  this._featuresLength = featuresLength;\n  this._textureDimensions = textureDimensions;\n  this._textureStep = textureStep;\n  this._owner = options.owner;\n  this._statistics = options.statistics;\n  this._colorChangedCallback = options.colorChangedCallback;\n}\n\nObject.defineProperties(BatchTexture.prototype, {\n  /**\n   * Number of features that are translucent\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  translucentFeaturesLength: {\n    get: function () {\n      return this._translucentFeaturesLength;\n    },\n  },\n\n  /**\n   * Total size of all GPU resources used by this batch texture.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  memorySizeInBytes: {\n    get: function () {\n      let memory = 0;\n      if (defined(this._pickTexture)) {\n        memory += this._pickTexture.sizeInBytes;\n      }\n      if (defined(this._batchTexture)) {\n        memory += this._batchTexture.sizeInBytes;\n      }\n      return memory;\n    },\n  },\n\n  /**\n   * Dimensions of the underlying batch texture.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Cartesian2}\n   * @readonly\n   * @private\n   */\n  textureDimensions: {\n    get: function () {\n      return this._textureDimensions;\n    },\n  },\n\n  /**\n   * Size of each texture and distance from side to center of a texel in\n   * each direction. Stored as (stepX, centerX, stepY, centerY)\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Cartesian4}\n   * @readonly\n   * @private\n   */\n  textureStep: {\n    get: function () {\n      return this._textureStep;\n    },\n  },\n\n  /**\n   * The underlying texture used for styling. The texels are accessed\n   * by batch ID, and the value is the color of this feature after accounting\n   * for show/hide settings.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  batchTexture: {\n    get: function () {\n      return this._batchTexture;\n    },\n  },\n\n  /**\n   * The default texture to use when there are no batch values\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  defaultTexture: {\n    get: function () {\n      return this._defaultTexture;\n    },\n  },\n\n  /**\n   * The underlying texture used for picking. The texels are accessed by\n   * batch ID, and the value is the pick color.\n   *\n   * @memberof BatchTexture.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  pickTexture: {\n    get: function () {\n      return this._pickTexture;\n    },\n  },\n});\n\nBatchTexture.DEFAULT_COLOR_VALUE = Color.WHITE;\nBatchTexture.DEFAULT_SHOW_VALUE = true;\n\nfunction getByteLength(batchTexture) {\n  const dimensions = batchTexture._textureDimensions;\n  return dimensions.x * dimensions.y * 4;\n}\n\nfunction getBatchValues(batchTexture) {\n  if (!defined(batchTexture._batchValues)) {\n    // Default batch texture to RGBA = 255: white highlight (RGB) and show/alpha = true/255 (A).\n    const byteLength = getByteLength(batchTexture);\n    const bytes = new Uint8Array(byteLength);\n    arrayFill(bytes, 255);\n    batchTexture._batchValues = bytes;\n  }\n\n  return batchTexture._batchValues;\n}\n\nfunction getShowAlphaProperties(batchTexture) {\n  if (!defined(batchTexture._showAlphaProperties)) {\n    const byteLength = 2 * batchTexture._featuresLength;\n    const bytes = new Uint8Array(byteLength);\n    // [Show = true, Alpha = 255]\n    arrayFill(bytes, 255);\n    batchTexture._showAlphaProperties = bytes;\n  }\n  return batchTexture._showAlphaProperties;\n}\n\nfunction checkBatchId(batchId, featuresLength) {\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${featuresLength}` -\n        +\").\"\n    );\n  }\n}\n\n/**\n * Set whether a feature is visible.\n *\n * @param {Number} batchId the ID of the feature\n * @param {Boolean} show <code>true</code> if the feature should be shown, <code>false</code> otherwise\n * @private\n */\nBatchTexture.prototype.setShow = function (batchId, show) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  Check.typeOf.bool(\"show\", show);\n  //>>includeEnd('debug');\n\n  if (show && !defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return;\n  }\n\n  const showAlphaProperties = getShowAlphaProperties(this);\n  const propertyOffset = batchId * 2;\n\n  const newShow = show ? 255 : 0;\n  if (showAlphaProperties[propertyOffset] !== newShow) {\n    showAlphaProperties[propertyOffset] = newShow;\n\n    const batchValues = getBatchValues(this);\n\n    // Compute alpha used in the shader based on show and color.alpha properties\n    const offset = batchId * 4 + 3;\n    batchValues[offset] = show ? showAlphaProperties[propertyOffset + 1] : 0;\n\n    this._batchValuesDirty = true;\n  }\n};\n\n/**\n * Set the show for all features at once.\n *\n * @param {Boolean} show <code>true</code> if the feature should be shown, <code>false</code> otherwise\n * @private\n */\nBatchTexture.prototype.setAllShow = function (show) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"show\", show);\n  //>>includeEnd('debug');\n\n  const featuresLength = this._featuresLength;\n  for (let i = 0; i < featuresLength; ++i) {\n    this.setShow(i, show);\n  }\n};\n\n/**\n * Check the current show value for a feature\n *\n * @param {Number} batchId the ID of the feature\n * @return {Boolean} <code>true</code> if the feature is shown, or <code>false</code> otherwise\n * @private\n */\nBatchTexture.prototype.getShow = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  //>>includeEnd('debug');\n\n  if (!defined(this._showAlphaProperties)) {\n    // Avoid allocating since the default is show = true\n    return true;\n  }\n\n  const offset = batchId * 2;\n  return this._showAlphaProperties[offset] === 255;\n};\n\nconst scratchColorBytes = new Array(4);\n\n/**\n * Set the styling color of a feature\n *\n * @param {Number} batchId the ID of the feature\n * @param {Color} color the color to assign to this feature.\n *\n * @private\n */\nBatchTexture.prototype.setColor = function (batchId, color) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n\n  if (\n    Color.equals(color, BatchTexture.DEFAULT_COLOR_VALUE) &&\n    !defined(this._batchValues)\n  ) {\n    // Avoid allocating since the default is white\n    return;\n  }\n\n  const newColor = color.toBytes(scratchColorBytes);\n  const newAlpha = newColor[3];\n\n  const batchValues = getBatchValues(this);\n  const offset = batchId * 4;\n\n  const showAlphaProperties = getShowAlphaProperties(this);\n  const propertyOffset = batchId * 2;\n\n  if (\n    batchValues[offset] !== newColor[0] ||\n    batchValues[offset + 1] !== newColor[1] ||\n    batchValues[offset + 2] !== newColor[2] ||\n    showAlphaProperties[propertyOffset + 1] !== newAlpha\n  ) {\n    batchValues[offset] = newColor[0];\n    batchValues[offset + 1] = newColor[1];\n    batchValues[offset + 2] = newColor[2];\n\n    const wasTranslucent = showAlphaProperties[propertyOffset + 1] !== 255;\n\n    // Compute alpha used in the shader based on show and color.alpha properties\n    const show = showAlphaProperties[propertyOffset] !== 0;\n    batchValues[offset + 3] = show ? newAlpha : 0;\n    showAlphaProperties[propertyOffset + 1] = newAlpha;\n\n    // Track number of translucent features so we know if this tile needs\n    // opaque commands, translucent commands, or both for rendering.\n    const isTranslucent = newAlpha !== 255;\n    if (isTranslucent && !wasTranslucent) {\n      ++this._translucentFeaturesLength;\n    } else if (!isTranslucent && wasTranslucent) {\n      --this._translucentFeaturesLength;\n    }\n\n    this._batchValuesDirty = true;\n\n    if (defined(this._colorChangedCallback)) {\n      this._colorChangedCallback(batchId, color);\n    }\n  }\n};\n\n/**\n * Set the styling color for all features at once\n *\n * @param {Color} color the color to assign to all features.\n *\n * @private\n */\nBatchTexture.prototype.setAllColor = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n\n  const featuresLength = this._featuresLength;\n  for (let i = 0; i < featuresLength; ++i) {\n    this.setColor(i, color);\n  }\n};\n\n/**\n * Get the current color of a feature\n *\n * @param {Number} batchId The ID of the feature\n * @param {Color} result A color object where the result will be stored.\n * @return {Color} The color assigned to the selected feature\n *\n * @private\n */\nBatchTexture.prototype.getColor = function (batchId, result) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  if (!defined(this._batchValues)) {\n    return Color.clone(BatchTexture.DEFAULT_COLOR_VALUE, result);\n  }\n\n  const batchValues = this._batchValues;\n  const offset = batchId * 4;\n\n  const showAlphaProperties = this._showAlphaProperties;\n  const propertyOffset = batchId * 2;\n\n  return Color.fromBytes(\n    batchValues[offset],\n    batchValues[offset + 1],\n    batchValues[offset + 2],\n    showAlphaProperties[propertyOffset + 1],\n    result\n  );\n};\n\n/**\n * Get the pick color of a feature. This feature is an RGBA encoding of the\n * pick ID.\n *\n * @param {Number} batchId The ID of the feature\n * @return {PickId} The picking color assigned to this feature\n *\n * @private\n */\nBatchTexture.prototype.getPickColor = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this._featuresLength);\n  //>>includeEnd('debug');\n  return this._pickIds[batchId];\n};\n\nfunction createTexture(batchTexture, context, bytes) {\n  const dimensions = batchTexture._textureDimensions;\n  return new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: bytes,\n    },\n    flipY: false,\n    sampler: Sampler.NEAREST,\n  });\n}\n\nfunction createPickTexture(batchTexture, context) {\n  const featuresLength = batchTexture._featuresLength;\n  if (!defined(batchTexture._pickTexture) && featuresLength > 0) {\n    const pickIds = batchTexture._pickIds;\n    const byteLength = getByteLength(batchTexture);\n    const bytes = new Uint8Array(byteLength);\n    const owner = batchTexture._owner;\n    const statistics = batchTexture._statistics;\n\n    // PERFORMANCE_IDEA: we could skip the pick texture completely by allocating\n    // a continuous range of pickIds and then converting the base pickId + batchId\n    // to RGBA in the shader.  The only consider is precision issues, which might\n    // not be an issue in WebGL 2.\n    for (let i = 0; i < featuresLength; ++i) {\n      const pickId = context.createPickId(owner.getFeature(i));\n      pickIds.push(pickId);\n\n      const pickColor = pickId.color;\n      const offset = i * 4;\n      bytes[offset] = Color.floatToByte(pickColor.red);\n      bytes[offset + 1] = Color.floatToByte(pickColor.green);\n      bytes[offset + 2] = Color.floatToByte(pickColor.blue);\n      bytes[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n\n    batchTexture._pickTexture = createTexture(batchTexture, context, bytes);\n    if (defined(statistics)) {\n      statistics.batchTableByteLength += batchTexture._pickTexture.sizeInBytes;\n    }\n  }\n}\n\nfunction updateBatchTexture(batchTexture) {\n  const dimensions = batchTexture._textureDimensions;\n  // PERFORMANCE_IDEA: Instead of rewriting the entire texture, use fine-grained\n  // texture updates when less than, for example, 10%, of the values changed.  Or\n  // even just optimize the common case when one feature show/color changed.\n  batchTexture._batchTexture.copyFrom({\n    source: {\n      width: dimensions.x,\n      height: dimensions.y,\n      arrayBufferView: batchTexture._batchValues,\n    },\n  });\n}\n\nBatchTexture.prototype.update = function (tileset, frameState) {\n  const context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  const passes = frameState.passes;\n  if (passes.pick || passes.postProcess) {\n    createPickTexture(this, context);\n  }\n\n  if (this._batchValuesDirty) {\n    this._batchValuesDirty = false;\n\n    // Create batch texture on-demand\n    if (!defined(this._batchTexture)) {\n      this._batchTexture = createTexture(this, context, this._batchValues);\n      if (defined(this._statistics)) {\n        this._statistics.batchTableByteLength += this._batchTexture.sizeInBytes;\n      }\n    }\n\n    updateBatchTexture(this); // Apply per-feature show/color updates\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BatchTexture#destroy\n * @private\n */\nBatchTexture.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see BatchTexture#isDestroyed\n * @private\n */\nBatchTexture.prototype.destroy = function () {\n  this._batchTexture = this._batchTexture && this._batchTexture.destroy();\n  this._pickTexture = this._pickTexture && this._pickTexture.destroy();\n\n  const pickIds = this._pickIds;\n  const length = pickIds.length;\n  for (let i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  return destroyObject(this);\n};\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport Axis from \"./Axis.js\";\nimport B3dmParser from \"./B3dmParser.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport ClassificationModel from \"./ClassificationModel.js\";\nimport Model from \"./Model.js\";\nimport ModelAnimationLoop from \"./ModelAnimationLoop.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel|Batched 3D Model}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Batched3DModel3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Batched3DModel3DTileContent(\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset\n) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n  this._model = undefined;\n  this._batchTable = undefined;\n  this._features = undefined;\n\n  this._classificationType = tileset.vectorClassificationOnly\n    ? undefined\n    : tileset.classificationType;\n\n  this._metadata = undefined;\n\n  // Populate from gltf when available\n  this._batchIdAttributeName = undefined;\n  this._diffuseAttributeOrUniformName = {};\n\n  this._rtcCenterTransform = undefined;\n  this._contentModelMatrix = undefined;\n\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n\n  initialize(this, arrayBuffer, byteOffset);\n}\n\n// This can be overridden for testing purposes\nBatched3DModel3DTileContent._deprecationWarning = deprecationWarning;\n\nObject.defineProperties(Batched3DModel3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return this.batchTable.featuresLength;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return this._model.pointsLength;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      return this._model.trianglesLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return this._model.geometryByteLength;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return this._model.texturesByteLength;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return this.batchTable.memorySizeInBytes;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._model.readyPromise;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\nfunction getBatchIdAttributeName(gltf) {\n  let batchIdAttributeName = ModelUtility.getAttributeOrUniformBySemantic(\n    gltf,\n    \"_BATCHID\"\n  );\n  if (!defined(batchIdAttributeName)) {\n    batchIdAttributeName = ModelUtility.getAttributeOrUniformBySemantic(\n      gltf,\n      \"BATCHID\"\n    );\n    if (defined(batchIdAttributeName)) {\n      Batched3DModel3DTileContent._deprecationWarning(\n        \"b3dm-legacy-batchid\",\n        \"The glTF in this b3dm uses the semantic `BATCHID`. Application-specific semantics should be prefixed with an underscore: `_BATCHID`.\"\n      );\n    }\n  }\n  return batchIdAttributeName;\n}\n\nfunction getVertexShaderCallback(content) {\n  return function (vs, programId) {\n    const batchTable = content._batchTable;\n    const handleTranslucent = !defined(content._classificationType);\n\n    const gltf = content._model.gltfInternal;\n    if (defined(gltf)) {\n      content._batchIdAttributeName = getBatchIdAttributeName(gltf);\n      content._diffuseAttributeOrUniformName[\n        programId\n      ] = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n    }\n\n    const callback = batchTable.getVertexShaderCallback(\n      handleTranslucent,\n      content._batchIdAttributeName,\n      content._diffuseAttributeOrUniformName[programId]\n    );\n    return defined(callback) ? callback(vs) : vs;\n  };\n}\n\nfunction getFragmentShaderCallback(content) {\n  return function (fs, programId) {\n    const batchTable = content._batchTable;\n    const handleTranslucent = !defined(content._classificationType);\n\n    const gltf = content._model.gltfInternal;\n    if (defined(gltf)) {\n      content._diffuseAttributeOrUniformName[\n        programId\n      ] = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n    }\n    const callback = batchTable.getFragmentShaderCallback(\n      handleTranslucent,\n      content._diffuseAttributeOrUniformName[programId],\n      false\n    );\n    return defined(callback) ? callback(fs) : fs;\n  };\n}\n\nfunction getPickIdCallback(content) {\n  return function () {\n    return content._batchTable.getPickId();\n  };\n}\n\nfunction getClassificationFragmentShaderCallback(content) {\n  return function (fs) {\n    const batchTable = content._batchTable;\n    const callback = batchTable.getClassificationFragmentShaderCallback();\n    return defined(callback) ? callback(fs) : fs;\n  };\n}\n\nfunction createColorChangedCallback(content) {\n  return function (batchId, color) {\n    content._model.updateCommands(batchId, color);\n  };\n}\n\nfunction initialize(content, arrayBuffer, byteOffset) {\n  const tileset = content._tileset;\n  const tile = content._tile;\n  const resource = content._resource;\n\n  const b3dm = B3dmParser.parse(arrayBuffer, byteOffset);\n\n  let batchLength = b3dm.batchLength;\n\n  const featureTableJson = b3dm.featureTableJson;\n  const featureTableBinary = b3dm.featureTableBinary;\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary\n  );\n\n  batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n  featureTable.featuresLength = batchLength;\n\n  const batchTableJson = b3dm.batchTableJson;\n  const batchTableBinary = b3dm.batchTableBinary;\n\n  let colorChangedCallback;\n  if (defined(content._classificationType)) {\n    colorChangedCallback = createColorChangedCallback(content);\n  }\n\n  const batchTable = new Cesium3DTileBatchTable(\n    content,\n    batchLength,\n    batchTableJson,\n    batchTableBinary,\n    colorChangedCallback\n  );\n  content._batchTable = batchTable;\n\n  const gltfView = b3dm.gltf;\n\n  const pickObject = {\n    content: content,\n    primitive: tileset,\n  };\n\n  content._rtcCenterTransform = Matrix4.IDENTITY;\n  const rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n  if (defined(rtcCenter)) {\n    content._rtcCenterTransform = Matrix4.fromTranslation(\n      Cartesian3.fromArray(rtcCenter)\n    );\n  }\n\n  content._contentModelMatrix = Matrix4.multiply(\n    tile.computedTransform,\n    content._rtcCenterTransform,\n    new Matrix4()\n  );\n\n  if (!defined(content._classificationType)) {\n    // PERFORMANCE_IDEA: patch the shader on demand, e.g., the first time show/color changes.\n    // The pick shader still needs to be patched.\n    content._model = new Model({\n      gltf: gltfView,\n      cull: false, // The model is already culled by 3D Tiles\n      releaseGltfJson: true, // Models are unique and will not benefit from caching so save memory\n      opaquePass: Pass.CESIUM_3D_TILE, // Draw opaque portions of the model during the 3D Tiles pass\n      basePath: resource,\n      requestType: RequestType.TILES3D,\n      modelMatrix: content._contentModelMatrix,\n      upAxis: tileset._gltfUpAxis,\n      forwardAxis: Axis.X,\n      shadows: tileset.shadows,\n      debugWireframe: tileset.debugWireframe,\n      incrementallyLoadTextures: false,\n      vertexShaderLoaded: getVertexShaderCallback(content),\n      fragmentShaderLoaded: getFragmentShaderCallback(content),\n      uniformMapLoaded: batchTable.getUniformMapCallback(),\n      pickIdLoaded: getPickIdCallback(content),\n      addBatchIdToGeneratedShaders: batchLength > 0, // If the batch table has values in it, generated shaders will need a batchId attribute\n      pickObject: pickObject,\n      lightColor: tileset.lightColor,\n      imageBasedLighting: tileset.imageBasedLighting,\n      backFaceCulling: tileset.backFaceCulling,\n      showOutline: tileset.showOutline,\n      showCreditsOnScreen: tileset.showCreditsOnScreen,\n    });\n    content._model.readyPromise.then(function (model) {\n      model.activeAnimations.addAll({\n        loop: ModelAnimationLoop.REPEAT,\n      });\n    });\n  } else {\n    // This transcodes glTF to an internal representation for geometry so we can take advantage of the re-batching of vector data.\n    // For a list of limitations on the input glTF, see the documentation for classificationType of Cesium3DTileset.\n    content._model = new ClassificationModel({\n      gltf: gltfView,\n      cull: false, // The model is already culled by 3D Tiles\n      basePath: resource,\n      requestType: RequestType.TILES3D,\n      modelMatrix: content._contentModelMatrix,\n      upAxis: tileset._gltfUpAxis,\n      forwardAxis: Axis.X,\n      debugWireframe: tileset.debugWireframe,\n      vertexShaderLoaded: getVertexShaderCallback(content),\n      classificationShaderLoaded: getClassificationFragmentShaderCallback(\n        content\n      ),\n      uniformMapLoaded: batchTable.getUniformMapCallback(),\n      pickIdLoaded: getPickIdCallback(content),\n      classificationType: content._classificationType,\n      batchTable: batchTable,\n    });\n  }\n}\n\nfunction createFeatures(content) {\n  const featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    const features = new Array(featuresLength);\n    for (let i = 0; i < featuresLength; ++i) {\n      features[i] = new Cesium3DTileFeature(content, i);\n    }\n    content._features = features;\n  }\n}\n\nBatched3DModel3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\n\nBatched3DModel3DTileContent.prototype.getFeature = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = this.featuresLength;\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${\n        featuresLength - 1\n      }).`\n    );\n  }\n  //>>includeEnd('debug');\n\n  createFeatures(this);\n  return this._features[batchId];\n};\n\nBatched3DModel3DTileContent.prototype.applyDebugSettings = function (\n  enabled,\n  color\n) {\n  color = enabled ? color : Color.WHITE;\n  if (this.featuresLength === 0) {\n    this._model.color = color;\n  } else {\n    this._batchTable.setAllColor(color);\n  }\n};\n\nBatched3DModel3DTileContent.prototype.applyStyle = function (style) {\n  if (this.featuresLength === 0) {\n    const hasColorStyle = defined(style) && defined(style.color);\n    const hasShowStyle = defined(style) && defined(style.show);\n    this._model.color = hasColorStyle\n      ? style.color.evaluateColor(undefined, this._model.color)\n      : Color.clone(Color.WHITE, this._model.color);\n    this._model.show = hasShowStyle ? style.show.evaluate(undefined) : true;\n  } else {\n    this._batchTable.applyStyle(style);\n  }\n};\n\nBatched3DModel3DTileContent.prototype.update = function (tileset, frameState) {\n  const commandStart = frameState.commandList.length;\n\n  const model = this._model;\n  const tile = this._tile;\n  const batchTable = this._batchTable;\n\n  // In the PROCESSING state we may be calling update() to move forward\n  // the content's resource loading.  In the READY state, it will\n  // actually generate commands.\n  batchTable.update(tileset, frameState);\n\n  this._contentModelMatrix = Matrix4.multiply(\n    tile.computedTransform,\n    this._rtcCenterTransform,\n    this._contentModelMatrix\n  );\n  model.modelMatrix = this._contentModelMatrix;\n\n  model.shadows = tileset.shadows;\n  model.lightColor = tileset.lightColor;\n  model.imageBasedLighting = tileset.imageBasedLighting;\n  model.backFaceCulling = tileset.backFaceCulling;\n  model.debugWireframe = tileset.debugWireframe;\n  model.showCreditsOnScreen = tileset.showCreditsOnScreen;\n  model.splitDirection = tileset.splitDirection;\n\n  // Update clipping planes\n  const tilesetClippingPlanes = tileset.clippingPlanes;\n  model.referenceMatrix = tileset.clippingPlanesOriginMatrix;\n  if (defined(tilesetClippingPlanes) && tile.clippingPlanesDirty) {\n    // Dereference the clipping planes from the model if they are irrelevant.\n    // Link/Dereference directly to avoid ownership checks.\n    // This will also trigger synchronous shader regeneration to remove or add the clipping plane and color blending code.\n    model._clippingPlanes =\n      tilesetClippingPlanes.enabled && tile._isClipped\n        ? tilesetClippingPlanes\n        : undefined;\n  }\n\n  // If the model references a different ClippingPlaneCollection due to the tileset's collection being replaced with a\n  // ClippingPlaneCollection that gives this tile the same clipping status, update the model to use the new ClippingPlaneCollection.\n  if (\n    defined(tilesetClippingPlanes) &&\n    defined(model._clippingPlanes) &&\n    model._clippingPlanes !== tilesetClippingPlanes\n  ) {\n    model._clippingPlanes = tilesetClippingPlanes;\n  }\n\n  model.update(frameState);\n\n  // If any commands were pushed, add derived commands\n  const commandEnd = frameState.commandList.length;\n  if (\n    commandStart < commandEnd &&\n    (frameState.passes.render || frameState.passes.pick) &&\n    !defined(this._classificationType)\n  ) {\n    batchTable.addDerivedCommands(frameState, commandStart);\n  }\n};\n\nBatched3DModel3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nBatched3DModel3DTileContent.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\nexport default Batched3DModel3DTileContent;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Resource from \"../Core/Resource.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\n\n/**\n * A viewport-aligned image positioned in the 3D scene, that is created\n * and rendered using a {@link BillboardCollection}.  A billboard is created and its initial\n * properties are set by calling {@link BillboardCollection#add}.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Billboard.png' width='400' height='300' /><br />\n * Example billboards\n * </div>\n *\n * @alias Billboard\n *\n * @performance Reading a property, e.g., {@link Billboard#show}, is constant time.\n * Assigning to a property is constant time but results in\n * CPU to GPU traffic when {@link BillboardCollection#update} is called.  The per-billboard traffic is\n * the same regardless of how many properties were updated.  If most billboards in a collection need to be\n * updated, it may be more efficient to clear the collection with {@link BillboardCollection#removeAll}\n * and add new billboards instead of modifying each one.\n *\n * @exception {DeveloperError} scaleByDistance.far must be greater than scaleByDistance.near\n * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near\n * @exception {DeveloperError} pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near\n * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n *\n * @see BillboardCollection\n * @see BillboardCollection#add\n * @see Label\n *\n * @internalConstructor\n * @class\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}\n */\nfunction Billboard(options, billboardCollection) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(options.disableDepthTestDistance) &&\n    options.disableDepthTestDistance < 0.0\n  ) {\n    throw new DeveloperError(\n      \"disableDepthTestDistance must be greater than or equal to 0.0.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let translucencyByDistance = options.translucencyByDistance;\n  let pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;\n  let scaleByDistance = options.scaleByDistance;\n  let distanceDisplayCondition = options.distanceDisplayCondition;\n  if (defined(translucencyByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (translucencyByDistance.far <= translucencyByDistance.near) {\n      throw new DeveloperError(\n        \"translucencyByDistance.far must be greater than translucencyByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    translucencyByDistance = NearFarScalar.clone(translucencyByDistance);\n  }\n  if (defined(pixelOffsetScaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {\n      throw new DeveloperError(\n        \"pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    pixelOffsetScaleByDistance = NearFarScalar.clone(\n      pixelOffsetScaleByDistance\n    );\n  }\n  if (defined(scaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (scaleByDistance.far <= scaleByDistance.near) {\n      throw new DeveloperError(\n        \"scaleByDistance.far must be greater than scaleByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    scaleByDistance = NearFarScalar.clone(scaleByDistance);\n  }\n  if (defined(distanceDisplayCondition)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {\n      throw new DeveloperError(\n        \"distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    distanceDisplayCondition = DistanceDisplayCondition.clone(\n      distanceDisplayCondition\n    );\n  }\n\n  this._show = defaultValue(options.show, true);\n  this._position = Cartesian3.clone(\n    defaultValue(options.position, Cartesian3.ZERO)\n  );\n  this._actualPosition = Cartesian3.clone(this._position); // For columbus view and 2D\n  this._pixelOffset = Cartesian2.clone(\n    defaultValue(options.pixelOffset, Cartesian2.ZERO)\n  );\n  this._translate = new Cartesian2(0.0, 0.0); // used by labels for glyph vertex translation\n  this._eyeOffset = Cartesian3.clone(\n    defaultValue(options.eyeOffset, Cartesian3.ZERO)\n  );\n  this._heightReference = defaultValue(\n    options.heightReference,\n    HeightReference.NONE\n  );\n  this._verticalOrigin = defaultValue(\n    options.verticalOrigin,\n    VerticalOrigin.CENTER\n  );\n  this._horizontalOrigin = defaultValue(\n    options.horizontalOrigin,\n    HorizontalOrigin.CENTER\n  );\n  this._scale = defaultValue(options.scale, 1.0);\n  this._color = Color.clone(defaultValue(options.color, Color.WHITE));\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._alignedAxis = Cartesian3.clone(\n    defaultValue(options.alignedAxis, Cartesian3.ZERO)\n  );\n  this._width = options.width;\n  this._height = options.height;\n  this._scaleByDistance = scaleByDistance;\n  this._translucencyByDistance = translucencyByDistance;\n  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;\n  this._sizeInMeters = defaultValue(options.sizeInMeters, false);\n  this._distanceDisplayCondition = distanceDisplayCondition;\n  this._disableDepthTestDistance = options.disableDepthTestDistance;\n  this._id = options.id;\n  this._collection = defaultValue(options.collection, billboardCollection);\n\n  this._pickId = undefined;\n  this._pickPrimitive = defaultValue(options._pickPrimitive, this);\n  this._billboardCollection = billboardCollection;\n  this._dirty = false;\n  this._index = -1; //Used only by BillboardCollection\n  this._batchIndex = undefined; // Used only by Vector3DTilePoints and BillboardCollection\n\n  this._imageIndex = -1;\n  this._imageIndexPromise = undefined;\n  this._imageId = undefined;\n  this._image = undefined;\n  this._imageSubRegion = undefined;\n  this._imageWidth = undefined;\n  this._imageHeight = undefined;\n\n  this._labelDimensions = undefined;\n  this._labelHorizontalOrigin = undefined;\n  this._labelTranslate = undefined;\n\n  const image = options.image;\n  let imageId = options.imageId;\n  if (defined(image)) {\n    if (!defined(imageId)) {\n      if (typeof image === \"string\") {\n        imageId = image;\n      } else if (defined(image.src)) {\n        imageId = image.src;\n      } else {\n        imageId = createGuid();\n      }\n    }\n\n    this._imageId = imageId;\n    this._image = image;\n  }\n\n  if (defined(options.imageSubRegion)) {\n    this._imageId = imageId;\n    this._imageSubRegion = options.imageSubRegion;\n  }\n\n  if (defined(this._billboardCollection._textureAtlas)) {\n    this._loadImage();\n  }\n\n  this._actualClampedPosition = undefined;\n  this._removeCallbackFunc = undefined;\n  this._mode = SceneMode.SCENE3D;\n\n  this._clusterShow = true;\n  this._outlineColor = Color.clone(\n    defaultValue(options.outlineColor, Color.BLACK)\n  );\n  this._outlineWidth = defaultValue(options.outlineWidth, 0.0);\n\n  this._updateClamping();\n}\n\nconst SHOW_INDEX = (Billboard.SHOW_INDEX = 0);\nconst POSITION_INDEX = (Billboard.POSITION_INDEX = 1);\nconst PIXEL_OFFSET_INDEX = (Billboard.PIXEL_OFFSET_INDEX = 2);\nconst EYE_OFFSET_INDEX = (Billboard.EYE_OFFSET_INDEX = 3);\nconst HORIZONTAL_ORIGIN_INDEX = (Billboard.HORIZONTAL_ORIGIN_INDEX = 4);\nconst VERTICAL_ORIGIN_INDEX = (Billboard.VERTICAL_ORIGIN_INDEX = 5);\nconst SCALE_INDEX = (Billboard.SCALE_INDEX = 6);\nconst IMAGE_INDEX_INDEX = (Billboard.IMAGE_INDEX_INDEX = 7);\nconst COLOR_INDEX = (Billboard.COLOR_INDEX = 8);\nconst ROTATION_INDEX = (Billboard.ROTATION_INDEX = 9);\nconst ALIGNED_AXIS_INDEX = (Billboard.ALIGNED_AXIS_INDEX = 10);\nconst SCALE_BY_DISTANCE_INDEX = (Billboard.SCALE_BY_DISTANCE_INDEX = 11);\nconst TRANSLUCENCY_BY_DISTANCE_INDEX = (Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX = 12);\nconst PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = (Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = 13);\nconst DISTANCE_DISPLAY_CONDITION = (Billboard.DISTANCE_DISPLAY_CONDITION = 14);\nconst DISABLE_DEPTH_DISTANCE = (Billboard.DISABLE_DEPTH_DISTANCE = 15);\nBillboard.TEXTURE_COORDINATE_BOUNDS = 16;\nconst SDF_INDEX = (Billboard.SDF_INDEX = 17);\nBillboard.NUMBER_OF_PROPERTIES = 18;\n\nfunction makeDirty(billboard, propertyChanged) {\n  const billboardCollection = billboard._billboardCollection;\n  if (defined(billboardCollection)) {\n    billboardCollection._updateBillboard(billboard, propertyChanged);\n    billboard._dirty = true;\n  }\n}\n\nObject.defineProperties(Billboard.prototype, {\n  /**\n   * Determines if this billboard will be shown.  Use this to hide or show a billboard, instead\n   * of removing it and re-adding it to the collection.\n   * @memberof Billboard.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"value\", value);\n      //>>includeEnd('debug');\n\n      if (this._show !== value) {\n        this._show = value;\n        makeDirty(this, SHOW_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the Cartesian position of this billboard.\n   * @memberof Billboard.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug)\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n\n      const position = this._position;\n      if (!Cartesian3.equals(position, value)) {\n        Cartesian3.clone(value, position);\n        Cartesian3.clone(value, this._actualPosition);\n        this._updateClamping();\n        makeDirty(this, POSITION_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the height reference of this billboard.\n   * @memberof Billboard.prototype\n   * @type {HeightReference}\n   * @default HeightReference.NONE\n   */\n  heightReference: {\n    get: function () {\n      return this._heightReference;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug)\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n\n      const heightReference = this._heightReference;\n      if (value !== heightReference) {\n        this._heightReference = value;\n        this._updateClamping();\n        makeDirty(this, POSITION_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the pixel offset in screen space from the origin of this billboard.  This is commonly used\n   * to align multiple billboards and labels at the same position, e.g., an image and text.  The\n   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n   * left to right, and <code>y</code> increases from top to bottom.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>\n   * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>\n   * </tr></table>\n   * The billboard's origin is indicated by the yellow point.\n   * </div>\n   * @memberof Billboard.prototype\n   * @type {Cartesian2}\n   */\n  pixelOffset: {\n    get: function () {\n      return this._pixelOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n\n      const pixelOffset = this._pixelOffset;\n      if (!Cartesian2.equals(pixelOffset, value)) {\n        Cartesian2.clone(value, pixelOffset);\n        makeDirty(this, PIXEL_OFFSET_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far scaling properties of a Billboard based on the billboard's distance from the camera.\n   * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the billboard's scale remains clamped to the nearest bound.  If undefined,\n   * scaleByDistance will be disabled.\n   * @memberof Billboard.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a billboard's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the billboard and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * b.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable scaling by distance\n   * b.scaleByDistance = undefined;\n   */\n  scaleByDistance: {\n    get: function () {\n      return this._scaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value)) {\n        Check.typeOf.object(\"value\", value);\n        if (value.far <= value.near) {\n          throw new DeveloperError(\n            \"far distance must be greater than near distance.\"\n          );\n        }\n      }\n      //>>includeEnd('debug');\n\n      const scaleByDistance = this._scaleByDistance;\n      if (!NearFarScalar.equals(scaleByDistance, value)) {\n        this._scaleByDistance = NearFarScalar.clone(value, scaleByDistance);\n        makeDirty(this, SCALE_BY_DISTANCE_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far translucency properties of a Billboard based on the billboard's distance from the camera.\n   * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.  If undefined,\n   * translucencyByDistance will be disabled.\n   * @memberof Billboard.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a billboard's translucency to 1.0 when the\n   * // camera is 1500 meters from the billboard and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * b.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable translucency by distance\n   * b.translucencyByDistance = undefined;\n   */\n  translucencyByDistance: {\n    get: function () {\n      return this._translucencyByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value)) {\n        Check.typeOf.object(\"value\", value);\n        if (value.far <= value.near) {\n          throw new DeveloperError(\n            \"far distance must be greater than near distance.\"\n          );\n        }\n      }\n      //>>includeEnd('debug');\n\n      const translucencyByDistance = this._translucencyByDistance;\n      if (!NearFarScalar.equals(translucencyByDistance, value)) {\n        this._translucencyByDistance = NearFarScalar.clone(\n          value,\n          translucencyByDistance\n        );\n        makeDirty(this, TRANSLUCENCY_BY_DISTANCE_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far pixel offset scaling properties of a Billboard based on the billboard's distance from the camera.\n   * A billboard's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the billboard's pixel offset scale remains clamped to the nearest bound.  If undefined,\n   * pixelOffsetScaleByDistance will be disabled.\n   * @memberof Billboard.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a billboard's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the billboard and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * b.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * b.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable pixel offset by distance\n   * b.pixelOffsetScaleByDistance = undefined;\n   */\n  pixelOffsetScaleByDistance: {\n    get: function () {\n      return this._pixelOffsetScaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value)) {\n        Check.typeOf.object(\"value\", value);\n        if (value.far <= value.near) {\n          throw new DeveloperError(\n            \"far distance must be greater than near distance.\"\n          );\n        }\n      }\n      //>>includeEnd('debug');\n\n      const pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;\n      if (!NearFarScalar.equals(pixelOffsetScaleByDistance, value)) {\n        this._pixelOffsetScaleByDistance = NearFarScalar.clone(\n          value,\n          pixelOffsetScaleByDistance\n        );\n        makeDirty(this, PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed\n   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and\n   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,\n   * which is typically meters.\n   * <br /><br />\n   * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to\n   * arrange a billboard above its corresponding 3D model.\n   * <br /><br />\n   * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always\n   * appear on top of the Earth regardless of the viewer's or Earth's orientation.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>\n   * </tr></table>\n   * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />\n   * </div>\n   * @memberof Billboard.prototype\n   * @type {Cartesian3}\n   */\n  eyeOffset: {\n    get: function () {\n      return this._eyeOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n\n      const eyeOffset = this._eyeOffset;\n      if (!Cartesian3.equals(eyeOffset, value)) {\n        Cartesian3.clone(value, eyeOffset);\n        makeDirty(this, EYE_OFFSET_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the horizontal origin of this billboard, which determines if the billboard is\n   * to the left, center, or right of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />\n   * </div>\n   * @memberof Billboard.prototype\n   * @type {HorizontalOrigin}\n   * @example\n   * // Use a bottom, left origin\n   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;\n   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;\n   */\n  horizontalOrigin: {\n    get: function () {\n      return this._horizontalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n\n      if (this._horizontalOrigin !== value) {\n        this._horizontalOrigin = value;\n        makeDirty(this, HORIZONTAL_ORIGIN_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the vertical origin of this billboard, which determines if the billboard is\n   * to the above, below, or at the center of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />\n   * </div>\n   * @memberof Billboard.prototype\n   * @type {VerticalOrigin}\n   * @example\n   * // Use a bottom, left origin\n   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;\n   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;\n   */\n  verticalOrigin: {\n    get: function () {\n      return this._verticalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n\n      if (this._verticalOrigin !== value) {\n        this._verticalOrigin = value;\n        makeDirty(this, VERTICAL_ORIGIN_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the uniform scale that is multiplied with the billboard's image size in pixels.\n   * A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than\n   * <code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks\n   * the billboard.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>\n   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,\n   * and <code>2.0</code>.\n   * </div>\n   * @memberof Billboard.prototype\n   * @type {Number}\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n\n      if (this._scale !== value) {\n        this._scale = value;\n        makeDirty(this, SCALE_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,\n   * the same white texture may be used by many different billboards, each with a different color, to create\n   * colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.\n   * An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>\n   * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>\n   * </tr></table>\n   * </div>\n   * <br />\n   * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,\n   * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>\n   * (no intensity) to <code>1.0</code> (full intensity).\n   * @memberof Billboard.prototype\n   * @type {Color}\n   *\n   * @example\n   * // Example 1. Assign yellow.\n   * b.color = Cesium.Color.YELLOW;\n   *\n   * @example\n   * // Example 2. Make a billboard 50% translucent.\n   * b.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);\n   */\n  color: {\n    get: function () {\n      return this._color;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n\n      const color = this._color;\n      if (!Color.equals(color, value)) {\n        Color.clone(value, color);\n        makeDirty(this, COLOR_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the rotation angle in radians.\n   * @memberof Billboard.prototype\n   * @type {Number}\n   */\n  rotation: {\n    get: function () {\n      return this._rotation;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number(\"value\", value);\n      //>>includeEnd('debug');\n\n      if (this._rotation !== value) {\n        this._rotation = value;\n        makeDirty(this, ROTATION_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the aligned axis in world space. The aligned axis is the unit vector that the billboard up vector points towards.\n   * The default is the zero vector, which means the billboard is aligned to the screen up vector.\n   * @memberof Billboard.prototype\n   * @type {Cartesian3}\n   * @example\n   * // Example 1.\n   * // Have the billboard up vector point north\n   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;\n   *\n   * @example\n   * // Example 2.\n   * // Have the billboard point east.\n   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;\n   * billboard.rotation = -Cesium.Math.PI_OVER_TWO;\n   *\n   * @example\n   * // Example 3.\n   * // Reset the aligned axis\n   * billboard.alignedAxis = Cesium.Cartesian3.ZERO;\n   */\n  alignedAxis: {\n    get: function () {\n      return this._alignedAxis;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      //>>includeEnd('debug');\n\n      const alignedAxis = this._alignedAxis;\n      if (!Cartesian3.equals(alignedAxis, value)) {\n        Cartesian3.clone(value, alignedAxis);\n        makeDirty(this, ALIGNED_AXIS_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets a width for the billboard. If undefined, the image width will be used.\n   * @memberof Billboard.prototype\n   * @type {Number}\n   */\n  width: {\n    get: function () {\n      return defaultValue(this._width, this._imageWidth);\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value)) {\n        Check.typeOf.number(\"value\", value);\n      }\n      //>>includeEnd('debug');\n      if (this._width !== value) {\n        this._width = value;\n        makeDirty(this, IMAGE_INDEX_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets a height for the billboard. If undefined, the image height will be used.\n   * @memberof Billboard.prototype\n   * @type {Number}\n   */\n  height: {\n    get: function () {\n      return defaultValue(this._height, this._imageHeight);\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value)) {\n        Check.typeOf.number(\"value\", value);\n      }\n      //>>includeEnd('debug');\n      if (this._height !== value) {\n        this._height = value;\n        makeDirty(this, IMAGE_INDEX_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets if the billboard size is in meters or pixels. <code>true</code> to size the billboard in meters;\n   * otherwise, the size is in pixels.\n   * @memberof Billboard.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  sizeInMeters: {\n    get: function () {\n      return this._sizeInMeters;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"value\", value);\n      //>>includeEnd('debug');\n      if (this._sizeInMeters !== value) {\n        this._sizeInMeters = value;\n        makeDirty(this, COLOR_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this billboard will be displayed.\n   * @memberof Billboard.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      if (\n        !DistanceDisplayCondition.equals(value, this._distanceDisplayCondition)\n      ) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(value)) {\n          Check.typeOf.object(\"value\", value);\n          if (value.far <= value.near) {\n            throw new DeveloperError(\n              \"far distance must be greater than near distance.\"\n            );\n          }\n        }\n        //>>includeEnd('debug');\n        this._distanceDisplayCondition = DistanceDisplayCondition.clone(\n          value,\n          this._distanceDisplayCondition\n        );\n        makeDirty(this, DISTANCE_DISPLAY_CONDITION);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.\n   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.\n   * @memberof Billboard.prototype\n   * @type {Number}\n   */\n  disableDepthTestDistance: {\n    get: function () {\n      return this._disableDepthTestDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value)) {\n        Check.typeOf.number(\"value\", value);\n        if (value < 0.0) {\n          throw new DeveloperError(\n            \"disableDepthTestDistance must be greater than or equal to 0.0.\"\n          );\n        }\n      }\n      //>>includeEnd('debug');\n      if (this._disableDepthTestDistance !== value) {\n        this._disableDepthTestDistance = value;\n        makeDirty(this, DISABLE_DEPTH_DISTANCE);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the user-defined object returned when the billboard is picked.\n   * @memberof Billboard.prototype\n   * @type {Object}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n    set: function (value) {\n      this._id = value;\n      if (defined(this._pickId)) {\n        this._pickId.object.id = value;\n      }\n    },\n  },\n\n  /**\n   * The primitive to return when picking this billboard.\n   * @memberof Billboard.prototype\n   * @private\n   */\n  pickPrimitive: {\n    get: function () {\n      return this._pickPrimitive;\n    },\n    set: function (value) {\n      this._pickPrimitive = value;\n      if (defined(this._pickId)) {\n        this._pickId.object.primitive = value;\n      }\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickId: {\n    get: function () {\n      return this._pickId;\n    },\n  },\n\n  /**\n   * <p>\n   * Gets or sets the image to be used for this billboard.  If a texture has already been created for the\n   * given image, the existing texture is used.\n   * </p>\n   * <p>\n   * This property can be set to a loaded Image, a URL which will be loaded as an Image automatically,\n   * a canvas, or another billboard's image property (from the same billboard collection).\n   * </p>\n   *\n   * @memberof Billboard.prototype\n   * @type {String}\n   * @example\n   * // load an image from a URL\n   * b.image = 'some/image/url.png';\n   *\n   * // assuming b1 and b2 are billboards in the same billboard collection,\n   * // use the same image for both billboards.\n   * b2.image = b1.image;\n   */\n  image: {\n    get: function () {\n      return this._imageId;\n    },\n    set: function (value) {\n      if (!defined(value)) {\n        this._imageIndex = -1;\n        this._imageSubRegion = undefined;\n        this._imageId = undefined;\n        this._image = undefined;\n        this._imageIndexPromise = undefined;\n        makeDirty(this, IMAGE_INDEX_INDEX);\n      } else if (typeof value === \"string\") {\n        this.setImage(value, value);\n      } else if (value instanceof Resource) {\n        this.setImage(value.url, value);\n      } else if (defined(value.src)) {\n        this.setImage(value.src, value);\n      } else {\n        this.setImage(createGuid(), value);\n      }\n    },\n  },\n\n  /**\n   * When <code>true</code>, this billboard is ready to render, i.e., the image\n   * has been downloaded and the WebGL resources are created.\n   *\n   * @memberof Billboard.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  ready: {\n    get: function () {\n      return this._imageIndex !== -1;\n    },\n  },\n\n  /**\n   * Keeps track of the position of the billboard based on the height reference.\n   * @memberof Billboard.prototype\n   * @type {Cartesian3}\n   * @private\n   */\n  _clampedPosition: {\n    get: function () {\n      return this._actualClampedPosition;\n    },\n    set: function (value) {\n      this._actualClampedPosition = Cartesian3.clone(\n        value,\n        this._actualClampedPosition\n      );\n      makeDirty(this, POSITION_INDEX);\n    },\n  },\n\n  /**\n   * Determines whether or not this billboard will be shown or hidden because it was clustered.\n   * @memberof Billboard.prototype\n   * @type {Boolean}\n   * @private\n   */\n  clusterShow: {\n    get: function () {\n      return this._clusterShow;\n    },\n    set: function (value) {\n      if (this._clusterShow !== value) {\n        this._clusterShow = value;\n        makeDirty(this, SHOW_INDEX);\n      }\n    },\n  },\n\n  /**\n   * The outline color of this Billboard.  Effective only for SDF billboards like Label glyphs.\n   * @memberof Billboard.prototype\n   * @type {Color}\n   * @private\n   */\n  outlineColor: {\n    get: function () {\n      return this._outlineColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const outlineColor = this._outlineColor;\n      if (!Color.equals(outlineColor, value)) {\n        Color.clone(value, outlineColor);\n        makeDirty(this, SDF_INDEX);\n      }\n    },\n  },\n\n  /**\n   * The outline width of this Billboard in pixels.  Effective only for SDF billboards like Label glyphs.\n   * @memberof Billboard.prototype\n   * @type {Number}\n   * @private\n   */\n  outlineWidth: {\n    get: function () {\n      return this._outlineWidth;\n    },\n    set: function (value) {\n      if (this._outlineWidth !== value) {\n        this._outlineWidth = value;\n        makeDirty(this, SDF_INDEX);\n      }\n    },\n  },\n});\n\nBillboard.prototype.getPickId = function (context) {\n  if (!defined(this._pickId)) {\n    this._pickId = context.createPickId({\n      primitive: this._pickPrimitive,\n      collection: this._collection,\n      id: this._id,\n    });\n  }\n\n  return this._pickId;\n};\n\nBillboard.prototype._updateClamping = function () {\n  Billboard._updateClamping(this._billboardCollection, this);\n};\n\nconst scratchCartographic = new Cartographic();\nconst scratchPosition = new Cartesian3();\n\nBillboard._updateClamping = function (collection, owner) {\n  const scene = collection._scene;\n  if (!defined(scene) || !defined(scene.globe)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (owner._heightReference !== HeightReference.NONE) {\n      throw new DeveloperError(\n        \"Height reference is not supported without a scene and globe.\"\n      );\n    }\n    //>>includeEnd('debug');\n    return;\n  }\n\n  const globe = scene.globe;\n  const ellipsoid = globe.ellipsoid;\n  const surface = globe._surface;\n\n  const mode = scene.frameState.mode;\n\n  const modeChanged = mode !== owner._mode;\n  owner._mode = mode;\n\n  if (\n    (owner._heightReference === HeightReference.NONE || modeChanged) &&\n    defined(owner._removeCallbackFunc)\n  ) {\n    owner._removeCallbackFunc();\n    owner._removeCallbackFunc = undefined;\n    owner._clampedPosition = undefined;\n  }\n\n  if (\n    owner._heightReference === HeightReference.NONE ||\n    !defined(owner._position)\n  ) {\n    return;\n  }\n\n  const position = ellipsoid.cartesianToCartographic(owner._position);\n  if (!defined(position)) {\n    owner._actualClampedPosition = undefined;\n    return;\n  }\n\n  if (defined(owner._removeCallbackFunc)) {\n    owner._removeCallbackFunc();\n  }\n\n  function updateFunction(clampedPosition) {\n    if (owner._heightReference === HeightReference.RELATIVE_TO_GROUND) {\n      if (owner._mode === SceneMode.SCENE3D) {\n        const clampedCart = ellipsoid.cartesianToCartographic(\n          clampedPosition,\n          scratchCartographic\n        );\n        clampedCart.height += position.height;\n        ellipsoid.cartographicToCartesian(clampedCart, clampedPosition);\n      } else {\n        clampedPosition.x += position.height;\n      }\n    }\n    owner._clampedPosition = Cartesian3.clone(\n      clampedPosition,\n      owner._clampedPosition\n    );\n  }\n  owner._removeCallbackFunc = surface.updateHeight(position, updateFunction);\n\n  Cartographic.clone(position, scratchCartographic);\n  const height = globe.getHeight(position);\n  if (defined(height)) {\n    scratchCartographic.height = height;\n  }\n\n  ellipsoid.cartographicToCartesian(scratchCartographic, scratchPosition);\n\n  updateFunction(scratchPosition);\n};\n\nBillboard.prototype._loadImage = function () {\n  const atlas = this._billboardCollection._textureAtlas;\n\n  const imageId = this._imageId;\n  const image = this._image;\n  const imageSubRegion = this._imageSubRegion;\n  let imageIndexPromise;\n\n  const that = this;\n  function completeImageLoad(index) {\n    if (\n      that._imageId !== imageId ||\n      that._image !== image ||\n      !BoundingRectangle.equals(that._imageSubRegion, imageSubRegion)\n    ) {\n      // another load occurred before this one finished, ignore the index\n      return;\n    }\n\n    // fill in imageWidth and imageHeight\n    const textureCoordinates = atlas.textureCoordinates[index];\n    that._imageWidth = atlas.texture.width * textureCoordinates.width;\n    that._imageHeight = atlas.texture.height * textureCoordinates.height;\n\n    that._imageIndex = index;\n    that._ready = true;\n    that._image = undefined;\n    that._imageIndexPromise = undefined;\n    makeDirty(that, IMAGE_INDEX_INDEX);\n  }\n\n  if (defined(image)) {\n    // No need to wait on imageIndexPromise since these have already been added to the atlas\n    const index = atlas.getImageIndex(imageId);\n    if (defined(index)) {\n      completeImageLoad(index);\n      return;\n    }\n\n    imageIndexPromise = atlas.addImage(imageId, image);\n  }\n  if (defined(imageSubRegion)) {\n    imageIndexPromise = atlas.addSubRegion(imageId, imageSubRegion);\n  }\n\n  this._imageIndexPromise = imageIndexPromise;\n\n  if (!defined(imageIndexPromise)) {\n    return;\n  }\n\n  imageIndexPromise.then(completeImageLoad).catch(function (error) {\n    console.error(`Error loading image for billboard: ${error}`);\n    that._imageIndexPromise = undefined;\n  });\n};\n\n/**\n * <p>\n * Sets the image to be used for this billboard.  If a texture has already been created for the\n * given id, the existing texture is used.\n * </p>\n * <p>\n * This function is useful for dynamically creating textures that are shared across many billboards.\n * Only the first billboard will actually call the function and create the texture, while subsequent\n * billboards created with the same id will simply re-use the existing texture.\n * </p>\n * <p>\n * To load an image from a URL, setting the {@link Billboard#image} property is more convenient.\n * </p>\n *\n * @param {String} id The id of the image.  This can be any string that uniquely identifies the image.\n * @param {HTMLImageElement|HTMLCanvasElement|String|Resource|Billboard.CreateImageCallback} image The image to load.  This parameter\n *        can either be a loaded Image or Canvas, a URL which will be loaded as an Image automatically,\n *        or a function which will be called to create the image if it hasn't been loaded already.\n * @example\n * // create a billboard image dynamically\n * function drawImage(id) {\n *   // create and draw an image using a canvas\n *   const canvas = document.createElement('canvas');\n *   const context2D = canvas.getContext('2d');\n *   // ... draw image\n *   return canvas;\n * }\n * // drawImage will be called to create the texture\n * b.setImage('myImage', drawImage);\n *\n * // subsequent billboards created in the same collection using the same id will use the existing\n * // texture, without the need to create the canvas or draw the image\n * b2.setImage('myImage', drawImage);\n */\nBillboard.prototype.setImage = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(image)) {\n    throw new DeveloperError(\"image is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (this._imageId === id) {\n    return;\n  }\n\n  this._imageIndex = -1;\n  this._imageSubRegion = undefined;\n  this._imageId = id;\n  this._image = image;\n\n  if (defined(this._billboardCollection._textureAtlas)) {\n    this._loadImage();\n  }\n};\n\n/**\n * Uses a sub-region of the image with the given id as the image for this billboard,\n * measured in pixels from the bottom-left.\n *\n * @param {String} id The id of the image to use.\n * @param {BoundingRectangle} subRegion The sub-region of the image.\n *\n * @exception {RuntimeError} image with id must be in the atlas\n */\nBillboard.prototype.setImageSubRegion = function (id, subRegion) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(subRegion)) {\n    throw new DeveloperError(\"subRegion is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (\n    this._imageId === id &&\n    BoundingRectangle.equals(this._imageSubRegion, subRegion)\n  ) {\n    return;\n  }\n\n  this._imageIndex = -1;\n  this._imageId = id;\n  this._imageSubRegion = BoundingRectangle.clone(subRegion);\n\n  if (defined(this._billboardCollection._textureAtlas)) {\n    this._loadImage();\n  }\n};\n\nBillboard.prototype._setTranslate = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const translate = this._translate;\n  if (!Cartesian2.equals(translate, value)) {\n    Cartesian2.clone(value, translate);\n    makeDirty(this, PIXEL_OFFSET_INDEX);\n  }\n};\n\nBillboard.prototype._getActualPosition = function () {\n  return defined(this._clampedPosition)\n    ? this._clampedPosition\n    : this._actualPosition;\n};\n\nBillboard.prototype._setActualPosition = function (value) {\n  if (!defined(this._clampedPosition)) {\n    Cartesian3.clone(value, this._actualPosition);\n  }\n  makeDirty(this, POSITION_INDEX);\n};\n\nconst tempCartesian3 = new Cartesian4();\nBillboard._computeActualPosition = function (\n  billboard,\n  position,\n  frameState,\n  modelMatrix\n) {\n  if (defined(billboard._clampedPosition)) {\n    if (frameState.mode !== billboard._mode) {\n      billboard._updateClamping();\n    }\n    return billboard._clampedPosition;\n  } else if (frameState.mode === SceneMode.SCENE3D) {\n    return position;\n  }\n\n  Matrix4.multiplyByPoint(modelMatrix, position, tempCartesian3);\n  return SceneTransforms.computeActualWgs84Position(frameState, tempCartesian3);\n};\n\nconst scratchCartesian3 = new Cartesian3();\n\n// This function is basically a stripped-down JavaScript version of BillboardCollectionVS.glsl\nBillboard._computeScreenSpacePosition = function (\n  modelMatrix,\n  position,\n  eyeOffset,\n  pixelOffset,\n  scene,\n  result\n) {\n  // Model to world coordinates\n  const positionWorld = Matrix4.multiplyByPoint(\n    modelMatrix,\n    position,\n    scratchCartesian3\n  );\n\n  // World to window coordinates\n  const positionWC = SceneTransforms.wgs84WithEyeOffsetToWindowCoordinates(\n    scene,\n    positionWorld,\n    eyeOffset,\n    result\n  );\n  if (!defined(positionWC)) {\n    return undefined;\n  }\n\n  // Apply pixel offset\n  Cartesian2.add(positionWC, pixelOffset, positionWC);\n\n  return positionWC;\n};\n\nconst scratchPixelOffset = new Cartesian2(0.0, 0.0);\n\n/**\n * Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.\n * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n * left to right, and <code>y</code> increases from top to bottom.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The screen-space position of the billboard.\n *\n * @exception {DeveloperError} Billboard must be in a collection.\n *\n * @example\n * console.log(b.computeScreenSpacePosition(scene).toString());\n *\n * @see Billboard#eyeOffset\n * @see Billboard#pixelOffset\n */\nBillboard.prototype.computeScreenSpacePosition = function (scene, result) {\n  const billboardCollection = this._billboardCollection;\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(billboardCollection)) {\n    throw new DeveloperError(\n      \"Billboard must be in a collection.  Was it removed?\"\n    );\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // pixel offset for screen space computation is the pixelOffset + screen space translate\n  Cartesian2.clone(this._pixelOffset, scratchPixelOffset);\n  Cartesian2.add(scratchPixelOffset, this._translate, scratchPixelOffset);\n\n  let modelMatrix = billboardCollection.modelMatrix;\n  let position = this._position;\n  if (defined(this._clampedPosition)) {\n    position = this._clampedPosition;\n    if (scene.mode !== SceneMode.SCENE3D) {\n      // position needs to be in world coordinates\n      const projection = scene.mapProjection;\n      const ellipsoid = projection.ellipsoid;\n      const cart = projection.unproject(position, scratchCartographic);\n      position = ellipsoid.cartographicToCartesian(cart, scratchCartesian3);\n      modelMatrix = Matrix4.IDENTITY;\n    }\n  }\n\n  const windowCoordinates = Billboard._computeScreenSpacePosition(\n    modelMatrix,\n    position,\n    this._eyeOffset,\n    scratchPixelOffset,\n    scene,\n    result\n  );\n  return windowCoordinates;\n};\n\n/**\n * Gets a billboard's screen space bounding box centered around screenSpacePosition.\n * @param {Billboard} billboard The billboard to get the screen space bounding box for.\n * @param {Cartesian2} screenSpacePosition The screen space center of the label.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The screen space bounding box.\n *\n * @private\n */\nBillboard.getScreenSpaceBoundingBox = function (\n  billboard,\n  screenSpacePosition,\n  result\n) {\n  let width = billboard.width;\n  let height = billboard.height;\n\n  const scale = billboard.scale;\n  width *= scale;\n  height *= scale;\n\n  let x = screenSpacePosition.x;\n  if (billboard.horizontalOrigin === HorizontalOrigin.RIGHT) {\n    x -= width;\n  } else if (billboard.horizontalOrigin === HorizontalOrigin.CENTER) {\n    x -= width * 0.5;\n  }\n\n  let y = screenSpacePosition.y;\n  if (\n    billboard.verticalOrigin === VerticalOrigin.BOTTOM ||\n    billboard.verticalOrigin === VerticalOrigin.BASELINE\n  ) {\n    y -= height;\n  } else if (billboard.verticalOrigin === VerticalOrigin.CENTER) {\n    y -= height * 0.5;\n  }\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  result.x = x;\n  result.y = y;\n  result.width = width;\n  result.height = height;\n\n  return result;\n};\n\n/**\n * Determines if this billboard equals another billboard.  Billboards are equal if all their properties\n * are equal.  Billboards in different collections can be equal.\n *\n * @param {Billboard} other The billboard to compare for equality.\n * @returns {Boolean} <code>true</code> if the billboards are equal; otherwise, <code>false</code>.\n */\nBillboard.prototype.equals = function (other) {\n  return (\n    this === other ||\n    (defined(other) &&\n      this._id === other._id &&\n      Cartesian3.equals(this._position, other._position) &&\n      this._imageId === other._imageId &&\n      this._show === other._show &&\n      this._scale === other._scale &&\n      this._verticalOrigin === other._verticalOrigin &&\n      this._horizontalOrigin === other._horizontalOrigin &&\n      this._heightReference === other._heightReference &&\n      BoundingRectangle.equals(this._imageSubRegion, other._imageSubRegion) &&\n      Color.equals(this._color, other._color) &&\n      Cartesian2.equals(this._pixelOffset, other._pixelOffset) &&\n      Cartesian2.equals(this._translate, other._translate) &&\n      Cartesian3.equals(this._eyeOffset, other._eyeOffset) &&\n      NearFarScalar.equals(this._scaleByDistance, other._scaleByDistance) &&\n      NearFarScalar.equals(\n        this._translucencyByDistance,\n        other._translucencyByDistance\n      ) &&\n      NearFarScalar.equals(\n        this._pixelOffsetScaleByDistance,\n        other._pixelOffsetScaleByDistance\n      ) &&\n      DistanceDisplayCondition.equals(\n        this._distanceDisplayCondition,\n        other._distanceDisplayCondition\n      ) &&\n      this._disableDepthTestDistance === other._disableDepthTestDistance)\n  );\n};\n\nBillboard.prototype._destroy = function () {\n  if (defined(this._customData)) {\n    this._billboardCollection._scene.globe._surface.removeTileCustomData(\n      this._customData\n    );\n    this._customData = undefined;\n  }\n\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n    this._removeCallbackFunc = undefined;\n  }\n\n  this.image = undefined;\n  this._pickId = this._pickId && this._pickId.destroy();\n  this._billboardCollection = undefined;\n};\n\n/**\n * A function that creates an image.\n * @callback Billboard.CreateImageCallback\n * @param {String} id The identifier of the image to load.\n * @returns {HTMLImageElement|HTMLCanvasElement|Promise<HTMLImageElement|HTMLCanvasElement>} The image, or a promise that will resolve to an image.\n */\nexport default Billboard;\n","import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport BillboardCollectionFS from \"../Shaders/BillboardCollectionFS.js\";\nimport BillboardCollectionVS from \"../Shaders/BillboardCollectionVS.js\";\nimport Billboard from \"./Billboard.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"./TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\n\nconst SHOW_INDEX = Billboard.SHOW_INDEX;\nconst POSITION_INDEX = Billboard.POSITION_INDEX;\nconst PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;\nconst EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;\nconst HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;\nconst VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;\nconst SCALE_INDEX = Billboard.SCALE_INDEX;\nconst IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;\nconst COLOR_INDEX = Billboard.COLOR_INDEX;\nconst ROTATION_INDEX = Billboard.ROTATION_INDEX;\nconst ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX;\nconst SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX;\nconst TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX;\nconst PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX =\n  Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION_INDEX = Billboard.DISTANCE_DISPLAY_CONDITION;\nconst DISABLE_DEPTH_DISTANCE = Billboard.DISABLE_DEPTH_DISTANCE;\nconst TEXTURE_COORDINATE_BOUNDS = Billboard.TEXTURE_COORDINATE_BOUNDS;\nconst SDF_INDEX = Billboard.SDF_INDEX;\nconst NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;\n\nlet attributeLocations;\n\nconst attributeLocationsBatched = {\n  positionHighAndScale: 0,\n  positionLowAndRotation: 1,\n  compressedAttribute0: 2, // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates\n  compressedAttribute1: 3, // aligned axis, translucency by distance, image width\n  compressedAttribute2: 4, // image height, color, pick color, size in meters, valid aligned axis, 13 bits free\n  eyeOffset: 5, // 4 bytes free\n  scaleByDistance: 6,\n  pixelOffsetScaleByDistance: 7,\n  compressedAttribute3: 8,\n  textureCoordinateBoundsOrLabelTranslate: 9,\n  a_batchId: 10,\n  sdf: 11,\n};\n\nconst attributeLocationsInstanced = {\n  direction: 0,\n  positionHighAndScale: 1,\n  positionLowAndRotation: 2, // texture offset in w\n  compressedAttribute0: 3,\n  compressedAttribute1: 4,\n  compressedAttribute2: 5,\n  eyeOffset: 6, // texture range in w\n  scaleByDistance: 7,\n  pixelOffsetScaleByDistance: 8,\n  compressedAttribute3: 9,\n  textureCoordinateBoundsOrLabelTranslate: 10,\n  a_batchId: 11,\n  sdf: 12,\n};\n\n/**\n * A renderable collection of billboards.  Billboards are viewport-aligned\n * images positioned in the 3D scene.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Billboard.png' width='400' height='300' /><br />\n * Example billboards\n * </div>\n * <br /><br />\n * Billboards are added and removed from the collection using {@link BillboardCollection#add}\n * and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures\n * for images with the same identifier.\n *\n * @alias BillboardCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each billboard from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for billboards that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The billboard blending option. The default\n * is used for rendering both opaque and translucent billboards. However, if either all of the billboards are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {Boolean} [options.show=true] Determines if the billboards in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many billboards, to\n * many collections with only a few billboards each.  Organize collections so that billboards\n * with the same update frequency are in the same collection, i.e., billboards that do not\n * change should be in one collection; billboards that change every frame should be in another\n * collection; and so on.\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n * @see Billboard\n * @see LabelCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}\n *\n * @example\n * // Create a billboard collection with two billboards\n * const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * billboards.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   image : 'url/to/image'\n * });\n * billboards.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   image : 'url/to/another/image'\n * });\n */\nfunction BillboardCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n\n  this._textureAtlas = undefined;\n  this._textureAtlasGUID = undefined;\n  this._destroyTextureAtlas = true;\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n  this._createVertexArray = false;\n\n  this._shaderRotation = false;\n  this._compiledShaderRotation = false;\n\n  this._shaderAlignedAxis = false;\n  this._compiledShaderAlignedAxis = false;\n\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n\n  this._shaderPixelOffsetScaleByDistance = false;\n  this._compiledShaderPixelOffsetScaleByDistance = false;\n\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n\n  this._shaderClampToGround = false;\n  this._compiledShaderClampToGround = false;\n\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n\n  this._maxSize = 0.0;\n  this._maxEyeOffset = 0.0;\n  this._maxScale = 1.0;\n  this._maxPixelOffset = 0.0;\n  this._allHorizontalCenter = true;\n  this._allVerticalCenter = true;\n  this._allSizedInMeters = true;\n\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n\n  this._colorCommands = [];\n\n  /**\n   * Determines if billboards in this collection will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.\n   * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * billboards.add({\n   *   image : 'url/to/image',\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the texture atlas for this BillboardCollection as a fullscreen quad.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowTextureAtlas = defaultValue(\n    options.debugShowTextureAtlas,\n    false\n  );\n\n  /**\n   * The billboard blending option. The default is used for rendering both opaque and translucent billboards.\n   * However, if either all of the billboards are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = defaultValue(\n    options.blendOption,\n    BlendOption.OPAQUE_AND_TRANSLUCENT\n  );\n  this._blendOption = undefined;\n\n  this._mode = SceneMode.SCENE3D;\n\n  // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n  this._buffersUsage = [\n    BufferUsage.STATIC_DRAW, // SHOW_INDEX\n    BufferUsage.STATIC_DRAW, // POSITION_INDEX\n    BufferUsage.STATIC_DRAW, // PIXEL_OFFSET_INDEX\n    BufferUsage.STATIC_DRAW, // EYE_OFFSET_INDEX\n    BufferUsage.STATIC_DRAW, // HORIZONTAL_ORIGIN_INDEX\n    BufferUsage.STATIC_DRAW, // VERTICAL_ORIGIN_INDEX\n    BufferUsage.STATIC_DRAW, // SCALE_INDEX\n    BufferUsage.STATIC_DRAW, // IMAGE_INDEX_INDEX\n    BufferUsage.STATIC_DRAW, // COLOR_INDEX\n    BufferUsage.STATIC_DRAW, // ROTATION_INDEX\n    BufferUsage.STATIC_DRAW, // ALIGNED_AXIS_INDEX\n    BufferUsage.STATIC_DRAW, // SCALE_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // TRANSLUCENCY_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // DISTANCE_DISPLAY_CONDITION_INDEX\n    BufferUsage.STATIC_DRAW, // TEXTURE_COORDINATE_BOUNDS\n  ];\n\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  const that = this;\n  this._uniforms = {\n    u_atlas: function () {\n      return that._textureAtlas.texture;\n    },\n    u_highlightColor: function () {\n      return that._highlightColor;\n    },\n  };\n\n  const scene = this._scene;\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._removeCallbackFunc = scene.terrainProviderChanged.addEventListener(\n      function () {\n        const billboards = this._billboards;\n        const length = billboards.length;\n        for (let i = 0; i < length; ++i) {\n          if (defined(billboards[i])) {\n            billboards[i]._updateClamping();\n          }\n        }\n      },\n      this\n    );\n  }\n}\n\nObject.defineProperties(BillboardCollection.prototype, {\n  /**\n   * Returns the number of billboards in this collection.  This is commonly used with\n   * {@link BillboardCollection#get} to iterate over all the billboards\n   * in the collection.\n   * @memberof BillboardCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      removeBillboards(this);\n      return this._billboards.length;\n    },\n  },\n\n  /**\n   * Gets or sets the textureAtlas.\n   * @memberof BillboardCollection.prototype\n   * @type {TextureAtlas}\n   * @private\n   */\n  textureAtlas: {\n    get: function () {\n      return this._textureAtlas;\n    },\n    set: function (value) {\n      if (this._textureAtlas !== value) {\n        this._textureAtlas =\n          this._destroyTextureAtlas &&\n          this._textureAtlas &&\n          this._textureAtlas.destroy();\n        this._textureAtlas = value;\n        this._createVertexArray = true; // New per-billboard texture coordinates\n      }\n    },\n  },\n\n  /**\n   * Gets or sets a value which determines if the texture atlas is\n   * destroyed when the collection is destroyed.\n   *\n   * If the texture atlas is used by more than one collection, set this to <code>false</code>,\n   * and explicitly destroy the atlas to avoid attempting to destroy it multiple times.\n   *\n   * @memberof BillboardCollection.prototype\n   * @type {Boolean}\n   * @private\n   *\n   * @example\n   * // Set destroyTextureAtlas\n   * // Destroy a billboard collection but not its texture atlas.\n   *\n   * const atlas = new TextureAtlas({\n   *   scene : scene,\n   *   images : images\n   * });\n   * billboards.textureAtlas = atlas;\n   * billboards.destroyTextureAtlas = false;\n   * billboards = billboards.destroy();\n   * console.log(atlas.isDestroyed()); // False\n   */\n  destroyTextureAtlas: {\n    get: function () {\n      return this._destroyTextureAtlas;\n    },\n    set: function (value) {\n      this._destroyTextureAtlas = value;\n    },\n  },\n});\n\nfunction destroyBillboards(billboards) {\n  const length = billboards.length;\n  for (let i = 0; i < length; ++i) {\n    if (billboards[i]) {\n      billboards[i]._destroy();\n    }\n  }\n}\n\n/**\n * Creates and adds a billboard with the specified initial properties to the collection.\n * The added billboard is returned so it can be modified or removed from the collection later.\n *\n * @param {Object}[options] A template describing the billboard's properties as shown in Example 1.\n * @returns {Billboard} The billboard that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many billboards as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a billboard, specifying all the default values.\n * const b = billboards.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   heightReference : Cesium.HeightReference.NONE,\n *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,\n *   verticalOrigin : Cesium.VerticalOrigin.CENTER,\n *   scale : 1.0,\n *   image : 'url/to/image',\n *   imageSubRegion : undefined,\n *   color : Cesium.Color.WHITE,\n *   id : undefined,\n *   rotation : 0.0,\n *   alignedAxis : Cesium.Cartesian3.ZERO,\n *   width : undefined,\n *   height : undefined,\n *   scaleByDistance : undefined,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   sizeInMeters : false,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the billboard's cartographic position.\n * const b = billboards.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see BillboardCollection#remove\n * @see BillboardCollection#removeAll\n */\nBillboardCollection.prototype.add = function (options) {\n  const billboard = new Billboard(options, this);\n  billboard._index = this._billboards.length;\n\n  this._billboards.push(billboard);\n  this._createVertexArray = true;\n\n  return billboard;\n};\n\n/**\n * Removes a billboard from the collection.\n *\n * @param {Billboard} billboard The billboard to remove.\n * @returns {Boolean} <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many billboards as possible before calling <code>update</code>.\n * If you intend to temporarily hide a billboard, it is usually more efficient to call\n * {@link Billboard#show} instead of removing and re-adding the billboard.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const b = billboards.add(...);\n * billboards.remove(b);  // Returns true\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#removeAll\n * @see Billboard#show\n */\nBillboardCollection.prototype.remove = function (billboard) {\n  if (this.contains(billboard)) {\n    this._billboards[billboard._index] = undefined; // Removed later\n    this._billboardsRemoved = true;\n    this._createVertexArray = true;\n    billboard._destroy();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all billboards from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the billboards\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards.add(...);\n * billboards.add(...);\n * billboards.removeAll();\n *\n * @see BillboardCollection#add\n * @see BillboardCollection#remove\n */\nBillboardCollection.prototype.removeAll = function () {\n  destroyBillboards(this._billboards);\n  this._billboards = [];\n  this._billboardsToUpdate = [];\n  this._billboardsToUpdateIndex = 0;\n  this._billboardsRemoved = false;\n\n  this._createVertexArray = true;\n};\n\nfunction removeBillboards(billboardCollection) {\n  if (billboardCollection._billboardsRemoved) {\n    billboardCollection._billboardsRemoved = false;\n\n    const newBillboards = [];\n    const billboards = billboardCollection._billboards;\n    const length = billboards.length;\n    for (let i = 0, j = 0; i < length; ++i) {\n      const billboard = billboards[i];\n      if (defined(billboard)) {\n        billboard._index = j++;\n        newBillboards.push(billboard);\n      }\n    }\n\n    billboardCollection._billboards = newBillboards;\n  }\n}\n\nBillboardCollection.prototype._updateBillboard = function (\n  billboard,\n  propertyChanged\n) {\n  if (!billboard._dirty) {\n    this._billboardsToUpdate[this._billboardsToUpdateIndex++] = billboard;\n  }\n\n  ++this._propertiesChanged[propertyChanged];\n};\n\n/**\n * Check whether this collection contains a given billboard.\n *\n * @param {Billboard} [billboard] The billboard to check for.\n * @returns {Boolean} true if this collection contains the billboard, false otherwise.\n *\n * @see BillboardCollection#get\n */\nBillboardCollection.prototype.contains = function (billboard) {\n  return defined(billboard) && billboard._billboardCollection === this;\n};\n\n/**\n * Returns the billboard in the collection at the specified index.  Indices are zero-based\n * and increase as billboards are added.  Removing a billboard shifts all billboards after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link BillboardCollection#length} to iterate over all the billboards\n * in the collection.\n *\n * @param {Number} index The zero-based index of the billboard.\n * @returns {Billboard} The billboard at the specified index.\n *\n * @performance Expected constant time.  If billboards were removed from the collection and\n * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every billboard in the collection\n * const len = billboards.length;\n * for (let i = 0; i < len; ++i) {\n *   const b = billboards.get(i);\n *   b.show = !b.show;\n * }\n *\n * @see BillboardCollection#length\n */\nBillboardCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  removeBillboards(this);\n  return this._billboards[index];\n};\n\nlet getIndexBuffer;\n\nfunction getIndexBufferBatched(context) {\n  const sixteenK = 16 * 1024;\n\n  let indexBuffer = context.cache.billboardCollection_indexBufferBatched;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n\n  // Subtract 6 because the last index is reserverd for primitive restart.\n  // https://www.khronos.org/registry/webgl/specs/latest/2.0/#5.18\n  const length = sixteenK * 6 - 6;\n  const indices = new Uint16Array(length);\n  for (let i = 0, j = 0; i < length; i += 6, j += 4) {\n    indices[i] = j;\n    indices[i + 1] = j + 1;\n    indices[i + 2] = j + 2;\n\n    indices[i + 3] = j + 0;\n    indices[i + 4] = j + 2;\n    indices[i + 5] = j + 3;\n  }\n\n  // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?\n  // Is this too much memory to allocate up front?  Should we dynamically grow it?\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: indices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferBatched = indexBuffer;\n  return indexBuffer;\n}\n\nfunction getIndexBufferInstanced(context) {\n  let indexBuffer = context.cache.billboardCollection_indexBufferInstanced;\n  if (defined(indexBuffer)) {\n    return indexBuffer;\n  }\n\n  indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n  });\n\n  indexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_indexBufferInstanced = indexBuffer;\n  return indexBuffer;\n}\n\nfunction getVertexBufferInstanced(context) {\n  let vertexBuffer = context.cache.billboardCollection_vertexBufferInstanced;\n  if (defined(vertexBuffer)) {\n    return vertexBuffer;\n  }\n\n  vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: new Float32Array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]),\n    usage: BufferUsage.STATIC_DRAW,\n  });\n\n  vertexBuffer.vertexArrayDestroyable = false;\n  context.cache.billboardCollection_vertexBufferInstanced = vertexBuffer;\n  return vertexBuffer;\n}\n\nBillboardCollection.prototype.computeNewBuffersUsage = function () {\n  const buffersUsage = this._buffersUsage;\n  let usageChanged = false;\n\n  const properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    const newUsage =\n      properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n\n  return usageChanged;\n};\n\nfunction createVAF(\n  context,\n  numberOfBillboards,\n  buffersUsage,\n  instanced,\n  batchTable,\n  sdf\n) {\n  const attributes = [\n    {\n      index: attributeLocations.positionHighAndScale,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[POSITION_INDEX],\n    },\n    {\n      index: attributeLocations.positionLowAndRotation,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[POSITION_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute0,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[PIXEL_OFFSET_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute1,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute2,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[COLOR_INDEX],\n    },\n    {\n      index: attributeLocations.eyeOffset,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[EYE_OFFSET_INDEX],\n    },\n    {\n      index: attributeLocations.scaleByDistance,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SCALE_BY_DISTANCE_INDEX],\n    },\n    {\n      index: attributeLocations.pixelOffsetScaleByDistance,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX],\n    },\n    {\n      index: attributeLocations.compressedAttribute3,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX],\n    },\n    {\n      index: attributeLocations.textureCoordinateBoundsOrLabelTranslate,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[TEXTURE_COORDINATE_BOUNDS],\n    },\n  ];\n\n  // Instancing requires one non-instanced attribute.\n  if (instanced) {\n    attributes.push({\n      index: attributeLocations.direction,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      vertexBuffer: getVertexBufferInstanced(context),\n    });\n  }\n\n  if (defined(batchTable)) {\n    attributes.push({\n      index: attributeLocations.a_batchId,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.FLOAT,\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n  }\n\n  if (sdf) {\n    attributes.push({\n      index: attributeLocations.sdf,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n      usage: buffersUsage[SDF_INDEX],\n    });\n  }\n\n  // When instancing is enabled, only one vertex is needed for each billboard.\n  const sizeInVertices = instanced\n    ? numberOfBillboards\n    : 4 * numberOfBillboards;\n  return new VertexArrayFacade(context, attributes, sizeInVertices, instanced);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n// Four vertices per billboard.  Each has the same position, etc., but a different screen-space direction vector.\n\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all billboards, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\nconst writePositionScratch = new EncodedCartesian3();\n\nfunction writePositionScaleAndRotation(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  let i;\n  const positionHighWriter =\n    vafWriters[attributeLocations.positionHighAndScale];\n  const positionLowWriter =\n    vafWriters[attributeLocations.positionLowAndRotation];\n  const position = billboard._getActualPosition();\n\n  if (billboardCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(\n      billboardCollection._baseVolume,\n      position,\n      billboardCollection._baseVolume\n    );\n    billboardCollection._boundingVolumeDirty = true;\n  }\n\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  const scale = billboard.scale;\n  const rotation = billboard.rotation;\n\n  if (rotation !== 0.0) {\n    billboardCollection._shaderRotation = true;\n  }\n\n  billboardCollection._maxScale = Math.max(\n    billboardCollection._maxScale,\n    scale\n  );\n\n  const high = writePositionScratch.high;\n  const low = writePositionScratch.low;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    positionHighWriter(i, high.x, high.y, high.z, scale);\n    positionLowWriter(i, low.x, low.y, low.z, rotation);\n  } else {\n    i = billboard._index * 4;\n    positionHighWriter(i + 0, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 1, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 2, high.x, high.y, high.z, scale);\n    positionHighWriter(i + 3, high.x, high.y, high.z, scale);\n\n    positionLowWriter(i + 0, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 1, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 2, low.x, low.y, low.z, rotation);\n    positionLowWriter(i + 3, low.x, low.y, low.z, rotation);\n  }\n}\n\nconst scratchCartesian2 = new Cartesian2();\n\nconst UPPER_BOUND = 32768.0; // 2^15\n\nconst LEFT_SHIFT16 = 65536.0; // 2^16\nconst LEFT_SHIFT12 = 4096.0; // 2^12\nconst LEFT_SHIFT8 = 256.0; // 2^8\nconst LEFT_SHIFT7 = 128.0;\nconst LEFT_SHIFT5 = 32.0;\nconst LEFT_SHIFT3 = 8.0;\nconst LEFT_SHIFT2 = 4.0;\n\nconst RIGHT_SHIFT8 = 1.0 / 256.0;\n\nconst LOWER_LEFT = 0.0;\nconst LOWER_RIGHT = 2.0;\nconst UPPER_RIGHT = 3.0;\nconst UPPER_LEFT = 1.0;\n\nfunction writeCompressedAttrib0(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute0];\n  const pixelOffset = billboard.pixelOffset;\n  const pixelOffsetX = pixelOffset.x;\n  const pixelOffsetY = pixelOffset.y;\n\n  const translate = billboard._translate;\n  const translateX = translate.x;\n  const translateY = translate.y;\n\n  billboardCollection._maxPixelOffset = Math.max(\n    billboardCollection._maxPixelOffset,\n    Math.abs(pixelOffsetX + translateX),\n    Math.abs(-pixelOffsetY + translateY)\n  );\n\n  const horizontalOrigin = billboard.horizontalOrigin;\n  let verticalOrigin = billboard._verticalOrigin;\n  let show = billboard.show && billboard.clusterShow;\n\n  // If the color alpha is zero, do not show this billboard.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n  if (billboard.color.alpha === 0.0) {\n    show = false;\n  }\n\n  // Raw billboards don't distinguish between BASELINE and BOTTOM, only LabelCollection does that.\n  if (verticalOrigin === VerticalOrigin.BASELINE) {\n    verticalOrigin = VerticalOrigin.BOTTOM;\n  }\n\n  billboardCollection._allHorizontalCenter =\n    billboardCollection._allHorizontalCenter &&\n    horizontalOrigin === HorizontalOrigin.CENTER;\n  billboardCollection._allVerticalCenter =\n    billboardCollection._allVerticalCenter &&\n    verticalOrigin === VerticalOrigin.CENTER;\n\n  let bottomLeftX = 0;\n  let bottomLeftY = 0;\n  let width = 0;\n  let height = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    bottomLeftX = imageRectangle.x;\n    bottomLeftY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const topRightX = bottomLeftX + width;\n  const topRightY = bottomLeftY + height;\n\n  let compressed0 =\n    Math.floor(\n      CesiumMath.clamp(pixelOffsetX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND\n    ) * LEFT_SHIFT7;\n  compressed0 += (horizontalOrigin + 1.0) * LEFT_SHIFT5;\n  compressed0 += (verticalOrigin + 1.0) * LEFT_SHIFT3;\n  compressed0 += (show ? 1.0 : 0.0) * LEFT_SHIFT2;\n\n  let compressed1 =\n    Math.floor(\n      CesiumMath.clamp(pixelOffsetY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND\n    ) * LEFT_SHIFT8;\n  let compressed2 =\n    Math.floor(\n      CesiumMath.clamp(translateX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND\n    ) * LEFT_SHIFT8;\n\n  const tempTanslateY =\n    (CesiumMath.clamp(translateY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) *\n    RIGHT_SHIFT8;\n  const upperTranslateY = Math.floor(tempTanslateY);\n  const lowerTranslateY = Math.floor(\n    (tempTanslateY - upperTranslateY) * LEFT_SHIFT8\n  );\n\n  compressed1 += upperTranslateY;\n  compressed2 += lowerTranslateY;\n\n  scratchCartesian2.x = bottomLeftX;\n  scratchCartesian2.y = bottomLeftY;\n  const compressedTexCoordsLL = AttributeCompression.compressTextureCoordinates(\n    scratchCartesian2\n  );\n  scratchCartesian2.x = topRightX;\n  const compressedTexCoordsLR = AttributeCompression.compressTextureCoordinates(\n    scratchCartesian2\n  );\n  scratchCartesian2.y = topRightY;\n  const compressedTexCoordsUR = AttributeCompression.compressTextureCoordinates(\n    scratchCartesian2\n  );\n  scratchCartesian2.x = bottomLeftX;\n  const compressedTexCoordsUL = AttributeCompression.compressTextureCoordinates(\n    scratchCartesian2\n  );\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressedTexCoordsLL);\n  } else {\n    i = billboard._index * 4;\n    writer(\n      i + 0,\n      compressed0 + LOWER_LEFT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsLL\n    );\n    writer(\n      i + 1,\n      compressed0 + LOWER_RIGHT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsLR\n    );\n    writer(\n      i + 2,\n      compressed0 + UPPER_RIGHT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsUR\n    );\n    writer(\n      i + 3,\n      compressed0 + UPPER_LEFT,\n      compressed1,\n      compressed2,\n      compressedTexCoordsUL\n    );\n  }\n}\n\nfunction writeCompressedAttrib1(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute1];\n  const alignedAxis = billboard.alignedAxis;\n  if (!Cartesian3.equals(alignedAxis, Cartesian3.ZERO)) {\n    billboardCollection._shaderAlignedAxis = true;\n  }\n\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const translucency = billboard.translucencyByDistance;\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n\n  let width = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    width = imageRectangle.width;\n  }\n\n  const textureWidth = billboardCollection._textureAtlas.texture.width;\n  const imageWidth = Math.round(\n    defaultValue(billboard.width, textureWidth * width)\n  );\n  billboardCollection._maxSize = Math.max(\n    billboardCollection._maxSize,\n    imageWidth\n  );\n\n  let compressed0 = CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT16);\n  let compressed1 = 0.0;\n\n  if (\n    Math.abs(Cartesian3.magnitudeSquared(alignedAxis) - 1.0) <\n    CesiumMath.EPSILON6\n  ) {\n    compressed1 = AttributeCompression.octEncodeFloat(alignedAxis);\n  }\n\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : (nearValue * 255.0) | 0;\n  compressed0 = compressed0 * LEFT_SHIFT8 + nearValue;\n\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : (farValue * 255.0) | 0;\n  compressed1 = compressed1 * LEFT_SHIFT8 + farValue;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, near, far);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, near, far);\n    writer(i + 1, compressed0, compressed1, near, far);\n    writer(i + 2, compressed0, compressed1, near, far);\n    writer(i + 3, compressed0, compressed1, near, far);\n  }\n}\n\nfunction writeCompressedAttrib2(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute2];\n  const color = billboard.color;\n  const pickColor = !defined(billboardCollection._batchTable)\n    ? billboard.getPickId(frameState.context).color\n    : Color.WHITE;\n  const sizeInMeters = billboard.sizeInMeters ? 1.0 : 0.0;\n  const validAlignedAxis =\n    Math.abs(Cartesian3.magnitudeSquared(billboard.alignedAxis) - 1.0) <\n    CesiumMath.EPSILON6\n      ? 1.0\n      : 0.0;\n\n  billboardCollection._allSizedInMeters =\n    billboardCollection._allSizedInMeters && sizeInMeters === 1.0;\n\n  let height = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    height = imageRectangle.height;\n  }\n\n  const dimensions = billboardCollection._textureAtlas.texture.dimensions;\n  const imageHeight = Math.round(\n    defaultValue(billboard.height, dimensions.y * height)\n  );\n  billboardCollection._maxSize = Math.max(\n    billboardCollection._maxSize,\n    imageHeight\n  );\n  let labelHorizontalOrigin = defaultValue(\n    billboard._labelHorizontalOrigin,\n    -2\n  );\n  labelHorizontalOrigin += 2;\n  const compressed3 = imageHeight * LEFT_SHIFT2 + labelHorizontalOrigin;\n\n  let red = Color.floatToByte(color.red);\n  let green = Color.floatToByte(color.green);\n  let blue = Color.floatToByte(color.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  let compressed2 =\n    Color.floatToByte(color.alpha) * LEFT_SHIFT16 +\n    Color.floatToByte(pickColor.alpha) * LEFT_SHIFT8;\n  compressed2 += sizeInMeters * 2.0 + validAlignedAxis;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1, compressed2, compressed3);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 1, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 2, compressed0, compressed1, compressed2, compressed3);\n    writer(i + 3, compressed0, compressed1, compressed2, compressed3);\n  }\n}\n\nfunction writeEyeOffset(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.eyeOffset];\n  const eyeOffset = billboard.eyeOffset;\n\n  // For billboards that are clamped to ground, move it slightly closer to the camera\n  let eyeOffsetZ = eyeOffset.z;\n  if (billboard._heightReference !== HeightReference.NONE) {\n    eyeOffsetZ *= 1.005;\n  }\n  billboardCollection._maxEyeOffset = Math.max(\n    billboardCollection._maxEyeOffset,\n    Math.abs(eyeOffset.x),\n    Math.abs(eyeOffset.y),\n    Math.abs(eyeOffsetZ)\n  );\n\n  if (billboardCollection._instanced) {\n    let width = 0;\n    let height = 0;\n    const index = billboard._imageIndex;\n    if (index !== -1) {\n      const imageRectangle = textureAtlasCoordinates[index];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(imageRectangle)) {\n        throw new DeveloperError(`Invalid billboard image index: ${index}`);\n      }\n      //>>includeEnd('debug');\n\n      width = imageRectangle.width;\n      height = imageRectangle.height;\n    }\n\n    scratchCartesian2.x = width;\n    scratchCartesian2.y = height;\n    const compressedTexCoordsRange = AttributeCompression.compressTextureCoordinates(\n      scratchCartesian2\n    );\n\n    i = billboard._index;\n    writer(i, eyeOffset.x, eyeOffset.y, eyeOffsetZ, compressedTexCoordsRange);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n    writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0.0);\n  }\n}\n\nfunction writeScaleByDistance(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.scaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const scale = billboard.scaleByDistance;\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderScaleByDistance = true;\n    }\n  }\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\n\nfunction writePixelOffsetScaleByDistance(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.pixelOffsetScaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const pixelOffsetScale = billboard.pixelOffsetScaleByDistance;\n  if (defined(pixelOffsetScale)) {\n    near = pixelOffsetScale.near;\n    nearValue = pixelOffsetScale.nearValue;\n    far = pixelOffsetScale.far;\n    farValue = pixelOffsetScale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // pixelOffsetScale by distance calculation in shader need not be enabled\n      // until a billboard with near and far !== 1.0 is found\n      billboardCollection._shaderPixelOffsetScaleByDistance = true;\n    }\n  }\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, nearValue, far, farValue);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, nearValue, far, farValue);\n    writer(i + 1, near, nearValue, far, farValue);\n    writer(i + 2, near, nearValue, far, farValue);\n    writer(i + 3, near, nearValue, far, farValue);\n  }\n}\n\nfunction writeCompressedAttribute3(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  let i;\n  const writer = vafWriters[attributeLocations.compressedAttribute3];\n  let near = 0.0;\n  let far = Number.MAX_VALUE;\n\n  const distanceDisplayCondition = billboard.distanceDisplayCondition;\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n\n    near *= near;\n    far *= far;\n\n    billboardCollection._shaderDistanceDisplayCondition = true;\n  }\n\n  let disableDepthTestDistance = billboard.disableDepthTestDistance;\n  const clampToGround =\n    billboard.heightReference === HeightReference.CLAMP_TO_GROUND &&\n    frameState.context.depthTexture;\n  if (!defined(disableDepthTestDistance)) {\n    disableDepthTestDistance = clampToGround ? 5000.0 : 0.0;\n  }\n\n  disableDepthTestDistance *= disableDepthTestDistance;\n  if (clampToGround || disableDepthTestDistance > 0.0) {\n    billboardCollection._shaderDisableDepthDistance = true;\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n\n  let imageHeight;\n  let imageWidth;\n\n  if (!defined(billboard._labelDimensions)) {\n    let height = 0;\n    let width = 0;\n    const index = billboard._imageIndex;\n    if (index !== -1) {\n      const imageRectangle = textureAtlasCoordinates[index];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(imageRectangle)) {\n        throw new DeveloperError(`Invalid billboard image index: ${index}`);\n      }\n      //>>includeEnd('debug');\n\n      height = imageRectangle.height;\n      width = imageRectangle.width;\n    }\n\n    imageHeight = Math.round(\n      defaultValue(\n        billboard.height,\n        billboardCollection._textureAtlas.texture.dimensions.y * height\n      )\n    );\n\n    const textureWidth = billboardCollection._textureAtlas.texture.width;\n    imageWidth = Math.round(\n      defaultValue(billboard.width, textureWidth * width)\n    );\n  } else {\n    imageWidth = billboard._labelDimensions.x;\n    imageHeight = billboard._labelDimensions.y;\n  }\n\n  const w = Math.floor(CesiumMath.clamp(imageWidth, 0.0, LEFT_SHIFT12));\n  const h = Math.floor(CesiumMath.clamp(imageHeight, 0.0, LEFT_SHIFT12));\n  const dimensions = w * LEFT_SHIFT12 + h;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, near, far, disableDepthTestDistance, dimensions);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 1, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 2, near, far, disableDepthTestDistance, dimensions);\n    writer(i + 3, near, far, disableDepthTestDistance, dimensions);\n  }\n}\n\nfunction writeTextureCoordinateBoundsOrLabelTranslate(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  if (billboard.heightReference === HeightReference.CLAMP_TO_GROUND) {\n    const scene = billboardCollection._scene;\n    const context = frameState.context;\n    const globeTranslucent = frameState.globeTranslucencyState.translucent;\n    const depthTestAgainstTerrain =\n      defined(scene.globe) && scene.globe.depthTestAgainstTerrain;\n\n    // Only do manual depth test if the globe is opaque and writes depth\n    billboardCollection._shaderClampToGround =\n      context.depthTexture && !globeTranslucent && depthTestAgainstTerrain;\n  }\n  let i;\n  const writer =\n    vafWriters[attributeLocations.textureCoordinateBoundsOrLabelTranslate];\n\n  if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n    //write _labelTranslate, used by depth testing in the vertex shader\n    let translateX = 0;\n    let translateY = 0;\n    if (defined(billboard._labelTranslate)) {\n      translateX = billboard._labelTranslate.x;\n      translateY = billboard._labelTranslate.y;\n    }\n    if (billboardCollection._instanced) {\n      i = billboard._index;\n      writer(i, translateX, translateY, 0.0, 0.0);\n    } else {\n      i = billboard._index * 4;\n      writer(i + 0, translateX, translateY, 0.0, 0.0);\n      writer(i + 1, translateX, translateY, 0.0, 0.0);\n      writer(i + 2, translateX, translateY, 0.0, 0.0);\n      writer(i + 3, translateX, translateY, 0.0, 0.0);\n    }\n    return;\n  }\n\n  //write texture coordinate bounds, used by depth testing in fragment shader\n  let minX = 0;\n  let minY = 0;\n  let width = 0;\n  let height = 0;\n  const index = billboard._imageIndex;\n  if (index !== -1) {\n    const imageRectangle = textureAtlasCoordinates[index];\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(imageRectangle)) {\n      throw new DeveloperError(`Invalid billboard image index: ${index}`);\n    }\n    //>>includeEnd('debug');\n\n    minX = imageRectangle.x;\n    minY = imageRectangle.y;\n    width = imageRectangle.width;\n    height = imageRectangle.height;\n  }\n  const maxX = minX + width;\n  const maxY = minY + height;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, minX, minY, maxX, maxY);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, minX, minY, maxX, maxY);\n    writer(i + 1, minX, minY, maxX, maxY);\n    writer(i + 2, minX, minY, maxX, maxY);\n    writer(i + 3, minX, minY, maxX, maxY);\n  }\n}\n\nfunction writeBatchId(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  if (!defined(billboardCollection._batchTable)) {\n    return;\n  }\n\n  const writer = vafWriters[attributeLocations.a_batchId];\n  const id = billboard._batchIndex;\n\n  let i;\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, id);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, id);\n    writer(i + 1, id);\n    writer(i + 2, id);\n    writer(i + 3, id);\n  }\n}\n\nfunction writeSDF(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  if (!billboardCollection._sdf) {\n    return;\n  }\n\n  let i;\n  const writer = vafWriters[attributeLocations.sdf];\n\n  const outlineColor = billboard.outlineColor;\n  const outlineWidth = billboard.outlineWidth;\n\n  const red = Color.floatToByte(outlineColor.red);\n  const green = Color.floatToByte(outlineColor.green);\n  const blue = Color.floatToByte(outlineColor.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  // Compute the relative outline distance\n  const outlineDistance = outlineWidth / SDFSettings.RADIUS;\n  const compressed1 =\n    Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT16 +\n    Color.floatToByte(outlineDistance) * LEFT_SHIFT8;\n\n  if (billboardCollection._instanced) {\n    i = billboard._index;\n    writer(i, compressed0, compressed1);\n  } else {\n    i = billboard._index * 4;\n    writer(i + 0, compressed0 + LOWER_LEFT, compressed1);\n    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1);\n    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1);\n    writer(i + 3, compressed0 + UPPER_LEFT, compressed1);\n  }\n}\n\nfunction writeBillboard(\n  billboardCollection,\n  frameState,\n  textureAtlasCoordinates,\n  vafWriters,\n  billboard\n) {\n  writePositionScaleAndRotation(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writeCompressedAttrib0(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writeCompressedAttrib1(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writeCompressedAttrib2(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writeEyeOffset(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writeScaleByDistance(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writePixelOffsetScaleByDistance(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writeCompressedAttribute3(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writeTextureCoordinateBoundsOrLabelTranslate(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writeBatchId(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n  writeSDF(\n    billboardCollection,\n    frameState,\n    textureAtlasCoordinates,\n    vafWriters,\n    billboard\n  );\n}\n\nfunction recomputeActualPositions(\n  billboardCollection,\n  billboards,\n  length,\n  frameState,\n  modelMatrix,\n  recomputeBoundingVolume\n) {\n  let boundingVolume;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = billboardCollection._baseVolume;\n    billboardCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = billboardCollection._baseVolume2D;\n  }\n\n  const positions = [];\n  for (let i = 0; i < length; ++i) {\n    const billboard = billboards[i];\n    const position = billboard.position;\n    const actualPosition = Billboard._computeActualPosition(\n      billboard,\n      position,\n      frameState,\n      modelMatrix\n    );\n    if (defined(actualPosition)) {\n      billboard._setActualPosition(actualPosition);\n\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\n\nfunction updateMode(billboardCollection, frameState) {\n  const mode = frameState.mode;\n\n  const billboards = billboardCollection._billboards;\n  const billboardsToUpdate = billboardCollection._billboardsToUpdate;\n  const modelMatrix = billboardCollection._modelMatrix;\n\n  if (\n    billboardCollection._createVertexArray ||\n    billboardCollection._mode !== mode ||\n    (mode !== SceneMode.SCENE3D &&\n      !Matrix4.equals(modelMatrix, billboardCollection.modelMatrix))\n  ) {\n    billboardCollection._mode = mode;\n    Matrix4.clone(billboardCollection.modelMatrix, modelMatrix);\n    billboardCollection._createVertexArray = true;\n\n    if (\n      mode === SceneMode.SCENE3D ||\n      mode === SceneMode.SCENE2D ||\n      mode === SceneMode.COLUMBUS_VIEW\n    ) {\n      recomputeActualPositions(\n        billboardCollection,\n        billboards,\n        billboards.length,\n        frameState,\n        modelMatrix,\n        true\n      );\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(\n      billboardCollection,\n      billboards,\n      billboards.length,\n      frameState,\n      modelMatrix,\n      true\n    );\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(\n      billboardCollection,\n      billboardsToUpdate,\n      billboardCollection._billboardsToUpdateIndex,\n      frameState,\n      modelMatrix,\n      false\n    );\n  }\n}\n\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  let pixelScale = 1.0;\n  if (!collection._allSizedInMeters || collection._maxPixelOffset !== 0.0) {\n    pixelScale = frameState.camera.getPixelSize(\n      boundingVolume,\n      frameState.context.drawingBufferWidth,\n      frameState.context.drawingBufferHeight\n    );\n  }\n\n  let size = pixelScale * collection._maxScale * collection._maxSize * 2.0;\n  if (collection._allHorizontalCenter && collection._allVerticalCenter) {\n    size *= 0.5;\n  }\n\n  const offset =\n    pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;\n  boundingVolume.radius += size + offset;\n}\n\nfunction createDebugCommand(billboardCollection, context) {\n  const fs =\n    \"uniform sampler2D billboard_texture; \\n\" +\n    \"varying vec2 v_textureCoordinates; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gl_FragColor = texture2D(billboard_texture, v_textureCoordinates); \\n\" +\n    \"} \\n\";\n\n  const drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      billboard_texture: function () {\n        return billboardCollection._textureAtlas.texture;\n      },\n    },\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\n\nconst scratchWriterArray = [];\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} image with id must be in the atlas.\n */\nBillboardCollection.prototype.update = function (frameState) {\n  removeBillboards(this);\n\n  if (!this.show) {\n    return;\n  }\n\n  let billboards = this._billboards;\n  let billboardsLength = billboards.length;\n\n  const context = frameState.context;\n  this._instanced = context.instancedArrays;\n  attributeLocations = this._instanced\n    ? attributeLocationsInstanced\n    : attributeLocationsBatched;\n  getIndexBuffer = this._instanced\n    ? getIndexBufferInstanced\n    : getIndexBufferBatched;\n\n  let textureAtlas = this._textureAtlas;\n  if (!defined(textureAtlas)) {\n    textureAtlas = this._textureAtlas = new TextureAtlas({\n      context: context,\n    });\n\n    for (let ii = 0; ii < billboardsLength; ++ii) {\n      billboards[ii]._loadImage();\n    }\n  }\n\n  const textureAtlasCoordinates = textureAtlas.textureCoordinates;\n  if (textureAtlasCoordinates.length === 0) {\n    // Can't write billboard vertices until we have texture coordinates\n    // provided by a texture atlas\n    return;\n  }\n\n  updateMode(this, frameState);\n\n  billboards = this._billboards;\n  billboardsLength = billboards.length;\n  const billboardsToUpdate = this._billboardsToUpdate;\n  const billboardsToUpdateLength = this._billboardsToUpdateIndex;\n\n  const properties = this._propertiesChanged;\n\n  const textureAtlasGUID = textureAtlas.guid;\n  const createVertexArray =\n    this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;\n  this._textureAtlasGUID = textureAtlasGUID;\n\n  let vafWriters;\n  const pass = frameState.passes;\n  const picking = pass.pick;\n\n  // PERFORMANCE_IDEA: Round robin multiple buffers.\n  if (createVertexArray || (!picking && this.computeNewBuffersUsage())) {\n    this._createVertexArray = false;\n\n    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n\n    this._vaf = this._vaf && this._vaf.destroy();\n\n    if (billboardsLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(\n        context,\n        billboardsLength,\n        this._buffersUsage,\n        this._instanced,\n        this._batchTable,\n        this._sdf\n      );\n      vafWriters = this._vaf.writers;\n\n      // Rewrite entire buffer if billboards were added or removed.\n      for (let i = 0; i < billboardsLength; ++i) {\n        const billboard = this._billboards[i];\n        billboard._dirty = false; // In case it needed an update.\n        writeBillboard(\n          this,\n          frameState,\n          textureAtlasCoordinates,\n          vafWriters,\n          billboard\n        );\n      }\n\n      // Different billboard collections share the same index buffer.\n      this._vaf.commit(getIndexBuffer(context));\n    }\n\n    this._billboardsToUpdateIndex = 0;\n  } else if (billboardsToUpdateLength > 0) {\n    // Billboards were modified, but none were added or removed.\n    const writers = scratchWriterArray;\n    writers.length = 0;\n\n    if (\n      properties[POSITION_INDEX] ||\n      properties[ROTATION_INDEX] ||\n      properties[SCALE_INDEX]\n    ) {\n      writers.push(writePositionScaleAndRotation);\n    }\n\n    if (\n      properties[IMAGE_INDEX_INDEX] ||\n      properties[PIXEL_OFFSET_INDEX] ||\n      properties[HORIZONTAL_ORIGIN_INDEX] ||\n      properties[VERTICAL_ORIGIN_INDEX] ||\n      properties[SHOW_INDEX]\n    ) {\n      writers.push(writeCompressedAttrib0);\n      if (this._instanced) {\n        writers.push(writeEyeOffset);\n      }\n    }\n\n    if (\n      properties[IMAGE_INDEX_INDEX] ||\n      properties[ALIGNED_AXIS_INDEX] ||\n      properties[TRANSLUCENCY_BY_DISTANCE_INDEX]\n    ) {\n      writers.push(writeCompressedAttrib1);\n      writers.push(writeCompressedAttrib2);\n    }\n\n    if (properties[IMAGE_INDEX_INDEX] || properties[COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib2);\n    }\n\n    if (properties[EYE_OFFSET_INDEX]) {\n      writers.push(writeEyeOffset);\n    }\n\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n\n    if (properties[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writePixelOffsetScaleByDistance);\n    }\n\n    if (\n      properties[DISTANCE_DISPLAY_CONDITION_INDEX] ||\n      properties[DISABLE_DEPTH_DISTANCE] ||\n      properties[IMAGE_INDEX_INDEX] ||\n      properties[POSITION_INDEX]\n    ) {\n      writers.push(writeCompressedAttribute3);\n    }\n\n    if (properties[IMAGE_INDEX_INDEX] || properties[POSITION_INDEX]) {\n      writers.push(writeTextureCoordinateBoundsOrLabelTranslate);\n    }\n\n    if (properties[SDF_INDEX]) {\n      writers.push(writeSDF);\n    }\n\n    const numWriters = writers.length;\n    vafWriters = this._vaf.writers;\n\n    if (billboardsToUpdateLength / billboardsLength > 0.1) {\n      // If more than 10% of billboard change, rewrite the entire buffer.\n\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n\n      for (let m = 0; m < billboardsToUpdateLength; ++m) {\n        const b = billboardsToUpdate[m];\n        b._dirty = false;\n\n        for (let n = 0; n < numWriters; ++n) {\n          writers[n](this, frameState, textureAtlasCoordinates, vafWriters, b);\n        }\n      }\n      this._vaf.commit(getIndexBuffer(context));\n    } else {\n      for (let h = 0; h < billboardsToUpdateLength; ++h) {\n        const bb = billboardsToUpdate[h];\n        bb._dirty = false;\n\n        for (let o = 0; o < numWriters; ++o) {\n          writers[o](this, frameState, textureAtlasCoordinates, vafWriters, bb);\n        }\n\n        if (this._instanced) {\n          this._vaf.subCommit(bb._index, 1);\n        } else {\n          this._vaf.subCommit(bb._index * 4, 4);\n        }\n      }\n      this._vaf.endSubCommits();\n    }\n\n    this._billboardsToUpdateIndex = 0;\n  }\n\n  // If the number of total billboards ever shrinks considerably\n  // Truncate billboardsToUpdate so that we free memory that we're\n  // not going to be using.\n  if (billboardsToUpdateLength > billboardsLength * 1.5) {\n    billboardsToUpdate.length = billboardsLength;\n  }\n\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(\n      this._baseVolume,\n      this.modelMatrix,\n      this._baseVolumeWC\n    );\n  }\n\n  let boundingVolume;\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolumeWC,\n      this._boundingVolume\n    );\n  } else {\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolume2D,\n      this._boundingVolume\n    );\n  }\n  updateBoundingVolume(this, frameState, boundingVolume);\n\n  const blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n\n  if (blendOptionChanged) {\n    if (\n      this._blendOption === BlendOption.OPAQUE ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LESS,\n        },\n        depthMask: true,\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n\n    // If OPAQUE_AND_TRANSLUCENT is in use, only the opaque pass gets the benefit of the depth buffer,\n    // not the translucent pass.  Otherwise, if the TRANSLUCENT pass is on its own, it turns on\n    // a depthMask in lieu of full depth sorting (because it has opaque-ish fragments that look bad in OIT).\n    // When the TRANSLUCENT depth mask is in use, label backgrounds require the depth func to be LEQUAL.\n    const useTranslucentDepthMask =\n      this._blendOption === BlendOption.TRANSLUCENT;\n\n    if (\n      this._blendOption === BlendOption.TRANSLUCENT ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: useTranslucentDepthMask\n            ? WebGLConstants.LEQUAL\n            : WebGLConstants.LESS,\n        },\n        depthMask: useTranslucentDepthMask,\n        blending: BlendingState.ALPHA_BLEND,\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n\n  this._shaderDisableDepthDistance =\n    this._shaderDisableDepthDistance ||\n    frameState.minimumDisableDepthTestDistance !== 0.0;\n\n  let vsSource;\n  let fsSource;\n  let vs;\n  let fs;\n  let vertDefines;\n\n  const supportVSTextureReads =\n    ContextLimits.maximumVertexTextureImageUnits > 0;\n\n  if (\n    blendOptionChanged ||\n    this._shaderRotation !== this._compiledShaderRotation ||\n    this._shaderAlignedAxis !== this._compiledShaderAlignedAxis ||\n    this._shaderScaleByDistance !== this._compiledShaderScaleByDistance ||\n    this._shaderTranslucencyByDistance !==\n      this._compiledShaderTranslucencyByDistance ||\n    this._shaderPixelOffsetScaleByDistance !==\n      this._compiledShaderPixelOffsetScaleByDistance ||\n    this._shaderDistanceDisplayCondition !==\n      this._compiledShaderDistanceDisplayCondition ||\n    this._shaderDisableDepthDistance !==\n      this._compiledShaderDisableDepthDistance ||\n    this._shaderClampToGround !== this._compiledShaderClampToGround ||\n    this._sdf !== this._compiledSDF\n  ) {\n    vsSource = BillboardCollectionVS;\n    fsSource = BillboardCollectionFS;\n\n    vertDefines = [];\n    if (defined(this._batchTable)) {\n      vertDefines.push(\"VECTOR_TILE\");\n      vsSource = this._batchTable.getVertexShaderCallback(\n        false,\n        \"a_batchId\",\n        undefined\n      )(vsSource);\n      fsSource = this._batchTable.getFragmentShaderCallback(\n        false,\n        undefined\n      )(fsSource);\n    }\n\n    vs = new ShaderSource({\n      defines: vertDefines,\n      sources: [vsSource],\n    });\n    if (this._instanced) {\n      vs.defines.push(\"INSTANCED\");\n    }\n    if (this._shaderRotation) {\n      vs.defines.push(\"ROTATION\");\n    }\n    if (this._shaderAlignedAxis) {\n      vs.defines.push(\"ALIGNED_AXIS\");\n    }\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n    if (this._shaderPixelOffsetScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_PIXEL_OFFSET\");\n    }\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n    if (this._shaderClampToGround) {\n      if (supportVSTextureReads) {\n        vs.defines.push(\"VERTEX_DEPTH_CHECK\");\n      } else {\n        vs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n      }\n    }\n\n    const sdfEdge = 1.0 - SDFSettings.CUTOFF;\n\n    if (this._sdf) {\n      vs.defines.push(\"SDF\");\n    }\n\n    const vectorFragDefine = defined(this._batchTable) ? \"VECTOR_TILE\" : \"\";\n\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\", vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\", vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [vectorFragDefine],\n        sources: [fsSource],\n      });\n      if (this._shaderClampToGround) {\n        if (supportVSTextureReads) {\n          fs.defines.push(\"VERTEX_DEPTH_CHECK\");\n        } else {\n          fs.defines.push(\"FRAGMENT_DEPTH_CHECK\");\n        }\n      }\n      if (this._sdf) {\n        fs.defines.push(\"SDF\");\n        fs.defines.push(`SDF_EDGE ${sdfEdge}`);\n      }\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    this._compiledShaderRotation = this._shaderRotation;\n    this._compiledShaderAlignedAxis = this._shaderAlignedAxis;\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;\n    this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance;\n    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n    this._compiledShaderClampToGround = this._shaderClampToGround;\n    this._compiledSDF = this._sdf;\n  }\n\n  const commandList = frameState.commandList;\n\n  if (pass.render || pass.pick) {\n    const colorList = this._colorCommands;\n\n    const opaque = this._blendOption === BlendOption.OPAQUE;\n    const opaqueAndTranslucent =\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n\n    const va = this._vaf.va;\n    const vaLength = va.length;\n\n    let uniforms = this._uniforms;\n    let pickId;\n    if (defined(this._batchTable)) {\n      uniforms = this._batchTable.getUniformMapCallback()(uniforms);\n      pickId = this._batchTable.getPickId();\n    } else {\n      pickId = \"v_pickColor\";\n    }\n\n    colorList.length = vaLength;\n    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n    for (let j = 0; j < totalLength; ++j) {\n      let command = colorList[j];\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n\n      const opaqueCommand = opaque || (opaqueAndTranslucent && j % 2 === 0);\n\n      command.pass =\n        opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n\n      const index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.count = va[index].indicesCount;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand\n        ? this._rsOpaque\n        : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = pickId;\n\n      if (this._instanced) {\n        command.count = 6;\n        command.instanceCount = billboardsLength;\n      }\n\n      commandList.push(command);\n    }\n\n    if (this.debugShowTextureAtlas) {\n      if (!defined(this.debugCommand)) {\n        this.debugCommand = createDebugCommand(this, frameState.context);\n      }\n\n      commandList.push(this.debugCommand);\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see BillboardCollection#destroy\n */\nBillboardCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * billboards = billboards && billboards.destroy();\n *\n * @see BillboardCollection#isDestroyed\n */\nBillboardCollection.prototype.destroy = function () {\n  if (defined(this._removeCallbackFunc)) {\n    this._removeCallbackFunc();\n    this._removeCallbackFunc = undefined;\n  }\n\n  this._textureAtlas =\n    this._destroyTextureAtlas &&\n    this._textureAtlas &&\n    this._textureAtlas.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyBillboards(this._billboards);\n\n  return destroyObject(this);\n};\nexport default BillboardCollection;\n","import buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Check from \"../Core/Check.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport BingMapsStyle from \"./BingMapsStyle.js\";\nimport DiscardEmptyTilePolicy from \"./DiscardEmptyTileImagePolicy.js\";\nimport ImageryProvider from \"./ImageryProvider.js\";\n\n/**\n * @typedef {Object} BingMapsImageryProvider.ConstructorOptions\n *\n * Initialization options for the BingMapsImageryProvider constructor\n *\n * @property {Resource|String} url The url of the Bing Maps server hosting the imagery.\n * @property {String} key The Bing Maps key for your application, which can be\n *        created at {@link https://www.bingmapsportal.com/}.\n * @property {String} [tileProtocol] The protocol to use when loading tiles, e.g. 'http' or 'https'.\n *        By default, tiles are loaded using the same protocol as the page.\n * @property {BingMapsStyle} [mapStyle=BingMapsStyle.AERIAL] The type of Bing Maps imagery to load.\n * @property {String} [culture=''] The culture to use when requesting Bing Maps imagery. Not\n *        all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}\n *        for information on the supported cultures.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @property {TileDiscardPolicy} [tileDiscardPolicy] The policy that determines if a tile\n *        is invalid and should be discarded.  By default, a {@link DiscardEmptyTileImagePolicy}\n *        will be used, with the expectation that the Bing Maps server will send a zero-length response for missing tiles.\n *        To ensure that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this parameter.\n */\n\n/**\n * Provides tiled imagery using the Bing Maps Imagery REST API.\n *\n * @alias BingMapsImageryProvider\n * @constructor\n *\n * @param {BingMapsImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @see ArcGisMapServerImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n *\n *\n * @example\n * const bing = new Cesium.BingMapsImageryProvider({\n *     url : 'https://dev.virtualearth.net',\n *     key : 'get-yours-at-https://www.bingmapsportal.com/',\n *     mapStyle : Cesium.BingMapsStyle.AERIAL\n * });\n *\n * @see {@link http://msdn.microsoft.com/en-us/library/ff701713.aspx|Bing Maps REST Services}\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nfunction BingMapsImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const accessKey = options.key;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  if (!defined(accessKey)) {\n    throw new DeveloperError(\"options.key is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default 1.0\n   */\n  this.defaultGamma = 1.0;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  this._key = accessKey;\n  this._resource = Resource.createIfNeeded(options.url);\n  this._resource.appendForwardSlash();\n  this._tileProtocol = options.tileProtocol;\n  this._mapStyle = defaultValue(options.mapStyle, BingMapsStyle.AERIAL);\n  this._culture = defaultValue(options.culture, \"\");\n\n  this._tileDiscardPolicy = options.tileDiscardPolicy;\n  if (!defined(this._tileDiscardPolicy)) {\n    this._tileDiscardPolicy = new DiscardEmptyTilePolicy();\n  }\n\n  this._proxy = options.proxy;\n  this._credit = new Credit(\n    `<a href=\"http://www.bing.com\"><img src=\"${BingMapsImageryProvider.logoUrl}\" title=\"Bing Imagery\"/></a>`\n  );\n\n  this._tilingScheme = new WebMercatorTilingScheme({\n    numberOfLevelZeroTilesX: 2,\n    numberOfLevelZeroTilesY: 2,\n    ellipsoid: options.ellipsoid,\n  });\n\n  this._tileWidth = undefined;\n  this._tileHeight = undefined;\n  this._maximumLevel = undefined;\n  this._imageUrlTemplate = undefined;\n  this._imageUrlSubdomains = undefined;\n\n  this._errorEvent = new Event();\n\n  this._ready = false;\n  this._readyPromise = defer();\n\n  let tileProtocol = this._tileProtocol;\n\n  // For backward compatibility reasons, the tileProtocol may end with\n  // a `:`. Remove it.\n  if (defined(tileProtocol)) {\n    if (\n      tileProtocol.length > 0 &&\n      tileProtocol[tileProtocol.length - 1] === \":\"\n    ) {\n      tileProtocol = tileProtocol.substr(0, tileProtocol.length - 1);\n    }\n  } else {\n    // use http if the document's protocol is http, otherwise use https\n    const documentProtocol = document.location.protocol;\n    tileProtocol = documentProtocol === \"http:\" ? \"http\" : \"https\";\n  }\n\n  const metadataResource = this._resource.getDerivedResource({\n    url: `REST/v1/Imagery/Metadata/${this._mapStyle}`,\n    queryParameters: {\n      incl: \"ImageryProviders\",\n      key: this._key,\n      uriScheme: tileProtocol,\n    },\n  });\n  const that = this;\n  let metadataError;\n\n  function metadataSuccess(data) {\n    if (data.resourceSets.length !== 1) {\n      metadataFailure();\n      return;\n    }\n    const resource = data.resourceSets[0].resources[0];\n\n    that._tileWidth = resource.imageWidth;\n    that._tileHeight = resource.imageHeight;\n    that._maximumLevel = resource.zoomMax - 1;\n    that._imageUrlSubdomains = resource.imageUrlSubdomains;\n    that._imageUrlTemplate = resource.imageUrl;\n\n    let attributionList = (that._attributionList = resource.imageryProviders);\n    if (!attributionList) {\n      attributionList = that._attributionList = [];\n    }\n\n    for (\n      let attributionIndex = 0, attributionLength = attributionList.length;\n      attributionIndex < attributionLength;\n      ++attributionIndex\n    ) {\n      const attribution = attributionList[attributionIndex];\n\n      if (attribution.credit instanceof Credit) {\n        // If attribution.credit has already been created\n        // then we are using a cached value, which means\n        // none of the remaining processing needs to be done.\n        break;\n      }\n\n      attribution.credit = new Credit(attribution.attribution);\n      const coverageAreas = attribution.coverageAreas;\n\n      for (\n        let areaIndex = 0, areaLength = attribution.coverageAreas.length;\n        areaIndex < areaLength;\n        ++areaIndex\n      ) {\n        const area = coverageAreas[areaIndex];\n        const bbox = area.bbox;\n        area.bbox = new Rectangle(\n          CesiumMath.toRadians(bbox[1]),\n          CesiumMath.toRadians(bbox[0]),\n          CesiumMath.toRadians(bbox[3]),\n          CesiumMath.toRadians(bbox[2])\n        );\n      }\n    }\n\n    that._ready = true;\n    that._readyPromise.resolve(true);\n    TileProviderError.handleSuccess(metadataError);\n  }\n\n  function metadataFailure(e) {\n    const message = `An error occurred while accessing ${metadataResource.url}.`;\n    metadataError = TileProviderError.handleError(\n      metadataError,\n      that,\n      that._errorEvent,\n      message,\n      undefined,\n      undefined,\n      undefined,\n      requestMetadata\n    );\n    that._readyPromise.reject(new RuntimeError(message));\n  }\n\n  const cacheKey = metadataResource.url;\n  function requestMetadata() {\n    const promise = metadataResource.fetchJsonp(\"jsonp\");\n    BingMapsImageryProvider._metadataCache[cacheKey] = promise;\n    promise.then(metadataSuccess).catch(metadataFailure);\n  }\n\n  const promise = BingMapsImageryProvider._metadataCache[cacheKey];\n  if (defined(promise)) {\n    promise.then(metadataSuccess).catch(metadataFailure);\n  } else {\n    requestMetadata();\n  }\n}\n\nObject.defineProperties(BingMapsImageryProvider.prototype, {\n  /**\n   * Gets the name of the BingMaps server url hosting the imagery.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._resource.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._resource.proxy;\n    },\n  },\n\n  /**\n   * Gets the Bing Maps key.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  key: {\n    get: function () {\n      return this._key;\n    },\n  },\n\n  /**\n   * Gets the type of Bing Maps imagery to load.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {BingMapsStyle}\n   * @readonly\n   */\n  mapStyle: {\n    get: function () {\n      return this._mapStyle;\n    },\n  },\n\n  /**\n   * The culture to use when requesting Bing Maps imagery. Not\n   * all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}\n   * for information on the supported cultures.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  culture: {\n    get: function () {\n      return this._culture;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link BingMapsImageryProvider#ready} returns true.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileWidth must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link BingMapsImageryProvider#ready} returns true.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link BingMapsImageryProvider#ready} returns true.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"maximumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link BingMapsImageryProvider#ready} returns true.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"minimumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link BingMapsImageryProvider#ready} returns true.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link BingMapsImageryProvider#ready} returns true.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"rectangle must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme.rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link BingMapsImageryProvider#ready} returns true.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileDiscardPolicy must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link BingMapsImageryProvider#ready} returns true.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage\n   * and texture upload time.\n   * @memberof BingMapsImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return false;\n    },\n  },\n});\n\nconst rectangleScratch = new Rectangle();\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nBingMapsImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"getTileCredits must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const rectangle = this._tilingScheme.tileXYToRectangle(\n    x,\n    y,\n    level,\n    rectangleScratch\n  );\n  const result = getRectangleAttribution(\n    this._attributionList,\n    level,\n    rectangle\n  );\n\n  return result;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link BingMapsImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nBingMapsImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestImage must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const promise = ImageryProvider.loadImage(\n    this,\n    buildImageResource(this, x, y, level, request)\n  );\n\n  if (defined(promise)) {\n    return promise.catch(function (error) {\n      // One cause of an error here is that the image we tried to load was zero-length.\n      // This isn't actually a problem, since it indicates that there is no tile.\n      // So, in that case we return the EMPTY_IMAGE sentinel value for later discarding.\n      if (defined(error.blob) && error.blob.size === 0) {\n        return DiscardEmptyTilePolicy.EMPTY_IMAGE;\n      }\n      return Promise.reject(error);\n    });\n  }\n\n  return undefined;\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {undefined} Undefined since picking is not supported.\n */\nBingMapsImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return undefined;\n};\n\n/**\n * Converts a tiles (x, y, level) position into a quadkey used to request an image\n * from a Bing Maps server.\n *\n * @param {Number} x The tile's x coordinate.\n * @param {Number} y The tile's y coordinate.\n * @param {Number} level The tile's zoom level.\n *\n * @see {@link http://msdn.microsoft.com/en-us/library/bb259689.aspx|Bing Maps Tile System}\n * @see BingMapsImageryProvider#quadKeyToTileXY\n */\nBingMapsImageryProvider.tileXYToQuadKey = function (x, y, level) {\n  let quadkey = \"\";\n  for (let i = level; i >= 0; --i) {\n    const bitmask = 1 << i;\n    let digit = 0;\n\n    if ((x & bitmask) !== 0) {\n      digit |= 1;\n    }\n\n    if ((y & bitmask) !== 0) {\n      digit |= 2;\n    }\n\n    quadkey += digit;\n  }\n  return quadkey;\n};\n\n/**\n * Converts a tile's quadkey used to request an image from a Bing Maps server into the\n * (x, y, level) position.\n *\n * @param {String} quadkey The tile's quad key\n *\n * @see {@link http://msdn.microsoft.com/en-us/library/bb259689.aspx|Bing Maps Tile System}\n * @see BingMapsImageryProvider#tileXYToQuadKey\n */\nBingMapsImageryProvider.quadKeyToTileXY = function (quadkey) {\n  let x = 0;\n  let y = 0;\n  const level = quadkey.length - 1;\n  for (let i = level; i >= 0; --i) {\n    const bitmask = 1 << i;\n    const digit = +quadkey[level - i];\n\n    if ((digit & 1) !== 0) {\n      x |= bitmask;\n    }\n\n    if ((digit & 2) !== 0) {\n      y |= bitmask;\n    }\n  }\n  return {\n    x: x,\n    y: y,\n    level: level,\n  };\n};\n\nBingMapsImageryProvider._logoUrl = undefined;\n\nObject.defineProperties(BingMapsImageryProvider, {\n  /**\n   * Gets or sets the URL to the Bing logo for display in the credit.\n   * @memberof BingMapsImageryProvider\n   * @type {String}\n   */\n  logoUrl: {\n    get: function () {\n      if (!defined(BingMapsImageryProvider._logoUrl)) {\n        BingMapsImageryProvider._logoUrl = buildModuleUrl(\n          \"Assets/Images/bing_maps_credit.png\"\n        );\n      }\n      return BingMapsImageryProvider._logoUrl;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n\n      BingMapsImageryProvider._logoUrl = value;\n    },\n  },\n});\n\nfunction buildImageResource(imageryProvider, x, y, level, request) {\n  const imageUrl = imageryProvider._imageUrlTemplate;\n\n  const subdomains = imageryProvider._imageUrlSubdomains;\n  const subdomainIndex = (x + y + level) % subdomains.length;\n\n  return imageryProvider._resource.getDerivedResource({\n    url: imageUrl,\n    request: request,\n    templateValues: {\n      quadkey: BingMapsImageryProvider.tileXYToQuadKey(x, y, level),\n      subdomain: subdomains[subdomainIndex],\n      culture: imageryProvider._culture,\n    },\n    queryParameters: {\n      // this parameter tells the Bing servers to send a zero-length response\n      // instead of a placeholder image for missing tiles.\n      n: \"z\",\n    },\n  });\n}\n\nconst intersectionScratch = new Rectangle();\n\nfunction getRectangleAttribution(attributionList, level, rectangle) {\n  // Bing levels start at 1, while ours start at 0.\n  ++level;\n\n  const result = [];\n\n  for (\n    let attributionIndex = 0, attributionLength = attributionList.length;\n    attributionIndex < attributionLength;\n    ++attributionIndex\n  ) {\n    const attribution = attributionList[attributionIndex];\n    const coverageAreas = attribution.coverageAreas;\n\n    let included = false;\n\n    for (\n      let areaIndex = 0, areaLength = attribution.coverageAreas.length;\n      !included && areaIndex < areaLength;\n      ++areaIndex\n    ) {\n      const area = coverageAreas[areaIndex];\n      if (level >= area.zoomMin && level <= area.zoomMax) {\n        const intersection = Rectangle.intersection(\n          rectangle,\n          area.bbox,\n          intersectionScratch\n        );\n        if (defined(intersection)) {\n          included = true;\n        }\n      }\n    }\n\n    if (included) {\n      result.push(attribution.credit);\n    }\n  }\n\n  return result;\n}\n\n// Exposed for testing\nBingMapsImageryProvider._metadataCache = {};\nexport default BingMapsImageryProvider;\n","/**\n * The types of imagery provided by Bing Maps.\n *\n * @enum {Number}\n *\n * @see BingMapsImageryProvider\n */\nconst BingMapsStyle = {\n  /**\n   * Aerial imagery.\n   *\n   * @type {String}\n   * @constant\n   */\n  AERIAL: \"Aerial\",\n\n  /**\n   * Aerial imagery with a road overlay.\n   *\n   * @type {String}\n   * @constant\n   * @deprecated See https://github.com/CesiumGS/cesium/issues/7128.\n   * Use `BingMapsStyle.AERIAL_WITH_LABELS_ON_DEMAND` instead\n   */\n  AERIAL_WITH_LABELS: \"AerialWithLabels\",\n\n  /**\n   * Aerial imagery with a road overlay.\n   *\n   * @type {String}\n   * @constant\n   */\n  AERIAL_WITH_LABELS_ON_DEMAND: \"AerialWithLabelsOnDemand\",\n\n  /**\n   * Roads without additional imagery.\n   *\n   * @type {String}\n   * @constant\n   * @deprecated See https://github.com/CesiumGS/cesium/issues/7128.\n   * Use `BingMapsStyle.ROAD_ON_DEMAND` instead\n   */\n  ROAD: \"Road\",\n\n  /**\n   * Roads without additional imagery.\n   *\n   * @type {String}\n   * @constant\n   */\n  ROAD_ON_DEMAND: \"RoadOnDemand\",\n\n  /**\n   * A dark version of the road maps.\n   *\n   * @type {String}\n   * @constant\n   */\n  CANVAS_DARK: \"CanvasDark\",\n\n  /**\n   * A lighter version of the road maps.\n   *\n   * @type {String}\n   * @constant\n   */\n  CANVAS_LIGHT: \"CanvasLight\",\n\n  /**\n   * A grayscale version of the road maps.\n   *\n   * @type {String}\n   * @constant\n   */\n  CANVAS_GRAY: \"CanvasGray\",\n\n  /**\n   * Ordnance Survey imagery. This imagery is visible only for the London, UK area.\n   *\n   * @type {String}\n   * @constant\n   */\n  ORDNANCE_SURVEY: \"OrdnanceSurvey\",\n\n  /**\n   * Collins Bart imagery.\n   *\n   * @type {String}\n   * @constant\n   */\n  COLLINS_BART: \"CollinsBart\",\n};\nexport default Object.freeze(BingMapsStyle);\n","import WebGLConstants from \"../Core/WebGLConstants.js\";\n\n/**\n * Determines how two pixels' values are combined.\n *\n * @enum {Number}\n */\nconst BlendEquation = {\n  /**\n   * Pixel values are added componentwise.  This is used in additive blending for translucency.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ADD: WebGLConstants.FUNC_ADD,\n\n  /**\n   * Pixel values are subtracted componentwise (source - destination).  This is used in alpha blending for translucency.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SUBTRACT: WebGLConstants.FUNC_SUBTRACT,\n\n  /**\n   * Pixel values are subtracted componentwise (destination - source).\n   *\n   * @type {Number}\n   * @constant\n   */\n  REVERSE_SUBTRACT: WebGLConstants.FUNC_REVERSE_SUBTRACT,\n\n  /**\n   * Pixel values are given to the minimum function (min(source, destination)).\n   *\n   * This equation operates on each pixel color component.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MIN: WebGLConstants.MIN,\n\n  /**\n   * Pixel values are given to the maximum function (max(source, destination)).\n   *\n   * This equation operates on each pixel color component.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MAX: WebGLConstants.MAX,\n};\nexport default Object.freeze(BlendEquation);\n","import WebGLConstants from \"../Core/WebGLConstants.js\";\n\n/**\n * Determines how blending factors are computed.\n *\n * @enum {Number}\n */\nconst BlendFunction = {\n  /**\n   * The blend factor is zero.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ZERO: WebGLConstants.ZERO,\n\n  /**\n   * The blend factor is one.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ONE: WebGLConstants.ONE,\n\n  /**\n   * The blend factor is the source color.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SOURCE_COLOR: WebGLConstants.SRC_COLOR,\n\n  /**\n   * The blend factor is one minus the source color.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ONE_MINUS_SOURCE_COLOR: WebGLConstants.ONE_MINUS_SRC_COLOR,\n\n  /**\n   * The blend factor is the destination color.\n   *\n   * @type {Number}\n   * @constant\n   */\n  DESTINATION_COLOR: WebGLConstants.DST_COLOR,\n\n  /**\n   * The blend factor is one minus the destination color.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ONE_MINUS_DESTINATION_COLOR: WebGLConstants.ONE_MINUS_DST_COLOR,\n\n  /**\n   * The blend factor is the source alpha.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SOURCE_ALPHA: WebGLConstants.SRC_ALPHA,\n\n  /**\n   * The blend factor is one minus the source alpha.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ONE_MINUS_SOURCE_ALPHA: WebGLConstants.ONE_MINUS_SRC_ALPHA,\n\n  /**\n   * The blend factor is the destination alpha.\n   *\n   * @type {Number}\n   * @constant\n   */\n  DESTINATION_ALPHA: WebGLConstants.DST_ALPHA,\n\n  /**\n   * The blend factor is one minus the destination alpha.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ONE_MINUS_DESTINATION_ALPHA: WebGLConstants.ONE_MINUS_DST_ALPHA,\n\n  /**\n   * The blend factor is the constant color.\n   *\n   * @type {Number}\n   * @constant\n   */\n  CONSTANT_COLOR: WebGLConstants.CONSTANT_COLOR,\n\n  /**\n   * The blend factor is one minus the constant color.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ONE_MINUS_CONSTANT_COLOR: WebGLConstants.ONE_MINUS_CONSTANT_COLOR,\n\n  /**\n   * The blend factor is the constant alpha.\n   *\n   * @type {Number}\n   * @constant\n   */\n  CONSTANT_ALPHA: WebGLConstants.CONSTANT_ALPHA,\n\n  /**\n   * The blend factor is one minus the constant alpha.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ONE_MINUS_CONSTANT_ALPHA: WebGLConstants.ONE_MINUS_CONSTANT_ALPHA,\n\n  /**\n   * The blend factor is the saturated source alpha.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SOURCE_ALPHA_SATURATE: WebGLConstants.SRC_ALPHA_SATURATE,\n};\nexport default Object.freeze(BlendFunction);\n","/**\n * Determines how opaque and translucent parts of billboards, points, and labels are blended with the scene.\n *\n * @enum {Number}\n */\nconst BlendOption = {\n  /**\n   * The billboards, points, or labels in the collection are completely opaque.\n   * @type {Number}\n   * @constant\n   */\n  OPAQUE: 0,\n\n  /**\n   * The billboards, points, or labels in the collection are completely translucent.\n   * @type {Number}\n   * @constant\n   */\n  TRANSLUCENT: 1,\n\n  /**\n   * The billboards, points, or labels in the collection are both opaque and translucent.\n   * @type {Number}\n   * @constant\n   */\n  OPAQUE_AND_TRANSLUCENT: 2,\n};\nexport default Object.freeze(BlendOption);\n","import BlendEquation from \"./BlendEquation.js\";\nimport BlendFunction from \"./BlendFunction.js\";\n\n/**\n * The blending state combines {@link BlendEquation} and {@link BlendFunction} and the\n * <code>enabled</code> flag to define the full blending state for combining source and\n * destination fragments when rendering.\n * <p>\n * This is a helper when using custom render states with {@link Appearance#renderState}.\n * </p>\n *\n * @namespace\n */\nconst BlendingState = {\n  /**\n   * Blending is disabled.\n   *\n   * @type {Object}\n   * @constant\n   */\n  DISABLED: Object.freeze({\n    enabled: false,\n  }),\n\n  /**\n   * Blending is enabled using alpha blending, <code>source(source.alpha) + destination(1 - source.alpha)</code>.\n   *\n   * @type {Object}\n   * @constant\n   */\n  ALPHA_BLEND: Object.freeze({\n    enabled: true,\n    equationRgb: BlendEquation.ADD,\n    equationAlpha: BlendEquation.ADD,\n    functionSourceRgb: BlendFunction.SOURCE_ALPHA,\n    functionSourceAlpha: BlendFunction.ONE,\n    functionDestinationRgb: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n    functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n  }),\n\n  /**\n   * Blending is enabled using alpha blending with premultiplied alpha, <code>source + destination(1 - source.alpha)</code>.\n   *\n   * @type {Object}\n   * @constant\n   */\n  PRE_MULTIPLIED_ALPHA_BLEND: Object.freeze({\n    enabled: true,\n    equationRgb: BlendEquation.ADD,\n    equationAlpha: BlendEquation.ADD,\n    functionSourceRgb: BlendFunction.ONE,\n    functionSourceAlpha: BlendFunction.ONE,\n    functionDestinationRgb: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n    functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n  }),\n\n  /**\n   * Blending is enabled using additive blending, <code>source(source.alpha) + destination</code>.\n   *\n   * @type {Object}\n   * @constant\n   */\n  ADDITIVE_BLEND: Object.freeze({\n    enabled: true,\n    equationRgb: BlendEquation.ADD,\n    equationAlpha: BlendEquation.ADD,\n    functionSourceRgb: BlendFunction.SOURCE_ALPHA,\n    functionSourceAlpha: BlendFunction.ONE,\n    functionDestinationRgb: BlendFunction.ONE,\n    functionDestinationAlpha: BlendFunction.ONE,\n  }),\n};\nexport default Object.freeze(BlendingState);\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\nconst defaultDimensions = new Cartesian3(1.0, 1.0, 1.0);\n\n/**\n * A ParticleEmitter that emits particles within a box.\n * Particles will be positioned randomly within the box and have initial velocities emanating from the center of the box.\n *\n * @alias BoxEmitter\n * @constructor\n *\n * @param {Cartesian3} dimensions The width, height and depth dimensions of the box.\n */\nfunction BoxEmitter(dimensions) {\n  dimensions = defaultValue(dimensions, defaultDimensions);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"dimensions\", dimensions);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.x\", dimensions.x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.y\", dimensions.y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"dimensions.z\", dimensions.z, 0.0);\n  //>>includeEnd('debug');\n\n  this._dimensions = Cartesian3.clone(dimensions);\n}\n\nObject.defineProperties(BoxEmitter.prototype, {\n  /**\n   * The width, height and depth dimensions of the box in meters.\n   * @memberof BoxEmitter.prototype\n   * @type {Cartesian3}\n   * @default new Cartesian3(1.0, 1.0, 1.0)\n   */\n  dimensions: {\n    get: function () {\n      return this._dimensions;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      Check.typeOf.number.greaterThanOrEquals(\"value.x\", value.x, 0.0);\n      Check.typeOf.number.greaterThanOrEquals(\"value.y\", value.y, 0.0);\n      Check.typeOf.number.greaterThanOrEquals(\"value.z\", value.z, 0.0);\n      //>>includeEnd('debug');\n      Cartesian3.clone(value, this._dimensions);\n    },\n  },\n});\n\nconst scratchHalfDim = new Cartesian3();\n\n/**\n * Initializes the given {Particle} by setting it's position and velocity.\n *\n * @private\n * @param {Particle} particle The particle to initialize.\n */\nBoxEmitter.prototype.emit = function (particle) {\n  const dim = this._dimensions;\n  const halfDim = Cartesian3.multiplyByScalar(dim, 0.5, scratchHalfDim);\n\n  const x = CesiumMath.randomBetween(-halfDim.x, halfDim.x);\n  const y = CesiumMath.randomBetween(-halfDim.y, halfDim.y);\n  const z = CesiumMath.randomBetween(-halfDim.z, halfDim.z);\n\n  particle.position = Cartesian3.fromElements(x, y, z, particle.position);\n  particle.velocity = Cartesian3.normalize(\n    particle.position,\n    particle.velocity\n  );\n};\nexport default BoxEmitter;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport BrdfLutGeneratorFS from \"../Shaders/BrdfLutGeneratorFS.js\";\n\n/**\n * @private\n */\nfunction BrdfLutGenerator() {\n  this._colorTexture = undefined;\n  this._drawCommand = undefined;\n}\n\nObject.defineProperties(BrdfLutGenerator.prototype, {\n  colorTexture: {\n    get: function () {\n      return this._colorTexture;\n    },\n  },\n});\n\nfunction createCommand(generator, context, framebuffer) {\n  const drawCommand = context.createViewportQuadCommand(BrdfLutGeneratorFS, {\n    framebuffer: framebuffer,\n    renderState: RenderState.fromCache({\n      viewport: new BoundingRectangle(0.0, 0.0, 256.0, 256.0),\n    }),\n  });\n\n  generator._drawCommand = drawCommand;\n}\n\nBrdfLutGenerator.prototype.update = function (frameState) {\n  if (!defined(this._colorTexture)) {\n    const context = frameState.context;\n    const colorTexture = new Texture({\n      context: context,\n      width: 256,\n      height: 256,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      sampler: Sampler.NEAREST,\n    });\n\n    this._colorTexture = colorTexture;\n    const framebuffer = new Framebuffer({\n      context: context,\n      colorTextures: [colorTexture],\n      destroyAttachments: false,\n    });\n\n    createCommand(this, context, framebuffer);\n    this._drawCommand.execute(context);\n    framebuffer.destroy();\n    this._drawCommand.shaderProgram =\n      this._drawCommand.shaderProgram &&\n      this._drawCommand.shaderProgram.destroy();\n  }\n};\n\nBrdfLutGenerator.prototype.isDestroyed = function () {\n  return false;\n};\n\nBrdfLutGenerator.prototype.destroy = function () {\n  this._colorTexture = this._colorTexture && this._colorTexture.destroy();\n  return destroyObject(this);\n};\nexport default BrdfLutGenerator;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads an embedded or external buffer.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias BufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {Uint8Array} [options.typedArray] The typed array containing the embedded buffer contents. Mutually exclusive with options.resource.\n * @param {Resource} [options.resource] The {@link Resource} pointing to the external buffer. Mutually exclusive with options.typedArray.\n * @param {String} [options.cacheKey] The cache key of the resource.\n *\n * @exception {DeveloperError} One of options.typedArray and options.resource must be defined.\n *\n * @private\n */\nexport default function BufferLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const typedArray = options.typedArray;\n  const resource = options.resource;\n  const cacheKey = options.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(typedArray) === defined(resource)) {\n    throw new DeveloperError(\n      \"One of options.typedArray and options.resource must be defined.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._typedArray = typedArray;\n  this._resource = resource;\n  this._cacheKey = cacheKey;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  BufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  BufferLoader.prototype.constructor = BufferLoader;\n}\n\nObject.defineProperties(BufferLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof BufferLoader.prototype\n   *\n   * @type {Promise.<BufferLoader>|undefined}\n   * @readonly\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof BufferLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The typed array containing the embedded buffer contents.\n   *\n   * @memberof BufferLoader.prototype\n   *\n   * @type {Uint8Array}\n   * @readonly\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<BufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nBufferLoader.prototype.load = function () {\n  if (defined(this._typedArray)) {\n    this._promise = Promise.resolve(this);\n  } else {\n    this._promise = loadExternalBuffer(this);\n  }\n  return this._promise;\n};\n\nfunction loadExternalBuffer(bufferLoader) {\n  const resource = bufferLoader._resource;\n  bufferLoader._state = ResourceLoaderState.LOADING;\n  return BufferLoader._fetchArrayBuffer(resource)\n    .then(function (arrayBuffer) {\n      if (bufferLoader.isDestroyed()) {\n        return;\n      }\n      bufferLoader._typedArray = new Uint8Array(arrayBuffer);\n      bufferLoader._state = ResourceLoaderState.READY;\n      return bufferLoader;\n    })\n    .catch(function (error) {\n      if (bufferLoader.isDestroyed()) {\n        return;\n      }\n      bufferLoader._state = ResourceLoaderState.FAILED;\n      const errorMessage = `Failed to load external buffer: ${resource.url}`;\n      return Promise.reject(bufferLoader.getError(errorMessage, error));\n    });\n}\n\n/**\n * Exposed for testing\n * @private\n */\nBufferLoader._fetchArrayBuffer = function (resource) {\n  return resource.fetchArrayBuffer();\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nBufferLoader.prototype.unload = function () {\n  this._typedArray = undefined;\n};\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeodesic from \"../Core/EllipsoidGeodesic.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraFlightPath from \"./CameraFlightPath.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * @typedef {Object} DirectionUp\n *\n * An orientation given by a pair of unit vectors\n *\n * @property {Cartesian3} direction The unit \"direction\" vector\n * @property {Cartesian3} up The unit \"up\" vector\n **/\n/**\n * @typedef {Object} HeadingPitchRollValues\n *\n * An orientation given by numeric heading, pitch, and roll\n *\n * @property {number} [heading=0.0] The heading in radians\n * @property {number} [pitch=-CesiumMath.PI_OVER_TWO] The pitch in radians\n * @property {number} [roll=0.0] The roll in meters\n **/\n\n/**\n * The camera is defined by a position, orientation, and view frustum.\n * <br /><br />\n * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.\n * <br /><br />\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias Camera\n *\n * @constructor\n *\n * @param {Scene} scene The scene.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html|Cesium Sandcastle Camera Tutorial Example}\n * @demo {@link https://cesium.com/learn/cesiumjs-learn/cesiumjs-camera|Camera Tutorial}\n *\n * @example\n * // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * const camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;\n */\nfunction Camera(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n  this._scene = scene;\n\n  this._transform = Matrix4.clone(Matrix4.IDENTITY);\n  this._invTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualInvTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._transformChanged = false;\n\n  /**\n   * The position of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.position = new Cartesian3();\n  this._position = new Cartesian3();\n  this._positionWC = new Cartesian3();\n  this._positionCartographic = new Cartographic();\n  this._oldPositionWC = undefined;\n\n  /**\n   * The position delta magnitude.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitude = 0.0;\n\n  /**\n   * The position delta magnitude last frame.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitudeLastFrame = 0.0;\n\n  /**\n   * How long in seconds since the camera has stopped moving\n   *\n   * @private\n   */\n  this.timeSinceMoved = 0.0;\n  this._lastMovedTimestamp = 0.0;\n\n  /**\n   * The view direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.direction = new Cartesian3();\n  this._direction = new Cartesian3();\n  this._directionWC = new Cartesian3();\n\n  /**\n   * The up direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.up = new Cartesian3();\n  this._up = new Cartesian3();\n  this._upWC = new Cartesian3();\n\n  /**\n   * The right direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.right = new Cartesian3();\n  this._right = new Cartesian3();\n  this._rightWC = new Cartesian3();\n\n  /**\n   * The region of space in view.\n   *\n   * @type {PerspectiveFrustum|PerspectiveOffCenterFrustum|OrthographicFrustum}\n   * @default PerspectiveFrustum()\n   *\n   * @see PerspectiveFrustum\n   * @see PerspectiveOffCenterFrustum\n   * @see OrthographicFrustum\n   */\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the move methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n  this.defaultMoveAmount = 100000.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the look methods.\n   * @type {Number}\n   * @default Math.PI / 60.0\n   */\n  this.defaultLookAmount = Math.PI / 60.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the rotate methods.\n   * @type {Number}\n   * @default Math.PI / 3600.0\n   */\n  this.defaultRotateAmount = Math.PI / 3600.0;\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the zoom methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n  this.defaultZoomAmount = 100000.0;\n  /**\n   * If set, the camera will not be able to rotate past this axis in either direction.\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  this.constrainedAxis = undefined;\n  /**\n   * The factor multiplied by the the map size used to determine where to clamp the camera position\n   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n   * @type {Number}\n   * @default 1.5\n   */\n  this.maximumZoomFactor = 1.5;\n\n  this._moveStart = new Event();\n  this._moveEnd = new Event();\n\n  this._changed = new Event();\n  this._changedPosition = undefined;\n  this._changedDirection = undefined;\n  this._changedFrustum = undefined;\n  this._changedHeading = undefined;\n\n  /**\n   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.\n   * @type {number}\n   * @default 0.5\n   */\n  this.percentageChanged = 0.5;\n\n  this._viewMatrix = new Matrix4();\n  this._invViewMatrix = new Matrix4();\n  updateViewMatrix(this);\n\n  this._mode = SceneMode.SCENE3D;\n  this._modeChanged = true;\n  const projection = scene.mapProjection;\n  this._projection = projection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO)\n  );\n  this._max2Dfrustum = undefined;\n\n  // set default view\n  rectangleCameraPosition3D(\n    this,\n    Camera.DEFAULT_VIEW_RECTANGLE,\n    this.position,\n    true\n  );\n\n  let mag = Cartesian3.magnitude(this.position);\n  mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n  Cartesian3.normalize(this.position, this.position);\n  Cartesian3.multiplyByScalar(this.position, mag, this.position);\n}\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D = new Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D_INVERSE = Matrix4.inverseTransformation(\n  Camera.TRANSFORM_2D,\n  new Matrix4()\n);\n\n/**\n * The default rectangle the camera will view on creation.\n * @type Rectangle\n */\nCamera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(\n  -95.0,\n  -20.0,\n  -70.0,\n  90.0\n);\n\n/**\n * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.\n * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero\n * will move it further away from the extent, and a value less than zero will move it close to the extent.\n * @type Number\n */\nCamera.DEFAULT_VIEW_FACTOR = 0.5;\n\n/**\n * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n * @type HeadingPitchRange\n */\nCamera.DEFAULT_OFFSET = new HeadingPitchRange(\n  0.0,\n  -CesiumMath.PI_OVER_FOUR,\n  0.0\n);\n\nfunction updateViewMatrix(camera) {\n  Matrix4.computeView(\n    camera._position,\n    camera._direction,\n    camera._up,\n    camera._right,\n    camera._viewMatrix\n  );\n  Matrix4.multiply(\n    camera._viewMatrix,\n    camera._actualInvTransform,\n    camera._viewMatrix\n  );\n  Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);\n}\n\nfunction updateCameraDeltas(camera) {\n  if (!defined(camera._oldPositionWC)) {\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC\n    );\n  } else {\n    camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;\n    const delta = Cartesian3.subtract(\n      camera.positionWC,\n      camera._oldPositionWC,\n      camera._oldPositionWC\n    );\n    camera.positionWCDeltaMagnitude = Cartesian3.magnitude(delta);\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC\n    );\n\n    // Update move timers\n    if (camera.positionWCDeltaMagnitude > 0.0) {\n      camera.timeSinceMoved = 0.0;\n      camera._lastMovedTimestamp = getTimestamp();\n    } else {\n      camera.timeSinceMoved =\n        Math.max(getTimestamp() - camera._lastMovedTimestamp, 0.0) / 1000.0;\n    }\n  }\n}\n\n/**\n * Checks if there's a camera flight with preload for this camera.\n *\n * @returns {Boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.\n *\n * @private\n *\n */\nCamera.prototype.canPreloadFlight = function () {\n  return defined(this._currentFlight) && this._mode !== SceneMode.SCENE2D;\n};\n\nCamera.prototype._updateCameraChanged = function () {\n  const camera = this;\n\n  updateCameraDeltas(camera);\n\n  if (camera._changed.numberOfListeners === 0) {\n    return;\n  }\n\n  const percentageChanged = camera.percentageChanged;\n\n  const currentHeading = camera.heading;\n\n  if (!defined(camera._changedHeading)) {\n    camera._changedHeading = currentHeading;\n  }\n\n  let delta =\n    Math.abs(camera._changedHeading - currentHeading) % CesiumMath.TWO_PI;\n  delta = delta > CesiumMath.PI ? CesiumMath.TWO_PI - delta : delta;\n\n  // Since delta is computed as the shortest distance between two angles\n  // the percentage is relative to the half circle.\n  const headingChangedPercentage = delta / Math.PI;\n\n  if (headingChangedPercentage > percentageChanged) {\n    camera._changed.raiseEvent(headingChangedPercentage);\n    camera._changedHeading = currentHeading;\n  }\n\n  if (camera._mode === SceneMode.SCENE2D) {\n    if (!defined(camera._changedFrustum)) {\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition\n      );\n      camera._changedFrustum = camera.frustum.clone();\n      return;\n    }\n\n    const position = camera.position;\n    const lastPosition = camera._changedPosition;\n\n    const frustum = camera.frustum;\n    const lastFrustum = camera._changedFrustum;\n\n    const x0 = position.x + frustum.left;\n    const x1 = position.x + frustum.right;\n    const x2 = lastPosition.x + lastFrustum.left;\n    const x3 = lastPosition.x + lastFrustum.right;\n\n    const y0 = position.y + frustum.bottom;\n    const y1 = position.y + frustum.top;\n    const y2 = lastPosition.y + lastFrustum.bottom;\n    const y3 = lastPosition.y + lastFrustum.top;\n\n    const leftX = Math.max(x0, x2);\n    const rightX = Math.min(x1, x3);\n    const bottomY = Math.max(y0, y2);\n    const topY = Math.min(y1, y3);\n\n    let areaPercentage;\n    if (leftX >= rightX || bottomY >= y1) {\n      areaPercentage = 1.0;\n    } else {\n      let areaRef = lastFrustum;\n      if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {\n        areaRef = frustum;\n      }\n      areaPercentage =\n        1.0 -\n        ((rightX - leftX) * (topY - bottomY)) /\n          ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));\n    }\n\n    if (areaPercentage > percentageChanged) {\n      camera._changed.raiseEvent(areaPercentage);\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition\n      );\n      camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);\n    }\n    return;\n  }\n\n  if (!defined(camera._changedDirection)) {\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection\n    );\n    return;\n  }\n\n  const dirAngle = CesiumMath.acosClamped(\n    Cartesian3.dot(camera.directionWC, camera._changedDirection)\n  );\n\n  let dirPercentage;\n  if (defined(camera.frustum.fovy)) {\n    dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);\n  } else {\n    dirPercentage = dirAngle;\n  }\n\n  const distance = Cartesian3.distance(\n    camera.positionWC,\n    camera._changedPosition\n  );\n  const heightPercentage = distance / camera.positionCartographic.height;\n\n  if (\n    dirPercentage > percentageChanged ||\n    heightPercentage > percentageChanged\n  ) {\n    camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection\n    );\n  }\n};\n\nfunction convertTransformForColumbusView(camera) {\n  Transforms.basisTo2D(\n    camera._projection,\n    camera._transform,\n    camera._actualTransform\n  );\n}\n\nconst scratchCartographic = new Cartographic();\nconst scratchCartesian3Projection = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4Origin = new Cartesian4();\nconst scratchCartesian4NewOrigin = new Cartesian4();\nconst scratchCartesian4NewXAxis = new Cartesian4();\nconst scratchCartesian4NewYAxis = new Cartesian4();\nconst scratchCartesian4NewZAxis = new Cartesian4();\n\nfunction convertTransformFor2D(camera) {\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n\n  const origin = Matrix4.getColumn(\n    camera._transform,\n    3,\n    scratchCartesian4Origin\n  );\n  const cartographic = ellipsoid.cartesianToCartographic(\n    origin,\n    scratchCartographic\n  );\n\n  const projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection\n  );\n  const newOrigin = scratchCartesian4NewOrigin;\n  newOrigin.x = projectedPosition.z;\n  newOrigin.y = projectedPosition.x;\n  newOrigin.z = projectedPosition.y;\n  newOrigin.w = 1.0;\n\n  const newZAxis = Cartesian4.clone(\n    Cartesian4.UNIT_X,\n    scratchCartesian4NewZAxis\n  );\n\n  const xAxis = Cartesian4.add(\n    Matrix4.getColumn(camera._transform, 0, scratchCartesian3),\n    origin,\n    scratchCartesian3\n  );\n  ellipsoid.cartesianToCartographic(xAxis, cartographic);\n\n  projection.project(cartographic, projectedPosition);\n  const newXAxis = scratchCartesian4NewXAxis;\n  newXAxis.x = projectedPosition.z;\n  newXAxis.y = projectedPosition.x;\n  newXAxis.z = projectedPosition.y;\n  newXAxis.w = 0.0;\n\n  Cartesian3.subtract(newXAxis, newOrigin, newXAxis);\n  newXAxis.x = 0.0;\n\n  const newYAxis = scratchCartesian4NewYAxis;\n  if (Cartesian3.magnitudeSquared(newXAxis) > CesiumMath.EPSILON10) {\n    Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  } else {\n    const yAxis = Cartesian4.add(\n      Matrix4.getColumn(camera._transform, 1, scratchCartesian3),\n      origin,\n      scratchCartesian3\n    );\n    ellipsoid.cartesianToCartographic(yAxis, cartographic);\n\n    projection.project(cartographic, projectedPosition);\n    newYAxis.x = projectedPosition.z;\n    newYAxis.y = projectedPosition.x;\n    newYAxis.z = projectedPosition.y;\n    newYAxis.w = 0.0;\n\n    Cartesian3.subtract(newYAxis, newOrigin, newYAxis);\n    newYAxis.x = 0.0;\n\n    if (Cartesian3.magnitudeSquared(newYAxis) < CesiumMath.EPSILON10) {\n      Cartesian4.clone(Cartesian4.UNIT_Y, newXAxis);\n      Cartesian4.clone(Cartesian4.UNIT_Z, newYAxis);\n    }\n  }\n\n  Cartesian3.cross(newYAxis, newZAxis, newXAxis);\n  Cartesian3.normalize(newXAxis, newXAxis);\n  Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  Cartesian3.normalize(newYAxis, newYAxis);\n\n  Matrix4.setColumn(\n    camera._actualTransform,\n    0,\n    newXAxis,\n    camera._actualTransform\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    1,\n    newYAxis,\n    camera._actualTransform\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    2,\n    newZAxis,\n    camera._actualTransform\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    3,\n    newOrigin,\n    camera._actualTransform\n  );\n}\n\nconst scratchCartesian = new Cartesian3();\n\nfunction updateMembers(camera) {\n  const mode = camera._mode;\n\n  let heightChanged = false;\n  let height = 0.0;\n  if (mode === SceneMode.SCENE2D) {\n    height = camera.frustum.right - camera.frustum.left;\n    heightChanged = height !== camera._positionCartographic.height;\n  }\n\n  let position = camera._position;\n  const positionChanged =\n    !Cartesian3.equals(position, camera.position) || heightChanged;\n  if (positionChanged) {\n    position = Cartesian3.clone(camera.position, camera._position);\n  }\n\n  let direction = camera._direction;\n  const directionChanged = !Cartesian3.equals(direction, camera.direction);\n  if (directionChanged) {\n    Cartesian3.normalize(camera.direction, camera.direction);\n    direction = Cartesian3.clone(camera.direction, camera._direction);\n  }\n\n  let up = camera._up;\n  const upChanged = !Cartesian3.equals(up, camera.up);\n  if (upChanged) {\n    Cartesian3.normalize(camera.up, camera.up);\n    up = Cartesian3.clone(camera.up, camera._up);\n  }\n\n  let right = camera._right;\n  const rightChanged = !Cartesian3.equals(right, camera.right);\n  if (rightChanged) {\n    Cartesian3.normalize(camera.right, camera.right);\n    right = Cartesian3.clone(camera.right, camera._right);\n  }\n\n  const transformChanged = camera._transformChanged || camera._modeChanged;\n  camera._transformChanged = false;\n\n  if (transformChanged) {\n    Matrix4.inverseTransformation(camera._transform, camera._invTransform);\n\n    if (\n      camera._mode === SceneMode.COLUMBUS_VIEW ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      if (Matrix4.equals(Matrix4.IDENTITY, camera._transform)) {\n        Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);\n      } else if (camera._mode === SceneMode.COLUMBUS_VIEW) {\n        convertTransformForColumbusView(camera);\n      } else {\n        convertTransformFor2D(camera);\n      }\n    } else {\n      Matrix4.clone(camera._transform, camera._actualTransform);\n    }\n\n    Matrix4.inverseTransformation(\n      camera._actualTransform,\n      camera._actualInvTransform\n    );\n\n    camera._modeChanged = false;\n  }\n\n  const transform = camera._actualTransform;\n\n  if (positionChanged || transformChanged) {\n    camera._positionWC = Matrix4.multiplyByPoint(\n      transform,\n      position,\n      camera._positionWC\n    );\n\n    // Compute the Cartographic position of the camera.\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.MORPHING) {\n      camera._positionCartographic = camera._projection.ellipsoid.cartesianToCartographic(\n        camera._positionWC,\n        camera._positionCartographic\n      );\n    } else {\n      // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,\n      // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n      // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n      const positionENU = scratchCartesian;\n      positionENU.x = camera._positionWC.y;\n      positionENU.y = camera._positionWC.z;\n      positionENU.z = camera._positionWC.x;\n\n      // In 2D, the camera height is always 12.7 million meters.\n      // The apparent height is equal to half the frustum width.\n      if (mode === SceneMode.SCENE2D) {\n        positionENU.z = height;\n      }\n\n      camera._projection.unproject(positionENU, camera._positionCartographic);\n    }\n  }\n\n  if (directionChanged || upChanged || rightChanged) {\n    const det = Cartesian3.dot(\n      direction,\n      Cartesian3.cross(up, right, scratchCartesian)\n    );\n    if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {\n      //orthonormalize axes\n      const invUpMag = 1.0 / Cartesian3.magnitudeSquared(up);\n      const scalar = Cartesian3.dot(up, direction) * invUpMag;\n      const w0 = Cartesian3.multiplyByScalar(\n        direction,\n        scalar,\n        scratchCartesian\n      );\n      up = Cartesian3.normalize(\n        Cartesian3.subtract(up, w0, camera._up),\n        camera._up\n      );\n      Cartesian3.clone(up, camera.up);\n\n      right = Cartesian3.cross(direction, up, camera._right);\n      Cartesian3.clone(right, camera.right);\n    }\n  }\n\n  if (directionChanged || transformChanged) {\n    camera._directionWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      direction,\n      camera._directionWC\n    );\n    Cartesian3.normalize(camera._directionWC, camera._directionWC);\n  }\n\n  if (upChanged || transformChanged) {\n    camera._upWC = Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);\n    Cartesian3.normalize(camera._upWC, camera._upWC);\n  }\n\n  if (rightChanged || transformChanged) {\n    camera._rightWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      right,\n      camera._rightWC\n    );\n    Cartesian3.normalize(camera._rightWC, camera._rightWC);\n  }\n\n  if (\n    positionChanged ||\n    directionChanged ||\n    upChanged ||\n    rightChanged ||\n    transformChanged\n  ) {\n    updateViewMatrix(camera);\n  }\n}\n\nfunction getHeading(direction, up) {\n  let heading;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    heading = Math.atan2(direction.y, direction.x) - CesiumMath.PI_OVER_TWO;\n  } else {\n    heading = Math.atan2(up.y, up.x) - CesiumMath.PI_OVER_TWO;\n  }\n\n  return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(heading);\n}\n\nfunction getPitch(direction) {\n  return CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(direction.z);\n}\n\nfunction getRoll(direction, up, right) {\n  let roll = 0.0;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    roll = Math.atan2(-right.z, up.z);\n    roll = CesiumMath.zeroToTwoPi(roll + CesiumMath.TWO_PI);\n  }\n\n  return roll;\n}\n\nconst scratchHPRMatrix1 = new Matrix4();\nconst scratchHPRMatrix2 = new Matrix4();\n\nObject.defineProperties(Camera.prototype, {\n  /**\n   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n  },\n\n  /**\n   * Gets the inverse camera transform.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  inverseTransform: {\n    get: function () {\n      updateMembers(this);\n      return this._invTransform;\n    },\n  },\n\n  /**\n   * Gets the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#inverseViewMatrix\n   */\n  viewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._viewMatrix;\n    },\n  },\n\n  /**\n   * Gets the inverse view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#viewMatrix\n   */\n  inverseViewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._invViewMatrix;\n    },\n  },\n\n  /**\n   * Gets the {@link Cartographic} position of the camera, with longitude and latitude\n   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible\n   * for the returned longitude and latitude to be outside the range of valid longitudes\n   * and latitudes when the camera is outside the map.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartographic}\n   * @readonly\n   */\n  positionCartographic: {\n    get: function () {\n      updateMembers(this);\n      return this._positionCartographic;\n    },\n  },\n\n  /**\n   * Gets the position of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  positionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._positionWC;\n    },\n  },\n\n  /**\n   * Gets the view direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  directionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._directionWC;\n    },\n  },\n\n  /**\n   * Gets the up direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  upWC: {\n    get: function () {\n      updateMembers(this);\n      return this._upWC;\n    },\n  },\n\n  /**\n   * Gets the right direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rightWC: {\n    get: function () {\n      updateMembers(this);\n      return this._rightWC;\n    },\n  },\n\n  /**\n   * Gets the camera heading in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        const heading = getHeading(this.direction, this.up);\n\n        this._setTransform(oldTransform);\n\n        return heading;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera pitch in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pitch: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        const pitch = getPitch(this.direction);\n\n        this._setTransform(oldTransform);\n\n        return pitch;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera roll in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  roll: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        const ellipsoid = this._projection.ellipsoid;\n\n        const oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        const transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        const roll = getRoll(this.direction, this.up, this.right);\n\n        this._setTransform(oldTransform);\n\n        return roll;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised at when the camera starts to move.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveStart: {\n    get: function () {\n      return this._moveStart;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has stopped moving.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveEnd: {\n    get: function () {\n      return this._moveEnd;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changed: {\n    get: function () {\n      return this._changed;\n    },\n  },\n});\n\n/**\n * @private\n */\nCamera.prototype.update = function (mode) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(mode)) {\n    throw new DeveloperError(\"mode is required.\");\n  }\n  if (\n    mode === SceneMode.SCENE2D &&\n    !(this.frustum instanceof OrthographicOffCenterFrustum)\n  ) {\n    throw new DeveloperError(\n      \"An OrthographicOffCenterFrustum is required in 2D.\"\n    );\n  }\n  if (\n    (mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) &&\n    !(this.frustum instanceof PerspectiveFrustum) &&\n    !(this.frustum instanceof OrthographicFrustum)\n  ) {\n    throw new DeveloperError(\n      \"A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let updateFrustum = false;\n  if (mode !== this._mode) {\n    this._mode = mode;\n    this._modeChanged = mode !== SceneMode.MORPHING;\n    updateFrustum = this._mode === SceneMode.SCENE2D;\n  }\n\n  if (updateFrustum) {\n    const frustum = (this._max2Dfrustum = this.frustum.clone());\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!(frustum instanceof OrthographicOffCenterFrustum)) {\n      throw new DeveloperError(\n        \"The camera frustum is expected to be orthographic for 2D camera control.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    const maxZoomOut = 2.0;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = this._maxCoord.x * maxZoomOut;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, this.position);\n  }\n};\n\nconst setTransformPosition = new Cartesian3();\nconst setTransformUp = new Cartesian3();\nconst setTransformDirection = new Cartesian3();\n\nCamera.prototype._setTransform = function (transform) {\n  const position = Cartesian3.clone(this.positionWC, setTransformPosition);\n  const up = Cartesian3.clone(this.upWC, setTransformUp);\n  const direction = Cartesian3.clone(this.directionWC, setTransformDirection);\n\n  Matrix4.clone(transform, this._transform);\n  this._transformChanged = true;\n  updateMembers(this);\n  const inverse = this._actualInvTransform;\n\n  Matrix4.multiplyByPoint(inverse, position, this.position);\n  Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);\n  Matrix4.multiplyByPointAsVector(inverse, up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n\n  updateMembers(this);\n};\n\nconst scratchAdjustOrthographicFrustumMousePosition = new Cartesian2();\nconst scratchPickRay = new Ray();\nconst scratchRayIntersection = new Cartesian3();\nconst scratchDepthIntersection = new Cartesian3();\n\nfunction calculateOrthographicFrustumWidth(camera) {\n  // Camera is fixed to an object, so keep frustum width constant.\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    return Cartesian3.magnitude(camera.position);\n  }\n\n  const scene = camera._scene;\n  const globe = scene.globe;\n\n  const mousePosition = scratchAdjustOrthographicFrustumMousePosition;\n  mousePosition.x = scene.drawingBufferWidth / 2.0;\n  mousePosition.y = scene.drawingBufferHeight / 2.0;\n\n  let rayIntersection;\n  if (defined(globe)) {\n    const ray = camera.getPickRay(mousePosition, scratchPickRay);\n    rayIntersection = globe.pickWorldCoordinates(\n      ray,\n      scene,\n      true,\n      scratchRayIntersection\n    );\n  }\n\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection\n    );\n  }\n\n  let distance;\n  if (defined(rayIntersection) || defined(depthIntersection)) {\n    const depthDistance = defined(depthIntersection)\n      ? Cartesian3.distance(depthIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    const rayDistance = defined(rayIntersection)\n      ? Cartesian3.distance(rayIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    distance = Math.min(depthDistance, rayDistance);\n  } else {\n    distance = Math.max(camera.positionCartographic.height, 0.0);\n  }\n  return distance;\n}\n\nCamera.prototype._adjustOrthographicFrustum = function (zooming) {\n  if (!(this.frustum instanceof OrthographicFrustum)) {\n    return;\n  }\n\n  if (!zooming && this._positionCartographic.height < 150000.0) {\n    return;\n  }\n\n  this.frustum.width = calculateOrthographicFrustumWidth(this);\n};\n\nconst scratchSetViewCartesian = new Cartesian3();\nconst scratchSetViewTransform1 = new Matrix4();\nconst scratchSetViewTransform2 = new Matrix4();\nconst scratchSetViewQuaternion = new Quaternion();\nconst scratchSetViewMatrix3 = new Matrix3();\nconst scratchSetViewCartographic = new Cartographic();\n\nfunction setView3D(camera, position, hpr) {\n  const currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  const localTransform = Transforms.eastNorthUpToFixedFrame(\n    position,\n    camera._projection.ellipsoid,\n    scratchSetViewTransform2\n  );\n  camera._setTransform(localTransform);\n\n  Cartesian3.clone(Cartesian3.ZERO, camera.position);\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  const rotQuat = Quaternion.fromHeadingPitchRoll(\n    hpr,\n    scratchSetViewQuaternion\n  );\n  const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setViewCV(camera, position, hpr, convert) {\n  const currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n    Cartesian3.clone(position, camera.position);\n  }\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  const rotQuat = Quaternion.fromHeadingPitchRoll(\n    hpr,\n    scratchSetViewQuaternion\n  );\n  const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setView2D(camera, position, hpr, convert) {\n  const currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      const projection = camera._projection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Cartesian2.clone(position, camera.position);\n\n    const newLeft = -position.z * 0.5;\n    const newRight = -newLeft;\n\n    const frustum = camera.frustum;\n    if (newRight > newLeft) {\n      const ratio = frustum.top / frustum.right;\n      frustum.right = newRight;\n      frustum.left = newLeft;\n      frustum.top = frustum.right * ratio;\n      frustum.bottom = -frustum.top;\n    }\n  }\n\n  if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n    hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n    hpr.pitch = -CesiumMath.PI_OVER_TWO;\n    hpr.roll = 0.0;\n    const rotQuat = Quaternion.fromHeadingPitchRoll(\n      hpr,\n      scratchSetViewQuaternion\n    );\n    const rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n    Matrix3.getColumn(rotMat, 2, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n  }\n\n  camera._setTransform(currentTransform);\n}\n\nconst scratchToHPRDirection = new Cartesian3();\nconst scratchToHPRUp = new Cartesian3();\nconst scratchToHPRRight = new Cartesian3();\n\nfunction directionUpToHeadingPitchRoll(camera, position, orientation, result) {\n  const direction = Cartesian3.clone(\n    orientation.direction,\n    scratchToHPRDirection\n  );\n  const up = Cartesian3.clone(orientation.up, scratchToHPRUp);\n\n  if (camera._scene.mode === SceneMode.SCENE3D) {\n    const ellipsoid = camera._projection.ellipsoid;\n    const transform = Transforms.eastNorthUpToFixedFrame(\n      position,\n      ellipsoid,\n      scratchHPRMatrix1\n    );\n    const invTransform = Matrix4.inverseTransformation(\n      transform,\n      scratchHPRMatrix2\n    );\n\n    Matrix4.multiplyByPointAsVector(invTransform, direction, direction);\n    Matrix4.multiplyByPointAsVector(invTransform, up, up);\n  }\n\n  const right = Cartesian3.cross(direction, up, scratchToHPRRight);\n\n  result.heading = getHeading(direction, up);\n  result.pitch = getPitch(direction);\n  result.roll = getRoll(direction, up, right);\n\n  return result;\n}\n\nconst scratchSetViewOptions = {\n  destination: undefined,\n  orientation: {\n    direction: undefined,\n    up: undefined,\n    heading: undefined,\n    pitch: undefined,\n    roll: undefined,\n  },\n  convert: undefined,\n  endTransform: undefined,\n};\n\nconst scratchHpr = new HeadingPitchRoll();\n/**\n * Sets the camera position, orientation and transform.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {HeadingPitchRollValues|DirectionUp} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n *\n * @example\n * // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n */\nCamera.prototype.setView = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let orientation = defaultValue(\n    options.orientation,\n    defaultValue.EMPTY_OBJECT\n  );\n\n  const mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (defined(options.endTransform)) {\n    this._setTransform(options.endTransform);\n  }\n\n  let convert = defaultValue(options.convert, true);\n  let destination = defaultValue(\n    options.destination,\n    Cartesian3.clone(this.positionWC, scratchSetViewCartesian)\n  );\n  if (defined(destination) && defined(destination.west)) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchSetViewCartesian\n    );\n    convert = false;\n  }\n\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation\n    );\n  }\n\n  scratchHpr.heading = defaultValue(orientation.heading, 0.0);\n  scratchHpr.pitch = defaultValue(orientation.pitch, -CesiumMath.PI_OVER_TWO);\n  scratchHpr.roll = defaultValue(orientation.roll, 0.0);\n\n  if (mode === SceneMode.SCENE3D) {\n    setView3D(this, destination, scratchHpr);\n  } else if (mode === SceneMode.SCENE2D) {\n    setView2D(this, destination, scratchHpr, convert);\n  } else {\n    setViewCV(this, destination, scratchHpr, convert);\n  }\n};\n\nconst pitchScratch = new Cartesian3();\n/**\n * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set\n * the default view for the 3D scene.  The home view for 2D and columbus view shows the\n * entire map.\n *\n * @param {Number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}\n */\nCamera.prototype.flyHome = function (duration) {\n  const mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    this._scene.completeMorph();\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    this.flyTo({\n      destination: Camera.DEFAULT_VIEW_RECTANGLE,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.SCENE3D) {\n    const destination = this.getRectangleCameraCoordinates(\n      Camera.DEFAULT_VIEW_RECTANGLE\n    );\n\n    let mag = Cartesian3.magnitude(destination);\n    mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n    Cartesian3.normalize(destination, destination);\n    Cartesian3.multiplyByScalar(destination, mag, destination);\n\n    this.flyTo({\n      destination: destination,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    const maxRadii = this._projection.ellipsoid.maximumRadius;\n    let position = new Cartesian3(0.0, -1.0, 1.0);\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(position, position),\n      5.0 * maxRadii,\n      position\n    );\n    this.flyTo({\n      destination: position,\n      duration: duration,\n      orientation: {\n        heading: 0.0,\n        pitch: -Math.acos(Cartesian3.normalize(position, pitchScratch).z),\n        roll: 0.0,\n      },\n      endTransform: Matrix4.IDENTITY,\n      convert: false,\n    });\n  }\n};\n\n/**\n * Transform a vector or point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.worldToCameraCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualInvTransform,\n    cartesian,\n    result\n  );\n};\n\n/**\n * Transform a vector or point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.cameraToWorldCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualTransform,\n    cartesian,\n    result\n  );\n};\n\nfunction clampMove2D(camera, position) {\n  const rotatable2D = camera._scene.mapMode2D === MapMode2D.ROTATE;\n  const maxProjectedX = camera._maxCoord.x;\n  const maxProjectedY = camera._maxCoord.y;\n\n  let minX;\n  let maxX;\n  if (rotatable2D) {\n    maxX = maxProjectedX;\n    minX = -maxX;\n  } else {\n    maxX = position.x - maxProjectedX * 2.0;\n    minX = position.x + maxProjectedX * 2.0;\n  }\n\n  if (position.x > maxProjectedX) {\n    position.x = maxX;\n  }\n  if (position.x < -maxProjectedX) {\n    position.x = minX;\n  }\n\n  if (position.y > maxProjectedY) {\n    position.y = maxProjectedY;\n  }\n  if (position.y < -maxProjectedY) {\n    position.y = -maxProjectedY;\n  }\n}\n\nconst moveScratch = new Cartesian3();\n/**\n * Translates the camera's position by <code>amount</code> along <code>direction</code>.\n *\n * @param {Cartesian3} direction The direction to move.\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n * @see Camera#moveForward\n * @see Camera#moveLeft\n * @see Camera#moveRight\n * @see Camera#moveUp\n * @see Camera#moveDown\n */\nCamera.prototype.move = function (direction, amount) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const cameraPosition = this.position;\n  Cartesian3.multiplyByScalar(direction, amount, moveScratch);\n  Cartesian3.add(cameraPosition, moveScratch, cameraPosition);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, cameraPosition);\n  }\n  this._adjustOrthographicFrustum(true);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's view vector.\n * When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n */\nCamera.prototype.moveForward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's view vector.\n * When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveForward\n */\nCamera.prototype.moveBackward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, -amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, -amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveDown\n */\nCamera.prototype.moveUp = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveUp\n */\nCamera.prototype.moveDown = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, -amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveLeft\n */\nCamera.prototype.moveRight = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveRight\n */\nCamera.prototype.moveLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, -amount);\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the opposite direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookRight\n */\nCamera.prototype.lookLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookLeft\n */\nCamera.prototype.lookRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookDown\n */\nCamera.prototype.lookUp = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the opposite direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n */\nCamera.prototype.lookDown = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, amount);\n  }\n};\n\nconst lookScratchQuaternion = new Quaternion();\nconst lookScratchMatrix = new Matrix3();\n/**\n * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>\n *\n * @param {Cartesian3} axis The axis to rotate around.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n * @see Camera#lookDown\n * @see Camera#lookLeft\n * @see Camera#lookRight\n */\nCamera.prototype.look = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = defaultValue(angle, this.defaultLookAmount);\n  const quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    lookScratchQuaternion\n  );\n  const rotation = Matrix3.fromQuaternion(quaternion, lookScratchMatrix);\n\n  const direction = this.direction;\n  const up = this.up;\n  const right = this.right;\n\n  Matrix3.multiplyByVector(rotation, direction, direction);\n  Matrix3.multiplyByVector(rotation, up, up);\n  Matrix3.multiplyByVector(rotation, right, right);\n};\n\n/**\n * Rotate the camera counter-clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistRight\n */\nCamera.prototype.twistLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, amount);\n};\n\n/**\n * Rotate the camera clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistLeft\n */\nCamera.prototype.twistRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, -amount);\n};\n\nconst rotateScratchQuaternion = new Quaternion();\nconst rotateScratchMatrix = new Matrix3();\n/**\n * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance\n * of the camera's position to the center of the camera's reference frame remains the same.\n *\n * @param {Cartesian3} axis The axis to rotate around given in world coordinates.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotateDown\n * @see Camera#rotateLeft\n * @see Camera#rotateRight\n */\nCamera.prototype.rotate = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const turnAngle = defaultValue(angle, this.defaultRotateAmount);\n  const quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    rotateScratchQuaternion\n  );\n  const rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);\n  Matrix3.multiplyByVector(rotation, this.position, this.position);\n  Matrix3.multiplyByVector(rotation, this.direction, this.direction);\n  Matrix3.multiplyByVector(rotation, this.up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n\n  this._adjustOrthographicFrustum(false);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle downwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotate\n */\nCamera.prototype.rotateDown = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle upwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateDown\n * @see Camera#rotate\n */\nCamera.prototype.rotateUp = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, -angle);\n};\n\nconst rotateVertScratchP = new Cartesian3();\nconst rotateVertScratchA = new Cartesian3();\nconst rotateVertScratchTan = new Cartesian3();\nconst rotateVertScratchNegate = new Cartesian3();\nfunction rotateVertical(camera, angle) {\n  const position = camera.position;\n  if (\n    defined(camera.constrainedAxis) &&\n    !Cartesian3.equalsEpsilon(\n      camera.position,\n      Cartesian3.ZERO,\n      CesiumMath.EPSILON2\n    )\n  ) {\n    const p = Cartesian3.normalize(position, rotateVertScratchP);\n    const northParallel = Cartesian3.equalsEpsilon(\n      p,\n      camera.constrainedAxis,\n      CesiumMath.EPSILON2\n    );\n    const southParallel = Cartesian3.equalsEpsilon(\n      p,\n      Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate),\n      CesiumMath.EPSILON2\n    );\n    if (!northParallel && !southParallel) {\n      const constrainedAxis = Cartesian3.normalize(\n        camera.constrainedAxis,\n        rotateVertScratchA\n      );\n\n      let dot = Cartesian3.dot(p, constrainedAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(\n        p,\n        Cartesian3.negate(constrainedAxis, rotateVertScratchNegate)\n      );\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      const tangent = Cartesian3.cross(\n        constrainedAxis,\n        p,\n        rotateVertScratchTan\n      );\n      camera.rotate(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.rotate(camera.right, angle);\n    }\n  } else {\n    camera.rotate(camera.right, angle);\n  }\n}\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the right.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateLeft\n * @see Camera#rotate\n */\nCamera.prototype.rotateRight = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, -angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the left.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateRight\n * @see Camera#rotate\n */\nCamera.prototype.rotateLeft = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, angle);\n};\n\nfunction rotateHorizontal(camera, angle) {\n  if (defined(camera.constrainedAxis)) {\n    camera.rotate(camera.constrainedAxis, angle);\n  } else {\n    camera.rotate(camera.up, angle);\n  }\n}\n\nfunction zoom2D(camera, amount) {\n  const frustum = camera.frustum;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !(frustum instanceof OrthographicOffCenterFrustum) ||\n    !defined(frustum.left) ||\n    !defined(frustum.right) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.top)\n  ) {\n    throw new DeveloperError(\n      \"The camera frustum is expected to be orthographic for 2D camera control.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let ratio;\n  amount = amount * 0.5;\n\n  if (\n    Math.abs(frustum.top) + Math.abs(frustum.bottom) >\n    Math.abs(frustum.left) + Math.abs(frustum.right)\n  ) {\n    let newTop = frustum.top - amount;\n    let newBottom = frustum.bottom + amount;\n\n    let maxBottom = camera._maxCoord.y;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxBottom *= camera.maximumZoomFactor;\n    }\n\n    if (newBottom > maxBottom) {\n      newBottom = maxBottom;\n      newTop = -maxBottom;\n    }\n\n    if (newTop <= newBottom) {\n      newTop = 1.0;\n      newBottom = -1.0;\n    }\n\n    ratio = frustum.right / frustum.top;\n    frustum.top = newTop;\n    frustum.bottom = newBottom;\n    frustum.right = frustum.top * ratio;\n    frustum.left = -frustum.right;\n  } else {\n    let newRight = frustum.right - amount;\n    let newLeft = frustum.left + amount;\n\n    let maxRight = camera._maxCoord.x;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxRight *= camera.maximumZoomFactor;\n    }\n\n    if (newRight > maxRight) {\n      newRight = maxRight;\n      newLeft = -maxRight;\n    }\n\n    if (newRight <= newLeft) {\n      newRight = 1.0;\n      newLeft = -1.0;\n    }\n    ratio = frustum.top / frustum.right;\n    frustum.right = newRight;\n    frustum.left = newLeft;\n    frustum.top = frustum.right * ratio;\n    frustum.bottom = -frustum.top;\n  }\n}\n\nfunction zoom3D(camera, amount) {\n  camera.move(camera.direction, amount);\n}\n\n/**\n * Zooms <code>amount</code> along the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomOut\n */\nCamera.prototype.zoomIn = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, amount);\n  } else {\n    zoom3D(this, amount);\n  }\n};\n\n/**\n * Zooms <code>amount</code> along the opposite direction of\n * the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomIn\n */\nCamera.prototype.zoomOut = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, -amount);\n  } else {\n    zoom3D(this, -amount);\n  }\n};\n\n/**\n * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and\n * Columbus view, this is the distance to the map.\n *\n * @returns {Number} The magnitude of the position.\n */\nCamera.prototype.getMagnitude = function () {\n  if (this._mode === SceneMode.SCENE3D) {\n    return Cartesian3.magnitude(this.position);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(this.position.z);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    return Math.max(\n      this.frustum.right - this.frustum.left,\n      this.frustum.top - this.frustum.bottom\n    );\n  }\n};\n\nconst scratchLookAtMatrix4 = new Matrix4();\n\n/**\n * Sets the camera position and orientation using a target and offset. The target must be given in\n * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Cartesian3} target The target position in world coordinates.\n * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAt is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAt = function (target, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(target)) {\n    throw new DeveloperError(\"target is required\");\n  }\n  if (!defined(offset)) {\n    throw new DeveloperError(\"offset is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAt is not supported while morphing.\");\n  }\n  //>>includeEnd('debug');\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    target,\n    Ellipsoid.WGS84,\n    scratchLookAtMatrix4\n  );\n  this.lookAtTransform(transform, offset);\n};\n\nconst scratchLookAtHeadingPitchRangeOffset = new Cartesian3();\nconst scratchLookAtHeadingPitchRangeQuaternion1 = new Quaternion();\nconst scratchLookAtHeadingPitchRangeQuaternion2 = new Quaternion();\nconst scratchHeadingPitchRangeMatrix3 = new Matrix3();\n\nfunction offsetFromHeadingPitchRange(heading, pitch, range) {\n  pitch = CesiumMath.clamp(\n    pitch,\n    -CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO\n  );\n  heading = CesiumMath.zeroToTwoPi(heading) - CesiumMath.PI_OVER_TWO;\n\n  const pitchQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Y,\n    -pitch,\n    scratchLookAtHeadingPitchRangeQuaternion1\n  );\n  const headingQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -heading,\n    scratchLookAtHeadingPitchRangeQuaternion2\n  );\n  const rotQuat = Quaternion.multiply(headingQuat, pitchQuat, headingQuat);\n  const rotMatrix = Matrix3.fromQuaternion(\n    rotQuat,\n    scratchHeadingPitchRangeMatrix3\n  );\n\n  const offset = Cartesian3.clone(\n    Cartesian3.UNIT_X,\n    scratchLookAtHeadingPitchRangeOffset\n  );\n  Matrix3.multiplyByVector(rotMatrix, offset, offset);\n  Cartesian3.negate(offset, offset);\n  Cartesian3.multiplyByScalar(offset, range, offset);\n  return offset;\n}\n\n/**\n * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Matrix4} transform The transformation matrix defining the reference frame.\n * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAtTransform is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * const heading = Cesium.Math.toRadians(50.0);\n * const pitch = Cesium.Math.toRadians(-20.0);\n * const range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAtTransform = function (transform, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(transform)) {\n    throw new DeveloperError(\"transform is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"lookAtTransform is not supported while morphing.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._setTransform(transform);\n  if (!defined(offset)) {\n    return;\n  }\n\n  let cartesianOffset;\n  if (defined(offset.heading)) {\n    cartesianOffset = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range\n    );\n  } else {\n    cartesianOffset = offset;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    Cartesian2.clone(Cartesian2.ZERO, this.position);\n\n    Cartesian3.negate(cartesianOffset, this.up);\n    this.up.z = 0.0;\n\n    if (Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10) {\n      Cartesian3.clone(Cartesian3.UNIT_Y, this.up);\n    }\n\n    Cartesian3.normalize(this.up, this.up);\n\n    this._setTransform(Matrix4.IDENTITY);\n\n    Cartesian3.negate(Cartesian3.UNIT_Z, this.direction);\n    Cartesian3.cross(this.direction, this.up, this.right);\n    Cartesian3.normalize(this.right, this.right);\n\n    const frustum = this.frustum;\n    const ratio = frustum.top / frustum.right;\n    frustum.right = Cartesian3.magnitude(cartesianOffset) * 0.5;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n\n    this._setTransform(transform);\n\n    return;\n  }\n\n  Cartesian3.clone(cartesianOffset, this.position);\n  Cartesian3.negate(this.position, this.direction);\n  Cartesian3.normalize(this.direction, this.direction);\n  Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right);\n\n  if (Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10) {\n    Cartesian3.clone(Cartesian3.UNIT_X, this.right);\n  }\n\n  Cartesian3.normalize(this.right, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n  Cartesian3.normalize(this.up, this.up);\n\n  this._adjustOrthographicFrustum(true);\n};\n\nconst viewRectangle3DCartographic1 = new Cartographic();\nconst viewRectangle3DCartographic2 = new Cartographic();\nconst viewRectangle3DNorthEast = new Cartesian3();\nconst viewRectangle3DSouthWest = new Cartesian3();\nconst viewRectangle3DNorthWest = new Cartesian3();\nconst viewRectangle3DSouthEast = new Cartesian3();\nconst viewRectangle3DNorthCenter = new Cartesian3();\nconst viewRectangle3DSouthCenter = new Cartesian3();\nconst viewRectangle3DCenter = new Cartesian3();\nconst viewRectangle3DEquator = new Cartesian3();\nconst defaultRF = {\n  direction: new Cartesian3(),\n  right: new Cartesian3(),\n  up: new Cartesian3(),\n};\nlet viewRectangle3DEllipsoidGeodesic;\n\nfunction computeD(direction, upOrRight, corner, tanThetaOrPhi) {\n  const opposite = Math.abs(Cartesian3.dot(upOrRight, corner));\n  return opposite / tanThetaOrPhi - Cartesian3.dot(direction, corner);\n}\n\nfunction rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {\n  const ellipsoid = camera._projection.ellipsoid;\n  const cameraRF = updateCamera ? camera : defaultRF;\n\n  const north = rectangle.north;\n  const south = rectangle.south;\n  let east = rectangle.east;\n  const west = rectangle.west;\n\n  // If we go across the International Date Line\n  if (west > east) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  // Find the midpoint latitude.\n  //\n  // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.\n  // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't\n  // even look for this case in optimized builds, so we have to test for it here instead.\n  //\n  // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,\n  // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance\n  // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any\n  // rectangle that spans 178+ of the 180 degrees of latitude.\n  const longitude = (west + east) * 0.5;\n  let latitude;\n  if (\n    south < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE &&\n    north > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE\n  ) {\n    latitude = 0.0;\n  } else {\n    const northCartographic = viewRectangle3DCartographic1;\n    northCartographic.longitude = longitude;\n    northCartographic.latitude = north;\n    northCartographic.height = 0.0;\n\n    const southCartographic = viewRectangle3DCartographic2;\n    southCartographic.longitude = longitude;\n    southCartographic.latitude = south;\n    southCartographic.height = 0.0;\n\n    let ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;\n    if (\n      !defined(ellipsoidGeodesic) ||\n      ellipsoidGeodesic.ellipsoid !== ellipsoid\n    ) {\n      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic = new EllipsoidGeodesic(\n        undefined,\n        undefined,\n        ellipsoid\n      );\n    }\n\n    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);\n    latitude = ellipsoidGeodesic.interpolateUsingFraction(\n      0.5,\n      viewRectangle3DCartographic1\n    ).latitude;\n  }\n\n  const centerCartographic = viewRectangle3DCartographic1;\n  centerCartographic.longitude = longitude;\n  centerCartographic.latitude = latitude;\n  centerCartographic.height = 0.0;\n\n  const center = ellipsoid.cartographicToCartesian(\n    centerCartographic,\n    viewRectangle3DCenter\n  );\n\n  const cart = viewRectangle3DCartographic1;\n  cart.longitude = east;\n  cart.latitude = north;\n  const northEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthEast\n  );\n  cart.longitude = west;\n  const northWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthWest\n  );\n  cart.longitude = longitude;\n  const northCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthCenter\n  );\n  cart.latitude = south;\n  const southCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthCenter\n  );\n  cart.longitude = east;\n  const southEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthEast\n  );\n  cart.longitude = west;\n  const southWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthWest\n  );\n\n  Cartesian3.subtract(northWest, center, northWest);\n  Cartesian3.subtract(southEast, center, southEast);\n  Cartesian3.subtract(northEast, center, northEast);\n  Cartesian3.subtract(southWest, center, southWest);\n  Cartesian3.subtract(northCenter, center, northCenter);\n  Cartesian3.subtract(southCenter, center, southCenter);\n\n  const direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);\n  Cartesian3.negate(direction, direction);\n  const right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);\n  Cartesian3.normalize(right, right);\n  const up = Cartesian3.cross(right, direction, cameraRF.up);\n\n  let d;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    const width = Math.max(\n      Cartesian3.distance(northEast, northWest),\n      Cartesian3.distance(southEast, southWest)\n    );\n    const height = Math.max(\n      Cartesian3.distance(northEast, southEast),\n      Cartesian3.distance(northWest, southWest)\n    );\n\n    let rightScalar;\n    let topScalar;\n    const ratio =\n      camera.frustum._offCenterFrustum.right /\n      camera.frustum._offCenterFrustum.top;\n    const heightRatio = height * ratio;\n    if (width > heightRatio) {\n      rightScalar = width;\n      topScalar = rightScalar / ratio;\n    } else {\n      topScalar = height;\n      rightScalar = heightRatio;\n    }\n\n    d = Math.max(rightScalar, topScalar);\n  } else {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n\n    d = Math.max(\n      computeD(direction, up, northWest, tanPhi),\n      computeD(direction, up, southEast, tanPhi),\n      computeD(direction, up, northEast, tanPhi),\n      computeD(direction, up, southWest, tanPhi),\n      computeD(direction, up, northCenter, tanPhi),\n      computeD(direction, up, southCenter, tanPhi),\n      computeD(direction, right, northWest, tanTheta),\n      computeD(direction, right, southEast, tanTheta),\n      computeD(direction, right, northEast, tanTheta),\n      computeD(direction, right, southWest, tanTheta),\n      computeD(direction, right, northCenter, tanTheta),\n      computeD(direction, right, southCenter, tanTheta)\n    );\n\n    // If the rectangle crosses the equator, compute D at the equator, too, because that's the\n    // widest part of the rectangle when projected onto the globe.\n    if (south < 0 && north > 0) {\n      const equatorCartographic = viewRectangle3DCartographic1;\n      equatorCartographic.longitude = west;\n      equatorCartographic.latitude = 0.0;\n      equatorCartographic.height = 0.0;\n      let equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta)\n      );\n\n      equatorCartographic.longitude = east;\n      equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta)\n      );\n    }\n  }\n\n  return Cartesian3.add(\n    center,\n    Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator),\n    result\n  );\n}\n\nconst viewRectangleCVCartographic = new Cartographic();\nconst viewRectangleCVNorthEast = new Cartesian3();\nconst viewRectangleCVSouthWest = new Cartesian3();\nfunction rectangleCameraPositionColumbusView(camera, rectangle, result) {\n  const projection = camera._projection;\n  if (rectangle.west > rectangle.east) {\n    rectangle = Rectangle.MAX_VALUE;\n  }\n  const transform = camera._actualTransform;\n  const invTransform = camera._actualInvTransform;\n\n  const cart = viewRectangleCVCartographic;\n  cart.longitude = rectangle.east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangleCVNorthEast);\n  Matrix4.multiplyByPoint(transform, northEast, northEast);\n  Matrix4.multiplyByPoint(invTransform, northEast, northEast);\n\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangleCVSouthWest);\n  Matrix4.multiplyByPoint(transform, southWest, southWest);\n  Matrix4.multiplyByPoint(invTransform, southWest, southWest);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  if (defined(camera.frustum.fovy)) {\n    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    const tanTheta = camera.frustum.aspectRatio * tanPhi;\n    result.z =\n      Math.max(\n        (northEast.x - southWest.x) / tanTheta,\n        (northEast.y - southWest.y) / tanPhi\n      ) * 0.5;\n  } else {\n    const width = northEast.x - southWest.x;\n    const height = northEast.y - southWest.y;\n    result.z = Math.max(width, height);\n  }\n\n  return result;\n}\n\nconst viewRectangle2DCartographic = new Cartographic();\nconst viewRectangle2DNorthEast = new Cartesian3();\nconst viewRectangle2DSouthWest = new Cartesian3();\nfunction rectangleCameraPosition2D(camera, rectangle, result) {\n  const projection = camera._projection;\n\n  // Account for the rectangle crossing the International Date Line in 2D mode\n  let east = rectangle.east;\n  if (rectangle.west > rectangle.east) {\n    if (camera._scene.mapMode2D === MapMode2D.INFINITE_SCROLL) {\n      east += CesiumMath.TWO_PI;\n    } else {\n      rectangle = Rectangle.MAX_VALUE;\n      east = rectangle.east;\n    }\n  }\n\n  let cart = viewRectangle2DCartographic;\n  cart.longitude = east;\n  cart.latitude = rectangle.north;\n  const northEast = projection.project(cart, viewRectangle2DNorthEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  const southWest = projection.project(cart, viewRectangle2DSouthWest);\n\n  const width = Math.abs(northEast.x - southWest.x) * 0.5;\n  let height = Math.abs(northEast.y - southWest.y) * 0.5;\n\n  let right, top;\n  const ratio = camera.frustum.right / camera.frustum.top;\n  const heightRatio = height * ratio;\n  if (width > heightRatio) {\n    right = width;\n    top = right / ratio;\n  } else {\n    top = height;\n    right = heightRatio;\n  }\n\n  height = Math.max(2.0 * right, 2.0 * top);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  cart = projection.unproject(result, cart);\n  cart.height = height;\n  result = projection.project(cart, result);\n\n  return result;\n}\n\n/**\n * Get the camera position needed to view a rectangle on an ellipsoid or map\n *\n * @param {Rectangle} rectangle The rectangle to view.\n * @param {Cartesian3} [result] The camera position needed to view the rectangle\n * @returns {Cartesian3} The camera position needed to view the rectangle\n */\nCamera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  //>>includeEnd('debug');\n  const mode = this._mode;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  if (mode === SceneMode.SCENE3D) {\n    return rectangleCameraPosition3D(this, rectangle, result);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    return rectangleCameraPositionColumbusView(this, rectangle, result);\n  } else if (mode === SceneMode.SCENE2D) {\n    return rectangleCameraPosition2D(this, rectangle, result);\n  }\n\n  return undefined;\n};\n\nconst pickEllipsoid3DRay = new Ray();\nfunction pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (!intersection) {\n    return undefined;\n  }\n\n  const t = intersection.start > 0.0 ? intersection.start : intersection.stop;\n  return Ray.getPoint(ray, t, result);\n}\n\nconst pickEllipsoid2DRay = new Ray();\nfunction pickMap2D(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);\n  let position = ray.origin;\n  position = Cartesian3.fromElements(position.y, position.z, 0.0, position);\n  const cart = projection.unproject(position);\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\nconst pickEllipsoidCVRay = new Ray();\nfunction pickMapColumbusView(camera, windowPosition, projection, result) {\n  const ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);\n  const scalar = -ray.origin.x / ray.direction.x;\n  Ray.getPoint(ray, scalar, result);\n\n  const cart = projection.unproject(new Cartesian3(result.y, result.z, 0.0));\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO ||\n    cart.longitude < -Math.PI ||\n    cart.longitude > Math.PI\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\n/**\n * Pick an ellipsoid or map.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3 | undefined} If the ellipsoid or map was picked,\n * returns the point on the surface of the ellipsoid or map in world\n * coordinates. If the ellipsoid or map was not picked, returns undefined.\n *\n * @example\n * const canvas = viewer.scene.canvas;\n * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * const ellipsoid = viewer.scene.globe.ellipsoid;\n * const result = viewer.camera.pickEllipsoid(center, ellipsoid);\n */\nCamera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  if (this._mode === SceneMode.SCENE3D) {\n    result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    result = pickMap2D(this, windowPosition, this._projection, result);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    result = pickMapColumbusView(\n      this,\n      windowPosition,\n      this._projection,\n      result\n    );\n  } else {\n    return undefined;\n  }\n\n  return result;\n};\n\nconst pickPerspCenter = new Cartesian3();\nconst pickPerspXDir = new Cartesian3();\nconst pickPerspYDir = new Cartesian3();\nfunction getPickRayPerspective(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const near = camera.frustum.near;\n\n  const x = (2.0 / width) * windowPosition.x - 1.0;\n  const y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n\n  const position = camera.positionWC;\n  Cartesian3.clone(position, result.origin);\n\n  const nearCenter = Cartesian3.multiplyByScalar(\n    camera.directionWC,\n    near,\n    pickPerspCenter\n  );\n  Cartesian3.add(position, nearCenter, nearCenter);\n  const xDir = Cartesian3.multiplyByScalar(\n    camera.rightWC,\n    x * near * tanTheta,\n    pickPerspXDir\n  );\n  const yDir = Cartesian3.multiplyByScalar(\n    camera.upWC,\n    y * near * tanPhi,\n    pickPerspYDir\n  );\n  const direction = Cartesian3.add(nearCenter, xDir, result.direction);\n  Cartesian3.add(direction, yDir, direction);\n  Cartesian3.subtract(direction, position, direction);\n  Cartesian3.normalize(direction, direction);\n\n  return result;\n}\n\nconst scratchDirection = new Cartesian3();\n\nfunction getPickRayOrthographic(camera, windowPosition, result) {\n  const canvas = camera._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n  let x = (2.0 / width) * windowPosition.x - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  let y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n\n  const origin = result.origin;\n  Cartesian3.clone(camera.position, origin);\n\n  Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n\n  Cartesian3.clone(camera.directionWC, result.direction);\n\n  if (\n    camera._mode === SceneMode.COLUMBUS_VIEW ||\n    camera._mode === SceneMode.SCENE2D\n  ) {\n    Cartesian3.fromElements(\n      result.origin.z,\n      result.origin.x,\n      result.origin.y,\n      result.origin\n    );\n  }\n\n  return result;\n}\n\n/**\n * Create a ray from the camera position through the pixel at <code>windowPosition</code>\n * in world coordinates.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray|undefined} Returns the {@link Cartesian3} position and direction of the ray, or undefined if the pick ray cannot be determined.\n */\nCamera.prototype.getPickRay = function (windowPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Ray();\n  }\n\n  const canvas = this._scene.canvas;\n  if (canvas.clientWidth <= 0 || canvas.clientHeight <= 0) {\n    return undefined;\n  }\n\n  const frustum = this.frustum;\n  if (\n    defined(frustum.aspectRatio) &&\n    defined(frustum.fov) &&\n    defined(frustum.near)\n  ) {\n    return getPickRayPerspective(this, windowPosition, result);\n  }\n\n  return getPickRayOrthographic(this, windowPosition, result);\n};\n\nconst scratchToCenter = new Cartesian3();\nconst scratchProj = new Cartesian3();\n\n/**\n * Return the distance from the camera to the front of the bounding sphere.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @returns {Number} The distance to the bounding sphere.\n */\nCamera.prototype.distanceToBoundingSphere = function (boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const toCenter = Cartesian3.subtract(\n    this.positionWC,\n    boundingSphere.center,\n    scratchToCenter\n  );\n  const proj = Cartesian3.multiplyByScalar(\n    this.directionWC,\n    Cartesian3.dot(toCenter, this.directionWC),\n    scratchProj\n  );\n  return Math.max(0.0, Cartesian3.magnitude(proj) - boundingSphere.radius);\n};\n\nconst scratchPixelSize = new Cartesian2();\n\n/**\n * Return the pixel size in meters.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @param {Number} drawingBufferWidth The drawing buffer width.\n * @param {Number} drawingBufferHeight The drawing buffer height.\n * @returns {Number} The pixel size in meters.\n */\nCamera.prototype.getPixelSize = function (\n  boundingSphere,\n  drawingBufferWidth,\n  drawingBufferHeight\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  if (!defined(drawingBufferWidth)) {\n    throw new DeveloperError(\"drawingBufferWidth is required.\");\n  }\n  if (!defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"drawingBufferHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = this.distanceToBoundingSphere(boundingSphere);\n  const pixelSize = this.frustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    this._scene.pixelRatio,\n    scratchPixelSize\n  );\n  return Math.max(pixelSize.x, pixelSize.y);\n};\n\nfunction createAnimationTemplateCV(\n  camera,\n  position,\n  center,\n  maxX,\n  maxY,\n  duration\n) {\n  const newPosition = Cartesian3.clone(position);\n\n  if (center.y > maxX) {\n    newPosition.y -= center.y - maxX;\n  } else if (center.y < -maxX) {\n    newPosition.y += -maxX - center.y;\n  }\n\n  if (center.z > maxY) {\n    newPosition.z -= center.z - maxY;\n  } else if (center.z < -maxY) {\n    newPosition.z += -maxY - center.z;\n  }\n\n  function updateCV(value) {\n    const interp = Cartesian3.lerp(\n      position,\n      newPosition,\n      value.time,\n      new Cartesian3()\n    );\n    camera.worldToCameraCoordinatesPoint(interp, camera.position);\n  }\n  return {\n    easingFunction: EasingFunction.EXPONENTIAL_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    duration: duration,\n    update: updateCV,\n  };\n}\n\nconst normalScratch = new Cartesian3();\nconst centerScratch = new Cartesian3();\nconst posScratch = new Cartesian3();\nconst scratchCartesian3Subtract = new Cartesian3();\n\nfunction createAnimationCV(camera, duration) {\n  let position = camera.position;\n  const direction = camera.direction;\n\n  const normal = camera.worldToCameraCoordinatesVector(\n    Cartesian3.UNIT_X,\n    normalScratch\n  );\n  const scalar =\n    -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  const center = Cartesian3.add(\n    position,\n    Cartesian3.multiplyByScalar(direction, scalar, centerScratch),\n    centerScratch\n  );\n  camera.cameraToWorldCoordinatesPoint(center, center);\n\n  position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);\n\n  const tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  const tanTheta = camera.frustum.aspectRatio * tanPhi;\n  const distToC = Cartesian3.magnitude(\n    Cartesian3.subtract(position, center, scratchCartesian3Subtract)\n  );\n  const dWidth = tanTheta * distToC;\n  const dHeight = tanPhi * distToC;\n\n  const mapWidth = camera._maxCoord.x;\n  const mapHeight = camera._maxCoord.y;\n\n  const maxX = Math.max(dWidth - mapWidth, mapWidth);\n  const maxY = Math.max(dHeight - mapHeight, mapHeight);\n\n  if (\n    position.z < -maxX ||\n    position.z > maxX ||\n    position.y < -maxY ||\n    position.y > maxY\n  ) {\n    const translateX = center.y < -maxX || center.y > maxX;\n    const translateY = center.z < -maxY || center.z > maxY;\n    if (translateX || translateY) {\n      return createAnimationTemplateCV(\n        camera,\n        position,\n        center,\n        maxX,\n        maxY,\n        duration\n      );\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.\n *\n * @param {Number} duration The duration, in seconds, of the animation.\n * @returns {Object} The animation or undefined if the scene mode is 3D or the map is already ion view.\n *\n * @private\n */\nCamera.prototype.createCorrectPositionTween = function (duration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(duration)) {\n    throw new DeveloperError(\"duration is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return createAnimationCV(this, duration);\n  }\n\n  return undefined;\n};\n\nconst scratchFlyToDestination = new Cartesian3();\nconst newOptions = {\n  destination: undefined,\n  heading: undefined,\n  pitch: undefined,\n  roll: undefined,\n  duration: undefined,\n  complete: undefined,\n  cancel: undefined,\n  endTransform: undefined,\n  maximumHeight: undefined,\n  easingFunction: undefined,\n};\n\n/**\n * Cancels the current camera flight and leaves the camera at its current location.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.cancelFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Completes the current camera flight and moves the camera immediately to its final destination.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.completeFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n\n    const options = {\n      destination: undefined,\n      orientation: {\n        heading: undefined,\n        pitch: undefined,\n        roll: undefined,\n      },\n    };\n\n    options.destination = newOptions.destination;\n    options.orientation.heading = newOptions.heading;\n    options.orientation.pitch = newOptions.pitch;\n    options.orientation.roll = newOptions.roll;\n\n    this.setView(options);\n\n    if (defined(this._currentFlight.complete)) {\n      this._currentFlight.complete();\n    }\n\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Flies the camera from its current position to a new position.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} options.destination The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n *\n * @exception {DeveloperError} If either direction or up is given, then both are required.\n *\n * @example\n * // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });\n */\nCamera.prototype.flyTo = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let destination = options.destination;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  this.cancelFlight();\n\n  let orientation = defaultValue(\n    options.orientation,\n    defaultValue.EMPTY_OBJECT\n  );\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation\n    );\n  }\n\n  if (defined(options.duration) && options.duration <= 0.0) {\n    const setViewOptions = scratchSetViewOptions;\n    setViewOptions.destination = options.destination;\n    setViewOptions.orientation.heading = orientation.heading;\n    setViewOptions.orientation.pitch = orientation.pitch;\n    setViewOptions.orientation.roll = orientation.roll;\n    setViewOptions.convert = options.convert;\n    setViewOptions.endTransform = options.endTransform;\n    this.setView(setViewOptions);\n    if (typeof options.complete === \"function\") {\n      options.complete();\n    }\n    return;\n  }\n\n  const isRectangle = defined(destination.west);\n  if (isRectangle) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchFlyToDestination\n    );\n  }\n\n  const that = this;\n  /* eslint-disable-next-line prefer-const */\n  let flightTween;\n\n  newOptions.destination = destination;\n  newOptions.heading = orientation.heading;\n  newOptions.pitch = orientation.pitch;\n  newOptions.roll = orientation.roll;\n  newOptions.duration = options.duration;\n  newOptions.complete = function () {\n    if (flightTween === that._currentFlight) {\n      that._currentFlight = undefined;\n    }\n    if (defined(options.complete)) {\n      options.complete();\n    }\n  };\n  newOptions.cancel = options.cancel;\n  newOptions.endTransform = options.endTransform;\n  newOptions.convert = isRectangle ? false : options.convert;\n  newOptions.maximumHeight = options.maximumHeight;\n  newOptions.pitchAdjustHeight = options.pitchAdjustHeight;\n  newOptions.flyOverLongitude = options.flyOverLongitude;\n  newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  newOptions.easingFunction = options.easingFunction;\n\n  const scene = this._scene;\n  const tweenOptions = CameraFlightPath.createTween(scene, newOptions);\n  // If the camera doesn't actually need to go anywhere, duration\n  // will be 0 and we can just complete the current flight.\n  if (tweenOptions.duration === 0) {\n    if (typeof tweenOptions.complete === \"function\") {\n      tweenOptions.complete();\n    }\n    return;\n  }\n  flightTween = scene.tweens.add(tweenOptions);\n  this._currentFlight = flightTween;\n\n  // Save the final destination view information for the PRELOAD_FLIGHT pass.\n  let preloadFlightCamera = this._scene.preloadFlightCamera;\n  if (this._mode !== SceneMode.SCENE2D) {\n    if (!defined(preloadFlightCamera)) {\n      preloadFlightCamera = Camera.clone(this);\n    }\n    preloadFlightCamera.setView({\n      destination: destination,\n      orientation: orientation,\n    });\n\n    this._scene.preloadFlightCullingVolume = preloadFlightCamera.frustum.computeCullingVolume(\n      preloadFlightCamera.positionWC,\n      preloadFlightCamera.directionWC,\n      preloadFlightCamera.upWC\n    );\n  }\n};\n\nfunction distanceToBoundingSphere3D(camera, radius) {\n  const frustum = camera.frustum;\n  const tanPhi = Math.tan(frustum.fovy * 0.5);\n  const tanTheta = frustum.aspectRatio * tanPhi;\n  return Math.max(radius / tanTheta, radius / tanPhi);\n}\n\nfunction distanceToBoundingSphere2D(camera, radius) {\n  let frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  let right, top;\n  const ratio = frustum.right / frustum.top;\n  const heightRatio = radius * ratio;\n  if (radius > heightRatio) {\n    right = radius;\n    top = right / ratio;\n  } else {\n    top = radius;\n    right = heightRatio;\n  }\n\n  return Math.max(right, top) * 1.5;\n}\n\nconst MINIMUM_ZOOM = 100.0;\n\nfunction adjustBoundingSphereOffset(camera, boundingSphere, offset) {\n  offset = HeadingPitchRange.clone(\n    defined(offset) ? offset : Camera.DEFAULT_OFFSET\n  );\n\n  const minimumZoom =\n    camera._scene.screenSpaceCameraController.minimumZoomDistance;\n  const maximumZoom =\n    camera._scene.screenSpaceCameraController.maximumZoomDistance;\n  const range = offset.range;\n  if (!defined(range) || range === 0.0) {\n    const radius = boundingSphere.radius;\n    if (radius === 0.0) {\n      offset.range = MINIMUM_ZOOM;\n    } else if (\n      camera.frustum instanceof OrthographicFrustum ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      offset.range = distanceToBoundingSphere2D(camera, radius);\n    } else {\n      offset.range = distanceToBoundingSphere3D(camera, radius);\n    }\n    offset.range = CesiumMath.clamp(offset.range, minimumZoom, maximumZoom);\n  }\n\n  return offset;\n}\n\n/**\n * Sets the camera so that the current view contains the provided bounding sphere.\n *\n * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.\n */\nCamera.prototype.viewBoundingSphere = function (boundingSphere, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"viewBoundingSphere is not supported while morphing.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  offset = adjustBoundingSphereOffset(this, boundingSphere, offset);\n  this.lookAt(boundingSphere.center, offset);\n};\n\nconst scratchflyToBoundingSphereTransform = new Matrix4();\nconst scratchflyToBoundingSphereDestination = new Cartesian3();\nconst scratchflyToBoundingSphereDirection = new Cartesian3();\nconst scratchflyToBoundingSphereUp = new Cartesian3();\nconst scratchflyToBoundingSphereRight = new Cartesian3();\nconst scratchFlyToBoundingSphereCart4 = new Cartesian4();\nconst scratchFlyToBoundingSphereQuaternion = new Quaternion();\nconst scratchFlyToBoundingSphereMatrix3 = new Matrix3();\n\n/**\n * Flies the camera to a location where the current view contains the provided bounding sphere.\n *\n * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be aligned to local north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {Object} [options] Object with the following properties:\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n */\nCamera.prototype.flyToBoundingSphere = function (boundingSphere, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const scene2D =\n    this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW;\n  this._setTransform(Matrix4.IDENTITY);\n  const offset = adjustBoundingSphereOffset(\n    this,\n    boundingSphere,\n    options.offset\n  );\n\n  let position;\n  if (scene2D) {\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.UNIT_Z,\n      offset.range,\n      scratchflyToBoundingSphereDestination\n    );\n  } else {\n    position = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range\n    );\n  }\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    boundingSphere.center,\n    Ellipsoid.WGS84,\n    scratchflyToBoundingSphereTransform\n  );\n  Matrix4.multiplyByPoint(transform, position, position);\n\n  let direction;\n  let up;\n\n  if (!scene2D) {\n    direction = Cartesian3.subtract(\n      boundingSphere.center,\n      position,\n      scratchflyToBoundingSphereDirection\n    );\n    Cartesian3.normalize(direction, direction);\n\n    up = Matrix4.multiplyByPointAsVector(\n      transform,\n      Cartesian3.UNIT_Z,\n      scratchflyToBoundingSphereUp\n    );\n    if (1.0 - Math.abs(Cartesian3.dot(direction, up)) < CesiumMath.EPSILON6) {\n      const rotateQuat = Quaternion.fromAxisAngle(\n        direction,\n        offset.heading,\n        scratchFlyToBoundingSphereQuaternion\n      );\n      const rotation = Matrix3.fromQuaternion(\n        rotateQuat,\n        scratchFlyToBoundingSphereMatrix3\n      );\n\n      Cartesian3.fromCartesian4(\n        Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4),\n        up\n      );\n      Matrix3.multiplyByVector(rotation, up, up);\n    }\n\n    const right = Cartesian3.cross(\n      direction,\n      up,\n      scratchflyToBoundingSphereRight\n    );\n    Cartesian3.cross(right, direction, up);\n    Cartesian3.normalize(up, up);\n  }\n\n  this.flyTo({\n    destination: position,\n    orientation: {\n      direction: direction,\n      up: up,\n    },\n    duration: options.duration,\n    complete: options.complete,\n    cancel: options.cancel,\n    endTransform: options.endTransform,\n    maximumHeight: options.maximumHeight,\n    easingFunction: options.easingFunction,\n    flyOverLongitude: options.flyOverLongitude,\n    flyOverLongitudeWeight: options.flyOverLongitudeWeight,\n    pitchAdjustHeight: options.pitchAdjustHeight,\n  });\n};\n\nconst scratchCartesian3_1 = new Cartesian3();\nconst scratchCartesian3_2 = new Cartesian3();\nconst scratchCartesian3_3 = new Cartesian3();\nconst scratchCartesian3_4 = new Cartesian3();\nconst horizonPoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeHorizonQuad(camera, ellipsoid) {\n  const radii = ellipsoid.radii;\n  const p = camera.positionWC;\n\n  // Find the corresponding position in the scaled space of the ellipsoid.\n  const q = Cartesian3.multiplyComponents(\n    ellipsoid.oneOverRadii,\n    p,\n    scratchCartesian3_1\n  );\n\n  const qMagnitude = Cartesian3.magnitude(q);\n  const qUnit = Cartesian3.normalize(q, scratchCartesian3_2);\n\n  // Determine the east and north directions at q.\n  let eUnit;\n  let nUnit;\n  if (\n    Cartesian3.equalsEpsilon(qUnit, Cartesian3.UNIT_Z, CesiumMath.EPSILON10)\n  ) {\n    eUnit = new Cartesian3(0, 1, 0);\n    nUnit = new Cartesian3(0, 0, 1);\n  } else {\n    eUnit = Cartesian3.normalize(\n      Cartesian3.cross(Cartesian3.UNIT_Z, qUnit, scratchCartesian3_3),\n      scratchCartesian3_3\n    );\n    nUnit = Cartesian3.normalize(\n      Cartesian3.cross(qUnit, eUnit, scratchCartesian3_4),\n      scratchCartesian3_4\n    );\n  }\n\n  // Determine the radius of the 'limb' of the ellipsoid.\n  const wMagnitude = Math.sqrt(Cartesian3.magnitudeSquared(q) - 1.0);\n\n  // Compute the center and offsets.\n  const center = Cartesian3.multiplyByScalar(\n    qUnit,\n    1.0 / qMagnitude,\n    scratchCartesian3_1\n  );\n  const scalar = wMagnitude / qMagnitude;\n  const eastOffset = Cartesian3.multiplyByScalar(\n    eUnit,\n    scalar,\n    scratchCartesian3_2\n  );\n  const northOffset = Cartesian3.multiplyByScalar(\n    nUnit,\n    scalar,\n    scratchCartesian3_3\n  );\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  const upperLeft = Cartesian3.add(center, northOffset, horizonPoints[0]);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n\n  const lowerLeft = Cartesian3.subtract(center, northOffset, horizonPoints[1]);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n\n  const lowerRight = Cartesian3.subtract(center, northOffset, horizonPoints[2]);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n\n  const upperRight = Cartesian3.add(center, northOffset, horizonPoints[3]);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n\n  return horizonPoints;\n}\n\nconst scratchPickCartesian2 = new Cartesian2();\nconst scratchRectCartesian = new Cartesian3();\nconst cartoArray = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nfunction addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {\n  scratchPickCartesian2.x = x;\n  scratchPickCartesian2.y = y;\n  const r = camera.pickEllipsoid(\n    scratchPickCartesian2,\n    ellipsoid,\n    scratchRectCartesian\n  );\n  if (defined(r)) {\n    cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);\n    return 1;\n  }\n  cartoArray[index] = ellipsoid.cartesianToCartographic(\n    computedHorizonQuad[index],\n    cartoArray[index]\n  );\n  return 0;\n}\n/**\n * Computes the approximate visible rectangle on the ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that you want to know the visible region.\n * @param {Rectangle} [result] The rectangle in which to store the result\n *\n * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.\n */\nCamera.prototype.computeViewRectangle = function (ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  const cullingVolume = this.frustum.computeCullingVolume(\n    this.positionWC,\n    this.directionWC,\n    this.upWC\n  );\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    ellipsoid.maximumRadius\n  );\n  const visibility = cullingVolume.computeVisibility(boundingSphere);\n  if (visibility === Intersect.OUTSIDE) {\n    return undefined;\n  }\n\n  const canvas = this._scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let successfulPickCount = 0;\n\n  const computedHorizonQuad = computeHorizonQuad(this, ellipsoid);\n\n  successfulPickCount += addToResult(\n    0,\n    0,\n    0,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    0,\n    height,\n    1,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    width,\n    height,\n    2,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    width,\n    0,\n    3,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n\n  if (successfulPickCount < 2) {\n    // If we have space non-globe in 3 or 4 corners then return the whole globe\n    return Rectangle.MAX_VALUE;\n  }\n\n  result = Rectangle.fromCartographicArray(cartoArray, result);\n\n  // Detect if we go over the poles\n  let distance = 0;\n  let lastLon = cartoArray[3].longitude;\n  for (let i = 0; i < 4; ++i) {\n    const lon = cartoArray[i].longitude;\n    const diff = Math.abs(lon - lastLon);\n    if (diff > CesiumMath.PI) {\n      // Crossed the dateline\n      distance += CesiumMath.TWO_PI - diff;\n    } else {\n      distance += diff;\n    }\n\n    lastLon = lon;\n  }\n\n  // We are over one of the poles so adjust the rectangle accordingly\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(distance),\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON9\n    )\n  ) {\n    result.west = -CesiumMath.PI;\n    result.east = CesiumMath.PI;\n    if (cartoArray[0].latitude >= 0.0) {\n      result.north = CesiumMath.PI_OVER_TWO;\n    } else {\n      result.south = -CesiumMath.PI_OVER_TWO;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Switches the frustum/projection to perspective.\n *\n * This function is a no-op in 2D which must always be orthographic.\n */\nCamera.prototype.switchToPerspectiveFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof PerspectiveFrustum\n  ) {\n    return;\n  }\n\n  const scene = this._scene;\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n};\n\n/**\n * Switches the frustum/projection to orthographic.\n *\n * This function is a no-op in 2D which will always be orthographic.\n */\nCamera.prototype.switchToOrthographicFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof OrthographicFrustum\n  ) {\n    return;\n  }\n\n  // This must be called before changing the frustum because it uses the previous\n  // frustum to reconstruct the world space position from the depth buffer.\n  const frustumWidth = calculateOrthographicFrustumWidth(this);\n\n  const scene = this._scene;\n  this.frustum = new OrthographicFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.width = frustumWidth;\n};\n\n/**\n * @private\n */\nCamera.clone = function (camera, result) {\n  if (!defined(result)) {\n    result = new Camera(camera._scene);\n  }\n\n  Cartesian3.clone(camera.position, result.position);\n  Cartesian3.clone(camera.direction, result.direction);\n  Cartesian3.clone(camera.up, result.up);\n  Cartesian3.clone(camera.right, result.right);\n  Matrix4.clone(camera._transform, result.transform);\n  result._transformChanged = true;\n  result.frustum = camera.frustum.clone();\n\n  return result;\n};\n\n/**\n * A function that will execute when a flight completes.\n * @callback Camera.FlightCompleteCallback\n */\n\n/**\n * A function that will execute when a flight is cancelled.\n * @callback Camera.FlightCancelledCallback\n */\nexport default Camera;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ScreenSpaceEventHandler from \"../Core/ScreenSpaceEventHandler.js\";\nimport ScreenSpaceEventType from \"../Core/ScreenSpaceEventType.js\";\nimport CameraEventType from \"./CameraEventType.js\";\n\nfunction getKey(type, modifier) {\n  let key = type;\n  if (defined(modifier)) {\n    key += `+${modifier}`;\n  }\n  return key;\n}\n\nfunction clonePinchMovement(pinchMovement, result) {\n  Cartesian2.clone(\n    pinchMovement.distance.startPosition,\n    result.distance.startPosition\n  );\n  Cartesian2.clone(\n    pinchMovement.distance.endPosition,\n    result.distance.endPosition\n  );\n\n  Cartesian2.clone(\n    pinchMovement.angleAndHeight.startPosition,\n    result.angleAndHeight.startPosition\n  );\n  Cartesian2.clone(\n    pinchMovement.angleAndHeight.endPosition,\n    result.angleAndHeight.endPosition\n  );\n}\n\nfunction listenToPinch(aggregator, modifier, canvas) {\n  const key = getKey(CameraEventType.PINCH, modifier);\n\n  const update = aggregator._update;\n  const isDown = aggregator._isDown;\n  const eventStartPosition = aggregator._eventStartPosition;\n  const pressTime = aggregator._pressTime;\n  const releaseTime = aggregator._releaseTime;\n\n  update[key] = true;\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n\n  let movement = aggregator._movement[key];\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n\n  movement.distance = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  };\n  movement.angleAndHeight = {\n    startPosition: new Cartesian2(),\n    endPosition: new Cartesian2(),\n  };\n  movement.prevAngle = 0.0;\n\n  aggregator._eventHandler.setInputAction(\n    function (event) {\n      aggregator._buttonsDown++;\n      isDown[key] = true;\n      pressTime[key] = new Date();\n      // Compute center position and store as start point.\n      Cartesian2.lerp(\n        event.position1,\n        event.position2,\n        0.5,\n        eventStartPosition[key]\n      );\n    },\n    ScreenSpaceEventType.PINCH_START,\n    modifier\n  );\n\n  aggregator._eventHandler.setInputAction(\n    function () {\n      aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n      isDown[key] = false;\n      releaseTime[key] = new Date();\n    },\n    ScreenSpaceEventType.PINCH_END,\n    modifier\n  );\n\n  aggregator._eventHandler.setInputAction(\n    function (mouseMovement) {\n      if (isDown[key]) {\n        // Aggregate several input events into a single animation frame.\n        if (!update[key]) {\n          Cartesian2.clone(\n            mouseMovement.distance.endPosition,\n            movement.distance.endPosition\n          );\n          Cartesian2.clone(\n            mouseMovement.angleAndHeight.endPosition,\n            movement.angleAndHeight.endPosition\n          );\n        } else {\n          clonePinchMovement(mouseMovement, movement);\n          update[key] = false;\n          movement.prevAngle = movement.angleAndHeight.startPosition.x;\n        }\n        // Make sure our aggregation of angles does not \"flip\" over 360 degrees.\n        let angle = movement.angleAndHeight.endPosition.x;\n        const prevAngle = movement.prevAngle;\n        const TwoPI = Math.PI * 2;\n        while (angle >= prevAngle + Math.PI) {\n          angle -= TwoPI;\n        }\n        while (angle < prevAngle - Math.PI) {\n          angle += TwoPI;\n        }\n        movement.angleAndHeight.endPosition.x =\n          (-angle * canvas.clientWidth) / 12;\n        movement.angleAndHeight.startPosition.x =\n          (-prevAngle * canvas.clientWidth) / 12;\n      }\n    },\n    ScreenSpaceEventType.PINCH_MOVE,\n    modifier\n  );\n}\n\nfunction listenToWheel(aggregator, modifier) {\n  const key = getKey(CameraEventType.WHEEL, modifier);\n\n  const update = aggregator._update;\n  update[key] = true;\n\n  let movement = aggregator._movement[key];\n  if (!defined(movement)) {\n    movement = aggregator._movement[key] = {};\n  }\n\n  movement.startPosition = new Cartesian2();\n  movement.endPosition = new Cartesian2();\n\n  aggregator._eventHandler.setInputAction(\n    function (delta) {\n      // TODO: magic numbers\n      const arcLength = 15.0 * CesiumMath.toRadians(delta);\n      if (!update[key]) {\n        movement.endPosition.y = movement.endPosition.y + arcLength;\n      } else {\n        Cartesian2.clone(Cartesian2.ZERO, movement.startPosition);\n        movement.endPosition.x = 0.0;\n        movement.endPosition.y = arcLength;\n        update[key] = false;\n      }\n    },\n    ScreenSpaceEventType.WHEEL,\n    modifier\n  );\n}\n\nfunction listenMouseButtonDownUp(aggregator, modifier, type) {\n  const key = getKey(type, modifier);\n\n  const isDown = aggregator._isDown;\n  const eventStartPosition = aggregator._eventStartPosition;\n  const pressTime = aggregator._pressTime;\n  const releaseTime = aggregator._releaseTime;\n\n  isDown[key] = false;\n  eventStartPosition[key] = new Cartesian2();\n\n  let lastMovement = aggregator._lastMovement[key];\n  if (!defined(lastMovement)) {\n    lastMovement = aggregator._lastMovement[key] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      valid: false,\n    };\n  }\n\n  let down;\n  let up;\n  if (type === CameraEventType.LEFT_DRAG) {\n    down = ScreenSpaceEventType.LEFT_DOWN;\n    up = ScreenSpaceEventType.LEFT_UP;\n  } else if (type === CameraEventType.RIGHT_DRAG) {\n    down = ScreenSpaceEventType.RIGHT_DOWN;\n    up = ScreenSpaceEventType.RIGHT_UP;\n  } else if (type === CameraEventType.MIDDLE_DRAG) {\n    down = ScreenSpaceEventType.MIDDLE_DOWN;\n    up = ScreenSpaceEventType.MIDDLE_UP;\n  }\n\n  aggregator._eventHandler.setInputAction(\n    function (event) {\n      aggregator._buttonsDown++;\n      lastMovement.valid = false;\n      isDown[key] = true;\n      pressTime[key] = new Date();\n      Cartesian2.clone(event.position, eventStartPosition[key]);\n    },\n    down,\n    modifier\n  );\n\n  aggregator._eventHandler.setInputAction(\n    function () {\n      aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);\n      isDown[key] = false;\n      releaseTime[key] = new Date();\n    },\n    up,\n    modifier\n  );\n}\n\nfunction cloneMouseMovement(mouseMovement, result) {\n  Cartesian2.clone(mouseMovement.startPosition, result.startPosition);\n  Cartesian2.clone(mouseMovement.endPosition, result.endPosition);\n}\n\nfunction listenMouseMove(aggregator, modifier) {\n  const update = aggregator._update;\n  const movement = aggregator._movement;\n  const lastMovement = aggregator._lastMovement;\n  const isDown = aggregator._isDown;\n\n  for (const typeName in CameraEventType) {\n    if (CameraEventType.hasOwnProperty(typeName)) {\n      const type = CameraEventType[typeName];\n      if (defined(type)) {\n        const key = getKey(type, modifier);\n        update[key] = true;\n\n        if (!defined(aggregator._lastMovement[key])) {\n          aggregator._lastMovement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2(),\n            valid: false,\n          };\n        }\n\n        if (!defined(aggregator._movement[key])) {\n          aggregator._movement[key] = {\n            startPosition: new Cartesian2(),\n            endPosition: new Cartesian2(),\n          };\n        }\n      }\n    }\n  }\n\n  aggregator._eventHandler.setInputAction(\n    function (mouseMovement) {\n      for (const typeName in CameraEventType) {\n        if (CameraEventType.hasOwnProperty(typeName)) {\n          const type = CameraEventType[typeName];\n          if (defined(type)) {\n            const key = getKey(type, modifier);\n            if (isDown[key]) {\n              if (!update[key]) {\n                Cartesian2.clone(\n                  mouseMovement.endPosition,\n                  movement[key].endPosition\n                );\n              } else {\n                cloneMouseMovement(movement[key], lastMovement[key]);\n                lastMovement[key].valid = true;\n                cloneMouseMovement(mouseMovement, movement[key]);\n                update[key] = false;\n              }\n            }\n          }\n        }\n      }\n\n      Cartesian2.clone(\n        mouseMovement.endPosition,\n        aggregator._currentMousePosition\n      );\n    },\n    ScreenSpaceEventType.MOUSE_MOVE,\n    modifier\n  );\n}\n\n/**\n * Aggregates input events. For example, suppose the following inputs are received between frames:\n * left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into\n * one event with a start and end position of the mouse.\n *\n * @alias CameraEventAggregator\n * @constructor\n *\n * @param {HTMLCanvasElement} [canvas=document] The element to handle events for.\n *\n * @see ScreenSpaceEventHandler\n */\nfunction CameraEventAggregator(canvas) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(canvas)) {\n    throw new DeveloperError(\"canvas is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._eventHandler = new ScreenSpaceEventHandler(canvas);\n\n  this._update = {};\n  this._movement = {};\n  this._lastMovement = {};\n  this._isDown = {};\n  this._eventStartPosition = {};\n  this._pressTime = {};\n  this._releaseTime = {};\n\n  this._buttonsDown = 0;\n\n  this._currentMousePosition = new Cartesian2();\n\n  listenToWheel(this, undefined);\n  listenToPinch(this, undefined, canvas);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.LEFT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.RIGHT_DRAG);\n  listenMouseButtonDownUp(this, undefined, CameraEventType.MIDDLE_DRAG);\n  listenMouseMove(this, undefined);\n\n  for (const modifierName in KeyboardEventModifier) {\n    if (KeyboardEventModifier.hasOwnProperty(modifierName)) {\n      const modifier = KeyboardEventModifier[modifierName];\n      if (defined(modifier)) {\n        listenToWheel(this, modifier);\n        listenToPinch(this, modifier, canvas);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.LEFT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.RIGHT_DRAG);\n        listenMouseButtonDownUp(this, modifier, CameraEventType.MIDDLE_DRAG);\n        listenMouseMove(this, modifier);\n      }\n    }\n  }\n}\n\nObject.defineProperties(CameraEventAggregator.prototype, {\n  /**\n   * Gets the current mouse position.\n   * @memberof CameraEventAggregator.prototype\n   * @type {Cartesian2}\n   */\n  currentMousePosition: {\n    get: function () {\n      return this._currentMousePosition;\n    },\n  },\n\n  /**\n   * Gets whether any mouse button is down, a touch has started, or the wheel has been moved.\n   * @memberof CameraEventAggregator.prototype\n   * @type {Boolean}\n   */\n  anyButtonDown: {\n    get: function () {\n      const wheelMoved =\n        !this._update[getKey(CameraEventType.WHEEL)] ||\n        !this._update[\n          getKey(CameraEventType.WHEEL, KeyboardEventModifier.SHIFT)\n        ] ||\n        !this._update[\n          getKey(CameraEventType.WHEEL, KeyboardEventModifier.CTRL)\n        ] ||\n        !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.ALT)];\n      return this._buttonsDown > 0 || wheelMoved;\n    },\n  },\n});\n\n/**\n * Gets if a mouse button down or touch has started and has been moved.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Boolean} Returns <code>true</code> if a mouse button down or touch has started and has been moved; otherwise, <code>false</code>\n */\nCameraEventAggregator.prototype.isMoving = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return !this._update[key];\n};\n\n/**\n * Gets the aggregated start and end position of the current event.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Object} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code>.\n */\nCameraEventAggregator.prototype.getMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  const movement = this._movement[key];\n  return movement;\n};\n\n/**\n * Gets the start and end position of the last move event (not the aggregated event).\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Object|undefined} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code> or <code>undefined</code>.\n */\nCameraEventAggregator.prototype.getLastMovement = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  const lastMovement = this._lastMovement[key];\n  if (lastMovement.valid) {\n    return lastMovement;\n  }\n\n  return undefined;\n};\n\n/**\n * Gets whether the mouse button is down or a touch has started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Boolean} Whether the mouse button is down or a touch has started.\n */\nCameraEventAggregator.prototype.isButtonDown = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return this._isDown[key];\n};\n\n/**\n * Gets the mouse position that started the aggregation.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Cartesian2} The mouse position.\n */\nCameraEventAggregator.prototype.getStartMousePosition = function (\n  type,\n  modifier\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (type === CameraEventType.WHEEL) {\n    return this._currentMousePosition;\n  }\n\n  const key = getKey(type, modifier);\n  return this._eventStartPosition[key];\n};\n\n/**\n * Gets the time the button was pressed or the touch was started.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was pressed or the touch was started.\n */\nCameraEventAggregator.prototype.getButtonPressTime = function (type, modifier) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return this._pressTime[key];\n};\n\n/**\n * Gets the time the button was released or the touch was ended.\n *\n * @param {CameraEventType} type The camera event type.\n * @param {KeyboardEventModifier} [modifier] The keyboard modifier.\n * @returns {Date} The time the button was released or the touch was ended.\n */\nCameraEventAggregator.prototype.getButtonReleaseTime = function (\n  type,\n  modifier\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const key = getKey(type, modifier);\n  return this._releaseTime[key];\n};\n\n/**\n * Signals that all of the events have been handled and the aggregator should be reset to handle new events.\n */\nCameraEventAggregator.prototype.reset = function () {\n  for (const name in this._update) {\n    if (this._update.hasOwnProperty(name)) {\n      this._update[name] = true;\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see CameraEventAggregator#destroy\n */\nCameraEventAggregator.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * handler = handler && handler.destroy();\n *\n * @see CameraEventAggregator#isDestroyed\n */\nCameraEventAggregator.prototype.destroy = function () {\n  this._eventHandler = this._eventHandler && this._eventHandler.destroy();\n  return destroyObject(this);\n};\nexport default CameraEventAggregator;\n","/**\n * Enumerates the available input for interacting with the camera.\n *\n * @enum {Number}\n */\nconst CameraEventType = {\n  /**\n   * A left mouse button press followed by moving the mouse and releasing the button.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LEFT_DRAG: 0,\n\n  /**\n   *  A right mouse button press followed by moving the mouse and releasing the button.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RIGHT_DRAG: 1,\n\n  /**\n   *  A middle mouse button press followed by moving the mouse and releasing the button.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MIDDLE_DRAG: 2,\n\n  /**\n   * Scrolling the middle mouse button.\n   *\n   * @type {Number}\n   * @constant\n   */\n  WHEEL: 3,\n\n  /**\n   * A two-finger touch on a touch surface.\n   *\n   * @type {Number}\n   * @constant\n   */\n  PINCH: 4,\n};\nexport default Object.freeze(CameraEventType);\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Creates tweens for camera flights.\n * <br /><br />\n * Mouse interaction is disabled during flights.\n *\n * @private\n */\nconst CameraFlightPath = {};\n\nfunction getAltitude(frustum, dx, dy) {\n  let near;\n  let top;\n  let right;\n  if (frustum instanceof PerspectiveFrustum) {\n    const tanTheta = Math.tan(0.5 * frustum.fovy);\n    near = frustum.near;\n    top = frustum.near * tanTheta;\n    right = frustum.aspectRatio * top;\n    return Math.max((dx * near) / right, (dy * near) / top);\n  } else if (frustum instanceof PerspectiveOffCenterFrustum) {\n    near = frustum.near;\n    top = frustum.top;\n    right = frustum.right;\n    return Math.max((dx * near) / right, (dy * near) / top);\n  }\n\n  return Math.max(dx, dy);\n}\n\nconst scratchCart = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\n\nfunction createPitchFunction(\n  startPitch,\n  endPitch,\n  heightFunction,\n  pitchAdjustHeight\n) {\n  if (defined(pitchAdjustHeight) && heightFunction(0.5) > pitchAdjustHeight) {\n    const startHeight = heightFunction(0.0);\n    const endHeight = heightFunction(1.0);\n    const middleHeight = heightFunction(0.5);\n\n    const d1 = middleHeight - startHeight;\n    const d2 = middleHeight - endHeight;\n\n    return function (time) {\n      const altitude = heightFunction(time);\n      if (time <= 0.5) {\n        const t1 = (altitude - startHeight) / d1;\n        return CesiumMath.lerp(startPitch, -CesiumMath.PI_OVER_TWO, t1);\n      }\n\n      const t2 = (altitude - endHeight) / d2;\n      return CesiumMath.lerp(-CesiumMath.PI_OVER_TWO, endPitch, 1 - t2);\n    };\n  }\n  return function (time) {\n    return CesiumMath.lerp(startPitch, endPitch, time);\n  };\n}\n\nfunction createHeightFunction(\n  camera,\n  destination,\n  startHeight,\n  endHeight,\n  optionAltitude\n) {\n  let altitude = optionAltitude;\n  const maxHeight = Math.max(startHeight, endHeight);\n\n  if (!defined(altitude)) {\n    const start = camera.position;\n    const end = destination;\n    const up = camera.up;\n    const right = camera.right;\n    const frustum = camera.frustum;\n\n    const diff = Cartesian3.subtract(start, end, scratchCart);\n    const verticalDistance = Cartesian3.magnitude(\n      Cartesian3.multiplyByScalar(up, Cartesian3.dot(diff, up), scratchCart2)\n    );\n    const horizontalDistance = Cartesian3.magnitude(\n      Cartesian3.multiplyByScalar(\n        right,\n        Cartesian3.dot(diff, right),\n        scratchCart2\n      )\n    );\n\n    altitude = Math.min(\n      getAltitude(frustum, verticalDistance, horizontalDistance) * 0.2,\n      1000000000.0\n    );\n  }\n\n  if (maxHeight < altitude) {\n    const power = 8.0;\n    const factor = 1000000.0;\n\n    const s = -Math.pow((altitude - startHeight) * factor, 1.0 / power);\n    const e = Math.pow((altitude - endHeight) * factor, 1.0 / power);\n\n    return function (t) {\n      const x = t * (e - s) + s;\n      return -Math.pow(x, power) / factor + altitude;\n    };\n  }\n\n  return function (t) {\n    return CesiumMath.lerp(startHeight, endHeight, t);\n  };\n}\n\nfunction adjustAngleForLERP(startAngle, endAngle) {\n  if (\n    CesiumMath.equalsEpsilon(\n      startAngle,\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON11\n    )\n  ) {\n    startAngle = 0.0;\n  }\n\n  if (endAngle > startAngle + Math.PI) {\n    startAngle += CesiumMath.TWO_PI;\n  } else if (endAngle < startAngle - Math.PI) {\n    startAngle -= CesiumMath.TWO_PI;\n  }\n\n  return startAngle;\n}\n\nconst scratchStart = new Cartesian3();\n\nfunction createUpdateCV(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude,\n  optionPitchAdjustHeight\n) {\n  const camera = scene.camera;\n\n  const start = Cartesian3.clone(camera.position, scratchStart);\n  const startPitch = camera.pitch;\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n  const startRoll = adjustAngleForLERP(camera.roll, roll);\n\n  const heightFunction = createHeightFunction(\n    camera,\n    destination,\n    start.z,\n    destination.z,\n    optionAltitude\n  );\n\n  const pitchFunction = createPitchFunction(\n    startPitch,\n    pitch,\n    heightFunction,\n    optionPitchAdjustHeight\n  );\n\n  function update(value) {\n    const time = value.time / duration;\n\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time),\n        pitch: pitchFunction(time),\n        roll: CesiumMath.lerp(startRoll, roll, time),\n      },\n    });\n\n    Cartesian2.lerp(start, destination, time, camera.position);\n    camera.position.z = heightFunction(time);\n  }\n  return update;\n}\n\nfunction useLongestFlight(startCart, destCart) {\n  if (startCart.longitude < destCart.longitude) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\n\nfunction useShortestFlight(startCart, destCart) {\n  const diff = startCart.longitude - destCart.longitude;\n  if (diff < -CesiumMath.PI) {\n    startCart.longitude += CesiumMath.TWO_PI;\n  } else if (diff > CesiumMath.PI) {\n    destCart.longitude += CesiumMath.TWO_PI;\n  }\n}\n\nconst scratchStartCart = new Cartographic();\nconst scratchEndCart = new Cartographic();\n\nfunction createUpdate3D(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude,\n  optionFlyOverLongitude,\n  optionFlyOverLongitudeWeight,\n  optionPitchAdjustHeight\n) {\n  const camera = scene.camera;\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  const startCart = Cartographic.clone(\n    camera.positionCartographic,\n    scratchStartCart\n  );\n  const startPitch = camera.pitch;\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n  const startRoll = adjustAngleForLERP(camera.roll, roll);\n\n  const destCart = ellipsoid.cartesianToCartographic(\n    destination,\n    scratchEndCart\n  );\n  startCart.longitude = CesiumMath.zeroToTwoPi(startCart.longitude);\n  destCart.longitude = CesiumMath.zeroToTwoPi(destCart.longitude);\n\n  let useLongFlight = false;\n\n  if (defined(optionFlyOverLongitude)) {\n    const hitLon = CesiumMath.zeroToTwoPi(optionFlyOverLongitude);\n\n    const lonMin = Math.min(startCart.longitude, destCart.longitude);\n    const lonMax = Math.max(startCart.longitude, destCart.longitude);\n\n    const hitInside = hitLon >= lonMin && hitLon <= lonMax;\n\n    if (defined(optionFlyOverLongitudeWeight)) {\n      // Distance inside  (0...2Pi)\n      const din = Math.abs(startCart.longitude - destCart.longitude);\n      // Distance outside (0...2Pi)\n      const dot = CesiumMath.TWO_PI - din;\n\n      const hitDistance = hitInside ? din : dot;\n      const offDistance = hitInside ? dot : din;\n\n      if (\n        hitDistance < offDistance * optionFlyOverLongitudeWeight &&\n        !hitInside\n      ) {\n        useLongFlight = true;\n      }\n    } else if (!hitInside) {\n      useLongFlight = true;\n    }\n  }\n\n  if (useLongFlight) {\n    useLongestFlight(startCart, destCart);\n  } else {\n    useShortestFlight(startCart, destCart);\n  }\n\n  const heightFunction = createHeightFunction(\n    camera,\n    destination,\n    startCart.height,\n    destCart.height,\n    optionAltitude\n  );\n  const pitchFunction = createPitchFunction(\n    startPitch,\n    pitch,\n    heightFunction,\n    optionPitchAdjustHeight\n  );\n\n  // Isolate scope for update function.\n  // to have local copies of vars used in lerp\n  // Othervise, if you call nex\n  // createUpdate3D (createAnimationTween)\n  // before you played animation, variables will be overwriten.\n  function isolateUpdateFunction() {\n    const startLongitude = startCart.longitude;\n    const destLongitude = destCart.longitude;\n    const startLatitude = startCart.latitude;\n    const destLatitude = destCart.latitude;\n\n    return function update(value) {\n      const time = value.time / duration;\n\n      const position = Cartesian3.fromRadians(\n        CesiumMath.lerp(startLongitude, destLongitude, time),\n        CesiumMath.lerp(startLatitude, destLatitude, time),\n        heightFunction(time),\n        ellipsoid\n      );\n\n      camera.setView({\n        destination: position,\n        orientation: {\n          heading: CesiumMath.lerp(startHeading, heading, time),\n          pitch: pitchFunction(time),\n          roll: CesiumMath.lerp(startRoll, roll, time),\n        },\n      });\n    };\n  }\n  return isolateUpdateFunction();\n}\n\nfunction createUpdate2D(\n  scene,\n  duration,\n  destination,\n  heading,\n  pitch,\n  roll,\n  optionAltitude\n) {\n  const camera = scene.camera;\n\n  const start = Cartesian3.clone(camera.position, scratchStart);\n  const startHeading = adjustAngleForLERP(camera.heading, heading);\n\n  const startHeight = camera.frustum.right - camera.frustum.left;\n  const heightFunction = createHeightFunction(\n    camera,\n    destination,\n    startHeight,\n    destination.z,\n    optionAltitude\n  );\n\n  function update(value) {\n    const time = value.time / duration;\n\n    camera.setView({\n      orientation: {\n        heading: CesiumMath.lerp(startHeading, heading, time),\n      },\n    });\n\n    Cartesian2.lerp(start, destination, time, camera.position);\n\n    const zoom = heightFunction(time);\n\n    const frustum = camera.frustum;\n    const ratio = frustum.top / frustum.right;\n\n    const incrementAmount = (zoom - (frustum.right - frustum.left)) * 0.5;\n    frustum.right += incrementAmount;\n    frustum.left -= incrementAmount;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n  return update;\n}\n\nconst scratchCartographic = new Cartographic();\nconst scratchDestination = new Cartesian3();\n\nfunction emptyFlight(complete, cancel) {\n  return {\n    startObject: {},\n    stopObject: {},\n    duration: 0.0,\n    complete: complete,\n    cancel: cancel,\n  };\n}\n\nfunction wrapCallback(controller, cb) {\n  function wrapped() {\n    if (typeof cb === \"function\") {\n      cb();\n    }\n\n    controller.enableInputs = true;\n  }\n  return wrapped;\n}\n\nCameraFlightPath.createTween = function (scene, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let destination = options.destination;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n  const mode = scene.mode;\n\n  if (mode === SceneMode.MORPHING) {\n    return emptyFlight();\n  }\n\n  const convert = defaultValue(options.convert, true);\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n  const maximumHeight = options.maximumHeight;\n  const flyOverLongitude = options.flyOverLongitude;\n  const flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  const pitchAdjustHeight = options.pitchAdjustHeight;\n  let easingFunction = options.easingFunction;\n\n  if (convert && mode !== SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(destination, scratchCartographic);\n    destination = projection.project(scratchCartographic, scratchDestination);\n  }\n\n  const camera = scene.camera;\n  const transform = options.endTransform;\n  if (defined(transform)) {\n    camera._setTransform(transform);\n  }\n\n  let duration = options.duration;\n  if (!defined(duration)) {\n    duration =\n      Math.ceil(Cartesian3.distance(camera.position, destination) / 1000000.0) +\n      2.0;\n    duration = Math.min(duration, 3.0);\n  }\n\n  const heading = defaultValue(options.heading, 0.0);\n  const pitch = defaultValue(options.pitch, -CesiumMath.PI_OVER_TWO);\n  const roll = defaultValue(options.roll, 0.0);\n\n  const controller = scene.screenSpaceCameraController;\n  controller.enableInputs = false;\n\n  const complete = wrapCallback(controller, options.complete);\n  const cancel = wrapCallback(controller, options.cancel);\n\n  const frustum = camera.frustum;\n\n  let empty = scene.mode === SceneMode.SCENE2D;\n  empty =\n    empty &&\n    Cartesian2.equalsEpsilon(camera.position, destination, CesiumMath.EPSILON6);\n  empty =\n    empty &&\n    CesiumMath.equalsEpsilon(\n      Math.max(frustum.right - frustum.left, frustum.top - frustum.bottom),\n      destination.z,\n      CesiumMath.EPSILON6\n    );\n\n  empty =\n    empty ||\n    (scene.mode !== SceneMode.SCENE2D &&\n      Cartesian3.equalsEpsilon(\n        destination,\n        camera.position,\n        CesiumMath.EPSILON10\n      ));\n\n  empty =\n    empty &&\n    CesiumMath.equalsEpsilon(\n      CesiumMath.negativePiToPi(heading),\n      CesiumMath.negativePiToPi(camera.heading),\n      CesiumMath.EPSILON10\n    ) &&\n    CesiumMath.equalsEpsilon(\n      CesiumMath.negativePiToPi(pitch),\n      CesiumMath.negativePiToPi(camera.pitch),\n      CesiumMath.EPSILON10\n    ) &&\n    CesiumMath.equalsEpsilon(\n      CesiumMath.negativePiToPi(roll),\n      CesiumMath.negativePiToPi(camera.roll),\n      CesiumMath.EPSILON10\n    );\n\n  if (empty) {\n    return emptyFlight(complete, cancel);\n  }\n\n  const updateFunctions = new Array(4);\n  updateFunctions[SceneMode.SCENE2D] = createUpdate2D;\n  updateFunctions[SceneMode.SCENE3D] = createUpdate3D;\n  updateFunctions[SceneMode.COLUMBUS_VIEW] = createUpdateCV;\n\n  if (duration <= 0.0) {\n    const newOnComplete = function () {\n      const update = updateFunctions[mode](\n        scene,\n        1.0,\n        destination,\n        heading,\n        pitch,\n        roll,\n        maximumHeight,\n        flyOverLongitude,\n        flyOverLongitudeWeight,\n        pitchAdjustHeight\n      );\n      update({ time: 1.0 });\n\n      if (typeof complete === \"function\") {\n        complete();\n      }\n    };\n    return emptyFlight(newOnComplete, cancel);\n  }\n\n  const update = updateFunctions[mode](\n    scene,\n    duration,\n    destination,\n    heading,\n    pitch,\n    roll,\n    maximumHeight,\n    flyOverLongitude,\n    flyOverLongitudeWeight,\n    pitchAdjustHeight\n  );\n\n  if (!defined(easingFunction)) {\n    const startHeight = camera.positionCartographic.height;\n    const endHeight =\n      mode === SceneMode.SCENE3D\n        ? ellipsoid.cartesianToCartographic(destination).height\n        : destination.z;\n\n    if (startHeight > endHeight && startHeight > 11500.0) {\n      easingFunction = EasingFunction.CUBIC_OUT;\n    } else {\n      easingFunction = EasingFunction.QUINTIC_IN_OUT;\n    }\n  }\n\n  return {\n    duration: duration,\n    easingFunction: easingFunction,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: duration,\n    },\n    update: update,\n    complete: complete,\n    cancel: cancel,\n  };\n};\nexport default CameraFlightPath;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\n\n/**\n * Simple abstraction for a group. This class exists to make the metadata API\n * more consistent, i.e. metadata can be accessed via\n * <code>content.group.metadata</code> much like tile metadata is accessed as\n * <code>tile.metadata</code>.\n *\n * @param {Object} options Object with the following properties:\n * @param {GroupMetadata} options.metadata The metadata associated with this group.\n *\n * @alias Cesium3DContentGroup\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function Cesium3DContentGroup(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.metadata\", options.metadata);\n  //>>includeEnd('debug');\n\n  this._metadata = options.metadata;\n}\n\nObject.defineProperties(Cesium3DContentGroup.prototype, {\n  /**\n   * Get the metadata for this group\n   *\n   * @memberof Cesium3DContentGroup.prototype\n   *\n   * @type {GroupMetadata}\n   *\n   * @readonly\n   */\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n  },\n});\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BatchTexture from \"./BatchTexture.js\";\nimport BatchTableHierarchy from \"./BatchTableHierarchy.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileColorBlendMode from \"./Cesium3DTileColorBlendMode.js\";\nimport CullFace from \"./CullFace.js\";\nimport getBinaryAccessor from \"./getBinaryAccessor.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\nconst DEFAULT_COLOR_VALUE = BatchTexture.DEFAULT_COLOR_VALUE;\nconst DEFAULT_SHOW_VALUE = BatchTexture.DEFAULT_SHOW_VALUE;\n\n/**\n * @private\n * @constructor\n */\nfunction Cesium3DTileBatchTable(\n  content,\n  featuresLength,\n  batchTableJson,\n  batchTableBinary,\n  colorChangedCallback\n) {\n  /**\n   * @readonly\n   */\n  this.featuresLength = featuresLength;\n\n  let extensions;\n  if (defined(batchTableJson)) {\n    extensions = batchTableJson.extensions;\n  }\n  this._extensions = defaultValue(extensions, {});\n\n  const properties = initializeProperties(batchTableJson);\n  this._properties = properties;\n\n  this._batchTableHierarchy = initializeHierarchy(\n    this,\n    batchTableJson,\n    batchTableBinary\n  );\n  this._batchTableBinaryProperties = getBinaryProperties(\n    featuresLength,\n    properties,\n    batchTableBinary\n  );\n\n  this._content = content;\n\n  this._batchTexture = new BatchTexture({\n    featuresLength: featuresLength,\n    colorChangedCallback: colorChangedCallback,\n    owner: content,\n    statistics: content.tileset.statistics,\n  });\n}\n\n// This can be overridden for testing purposes\nCesium3DTileBatchTable._deprecationWarning = deprecationWarning;\n\nObject.defineProperties(Cesium3DTileBatchTable.prototype, {\n  memorySizeInBytes: {\n    get: function () {\n      return this._batchTexture.memorySizeInBytes;\n    },\n  },\n});\n\nfunction initializeProperties(jsonHeader) {\n  const properties = {};\n\n  if (!defined(jsonHeader)) {\n    return properties;\n  }\n\n  for (const propertyName in jsonHeader) {\n    if (\n      jsonHeader.hasOwnProperty(propertyName) &&\n      propertyName !== \"HIERARCHY\" && // Deprecated HIERARCHY property\n      propertyName !== \"extensions\" &&\n      propertyName !== \"extras\"\n    ) {\n      properties[propertyName] = clone(jsonHeader[propertyName], true);\n    }\n  }\n\n  return properties;\n}\n\nfunction initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!defined(jsonHeader)) {\n    return;\n  }\n\n  let hierarchy = batchTable._extensions[\"3DTILES_batch_table_hierarchy\"];\n\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n  if (defined(legacyHierarchy)) {\n    Cesium3DTileBatchTable._deprecationWarning(\n      \"batchTableHierarchyExtension\",\n      \"The batch table HIERARCHY property has been moved to an extension. Use extensions.3DTILES_batch_table_hierarchy instead.\"\n    );\n    batchTable._extensions[\"3DTILES_batch_table_hierarchy\"] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!defined(hierarchy)) {\n    return;\n  }\n\n  return new BatchTableHierarchy({\n    extension: hierarchy,\n    binaryBody: binaryBody,\n  });\n}\n\nfunction getBinaryProperties(featuresLength, properties, binaryBody) {\n  let binaryProperties;\n  for (const name in properties) {\n    if (properties.hasOwnProperty(name)) {\n      const property = properties[name];\n      const byteOffset = property.byteOffset;\n      if (defined(byteOffset)) {\n        // This is a binary property\n        const componentType = property.componentType;\n        const type = property.type;\n        if (!defined(componentType)) {\n          throw new RuntimeError(\"componentType is required.\");\n        }\n        if (!defined(type)) {\n          throw new RuntimeError(\"type is required.\");\n        }\n        if (!defined(binaryBody)) {\n          throw new RuntimeError(\n            `Property ${name} requires a batch table binary.`\n          );\n        }\n\n        const binaryAccessor = getBinaryAccessor(property);\n        const componentCount = binaryAccessor.componentsPerAttribute;\n        const classType = binaryAccessor.classType;\n        const typedArray = binaryAccessor.createArrayBufferView(\n          binaryBody.buffer,\n          binaryBody.byteOffset + byteOffset,\n          featuresLength\n        );\n\n        if (!defined(binaryProperties)) {\n          binaryProperties = {};\n        }\n\n        // Store any information needed to access the binary data, including the typed array,\n        // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n        binaryProperties[name] = {\n          typedArray: typedArray,\n          componentCount: componentCount,\n          type: classType,\n        };\n      }\n    }\n  }\n  return binaryProperties;\n}\n\nCesium3DTileBatchTable.getBinaryProperties = function (\n  featuresLength,\n  batchTableJson,\n  batchTableBinary\n) {\n  return getBinaryProperties(featuresLength, batchTableJson, batchTableBinary);\n};\n\nCesium3DTileBatchTable.prototype.setShow = function (batchId, show) {\n  this._batchTexture.setShow(batchId, show);\n};\n\nCesium3DTileBatchTable.prototype.setAllShow = function (show) {\n  this._batchTexture.setAllShow(show);\n};\n\nCesium3DTileBatchTable.prototype.getShow = function (batchId) {\n  return this._batchTexture.getShow(batchId);\n};\n\nCesium3DTileBatchTable.prototype.setColor = function (batchId, color) {\n  this._batchTexture.setColor(batchId, color);\n};\n\nCesium3DTileBatchTable.prototype.setAllColor = function (color) {\n  this._batchTexture.setAllColor(color);\n};\n\nCesium3DTileBatchTable.prototype.getColor = function (batchId, result) {\n  return this._batchTexture.getColor(batchId, result);\n};\n\nCesium3DTileBatchTable.prototype.getPickColor = function (batchId) {\n  return this._batchTexture.getPickColor(batchId);\n};\n\nconst scratchColor = new Color();\n\nCesium3DTileBatchTable.prototype.applyStyle = function (style) {\n  if (!defined(style)) {\n    this.setAllColor(DEFAULT_COLOR_VALUE);\n    this.setAllShow(DEFAULT_SHOW_VALUE);\n    return;\n  }\n\n  const content = this._content;\n  const length = this.featuresLength;\n  for (let i = 0; i < length; ++i) {\n    const feature = content.getFeature(i);\n    const color = defined(style.color)\n      ? defaultValue(\n          style.color.evaluateColor(feature, scratchColor),\n          DEFAULT_COLOR_VALUE\n        )\n      : DEFAULT_COLOR_VALUE;\n    const show = defined(style.show)\n      ? defaultValue(style.show.evaluate(feature), DEFAULT_SHOW_VALUE)\n      : DEFAULT_SHOW_VALUE;\n    this.setColor(i, color);\n    this.setShow(i, show);\n  }\n};\n\nfunction getBinaryProperty(binaryProperty, index) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    return typedArray[index];\n  }\n  return binaryProperty.type.unpack(typedArray, index * componentCount);\n}\n\nfunction setBinaryProperty(binaryProperty, index, value) {\n  const typedArray = binaryProperty.typedArray;\n  const componentCount = binaryProperty.componentCount;\n  if (componentCount === 1) {\n    typedArray[index] = value;\n  } else {\n    binaryProperty.type.pack(value, typedArray, index * componentCount);\n  }\n}\n\nfunction checkBatchId(batchId, featuresLength) {\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${featuresLength}` -\n        +\").\"\n    );\n  }\n}\n\nCesium3DTileBatchTable.prototype.isClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return false;\n  }\n\n  return hierarchy.isClass(batchId, className);\n};\n\nCesium3DTileBatchTable.prototype.isExactClass = function (batchId, className) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"className\", className);\n  //>>includeEnd('debug');\n\n  return this.getExactClassName(batchId) === className;\n};\n\nCesium3DTileBatchTable.prototype.getExactClassName = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n\n  const hierarchy = this._batchTableHierarchy;\n  if (!defined(hierarchy)) {\n    return undefined;\n  }\n\n  return hierarchy.getClassName(batchId);\n};\n\nCesium3DTileBatchTable.prototype.hasProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  return (\n    defined(this._properties[name]) ||\n    (defined(this._batchTableHierarchy) &&\n      this._batchTableHierarchy.hasProperty(batchId, name))\n  );\n};\n\n/**\n * @private\n */\nCesium3DTileBatchTable.prototype.hasPropertyBySemantic = function () {\n  // Cesium 3D Tiles 1.0 formats do not have semantics\n  return false;\n};\n\nCesium3DTileBatchTable.prototype.getPropertyNames = function (\n  batchId,\n  results\n) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  //>>includeEnd('debug');\n\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  const scratchPropertyNames = Object.keys(this._properties);\n  results.push.apply(results, scratchPropertyNames);\n\n  if (defined(this._batchTableHierarchy)) {\n    results.push.apply(\n      results,\n      this._batchTableHierarchy.getPropertyIds(batchId, scratchPropertyNames)\n    );\n  }\n\n  return results;\n};\n\n/**\n * @private\n */\nCesium3DTileBatchTable.prototype.getPropertyBySemantic = function (\n  batchId,\n  name\n) {\n  // Cesium 3D Tiles 1.0 formats do not have semantics\n  return undefined;\n};\n\nCesium3DTileBatchTable.prototype.getProperty = function (batchId, name) {\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, this.featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    const binaryProperty = this._batchTableBinaryProperties[name];\n    if (defined(binaryProperty)) {\n      return getBinaryProperty(binaryProperty, batchId);\n    }\n  }\n\n  const propertyValues = this._properties[name];\n  if (defined(propertyValues)) {\n    return clone(propertyValues[batchId], true);\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    const hierarchyProperty = this._batchTableHierarchy.getProperty(\n      batchId,\n      name\n    );\n    if (defined(hierarchyProperty)) {\n      return hierarchyProperty;\n    }\n  }\n\n  return undefined;\n};\n\nCesium3DTileBatchTable.prototype.setProperty = function (batchId, name, value) {\n  const featuresLength = this.featuresLength;\n  //>>includeStart('debug', pragmas.debug);\n  checkBatchId(batchId, featuresLength);\n  Check.typeOf.string(\"name\", name);\n  //>>includeEnd('debug');\n\n  if (defined(this._batchTableBinaryProperties)) {\n    const binaryProperty = this._batchTableBinaryProperties[name];\n    if (defined(binaryProperty)) {\n      setBinaryProperty(binaryProperty, batchId, value);\n      return;\n    }\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    if (this._batchTableHierarchy.setProperty(batchId, name, value)) {\n      return;\n    }\n  }\n\n  let propertyValues = this._properties[name];\n  if (!defined(propertyValues)) {\n    // Property does not exist. Create it.\n    this._properties[name] = new Array(featuresLength);\n    propertyValues = this._properties[name];\n  }\n\n  propertyValues[batchId] = clone(value, true);\n};\n\nfunction getGlslComputeSt(batchTable) {\n  // GLSL batchId is zero-based: [0, featuresLength - 1]\n  if (batchTable._batchTexture.textureDimensions.y === 1) {\n    return (\n      \"uniform vec4 tile_textureStep; \\n\" +\n      \"vec2 computeSt(float batchId) \\n\" +\n      \"{ \\n\" +\n      \"    float stepX = tile_textureStep.x; \\n\" +\n      \"    float centerX = tile_textureStep.y; \\n\" +\n      \"    return vec2(centerX + (batchId * stepX), 0.5); \\n\" +\n      \"} \\n\"\n    );\n  }\n\n  return (\n    \"uniform vec4 tile_textureStep; \\n\" +\n    \"uniform vec2 tile_textureDimensions; \\n\" +\n    \"vec2 computeSt(float batchId) \\n\" +\n    \"{ \\n\" +\n    \"    float stepX = tile_textureStep.x; \\n\" +\n    \"    float centerX = tile_textureStep.y; \\n\" +\n    \"    float stepY = tile_textureStep.z; \\n\" +\n    \"    float centerY = tile_textureStep.w; \\n\" +\n    \"    float xId = mod(batchId, tile_textureDimensions.x); \\n\" +\n    \"    float yId = floor(batchId / tile_textureDimensions.x); \\n\" +\n    \"    return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); \\n\" +\n    \"} \\n\"\n  );\n}\n\nCesium3DTileBatchTable.prototype.getVertexShaderCallback = function (\n  handleTranslucent,\n  batchIdAttributeName,\n  diffuseAttributeOrUniformName\n) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  const that = this;\n  return function (source) {\n    // If the color blend mode is HIGHLIGHT, the highlight color will always be applied in the fragment shader.\n    // No need to apply the highlight color in the vertex shader as well.\n    const renamedSource = modifyDiffuse(\n      source,\n      diffuseAttributeOrUniformName,\n      false\n    );\n    let newMain;\n\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, perform per-feature show/hide in the vertex shader\n      newMain = \"\";\n      if (handleTranslucent) {\n        newMain += \"uniform bool tile_translucentCommand; \\n\";\n      }\n      newMain +=\n        `${\n          \"uniform sampler2D tile_batchTexture; \\n\" +\n          \"varying vec4 tile_featureColor; \\n\" +\n          \"varying vec2 tile_featureSt; \\n\" +\n          \"void main() \\n\" +\n          \"{ \\n\" +\n          \"    vec2 st = computeSt(\"\n        }${batchIdAttributeName}); \\n` +\n        `    vec4 featureProperties = texture2D(tile_batchTexture, st); \\n` +\n        `    tile_color(featureProperties); \\n` +\n        `    float show = ceil(featureProperties.a); \\n` + // 0 - false, non-zeo - true\n        `    gl_Position *= show; \\n`; // Per-feature show/hide\n      if (handleTranslucent) {\n        newMain +=\n          \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" +\n          \"    if (czm_pass == czm_passTranslucent) \\n\" +\n          \"    { \\n\" +\n          \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" + // Do not render opaque features in the translucent pass\n          \"        { \\n\" +\n          \"            gl_Position *= 0.0; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\" +\n          \"    else \\n\" +\n          \"    { \\n\" +\n          \"        if (isStyleTranslucent) \\n\" + // Do not render translucent features in the opaque pass\n          \"        { \\n\" +\n          \"            gl_Position *= 0.0; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\";\n      }\n      newMain +=\n        \"    tile_featureColor = featureProperties; \\n\" +\n        \"    tile_featureSt = st; \\n\" +\n        \"}\";\n    } else {\n      // When VTF is not supported, color blend mode MIX will look incorrect due to the feature's color not being available in the vertex shader\n      newMain =\n        `${\n          \"varying vec2 tile_featureSt; \\n\" +\n          \"void main() \\n\" +\n          \"{ \\n\" +\n          \"    tile_color(vec4(1.0)); \\n\" +\n          \"    tile_featureSt = computeSt(\"\n        }${batchIdAttributeName}); \\n` + `}`;\n    }\n\n    return `${renamedSource}\\n${getGlslComputeSt(that)}${newMain}`;\n  };\n};\n\nfunction getDefaultShader(source, applyHighlight) {\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n\n  if (!applyHighlight) {\n    return (\n      `${source}void tile_color(vec4 tile_featureColor) \\n` +\n      `{ \\n` +\n      `    tile_main(); \\n` +\n      `} \\n`\n    );\n  }\n\n  // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // gl_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n  return (\n    `${source}uniform float tile_colorBlend; \\n` +\n    `void tile_color(vec4 tile_featureColor) \\n` +\n    `{ \\n` +\n    `    tile_main(); \\n` +\n    `    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n` +\n    `    gl_FragColor.a *= tile_featureColor.a; \\n` +\n    `    float highlight = ceil(tile_colorBlend); \\n` +\n    `    gl_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n` +\n    `} \\n`\n  );\n}\n\nfunction replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName) {\n  const functionCall = `texture2D(${diffuseAttributeOrUniformName}`;\n\n  let fromIndex = 0;\n  let startIndex = source.indexOf(functionCall, fromIndex);\n  let endIndex;\n\n  while (startIndex > -1) {\n    let nestedLevel = 0;\n    for (let i = startIndex; i < source.length; ++i) {\n      const character = source.charAt(i);\n      if (character === \"(\") {\n        ++nestedLevel;\n      } else if (character === \")\") {\n        --nestedLevel;\n        if (nestedLevel === 0) {\n          endIndex = i + 1;\n          break;\n        }\n      }\n    }\n    const extractedFunction = source.slice(startIndex, endIndex);\n    const replacedFunction = `tile_diffuse_final(${extractedFunction}, tile_diffuse)`;\n\n    source =\n      source.slice(0, startIndex) + replacedFunction + source.slice(endIndex);\n    fromIndex = startIndex + replacedFunction.length;\n    startIndex = source.indexOf(functionCall, fromIndex);\n  }\n\n  return source;\n}\n\nfunction modifyDiffuse(source, diffuseAttributeOrUniformName, applyHighlight) {\n  // If the glTF does not specify the _3DTILESDIFFUSE semantic, return the default shader.\n  // Otherwise if _3DTILESDIFFUSE is defined prefer the shader below that can switch the color mode at runtime.\n  if (!defined(diffuseAttributeOrUniformName)) {\n    return getDefaultShader(source, applyHighlight);\n  }\n\n  // Find the diffuse uniform. Examples matches:\n  //   uniform vec3 u_diffuseColor;\n  //   uniform sampler2D diffuseTexture;\n  let regex = new RegExp(\n    `(uniform|attribute|in)\\\\s+(vec[34]|sampler2D)\\\\s+${diffuseAttributeOrUniformName};`\n  );\n  const uniformMatch = source.match(regex);\n\n  if (!defined(uniformMatch)) {\n    // Could not find uniform declaration of type vec3, vec4, or sampler2D\n    return getDefaultShader(source, applyHighlight);\n  }\n\n  const declaration = uniformMatch[0];\n  const type = uniformMatch[2];\n\n  source = ShaderSource.replaceMain(source, \"tile_main\");\n  source = source.replace(declaration, \"\"); // Remove uniform declaration for now so the replace below doesn't affect it\n\n  // If the tile color is white, use the source color. This implies the feature has not been styled.\n  // Highlight: tile_colorBlend is 0.0 and the source color is used\n  // Replace: tile_colorBlend is 1.0 and the tile color is used\n  // Mix: tile_colorBlend is between 0.0 and 1.0, causing the source color and tile color to mix\n  const finalDiffuseFunction =\n    \"bool isWhite(vec3 color) \\n\" +\n    \"{ \\n\" +\n    \"    return all(greaterThan(color, vec3(1.0 - czm_epsilon3))); \\n\" +\n    \"} \\n\" +\n    \"vec4 tile_diffuse_final(vec4 sourceDiffuse, vec4 tileDiffuse) \\n\" +\n    \"{ \\n\" +\n    \"    vec4 blendDiffuse = mix(sourceDiffuse, tileDiffuse, tile_colorBlend); \\n\" +\n    \"    vec4 diffuse = isWhite(tileDiffuse.rgb) ? sourceDiffuse : blendDiffuse; \\n\" +\n    \"    return vec4(diffuse.rgb, sourceDiffuse.a); \\n\" +\n    \"} \\n\";\n\n  // The color blend mode is intended for the RGB channels so alpha is always just multiplied.\n  // gl_FragColor is multiplied by the tile color only when tile_colorBlend is 0.0 (highlight)\n  const highlight =\n    \"    tile_featureColor = czm_gammaCorrect(tile_featureColor); \\n\" +\n    \"    gl_FragColor.a *= tile_featureColor.a; \\n\" +\n    \"    float highlight = ceil(tile_colorBlend); \\n\" +\n    \"    gl_FragColor.rgb *= mix(tile_featureColor.rgb, vec3(1.0), highlight); \\n\";\n\n  let setColor;\n  if (type === \"vec3\" || type === \"vec4\") {\n    const sourceDiffuse =\n      type === \"vec3\"\n        ? `vec4(${diffuseAttributeOrUniformName}, 1.0)`\n        : diffuseAttributeOrUniformName;\n    const replaceDiffuse =\n      type === \"vec3\" ? \"tile_diffuse.xyz\" : \"tile_diffuse\";\n    regex = new RegExp(diffuseAttributeOrUniformName, \"g\");\n    source = source.replace(regex, replaceDiffuse);\n    setColor =\n      `    vec4 source = ${sourceDiffuse}; \\n` +\n      `    tile_diffuse = tile_diffuse_final(source, tile_featureColor); \\n` +\n      `    tile_main(); \\n`;\n  } else if (type === \"sampler2D\") {\n    // Handles any number of nested parentheses\n    // E.g. texture2D(u_diffuse, uv)\n    // E.g. texture2D(u_diffuse, computeUV(index))\n    source = replaceDiffuseTextureCalls(source, diffuseAttributeOrUniformName);\n    setColor =\n      \"    tile_diffuse = tile_featureColor; \\n\" + \"    tile_main(); \\n\";\n  }\n\n  source =\n    `${\n      \"uniform float tile_colorBlend; \\n\" + \"vec4 tile_diffuse = vec4(1.0); \\n\"\n    }${finalDiffuseFunction}${declaration}\\n${source}\\n` +\n    `void tile_color(vec4 tile_featureColor) \\n` +\n    `{ \\n${setColor}`;\n\n  if (applyHighlight) {\n    source += highlight;\n  }\n\n  source += \"} \\n\";\n  return source;\n}\n\nCesium3DTileBatchTable.prototype.getFragmentShaderCallback = function (\n  handleTranslucent,\n  diffuseAttributeOrUniformName,\n  hasPremultipliedAlpha\n) {\n  if (this.featuresLength === 0) {\n    return;\n  }\n  return function (source) {\n    source = modifyDiffuse(source, diffuseAttributeOrUniformName, true);\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, per-feature show/hide already happened in the fragment shader\n      source +=\n        \"uniform sampler2D tile_pickTexture; \\n\" +\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"varying vec4 tile_featureColor; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    tile_color(tile_featureColor); \\n\";\n\n      if (hasPremultipliedAlpha) {\n        source += \"    gl_FragColor.rgb *= gl_FragColor.a; \\n\";\n      }\n\n      source += \"}\";\n    } else {\n      if (handleTranslucent) {\n        source += \"uniform bool tile_translucentCommand; \\n\";\n      }\n      source +=\n        \"uniform sampler2D tile_pickTexture; \\n\" +\n        \"uniform sampler2D tile_batchTexture; \\n\" +\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    vec4 featureProperties = texture2D(tile_batchTexture, tile_featureSt); \\n\" +\n        \"    if (featureProperties.a == 0.0) { \\n\" + // show: alpha == 0 - false, non-zeo - true\n        \"        discard; \\n\" +\n        \"    } \\n\";\n\n      if (handleTranslucent) {\n        source +=\n          \"    bool isStyleTranslucent = (featureProperties.a != 1.0); \\n\" +\n          \"    if (czm_pass == czm_passTranslucent) \\n\" +\n          \"    { \\n\" +\n          \"        if (!isStyleTranslucent && !tile_translucentCommand) \\n\" + // Do not render opaque features in the translucent pass\n          \"        { \\n\" +\n          \"            discard; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\" +\n          \"    else \\n\" +\n          \"    { \\n\" +\n          \"        if (isStyleTranslucent) \\n\" + // Do not render translucent features in the opaque pass\n          \"        { \\n\" +\n          \"            discard; \\n\" +\n          \"        } \\n\" +\n          \"    } \\n\";\n      }\n\n      source += \"    tile_color(featureProperties); \\n\";\n\n      if (hasPremultipliedAlpha) {\n        source += \"    gl_FragColor.rgb *= gl_FragColor.a; \\n\";\n      }\n\n      source += \"} \\n\";\n    }\n    return source;\n  };\n};\n\nCesium3DTileBatchTable.prototype.getClassificationFragmentShaderCallback = function () {\n  if (this.featuresLength === 0) {\n    return;\n  }\n  return function (source) {\n    source = ShaderSource.replaceMain(source, \"tile_main\");\n    if (ContextLimits.maximumVertexTextureImageUnits > 0) {\n      // When VTF is supported, per-feature show/hide already happened in the fragment shader\n      source +=\n        \"uniform sampler2D tile_pickTexture;\\n\" +\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"varying vec4 tile_featureColor; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    tile_main(); \\n\" +\n        \"    gl_FragColor = tile_featureColor; \\n\" +\n        \"    gl_FragColor.rgb *= gl_FragColor.a; \\n\" +\n        \"}\";\n    } else {\n      source +=\n        \"uniform sampler2D tile_batchTexture; \\n\" +\n        \"uniform sampler2D tile_pickTexture;\\n\" +\n        \"varying vec2 tile_featureSt; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    tile_main(); \\n\" +\n        \"    vec4 featureProperties = texture2D(tile_batchTexture, tile_featureSt); \\n\" +\n        \"    if (featureProperties.a == 0.0) { \\n\" + // show: alpha == 0 - false, non-zeo - true\n        \"        discard; \\n\" +\n        \"    } \\n\" +\n        \"    gl_FragColor = featureProperties; \\n\" +\n        \"    gl_FragColor.rgb *= gl_FragColor.a; \\n\" +\n        \"} \\n\";\n    }\n    return source;\n  };\n};\n\nfunction getColorBlend(batchTable) {\n  const tileset = batchTable._content.tileset;\n  const colorBlendMode = tileset.colorBlendMode;\n  const colorBlendAmount = tileset.colorBlendAmount;\n  if (colorBlendMode === Cesium3DTileColorBlendMode.HIGHLIGHT) {\n    return 0.0;\n  }\n  if (colorBlendMode === Cesium3DTileColorBlendMode.REPLACE) {\n    return 1.0;\n  }\n  if (colorBlendMode === Cesium3DTileColorBlendMode.MIX) {\n    // The value 0.0 is reserved for highlight, so clamp to just above 0.0.\n    return CesiumMath.clamp(colorBlendAmount, CesiumMath.EPSILON4, 1.0);\n  }\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(`Invalid color blend mode \"${colorBlendMode}\".`);\n  //>>includeEnd('debug');\n}\n\nCesium3DTileBatchTable.prototype.getUniformMapCallback = function () {\n  if (this.featuresLength === 0) {\n    return;\n  }\n\n  const that = this;\n  return function (uniformMap) {\n    const batchUniformMap = {\n      tile_batchTexture: function () {\n        // PERFORMANCE_IDEA: we could also use a custom shader that avoids the texture read.\n        return defaultValue(\n          that._batchTexture.batchTexture,\n          that._batchTexture.defaultTexture\n        );\n      },\n      tile_textureDimensions: function () {\n        return that._batchTexture.textureDimensions;\n      },\n      tile_textureStep: function () {\n        return that._batchTexture.textureStep;\n      },\n      tile_colorBlend: function () {\n        return getColorBlend(that);\n      },\n      tile_pickTexture: function () {\n        return that._batchTexture.pickTexture;\n      },\n    };\n\n    return combine(uniformMap, batchUniformMap);\n  };\n};\n\nCesium3DTileBatchTable.prototype.getPickId = function () {\n  return \"texture2D(tile_pickTexture, tile_featureSt)\";\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nconst StyleCommandsNeeded = {\n  ALL_OPAQUE: 0,\n  ALL_TRANSLUCENT: 1,\n  OPAQUE_AND_TRANSLUCENT: 2,\n};\n\nCesium3DTileBatchTable.prototype.addDerivedCommands = function (\n  frameState,\n  commandStart\n) {\n  const commandList = frameState.commandList;\n  const commandEnd = commandList.length;\n  const tile = this._content._tile;\n  const finalResolution = tile._finalResolution;\n  const tileset = tile.tileset;\n  const bivariateVisibilityTest =\n    tileset._skipLevelOfDetail &&\n    tileset._hasMixedContent &&\n    frameState.context.stencilBuffer;\n  const styleCommandsNeeded = getStyleCommandsNeeded(this);\n\n  for (let i = commandStart; i < commandEnd; ++i) {\n    const command = commandList[i];\n    if (command.pass === Pass.COMPUTE) {\n      continue;\n    }\n\n    let derivedCommands = command.derivedCommands.tileset;\n    if (!defined(derivedCommands) || command.dirty) {\n      derivedCommands = {};\n      command.derivedCommands.tileset = derivedCommands;\n      derivedCommands.originalCommand = deriveCommand(command);\n      command.dirty = false;\n    }\n    const originalCommand = derivedCommands.originalCommand;\n\n    if (\n      styleCommandsNeeded !== StyleCommandsNeeded.ALL_OPAQUE &&\n      command.pass !== Pass.TRANSLUCENT\n    ) {\n      if (!defined(derivedCommands.translucent)) {\n        derivedCommands.translucent = deriveTranslucentCommand(originalCommand);\n      }\n    }\n\n    if (\n      styleCommandsNeeded !== StyleCommandsNeeded.ALL_TRANSLUCENT &&\n      command.pass !== Pass.TRANSLUCENT\n    ) {\n      if (!defined(derivedCommands.opaque)) {\n        derivedCommands.opaque = deriveOpaqueCommand(originalCommand);\n      }\n\n      if (bivariateVisibilityTest) {\n        if (!finalResolution) {\n          if (!defined(derivedCommands.zback)) {\n            derivedCommands.zback = deriveZBackfaceCommand(\n              frameState.context,\n              originalCommand\n            );\n          }\n          tileset._backfaceCommands.push(derivedCommands.zback);\n        }\n        if (\n          !defined(derivedCommands.stencil) ||\n          tile._selectionDepth !==\n            getLastSelectionDepth(derivedCommands.stencil)\n        ) {\n          if (command.renderState.depthMask) {\n            derivedCommands.stencil = deriveStencilCommand(\n              originalCommand,\n              tile._selectionDepth\n            );\n          } else {\n            // Ignore if tile does not write depth\n            derivedCommands.stencil = derivedCommands.opaque;\n          }\n        }\n      }\n    }\n\n    const opaqueCommand = bivariateVisibilityTest\n      ? derivedCommands.stencil\n      : derivedCommands.opaque;\n    const translucentCommand = derivedCommands.translucent;\n\n    // If the command was originally opaque:\n    //    * If the styling applied to the tile is all opaque, use the opaque command\n    //      (with one additional uniform needed for the shader).\n    //    * If the styling is all translucent, use new (cached) derived commands (front\n    //      and back faces) with a translucent render state.\n    //    * If the styling causes both opaque and translucent features in this tile,\n    //      then use both sets of commands.\n    if (command.pass !== Pass.TRANSLUCENT) {\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_OPAQUE) {\n        commandList[i] = opaqueCommand;\n      }\n      if (styleCommandsNeeded === StyleCommandsNeeded.ALL_TRANSLUCENT) {\n        commandList[i] = translucentCommand;\n      }\n      if (styleCommandsNeeded === StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT) {\n        // PERFORMANCE_IDEA: if the tile has multiple commands, we do not know what features are in what\n        // commands so this case may be overkill.\n        commandList[i] = opaqueCommand;\n        commandList.push(translucentCommand);\n      }\n    } else {\n      // Command was originally translucent so no need to derive new commands;\n      // as of now, a style can't change an originally translucent feature to\n      // opaque since the style's alpha is modulated, not a replacement.  When\n      // this changes, we need to derive new opaque commands here.\n      commandList[i] = originalCommand;\n    }\n  }\n};\n\nfunction getStyleCommandsNeeded(batchTable) {\n  const translucentFeaturesLength =\n    batchTable._batchTexture.translucentFeaturesLength;\n\n  if (translucentFeaturesLength === 0) {\n    return StyleCommandsNeeded.ALL_OPAQUE;\n  } else if (translucentFeaturesLength === batchTable.featuresLength) {\n    return StyleCommandsNeeded.ALL_TRANSLUCENT;\n  }\n\n  return StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT;\n}\n\nfunction deriveCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n\n  // Add a uniform to indicate if the original command was translucent so\n  // the shader knows not to cull vertices that were originally transparent\n  // even though their style is opaque.\n  const translucentCommand = derivedCommand.pass === Pass.TRANSLUCENT;\n\n  derivedCommand.uniformMap = defined(derivedCommand.uniformMap)\n    ? derivedCommand.uniformMap\n    : {};\n  derivedCommand.uniformMap.tile_translucentCommand = function () {\n    return translucentCommand;\n  };\n\n  return derivedCommand;\n}\n\nfunction deriveTranslucentCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.pass = Pass.TRANSLUCENT;\n  derivedCommand.renderState = getTranslucentRenderState(command.renderState);\n  return derivedCommand;\n}\n\nfunction deriveOpaqueCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.renderState = getOpaqueRenderState(command.renderState);\n  return derivedCommand;\n}\n\nfunction getLogDepthPolygonOffsetFragmentShaderProgram(context, shaderProgram) {\n  let shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    \"zBackfaceLogDepth\"\n  );\n  if (!defined(shader)) {\n    const fs = shaderProgram.fragmentShaderSource.clone();\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    fs.defines.push(\"POLYGON_OFFSET\");\n\n    fs.sources.unshift(\n      \"#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n\"\n    );\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      \"zBackfaceLogDepth\",\n      {\n        vertexShaderSource: shaderProgram.vertexShaderSource,\n        fragmentShaderSource: fs,\n        attributeLocations: shaderProgram._attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nfunction deriveZBackfaceCommand(context, command) {\n  // Write just backface depth of unresolved tiles so resolved stenciled tiles do not appear in front\n  const derivedCommand = DrawCommand.shallowClone(command);\n  const rs = clone(derivedCommand.renderState, true);\n  rs.cull.enabled = true;\n  rs.cull.face = CullFace.FRONT;\n  // Back faces do not need to write color.\n  rs.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n  // Push back face depth away from the camera so it is less likely that back faces and front faces of the same tile\n  // intersect and overlap. This helps avoid flickering for very thin double-sided walls.\n  rs.polygonOffset = {\n    enabled: true,\n    factor: 5.0,\n    units: 5.0,\n  };\n  // Set the 3D Tiles bit\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  derivedCommand.castShadows = false;\n  derivedCommand.receiveShadows = false;\n  derivedCommand.uniformMap = clone(command.uniformMap);\n\n  const polygonOffset = new Cartesian2(5.0, 5.0);\n  derivedCommand.uniformMap.u_polygonOffset = function () {\n    return polygonOffset;\n  };\n\n  // Make the log depth depth fragment write account for the polygon offset, too.\n  // Otherwise, the back face commands will cause the higher resolution\n  // tiles to disappear.\n  derivedCommand.shaderProgram = getLogDepthPolygonOffsetFragmentShaderProgram(\n    context,\n    command.shaderProgram\n  );\n  return derivedCommand;\n}\n\nfunction deriveStencilCommand(command, reference) {\n  // Tiles only draw if their selection depth is >= the tile drawn already. They write their\n  // selection depth to the stencil buffer to prevent ancestor tiles from drawing on top\n  const derivedCommand = DrawCommand.shallowClone(command);\n  const rs = clone(derivedCommand.renderState, true);\n  // Stencil test is masked to the most significant 3 bits so the reference is shifted. Writes 0 for the terrain bit\n  rs.stencilTest.enabled = true;\n  rs.stencilTest.mask = StencilConstants.SKIP_LOD_MASK;\n  rs.stencilTest.reference =\n    StencilConstants.CESIUM_3D_TILE_MASK |\n    (reference << StencilConstants.SKIP_LOD_BIT_SHIFT);\n  rs.stencilTest.frontFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.frontOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilTest.backFunction = StencilFunction.GREATER_OR_EQUAL;\n  rs.stencilTest.backOperation.zPass = StencilOperation.REPLACE;\n  rs.stencilMask =\n    StencilConstants.CESIUM_3D_TILE_MASK | StencilConstants.SKIP_LOD_MASK;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n  return derivedCommand;\n}\n\nfunction getLastSelectionDepth(stencilCommand) {\n  // Isolate the selection depth from the stencil reference.\n  const reference = stencilCommand.renderState.stencilTest.reference;\n  return (\n    (reference & StencilConstants.SKIP_LOD_MASK) >>>\n    StencilConstants.SKIP_LOD_BIT_SHIFT\n  );\n}\n\nfunction getTranslucentRenderState(renderState) {\n  const rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n\n  return RenderState.fromCache(rs);\n}\n\nfunction getOpaqueRenderState(renderState) {\n  const rs = clone(renderState, true);\n  rs.stencilTest = StencilConstants.setCesium3DTileBit();\n  rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n\n  return RenderState.fromCache(rs);\n}\n\nCesium3DTileBatchTable.prototype.update = function (tileset, frameState) {\n  this._batchTexture.update(tileset, frameState);\n};\n\nCesium3DTileBatchTable.prototype.isDestroyed = function () {\n  return false;\n};\n\nCesium3DTileBatchTable.prototype.destroy = function () {\n  this._batchTexture = this._batchTexture && this._batchTexture.destroy();\n  return destroyObject(this);\n};\nexport default Cesium3DTileBatchTable;\n","/**\n * Defines how per-feature colors set from the Cesium API or declarative styling blend with the source colors from\n * the original feature, e.g. glTF material or per-point color in the tile.\n * <p>\n * When <code>REPLACE</code> or <code>MIX</code> are used and the source color is a glTF material, the technique must assign the\n * <code>_3DTILESDIFFUSE</code> semantic to the diffuse color parameter. Otherwise only <code>HIGHLIGHT</code> is supported.\n * </p>\n * <p>\n * A feature whose color evaluates to white (1.0, 1.0, 1.0) is always rendered without color blending, regardless of the\n * tileset's color blend mode.\n * </p>\n * <pre><code>\n * \"techniques\": {\n *   \"technique0\": {\n *     \"parameters\": {\n *       \"diffuse\": {\n *         \"semantic\": \"_3DTILESDIFFUSE\",\n *         \"type\": 35666\n *       }\n *     }\n *   }\n * }\n * </code></pre>\n *\n * @enum {Number}\n */\nconst Cesium3DTileColorBlendMode = {\n  /**\n   * Multiplies the source color by the feature color.\n   *\n   * @type {Number}\n   * @constant\n   */\n  HIGHLIGHT: 0,\n\n  /**\n   * Replaces the source color with the feature color.\n   *\n   * @type {Number}\n   * @constant\n   */\n  REPLACE: 1,\n\n  /**\n   * Blends the source color and feature color together.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MIX: 2,\n};\nexport default Object.freeze(Cesium3DTileColorBlendMode);\n","import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * The content of a tile in a {@link Cesium3DTileset}.\n * <p>\n * Derived classes of this interface provide access to individual features in the tile.\n * Access derived objects through {@link Cesium3DTile#content}.\n * </p>\n * <p>\n * This type describes an interface and is not intended to be instantiated directly.\n * </p>\n *\n * @alias Cesium3DTileContent\n * @constructor\n */\nfunction Cesium3DTileContent() {\n  /**\n   * Gets or sets if any feature's property changed.  Used to\n   * optimized applying a style when a feature's property changed.\n   * <p>\n   * This is used to implement the <code>Cesium3DTileContent</code> interface, but is\n   * not part of the public Cesium API.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @private\n   */\n  this.featurePropertiesDirty = false;\n}\n\nObject.defineProperties(Cesium3DTileContent.prototype, {\n  /**\n   * Gets the number of features in the tile.\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  featuresLength: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the number of points in the tile.\n   * <p>\n   * Only applicable for tiles with Point Cloud content. This is different than {@link Cesium3DTileContent#featuresLength} which\n   * equals the number of groups of points as distinguished by the <code>BATCH_ID</code> feature table semantic.\n   * </p>\n   *\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud#batched-points}\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pointsLength: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the number of triangles in the tile.\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the tile's geometry memory in bytes.\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the tile's texture memory in bytes.\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  texturesByteLength: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the amount of memory used by the batch table textures, in bytes.\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  batchTableByteLength: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the array of {@link Cesium3DTileContent} objects for contents that contain other contents, such as composite tiles. The inner contents may in turn have inner contents, such as a composite tile that contains a composite tile.\n   *\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Composite|Composite specification}\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Array}\n   * @readonly\n   */\n  innerContents: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the promise that will be resolved when the tile's content is ready to render.\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Promise.<Cesium3DTileContent>}\n   * @readonly\n   */\n  readyPromise: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the tileset for this tile.\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Cesium3DTileset}\n   * @readonly\n   */\n  tileset: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the tile containing this content.\n   *\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {Cesium3DTile}\n   * @readonly\n   */\n  tile: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the url of the tile's content.\n   * @memberof Cesium3DTileContent.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the batch table for this content.\n   * <p>\n   * This is used to implement the <code>Cesium3DTileContent</code> interface, but is\n   * not part of the public Cesium API.\n   * </p>\n   *\n   * @type {Cesium3DTileBatchTable}\n   * @readonly\n   *\n   * @private\n   */\n  batchTable: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the metadata for this content, whether it is available explicitly or via\n   * implicit tiling. If there is no metadata, this property should be undefined.\n   * <p>\n   * This is used to implement the <code>Cesium3DTileContent</code> interface, but is\n   * not part of the public Cesium API.\n   * </p>\n   *\n   * @type {ImplicitMetadataView|undefined}\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  metadata: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n    set: function (value) {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n\n  /**\n   * Gets the group for this content if the content has metadata (3D Tiles 1.1) or\n   * if it uses the <code>3DTILES_metadata</code> extension. If neither are present,\n   * this property should be undefined.\n   * <p>\n   * This is used to implement the <code>Cesium3DTileContent</code> interface, but is\n   * not part of the public Cesium API.\n   * </p>\n   *\n   * @type {Cesium3DTileContentGroup|undefined}\n   *\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  group: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n    set: function (value) {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n});\n\n/**\n * Returns whether the feature has this property.\n *\n * @param {Number} batchId The batchId for the feature.\n * @param {String} name The case-sensitive name of the property.\n * @returns {Boolean} <code>true</code> if the feature has this property; otherwise, <code>false</code>.\n */\nCesium3DTileContent.prototype.hasProperty = function (batchId, name) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns the {@link Cesium3DTileFeature} object for the feature with the\n * given <code>batchId</code>.  This object is used to get and modify the\n * feature's properties.\n * <p>\n * Features in a tile are ordered by <code>batchId</code>, an index used to retrieve their metadata from the batch table.\n * </p>\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/BatchTable}.\n *\n * @param {Number} batchId The batchId for the feature.\n * @returns {Cesium3DTileFeature} The corresponding {@link Cesium3DTileFeature} object.\n *\n * @exception {DeveloperError} batchId must be between zero and {@link Cesium3DTileContent#featuresLength} - 1.\n */\nCesium3DTileContent.prototype.getFeature = function (batchId) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n     * Called when {@link Cesium3DTileset#debugColorizeTiles} changes.\n     * <p>\n     * This is used to implement the <code>Cesium3DTileContent</code> interface, but is\n     * not part of the public Cesium API.\n     * </p>\n     *\n     * @param {Boolean} enabled Whether to enable or disable debug settings.\n     * @returns {Cesium3DTileFeature} The corresponding {@link Cesium3DTileFeature} object.\n\n     * @private\n     */\nCesium3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Apply a style to the content\n * <p>\n * This is used to implement the <code>Cesium3DTileContent</code> interface, but is\n * not part of the public Cesium API.\n * </p>\n *\n * @param {Cesium3DTileStyle} style The style.\n *\n * @private\n */\nCesium3DTileContent.prototype.applyStyle = function (style) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Called by the tile during tileset traversal to get the draw commands needed to render this content.\n * When the tile's content is in the PROCESSING state, this creates WebGL resources to ultimately\n * move to the READY state.\n * <p>\n * This is used to implement the <code>Cesium3DTileContent</code> interface, but is\n * not part of the public Cesium API.\n * </p>\n *\n * @param {Cesium3DTileset} tileset The tileset containing this tile.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nCesium3DTileContent.prototype.update = function (tileset, frameState) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * <p>\n * This is used to implement the <code>Cesium3DTileContent</code> interface, but is\n * not part of the public Cesium API.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Cesium3DTileContent#destroy\n *\n * @private\n */\nCesium3DTileContent.prototype.isDestroyed = function () {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * <p>\n * This is used to implement the <code>Cesium3DTileContent</code> interface, but is\n * not part of the public Cesium API.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * content = content && content.destroy();\n *\n * @see Cesium3DTileContent#isDestroyed\n *\n * @private\n */\nCesium3DTileContent.prototype.destroy = function () {\n  DeveloperError.throwInstantiationError();\n};\nexport default Cesium3DTileContent;\n","import Batched3DModel3DTileContent from \"./Batched3DModel3DTileContent.js\";\nimport Composite3DTileContent from \"./Composite3DTileContent.js\";\nimport Geometry3DTileContent from \"./Geometry3DTileContent.js\";\nimport Implicit3DTileContent from \"./Implicit3DTileContent.js\";\nimport Instanced3DModel3DTileContent from \"./Instanced3DModel3DTileContent.js\";\nimport PointCloud3DTileContent from \"./PointCloud3DTileContent.js\";\nimport Tileset3DTileContent from \"./Tileset3DTileContent.js\";\nimport Vector3DTileContent from \"./Vector3DTileContent.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ModelExperimental3DTileContent from \"./ModelExperimental/ModelExperimental3DTileContent.js\";\n\n/**\n * Maps a tile's magic field in its header to a new content object for the tile's payload.\n *\n * @private\n */\nconst Cesium3DTileContentFactory = {\n  b3dm: function (tileset, tile, resource, arrayBuffer, byteOffset) {\n    if (tileset.enableModelExperimental) {\n      return ModelExperimental3DTileContent.fromB3dm(\n        tileset,\n        tile,\n        resource,\n        arrayBuffer,\n        byteOffset\n      );\n    }\n    return new Batched3DModel3DTileContent(\n      tileset,\n      tile,\n      resource,\n      arrayBuffer,\n      byteOffset\n    );\n  },\n  pnts: function (tileset, tile, resource, arrayBuffer, byteOffset) {\n    if (tileset.enableModelExperimental) {\n      return ModelExperimental3DTileContent.fromPnts(\n        tileset,\n        tile,\n        resource,\n        arrayBuffer,\n        byteOffset\n      );\n    }\n    return new PointCloud3DTileContent(\n      tileset,\n      tile,\n      resource,\n      arrayBuffer,\n      byteOffset\n    );\n  },\n  i3dm: function (tileset, tile, resource, arrayBuffer, byteOffset) {\n    if (tileset.enableModelExperimental) {\n      return ModelExperimental3DTileContent.fromI3dm(\n        tileset,\n        tile,\n        resource,\n        arrayBuffer,\n        byteOffset\n      );\n    }\n    return new Instanced3DModel3DTileContent(\n      tileset,\n      tile,\n      resource,\n      arrayBuffer,\n      byteOffset\n    );\n  },\n  cmpt: function (tileset, tile, resource, arrayBuffer, byteOffset) {\n    // Send in the factory in order to avoid a cyclical dependency\n    return new Composite3DTileContent(\n      tileset,\n      tile,\n      resource,\n      arrayBuffer,\n      byteOffset,\n      Cesium3DTileContentFactory\n    );\n  },\n  externalTileset: function (tileset, tile, resource, json) {\n    return new Tileset3DTileContent(tileset, tile, resource, json);\n  },\n  geom: function (tileset, tile, resource, arrayBuffer, byteOffset) {\n    return new Geometry3DTileContent(\n      tileset,\n      tile,\n      resource,\n      arrayBuffer,\n      byteOffset\n    );\n  },\n  vctr: function (tileset, tile, resource, arrayBuffer, byteOffset) {\n    return new Vector3DTileContent(\n      tileset,\n      tile,\n      resource,\n      arrayBuffer,\n      byteOffset\n    );\n  },\n  subt: function (tileset, tile, resource, arrayBuffer, byteOffset) {\n    return new Implicit3DTileContent(\n      tileset,\n      tile,\n      resource,\n      undefined,\n      arrayBuffer,\n      byteOffset\n    );\n  },\n  subtreeJson: function (tileset, tile, resource, json) {\n    return new Implicit3DTileContent(tileset, tile, resource, json);\n  },\n  glb: function (tileset, tile, resource, arrayBuffer, byteOffset) {\n    const arrayBufferByteLength = arrayBuffer.byteLength;\n    if (arrayBufferByteLength < 12) {\n      throw new RuntimeError(\"Invalid glb content\");\n    }\n    const dataView = new DataView(arrayBuffer, byteOffset);\n    const byteLength = dataView.getUint32(8, true);\n    const glb = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n    return ModelExperimental3DTileContent.fromGltf(\n      tileset,\n      tile,\n      resource,\n      glb\n    );\n  },\n  gltf: function (tileset, tile, resource, json) {\n    return ModelExperimental3DTileContent.fromGltf(\n      tileset,\n      tile,\n      resource,\n      json\n    );\n  },\n  geoJson: function (tileset, tile, resource, json) {\n    return ModelExperimental3DTileContent.fromGeoJson(\n      tileset,\n      tile,\n      resource,\n      json\n    );\n  },\n};\nexport default Cesium3DTileContentFactory;\n","/**\n * @private\n */\nconst Cesium3DTileContentState = {\n  UNLOADED: 0, // Has never been requested\n  LOADING: 1, // Is waiting on a pending request\n  PROCESSING: 2, // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.\n  READY: 3, // Ready to render.\n  EXPIRED: 4, // Is expired and will be unloaded once new content is loaded.\n  FAILED: 5, // Request failed.\n};\nexport default Object.freeze(Cesium3DTileContentState);\n","/**\n * An enum to indicate the different types of {@link Cesium3DTileContent}.\n * For binary files, the enum value is the magic number of the binary file\n * unless otherwise noted. For JSON files, the enum value is a unique name\n * for internal use.\n *\n * @enum {String}\n * @see Cesium3DTileContent\n *\n * @private\n */\nconst Cesium3DTileContentType = {\n  /**\n   * A Batched 3D Model. This is a binary format with\n   * magic number <code>b3dm</code>\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  BATCHED_3D_MODEL: \"b3dm\",\n  /**\n   * An Instanced 3D Model. This is a binary format with magic number\n   * <code>i3dm</code>\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  INSTANCED_3D_MODEL: \"i3dm\",\n  /**\n   * A Composite model. This is a binary format with magic number\n   * <code>cmpt</code>\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  COMPOSITE: \"cmpt\",\n  /**\n   * A Point Cloud model. This is a binary format with magic number\n   * <code>pnts</code>\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  POINT_CLOUD: \"pnts\",\n  /**\n   * Vector tiles. This is a binary format with magic number\n   * <code>vctr</code>\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  VECTOR: \"vctr\",\n  /**\n   * Geometry tiles. This is a binary format with magic number\n   * <code>geom</code>\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  GEOMETRY: \"geom\",\n  /**\n   * A glTF model in JSON + external BIN form. This is treated\n   * as a JSON format.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  GLTF: \"gltf\",\n  /**\n   * The binary form of a glTF file. Internally, the magic number is\n   * changed from <code>glTF</code> to <code>glb</code> to distinguish it from\n   * the JSON glTF format.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  GLTF_BINARY: \"glb\",\n  /**\n   * For implicit tiling, availability bitstreams are stored in binary subtree files.\n   * The magic number is <code>subt</code>\n   *\n   * @type {String}\n   * @constant\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  IMPLICIT_SUBTREE: \"subt\",\n  /**\n   * For implicit tiling. Subtrees can also be represented as JSON files.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  IMPLICIT_SUBTREE_JSON: \"subtreeJson\",\n  /**\n   * Contents can reference another tileset.json to use\n   * as an external tileset. This is a JSON-based format.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  EXTERNAL_TILESET: \"externalTileset\",\n  /**\n   * Multiple contents are handled separately from the other content types\n   * due to differences in request scheduling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  MULTIPLE_CONTENT: \"multipleContent\",\n  /**\n   * GeoJSON content for <code>MAXAR_content_geojson</code> extension.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  GEOJSON: \"geoJson\",\n};\n\n/**\n * Check if a content is one of the supported binary formats. Otherwise,\n * the caller can assume a JSON format.\n * @param {Cesium3DTileContentType} contentType The content type of the content payload.\n * @return {Boolean} <code>true</code> if the content type is a binary format, or <code>false</code> if the content type is a JSON format.\n * @private\n */\nCesium3DTileContentType.isBinaryFormat = function (contentType) {\n  switch (contentType) {\n    case Cesium3DTileContentType.BATCHED_3D_MODEL:\n    case Cesium3DTileContentType.INSTANCED_3D_MODEL:\n    case Cesium3DTileContentType.COMPOSITE:\n    case Cesium3DTileContentType.POINT_CLOUD:\n    case Cesium3DTileContentType.VECTOR:\n    case Cesium3DTileContentType.GEOMETRY:\n    case Cesium3DTileContentType.IMPLICIT_SUBTREE:\n    case Cesium3DTileContentType.GLTF_BINARY:\n      return true;\n    default:\n      return false;\n  }\n};\n\nexport default Object.freeze(Cesium3DTileContentType);\n","import Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * A feature of a {@link Cesium3DTileset}.\n * <p>\n * Provides access to a feature's properties stored in the tile's batch table, as well\n * as the ability to show/hide a feature and change its highlight color via\n * {@link Cesium3DTileFeature#show} and {@link Cesium3DTileFeature#color}, respectively.\n * </p>\n * <p>\n * Modifications to a <code>Cesium3DTileFeature</code> object have the lifetime of the tile's\n * content.  If the tile's content is unloaded, e.g., due to it going out of view and needing\n * to free space in the cache for visible tiles, listen to the {@link Cesium3DTileset#tileUnload} event to save any\n * modifications. Also listen to the {@link Cesium3DTileset#tileVisible} event to reapply any modifications.\n * </p>\n * <p>\n * Do not construct this directly.  Access it through {@link Cesium3DTileContent#getFeature}\n * or picking using {@link Scene#pick}.\n * </p>\n *\n * @alias Cesium3DTileFeature\n * @constructor\n *\n * @example\n * // On mouse over, display all the properties for a feature in the console log.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTileFeature) {\n *         const propertyNames = feature.getPropertyNames();\n *         const length = propertyNames.length;\n *         for (let i = 0; i < length; ++i) {\n *             const propertyName = propertyNames[i];\n *             console.log(propertyName + ': ' + feature.getProperty(propertyName));\n *         }\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nfunction Cesium3DTileFeature(content, batchId) {\n  this._content = content;\n  this._batchId = batchId;\n  this._color = undefined; // for calling getColor\n}\n\nObject.defineProperties(Cesium3DTileFeature.prototype, {\n  /**\n   * Gets or sets if the feature will be shown. This is set for all features\n   * when a style's show is evaluated.\n   *\n   * @memberof Cesium3DTileFeature.prototype\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._content.batchTable.getShow(this._batchId);\n    },\n    set: function (value) {\n      this._content.batchTable.setShow(this._batchId, value);\n    },\n  },\n\n  /**\n   * Gets or sets the highlight color multiplied with the feature's color.  When\n   * this is white, the feature's color is not changed. This is set for all features\n   * when a style's color is evaluated.\n   *\n   * @memberof Cesium3DTileFeature.prototype\n   *\n   * @type {Color}\n   *\n   * @default {@link Color.WHITE}\n   */\n  color: {\n    get: function () {\n      if (!defined(this._color)) {\n        this._color = new Color();\n      }\n      return this._content.batchTable.getColor(this._batchId, this._color);\n    },\n    set: function (value) {\n      this._content.batchTable.setColor(this._batchId, value);\n    },\n  },\n\n  /**\n   * Gets a typed array containing the ECEF positions of the polyline.\n   * Returns undefined if {@link Cesium3DTileset#vectorKeepDecodedPositions} is false\n   * or the feature is not a polyline in a vector tile.\n   *\n   * @memberof Cesium3DTileFeature.prototype\n   *\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   *\n   * @type {Float64Array}\n   */\n  polylinePositions: {\n    get: function () {\n      if (!defined(this._content.getPolylinePositions)) {\n        return undefined;\n      }\n\n      return this._content.getPolylinePositions(this._batchId);\n    },\n  },\n\n  /**\n   * Gets the content of the tile containing the feature.\n   *\n   * @memberof Cesium3DTileFeature.prototype\n   *\n   * @type {Cesium3DTileContent}\n   *\n   * @readonly\n   * @private\n   */\n  content: {\n    get: function () {\n      return this._content;\n    },\n  },\n\n  /**\n   * Gets the tileset containing the feature.\n   *\n   * @memberof Cesium3DTileFeature.prototype\n   *\n   * @type {Cesium3DTileset}\n   *\n   * @readonly\n   */\n  tileset: {\n    get: function () {\n      return this._content.tileset;\n    },\n  },\n\n  /**\n   * All objects returned by {@link Scene#pick} have a <code>primitive</code> property. This returns\n   * the tileset containing the feature.\n   *\n   * @memberof Cesium3DTileFeature.prototype\n   *\n   * @type {Cesium3DTileset}\n   *\n   * @readonly\n   */\n  primitive: {\n    get: function () {\n      return this._content.tileset;\n    },\n  },\n\n  /**\n   * Get the feature ID associated with this feature. For 3D Tiles 1.0, the\n   * batch ID is returned. For EXT_mesh_features, this is the feature ID from\n   * the selected feature ID set.\n   *\n   * @memberof Cesium3DTileFeature.prototype\n   *\n   * @type {Number}\n   *\n   * @readonly\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  featureId: {\n    get: function () {\n      return this._batchId;\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickId: {\n    get: function () {\n      return this._content.batchTable.getPickColor(this._batchId);\n    },\n  },\n});\n\n/**\n * Returns whether the feature contains this property. This includes properties from this feature's\n * class and inherited classes when using a batch table hierarchy.\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_batch_table_hierarchy}\n *\n * @param {String} name The case-sensitive name of the property.\n * @returns {Boolean} Whether the feature contains this property.\n */\nCesium3DTileFeature.prototype.hasProperty = function (name) {\n  return this._content.batchTable.hasProperty(this._batchId, name);\n};\n\n/**\n * Returns an array of property names for the feature. This includes properties from this feature's\n * class and inherited classes when using a batch table hierarchy.\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_batch_table_hierarchy}\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The names of the feature's properties.\n */\nCesium3DTileFeature.prototype.getPropertyNames = function (results) {\n  return this._content.batchTable.getPropertyNames(this._batchId, results);\n};\n\n/**\n * Returns a copy of the value of the feature's property with the given name. This includes properties from this feature's\n * class and inherited classes when using a batch table hierarchy.\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_batch_table_hierarchy}\n *\n * @param {String} name The case-sensitive name of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n *\n * @example\n * // Display all the properties for a feature in the console log.\n * const propertyNames = feature.getPropertyNames();\n * const length = propertyNames.length;\n * for (let i = 0; i < length; ++i) {\n *     const propertyName = propertyNames[i];\n *     console.log(propertyName + ': ' + feature.getProperty(propertyName));\n * }\n */\nCesium3DTileFeature.prototype.getProperty = function (name) {\n  return this._content.batchTable.getProperty(this._batchId, name);\n};\n\n/**\n * Returns a copy of the feature's property with the given name, examining all\n * the metadata from 3D Tiles 1.0 formats, the EXT_structural_metadata and legacy\n * EXT_feature_metadata glTF extensions, and the metadata present either in the\n * tileset JSON (3D Tiles 1.1) or in the 3DTILES_metadata 3D Tiles extension.\n * Metadata is checked against name from most specific to most general and the\n * first match is returned. Metadata is checked in this order:\n *\n * <ol>\n *   <li>Batch table (structural metadata) property by semantic</li>\n *   <li>Batch table (structural metadata) property by property ID</li>\n *   <li>Content metadata property by semantic</li>\n *   <li>Content metadata property by property</li>\n *   <li>Tile metadata property by semantic</li>\n *   <li>Tile metadata property by property ID</li>\n *   <li>Subtree metadata property by semantic</li>\n *   <li>Subtree metadata property by property ID</li>\n *   <li>Group metadata property by semantic</li>\n *   <li>Group metadata property by property ID</li>\n *   <li>Tileset metadata property by semantic</li>\n *   <li>Tileset metadata property by property ID</li>\n *   <li>Otherwise, return undefined</li>\n * </ol>\n * <p>\n * For 3D Tiles Next details, see the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension}\n * for 3D Tiles, as well as the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension}\n * for glTF. For the legacy glTF extension, see {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension}\n * </p>\n *\n * @param {Cesium3DTileContent} content The content for accessing the metadata\n * @param {Number} batchId The batch ID (or feature ID) of the feature to get a property for\n * @param {String} name The semantic or property ID of the feature. Semantics are checked before property IDs in each granularity of metadata.\n * @return {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nCesium3DTileFeature.getPropertyInherited = function (content, batchId, name) {\n  const batchTable = content.batchTable;\n  if (defined(batchTable)) {\n    if (batchTable.hasPropertyBySemantic(batchId, name)) {\n      return batchTable.getPropertyBySemantic(batchId, name);\n    }\n\n    if (batchTable.hasProperty(batchId, name)) {\n      return batchTable.getProperty(batchId, name);\n    }\n  }\n\n  const contentMetadata = content.metadata;\n  if (defined(contentMetadata)) {\n    if (contentMetadata.hasPropertyBySemantic(name)) {\n      return contentMetadata.getPropertyBySemantic(name);\n    }\n\n    if (contentMetadata.hasProperty(name)) {\n      return contentMetadata.getProperty(name);\n    }\n  }\n\n  const tile = content.tile;\n  const tileMetadata = tile.metadata;\n  if (defined(tileMetadata)) {\n    if (tileMetadata.hasPropertyBySemantic(name)) {\n      return tileMetadata.getPropertyBySemantic(name);\n    }\n\n    if (tileMetadata.hasProperty(name)) {\n      return tileMetadata.getProperty(name);\n    }\n  }\n\n  let subtreeMetadata;\n  if (defined(tile.implicitSubtree)) {\n    subtreeMetadata = tile.implicitSubtree.metadata;\n  }\n\n  if (defined(subtreeMetadata)) {\n    if (subtreeMetadata.hasPropertyBySemantic(name)) {\n      return subtreeMetadata.getPropertyBySemantic(name);\n    }\n\n    if (subtreeMetadata.hasProperty(name)) {\n      return subtreeMetadata.getProperty(name);\n    }\n  }\n\n  const groupMetadata = defined(content.group)\n    ? content.group.metadata\n    : undefined;\n  if (defined(groupMetadata)) {\n    if (groupMetadata.hasPropertyBySemantic(name)) {\n      return groupMetadata.getPropertyBySemantic(name);\n    }\n\n    if (groupMetadata.hasProperty(name)) {\n      return groupMetadata.getProperty(name);\n    }\n  }\n\n  const tilesetMetadata = content.tileset.metadata;\n  if (defined(tilesetMetadata)) {\n    if (tilesetMetadata.hasPropertyBySemantic(name)) {\n      return tilesetMetadata.getPropertyBySemantic(name);\n    }\n\n    if (tilesetMetadata.hasProperty(name)) {\n      return tilesetMetadata.getProperty(name);\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Returns a copy of the value of the feature's property with the given name.\n * If the feature is contained within a tileset that has metadata (3D Tiles 1.1)\n * or uses the <code>3DTILES_metadata</code> extension, tileset, group and tile\n * metadata is inherited.\n * <p>\n * To resolve name conflicts, this method resolves names from most specific to\n * least specific by metadata granularity in the order: feature, tile, group,\n * tileset. Within each granularity, semantics are resolved first, then other\n * properties.\n * </p>\n * @param {String} name The case-sensitive name of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n * @private\n */\nCesium3DTileFeature.prototype.getPropertyInherited = function (name) {\n  return Cesium3DTileFeature.getPropertyInherited(\n    this._content,\n    this._batchId,\n    name\n  );\n};\n\n/**\n * Sets the value of the feature's property with the given name.\n * <p>\n * If a property with the given name doesn't exist, it is created.\n * </p>\n *\n * @param {String} name The case-sensitive name of the property.\n * @param {*} value The value of the property that will be copied.\n *\n * @exception {DeveloperError} Inherited batch table hierarchy property is read only.\n *\n * @example\n * const height = feature.getProperty('Height'); // e.g., the height of a building\n *\n * @example\n * const name = 'clicked';\n * if (feature.getProperty(name)) {\n *     console.log('already clicked');\n * } else {\n *     feature.setProperty(name, true);\n *     console.log('first click');\n * }\n */\nCesium3DTileFeature.prototype.setProperty = function (name, value) {\n  this._content.batchTable.setProperty(this._batchId, name, value);\n\n  // PERFORMANCE_IDEA: Probably overkill, but maybe only mark the tile dirty if the\n  // property is in one of the style's expressions or - if it can be done quickly -\n  // if the new property value changed the result of an expression.\n  this._content.featurePropertiesDirty = true;\n};\n\n/**\n * Returns whether the feature's class name equals <code>className</code>. Unlike {@link Cesium3DTileFeature#isClass}\n * this function only checks the feature's exact class and not inherited classes.\n * <p>\n * This function returns <code>false</code> if no batch table hierarchy is present.\n * </p>\n *\n * @param {String} className The name to check against.\n * @returns {Boolean} Whether the feature's class name equals <code>className</code>\n *\n * @private\n */\nCesium3DTileFeature.prototype.isExactClass = function (className) {\n  return this._content.batchTable.isExactClass(this._batchId, className);\n};\n\n/**\n * Returns whether the feature's class or any inherited classes are named <code>className</code>.\n * <p>\n * This function returns <code>false</code> if no batch table hierarchy is present.\n * </p>\n *\n * @param {String} className The name to check against.\n * @returns {Boolean} Whether the feature's class or inherited classes are named <code>className</code>\n *\n * @private\n */\nCesium3DTileFeature.prototype.isClass = function (className) {\n  return this._content.batchTable.isClass(this._batchId, className);\n};\n\n/**\n * Returns the feature's class name.\n * <p>\n * This function returns <code>undefined</code> if no batch table hierarchy is present.\n * </p>\n *\n * @returns {String} The feature's class name.\n *\n * @private\n */\nCesium3DTileFeature.prototype.getExactClassName = function () {\n  return this._content.batchTable.getExactClassName(this._batchId);\n};\nexport default Cesium3DTileFeature;\n","import ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * @private\n */\nfunction Cesium3DTileFeatureTable(featureTableJson, featureTableBinary) {\n  this.json = featureTableJson;\n  this.buffer = featureTableBinary;\n  this._cachedTypedArrays = {};\n  this.featuresLength = 0;\n}\n\nfunction getTypedArrayFromBinary(\n  featureTable,\n  semantic,\n  componentType,\n  componentLength,\n  count,\n  byteOffset\n) {\n  const cachedTypedArrays = featureTable._cachedTypedArrays;\n  let typedArray = cachedTypedArrays[semantic];\n  if (!defined(typedArray)) {\n    typedArray = ComponentDatatype.createArrayBufferView(\n      componentType,\n      featureTable.buffer.buffer,\n      featureTable.buffer.byteOffset + byteOffset,\n      count * componentLength\n    );\n    cachedTypedArrays[semantic] = typedArray;\n  }\n  return typedArray;\n}\n\nfunction getTypedArrayFromArray(featureTable, semantic, componentType, array) {\n  const cachedTypedArrays = featureTable._cachedTypedArrays;\n  let typedArray = cachedTypedArrays[semantic];\n  if (!defined(typedArray)) {\n    typedArray = ComponentDatatype.createTypedArray(componentType, array);\n    cachedTypedArrays[semantic] = typedArray;\n  }\n  return typedArray;\n}\n\nCesium3DTileFeatureTable.prototype.getGlobalProperty = function (\n  semantic,\n  componentType,\n  componentLength\n) {\n  const jsonValue = this.json[semantic];\n  if (!defined(jsonValue)) {\n    return undefined;\n  }\n\n  if (defined(jsonValue.byteOffset)) {\n    componentType = defaultValue(componentType, ComponentDatatype.UNSIGNED_INT);\n    componentLength = defaultValue(componentLength, 1);\n    return getTypedArrayFromBinary(\n      this,\n      semantic,\n      componentType,\n      componentLength,\n      1,\n      jsonValue.byteOffset\n    );\n  }\n\n  return jsonValue;\n};\n\nCesium3DTileFeatureTable.prototype.hasProperty = function (semantic) {\n  return defined(this.json[semantic]);\n};\n\nCesium3DTileFeatureTable.prototype.getPropertyArray = function (\n  semantic,\n  componentType,\n  componentLength\n) {\n  const jsonValue = this.json[semantic];\n  if (!defined(jsonValue)) {\n    return undefined;\n  }\n\n  if (defined(jsonValue.byteOffset)) {\n    if (defined(jsonValue.componentType)) {\n      componentType = ComponentDatatype.fromName(jsonValue.componentType);\n    }\n    return getTypedArrayFromBinary(\n      this,\n      semantic,\n      componentType,\n      componentLength,\n      this.featuresLength,\n      jsonValue.byteOffset\n    );\n  }\n\n  return getTypedArrayFromArray(this, semantic, componentType, jsonValue);\n};\n\nCesium3DTileFeatureTable.prototype.getProperty = function (\n  semantic,\n  componentType,\n  componentLength,\n  featureId,\n  result\n) {\n  const jsonValue = this.json[semantic];\n  if (!defined(jsonValue)) {\n    return undefined;\n  }\n\n  const typedArray = this.getPropertyArray(\n    semantic,\n    componentType,\n    componentLength\n  );\n\n  if (componentLength === 1) {\n    return typedArray[featureId];\n  }\n\n  for (let i = 0; i < componentLength; ++i) {\n    result[i] = typedArray[componentLength * featureId + i];\n  }\n\n  return result;\n};\nexport default Cesium3DTileFeatureTable;\n"],"names":["Object","freeze","OPAQUE","MASK","BLEND","Appearance","options","this","material","translucent","_vertexShaderSource","vertexShaderSource","_fragmentShaderSource","fragmentShaderSource","_renderState","renderState","_closed","closed","defineProperties","prototype","get","getFragmentShaderSource","parts","flat","push","faceForward","shaderSource","join","isTranslucent","getRenderState","rs","depthMask","blending","getDefaultRenderState","existing","depthTest","enabled","cull","face","ArcGisMapServerImageryProvider","url","defaultAlpha","undefined","defaultNightAlpha","defaultDayAlpha","defaultBrightness","defaultContrast","defaultHue","defaultSaturation","defaultGamma","defaultMinificationFilter","defaultMagnificationFilter","resource","appendForwardSlash","token","setQueryParameters","_resource","_tileDiscardPolicy","tileDiscardPolicy","_tileWidth","tileWidth","_tileHeight","tileHeight","_maximumLevel","maximumLevel","_tilingScheme","tilingScheme","ellipsoid","_useTiles","usePreCachedTilesIfAvailable","_rectangle","rectangle","_layers","layers","credit","_credit","enablePickFeatures","_errorEvent","_ready","_readyPromise","that","metadataError","requestMetadata","getDerivedResource","queryParameters","f","fetchJsonp","then","result","data","tileInfo","rows","cols","spatialReference","wkid","message","retry","reject","lods","length","fullExtent","projection","extent","sw","unproject","Math","max","xmin","maximumRadius","PI","ymin","ne","min","xmax","ymax","longitude","latitude","extentMessage","missingImageUrl","buildImageResource","pixelsToCheck","disableCheckIfAllPixelsAreTransparent","copyrightText","resolve","metadataSuccess","catch","e","metadataFailure","imageryProvider","x","y","level","request","nativeRectangle","tileXYToNativeRectangle","query","bbox","west","south","east","north","size","format","transparent","bboxSR","imageSR","_url","proxy","minimumLevel","errorEvent","ready","readyPromise","promise","usingPrecachedTiles","hasAlphaChannel","getTileCredits","requestImage","pickFeatures","horizontal","vertical","sr","projected","project","tolerance","geometryType","geometry","mapExtent","imageDisplay","fetchJson","json","features","results","i","feature","featureInfo","name","value","properties","attributes","configureDescriptionFromProperties","position","z","AttributeType","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","attributeType","Number","AutoExposure","_uniformMap","_command","_colorTexture","_depthTexture","_name","_logDepthChanged","_useLogDepth","_framebuffers","_previousLuminance","_commands","_clearCommand","_minMaxLuminance","_enabled","minimumLuminance","maximumLuminance","destroyFramebuffers","autoexposure","framebuffers","destroy","destroyCommands","commands","shaderProgram","createUniformMap","index","uniforms","colorTexture","colorTextureDimensions","dimensions","texture","getColorTexture","minMaxLuminance","previousLuminance","getShaderSource","source","outputTexture","clear","context","clearCommand","color","framebuffer","update","width","drawingBufferWidth","height","drawingBufferHeight","_width","_height","pixelDatatype","halfFloatingPointTexture","ceil","log","Array","lastTexture","createFramebuffers","createViewportQuadCommand","uniformMap","createCommands","temp","execute","isDestroyed","Axis","X","Y","Z","Y_UP_TO_Z_UP","Z_UP_TO_Y_UP","X_UP_TO_Z_UP","Z_UP_TO_X_UP","X_UP_TO_Y_UP","Y_UP_TO_X_UP","fromName","B3dmParser","_deprecationWarning","sizeOfUint32","Uint32Array","BYTES_PER_ELEMENT","parse","arrayBuffer","byteOffset","byteStart","uint8Array","Uint8Array","view","DataView","version","getUint32","byteLength","featureTableJsonByteLength","featureTableBinaryByteLength","batchTableJsonByteLength","batchLength","featureTableJson","batchTableBinaryByteLength","BATCH_LENGTH","featureTableBinary","batchTableJson","batchTableBinary","gltfByteLength","gltfView","subarray","gltf","BatchTable","numberOfInstances","_attributes","_numberOfInstances","foundFloatDatatype","componentDatatype","getDatatype","textureFloatSupported","floatingPointTexture","packFloats","offsets","currentOffset","attributesLength","createOffsets","stride","lastOffset","lastAttribute","getStride","maxNumberOfInstancesPerRow","floor","instancesPerWidth","stepX","centerX","stepY","centerY","_textureDimensions","_textureStep","_pixelDatatype","_packFloats","_offsets","_stride","_texture","_batchValues","Float32Array","_batchValuesDirty","getAttributeType","attributeIndex","componentsPerAttribute","scratchPackedFloatCartesian4","scratchGetAttributeCartesian4","getBatchedAttribute","instanceIndex","offset","array","packed","w","getPackedFloat","fromCartesian4","clone","setAttributeScratchValues","setAttributeScratchCartesian4","getGlslAttributeFunction","batchTable","attribute","functionName","functionReturnType","getComponentType","functionReturnValue","getComponentSwizzle","glslFunction","normalize","setBatchedAttribute","currentAttribute","equals","attributeValue","setPackedAttribute","frameState","pixelFormat","sampler","flipY","createTexture","copyFrom","arrayBufferView","updateTexture","getUniformMapCallback","batchUniformMap","batchTexture","batchTextureDimensions","batchTextureStep","getVertexShaderCallback","batchTableShader","getGlslComputeSt","mainIndex","indexOf","beforeMain","substring","afterMain","BatchTableHierarchy","_classes","_classIds","_classIndexes","_parentCounts","_parentIndexes","_parentIds","extension","hierarchy","hierarchyJson","binaryBody","classId","binaryAccessor","instancesLength","classes","parentIndexes","classIds","parentCounts","parentIds","parentIdsLength","componentType","type","createArrayBufferView","buffer","Uint16Array","classesLength","classInstancesLength","instances","binaryProperties","getBinaryProperties","classCounts","classIndexes","initialize","stack","scratchValidateStack","validateInstance","validateHierarchy","featuresLength","hasOwnProperty","property","componentCount","classType","typedArray","parentCount","parentIndex","parentId","pop","scratchVisited","scratchStack","marker","traverseHierarchy","endConditionCallback","visited","visitedMarker","traverseHierarchyMultipleParents","hasParent","traverseHierarchySingleParent","hasProperty","batchId","propertyId","propertyExists","getPropertyIds","getProperty","instanceClass","indexInClass","propertyValues","binaryProperty","unpack","getBinaryProperty","setProperty","pack","setBinaryProperty","isClass","className","getClassName","BatchTexture","owner","textureDimensions","textureStep","_showAlphaProperties","_batchTexture","_defaultTexture","_pickTexture","_pickIds","_translucentFeaturesLength","_featuresLength","_owner","_statistics","statistics","_colorChangedCallback","colorChangedCallback","getByteLength","getBatchValues","bytes","getShowAlphaProperties","checkBatchId","translucentFeaturesLength","memorySizeInBytes","memory","sizeInBytes","defaultTexture","pickTexture","DEFAULT_COLOR_VALUE","DEFAULT_SHOW_VALUE","setShow","show","showAlphaProperties","propertyOffset","newShow","setAllShow","getShow","scratchColorBytes","setColor","newColor","toBytes","newAlpha","batchValues","wasTranslucent","setAllColor","getColor","getPickColor","tileset","passes","pick","postProcess","pickIds","pickId","createPickId","getFeature","pickColor","red","green","blue","alpha","batchTableByteLength","createPickTexture","updateBatchTexture","Batched3DModel3DTileContent","tile","_tileset","_tile","_model","_batchTable","_features","_classificationType","vectorClassificationOnly","classificationType","_metadata","_batchIdAttributeName","_diffuseAttributeOrUniformName","_rtcCenterTransform","_contentModelMatrix","featurePropertiesDirty","_group","content","b3dm","featureTable","getGlobalProperty","updateCommands","createColorChangedCallback","pickObject","primitive","rtcCenter","computedTransform","basePath","requestType","modelMatrix","upAxis","_gltfUpAxis","forwardAxis","debugWireframe","vertexShaderLoaded","classificationShaderLoaded","getClassificationFragmentShaderCallback","uniformMapLoaded","pickIdLoaded","getPickIdCallback","releaseGltfJson","opaquePass","shadows","incrementallyLoadTextures","fragmentShaderLoaded","getFragmentShaderCallback","addBatchIdToGeneratedShaders","lightColor","imageBasedLighting","backFaceCulling","showOutline","showCreditsOnScreen","model","activeAnimations","addAll","loop","vs","programId","handleTranslucent","gltfInternal","batchIdAttributeName","getBatchIdAttributeName","callback","fs","getPickId","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","innerContents","getUrlComponent","metadata","set","group","createFeatures","applyDebugSettings","applyStyle","style","hasColorStyle","hasShowStyle","evaluateColor","evaluate","commandStart","commandList","splitDirection","tilesetClippingPlanes","clippingPlanes","referenceMatrix","clippingPlanesOriginMatrix","clippingPlanesDirty","_clippingPlanes","_isClipped","render","addDerivedCommands","Billboard","billboardCollection","disableDepthTestDistance","translucencyByDistance","pixelOffsetScaleByDistance","scaleByDistance","distanceDisplayCondition","far","near","_show","_position","_actualPosition","_pixelOffset","pixelOffset","_translate","_eyeOffset","eyeOffset","_heightReference","heightReference","_verticalOrigin","verticalOrigin","_horizontalOrigin","horizontalOrigin","_scale","scale","_color","_rotation","rotation","_alignedAxis","alignedAxis","_scaleByDistance","_translucencyByDistance","_pixelOffsetScaleByDistance","_sizeInMeters","sizeInMeters","_distanceDisplayCondition","_disableDepthTestDistance","_id","id","_collection","collection","_pickId","_pickPrimitive","_billboardCollection","_dirty","_index","_batchIndex","_imageIndex","_imageIndexPromise","_imageId","_image","_imageSubRegion","_imageWidth","_imageHeight","_labelDimensions","_labelHorizontalOrigin","_labelTranslate","image","imageId","src","imageSubRegion","_textureAtlas","_loadImage","_actualClampedPosition","_removeCallbackFunc","_mode","_clusterShow","_outlineColor","outlineColor","_outlineWidth","outlineWidth","_updateClamping","SHOW_INDEX","POSITION_INDEX","PIXEL_OFFSET_INDEX","EYE_OFFSET_INDEX","HORIZONTAL_ORIGIN_INDEX","VERTICAL_ORIGIN_INDEX","SCALE_INDEX","IMAGE_INDEX_INDEX","COLOR_INDEX","ROTATION_INDEX","ALIGNED_AXIS_INDEX","SCALE_BY_DISTANCE_INDEX","TRANSLUCENCY_BY_DISTANCE_INDEX","PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX","DISTANCE_DISPLAY_CONDITION","DISABLE_DEPTH_DISTANCE","TEXTURE_COORDINATE_BOUNDS","SDF_INDEX","makeDirty","billboard","propertyChanged","_updateBillboard","NUMBER_OF_PROPERTIES","object","pickPrimitive","setImage","_clampedPosition","clusterShow","scratchCartographic","scratchPosition","scene","_scene","globe","surface","_surface","mode","modeChanged","cartesianToCartographic","updateFunction","clampedPosition","clampedCart","cartographicToCartesian","updateHeight","getHeight","atlas","imageIndexPromise","completeImageLoad","textureCoordinates","getImageIndex","addImage","addSubRegion","error","setImageSubRegion","subRegion","_setTranslate","translate","_getActualPosition","_setActualPosition","tempCartesian3","_computeActualPosition","scratchCartesian3","_computeScreenSpacePosition","positionWorld","positionWC","scratchPixelOffset","computeScreenSpacePosition","mapProjection","cart","getScreenSpaceBoundingBox","screenSpacePosition","other","_destroy","_customData","removeTileCustomData","DISTANCE_DISPLAY_CONDITION_INDEX","attributeLocations","attributeLocationsBatched","positionHighAndScale","positionLowAndRotation","compressedAttribute0","compressedAttribute1","compressedAttribute2","compressedAttribute3","textureCoordinateBoundsOrLabelTranslate","a_batchId","sdf","attributeLocationsInstanced","direction","BillboardCollection","_textureAtlasGUID","_destroyTextureAtlas","_sp","_spTranslucent","_rsOpaque","_rsTranslucent","_vaf","_billboards","_billboardsToUpdate","_billboardsToUpdateIndex","_billboardsRemoved","_createVertexArray","_shaderRotation","_compiledShaderRotation","_shaderAlignedAxis","_compiledShaderAlignedAxis","_shaderScaleByDistance","_compiledShaderScaleByDistance","_shaderTranslucencyByDistance","_compiledShaderTranslucencyByDistance","_shaderPixelOffsetScaleByDistance","_compiledShaderPixelOffsetScaleByDistance","_shaderDistanceDisplayCondition","_compiledShaderDistanceDisplayCondition","_shaderDisableDepthDistance","_compiledShaderDisableDepthDistance","_shaderClampToGround","_compiledShaderClampToGround","_propertiesChanged","_maxSize","_maxEyeOffset","_maxScale","_maxPixelOffset","_allHorizontalCenter","_allVerticalCenter","_allSizedInMeters","_baseVolume","_baseVolumeWC","_baseVolume2D","_boundingVolume","_boundingVolumeDirty","_colorCommands","_modelMatrix","debugShowBoundingVolume","debugShowTextureAtlas","blendOption","_blendOption","_buffersUsage","_highlightColor","_uniforms","u_atlas","u_highlightColor","terrainProviderChanged","addEventListener","billboards","destroyBillboards","removeBillboards","newBillboards","j","getIndexBuffer","getIndexBufferBatched","indexBuffer","cache","billboardCollection_indexBufferBatched","indices","sixteenK","usage","indexDatatype","vertexArrayDestroyable","getIndexBufferInstanced","billboardCollection_indexBufferInstanced","getVertexBufferInstanced","vertexBuffer","billboardCollection_vertexBufferInstanced","textureAtlas","destroyTextureAtlas","add","remove","contains","removeAll","computeNewBuffersUsage","buffersUsage","usageChanged","k","newUsage","writePositionScratch","writePositionScaleAndRotation","textureAtlasCoordinates","vafWriters","positionHighWriter","positionLowWriter","high","low","_instanced","scratchCartesian2","UPPER_BOUND","LEFT_SHIFT16","LEFT_SHIFT12","LEFT_SHIFT8","writeCompressedAttrib0","writer","pixelOffsetX","pixelOffsetY","translateX","translateY","abs","bottomLeftX","bottomLeftY","imageRectangle","topRightX","topRightY","compressed0","compressed1","compressed2","tempTanslateY","upperTranslateY","compressedTexCoordsLL","compressedTexCoordsLR","compressedTexCoordsUR","compressedTexCoordsUL","writeCompressedAttrib1","nearValue","farValue","translucency","textureWidth","imageWidth","round","writeCompressedAttrib2","validAlignedAxis","imageHeight","labelHorizontalOrigin","compressed3","writeEyeOffset","eyeOffsetZ","compressedTexCoordsRange","writeScaleByDistance","writePixelOffsetScaleByDistance","pixelOffsetScale","writeCompressedAttribute3","MAX_VALUE","clampToGround","depthTexture","POSITIVE_INFINITY","h","writeTextureCoordinateBoundsOrLabelTranslate","globeTranslucent","globeTranslucencyState","depthTestAgainstTerrain","minX","minY","maxX","maxY","writeSDF","_sdf","outlineDistance","writeBillboard","writeBatchId","recomputeActualPositions","recomputeBoundingVolume","boundingVolume","positions","actualPosition","scratchWriterArray","billboardsLength","instancedArrays","ii","billboardsToUpdate","updateMode","billboardsToUpdateLength","textureAtlasGUID","guid","createVertexArray","pass","picking","numberOfBillboards","instanced","bufferUsage","sizeInVertices","createVAF","writers","commit","numWriters","m","b","n","bb","o","subCommit","endSubCommits","va","pixelScale","camera","getPixelSize","radius","updateBoundingVolume","blendOptionChanged","func","useTranslucentDepthMask","vsSource","fsSource","vertDefines","minimumDisableDepthTestDistance","supportVSTextureReads","_compiledSDF","defines","sources","sdfEdge","vectorFragDefine","colorList","opaque","opaqueAndTranslucent","vaLength","totalLength","command","opaqueCommand","count","indicesCount","vertexArray","instanceCount","debugCommand","drawCommand","billboard_texture","createDebugCommand","BingMapsImageryProvider","accessKey","key","_key","_tileProtocol","tileProtocol","_mapStyle","mapStyle","_culture","culture","_proxy","logoUrl","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","_imageUrlTemplate","_imageUrlSubdomains","substr","document","location","protocol","metadataResource","incl","uriScheme","resourceSets","resources","zoomMax","imageUrlSubdomains","imageUrl","attributionList","_attributionList","imageryProviders","attributionIndex","attributionLength","attribution","coverageAreas","areaIndex","areaLength","area","cacheKey","_metadataCache","rectangleScratch","tileXYToRectangle","included","zoomMin","intersection","intersectionScratch","getRectangleAttribution","subdomains","subdomainIndex","templateValues","quadkey","tileXYToQuadKey","subdomain","blob","Promise","bitmask","digit","quadKeyToTileXY","_logoUrl","AERIAL","AERIAL_WITH_LABELS","AERIAL_WITH_LABELS_ON_DEMAND","ROAD","ROAD_ON_DEMAND","CANVAS_DARK","CANVAS_LIGHT","CANVAS_GRAY","ORDNANCE_SURVEY","COLLINS_BART","BlendEquation","ADD","SUBTRACT","REVERSE_SUBTRACT","MIN","MAX","BlendFunction","ZERO","ONE","SOURCE_COLOR","ONE_MINUS_SOURCE_COLOR","DESTINATION_COLOR","ONE_MINUS_DESTINATION_COLOR","SOURCE_ALPHA","ONE_MINUS_SOURCE_ALPHA","DESTINATION_ALPHA","ONE_MINUS_DESTINATION_ALPHA","CONSTANT_COLOR","ONE_MINUS_CONSTANT_COLOR","CONSTANT_ALPHA","ONE_MINUS_CONSTANT_ALPHA","SOURCE_ALPHA_SATURATE","TRANSLUCENT","OPAQUE_AND_TRANSLUCENT","BlendingState","DISABLED","ALPHA_BLEND","equationRgb","equationAlpha","functionSourceRgb","functionSourceAlpha","functionDestinationRgb","functionDestinationAlpha","PRE_MULTIPLIED_ALPHA_BLEND","ADDITIVE_BLEND","defaultDimensions","BoxEmitter","_dimensions","scratchHalfDim","emit","particle","dim","halfDim","velocity","BrdfLutGenerator","_drawCommand","colorTextures","destroyAttachments","generator","viewport","createCommand","BufferLoader","_typedArray","_cacheKey","_state","_promise","create","constructor","load","bufferLoader","_fetchArrayBuffer","errorMessage","getError","loadExternalBuffer","fetchArrayBuffer","unload","Camera","_transform","_invTransform","_actualTransform","_actualInvTransform","_transformChanged","_positionWC","_positionCartographic","_oldPositionWC","positionWCDeltaMagnitude","positionWCDeltaMagnitudeLastFrame","timeSinceMoved","_lastMovedTimestamp","_direction","_directionWC","up","_up","_upWC","right","_right","_rightWC","frustum","aspectRatio","fov","defaultMoveAmount","defaultLookAmount","defaultRotateAmount","defaultZoomAmount","constrainedAxis","maximumZoomFactor","_moveStart","_moveEnd","_changed","_changedPosition","_changedDirection","_changedFrustum","_changedHeading","percentageChanged","_viewMatrix","_invViewMatrix","updateViewMatrix","_modeChanged","_projection","_maxCoord","_max2Dfrustum","rectangleCameraPosition3D","DEFAULT_VIEW_RECTANGLE","mag","DEFAULT_VIEW_FACTOR","TRANSFORM_2D","TRANSFORM_2D_INVERSE","DEFAULT_OFFSET","canPreloadFlight","_currentFlight","_updateCameraChanged","delta","updateCameraDeltas","numberOfListeners","currentHeading","heading","headingChangedPercentage","raiseEvent","lastPosition","lastFrustum","x0","left","x1","x2","x3","y0","bottom","y1","top","y2","y3","leftX","rightX","bottomY","topY","areaPercentage","areaRef","directionWC","dirAngle","dirPercentage","fovy","heightPercentage","positionCartographic","scratchCartesian3Projection","scratchCartesian4Origin","scratchCartesian4NewOrigin","scratchCartesian4NewXAxis","scratchCartesian4NewYAxis","scratchCartesian4NewZAxis","scratchCartesian","updateMembers","heightChanged","positionChanged","directionChanged","upChanged","rightChanged","transformChanged","convertTransformForColumbusView","origin","cartographic","projectedPosition","newOrigin","newZAxis","xAxis","newXAxis","newYAxis","yAxis","convertTransformFor2D","transform","positionENU","det","invUpMag","scalar","w0","getHeading","atan2","getPitch","getRoll","roll","scratchHPRMatrix1","scratchHPRMatrix2","inverseTransform","viewMatrix","inverseViewMatrix","upWC","rightWC","oldTransform","_setTransform","pitch","moveStart","moveEnd","changed","updateFrustum","maxZoomOut","ratio","clampMove2D","setTransformPosition","setTransformUp","setTransformDirection","inverse","scratchAdjustOrthographicFrustumMousePosition","scratchPickRay","scratchRayIntersection","scratchDepthIntersection","calculateOrthographicFrustumWidth","mousePosition","rayIntersection","depthIntersection","distance","ray","getPickRay","pickWorldCoordinates","pickPositionSupported","pickPositionWorldCoordinates","depthDistance","rayDistance","_adjustOrthographicFrustum","zooming","scratchSetViewCartesian","scratchSetViewTransform1","scratchSetViewTransform2","scratchSetViewQuaternion","scratchSetViewMatrix3","scratchSetViewCartographic","scratchToHPRDirection","scratchToHPRUp","scratchToHPRRight","directionUpToHeadingPitchRoll","orientation","invTransform","scratchSetViewOptions","destination","convert","endTransform","scratchHpr","setView","getRectangleCameraCoordinates","hpr","currentTransform","localTransform","rotQuat","rotMat","setView3D","newLeft","newRight","mapMode2D","setView2D","setViewCV","pitchScratch","rotatable2D","maxProjectedX","maxProjectedY","flyHome","duration","completeMorph","flyTo","maxRadii","acos","worldToCameraCoordinates","cartesian","worldToCameraCoordinatesPoint","worldToCameraCoordinatesVector","cameraToWorldCoordinates","cameraToWorldCoordinatesPoint","cameraToWorldCoordinatesVector","moveScratch","move","amount","cameraPosition","moveForward","zoom2D","moveBackward","moveUp","moveDown","moveRight","moveLeft","lookLeft","look","lookRight","lookUp","lookDown","lookScratchQuaternion","lookScratchMatrix","axis","angle","turnAngle","quaternion","twistLeft","twistRight","rotateScratchQuaternion","rotateScratchMatrix","rotate","rotateDown","rotateVertical","rotateUp","rotateVertScratchP","rotateVertScratchA","rotateVertScratchTan","rotateVertScratchNegate","p","northParallel","southParallel","dot","angleToAxis","tangent","rotateHorizontal","newTop","newBottom","maxBottom","maxRight","zoom3D","rotateRight","rotateLeft","zoomIn","zoomOut","getMagnitude","scratchLookAtMatrix4","lookAt","target","lookAtTransform","scratchLookAtHeadingPitchRangeOffset","scratchLookAtHeadingPitchRangeQuaternion1","scratchLookAtHeadingPitchRangeQuaternion2","scratchHeadingPitchRangeMatrix3","offsetFromHeadingPitchRange","range","pitchQuat","headingQuat","rotMatrix","cartesianOffset","viewRectangle3DCartographic1","viewRectangle3DCartographic2","viewRectangle3DNorthEast","viewRectangle3DSouthWest","viewRectangle3DNorthWest","viewRectangle3DSouthEast","viewRectangle3DNorthCenter","viewRectangle3DSouthCenter","viewRectangle3DCenter","viewRectangle3DEquator","defaultRF","viewRectangle3DEllipsoidGeodesic","computeD","upOrRight","corner","tanThetaOrPhi","updateCamera","cameraRF","northCartographic","southCartographic","ellipsoidGeodesic","setEndPoints","interpolateUsingFraction","centerCartographic","center","northEast","northWest","northCenter","southCenter","southEast","southWest","geodeticSurfaceNormal","d","rightScalar","topScalar","_offCenterFrustum","heightRatio","tanPhi","tan","tanTheta","equatorCartographic","equatorPosition","viewRectangleCVCartographic","viewRectangleCVNorthEast","viewRectangleCVSouthWest","viewRectangle2DCartographic","viewRectangle2DNorthEast","viewRectangle2DSouthWest","rectangleCameraPositionColumbusView","rectangleCameraPosition2D","pickEllipsoid3DRay","pickEllipsoid2DRay","pickEllipsoidCVRay","pickEllipsoid","windowPosition","canvas","clientWidth","clientHeight","t","start","stop","pickEllipsoid3D","pickMap2D","pickMapColumbusView","pickPerspCenter","pickPerspXDir","pickPerspYDir","scratchDirection","nearCenter","xDir","yDir","getPickRayPerspective","getPickRayOrthographic","scratchToCenter","scratchProj","distanceToBoundingSphere","boundingSphere","toCenter","proj","scratchPixelSize","pixelSize","getPixelDimensions","pixelRatio","normalScratch","centerScratch","posScratch","scratchCartesian3Subtract","createAnimationCV","normal","distToC","dWidth","dHeight","mapWidth","mapHeight","newPosition","easingFunction","startObject","time","stopObject","interp","createAnimationTemplateCV","createCorrectPositionTween","scratchFlyToDestination","newOptions","complete","cancel","maximumHeight","cancelFlight","cancelTween","completeFlight","setViewOptions","isRectangle","flightTween","pitchAdjustHeight","flyOverLongitude","flyOverLongitudeWeight","tweenOptions","tweens","preloadFlightCamera","preloadFlightCullingVolume","computeCullingVolume","adjustBoundingSphereOffset","minimumZoom","screenSpaceCameraController","minimumZoomDistance","maximumZoom","maximumZoomDistance","distanceToBoundingSphere2D","distanceToBoundingSphere3D","viewBoundingSphere","scratchflyToBoundingSphereTransform","scratchflyToBoundingSphereDestination","scratchflyToBoundingSphereDirection","scratchflyToBoundingSphereUp","scratchflyToBoundingSphereRight","scratchFlyToBoundingSphereCart4","scratchFlyToBoundingSphereQuaternion","scratchFlyToBoundingSphereMatrix3","flyToBoundingSphere","scene2D","rotateQuat","scratchCartesian3_1","scratchCartesian3_2","scratchCartesian3_3","scratchCartesian3_4","horizonPoints","scratchPickCartesian2","scratchRectCartesian","cartoArray","addToResult","computedHorizonQuad","r","computeViewRectangle","cullingVolume","computeVisibility","successfulPickCount","radii","q","oneOverRadii","qMagnitude","qUnit","eUnit","nUnit","wMagnitude","sqrt","eastOffset","northOffset","upperLeft","lowerLeft","lowerRight","upperRight","computeHorizonQuad","lastLon","lon","diff","switchToPerspectiveFrustum","switchToOrthographicFrustum","frustumWidth","getKey","modifier","listenToPinch","aggregator","_update","isDown","_isDown","eventStartPosition","_eventStartPosition","pressTime","_pressTime","releaseTime","_releaseTime","movement","_movement","startPosition","endPosition","angleAndHeight","prevAngle","_eventHandler","setInputAction","event","_buttonsDown","Date","position1","position2","mouseMovement","pinchMovement","TwoPI","listenToWheel","arcLength","listenMouseButtonDownUp","down","lastMovement","_lastMovement","valid","cloneMouseMovement","listenMouseMove","typeName","_currentMousePosition","CameraEventAggregator","modifierName","currentMousePosition","anyButtonDown","wheelMoved","isMoving","getMovement","getLastMovement","isButtonDown","getStartMousePosition","getButtonPressTime","getButtonReleaseTime","reset","LEFT_DRAG","RIGHT_DRAG","MIDDLE_DRAG","WHEEL","PINCH","CameraFlightPath","scratchCart","scratchCart2","createPitchFunction","startPitch","endPitch","heightFunction","startHeight","endHeight","middleHeight","d1","d2","altitude","t1","t2","createHeightFunction","optionAltitude","maxHeight","end","verticalDistance","horizontalDistance","dx","dy","getAltitude","power","factor","s","pow","adjustAngleForLERP","startAngle","endAngle","scratchStart","createUpdateCV","optionPitchAdjustHeight","startHeading","startRoll","pitchFunction","scratchStartCart","scratchEndCart","createUpdate3D","optionFlyOverLongitude","optionFlyOverLongitudeWeight","startCart","destCart","useLongFlight","hitLon","lonMin","lonMax","hitInside","din","useLongestFlight","useShortestFlight","startLongitude","destLongitude","startLatitude","destLatitude","isolateUpdateFunction","createUpdate2D","zoom","incrementAmount","scratchDestination","emptyFlight","wrapCallback","controller","cb","enableInputs","createTween","empty","updateFunctions","Cesium3DContentGroup","Cesium3DTileBatchTable","extensions","_extensions","jsonHeader","propertyName","initializeProperties","_properties","_batchTableHierarchy","legacyHierarchy","HIERARCHY","initializeHierarchy","_batchTableBinaryProperties","_content","scratchColor","getDefaultShader","applyHighlight","modifyDiffuse","diffuseAttributeOrUniformName","regex","RegExp","uniformMatch","match","declaration","replace","sourceDiffuse","replaceDiffuse","functionCall","endIndex","fromIndex","startIndex","nestedLevel","character","charAt","replacedFunction","slice","replaceDiffuseTextureCalls","isExactClass","getExactClassName","hasPropertyBySemantic","getPropertyNames","scratchPropertyNames","keys","apply","getPropertyBySemantic","hierarchyProperty","renamedSource","newMain","hasPremultipliedAlpha","tile_batchTexture","tile_textureDimensions","tile_textureStep","tile_colorBlend","colorBlendMode","colorBlendAmount","getColorBlend","tile_pickTexture","StyleCommandsNeeded","deriveCommand","derivedCommand","translucentCommand","tile_translucentCommand","deriveTranslucentCommand","stencilTest","stencilMask","getTranslucentRenderState","deriveOpaqueCommand","getOpaqueRenderState","deriveZBackfaceCommand","colorMask","polygonOffset","units","castShadows","receiveShadows","u_polygonOffset","shader","shaderCache","getDerivedShaderProgram","unshift","createDerivedShaderProgram","_attributeLocations","getLogDepthPolygonOffsetFragmentShaderProgram","deriveStencilCommand","reference","mask","frontFunction","frontOperation","zPass","backFunction","backOperation","getLastSelectionDepth","stencilCommand","commandEnd","finalResolution","_finalResolution","bivariateVisibilityTest","_skipLevelOfDetail","_hasMixedContent","stencilBuffer","styleCommandsNeeded","getStyleCommandsNeeded","derivedCommands","dirty","originalCommand","zback","_backfaceCommands","stencil","_selectionDepth","HIGHLIGHT","REPLACE","MIX","Cesium3DTileContent","Cesium3DTileContentFactory","enableModelExperimental","pnts","i3dm","cmpt","externalTileset","geom","vctr","subt","subtreeJson","glb","geoJson","UNLOADED","LOADING","PROCESSING","READY","EXPIRED","FAILED","Cesium3DTileContentType","BATCHED_3D_MODEL","INSTANCED_3D_MODEL","COMPOSITE","POINT_CLOUD","VECTOR","GEOMETRY","GLTF","GLTF_BINARY","IMPLICIT_SUBTREE","IMPLICIT_SUBTREE_JSON","EXTERNAL_TILESET","MULTIPLE_CONTENT","GEOJSON","contentType","Cesium3DTileFeature","_batchId","polylinePositions","getPolylinePositions","featureId","getPropertyInherited","contentMetadata","tileMetadata","subtreeMetadata","implicitSubtree","groupMetadata","tilesetMetadata","Cesium3DTileFeatureTable","_cachedTypedArrays","getTypedArrayFromBinary","semantic","componentLength","cachedTypedArrays","jsonValue","getPropertyArray","getTypedArrayFromArray"],"sourceRoot":""}