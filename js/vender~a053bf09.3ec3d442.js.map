{"version":3,"file":"js/vender~a053bf09.3ec3d442.js","mappings":"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","sources":["webpack:///../../../node_modules/cesium/Source/Scene/PointCloud.js","webpack:///../../../node_modules/cesium/Source/Scene/PointCloud3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/PointCloudEyeDomeLighting.js","webpack:///../../../node_modules/cesium/Source/Scene/PointCloudShading.js","webpack:///../../../node_modules/cesium/Source/Scene/PointPrimitive.js","webpack:///../../../node_modules/cesium/Source/Scene/PointPrimitiveCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/Polyline.js","webpack:///../../../node_modules/cesium/Source/Scene/PolylineCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/PolylineColorAppearance.js","webpack:///../../../node_modules/cesium/Source/Scene/PolylineMaterialAppearance.js","webpack:///../../../node_modules/cesium/Source/Scene/PostProcessStage.js","webpack:///../../../node_modules/cesium/Source/Scene/PostProcessStageCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/PostProcessStageComposite.js","webpack:///../../../node_modules/cesium/Source/Scene/PostProcessStageLibrary.js","webpack:///../../../node_modules/cesium/Source/Scene/PostProcessStageSampleMode.js","webpack:///../../../node_modules/cesium/Source/Scene/PostProcessStageTextureCache.js","webpack:///../../../node_modules/cesium/Source/Scene/Primitive.js","webpack:///../../../node_modules/cesium/Source/Scene/PrimitiveCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/PrimitivePipeline.js","webpack:///../../../node_modules/cesium/Source/Scene/PrimitiveState.js","webpack:///../../../node_modules/cesium/Source/Scene/PropertyAttribute.js","webpack:///../../../node_modules/cesium/Source/Scene/PropertyAttributeProperty.js","webpack:///../../../node_modules/cesium/Source/Scene/PropertyTable.js","webpack:///../../../node_modules/cesium/Source/Scene/PropertyTexture.js","webpack:///../../../node_modules/cesium/Source/Scene/PropertyTextureProperty.js","webpack:///../../../node_modules/cesium/Source/Scene/QuadtreeOccluders.js","webpack:///../../../node_modules/cesium/Source/Scene/QuadtreePrimitive.js","webpack:///../../../node_modules/cesium/Source/Scene/QuadtreeTile.js","webpack:///../../../node_modules/cesium/Source/Scene/QuadtreeTileLoadState.js","webpack:///../../../node_modules/cesium/Source/Scene/QuadtreeTileProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/ResourceCache.js","webpack:///../../../node_modules/cesium/Source/Scene/ResourceCacheKey.js","webpack:///../../../node_modules/cesium/Source/Scene/ResourceLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/ResourceLoaderState.js","webpack:///../../../node_modules/cesium/Source/Scene/SDFSettings.js","webpack:///../../../node_modules/cesium/Source/Scene/Scene.js","webpack:///../../../node_modules/cesium/Source/Scene/SceneFramebuffer.js","webpack:///../../../node_modules/cesium/Source/Scene/SceneMode.js","webpack:///../../../node_modules/cesium/Source/Scene/SceneTransforms.js","webpack:///../../../node_modules/cesium/Source/Scene/SceneTransitioner.js","webpack:///../../../node_modules/cesium/Source/Scene/ScreenSpaceCameraController.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport MersenneTwister from \"../ThirdParty/mersenne-twister.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport PntsParser from \"./PntsParser.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport SplitDirection from \"./SplitDirection.js\";\nimport Splitter from \"./Splitter.js\";\nimport StencilConstants from \"./StencilConstants.js\";\n\nconst DecodingState = {\n  NEEDS_DECODE: 0,\n  DECODING: 1,\n  READY: 2,\n  FAILED: 3,\n};\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud|Point Cloud}\n * tile. Used internally by {@link PointCloud3DTileContent} and {@link TimeDynamicPointCloud}.\n *\n * @alias PointCloud\n * @constructor\n *\n * @see PointCloud3DTileContent\n * @see TimeDynamicPointCloud\n *\n * @private\n */\nfunction PointCloud(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.arrayBuffer\", options.arrayBuffer);\n  //>>includeEnd('debug');\n\n  // Hold onto the payload until the render resources are created\n  this._parsedContent = undefined;\n\n  this._drawCommand = undefined;\n  this._isTranslucent = false;\n  this._styleTranslucent = false;\n  this._constantColor = Color.clone(Color.DARKGRAY);\n  this._highlightColor = Color.clone(Color.WHITE);\n  this._pointSize = 1.0;\n\n  this._rtcCenter = undefined;\n  this._quantizedVolumeScale = undefined;\n  this._quantizedVolumeOffset = undefined;\n\n  // These values are used to regenerate the shader when the style changes\n  this._styleableShaderAttributes = undefined;\n  this._isQuantized = false;\n  this._isOctEncoded16P = false;\n  this._isRGB565 = false;\n  this._hasColors = false;\n  this._hasNormals = false;\n  this._hasBatchIds = false;\n\n  // Draco\n  this._decodingState = DecodingState.READY;\n  this._dequantizeInShader = true;\n  this._isQuantizedDraco = false;\n  this._isOctEncodedDraco = false;\n  this._quantizedRange = 0.0;\n  this._octEncodedRange = 0.0;\n\n  // Use per-point normals to hide back-facing points.\n  this.backFaceCulling = false;\n  this._backFaceCulling = false;\n\n  // Whether to enable normal shading\n  this.normalShading = true;\n  this._normalShading = true;\n\n  this._opaqueRenderState = undefined;\n  this._translucentRenderState = undefined;\n\n  this._mode = undefined;\n\n  this._ready = false;\n  this._pointsLength = 0;\n  this._geometryByteLength = 0;\n\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._batchTableLoaded = options.batchTableLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._cull = defaultValue(options.cull, true);\n\n  this.style = undefined;\n  this._style = undefined;\n  this.styleDirty = false;\n\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  this.time = 0.0; // For styling\n  this.shadows = ShadowMode.ENABLED;\n  this._boundingSphere = undefined;\n\n  this.clippingPlanes = undefined;\n  this.isClipped = false;\n  this.clippingPlanesDirty = false;\n  // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n  // This is so that when point clouds are part of a tileset they all get clipped relative\n  // to the root tile.\n  this.clippingPlanesOriginMatrix = undefined;\n\n  this.attenuation = false;\n  this._attenuation = false;\n\n  // Options for geometric error based attenuation\n  this.geometricError = 0.0;\n  this.geometricErrorScale = 1.0;\n  this.maximumAttenuation = this._pointSize;\n\n  /**\n   * The {@link SplitDirection} to apply to this point cloud.\n   *\n   * @type {SplitDirection}\n   * @default {@link SplitDirection.NONE}\n   */\n  this.splitDirection = defaultValue(\n    options.splitDirection,\n    SplitDirection.NONE\n  );\n  this._splittingEnabled = false;\n\n  this._resolveReadyPromise = undefined;\n  this._rejectReadyPromise = undefined;\n  this._readyPromise = initialize(this, options);\n}\n\nObject.defineProperties(PointCloud.prototype, {\n  pointsLength: {\n    get: function () {\n      return this._pointsLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  color: {\n    get: function () {\n      return Color.clone(this._highlightColor);\n    },\n    set: function (value) {\n      this._highlightColor = Color.clone(value, this._highlightColor);\n    },\n  },\n\n  boundingSphere: {\n    get: function () {\n      if (defined(this._drawCommand)) {\n        return this._drawCommand.boundingVolume;\n      }\n      return undefined;\n    },\n    set: function (value) {\n      this._boundingSphere = BoundingSphere.clone(value, this._boundingSphere);\n    },\n  },\n});\n\nfunction initialize(pointCloud, options) {\n  const parsedContent = PntsParser.parse(\n    options.arrayBuffer,\n    options.byteOffset\n  );\n  pointCloud._parsedContent = parsedContent;\n  pointCloud._rtcCenter = parsedContent.rtcCenter;\n  pointCloud._hasNormals = parsedContent.hasNormals;\n  pointCloud._hasColors = parsedContent.hasColors;\n  pointCloud._hasBatchIds = parsedContent.hasBatchIds;\n  pointCloud._isTranslucent = parsedContent.isTranslucent;\n\n  // If points are not batched and there are per-point properties, use the\n  // properties as metadata for styling purposes.\n  if (!parsedContent.hasBatchIds && defined(parsedContent.batchTableBinary)) {\n    parsedContent.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      parsedContent.pointsLength,\n      parsedContent.batchTableJson,\n      parsedContent.batchTableBinary\n    );\n  }\n\n  if (defined(parsedContent.draco)) {\n    const draco = parsedContent.draco;\n    pointCloud._decodingState = DecodingState.NEEDS_DECODE;\n    draco.dequantizeInShader = pointCloud._dequantizeInShader;\n  }\n\n  const positions = parsedContent.positions;\n  if (defined(positions)) {\n    pointCloud._isQuantized = positions.isQuantized;\n    pointCloud._quantizedVolumeScale = positions.quantizedVolumeScale;\n    pointCloud._quantizedVolumeOffset = positions.quantizedVolumeOffset;\n    pointCloud._quantizedRange = positions.quantizedRange;\n  }\n\n  const normals = parsedContent.normals;\n  if (defined(normals)) {\n    pointCloud._isOctEncoded16P = normals.octEncoded;\n  }\n\n  const colors = parsedContent.colors;\n  if (defined(colors)) {\n    if (defined(colors.constantColor)) {\n      pointCloud._constantColor = Color.clone(\n        colors.constantColor,\n        pointCloud._constantColor\n      );\n\n      // Constant colors are handled as a uniform rather than a vertex\n      // attribute.\n      pointCloud._hasColors = false;\n    }\n    pointCloud._isRGB565 = colors.isRGB565;\n  }\n\n  // PntsParser parses BATCH_ID as _FEATURE_ID_0 for EXT_mesh_features.\n  // These properties aren't used but rename them to BATCH_ID to avoid\n  // confusion when debugging.\n  const batchIds = parsedContent.batchIds;\n  if (defined(parsedContent.batchIds)) {\n    batchIds.name = \"BATCH_ID\";\n    batchIds.semantic = \"BATCH_ID\";\n    batchIds.setIndex = undefined;\n  }\n\n  if (parsedContent.hasBatchIds) {\n    pointCloud._batchTableLoaded(\n      parsedContent.batchLength,\n      parsedContent.batchTableJson,\n      parsedContent.batchTableBinary\n    );\n  }\n\n  pointCloud._pointsLength = parsedContent.pointsLength;\n\n  return new Promise(function (resolve, reject) {\n    pointCloud._resolveReadyPromise = function () {\n      pointCloud._ready = true;\n      resolve(pointCloud);\n    };\n    pointCloud._rejectReadyPromise = reject;\n  });\n}\n\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchPosition = new Cartesian3();\n\n// Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n// See https://github.com/CesiumGS/cesium/issues/9730\nlet randomNumberGenerator;\nlet randomValues;\n\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    // Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n    // See https://github.com/CesiumGS/cesium/issues/9730\n    randomNumberGenerator = new MersenneTwister(0);\n    randomValues = new Array(samplesLength);\n    for (let i = 0; i < samplesLength; ++i) {\n      randomValues[i] = randomNumberGenerator.random();\n    }\n  }\n  return randomValues;\n}\n\nfunction computeApproximateBoundingSphereFromPositions(positions) {\n  const maximumSamplesLength = 20;\n  const pointsLength = positions.length / 3;\n  const samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  const randomValues = getRandomValues(maximumSamplesLength);\n  const maxValue = Number.MAX_VALUE;\n  const minValue = -Number.MAX_VALUE;\n  const min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  const max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n  for (let i = 0; i < samplesLength; ++i) {\n    const index = Math.floor(randomValues[i] * pointsLength);\n    const position = Cartesian3.unpack(positions, index * 3, scratchPosition);\n    Cartesian3.minimumByComponent(min, position, min);\n    Cartesian3.maximumByComponent(max, position, max);\n  }\n\n  const boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n  boundingSphere.radius += CesiumMath.EPSILON2; // To avoid radius of zero\n  return boundingSphere;\n}\n\nfunction prepareVertexAttribute(typedArray, name) {\n  // WebGL does not support UNSIGNED_INT, INT, or DOUBLE vertex attributes. Convert these to FLOAT.\n  const componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n  if (\n    componentDatatype === ComponentDatatype.INT ||\n    componentDatatype === ComponentDatatype.UNSIGNED_INT ||\n    componentDatatype === ComponentDatatype.DOUBLE\n  ) {\n    oneTimeWarning(\n      \"Cast pnts property to floats\",\n      `Point cloud property \"${name}\" will be casted to a float array because INT, UNSIGNED_INT, and DOUBLE are not valid WebGL vertex attribute types. Some precision may be lost.`\n    );\n    return new Float32Array(typedArray);\n  }\n  return typedArray;\n}\n\nconst scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier = new Cartesian4();\nconst scratchQuantizedVolumeScaleAndOctEncodedRange = new Cartesian4();\nconst scratchColor = new Color();\n\nconst positionLocation = 0;\nconst colorLocation = 1;\nconst normalLocation = 2;\nconst batchIdLocation = 3;\nconst numberOfAttributes = 4;\n\nconst scratchClippingPlanesMatrix = new Matrix4();\nconst scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\n\nfunction createResources(pointCloud, frameState) {\n  const context = frameState.context;\n  const parsedContent = pointCloud._parsedContent;\n  const pointsLength = pointCloud._pointsLength;\n  const positions = parsedContent.positions;\n  const colors = parsedContent.colors;\n  const normals = parsedContent.normals;\n  const batchIds = parsedContent.batchIds;\n  const styleableProperties = parsedContent.styleableProperties;\n  const hasStyleableProperties = defined(styleableProperties);\n  const isQuantized = pointCloud._isQuantized;\n  const isQuantizedDraco = pointCloud._isQuantizedDraco;\n  const isOctEncoded16P = pointCloud._isOctEncoded16P;\n  const isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  const quantizedRange = pointCloud._quantizedRange;\n  const octEncodedRange = pointCloud._octEncodedRange;\n  const isRGB565 = pointCloud._isRGB565;\n  const isTranslucent = pointCloud._isTranslucent;\n  const hasColors = pointCloud._hasColors;\n  const hasNormals = pointCloud._hasNormals;\n  const hasBatchIds = pointCloud._hasBatchIds;\n\n  let componentsPerAttribute;\n  let componentDatatype;\n\n  const styleableVertexAttributes = [];\n  const styleableShaderAttributes = {};\n  pointCloud._styleableShaderAttributes = styleableShaderAttributes;\n\n  if (hasStyleableProperties) {\n    let attributeLocation = numberOfAttributes;\n\n    for (const name in styleableProperties) {\n      if (styleableProperties.hasOwnProperty(name)) {\n        const property = styleableProperties[name];\n        const typedArray = prepareVertexAttribute(property.typedArray, name);\n        componentsPerAttribute = property.componentCount;\n        componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n\n        const vertexBuffer = Buffer.createVertexBuffer({\n          context: context,\n          typedArray: typedArray,\n          usage: BufferUsage.STATIC_DRAW,\n        });\n\n        pointCloud._geometryByteLength += vertexBuffer.sizeInBytes;\n\n        const vertexAttribute = {\n          index: attributeLocation,\n          vertexBuffer: vertexBuffer,\n          componentsPerAttribute: componentsPerAttribute,\n          componentDatatype: componentDatatype,\n          normalize: false,\n          offsetInBytes: 0,\n          strideInBytes: 0,\n        };\n\n        styleableVertexAttributes.push(vertexAttribute);\n        styleableShaderAttributes[name] = {\n          location: attributeLocation,\n          componentCount: componentsPerAttribute,\n        };\n        ++attributeLocation;\n      }\n    }\n  }\n\n  const positionsVertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: positions.typedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  pointCloud._geometryByteLength += positionsVertexBuffer.sizeInBytes;\n\n  let colorsVertexBuffer;\n  if (hasColors) {\n    colorsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: colors.typedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += colorsVertexBuffer.sizeInBytes;\n  }\n\n  let normalsVertexBuffer;\n  if (hasNormals) {\n    normalsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: normals.typedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += normalsVertexBuffer.sizeInBytes;\n  }\n\n  let batchIdsVertexBuffer;\n  if (hasBatchIds) {\n    batchIds.typedArray = prepareVertexAttribute(\n      batchIds.typedArray,\n      \"batchIds\"\n    );\n    batchIdsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIds.typedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += batchIdsVertexBuffer.sizeInBytes;\n  }\n\n  let attributes = [];\n\n  if (isQuantized) {\n    componentDatatype = ComponentDatatype.UNSIGNED_SHORT;\n  } else if (isQuantizedDraco) {\n    componentDatatype =\n      quantizedRange <= 255\n        ? ComponentDatatype.UNSIGNED_BYTE\n        : ComponentDatatype.UNSIGNED_SHORT;\n  } else {\n    componentDatatype = ComponentDatatype.FLOAT;\n  }\n\n  attributes.push({\n    index: positionLocation,\n    vertexBuffer: positionsVertexBuffer,\n    componentsPerAttribute: 3,\n    componentDatatype: componentDatatype,\n    normalize: false,\n    offsetInBytes: 0,\n    strideInBytes: 0,\n  });\n\n  if (pointCloud._cull) {\n    if (isQuantized || isQuantizedDraco) {\n      pointCloud._boundingSphere = BoundingSphere.fromCornerPoints(\n        Cartesian3.ZERO,\n        pointCloud._quantizedVolumeScale\n      );\n    } else {\n      pointCloud._boundingSphere = computeApproximateBoundingSphereFromPositions(\n        positions.typedArray\n      );\n    }\n  }\n\n  if (hasColors) {\n    if (isRGB565) {\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n      });\n    } else {\n      const colorComponentsPerAttribute = isTranslucent ? 4 : 3;\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: colorComponentsPerAttribute,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n      });\n    }\n  }\n\n  if (hasNormals) {\n    if (isOctEncoded16P) {\n      componentsPerAttribute = 2;\n      componentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n    } else if (isOctEncodedDraco) {\n      componentsPerAttribute = 2;\n      componentDatatype =\n        octEncodedRange <= 255\n          ? ComponentDatatype.UNSIGNED_BYTE\n          : ComponentDatatype.UNSIGNED_SHORT;\n    } else {\n      componentsPerAttribute = 3;\n      componentDatatype = ComponentDatatype.FLOAT;\n    }\n    attributes.push({\n      index: normalLocation,\n      vertexBuffer: normalsVertexBuffer,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0,\n    });\n  }\n\n  if (hasBatchIds) {\n    attributes.push({\n      index: batchIdLocation,\n      vertexBuffer: batchIdsVertexBuffer,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds.typedArray),\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0,\n    });\n  }\n\n  if (hasStyleableProperties) {\n    attributes = attributes.concat(styleableVertexAttributes);\n  }\n\n  const vertexArray = new VertexArray({\n    context: context,\n    attributes: attributes,\n  });\n\n  const opaqueRenderState = {\n    depthTest: {\n      enabled: true,\n    },\n  };\n\n  const translucentRenderState = {\n    depthTest: {\n      enabled: true,\n    },\n    depthMask: false,\n    blending: BlendingState.ALPHA_BLEND,\n  };\n\n  if (pointCloud._opaquePass === Pass.CESIUM_3D_TILE) {\n    opaqueRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    opaqueRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n    translucentRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    translucentRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  }\n\n  pointCloud._opaqueRenderState = RenderState.fromCache(opaqueRenderState);\n  pointCloud._translucentRenderState = RenderState.fromCache(\n    translucentRenderState\n  );\n\n  pointCloud._drawCommand = new DrawCommand({\n    boundingVolume: new BoundingSphere(),\n    cull: pointCloud._cull,\n    modelMatrix: new Matrix4(),\n    primitiveType: PrimitiveType.POINTS,\n    vertexArray: vertexArray,\n    count: pointsLength,\n    shaderProgram: undefined, // Updated in createShaders\n    uniformMap: undefined, // Updated in createShaders\n    renderState: isTranslucent\n      ? pointCloud._translucentRenderState\n      : pointCloud._opaqueRenderState,\n    pass: isTranslucent ? Pass.TRANSLUCENT : pointCloud._opaquePass,\n    owner: pointCloud,\n    castShadows: false,\n    receiveShadows: false,\n    pickId: pointCloud._pickIdLoaded(),\n  });\n}\n\nfunction createUniformMap(pointCloud, frameState) {\n  const context = frameState.context;\n  const isQuantized = pointCloud._isQuantized;\n  const isQuantizedDraco = pointCloud._isQuantizedDraco;\n  const isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n\n  let uniformMap = {\n    u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier: function () {\n      const scratch = scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier;\n      scratch.x = pointCloud._attenuation\n        ? pointCloud.maximumAttenuation\n        : pointCloud._pointSize;\n      scratch.x *= frameState.pixelRatio;\n\n      scratch.y = pointCloud.time;\n\n      if (pointCloud._attenuation) {\n        const frustum = frameState.camera.frustum;\n        let depthMultiplier;\n        // Attenuation is maximumAttenuation in 2D/ortho\n        if (\n          frameState.mode === SceneMode.SCENE2D ||\n          frustum instanceof OrthographicFrustum\n        ) {\n          depthMultiplier = Number.POSITIVE_INFINITY;\n        } else {\n          depthMultiplier =\n            context.drawingBufferHeight /\n            frameState.camera.frustum.sseDenominator;\n        }\n\n        scratch.z = pointCloud.geometricError * pointCloud.geometricErrorScale;\n        scratch.w = depthMultiplier;\n      }\n\n      return scratch;\n    },\n    u_highlightColor: function () {\n      return pointCloud._highlightColor;\n    },\n    u_constantColor: function () {\n      return pointCloud._constantColor;\n    },\n    u_clippingPlanes: function () {\n      const clippingPlanes = pointCloud.clippingPlanes;\n      const isClipped = pointCloud.isClipped;\n      return isClipped ? clippingPlanes.texture : context.defaultTexture;\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      const clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Color.TRANSPARENT;\n      }\n\n      const style = Color.clone(clippingPlanes.edgeColor, scratchColor);\n      style.alpha = clippingPlanes.edgeWidth;\n      return style;\n    },\n    u_clippingPlanesMatrix: function () {\n      const clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Matrix4.IDENTITY;\n      }\n\n      const clippingPlanesOriginMatrix = defaultValue(\n        pointCloud.clippingPlanesOriginMatrix,\n        pointCloud._modelMatrix\n      );\n      Matrix4.multiply(\n        context.uniformState.view3D,\n        clippingPlanesOriginMatrix,\n        scratchClippingPlanesMatrix\n      );\n      const transform = Matrix4.multiply(\n        scratchClippingPlanesMatrix,\n        clippingPlanes.modelMatrix,\n        scratchClippingPlanesMatrix\n      );\n\n      return Matrix4.inverseTranspose(\n        transform,\n        scratchInverseTransposeClippingPlanesMatrix\n      );\n    },\n  };\n\n  Splitter.addUniforms(pointCloud, uniformMap);\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    uniformMap = combine(uniformMap, {\n      u_quantizedVolumeScaleAndOctEncodedRange: function () {\n        const scratch = scratchQuantizedVolumeScaleAndOctEncodedRange;\n        if (defined(pointCloud._quantizedVolumeScale)) {\n          const scale = Cartesian3.clone(\n            pointCloud._quantizedVolumeScale,\n            scratch\n          );\n          Cartesian3.divideByScalar(scale, pointCloud._quantizedRange, scratch);\n        }\n        scratch.w = pointCloud._octEncodedRange;\n        return scratch;\n      },\n    });\n  }\n\n  if (defined(pointCloud._uniformMapLoaded)) {\n    uniformMap = pointCloud._uniformMapLoaded(uniformMap);\n  }\n\n  pointCloud._drawCommand.uniformMap = uniformMap;\n}\n\nfunction getStyleablePropertyIds(source, propertyIds) {\n  // Get all the property IDs used by this style\n  const regex = /czm_3dtiles_property_(\\d+)/g;\n  let matches = regex.exec(source);\n  while (matches !== null) {\n    const id = parseInt(matches[1]);\n    if (propertyIds.indexOf(id) === -1) {\n      propertyIds.push(id);\n    }\n    matches = regex.exec(source);\n  }\n}\n\nfunction getBuiltinPropertyNames(source, propertyNames) {\n  // Get all the builtin property names used by this style, ignoring the function signature\n  source = source.slice(source.indexOf(\"\\n\"));\n  const regex = /czm_3dtiles_builtin_property_(\\w+)/g;\n  let matches = regex.exec(source);\n  while (matches !== null) {\n    const name = matches[1];\n    if (propertyNames.indexOf(name) === -1) {\n      propertyNames.push(name);\n    }\n    matches = regex.exec(source);\n  }\n}\n\nfunction getVertexAttribute(vertexArray, index) {\n  const numberOfAttributes = vertexArray.numberOfAttributes;\n  for (let i = 0; i < numberOfAttributes; ++i) {\n    const attribute = vertexArray.getAttribute(i);\n    if (attribute.index === index) {\n      return attribute;\n    }\n  }\n}\n\nconst builtinVariableSubstitutionMap = {\n  POSITION: \"czm_3dtiles_builtin_property_POSITION\",\n  POSITION_ABSOLUTE: \"czm_3dtiles_builtin_property_POSITION_ABSOLUTE\",\n  COLOR: \"czm_3dtiles_builtin_property_COLOR\",\n  NORMAL: \"czm_3dtiles_builtin_property_NORMAL\",\n};\n\nfunction createShaders(pointCloud, frameState, style) {\n  let i;\n  let name;\n  let attribute;\n\n  const context = frameState.context;\n  const hasStyle = defined(style);\n  const isQuantized = pointCloud._isQuantized;\n  const isQuantizedDraco = pointCloud._isQuantizedDraco;\n  const isOctEncoded16P = pointCloud._isOctEncoded16P;\n  const isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  const isRGB565 = pointCloud._isRGB565;\n  const isTranslucent = pointCloud._isTranslucent;\n  const hasColors = pointCloud._hasColors;\n  const hasNormals = pointCloud._hasNormals;\n  const hasBatchIds = pointCloud._hasBatchIds;\n  const backFaceCulling = pointCloud._backFaceCulling;\n  const normalShading = pointCloud._normalShading;\n  const vertexArray = pointCloud._drawCommand.vertexArray;\n  const clippingPlanes = pointCloud.clippingPlanes;\n  const attenuation = pointCloud._attenuation;\n\n  let colorStyleFunction;\n  let showStyleFunction;\n  let pointSizeStyleFunction;\n  let styleTranslucent = isTranslucent;\n\n  const variableSubstitutionMap = clone(builtinVariableSubstitutionMap);\n  const propertyIdToAttributeMap = {};\n  const styleableShaderAttributes = pointCloud._styleableShaderAttributes;\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      variableSubstitutionMap[\n        name\n      ] = `czm_3dtiles_property_${attribute.location}`;\n      propertyIdToAttributeMap[attribute.location] = attribute;\n    }\n  }\n\n  if (hasStyle) {\n    const shaderState = {\n      translucent: false,\n    };\n    const parameterList =\n      \"(\" +\n      \"vec3 czm_3dtiles_builtin_property_POSITION, \" +\n      \"vec3 czm_3dtiles_builtin_property_POSITION_ABSOLUTE, \" +\n      \"vec4 czm_3dtiles_builtin_property_COLOR, \" +\n      \"vec3 czm_3dtiles_builtin_property_NORMAL\" +\n      \")\";\n    colorStyleFunction = style.getColorShaderFunction(\n      `getColorFromStyle${parameterList}`,\n      variableSubstitutionMap,\n      shaderState\n    );\n    showStyleFunction = style.getShowShaderFunction(\n      `getShowFromStyle${parameterList}`,\n      variableSubstitutionMap,\n      shaderState\n    );\n    pointSizeStyleFunction = style.getPointSizeShaderFunction(\n      `getPointSizeFromStyle${parameterList}`,\n      variableSubstitutionMap,\n      shaderState\n    );\n    if (defined(colorStyleFunction) && shaderState.translucent) {\n      styleTranslucent = true;\n    }\n  }\n\n  pointCloud._styleTranslucent = styleTranslucent;\n\n  const hasColorStyle = defined(colorStyleFunction);\n  const hasShowStyle = defined(showStyleFunction);\n  const hasPointSizeStyle = defined(pointSizeStyleFunction);\n  const hasClippedContent = pointCloud.isClipped;\n\n  // Get the properties in use by the style\n  const styleablePropertyIds = [];\n  const builtinPropertyNames = [];\n\n  if (hasColorStyle) {\n    getStyleablePropertyIds(colorStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(colorStyleFunction, builtinPropertyNames);\n  }\n  if (hasShowStyle) {\n    getStyleablePropertyIds(showStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(showStyleFunction, builtinPropertyNames);\n  }\n  if (hasPointSizeStyle) {\n    getStyleablePropertyIds(pointSizeStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(pointSizeStyleFunction, builtinPropertyNames);\n  }\n\n  const usesColorSemantic = builtinPropertyNames.indexOf(\"COLOR\") >= 0;\n  const usesNormalSemantic = builtinPropertyNames.indexOf(\"NORMAL\") >= 0;\n\n  if (usesNormalSemantic && !hasNormals) {\n    throw new RuntimeError(\n      \"Style references the NORMAL semantic but the point cloud does not have normals\"\n    );\n  }\n\n  // Disable vertex attributes that aren't used in the style, enable attributes that are\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      const enabled = styleablePropertyIds.indexOf(attribute.location) >= 0;\n      const vertexAttribute = getVertexAttribute(\n        vertexArray,\n        attribute.location\n      );\n      vertexAttribute.enabled = enabled;\n    }\n  }\n\n  const usesColors = hasColors && (!hasColorStyle || usesColorSemantic);\n  if (hasColors) {\n    // Disable the color vertex attribute if the color style does not reference the color semantic\n    const colorVertexAttribute = getVertexAttribute(vertexArray, colorLocation);\n    colorVertexAttribute.enabled = usesColors;\n  }\n\n  const usesNormals =\n    hasNormals && (normalShading || backFaceCulling || usesNormalSemantic);\n  if (hasNormals) {\n    // Disable the normal vertex attribute if normals are not used\n    const normalVertexAttribute = getVertexAttribute(\n      vertexArray,\n      normalLocation\n    );\n    normalVertexAttribute.enabled = usesNormals;\n  }\n\n  const attributeLocations = {\n    a_position: positionLocation,\n  };\n  if (usesColors) {\n    attributeLocations.a_color = colorLocation;\n  }\n  if (usesNormals) {\n    attributeLocations.a_normal = normalLocation;\n  }\n  if (hasBatchIds) {\n    attributeLocations.a_batchId = batchIdLocation;\n  }\n\n  let attributeDeclarations = \"\";\n\n  const length = styleablePropertyIds.length;\n  for (i = 0; i < length; ++i) {\n    const propertyId = styleablePropertyIds[i];\n    attribute = propertyIdToAttributeMap[propertyId];\n    const componentCount = attribute.componentCount;\n    const attributeName = `czm_3dtiles_property_${propertyId}`;\n    let attributeType;\n    if (componentCount === 1) {\n      attributeType = \"float\";\n    } else {\n      attributeType = `vec${componentCount}`;\n    }\n\n    attributeDeclarations += `attribute ${attributeType} ${attributeName}; \\n`;\n    attributeLocations[attributeName] = attribute.location;\n  }\n\n  createUniformMap(pointCloud, frameState);\n\n  let vs =\n    \"attribute vec3 a_position; \\n\" +\n    \"varying vec4 v_color; \\n\" +\n    \"uniform vec4 u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier; \\n\" +\n    \"uniform vec4 u_constantColor; \\n\" +\n    \"uniform vec4 u_highlightColor; \\n\";\n  vs += \"float u_pointSize; \\n\" + \"float u_time; \\n\";\n\n  if (attenuation) {\n    vs += \"float u_geometricError; \\n\" + \"float u_depthMultiplier; \\n\";\n  }\n\n  vs += attributeDeclarations;\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"attribute vec4 a_color; \\n\";\n    } else if (isRGB565) {\n      vs +=\n        \"attribute float a_color; \\n\" +\n        \"const float SHIFT_RIGHT_11 = 1.0 / 2048.0; \\n\" +\n        \"const float SHIFT_RIGHT_5 = 1.0 / 32.0; \\n\" +\n        \"const float SHIFT_LEFT_11 = 2048.0; \\n\" +\n        \"const float SHIFT_LEFT_5 = 32.0; \\n\" +\n        \"const float NORMALIZE_6 = 1.0 / 64.0; \\n\" +\n        \"const float NORMALIZE_5 = 1.0 / 32.0; \\n\";\n    } else {\n      vs += \"attribute vec3 a_color; \\n\";\n    }\n  }\n  if (usesNormals) {\n    if (isOctEncoded16P || isOctEncodedDraco) {\n      vs += \"attribute vec2 a_normal; \\n\";\n    } else {\n      vs += \"attribute vec3 a_normal; \\n\";\n    }\n  }\n\n  if (hasBatchIds) {\n    vs += \"attribute float a_batchId; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    vs += \"uniform vec4 u_quantizedVolumeScaleAndOctEncodedRange; \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs += colorStyleFunction;\n  }\n\n  if (hasShowStyle) {\n    vs += showStyleFunction;\n  }\n\n  if (hasPointSizeStyle) {\n    vs += pointSizeStyleFunction;\n  }\n\n  vs +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    u_pointSize = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.x; \\n\" +\n    \"    u_time = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.y; \\n\";\n\n  if (attenuation) {\n    vs +=\n      \"    u_geometricError = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.z; \\n\" +\n      \"    u_depthMultiplier = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.w; \\n\";\n  }\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"    vec4 color = a_color; \\n\";\n    } else if (isRGB565) {\n      vs +=\n        \"    float compressed = a_color; \\n\" +\n        \"    float r = floor(compressed * SHIFT_RIGHT_11); \\n\" +\n        \"    compressed -= r * SHIFT_LEFT_11; \\n\" +\n        \"    float g = floor(compressed * SHIFT_RIGHT_5); \\n\" +\n        \"    compressed -= g * SHIFT_LEFT_5; \\n\" +\n        \"    float b = compressed; \\n\" +\n        \"    vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5); \\n\" +\n        \"    vec4 color = vec4(rgb, 1.0); \\n\";\n    } else {\n      vs += \"    vec4 color = vec4(a_color, 1.0); \\n\";\n    }\n  } else {\n    vs += \"    vec4 color = u_constantColor; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco) {\n    vs +=\n      \"    vec3 position = a_position * u_quantizedVolumeScaleAndOctEncodedRange.xyz; \\n\";\n  } else {\n    vs += \"    vec3 position = a_position; \\n\";\n  }\n  vs +=\n    \"    vec3 position_absolute = vec3(czm_model * vec4(position, 1.0)); \\n\";\n\n  if (usesNormals) {\n    if (isOctEncoded16P) {\n      vs += \"    vec3 normal = czm_octDecode(a_normal); \\n\";\n    } else if (isOctEncodedDraco) {\n      // Draco oct-encoding decodes to zxy order\n      vs +=\n        \"    vec3 normal = czm_octDecode(a_normal, u_quantizedVolumeScaleAndOctEncodedRange.w).zxy; \\n\";\n    } else {\n      vs += \"    vec3 normal = a_normal; \\n\";\n    }\n    vs += \"    vec3 normalEC = czm_normal * normal; \\n\";\n  } else {\n    vs += \"    vec3 normal = vec3(1.0); \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs +=\n      \"    color = getColorFromStyle(position, position_absolute, color, normal); \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs +=\n      \"    float show = float(getShowFromStyle(position, position_absolute, color, normal)); \\n\";\n  }\n\n  if (hasPointSizeStyle) {\n    vs +=\n      \"    gl_PointSize = getPointSizeFromStyle(position, position_absolute, color, normal) * czm_pixelRatio; \\n\";\n  } else if (attenuation) {\n    vs +=\n      \"    vec4 positionEC = czm_modelView * vec4(position, 1.0); \\n\" +\n      \"    float depth = -positionEC.z; \\n\" +\n      // compute SSE for this point\n      \"    gl_PointSize = min((u_geometricError / depth) * u_depthMultiplier, u_pointSize); \\n\";\n  } else {\n    vs += \"    gl_PointSize = u_pointSize; \\n\";\n  }\n\n  vs += \"    color = color * u_highlightColor; \\n\";\n\n  if (usesNormals && normalShading) {\n    vs +=\n      \"    float diffuseStrength = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC); \\n\" +\n      \"    diffuseStrength = max(diffuseStrength, 0.4); \\n\" + // Apply some ambient lighting\n      \"    color.xyz *= diffuseStrength * czm_lightColor; \\n\";\n  }\n\n  vs +=\n    \"    v_color = color; \\n\" +\n    \"    gl_Position = czm_modelViewProjection * vec4(position, 1.0); \\n\";\n\n  if (usesNormals && backFaceCulling) {\n    vs +=\n      \"    float visible = step(-normalEC.z, 0.0); \\n\" +\n      \"    gl_Position *= visible; \\n\" +\n      \"    gl_PointSize *= visible; \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs +=\n      \"    gl_Position.w *= float(show); \\n\" +\n      \"    gl_PointSize *= float(show); \\n\";\n  }\n\n  vs += \"} \\n\";\n\n  let fs = \"varying vec4 v_color; \\n\";\n\n  if (hasClippedContent) {\n    fs +=\n      \"uniform highp sampler2D u_clippingPlanes; \\n\" +\n      \"uniform mat4 u_clippingPlanesMatrix; \\n\" +\n      \"uniform vec4 u_clippingPlanesEdgeStyle; \\n\";\n    fs += \"\\n\";\n    fs += getClippingFunction(clippingPlanes, context);\n    fs += \"\\n\";\n  }\n\n  fs +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gl_FragColor = czm_gammaCorrect(v_color); \\n\";\n\n  if (hasClippedContent) {\n    fs += getClipAndStyleCode(\n      \"u_clippingPlanes\",\n      \"u_clippingPlanesMatrix\",\n      \"u_clippingPlanesEdgeStyle\"\n    );\n  }\n\n  fs += \"} \\n\";\n\n  if (pointCloud.splitDirection !== SplitDirection.NONE) {\n    fs = Splitter.modifyFragmentShader(fs);\n  }\n\n  if (defined(pointCloud._vertexShaderLoaded)) {\n    vs = pointCloud._vertexShaderLoaded(vs);\n  }\n\n  if (defined(pointCloud._fragmentShaderLoaded)) {\n    fs = pointCloud._fragmentShaderLoaded(fs);\n  }\n\n  const drawCommand = pointCloud._drawCommand;\n  if (defined(drawCommand.shaderProgram)) {\n    // Destroy the old shader\n    drawCommand.shaderProgram.destroy();\n  }\n  drawCommand.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  try {\n    // Check if the shader compiles correctly. If not there is likely a syntax error with the style.\n    drawCommand.shaderProgram._bind();\n  } catch (error) {\n    // Rephrase the error.\n    throw new RuntimeError(\n      \"Error generating style shader: this may be caused by a type mismatch, index out-of-bounds, or other syntax error.\"\n    );\n  }\n}\n\nfunction decodeDraco(pointCloud, context) {\n  if (pointCloud._decodingState === DecodingState.READY) {\n    return false;\n  }\n  if (pointCloud._decodingState === DecodingState.NEEDS_DECODE) {\n    const parsedContent = pointCloud._parsedContent;\n    const draco = parsedContent.draco;\n    const decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      pointCloud._decodingState = DecodingState.DECODING;\n      decodePromise\n        .then(function (result) {\n          pointCloud._decodingState = DecodingState.READY;\n          const decodedPositions = defined(result.POSITION)\n            ? result.POSITION.array\n            : undefined;\n          const decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n          const decodedRgba = defined(result.RGBA)\n            ? result.RGBA.array\n            : undefined;\n          const decodedNormals = defined(result.NORMAL)\n            ? result.NORMAL.array\n            : undefined;\n          const decodedBatchIds = defined(result.BATCH_ID)\n            ? result.BATCH_ID.array\n            : undefined;\n          const isQuantizedDraco =\n            defined(decodedPositions) &&\n            defined(result.POSITION.data.quantization);\n          const isOctEncodedDraco =\n            defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n          if (isQuantizedDraco) {\n            // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n            // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n            const quantization = result.POSITION.data.quantization;\n            const range = quantization.range;\n            pointCloud._quantizedVolumeScale = Cartesian3.fromElements(\n              range,\n              range,\n              range\n            );\n            pointCloud._quantizedVolumeOffset = Cartesian3.unpack(\n              quantization.minValues\n            );\n            pointCloud._quantizedRange =\n              (1 << quantization.quantizationBits) - 1.0;\n            pointCloud._isQuantizedDraco = true;\n          }\n          if (isOctEncodedDraco) {\n            pointCloud._octEncodedRange =\n              (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n            pointCloud._isOctEncodedDraco = true;\n          }\n          let styleableProperties = parsedContent.styleableProperties;\n          const batchTableProperties = draco.batchTableProperties;\n          for (const name in batchTableProperties) {\n            if (batchTableProperties.hasOwnProperty(name)) {\n              const property = result[name];\n              if (!defined(styleableProperties)) {\n                styleableProperties = {};\n              }\n              styleableProperties[name] = {\n                typedArray: property.array,\n                componentCount: property.data.componentsPerAttribute,\n              };\n            }\n          }\n\n          if (defined(decodedPositions)) {\n            parsedContent.positions = {\n              typedArray: decodedPositions,\n            };\n          }\n\n          const decodedColors = defaultValue(decodedRgba, decodedRgb);\n          if (defined(decodedColors)) {\n            parsedContent.colors = {\n              typedArray: decodedColors,\n            };\n          }\n\n          if (defined(decodedNormals)) {\n            parsedContent.normals = {\n              typedArray: decodedNormals,\n            };\n          }\n\n          if (defined(decodedBatchIds)) {\n            parsedContent.batchIds = {\n              typedArray: decodedBatchIds,\n            };\n          }\n\n          parsedContent.styleableProperties = styleableProperties;\n        })\n        .catch(function (error) {\n          pointCloud._decodingState = DecodingState.FAILED;\n          pointCloud._rejectReadyPromise(error);\n        });\n    }\n  }\n  return true;\n}\n\nconst scratchComputedTranslation = new Cartesian4();\nconst scratchScale = new Cartesian3();\n\nPointCloud.prototype.update = function (frameState) {\n  const context = frameState.context;\n  const decoding = decodeDraco(this, context);\n  if (decoding) {\n    return;\n  }\n\n  let shadersDirty = false;\n  let modelMatrixDirty = !Matrix4.equals(this._modelMatrix, this.modelMatrix);\n\n  if (this._mode !== frameState.mode) {\n    this._mode = frameState.mode;\n    modelMatrixDirty = true;\n  }\n\n  if (!defined(this._drawCommand)) {\n    createResources(this, frameState);\n    modelMatrixDirty = true;\n    shadersDirty = true;\n    this._resolveReadyPromise();\n    this._parsedContent = undefined; // Unload\n  }\n\n  if (modelMatrixDirty) {\n    Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    const modelMatrix = this._drawCommand.modelMatrix;\n    Matrix4.clone(this._modelMatrix, modelMatrix);\n\n    if (defined(this._rtcCenter)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._rtcCenter, modelMatrix);\n    }\n    if (defined(this._quantizedVolumeOffset)) {\n      Matrix4.multiplyByTranslation(\n        modelMatrix,\n        this._quantizedVolumeOffset,\n        modelMatrix\n      );\n    }\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      const projection = frameState.mapProjection;\n      const translation = Matrix4.getColumn(\n        modelMatrix,\n        3,\n        scratchComputedTranslation\n      );\n      if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n        Transforms.basisTo2D(projection, modelMatrix, modelMatrix);\n      }\n    }\n\n    const boundingSphere = this._drawCommand.boundingVolume;\n    BoundingSphere.clone(this._boundingSphere, boundingSphere);\n\n    if (this._cull) {\n      const center = boundingSphere.center;\n      Matrix4.multiplyByPoint(modelMatrix, center, center);\n      const scale = Matrix4.getScale(modelMatrix, scratchScale);\n      boundingSphere.radius *= Cartesian3.maximumComponent(scale);\n    }\n  }\n\n  if (this.clippingPlanesDirty) {\n    this.clippingPlanesDirty = false;\n    shadersDirty = true;\n  }\n\n  if (this._attenuation !== this.attenuation) {\n    this._attenuation = this.attenuation;\n    shadersDirty = true;\n  }\n\n  if (this.backFaceCulling !== this._backFaceCulling) {\n    this._backFaceCulling = this.backFaceCulling;\n    shadersDirty = true;\n  }\n\n  if (this.normalShading !== this._normalShading) {\n    this._normalShading = this.normalShading;\n    shadersDirty = true;\n  }\n\n  if (this._style !== this.style || this.styleDirty) {\n    this._style = this.style;\n    this.styleDirty = false;\n    shadersDirty = true;\n  }\n\n  const splittingEnabled = this.splitDirection !== SplitDirection.NONE;\n  if (this._splittingEnabled !== splittingEnabled) {\n    this._splittingEnabled = splittingEnabled;\n    shadersDirty = true;\n  }\n\n  if (shadersDirty) {\n    createShaders(this, frameState, this._style);\n  }\n\n  this._drawCommand.castShadows = ShadowMode.castShadows(this.shadows);\n  this._drawCommand.receiveShadows = ShadowMode.receiveShadows(this.shadows);\n\n  // Update the render state\n  const isTranslucent =\n    this._highlightColor.alpha < 1.0 ||\n    this._constantColor.alpha < 1.0 ||\n    this._styleTranslucent;\n  this._drawCommand.renderState = isTranslucent\n    ? this._translucentRenderState\n    : this._opaqueRenderState;\n  this._drawCommand.pass = isTranslucent ? Pass.TRANSLUCENT : this._opaquePass;\n\n  const commandList = frameState.commandList;\n\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    commandList.push(this._drawCommand);\n  }\n};\n\nPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\nPointCloud.prototype.destroy = function () {\n  const command = this._drawCommand;\n  if (defined(command)) {\n    command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n    command.shaderProgram =\n      command.shaderProgram && command.shaderProgram.destroy();\n  }\n  return destroyObject(this);\n};\nexport default PointCloud;\n","import Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport Cesium3DTileRefine from \"./Cesium3DTileRefine.js\";\nimport PointCloud from \"./PointCloud.js\";\nimport PointCloudShading from \"./PointCloudShading.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud|Point Cloud}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias PointCloud3DTileContent\n * @constructor\n *\n * @private\n */\nfunction PointCloud3DTileContent(\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset\n) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this._metadata = undefined;\n\n  this._pickId = undefined; // Only defined when batchTable is undefined\n  this._batchTable = undefined; // Used when feature table contains BATCH_ID semantic\n  this._styleDirty = false;\n  this._features = undefined;\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n\n  this._pointCloud = new PointCloud({\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    cull: false,\n    opaquePass: Pass.CESIUM_3D_TILE,\n    vertexShaderLoaded: getVertexShaderLoaded(this),\n    fragmentShaderLoaded: getFragmentShaderLoaded(this),\n    uniformMapLoaded: getUniformMapLoaded(this),\n    batchTableLoaded: getBatchTableLoaded(this),\n    pickIdLoaded: getPickIdLoaded(this),\n  });\n}\n\nObject.defineProperties(PointCloud3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      if (defined(this._batchTable)) {\n        return this._batchTable.featuresLength;\n      }\n      return 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return this._pointCloud.pointsLength;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return this._pointCloud.geometryByteLength;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      if (defined(this._batchTable)) {\n        return this._batchTable.memorySizeInBytes;\n      }\n      return 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._pointCloud.readyPromise;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\nfunction getVertexShaderLoaded(content) {\n  return function (vs) {\n    if (defined(content._batchTable)) {\n      return content._batchTable.getVertexShaderCallback(\n        false,\n        \"a_batchId\",\n        undefined\n      )(vs);\n    }\n    return vs;\n  };\n}\n\nfunction getFragmentShaderLoaded(content) {\n  return function (fs) {\n    if (defined(content._batchTable)) {\n      return content._batchTable.getFragmentShaderCallback(\n        false,\n        undefined,\n        false\n      )(fs);\n    }\n    return `uniform vec4 czm_pickColor;\\n${fs}`;\n  };\n}\n\nfunction getUniformMapLoaded(content) {\n  return function (uniformMap) {\n    if (defined(content._batchTable)) {\n      return content._batchTable.getUniformMapCallback()(uniformMap);\n    }\n    return combine(uniformMap, {\n      czm_pickColor: function () {\n        return content._pickId.color;\n      },\n    });\n  };\n}\n\nfunction getBatchTableLoaded(content) {\n  return function (batchLength, batchTableJson, batchTableBinary) {\n    content._batchTable = new Cesium3DTileBatchTable(\n      content,\n      batchLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  };\n}\n\nfunction getPickIdLoaded(content) {\n  return function () {\n    return defined(content._batchTable)\n      ? content._batchTable.getPickId()\n      : \"czm_pickColor\";\n  };\n}\n\nfunction getGeometricError(content) {\n  const pointCloudShading = content._tileset.pointCloudShading;\n  const sphereVolume = content._tile.contentBoundingVolume.boundingSphere.volume();\n  const baseResolutionApproximation = CesiumMath.cbrt(\n    sphereVolume / content.pointsLength\n  );\n\n  let geometricError = content._tile.geometricError;\n  if (geometricError === 0) {\n    if (\n      defined(pointCloudShading) &&\n      defined(pointCloudShading.baseResolution)\n    ) {\n      geometricError = pointCloudShading.baseResolution;\n    } else {\n      geometricError = baseResolutionApproximation;\n    }\n  }\n  return geometricError;\n}\n\nfunction createFeatures(content) {\n  const featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    const features = new Array(featuresLength);\n    for (let i = 0; i < featuresLength; ++i) {\n      features[i] = new Cesium3DTileFeature(content, i);\n    }\n    content._features = features;\n  }\n}\n\nPointCloud3DTileContent.prototype.hasProperty = function (batchId, name) {\n  if (defined(this._batchTable)) {\n    return this._batchTable.hasProperty(batchId, name);\n  }\n  return false;\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.\n *\n * In this context a feature refers to a group of points that share the same BATCH_ID.\n * For example all the points that represent a door in a house point cloud would be a feature.\n *\n * Features are backed by a batch table and can be colored, shown/hidden, picked, etc like features\n * in b3dm and i3dm.\n *\n * When the BATCH_ID semantic is omitted and the point cloud stores per-point properties, they\n * are not accessible by getFeature. They are only used for dynamic styling.\n */\nPointCloud3DTileContent.prototype.getFeature = function (batchId) {\n  if (!defined(this._batchTable)) {\n    return undefined;\n  }\n  const featuresLength = this.featuresLength;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${\n        featuresLength - 1\n      }).`\n    );\n  }\n  //>>includeEnd('debug');\n  createFeatures(this);\n  return this._features[batchId];\n};\n\nPointCloud3DTileContent.prototype.applyDebugSettings = function (\n  enabled,\n  color\n) {\n  this._pointCloud.color = enabled ? color : Color.WHITE;\n};\n\nPointCloud3DTileContent.prototype.applyStyle = function (style) {\n  if (defined(this._batchTable)) {\n    this._batchTable.applyStyle(style);\n  } else {\n    this._styleDirty = true;\n  }\n};\n\nconst defaultShading = new PointCloudShading();\n\nPointCloud3DTileContent.prototype.update = function (tileset, frameState) {\n  const pointCloud = this._pointCloud;\n  const pointCloudShading = defaultValue(\n    tileset.pointCloudShading,\n    defaultShading\n  );\n  const tile = this._tile;\n  const batchTable = this._batchTable;\n  const mode = frameState.mode;\n  const clippingPlanes = tileset.clippingPlanes;\n\n  if (!defined(this._pickId) && !defined(batchTable)) {\n    this._pickId = frameState.context.createPickId({\n      primitive: tileset,\n      content: this,\n    });\n  }\n\n  if (defined(batchTable)) {\n    batchTable.update(tileset, frameState);\n  }\n\n  let boundingSphere;\n  if (defined(tile._contentBoundingVolume)) {\n    boundingSphere =\n      mode === SceneMode.SCENE3D\n        ? tile._contentBoundingVolume.boundingSphere\n        : tile._contentBoundingVolume2D.boundingSphere;\n  } else {\n    boundingSphere =\n      mode === SceneMode.SCENE3D\n        ? tile._boundingVolume.boundingSphere\n        : tile._boundingVolume2D.boundingSphere;\n  }\n\n  const styleDirty = this._styleDirty;\n  this._styleDirty = false;\n\n  pointCloud.clippingPlanesOriginMatrix = tileset.clippingPlanesOriginMatrix;\n  pointCloud.style = defined(batchTable) ? undefined : tileset.style;\n  pointCloud.styleDirty = styleDirty;\n  pointCloud.modelMatrix = tile.computedTransform;\n  pointCloud.time = tileset.timeSinceLoad;\n  pointCloud.shadows = tileset.shadows;\n  pointCloud.boundingSphere = boundingSphere;\n  pointCloud.clippingPlanes = clippingPlanes;\n  pointCloud.isClipped =\n    defined(clippingPlanes) && clippingPlanes.enabled && tile._isClipped;\n  pointCloud.clippingPlanesDirty = tile.clippingPlanesDirty;\n  pointCloud.attenuation = pointCloudShading.attenuation;\n  pointCloud.backFaceCulling = pointCloudShading.backFaceCulling;\n  pointCloud.normalShading = pointCloudShading.normalShading;\n  pointCloud.geometricError = getGeometricError(this);\n  pointCloud.geometricErrorScale = pointCloudShading.geometricErrorScale;\n  pointCloud.splitDirection = tileset.splitDirection;\n  if (\n    defined(pointCloudShading) &&\n    defined(pointCloudShading.maximumAttenuation)\n  ) {\n    pointCloud.maximumAttenuation = pointCloudShading.maximumAttenuation;\n  } else if (tile.refine === Cesium3DTileRefine.ADD) {\n    pointCloud.maximumAttenuation = 5.0;\n  } else {\n    pointCloud.maximumAttenuation = tileset.maximumScreenSpaceError;\n  }\n\n  pointCloud.update(frameState);\n};\n\nPointCloud3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nPointCloud3DTileContent.prototype.destroy = function () {\n  this._pickId = this._pickId && this._pickId.destroy();\n  this._pointCloud = this._pointCloud && this._pointCloud.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\nexport default PointCloud3DTileContent;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BlendingState from \"../Scene/BlendingState.js\";\nimport StencilConstants from \"../Scene/StencilConstants.js\";\nimport PointCloudEyeDomeLightingShader from \"../Shaders/PostProcessStages/PointCloudEyeDomeLighting.js\";\n\n/**\n * Eye dome lighting. Does not support points with per-point translucency, but does allow translucent styling against the globe.\n * Requires support for EXT_frag_depth and WEBGL_draw_buffers extensions in WebGL 1.0.\n *\n * @private\n */\nfunction PointCloudEyeDomeLighting() {\n  this._framebuffer = new FramebufferManager({\n    colorAttachmentsLength: 2,\n    depth: true,\n    supportsDepthTexture: true,\n  });\n\n  this._drawCommand = undefined;\n  this._clearCommand = undefined;\n\n  this._strength = 1.0;\n  this._radius = 1.0;\n}\n\nObject.defineProperties(PointCloudEyeDomeLighting.prototype, {\n  framebuffer: {\n    get: function () {\n      return this._framebuffer.framebuffer;\n    },\n  },\n  colorGBuffer: {\n    get: function () {\n      return this._framebuffer.getColorTexture(0);\n    },\n  },\n  depthGBuffer: {\n    get: function () {\n      return this._framebuffer.getColorTexture(1);\n    },\n  },\n});\n\nfunction destroyFramebuffer(processor) {\n  processor._framebuffer.destroy();\n  processor._drawCommand = undefined;\n  processor._clearCommand = undefined;\n}\n\nconst distanceAndEdlStrengthScratch = new Cartesian2();\n\nfunction createCommands(processor, context) {\n  const blendFS = new ShaderSource({\n    defines: [\"LOG_DEPTH_WRITE\"],\n    sources: [PointCloudEyeDomeLightingShader],\n  });\n\n  const blendUniformMap = {\n    u_pointCloud_colorGBuffer: function () {\n      return processor.colorGBuffer;\n    },\n    u_pointCloud_depthGBuffer: function () {\n      return processor.depthGBuffer;\n    },\n    u_distanceAndEdlStrength: function () {\n      distanceAndEdlStrengthScratch.x = processor._radius;\n      distanceAndEdlStrengthScratch.y = processor._strength;\n      return distanceAndEdlStrengthScratch;\n    },\n  };\n\n  const blendRenderState = RenderState.fromCache({\n    blending: BlendingState.ALPHA_BLEND,\n    depthMask: true,\n    depthTest: {\n      enabled: true,\n    },\n    stencilTest: StencilConstants.setCesium3DTileBit(),\n    stencilMask: StencilConstants.CESIUM_3D_TILE_MASK,\n  });\n\n  processor._drawCommand = context.createViewportQuadCommand(blendFS, {\n    uniformMap: blendUniformMap,\n    renderState: blendRenderState,\n    pass: Pass.CESIUM_3D_TILE,\n    owner: processor,\n  });\n\n  processor._clearCommand = new ClearCommand({\n    framebuffer: processor.framebuffer,\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    depth: 1.0,\n    renderState: RenderState.fromCache(),\n    pass: Pass.CESIUM_3D_TILE,\n    owner: processor,\n  });\n}\n\nfunction createResources(processor, context) {\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n  processor._framebuffer.update(context, width, height);\n  createCommands(processor, context);\n}\n\nfunction isSupported(context) {\n  return context.drawBuffers && context.fragmentDepth;\n}\n\nPointCloudEyeDomeLighting.isSupported = isSupported;\n\nfunction getECShaderProgram(context, shaderProgram) {\n  let shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, \"EC\");\n  if (!defined(shader)) {\n    const attributeLocations = shaderProgram._attributeLocations;\n\n    const fs = shaderProgram.fragmentShaderSource.clone();\n\n    fs.sources = fs.sources.map(function (source) {\n      source = ShaderSource.replaceMain(\n        source,\n        \"czm_point_cloud_post_process_main\"\n      );\n      source = source.replace(/gl_FragColor/g, \"gl_FragData[0]\");\n      return source;\n    });\n\n    fs.sources.unshift(\"#extension GL_EXT_draw_buffers : enable \\n\");\n    fs.sources.push(\n      \"void main() \\n\" +\n        \"{ \\n\" +\n        \"    czm_point_cloud_post_process_main(); \\n\" +\n        \"#ifdef LOG_DEPTH\\n\" +\n        \"    czm_writeLogDepth();\\n\" +\n        \"    gl_FragData[1] = czm_packDepth(gl_FragDepthEXT); \\n\" +\n        \"#else\\n\" +\n        \"    gl_FragData[1] = czm_packDepth(gl_FragCoord.z);\\n\" +\n        \"#endif\\n\" +\n        \"}\"\n    );\n\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      \"EC\",\n      {\n        vertexShaderSource: shaderProgram.vertexShaderSource,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nPointCloudEyeDomeLighting.prototype.update = function (\n  frameState,\n  commandStart,\n  pointCloudShading,\n  boundingVolume\n) {\n  if (!isSupported(frameState.context)) {\n    return;\n  }\n\n  this._strength = pointCloudShading.eyeDomeLightingStrength;\n  this._radius =\n    pointCloudShading.eyeDomeLightingRadius * frameState.pixelRatio;\n\n  createResources(this, frameState.context);\n\n  // Hijack existing point commands to render into an offscreen FBO.\n  let i;\n  const commandList = frameState.commandList;\n  const commandEnd = commandList.length;\n\n  for (i = commandStart; i < commandEnd; ++i) {\n    const command = commandList[i];\n    if (\n      command.primitiveType !== PrimitiveType.POINTS ||\n      command.pass === Pass.TRANSLUCENT\n    ) {\n      continue;\n    }\n\n    let derivedCommand;\n    let originalShaderProgram;\n\n    let derivedCommandObject = command.derivedCommands.pointCloudProcessor;\n    if (defined(derivedCommandObject)) {\n      derivedCommand = derivedCommandObject.command;\n      originalShaderProgram = derivedCommandObject.originalShaderProgram;\n    }\n\n    if (\n      !defined(derivedCommand) ||\n      command.dirty ||\n      originalShaderProgram !== command.shaderProgram ||\n      derivedCommand.framebuffer !== this.framebuffer\n    ) {\n      // Prevent crash when tiles out-of-view come in-view during context size change or\n      // when the underlying shader changes while EDL is disabled\n      derivedCommand = DrawCommand.shallowClone(command, derivedCommand);\n      derivedCommand.framebuffer = this.framebuffer;\n      derivedCommand.shaderProgram = getECShaderProgram(\n        frameState.context,\n        command.shaderProgram\n      );\n      derivedCommand.castShadows = false;\n      derivedCommand.receiveShadows = false;\n\n      if (!defined(derivedCommandObject)) {\n        derivedCommandObject = {\n          command: derivedCommand,\n          originalShaderProgram: command.shaderProgram,\n        };\n        command.derivedCommands.pointCloudProcessor = derivedCommandObject;\n      }\n\n      derivedCommandObject.originalShaderProgram = command.shaderProgram;\n    }\n\n    commandList[i] = derivedCommand;\n  }\n\n  const clearCommand = this._clearCommand;\n  const blendCommand = this._drawCommand;\n\n  blendCommand.boundingVolume = boundingVolume;\n\n  // Blend EDL into the main FBO\n  commandList.push(blendCommand);\n  commandList.push(clearCommand);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PointCloudEyeDomeLighting#destroy\n */\nPointCloudEyeDomeLighting.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * processor = processor && processor.destroy();\n *\n * @see PointCloudEyeDomeLighting#isDestroyed\n */\nPointCloudEyeDomeLighting.prototype.destroy = function () {\n  destroyFramebuffer(this);\n  return destroyObject(this);\n};\nexport default PointCloudEyeDomeLighting;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\n\n/**\n * Options for performing point attenuation based on geometric error when rendering\n * point clouds using 3D Tiles.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.attenuation=false] Perform point attenuation based on geometric error.\n * @param {Number} [options.geometricErrorScale=1.0] Scale to be applied to each tile's geometric error.\n * @param {Number} [options.maximumAttenuation] Maximum attenuation in pixels. Defaults to the Cesium3DTileset's maximumScreenSpaceError.\n * @param {Number} [options.baseResolution] Average base resolution for the dataset in meters. Substitute for Geometric Error when not available.\n * @param {Boolean} [options.eyeDomeLighting=true] When true, use eye dome lighting when drawing with point attenuation.\n * @param {Number} [options.eyeDomeLightingStrength=1.0] Increasing this value increases contrast on slopes and edges.\n * @param {Number} [options.eyeDomeLightingRadius=1.0] Increase the thickness of contours from eye dome lighting.\n * @param {Boolean} [options.backFaceCulling=false] Determines whether back-facing points are hidden. This option works only if data has normals included.\n * @param {Boolean} [options.normalShading=true] Determines whether a point cloud that contains normals is shaded by the scene's light source.\n *\n * @alias PointCloudShading\n * @constructor\n */\nfunction PointCloudShading(options) {\n  const pointCloudShading = defaultValue(options, {});\n\n  /**\n   * Perform point attenuation based on geometric error.\n   * @type {Boolean}\n   * @default false\n   */\n  this.attenuation = defaultValue(pointCloudShading.attenuation, false);\n\n  /**\n   * Scale to be applied to the geometric error before computing attenuation.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.geometricErrorScale = defaultValue(\n    pointCloudShading.geometricErrorScale,\n    1.0\n  );\n\n  /**\n   * Maximum point attenuation in pixels. If undefined, the Cesium3DTileset's maximumScreenSpaceError will be used.\n   * @type {Number}\n   */\n  this.maximumAttenuation = pointCloudShading.maximumAttenuation;\n\n  /**\n   * Average base resolution for the dataset in meters.\n   * Used in place of geometric error when geometric error is 0.\n   * If undefined, an approximation will be computed for each tile that has geometric error of 0.\n   * @type {Number}\n   */\n  this.baseResolution = pointCloudShading.baseResolution;\n\n  /**\n   * Use eye dome lighting when drawing with point attenuation\n   * Requires support for EXT_frag_depth, OES_texture_float, and WEBGL_draw_buffers extensions in WebGL 1.0,\n   * otherwise eye dome lighting is ignored.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.eyeDomeLighting = defaultValue(pointCloudShading.eyeDomeLighting, true);\n\n  /**\n   * Eye dome lighting strength (apparent contrast)\n   * @type {Number}\n   * @default 1.0\n   */\n  this.eyeDomeLightingStrength = defaultValue(\n    pointCloudShading.eyeDomeLightingStrength,\n    1.0\n  );\n\n  /**\n   * Thickness of contours from eye dome lighting\n   * @type {Number}\n   * @default 1.0\n   */\n  this.eyeDomeLightingRadius = defaultValue(\n    pointCloudShading.eyeDomeLightingRadius,\n    1.0\n  );\n\n  /**\n   * Determines whether back-facing points are hidden.\n   * This option works only if data has normals included.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.backFaceCulling = defaultValue(pointCloudShading.backFaceCulling, false);\n\n  /**\n   * Determines whether a point cloud that contains normals is shaded by the scene's light source.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.normalShading = defaultValue(pointCloudShading.normalShading, true);\n}\n\n/**\n * Determines if point cloud shading is supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if point cloud shading is supported; otherwise, returns <code>false</code>\n */\nPointCloudShading.isSupported = function (scene) {\n  return PointCloudEyeDomeLighting.isSupported(scene.context);\n};\nexport default PointCloudShading;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\n\n/**\n * A graphical point positioned in the 3D scene, that is created\n * and rendered using a {@link PointPrimitiveCollection}.  A point is created and its initial\n * properties are set by calling {@link PointPrimitiveCollection#add}.\n *\n * @alias PointPrimitive\n *\n * @performance Reading a property, e.g., {@link PointPrimitive#show}, is constant time.\n * Assigning to a property is constant time but results in\n * CPU to GPU traffic when {@link PointPrimitiveCollection#update} is called.  The per-pointPrimitive traffic is\n * the same regardless of how many properties were updated.  If most pointPrimitives in a collection need to be\n * updated, it may be more efficient to clear the collection with {@link PointPrimitiveCollection#removeAll}\n * and add new pointPrimitives instead of modifying each one.\n *\n * @exception {DeveloperError} scaleByDistance.far must be greater than scaleByDistance.near\n * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near\n * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n *\n * @see PointPrimitiveCollection\n * @see PointPrimitiveCollection#add\n *\n * @internalConstructor\n * @class\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Points.html|Cesium Sandcastle Points Demo}\n */\nfunction PointPrimitive(options, pointPrimitiveCollection) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(options.disableDepthTestDistance) &&\n    options.disableDepthTestDistance < 0.0\n  ) {\n    throw new DeveloperError(\n      \"disableDepthTestDistance must be greater than or equal to 0.0.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let translucencyByDistance = options.translucencyByDistance;\n  let scaleByDistance = options.scaleByDistance;\n  let distanceDisplayCondition = options.distanceDisplayCondition;\n  if (defined(translucencyByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (translucencyByDistance.far <= translucencyByDistance.near) {\n      throw new DeveloperError(\n        \"translucencyByDistance.far must be greater than translucencyByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    translucencyByDistance = NearFarScalar.clone(translucencyByDistance);\n  }\n  if (defined(scaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (scaleByDistance.far <= scaleByDistance.near) {\n      throw new DeveloperError(\n        \"scaleByDistance.far must be greater than scaleByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    scaleByDistance = NearFarScalar.clone(scaleByDistance);\n  }\n  if (defined(distanceDisplayCondition)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {\n      throw new DeveloperError(\n        \"distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    distanceDisplayCondition = DistanceDisplayCondition.clone(\n      distanceDisplayCondition\n    );\n  }\n\n  this._show = defaultValue(options.show, true);\n  this._position = Cartesian3.clone(\n    defaultValue(options.position, Cartesian3.ZERO)\n  );\n  this._actualPosition = Cartesian3.clone(this._position); // For columbus view and 2D\n  this._color = Color.clone(defaultValue(options.color, Color.WHITE));\n  this._outlineColor = Color.clone(\n    defaultValue(options.outlineColor, Color.TRANSPARENT)\n  );\n  this._outlineWidth = defaultValue(options.outlineWidth, 0.0);\n  this._pixelSize = defaultValue(options.pixelSize, 10.0);\n  this._scaleByDistance = scaleByDistance;\n  this._translucencyByDistance = translucencyByDistance;\n  this._distanceDisplayCondition = distanceDisplayCondition;\n  this._disableDepthTestDistance = defaultValue(\n    options.disableDepthTestDistance,\n    0.0\n  );\n  this._id = options.id;\n  this._collection = defaultValue(options.collection, pointPrimitiveCollection);\n\n  this._clusterShow = true;\n\n  this._pickId = undefined;\n  this._pointPrimitiveCollection = pointPrimitiveCollection;\n  this._dirty = false;\n  this._index = -1; //Used only by PointPrimitiveCollection\n}\n\nconst SHOW_INDEX = (PointPrimitive.SHOW_INDEX = 0);\nconst POSITION_INDEX = (PointPrimitive.POSITION_INDEX = 1);\nconst COLOR_INDEX = (PointPrimitive.COLOR_INDEX = 2);\nconst OUTLINE_COLOR_INDEX = (PointPrimitive.OUTLINE_COLOR_INDEX = 3);\nconst OUTLINE_WIDTH_INDEX = (PointPrimitive.OUTLINE_WIDTH_INDEX = 4);\nconst PIXEL_SIZE_INDEX = (PointPrimitive.PIXEL_SIZE_INDEX = 5);\nconst SCALE_BY_DISTANCE_INDEX = (PointPrimitive.SCALE_BY_DISTANCE_INDEX = 6);\nconst TRANSLUCENCY_BY_DISTANCE_INDEX = (PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX = 7);\nconst DISTANCE_DISPLAY_CONDITION_INDEX = (PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX = 8);\nconst DISABLE_DEPTH_DISTANCE_INDEX = (PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX = 9);\nPointPrimitive.NUMBER_OF_PROPERTIES = 10;\n\nfunction makeDirty(pointPrimitive, propertyChanged) {\n  const pointPrimitiveCollection = pointPrimitive._pointPrimitiveCollection;\n  if (defined(pointPrimitiveCollection)) {\n    pointPrimitiveCollection._updatePointPrimitive(\n      pointPrimitive,\n      propertyChanged\n    );\n    pointPrimitive._dirty = true;\n  }\n}\n\nObject.defineProperties(PointPrimitive.prototype, {\n  /**\n   * Determines if this point will be shown.  Use this to hide or show a point, instead\n   * of removing it and re-adding it to the collection.\n   * @memberof PointPrimitive.prototype\n   * @type {Boolean}\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._show !== value) {\n        this._show = value;\n        makeDirty(this, SHOW_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the Cartesian position of this point.\n   * @memberof PointPrimitive.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug)\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const position = this._position;\n      if (!Cartesian3.equals(position, value)) {\n        Cartesian3.clone(value, position);\n        Cartesian3.clone(value, this._actualPosition);\n\n        makeDirty(this, POSITION_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far scaling properties of a point based on the point's distance from the camera.\n   * A point's scale will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the point's scale remains clamped to the nearest bound.  This scale\n   * multiplies the pixelSize and outlineWidth to affect the total size of the point.  If undefined,\n   * scaleByDistance will be disabled.\n   * @memberof PointPrimitive.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a pointPrimitive's scaleByDistance to scale to 15 when the\n   * // camera is 1500 meters from the pointPrimitive and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * p.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 15, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable scaling by distance\n   * p.scaleByDistance = undefined;\n   */\n  scaleByDistance: {\n    get: function () {\n      return this._scaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      const scaleByDistance = this._scaleByDistance;\n      if (!NearFarScalar.equals(scaleByDistance, value)) {\n        this._scaleByDistance = NearFarScalar.clone(value, scaleByDistance);\n        makeDirty(this, SCALE_BY_DISTANCE_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far translucency properties of a point based on the point's distance from the camera.\n   * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the point's translucency remains clamped to the nearest bound.  If undefined,\n   * translucencyByDistance will be disabled.\n   * @memberof PointPrimitive.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a point's translucency to 1.0 when the\n   * // camera is 1500 meters from the point and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * p.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable translucency by distance\n   * p.translucencyByDistance = undefined;\n   */\n  translucencyByDistance: {\n    get: function () {\n      return this._translucencyByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      const translucencyByDistance = this._translucencyByDistance;\n      if (!NearFarScalar.equals(translucencyByDistance, value)) {\n        this._translucencyByDistance = NearFarScalar.clone(\n          value,\n          translucencyByDistance\n        );\n        makeDirty(this, TRANSLUCENCY_BY_DISTANCE_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the inner size of the point in pixels.\n   * @memberof PointPrimitive.prototype\n   * @type {Number}\n   */\n  pixelSize: {\n    get: function () {\n      return this._pixelSize;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._pixelSize !== value) {\n        this._pixelSize = value;\n        makeDirty(this, PIXEL_SIZE_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the inner color of the point.\n   * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,\n   * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>\n   * (no intensity) to <code>1.0</code> (full intensity).\n   * @memberof PointPrimitive.prototype\n   * @type {Color}\n   *\n   * @example\n   * // Example 1. Assign yellow.\n   * p.color = Cesium.Color.YELLOW;\n   *\n   * @example\n   * // Example 2. Make a pointPrimitive 50% translucent.\n   * p.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);\n   */\n  color: {\n    get: function () {\n      return this._color;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const color = this._color;\n      if (!Color.equals(color, value)) {\n        Color.clone(value, color);\n        makeDirty(this, COLOR_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the outline color of the point.\n   * @memberof PointPrimitive.prototype\n   * @type {Color}\n   */\n  outlineColor: {\n    get: function () {\n      return this._outlineColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const outlineColor = this._outlineColor;\n      if (!Color.equals(outlineColor, value)) {\n        Color.clone(value, outlineColor);\n        makeDirty(this, OUTLINE_COLOR_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the outline width in pixels.  This width adds to pixelSize,\n   * increasing the total size of the point.\n   * @memberof PointPrimitive.prototype\n   * @type {Number}\n   */\n  outlineWidth: {\n    get: function () {\n      return this._outlineWidth;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._outlineWidth !== value) {\n        this._outlineWidth = value;\n        makeDirty(this, OUTLINE_WIDTH_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this point will be displayed.\n   * @memberof PointPrimitive.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      }\n      //>>includeEnd('debug');\n      if (\n        !DistanceDisplayCondition.equals(this._distanceDisplayCondition, value)\n      ) {\n        this._distanceDisplayCondition = DistanceDisplayCondition.clone(\n          value,\n          this._distanceDisplayCondition\n        );\n        makeDirty(this, DISTANCE_DISPLAY_CONDITION_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.\n   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.\n   * @memberof PointPrimitive.prototype\n   * @type {Number}\n   * @default 0.0\n   */\n  disableDepthTestDistance: {\n    get: function () {\n      return this._disableDepthTestDistance;\n    },\n    set: function (value) {\n      if (this._disableDepthTestDistance !== value) {\n        //>>includeStart('debug', pragmas.debug);\n        if (!defined(value) || value < 0.0) {\n          throw new DeveloperError(\n            \"disableDepthTestDistance must be greater than or equal to 0.0.\"\n          );\n        }\n        //>>includeEnd('debug');\n        this._disableDepthTestDistance = value;\n        makeDirty(this, DISABLE_DEPTH_DISTANCE_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the user-defined value returned when the point is picked.\n   * @memberof PointPrimitive.prototype\n   * @type {*}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n    set: function (value) {\n      this._id = value;\n      if (defined(this._pickId)) {\n        this._pickId.object.id = value;\n      }\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickId: {\n    get: function () {\n      return this._pickId;\n    },\n  },\n\n  /**\n   * Determines whether or not this point will be shown or hidden because it was clustered.\n   * @memberof PointPrimitive.prototype\n   * @type {Boolean}\n   * @private\n   */\n  clusterShow: {\n    get: function () {\n      return this._clusterShow;\n    },\n    set: function (value) {\n      if (this._clusterShow !== value) {\n        this._clusterShow = value;\n        makeDirty(this, SHOW_INDEX);\n      }\n    },\n  },\n});\n\nPointPrimitive.prototype.getPickId = function (context) {\n  if (!defined(this._pickId)) {\n    this._pickId = context.createPickId({\n      primitive: this,\n      collection: this._collection,\n      id: this._id,\n    });\n  }\n\n  return this._pickId;\n};\n\nPointPrimitive.prototype._getActualPosition = function () {\n  return this._actualPosition;\n};\n\nPointPrimitive.prototype._setActualPosition = function (value) {\n  Cartesian3.clone(value, this._actualPosition);\n  makeDirty(this, POSITION_INDEX);\n};\n\nconst tempCartesian3 = new Cartesian4();\nPointPrimitive._computeActualPosition = function (\n  position,\n  frameState,\n  modelMatrix\n) {\n  if (frameState.mode === SceneMode.SCENE3D) {\n    return position;\n  }\n\n  Matrix4.multiplyByPoint(modelMatrix, position, tempCartesian3);\n  return SceneTransforms.computeActualWgs84Position(frameState, tempCartesian3);\n};\n\nconst scratchCartesian4 = new Cartesian4();\n\n// This function is basically a stripped-down JavaScript version of PointPrimitiveCollectionVS.glsl\nPointPrimitive._computeScreenSpacePosition = function (\n  modelMatrix,\n  position,\n  scene,\n  result\n) {\n  // Model to world coordinates\n  const positionWorld = Matrix4.multiplyByVector(\n    modelMatrix,\n    Cartesian4.fromElements(\n      position.x,\n      position.y,\n      position.z,\n      1,\n      scratchCartesian4\n    ),\n    scratchCartesian4\n  );\n  const positionWC = SceneTransforms.wgs84ToWindowCoordinates(\n    scene,\n    positionWorld,\n    result\n  );\n  return positionWC;\n};\n\n/**\n * Computes the screen-space position of the point's origin.\n * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n * left to right, and <code>y</code> increases from top to bottom.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The screen-space position of the point.\n *\n * @exception {DeveloperError} PointPrimitive must be in a collection.\n *\n * @example\n * console.log(p.computeScreenSpacePosition(scene).toString());\n */\nPointPrimitive.prototype.computeScreenSpacePosition = function (scene, result) {\n  const pointPrimitiveCollection = this._pointPrimitiveCollection;\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(pointPrimitiveCollection)) {\n    throw new DeveloperError(\"PointPrimitive must be in a collection.\");\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const modelMatrix = pointPrimitiveCollection.modelMatrix;\n  const windowCoordinates = PointPrimitive._computeScreenSpacePosition(\n    modelMatrix,\n    this._actualPosition,\n    scene,\n    result\n  );\n  if (!defined(windowCoordinates)) {\n    return undefined;\n  }\n\n  windowCoordinates.y = scene.canvas.clientHeight - windowCoordinates.y;\n  return windowCoordinates;\n};\n\n/**\n * Gets a point's screen space bounding box centered around screenSpacePosition.\n * @param {PointPrimitive} point The point to get the screen space bounding box for.\n * @param {Cartesian2} screenSpacePosition The screen space center of the label.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The screen space bounding box.\n *\n * @private\n */\nPointPrimitive.getScreenSpaceBoundingBox = function (\n  point,\n  screenSpacePosition,\n  result\n) {\n  const size = point.pixelSize;\n  const halfSize = size * 0.5;\n\n  const x = screenSpacePosition.x - halfSize;\n  const y = screenSpacePosition.y - halfSize;\n  const width = size;\n  const height = size;\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  result.x = x;\n  result.y = y;\n  result.width = width;\n  result.height = height;\n\n  return result;\n};\n\n/**\n * Determines if this point equals another point.  Points are equal if all their properties\n * are equal.  Points in different collections can be equal.\n *\n * @param {PointPrimitive} other The point to compare for equality.\n * @returns {Boolean} <code>true</code> if the points are equal; otherwise, <code>false</code>.\n */\nPointPrimitive.prototype.equals = function (other) {\n  return (\n    this === other ||\n    (defined(other) &&\n      this._id === other._id &&\n      Cartesian3.equals(this._position, other._position) &&\n      Color.equals(this._color, other._color) &&\n      this._pixelSize === other._pixelSize &&\n      this._outlineWidth === other._outlineWidth &&\n      this._show === other._show &&\n      Color.equals(this._outlineColor, other._outlineColor) &&\n      NearFarScalar.equals(this._scaleByDistance, other._scaleByDistance) &&\n      NearFarScalar.equals(\n        this._translucencyByDistance,\n        other._translucencyByDistance\n      ) &&\n      DistanceDisplayCondition.equals(\n        this._distanceDisplayCondition,\n        other._distanceDisplayCondition\n      ) &&\n      this._disableDepthTestDistance === other._disableDepthTestDistance)\n  );\n};\n\nPointPrimitive.prototype._destroy = function () {\n  this._pickId = this._pickId && this._pickId.destroy();\n  this._pointPrimitiveCollection = undefined;\n};\nexport default PointPrimitive;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArrayFacade from \"../Renderer/VertexArrayFacade.js\";\nimport PointPrimitiveCollectionFS from \"../Shaders/PointPrimitiveCollectionFS.js\";\nimport PointPrimitiveCollectionVS from \"../Shaders/PointPrimitiveCollectionVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport PointPrimitive from \"./PointPrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nconst SHOW_INDEX = PointPrimitive.SHOW_INDEX;\nconst POSITION_INDEX = PointPrimitive.POSITION_INDEX;\nconst COLOR_INDEX = PointPrimitive.COLOR_INDEX;\nconst OUTLINE_COLOR_INDEX = PointPrimitive.OUTLINE_COLOR_INDEX;\nconst OUTLINE_WIDTH_INDEX = PointPrimitive.OUTLINE_WIDTH_INDEX;\nconst PIXEL_SIZE_INDEX = PointPrimitive.PIXEL_SIZE_INDEX;\nconst SCALE_BY_DISTANCE_INDEX = PointPrimitive.SCALE_BY_DISTANCE_INDEX;\nconst TRANSLUCENCY_BY_DISTANCE_INDEX =\n  PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION_INDEX =\n  PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX;\nconst DISABLE_DEPTH_DISTANCE_INDEX =\n  PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX;\nconst NUMBER_OF_PROPERTIES = PointPrimitive.NUMBER_OF_PROPERTIES;\n\nconst attributeLocations = {\n  positionHighAndSize: 0,\n  positionLowAndOutline: 1,\n  compressedAttribute0: 2, // color, outlineColor, pick color\n  compressedAttribute1: 3, // show, translucency by distance, some free space\n  scaleByDistance: 4,\n  distanceDisplayConditionAndDisableDepth: 5,\n};\n\n/**\n * A renderable collection of points.\n * <br /><br />\n * Points are added and removed from the collection using {@link PointPrimitiveCollection#add}\n * and {@link PointPrimitiveCollection#remove}.\n *\n * @alias PointPrimitiveCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each point from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The point blending option. The default\n * is used for rendering both opaque and translucent points. However, if either all of the points are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {Boolean} [options.show=true] Determines if the primitives in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many points, to\n * many collections with only a few points each.  Organize collections so that points\n * with the same update frequency are in the same collection, i.e., points that do not\n * change should be in one collection; points that change every frame should be in another\n * collection; and so on.\n *\n *\n * @example\n * // Create a pointPrimitive collection with two points\n * const points = scene.primitives.add(new Cesium.PointPrimitiveCollection());\n * points.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   color : Cesium.Color.YELLOW\n * });\n * points.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   color : Cesium.Color.CYAN\n * });\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitive\n */\nfunction PointPrimitiveCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._sp = undefined;\n  this._spTranslucent = undefined;\n  this._rsOpaque = undefined;\n  this._rsTranslucent = undefined;\n  this._vaf = undefined;\n\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n  this._createVertexArray = false;\n\n  this._shaderScaleByDistance = false;\n  this._compiledShaderScaleByDistance = false;\n\n  this._shaderTranslucencyByDistance = false;\n  this._compiledShaderTranslucencyByDistance = false;\n\n  this._shaderDistanceDisplayCondition = false;\n  this._compiledShaderDistanceDisplayCondition = false;\n\n  this._shaderDisableDepthDistance = false;\n  this._compiledShaderDisableDepthDistance = false;\n\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n\n  this._maxPixelSize = 1.0;\n\n  this._baseVolume = new BoundingSphere();\n  this._baseVolumeWC = new BoundingSphere();\n  this._baseVolume2D = new BoundingSphere();\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolumeDirty = false;\n\n  this._colorCommands = [];\n\n  /**\n   * Determines if primitives in this collection will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.\n   * When this is the identity matrix, the pointPrimitives are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   *\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * pointPrimitives.add({\n   *   color : Cesium.Color.ORANGE,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.YELLOW,\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.GREEN,\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north\n   * });\n   * pointPrimitives.add({\n   *   color : Cesium.Color.CYAN,\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up\n   * });\n   *\n   * @see Transforms.eastNorthUpToFixedFrame\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * The point blending option. The default is used for rendering both opaque and translucent points.\n   * However, if either all of the points are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = defaultValue(\n    options.blendOption,\n    BlendOption.OPAQUE_AND_TRANSLUCENT\n  );\n  this._blendOption = undefined;\n\n  this._mode = SceneMode.SCENE3D;\n  this._maxTotalPointSize = 1;\n\n  // The buffer usage for each attribute is determined based on the usage of the attribute over time.\n  this._buffersUsage = [\n    BufferUsage.STATIC_DRAW, // SHOW_INDEX\n    BufferUsage.STATIC_DRAW, // POSITION_INDEX\n    BufferUsage.STATIC_DRAW, // COLOR_INDEX\n    BufferUsage.STATIC_DRAW, // OUTLINE_COLOR_INDEX\n    BufferUsage.STATIC_DRAW, // OUTLINE_WIDTH_INDEX\n    BufferUsage.STATIC_DRAW, // PIXEL_SIZE_INDEX\n    BufferUsage.STATIC_DRAW, // SCALE_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // TRANSLUCENCY_BY_DISTANCE_INDEX\n    BufferUsage.STATIC_DRAW, // DISTANCE_DISPLAY_CONDITION_INDEX\n  ];\n\n  const that = this;\n  this._uniforms = {\n    u_maxTotalPointSize: function () {\n      return that._maxTotalPointSize;\n    },\n  };\n}\n\nObject.defineProperties(PointPrimitiveCollection.prototype, {\n  /**\n   * Returns the number of points in this collection.  This is commonly used with\n   * {@link PointPrimitiveCollection#get} to iterate over all the points\n   * in the collection.\n   * @memberof PointPrimitiveCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      removePointPrimitives(this);\n      return this._pointPrimitives.length;\n    },\n  },\n});\n\nfunction destroyPointPrimitives(pointPrimitives) {\n  const length = pointPrimitives.length;\n  for (let i = 0; i < length; ++i) {\n    if (pointPrimitives[i]) {\n      pointPrimitives[i]._destroy();\n    }\n  }\n}\n\n/**\n * Creates and adds a point with the specified initial properties to the collection.\n * The added point is returned so it can be modified or removed from the collection later.\n *\n * @param {Object}[options] A template describing the point's properties as shown in Example 1.\n * @returns {PointPrimitive} The point that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, add as many pointPrimitives as possible before calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a point, specifying all the default values.\n * const p = pointPrimitives.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   pixelSize : 10.0,\n *   color : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.TRANSPARENT,\n *   outlineWidth : 0.0,\n *   id : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the point's cartographic position.\n * const p = pointPrimitives.add({\n *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)\n * });\n *\n * @see PointPrimitiveCollection#remove\n * @see PointPrimitiveCollection#removeAll\n */\nPointPrimitiveCollection.prototype.add = function (options) {\n  const p = new PointPrimitive(options, this);\n  p._index = this._pointPrimitives.length;\n\n  this._pointPrimitives.push(p);\n  this._createVertexArray = true;\n\n  return p;\n};\n\n/**\n * Removes a point from the collection.\n *\n * @param {PointPrimitive} pointPrimitive The point to remove.\n * @returns {Boolean} <code>true</code> if the point was removed; <code>false</code> if the point was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many points as possible before calling <code>update</code>.\n * If you intend to temporarily hide a point, it is usually more efficient to call\n * {@link PointPrimitive#show} instead of removing and re-adding the point.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const p = pointPrimitives.add(...);\n * pointPrimitives.remove(p);  // Returns true\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#removeAll\n * @see PointPrimitive#show\n */\nPointPrimitiveCollection.prototype.remove = function (pointPrimitive) {\n  if (this.contains(pointPrimitive)) {\n    this._pointPrimitives[pointPrimitive._index] = null; // Removed later\n    this._pointPrimitivesRemoved = true;\n    this._createVertexArray = true;\n    pointPrimitive._destroy();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all points from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the points\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives.add(...);\n * pointPrimitives.add(...);\n * pointPrimitives.removeAll();\n *\n * @see PointPrimitiveCollection#add\n * @see PointPrimitiveCollection#remove\n */\nPointPrimitiveCollection.prototype.removeAll = function () {\n  destroyPointPrimitives(this._pointPrimitives);\n  this._pointPrimitives = [];\n  this._pointPrimitivesToUpdate = [];\n  this._pointPrimitivesToUpdateIndex = 0;\n  this._pointPrimitivesRemoved = false;\n\n  this._createVertexArray = true;\n};\n\nfunction removePointPrimitives(pointPrimitiveCollection) {\n  if (pointPrimitiveCollection._pointPrimitivesRemoved) {\n    pointPrimitiveCollection._pointPrimitivesRemoved = false;\n\n    const newPointPrimitives = [];\n    const pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n    const length = pointPrimitives.length;\n    for (let i = 0, j = 0; i < length; ++i) {\n      const pointPrimitive = pointPrimitives[i];\n      if (pointPrimitive) {\n        pointPrimitive._index = j++;\n        newPointPrimitives.push(pointPrimitive);\n      }\n    }\n\n    pointPrimitiveCollection._pointPrimitives = newPointPrimitives;\n  }\n}\n\nPointPrimitiveCollection.prototype._updatePointPrimitive = function (\n  pointPrimitive,\n  propertyChanged\n) {\n  if (!pointPrimitive._dirty) {\n    this._pointPrimitivesToUpdate[\n      this._pointPrimitivesToUpdateIndex++\n    ] = pointPrimitive;\n  }\n\n  ++this._propertiesChanged[propertyChanged];\n};\n\n/**\n * Check whether this collection contains a given point.\n *\n * @param {PointPrimitive} [pointPrimitive] The point to check for.\n * @returns {Boolean} true if this collection contains the point, false otherwise.\n *\n * @see PointPrimitiveCollection#get\n */\nPointPrimitiveCollection.prototype.contains = function (pointPrimitive) {\n  return (\n    defined(pointPrimitive) && pointPrimitive._pointPrimitiveCollection === this\n  );\n};\n\n/**\n * Returns the point in the collection at the specified index.  Indices are zero-based\n * and increase as points are added.  Removing a point shifts all points after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PointPrimitiveCollection#length} to iterate over all the points\n * in the collection.\n *\n * @param {Number} index The zero-based index of the point.\n * @returns {PointPrimitive} The point at the specified index.\n *\n * @performance Expected constant time.  If points were removed from the collection and\n * {@link PointPrimitiveCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every point in the collection\n * const len = pointPrimitives.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = pointPrimitives.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PointPrimitiveCollection#length\n */\nPointPrimitiveCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  removePointPrimitives(this);\n  return this._pointPrimitives[index];\n};\n\nPointPrimitiveCollection.prototype.computeNewBuffersUsage = function () {\n  const buffersUsage = this._buffersUsage;\n  let usageChanged = false;\n\n  const properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    const newUsage =\n      properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;\n    usageChanged = usageChanged || buffersUsage[k] !== newUsage;\n    buffersUsage[k] = newUsage;\n  }\n\n  return usageChanged;\n};\n\nfunction createVAF(context, numberOfPointPrimitives, buffersUsage) {\n  return new VertexArrayFacade(\n    context,\n    [\n      {\n        index: attributeLocations.positionHighAndSize,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[POSITION_INDEX],\n      },\n      {\n        index: attributeLocations.positionLowAndShow,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[POSITION_INDEX],\n      },\n      {\n        index: attributeLocations.compressedAttribute0,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[COLOR_INDEX],\n      },\n      {\n        index: attributeLocations.compressedAttribute1,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX],\n      },\n      {\n        index: attributeLocations.scaleByDistance,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[SCALE_BY_DISTANCE_INDEX],\n      },\n      {\n        index: attributeLocations.distanceDisplayConditionAndDisableDepth,\n        componentsPerAttribute: 3,\n        componentDatatype: ComponentDatatype.FLOAT,\n        usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX],\n      },\n    ],\n    numberOfPointPrimitives\n  ); // 1 vertex per pointPrimitive\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n// PERFORMANCE_IDEA:  Save memory if a property is the same for all pointPrimitives, use a latched attribute state,\n// instead of storing it in a vertex buffer.\n\nconst writePositionScratch = new EncodedCartesian3();\n\nfunction writePositionSizeAndOutline(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  const i = pointPrimitive._index;\n  const position = pointPrimitive._getActualPosition();\n\n  if (pointPrimitiveCollection._mode === SceneMode.SCENE3D) {\n    BoundingSphere.expand(\n      pointPrimitiveCollection._baseVolume,\n      position,\n      pointPrimitiveCollection._baseVolume\n    );\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  }\n\n  EncodedCartesian3.fromCartesian(position, writePositionScratch);\n  const pixelSize = pointPrimitive.pixelSize;\n  const outlineWidth = pointPrimitive.outlineWidth;\n\n  pointPrimitiveCollection._maxPixelSize = Math.max(\n    pointPrimitiveCollection._maxPixelSize,\n    pixelSize + outlineWidth\n  );\n\n  const positionHighWriter = vafWriters[attributeLocations.positionHighAndSize];\n  const high = writePositionScratch.high;\n  positionHighWriter(i, high.x, high.y, high.z, pixelSize);\n\n  const positionLowWriter =\n    vafWriters[attributeLocations.positionLowAndOutline];\n  const low = writePositionScratch.low;\n  positionLowWriter(i, low.x, low.y, low.z, outlineWidth);\n}\n\nconst LEFT_SHIFT16 = 65536.0; // 2^16\nconst LEFT_SHIFT8 = 256.0; // 2^8\n\nfunction writeCompressedAttrib0(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  const i = pointPrimitive._index;\n\n  const color = pointPrimitive.color;\n  const pickColor = pointPrimitive.getPickId(context).color;\n  const outlineColor = pointPrimitive.outlineColor;\n\n  let red = Color.floatToByte(color.red);\n  let green = Color.floatToByte(color.green);\n  let blue = Color.floatToByte(color.blue);\n  const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  red = Color.floatToByte(outlineColor.red);\n  green = Color.floatToByte(outlineColor.green);\n  blue = Color.floatToByte(outlineColor.blue);\n  const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  red = Color.floatToByte(pickColor.red);\n  green = Color.floatToByte(pickColor.green);\n  blue = Color.floatToByte(pickColor.blue);\n  const compressed2 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;\n\n  const compressed3 =\n    Color.floatToByte(color.alpha) * LEFT_SHIFT16 +\n    Color.floatToByte(outlineColor.alpha) * LEFT_SHIFT8 +\n    Color.floatToByte(pickColor.alpha);\n\n  const writer = vafWriters[attributeLocations.compressedAttribute0];\n  writer(i, compressed0, compressed1, compressed2, compressed3);\n}\n\nfunction writeCompressedAttrib1(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  const i = pointPrimitive._index;\n\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const translucency = pointPrimitive.translucencyByDistance;\n  if (defined(translucency)) {\n    near = translucency.near;\n    nearValue = translucency.nearValue;\n    far = translucency.far;\n    farValue = translucency.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // translucency by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderTranslucencyByDistance = true;\n    }\n  }\n\n  let show = pointPrimitive.show && pointPrimitive.clusterShow;\n\n  // If the color alphas are zero, do not show this pointPrimitive.  This lets us avoid providing\n  // color during the pick pass and also eliminates a discard in the fragment shader.\n  if (\n    pointPrimitive.color.alpha === 0.0 &&\n    pointPrimitive.outlineColor.alpha === 0.0\n  ) {\n    show = false;\n  }\n\n  nearValue = CesiumMath.clamp(nearValue, 0.0, 1.0);\n  nearValue = nearValue === 1.0 ? 255.0 : (nearValue * 255.0) | 0;\n  const compressed0 = (show ? 1.0 : 0.0) * LEFT_SHIFT8 + nearValue;\n\n  farValue = CesiumMath.clamp(farValue, 0.0, 1.0);\n  farValue = farValue === 1.0 ? 255.0 : (farValue * 255.0) | 0;\n  const compressed1 = farValue;\n\n  const writer = vafWriters[attributeLocations.compressedAttribute1];\n  writer(i, compressed0, compressed1, near, far);\n}\n\nfunction writeScaleByDistance(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  const i = pointPrimitive._index;\n  const writer = vafWriters[attributeLocations.scaleByDistance];\n  let near = 0.0;\n  let nearValue = 1.0;\n  let far = 1.0;\n  let farValue = 1.0;\n\n  const scale = pointPrimitive.scaleByDistance;\n  if (defined(scale)) {\n    near = scale.near;\n    nearValue = scale.nearValue;\n    far = scale.far;\n    farValue = scale.farValue;\n\n    if (nearValue !== 1.0 || farValue !== 1.0) {\n      // scale by distance calculation in shader need not be enabled\n      // until a pointPrimitive with near and far !== 1.0 is found\n      pointPrimitiveCollection._shaderScaleByDistance = true;\n    }\n  }\n\n  writer(i, near, nearValue, far, farValue);\n}\n\nfunction writeDistanceDisplayConditionAndDepthDisable(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  const i = pointPrimitive._index;\n  const writer =\n    vafWriters[attributeLocations.distanceDisplayConditionAndDisableDepth];\n  let near = 0.0;\n  let far = Number.MAX_VALUE;\n\n  const distanceDisplayCondition = pointPrimitive.distanceDisplayCondition;\n  if (defined(distanceDisplayCondition)) {\n    near = distanceDisplayCondition.near;\n    far = distanceDisplayCondition.far;\n\n    near *= near;\n    far *= far;\n\n    pointPrimitiveCollection._shaderDistanceDisplayCondition = true;\n  }\n\n  let disableDepthTestDistance = pointPrimitive.disableDepthTestDistance;\n  disableDepthTestDistance *= disableDepthTestDistance;\n  if (disableDepthTestDistance > 0.0) {\n    pointPrimitiveCollection._shaderDisableDepthDistance = true;\n    if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {\n      disableDepthTestDistance = -1.0;\n    }\n  }\n\n  writer(i, near, far, disableDepthTestDistance);\n}\n\nfunction writePointPrimitive(\n  pointPrimitiveCollection,\n  context,\n  vafWriters,\n  pointPrimitive\n) {\n  writePositionSizeAndOutline(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n  writeCompressedAttrib0(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n  writeCompressedAttrib1(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n  writeScaleByDistance(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n  writeDistanceDisplayConditionAndDepthDisable(\n    pointPrimitiveCollection,\n    context,\n    vafWriters,\n    pointPrimitive\n  );\n}\n\nfunction recomputeActualPositions(\n  pointPrimitiveCollection,\n  pointPrimitives,\n  length,\n  frameState,\n  modelMatrix,\n  recomputeBoundingVolume\n) {\n  let boundingVolume;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolume = pointPrimitiveCollection._baseVolume;\n    pointPrimitiveCollection._boundingVolumeDirty = true;\n  } else {\n    boundingVolume = pointPrimitiveCollection._baseVolume2D;\n  }\n\n  const positions = [];\n  for (let i = 0; i < length; ++i) {\n    const pointPrimitive = pointPrimitives[i];\n    const position = pointPrimitive.position;\n    const actualPosition = PointPrimitive._computeActualPosition(\n      position,\n      frameState,\n      modelMatrix\n    );\n    if (defined(actualPosition)) {\n      pointPrimitive._setActualPosition(actualPosition);\n\n      if (recomputeBoundingVolume) {\n        positions.push(actualPosition);\n      } else {\n        BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);\n      }\n    }\n  }\n\n  if (recomputeBoundingVolume) {\n    BoundingSphere.fromPoints(positions, boundingVolume);\n  }\n}\n\nfunction updateMode(pointPrimitiveCollection, frameState) {\n  const mode = frameState.mode;\n\n  const pointPrimitives = pointPrimitiveCollection._pointPrimitives;\n  const pointPrimitivesToUpdate =\n    pointPrimitiveCollection._pointPrimitivesToUpdate;\n  const modelMatrix = pointPrimitiveCollection._modelMatrix;\n\n  if (\n    pointPrimitiveCollection._createVertexArray ||\n    pointPrimitiveCollection._mode !== mode ||\n    (mode !== SceneMode.SCENE3D &&\n      !Matrix4.equals(modelMatrix, pointPrimitiveCollection.modelMatrix))\n  ) {\n    pointPrimitiveCollection._mode = mode;\n    Matrix4.clone(pointPrimitiveCollection.modelMatrix, modelMatrix);\n    pointPrimitiveCollection._createVertexArray = true;\n\n    if (\n      mode === SceneMode.SCENE3D ||\n      mode === SceneMode.SCENE2D ||\n      mode === SceneMode.COLUMBUS_VIEW\n    ) {\n      recomputeActualPositions(\n        pointPrimitiveCollection,\n        pointPrimitives,\n        pointPrimitives.length,\n        frameState,\n        modelMatrix,\n        true\n      );\n    }\n  } else if (mode === SceneMode.MORPHING) {\n    recomputeActualPositions(\n      pointPrimitiveCollection,\n      pointPrimitives,\n      pointPrimitives.length,\n      frameState,\n      modelMatrix,\n      true\n    );\n  } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {\n    recomputeActualPositions(\n      pointPrimitiveCollection,\n      pointPrimitivesToUpdate,\n      pointPrimitiveCollection._pointPrimitivesToUpdateIndex,\n      frameState,\n      modelMatrix,\n      false\n    );\n  }\n}\n\nfunction updateBoundingVolume(collection, frameState, boundingVolume) {\n  const pixelSize = frameState.camera.getPixelSize(\n    boundingVolume,\n    frameState.context.drawingBufferWidth,\n    frameState.context.drawingBufferHeight\n  );\n  const size = pixelSize * collection._maxPixelSize;\n  boundingVolume.radius += size;\n}\n\nconst scratchWriterArray = [];\n\n/**\n * @private\n */\nPointPrimitiveCollection.prototype.update = function (frameState) {\n  removePointPrimitives(this);\n\n  if (!this.show) {\n    return;\n  }\n\n  this._maxTotalPointSize = ContextLimits.maximumAliasedPointSize;\n\n  updateMode(this, frameState);\n\n  const pointPrimitives = this._pointPrimitives;\n  const pointPrimitivesLength = pointPrimitives.length;\n  const pointPrimitivesToUpdate = this._pointPrimitivesToUpdate;\n  const pointPrimitivesToUpdateLength = this._pointPrimitivesToUpdateIndex;\n\n  const properties = this._propertiesChanged;\n\n  const createVertexArray = this._createVertexArray;\n\n  let vafWriters;\n  const context = frameState.context;\n  const pass = frameState.passes;\n  const picking = pass.pick;\n\n  // PERFORMANCE_IDEA: Round robin multiple buffers.\n  if (createVertexArray || (!picking && this.computeNewBuffersUsage())) {\n    this._createVertexArray = false;\n\n    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n      properties[k] = 0;\n    }\n\n    this._vaf = this._vaf && this._vaf.destroy();\n\n    if (pointPrimitivesLength > 0) {\n      // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.\n      this._vaf = createVAF(context, pointPrimitivesLength, this._buffersUsage);\n      vafWriters = this._vaf.writers;\n\n      // Rewrite entire buffer if pointPrimitives were added or removed.\n      for (let i = 0; i < pointPrimitivesLength; ++i) {\n        const pointPrimitive = this._pointPrimitives[i];\n        pointPrimitive._dirty = false; // In case it needed an update.\n        writePointPrimitive(this, context, vafWriters, pointPrimitive);\n      }\n\n      this._vaf.commit();\n    }\n\n    this._pointPrimitivesToUpdateIndex = 0;\n  } else if (pointPrimitivesToUpdateLength > 0) {\n    // PointPrimitives were modified, but none were added or removed.\n    const writers = scratchWriterArray;\n    writers.length = 0;\n\n    if (\n      properties[POSITION_INDEX] ||\n      properties[OUTLINE_WIDTH_INDEX] ||\n      properties[PIXEL_SIZE_INDEX]\n    ) {\n      writers.push(writePositionSizeAndOutline);\n    }\n\n    if (properties[COLOR_INDEX] || properties[OUTLINE_COLOR_INDEX]) {\n      writers.push(writeCompressedAttrib0);\n    }\n\n    if (properties[SHOW_INDEX] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX]) {\n      writers.push(writeCompressedAttrib1);\n    }\n\n    if (properties[SCALE_BY_DISTANCE_INDEX]) {\n      writers.push(writeScaleByDistance);\n    }\n\n    if (\n      properties[DISTANCE_DISPLAY_CONDITION_INDEX] ||\n      properties[DISABLE_DEPTH_DISTANCE_INDEX]\n    ) {\n      writers.push(writeDistanceDisplayConditionAndDepthDisable);\n    }\n\n    const numWriters = writers.length;\n\n    vafWriters = this._vaf.writers;\n\n    if (pointPrimitivesToUpdateLength / pointPrimitivesLength > 0.1) {\n      // If more than 10% of pointPrimitive change, rewrite the entire buffer.\n\n      // PERFORMANCE_IDEA:  I totally made up 10% :).\n\n      for (let m = 0; m < pointPrimitivesToUpdateLength; ++m) {\n        const b = pointPrimitivesToUpdate[m];\n        b._dirty = false;\n\n        for (let n = 0; n < numWriters; ++n) {\n          writers[n](this, context, vafWriters, b);\n        }\n      }\n      this._vaf.commit();\n    } else {\n      for (let h = 0; h < pointPrimitivesToUpdateLength; ++h) {\n        const bb = pointPrimitivesToUpdate[h];\n        bb._dirty = false;\n\n        for (let o = 0; o < numWriters; ++o) {\n          writers[o](this, context, vafWriters, bb);\n        }\n        this._vaf.subCommit(bb._index, 1);\n      }\n      this._vaf.endSubCommits();\n    }\n\n    this._pointPrimitivesToUpdateIndex = 0;\n  }\n\n  // If the number of total pointPrimitives ever shrinks considerably\n  // Truncate pointPrimitivesToUpdate so that we free memory that we're\n  // not going to be using.\n  if (pointPrimitivesToUpdateLength > pointPrimitivesLength * 1.5) {\n    pointPrimitivesToUpdate.length = pointPrimitivesLength;\n  }\n\n  if (!defined(this._vaf) || !defined(this._vaf.va)) {\n    return;\n  }\n\n  if (this._boundingVolumeDirty) {\n    this._boundingVolumeDirty = false;\n    BoundingSphere.transform(\n      this._baseVolume,\n      this.modelMatrix,\n      this._baseVolumeWC\n    );\n  }\n\n  let boundingVolume;\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolumeWC,\n      this._boundingVolume\n    );\n  } else {\n    boundingVolume = BoundingSphere.clone(\n      this._baseVolume2D,\n      this._boundingVolume\n    );\n  }\n  updateBoundingVolume(this, frameState, boundingVolume);\n\n  const blendOptionChanged = this._blendOption !== this.blendOption;\n  this._blendOption = this.blendOption;\n\n  if (blendOptionChanged) {\n    if (\n      this._blendOption === BlendOption.OPAQUE ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsOpaque = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL,\n        },\n        depthMask: true,\n      });\n    } else {\n      this._rsOpaque = undefined;\n    }\n\n    if (\n      this._blendOption === BlendOption.TRANSLUCENT ||\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT\n    ) {\n      this._rsTranslucent = RenderState.fromCache({\n        depthTest: {\n          enabled: true,\n          func: WebGLConstants.LEQUAL,\n        },\n        depthMask: false,\n        blending: BlendingState.ALPHA_BLEND,\n      });\n    } else {\n      this._rsTranslucent = undefined;\n    }\n  }\n\n  this._shaderDisableDepthDistance =\n    this._shaderDisableDepthDistance ||\n    frameState.minimumDisableDepthTestDistance !== 0.0;\n  let vs;\n  let fs;\n\n  if (\n    blendOptionChanged ||\n    (this._shaderScaleByDistance && !this._compiledShaderScaleByDistance) ||\n    (this._shaderTranslucencyByDistance &&\n      !this._compiledShaderTranslucencyByDistance) ||\n    (this._shaderDistanceDisplayCondition &&\n      !this._compiledShaderDistanceDisplayCondition) ||\n    this._shaderDisableDepthDistance !==\n      this._compiledShaderDisableDepthDistance\n  ) {\n    vs = new ShaderSource({\n      sources: [PointPrimitiveCollectionVS],\n    });\n    if (this._shaderScaleByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_SCALING\");\n    }\n    if (this._shaderTranslucencyByDistance) {\n      vs.defines.push(\"EYE_DISTANCE_TRANSLUCENCY\");\n    }\n    if (this._shaderDistanceDisplayCondition) {\n      vs.defines.push(\"DISTANCE_DISPLAY_CONDITION\");\n    }\n    if (this._shaderDisableDepthDistance) {\n      vs.defines.push(\"DISABLE_DEPTH_DISTANCE\");\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {\n      fs = new ShaderSource({\n        defines: [\"OPAQUE\"],\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n\n      fs = new ShaderSource({\n        defines: [\"TRANSLUCENT\"],\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.OPAQUE) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._sp = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._sp,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    if (this._blendOption === BlendOption.TRANSLUCENT) {\n      fs = new ShaderSource({\n        sources: [PointPrimitiveCollectionFS],\n      });\n      this._spTranslucent = ShaderProgram.replaceCache({\n        context: context,\n        shaderProgram: this._spTranslucent,\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      });\n    }\n\n    this._compiledShaderScaleByDistance = this._shaderScaleByDistance;\n    this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;\n    this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;\n    this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;\n  }\n\n  let va;\n  let vaLength;\n  let command;\n  let j;\n\n  const commandList = frameState.commandList;\n\n  if (pass.render || picking) {\n    const colorList = this._colorCommands;\n\n    const opaque = this._blendOption === BlendOption.OPAQUE;\n    const opaqueAndTranslucent =\n      this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;\n\n    va = this._vaf.va;\n    vaLength = va.length;\n\n    colorList.length = vaLength;\n    const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;\n    for (j = 0; j < totalLength; ++j) {\n      const opaqueCommand = opaque || (opaqueAndTranslucent && j % 2 === 0);\n\n      command = colorList[j];\n      if (!defined(command)) {\n        command = colorList[j] = new DrawCommand();\n      }\n\n      command.primitiveType = PrimitiveType.POINTS;\n      command.pass =\n        opaqueCommand || !opaqueAndTranslucent ? Pass.OPAQUE : Pass.TRANSLUCENT;\n      command.owner = this;\n\n      const index = opaqueAndTranslucent ? Math.floor(j / 2.0) : j;\n      command.boundingVolume = boundingVolume;\n      command.modelMatrix = modelMatrix;\n      command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;\n      command.uniformMap = this._uniforms;\n      command.vertexArray = va[index].va;\n      command.renderState = opaqueCommand\n        ? this._rsOpaque\n        : this._rsTranslucent;\n      command.debugShowBoundingVolume = this.debugShowBoundingVolume;\n      command.pickId = \"v_pickColor\";\n\n      commandList.push(command);\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PointPrimitiveCollection#destroy\n */\nPointPrimitiveCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * pointPrimitives = pointPrimitives && pointPrimitives.destroy();\n *\n * @see PointPrimitiveCollection#isDestroyed\n */\nPointPrimitiveCollection.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaf = this._vaf && this._vaf.destroy();\n  destroyPointPrimitives(this._pointPrimitives);\n\n  return destroyObject(this);\n};\nexport default PointPrimitiveCollection;\n","import arrayRemoveDuplicates from \"../Core/arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PolylinePipeline from \"../Core/PolylinePipeline.js\";\nimport Material from \"./Material.js\";\n\n/**\n * A renderable polyline. Create this by calling {@link PolylineCollection#add}\n *\n * @alias Polyline\n * @internalConstructor\n * @class\n *\n * @param {Object} options Object with the following properties:\n * @param {Boolean} [options.show=true] <code>true</code> if this polyline will be shown; otherwise, <code>false</code>.\n * @param {Number} [options.width=1.0] The width of the polyline in pixels.\n * @param {Boolean} [options.loop=false] Whether a line segment will be added between the last and first line positions to make this line a loop.\n * @param {Material} [options.material=Material.ColorType] The material.\n * @param {Cartesian3[]} [options.positions] The positions.\n * @param {Object} [options.id] The user-defined object to be returned when this polyline is picked.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this polyline will be displayed.\n * @param {PolylineCollection} polylineCollection The renderable polyline collection.\n *\n * @see PolylineCollection\n *\n */\nfunction Polyline(options, polylineCollection) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._show = defaultValue(options.show, true);\n  this._width = defaultValue(options.width, 1.0);\n  this._loop = defaultValue(options.loop, false);\n  this._distanceDisplayCondition = options.distanceDisplayCondition;\n\n  this._material = options.material;\n  if (!defined(this._material)) {\n    this._material = Material.fromType(Material.ColorType, {\n      color: new Color(1.0, 1.0, 1.0, 1.0),\n    });\n  }\n\n  let positions = options.positions;\n  if (!defined(positions)) {\n    positions = [];\n  }\n\n  this._positions = positions;\n  this._actualPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n\n  if (this._loop && this._actualPositions.length > 2) {\n    if (this._actualPositions === this._positions) {\n      this._actualPositions = positions.slice();\n    }\n    this._actualPositions.push(Cartesian3.clone(this._actualPositions[0]));\n  }\n\n  this._length = this._actualPositions.length;\n  this._id = options.id;\n\n  let modelMatrix;\n  if (defined(polylineCollection)) {\n    modelMatrix = Matrix4.clone(polylineCollection.modelMatrix);\n  }\n\n  this._modelMatrix = modelMatrix;\n  this._segments = PolylinePipeline.wrapLongitude(\n    this._actualPositions,\n    modelMatrix\n  );\n\n  this._actualLength = undefined;\n\n  // eslint-disable-next-line no-use-before-define\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._polylineCollection = polylineCollection;\n  this._dirty = false;\n  this._pickId = undefined;\n  this._boundingVolume = BoundingSphere.fromPoints(this._actualPositions);\n  this._boundingVolumeWC = BoundingSphere.transform(\n    this._boundingVolume,\n    this._modelMatrix\n  );\n  this._boundingVolume2D = new BoundingSphere(); // modified in PolylineCollection\n}\n\nconst POSITION_INDEX = (Polyline.POSITION_INDEX = 0);\nconst SHOW_INDEX = (Polyline.SHOW_INDEX = 1);\nconst WIDTH_INDEX = (Polyline.WIDTH_INDEX = 2);\nconst MATERIAL_INDEX = (Polyline.MATERIAL_INDEX = 3);\nconst POSITION_SIZE_INDEX = (Polyline.POSITION_SIZE_INDEX = 4);\nconst DISTANCE_DISPLAY_CONDITION = (Polyline.DISTANCE_DISPLAY_CONDITION = 5);\nconst NUMBER_OF_PROPERTIES = (Polyline.NUMBER_OF_PROPERTIES = 6);\n\nfunction makeDirty(polyline, propertyChanged) {\n  ++polyline._propertiesChanged[propertyChanged];\n  const polylineCollection = polyline._polylineCollection;\n  if (defined(polylineCollection)) {\n    polylineCollection._updatePolyline(polyline, propertyChanged);\n    polyline._dirty = true;\n  }\n}\n\nObject.defineProperties(Polyline.prototype, {\n  /**\n   * Determines if this polyline will be shown.  Use this to hide or show a polyline, instead\n   * of removing it and re-adding it to the collection.\n   * @memberof Polyline.prototype\n   * @type {Boolean}\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (value !== this._show) {\n        this._show = value;\n        makeDirty(this, SHOW_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the positions of the polyline.\n   * @memberof Polyline.prototype\n   * @type {Cartesian3[]}\n   * @example\n   * polyline.positions = Cesium.Cartesian3.fromDegreesArray([\n   *     0.0, 0.0,\n   *     10.0, 0.0,\n   *     0.0, 20.0\n   * ]);\n   */\n  positions: {\n    get: function () {\n      return this._positions;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      let positions = arrayRemoveDuplicates(value, Cartesian3.equalsEpsilon);\n\n      if (this._loop && positions.length > 2) {\n        if (positions === value) {\n          positions = value.slice();\n        }\n        positions.push(Cartesian3.clone(positions[0]));\n      }\n\n      if (\n        this._actualPositions.length !== positions.length ||\n        this._actualPositions.length !== this._length\n      ) {\n        makeDirty(this, POSITION_SIZE_INDEX);\n      }\n\n      this._positions = value;\n      this._actualPositions = positions;\n      this._length = positions.length;\n      this._boundingVolume = BoundingSphere.fromPoints(\n        this._actualPositions,\n        this._boundingVolume\n      );\n      this._boundingVolumeWC = BoundingSphere.transform(\n        this._boundingVolume,\n        this._modelMatrix,\n        this._boundingVolumeWC\n      );\n      makeDirty(this, POSITION_INDEX);\n\n      this.update();\n    },\n  },\n\n  /**\n   * Gets or sets the surface appearance of the polyline.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * @memberof Polyline.prototype\n   * @type {Material}\n   */\n  material: {\n    get: function () {\n      return this._material;\n    },\n    set: function (material) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(material)) {\n        throw new DeveloperError(\"material is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._material !== material) {\n        this._material = material;\n        makeDirty(this, MATERIAL_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the width of the polyline.\n   * @memberof Polyline.prototype\n   * @type {Number}\n   */\n  width: {\n    get: function () {\n      return this._width;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug)\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const width = this._width;\n      if (value !== width) {\n        this._width = value;\n        makeDirty(this, WIDTH_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets whether a line segment will be added between the first and last polyline positions.\n   * @memberof Polyline.prototype\n   * @type {Boolean}\n   */\n  loop: {\n    get: function () {\n      return this._loop;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug)\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (value !== this._loop) {\n        let positions = this._actualPositions;\n        if (value) {\n          if (\n            positions.length > 2 &&\n            !Cartesian3.equals(positions[0], positions[positions.length - 1])\n          ) {\n            if (positions.length === this._positions.length) {\n              this._actualPositions = positions = this._positions.slice();\n            }\n            positions.push(Cartesian3.clone(positions[0]));\n          }\n        } else if (\n          positions.length > 2 &&\n          Cartesian3.equals(positions[0], positions[positions.length - 1])\n        ) {\n          if (positions.length - 1 === this._positions.length) {\n            this._actualPositions = this._positions;\n          } else {\n            positions.pop();\n          }\n        }\n\n        this._loop = value;\n        makeDirty(this, POSITION_SIZE_INDEX);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the user-defined value returned when the polyline is picked.\n   * @memberof Polyline.prototype\n   * @type {*}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n    set: function (value) {\n      this._id = value;\n      if (defined(this._pickId)) {\n        this._pickId.object.id = value;\n      }\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickId: {\n    get: function () {\n      return this._pickId;\n    },\n  },\n\n  /**\n   * Gets the destruction status of this polyline\n   * @memberof Polyline.prototype\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  isDestroyed: {\n    get: function () {\n      return !defined(this._polylineCollection);\n    },\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this polyline will be displayed.\n   * @memberof Polyline.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n      if (\n        !DistanceDisplayCondition.equals(value, this._distanceDisplayCondition)\n      ) {\n        this._distanceDisplayCondition = DistanceDisplayCondition.clone(\n          value,\n          this._distanceDisplayCondition\n        );\n        makeDirty(this, DISTANCE_DISPLAY_CONDITION);\n      }\n    },\n  },\n});\n\n/**\n * @private\n */\nPolyline.prototype.update = function () {\n  let modelMatrix = Matrix4.IDENTITY;\n  if (defined(this._polylineCollection)) {\n    modelMatrix = this._polylineCollection.modelMatrix;\n  }\n\n  const segmentPositionsLength = this._segments.positions.length;\n  const segmentLengths = this._segments.lengths;\n\n  const positionsChanged =\n    this._propertiesChanged[POSITION_INDEX] > 0 ||\n    this._propertiesChanged[POSITION_SIZE_INDEX] > 0;\n  if (!Matrix4.equals(modelMatrix, this._modelMatrix) || positionsChanged) {\n    this._segments = PolylinePipeline.wrapLongitude(\n      this._actualPositions,\n      modelMatrix\n    );\n    this._boundingVolumeWC = BoundingSphere.transform(\n      this._boundingVolume,\n      modelMatrix,\n      this._boundingVolumeWC\n    );\n  }\n\n  this._modelMatrix = Matrix4.clone(modelMatrix, this._modelMatrix);\n\n  if (this._segments.positions.length !== segmentPositionsLength) {\n    // number of positions changed\n    makeDirty(this, POSITION_SIZE_INDEX);\n  } else {\n    const length = segmentLengths.length;\n    for (let i = 0; i < length; ++i) {\n      if (segmentLengths[i] !== this._segments.lengths[i]) {\n        // indices changed\n        makeDirty(this, POSITION_SIZE_INDEX);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * @private\n */\nPolyline.prototype.getPickId = function (context) {\n  if (!defined(this._pickId)) {\n    this._pickId = context.createPickId({\n      primitive: this,\n      collection: this._polylineCollection,\n      id: this._id,\n    });\n  }\n  return this._pickId;\n};\n\nPolyline.prototype._clean = function () {\n  this._dirty = false;\n  const properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES - 1; ++k) {\n    properties[k] = 0;\n  }\n};\n\nPolyline.prototype._destroy = function () {\n  this._pickId = this._pickId && this._pickId.destroy();\n  this._material = this._material && this._material.destroy();\n  this._polylineCollection = undefined;\n};\nexport default Polyline;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport PolylineFS from \"../Shaders/PolylineFS.js\";\nimport PolylineVS from \"../Shaders/PolylineVS.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Material from \"./Material.js\";\nimport Polyline from \"./Polyline.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nconst SHOW_INDEX = Polyline.SHOW_INDEX;\nconst WIDTH_INDEX = Polyline.WIDTH_INDEX;\nconst POSITION_INDEX = Polyline.POSITION_INDEX;\nconst MATERIAL_INDEX = Polyline.MATERIAL_INDEX;\n//POSITION_SIZE_INDEX is needed for when the polyline's position array changes size.\n//When it does, we need to recreate the indicesBuffer.\nconst POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX;\nconst DISTANCE_DISPLAY_CONDITION = Polyline.DISTANCE_DISPLAY_CONDITION;\nconst NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;\n\nconst attributeLocations = {\n  texCoordExpandAndBatchIndex: 0,\n  position3DHigh: 1,\n  position3DLow: 2,\n  position2DHigh: 3,\n  position2DLow: 4,\n  prevPosition3DHigh: 5,\n  prevPosition3DLow: 6,\n  prevPosition2DHigh: 7,\n  prevPosition2DLow: 8,\n  nextPosition3DHigh: 9,\n  nextPosition3DLow: 10,\n  nextPosition2DHigh: 11,\n  nextPosition2DLow: 12,\n};\n\n/**\n * A renderable collection of polylines.\n * <br /><br />\n * <div align=\"center\">\n * <img src=\"Images/Polyline.png\" width=\"400\" height=\"300\" /><br />\n * Example polylines\n * </div>\n * <br /><br />\n * Polylines are added and removed from the collection using {@link PolylineCollection#add}\n * and {@link PolylineCollection#remove}.\n *\n * @alias PolylineCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each polyline from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Boolean} [options.show=true] Determines if the polylines in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many polylines, to\n * many collections with only a few polylines each.  Organize collections so that polylines\n * with the same update frequency are in the same collection, i.e., polylines that do not\n * change should be in one collection; polylines that change every frame should be in another\n * collection; and so on.\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see Polyline\n * @see LabelCollection\n *\n * @example\n * // Create a polyline collection with two polylines\n * const polylines = new Cesium.PolylineCollection();\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -75.10, 39.57,\n *     -77.02, 38.53,\n *     -80.50, 35.14,\n *     -80.12, 25.46]),\n *   width : 2\n * });\n *\n * polylines.add({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -73.10, 37.57,\n *     -75.02, 36.53,\n *     -78.50, 33.14,\n *     -78.12, 23.46]),\n *   width : 4\n * });\n */\nfunction PolylineCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * Determines if polylines in this collection will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.\n   * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   * @default {@link Matrix4.IDENTITY}\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  this._opaqueRS = undefined;\n  this._translucentRS = undefined;\n\n  this._colorCommands = [];\n\n  this._polylinesUpdated = false;\n  this._polylinesRemoved = false;\n  this._createVertexArray = false;\n  this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);\n  this._polylines = [];\n  this._polylineBuckets = {};\n\n  // The buffer usage is determined based on the usage of the attribute over time.\n  this._positionBufferUsage = {\n    bufferUsage: BufferUsage.STATIC_DRAW,\n    frameCount: 0,\n  };\n\n  this._mode = undefined;\n\n  this._polylinesToUpdate = [];\n  this._vertexArrays = [];\n  this._positionBuffer = undefined;\n  this._texCoordExpandAndBatchIndexBuffer = undefined;\n\n  this._batchTable = undefined;\n  this._createBatchTable = false;\n\n  // Only used by Vector3DTilePoints\n  this._useHighlightColor = false;\n  this._highlightColor = Color.clone(Color.WHITE);\n\n  const that = this;\n  this._uniformMap = {\n    u_highlightColor: function () {\n      return that._highlightColor;\n    },\n  };\n}\n\nObject.defineProperties(PolylineCollection.prototype, {\n  /**\n   * Returns the number of polylines in this collection.  This is commonly used with\n   * {@link PolylineCollection#get} to iterate over all the polylines\n   * in the collection.\n   * @memberof PolylineCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      removePolylines(this);\n      return this._polylines.length;\n    },\n  },\n});\n\n/**\n     * Creates and adds a polyline with the specified initial properties to the collection.\n     * The added polyline is returned so it can be modified or removed from the collection later.\n     *\n     * @param {Object}[options] A template describing the polyline's properties as shown in Example 1.\n     * @returns {Polyline} The polyline that was added to the collection.\n     *\n     * @performance After calling <code>add</code>, {@link PolylineCollection#update} is called and\n     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n     * For best performance, add as many polylines as possible before calling <code>update</code>.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * // Example 1:  Add a polyline, specifying all the default values.\n     * const p = polylines.add({\n     *   show : true,\n     *   positions : ellipsoid.cartographicArrayToCartesianArray([\n           Cesium.Cartographic.fromDegrees(-75.10, 39.57),\n           Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),\n     *   width : 1\n     * });\n     *\n     * @see PolylineCollection#remove\n     * @see PolylineCollection#removeAll\n     * @see PolylineCollection#update\n     */\nPolylineCollection.prototype.add = function (options) {\n  const p = new Polyline(options, this);\n  p._index = this._polylines.length;\n  this._polylines.push(p);\n  this._createVertexArray = true;\n  this._createBatchTable = true;\n  return p;\n};\n\n/**\n * Removes a polyline from the collection.\n *\n * @param {Polyline} polyline The polyline to remove.\n * @returns {Boolean} <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.\n *\n * @performance After calling <code>remove</code>, {@link PolylineCollection#update} is called and\n * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.\n * For best performance, remove as many polylines as possible before calling <code>update</code>.\n * If you intend to temporarily hide a polyline, it is usually more efficient to call\n * {@link Polyline#show} instead of removing and re-adding the polyline.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const p = polylines.add(...);\n * polylines.remove(p);  // Returns true\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#removeAll\n * @see PolylineCollection#update\n * @see Polyline#show\n */\nPolylineCollection.prototype.remove = function (polyline) {\n  if (this.contains(polyline)) {\n    this._polylinesRemoved = true;\n    this._createVertexArray = true;\n    this._createBatchTable = true;\n    if (defined(polyline._bucket)) {\n      const bucket = polyline._bucket;\n      bucket.shaderProgram =\n        bucket.shaderProgram && bucket.shaderProgram.destroy();\n    }\n    polyline._destroy();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all polylines from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the polylines\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines.add(...);\n * polylines.add(...);\n * polylines.removeAll();\n *\n * @see PolylineCollection#add\n * @see PolylineCollection#remove\n * @see PolylineCollection#update\n */\nPolylineCollection.prototype.removeAll = function () {\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._polylineBuckets = {};\n  this._polylinesRemoved = false;\n  this._polylines.length = 0;\n  this._polylinesToUpdate.length = 0;\n  this._createVertexArray = true;\n};\n\n/**\n * Determines if this collection contains the specified polyline.\n *\n * @param {Polyline} polyline The polyline to check for.\n * @returns {Boolean} true if this collection contains the polyline, false otherwise.\n *\n * @see PolylineCollection#get\n */\nPolylineCollection.prototype.contains = function (polyline) {\n  return defined(polyline) && polyline._polylineCollection === this;\n};\n\n/**\n * Returns the polyline in the collection at the specified index.  Indices are zero-based\n * and increase as polylines are added.  Removing a polyline shifts all polylines after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link PolylineCollection#length} to iterate over all the polylines\n * in the collection.\n *\n * @param {Number} index The zero-based index of the polyline.\n * @returns {Polyline} The polyline at the specified index.\n *\n * @performance If polylines were removed from the collection and\n * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Toggle the show property of every polyline in the collection\n * const len = polylines.length;\n * for (let i = 0; i < len; ++i) {\n *   const p = polylines.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PolylineCollection#length\n */\nPolylineCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  removePolylines(this);\n  return this._polylines[index];\n};\n\nfunction createBatchTable(collection, context) {\n  if (defined(collection._batchTable)) {\n    collection._batchTable.destroy();\n  }\n\n  const attributes = [\n    {\n      functionName: \"batchTable_getWidthAndShow\",\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 2,\n    },\n    {\n      functionName: \"batchTable_getPickColor\",\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      normalize: true,\n    },\n    {\n      functionName: \"batchTable_getCenterHigh\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n    },\n    {\n      functionName: \"batchTable_getCenterLowAndRadius\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4,\n    },\n    {\n      functionName: \"batchTable_getDistanceDisplayCondition\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n    },\n  ];\n\n  collection._batchTable = new BatchTable(\n    context,\n    attributes,\n    collection._polylines.length\n  );\n}\n\nconst scratchUpdatePolylineEncodedCartesian = new EncodedCartesian3();\nconst scratchUpdatePolylineCartesian4 = new Cartesian4();\nconst scratchNearFarCartesian2 = new Cartesian2();\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPolylineCollection.prototype.update = function (frameState) {\n  removePolylines(this);\n\n  if (this._polylines.length === 0 || !this.show) {\n    return;\n  }\n\n  updateMode(this, frameState);\n\n  const context = frameState.context;\n  const projection = frameState.mapProjection;\n  let polyline;\n  let properties = this._propertiesChanged;\n\n  if (this._createBatchTable) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\n        \"Vertex texture fetch support is required to render polylines. The maximum number of vertex texture image units must be greater than zero.\"\n      );\n    }\n    createBatchTable(this, context);\n    this._createBatchTable = false;\n  }\n\n  if (this._createVertexArray || computeNewBuffersUsage(this)) {\n    createVertexArrays(this, context, projection);\n  } else if (this._polylinesUpdated) {\n    // Polylines were modified, but no polylines were added or removed.\n    const polylinesToUpdate = this._polylinesToUpdate;\n    if (this._mode !== SceneMode.SCENE3D) {\n      const updateLength = polylinesToUpdate.length;\n      for (let i = 0; i < updateLength; ++i) {\n        polyline = polylinesToUpdate[i];\n        polyline.update();\n      }\n    }\n\n    // if a polyline's positions size changes, we need to recreate the vertex arrays and vertex buffers because the indices will be different.\n    // if a polyline's material changes, we need to recreate the VAOs and VBOs because they will be batched differently.\n    if (properties[POSITION_SIZE_INDEX] || properties[MATERIAL_INDEX]) {\n      createVertexArrays(this, context, projection);\n    } else {\n      const length = polylinesToUpdate.length;\n      const polylineBuckets = this._polylineBuckets;\n      for (let ii = 0; ii < length; ++ii) {\n        polyline = polylinesToUpdate[ii];\n        properties = polyline._propertiesChanged;\n        const bucket = polyline._bucket;\n        let index = 0;\n        for (const x in polylineBuckets) {\n          if (polylineBuckets.hasOwnProperty(x)) {\n            if (polylineBuckets[x] === bucket) {\n              if (properties[POSITION_INDEX]) {\n                bucket.writeUpdate(\n                  index,\n                  polyline,\n                  this._positionBuffer,\n                  projection\n                );\n              }\n              break;\n            }\n            index += polylineBuckets[x].lengthOfPositions;\n          }\n        }\n\n        if (properties[SHOW_INDEX] || properties[WIDTH_INDEX]) {\n          this._batchTable.setBatchedAttribute(\n            polyline._index,\n            0,\n            new Cartesian2(polyline._width, polyline._show)\n          );\n        }\n\n        if (this._batchTable.attributes.length > 2) {\n          if (properties[POSITION_INDEX] || properties[POSITION_SIZE_INDEX]) {\n            const boundingSphere =\n              frameState.mode === SceneMode.SCENE2D\n                ? polyline._boundingVolume2D\n                : polyline._boundingVolumeWC;\n            const encodedCenter = EncodedCartesian3.fromCartesian(\n              boundingSphere.center,\n              scratchUpdatePolylineEncodedCartesian\n            );\n            const low = Cartesian4.fromElements(\n              encodedCenter.low.x,\n              encodedCenter.low.y,\n              encodedCenter.low.z,\n              boundingSphere.radius,\n              scratchUpdatePolylineCartesian4\n            );\n            this._batchTable.setBatchedAttribute(\n              polyline._index,\n              2,\n              encodedCenter.high\n            );\n            this._batchTable.setBatchedAttribute(polyline._index, 3, low);\n          }\n\n          if (properties[DISTANCE_DISPLAY_CONDITION]) {\n            const nearFarCartesian = scratchNearFarCartesian2;\n            nearFarCartesian.x = 0.0;\n            nearFarCartesian.y = Number.MAX_VALUE;\n\n            const distanceDisplayCondition = polyline.distanceDisplayCondition;\n            if (defined(distanceDisplayCondition)) {\n              nearFarCartesian.x = distanceDisplayCondition.near;\n              nearFarCartesian.y = distanceDisplayCondition.far;\n            }\n\n            this._batchTable.setBatchedAttribute(\n              polyline._index,\n              4,\n              nearFarCartesian\n            );\n          }\n        }\n\n        polyline._clean();\n      }\n    }\n    polylinesToUpdate.length = 0;\n    this._polylinesUpdated = false;\n  }\n\n  properties = this._propertiesChanged;\n  for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {\n    properties[k] = 0;\n  }\n\n  let modelMatrix = Matrix4.IDENTITY;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    modelMatrix = this.modelMatrix;\n  }\n\n  const pass = frameState.passes;\n  const useDepthTest = frameState.morphTime !== 0.0;\n\n  if (\n    !defined(this._opaqueRS) ||\n    this._opaqueRS.depthTest.enabled !== useDepthTest\n  ) {\n    this._opaqueRS = RenderState.fromCache({\n      depthMask: useDepthTest,\n      depthTest: {\n        enabled: useDepthTest,\n      },\n    });\n  }\n\n  if (\n    !defined(this._translucentRS) ||\n    this._translucentRS.depthTest.enabled !== useDepthTest\n  ) {\n    this._translucentRS = RenderState.fromCache({\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: !useDepthTest,\n      depthTest: {\n        enabled: useDepthTest,\n      },\n    });\n  }\n\n  this._batchTable.update(frameState);\n\n  if (pass.render || pass.pick) {\n    const colorList = this._colorCommands;\n    createCommandLists(this, frameState, colorList, modelMatrix);\n  }\n};\n\nconst boundingSphereScratch = new BoundingSphere();\nconst boundingSphereScratch2 = new BoundingSphere();\n\nfunction createCommandLists(\n  polylineCollection,\n  frameState,\n  commands,\n  modelMatrix\n) {\n  const context = frameState.context;\n  const commandList = frameState.commandList;\n\n  const commandsLength = commands.length;\n  let commandIndex = 0;\n  let cloneBoundingSphere = true;\n\n  const vertexArrays = polylineCollection._vertexArrays;\n  const debugShowBoundingVolume = polylineCollection.debugShowBoundingVolume;\n\n  const batchTable = polylineCollection._batchTable;\n  const uniformCallback = batchTable.getUniformMapCallback();\n\n  const length = vertexArrays.length;\n  for (let m = 0; m < length; ++m) {\n    const va = vertexArrays[m];\n    const buckets = va.buckets;\n    const bucketLength = buckets.length;\n\n    for (let n = 0; n < bucketLength; ++n) {\n      const bucketLocator = buckets[n];\n\n      let offset = bucketLocator.offset;\n      const sp = bucketLocator.bucket.shaderProgram;\n\n      const polylines = bucketLocator.bucket.polylines;\n      const polylineLength = polylines.length;\n      let currentId;\n      let currentMaterial;\n      let count = 0;\n      let command;\n      let uniformMap;\n\n      for (let s = 0; s < polylineLength; ++s) {\n        const polyline = polylines[s];\n        const mId = createMaterialId(polyline._material);\n        if (mId !== currentId) {\n          if (defined(currentId) && count > 0) {\n            const translucent = currentMaterial.isTranslucent();\n\n            if (commandIndex >= commandsLength) {\n              command = new DrawCommand({\n                owner: polylineCollection,\n              });\n              commands.push(command);\n            } else {\n              command = commands[commandIndex];\n            }\n\n            ++commandIndex;\n\n            uniformMap = combine(\n              uniformCallback(currentMaterial._uniforms),\n              polylineCollection._uniformMap\n            );\n\n            command.boundingVolume = BoundingSphere.clone(\n              boundingSphereScratch,\n              command.boundingVolume\n            );\n            command.modelMatrix = modelMatrix;\n            command.shaderProgram = sp;\n            command.vertexArray = va.va;\n            command.renderState = translucent\n              ? polylineCollection._translucentRS\n              : polylineCollection._opaqueRS;\n            command.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n            command.debugShowBoundingVolume = debugShowBoundingVolume;\n            command.pickId = \"v_pickColor\";\n\n            command.uniformMap = uniformMap;\n            command.count = count;\n            command.offset = offset;\n\n            offset += count;\n            count = 0;\n            cloneBoundingSphere = true;\n\n            commandList.push(command);\n          }\n\n          currentMaterial = polyline._material;\n          currentMaterial.update(context);\n          currentId = mId;\n        }\n\n        const locators = polyline._locatorBuckets;\n        const locatorLength = locators.length;\n        for (let t = 0; t < locatorLength; ++t) {\n          const locator = locators[t];\n          if (locator.locator === bucketLocator) {\n            count += locator.count;\n          }\n        }\n\n        let boundingVolume;\n        if (frameState.mode === SceneMode.SCENE3D) {\n          boundingVolume = polyline._boundingVolumeWC;\n        } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n          boundingVolume = polyline._boundingVolume2D;\n        } else if (frameState.mode === SceneMode.SCENE2D) {\n          if (defined(polyline._boundingVolume2D)) {\n            boundingVolume = BoundingSphere.clone(\n              polyline._boundingVolume2D,\n              boundingSphereScratch2\n            );\n            boundingVolume.center.x = 0.0;\n          }\n        } else if (\n          defined(polyline._boundingVolumeWC) &&\n          defined(polyline._boundingVolume2D)\n        ) {\n          boundingVolume = BoundingSphere.union(\n            polyline._boundingVolumeWC,\n            polyline._boundingVolume2D,\n            boundingSphereScratch2\n          );\n        }\n\n        if (cloneBoundingSphere) {\n          cloneBoundingSphere = false;\n          BoundingSphere.clone(boundingVolume, boundingSphereScratch);\n        } else {\n          BoundingSphere.union(\n            boundingVolume,\n            boundingSphereScratch,\n            boundingSphereScratch\n          );\n        }\n      }\n\n      if (defined(currentId) && count > 0) {\n        if (commandIndex >= commandsLength) {\n          command = new DrawCommand({\n            owner: polylineCollection,\n          });\n          commands.push(command);\n        } else {\n          command = commands[commandIndex];\n        }\n\n        ++commandIndex;\n\n        uniformMap = combine(\n          uniformCallback(currentMaterial._uniforms),\n          polylineCollection._uniformMap\n        );\n\n        command.boundingVolume = BoundingSphere.clone(\n          boundingSphereScratch,\n          command.boundingVolume\n        );\n        command.modelMatrix = modelMatrix;\n        command.shaderProgram = sp;\n        command.vertexArray = va.va;\n        command.renderState = currentMaterial.isTranslucent()\n          ? polylineCollection._translucentRS\n          : polylineCollection._opaqueRS;\n        command.pass = currentMaterial.isTranslucent()\n          ? Pass.TRANSLUCENT\n          : Pass.OPAQUE;\n        command.debugShowBoundingVolume = debugShowBoundingVolume;\n        command.pickId = \"v_pickColor\";\n\n        command.uniformMap = uniformMap;\n        command.count = count;\n        command.offset = offset;\n\n        cloneBoundingSphere = true;\n\n        commandList.push(command);\n      }\n\n      currentId = undefined;\n    }\n  }\n\n  commands.length = commandIndex;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PolylineCollection#destroy\n */\nPolylineCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * polylines = polylines && polylines.destroy();\n *\n * @see PolylineCollection#isDestroyed\n */\nPolylineCollection.prototype.destroy = function () {\n  destroyVertexArrays(this);\n  releaseShaders(this);\n  destroyPolylines(this);\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\n\nfunction computeNewBuffersUsage(collection) {\n  let usageChanged = false;\n  const properties = collection._propertiesChanged;\n  const bufferUsage = collection._positionBufferUsage;\n  if (properties[POSITION_INDEX]) {\n    if (bufferUsage.bufferUsage !== BufferUsage.STREAM_DRAW) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STREAM_DRAW;\n      bufferUsage.frameCount = 100;\n    } else {\n      bufferUsage.frameCount = 100;\n    }\n  } else if (bufferUsage.bufferUsage !== BufferUsage.STATIC_DRAW) {\n    if (bufferUsage.frameCount === 0) {\n      usageChanged = true;\n      bufferUsage.bufferUsage = BufferUsage.STATIC_DRAW;\n    } else {\n      bufferUsage.frameCount--;\n    }\n  }\n\n  return usageChanged;\n}\n\nconst emptyVertexBuffer = [0.0, 0.0, 0.0];\n\nfunction createVertexArrays(collection, context, projection) {\n  collection._createVertexArray = false;\n  releaseShaders(collection);\n  destroyVertexArrays(collection);\n  sortPolylinesIntoBuckets(collection);\n\n  //stores all of the individual indices arrays.\n  const totalIndices = [[]];\n  let indices = totalIndices[0];\n\n  const batchTable = collection._batchTable;\n  const useHighlightColor = collection._useHighlightColor;\n\n  //used to determine the vertexBuffer offset if the indicesArray goes over 64k.\n  //if it's the same polyline while it goes over 64k, the offset needs to backtrack componentsPerAttribute * componentDatatype bytes\n  //so that the polyline looks contiguous.\n  //if the polyline ends at the 64k mark, then the offset is just 64k * componentsPerAttribute * componentDatatype\n  const vertexBufferOffset = [0];\n  let offset = 0;\n  const vertexArrayBuckets = [[]];\n  let totalLength = 0;\n  const polylineBuckets = collection._polylineBuckets;\n  let x;\n  let bucket;\n  for (x in polylineBuckets) {\n    if (polylineBuckets.hasOwnProperty(x)) {\n      bucket = polylineBuckets[x];\n      bucket.updateShader(context, batchTable, useHighlightColor);\n      totalLength += bucket.lengthOfPositions;\n    }\n  }\n\n  if (totalLength > 0) {\n    const mode = collection._mode;\n\n    const positionArray = new Float32Array(6 * totalLength * 3);\n    const texCoordExpandAndBatchIndexArray = new Float32Array(totalLength * 4);\n    let position3DArray;\n\n    let positionIndex = 0;\n    let colorIndex = 0;\n    let texCoordExpandAndBatchIndexIndex = 0;\n    for (x in polylineBuckets) {\n      if (polylineBuckets.hasOwnProperty(x)) {\n        bucket = polylineBuckets[x];\n        bucket.write(\n          positionArray,\n          texCoordExpandAndBatchIndexArray,\n          positionIndex,\n          colorIndex,\n          texCoordExpandAndBatchIndexIndex,\n          batchTable,\n          context,\n          projection\n        );\n\n        if (mode === SceneMode.MORPHING) {\n          if (!defined(position3DArray)) {\n            position3DArray = new Float32Array(6 * totalLength * 3);\n          }\n          bucket.writeForMorph(position3DArray, positionIndex);\n        }\n\n        const bucketLength = bucket.lengthOfPositions;\n        positionIndex += 6 * bucketLength * 3;\n        colorIndex += bucketLength * 4;\n        texCoordExpandAndBatchIndexIndex += bucketLength * 4;\n        offset = bucket.updateIndices(\n          totalIndices,\n          vertexBufferOffset,\n          vertexArrayBuckets,\n          offset\n        );\n      }\n    }\n\n    const positionBufferUsage = collection._positionBufferUsage.bufferUsage;\n    const texCoordExpandAndBatchIndexBufferUsage = BufferUsage.STATIC_DRAW;\n\n    collection._positionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: positionArray,\n      usage: positionBufferUsage,\n    });\n    let position3DBuffer;\n    if (defined(position3DArray)) {\n      position3DBuffer = Buffer.createVertexBuffer({\n        context: context,\n        typedArray: position3DArray,\n        usage: positionBufferUsage,\n      });\n    }\n    collection._texCoordExpandAndBatchIndexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: texCoordExpandAndBatchIndexArray,\n      usage: texCoordExpandAndBatchIndexBufferUsage,\n    });\n\n    const positionSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;\n    const texCoordExpandAndBatchIndexSizeInBytes =\n      4 * Float32Array.BYTES_PER_ELEMENT;\n\n    let vbo = 0;\n    const numberOfIndicesArrays = totalIndices.length;\n    for (let k = 0; k < numberOfIndicesArrays; ++k) {\n      indices = totalIndices[k];\n\n      if (indices.length > 0) {\n        const indicesArray = new Uint16Array(indices);\n        const indexBuffer = Buffer.createIndexBuffer({\n          context: context,\n          typedArray: indicesArray,\n          usage: BufferUsage.STATIC_DRAW,\n          indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n        });\n\n        vbo += vertexBufferOffset[k];\n\n        const positionHighOffset =\n          6 *\n          (k * (positionSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) -\n            vbo * positionSizeInBytes); //componentsPerAttribute(3) * componentDatatype(4)\n        const positionLowOffset = positionSizeInBytes + positionHighOffset;\n        const prevPositionHighOffset = positionSizeInBytes + positionLowOffset;\n        const prevPositionLowOffset =\n          positionSizeInBytes + prevPositionHighOffset;\n        const nextPositionHighOffset =\n          positionSizeInBytes + prevPositionLowOffset;\n        const nextPositionLowOffset =\n          positionSizeInBytes + nextPositionHighOffset;\n        const vertexTexCoordExpandAndBatchIndexBufferOffset =\n          k *\n            (texCoordExpandAndBatchIndexSizeInBytes *\n              CesiumMath.SIXTY_FOUR_KILOBYTES) -\n          vbo * texCoordExpandAndBatchIndexSizeInBytes;\n\n        const attributes = [\n          {\n            index: attributeLocations.position3DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.position3DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.position2DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.position2DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: positionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition3DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition3DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition2DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.prevPosition2DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: prevPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition3DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition3DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition2DHigh,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionHighOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.nextPosition2DLow,\n            componentsPerAttribute: 3,\n            componentDatatype: ComponentDatatype.FLOAT,\n            offsetInBytes: nextPositionLowOffset,\n            strideInBytes: 6 * positionSizeInBytes,\n          },\n          {\n            index: attributeLocations.texCoordExpandAndBatchIndex,\n            componentsPerAttribute: 4,\n            componentDatatype: ComponentDatatype.FLOAT,\n            vertexBuffer: collection._texCoordExpandAndBatchIndexBuffer,\n            offsetInBytes: vertexTexCoordExpandAndBatchIndexBufferOffset,\n          },\n        ];\n\n        let bufferProperty3D;\n        let buffer3D;\n        let buffer2D;\n        let bufferProperty2D;\n\n        if (mode === SceneMode.SCENE3D) {\n          buffer3D = collection._positionBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = emptyVertexBuffer;\n          bufferProperty2D = \"value\";\n        } else if (\n          mode === SceneMode.SCENE2D ||\n          mode === SceneMode.COLUMBUS_VIEW\n        ) {\n          buffer3D = emptyVertexBuffer;\n          bufferProperty3D = \"value\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        } else {\n          buffer3D = position3DBuffer;\n          bufferProperty3D = \"vertexBuffer\";\n          buffer2D = collection._positionBuffer;\n          bufferProperty2D = \"vertexBuffer\";\n        }\n\n        attributes[0][bufferProperty3D] = buffer3D;\n        attributes[1][bufferProperty3D] = buffer3D;\n        attributes[2][bufferProperty2D] = buffer2D;\n        attributes[3][bufferProperty2D] = buffer2D;\n        attributes[4][bufferProperty3D] = buffer3D;\n        attributes[5][bufferProperty3D] = buffer3D;\n        attributes[6][bufferProperty2D] = buffer2D;\n        attributes[7][bufferProperty2D] = buffer2D;\n        attributes[8][bufferProperty3D] = buffer3D;\n        attributes[9][bufferProperty3D] = buffer3D;\n        attributes[10][bufferProperty2D] = buffer2D;\n        attributes[11][bufferProperty2D] = buffer2D;\n\n        const va = new VertexArray({\n          context: context,\n          attributes: attributes,\n          indexBuffer: indexBuffer,\n        });\n        collection._vertexArrays.push({\n          va: va,\n          buckets: vertexArrayBuckets[k],\n        });\n      }\n    }\n  }\n}\n\nfunction replacer(key, value) {\n  if (value instanceof Texture) {\n    return value.id;\n  }\n\n  return value;\n}\n\nconst scratchUniformArray = [];\nfunction createMaterialId(material) {\n  const uniforms = Material._uniformList[material.type];\n  const length = uniforms.length;\n  scratchUniformArray.length = 2.0 * length;\n\n  let index = 0;\n  for (let i = 0; i < length; ++i) {\n    const uniform = uniforms[i];\n    scratchUniformArray[index] = uniform;\n    scratchUniformArray[index + 1] = material._uniforms[uniform]();\n    index += 2;\n  }\n\n  return `${material.type}:${JSON.stringify(scratchUniformArray, replacer)}`;\n}\n\nfunction sortPolylinesIntoBuckets(collection) {\n  const mode = collection._mode;\n  const modelMatrix = collection._modelMatrix;\n\n  const polylineBuckets = (collection._polylineBuckets = {});\n  const polylines = collection._polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const p = polylines[i];\n    if (p._actualPositions.length > 1) {\n      p.update();\n      const material = p.material;\n      let value = polylineBuckets[material.type];\n      if (!defined(value)) {\n        value = polylineBuckets[material.type] = new PolylineBucket(\n          material,\n          mode,\n          modelMatrix\n        );\n      }\n      value.addPolyline(p);\n    }\n  }\n}\n\nfunction updateMode(collection, frameState) {\n  const mode = frameState.mode;\n\n  if (\n    collection._mode !== mode ||\n    !Matrix4.equals(collection._modelMatrix, collection.modelMatrix)\n  ) {\n    collection._mode = mode;\n    collection._modelMatrix = Matrix4.clone(collection.modelMatrix);\n    collection._createVertexArray = true;\n  }\n}\n\nfunction removePolylines(collection) {\n  if (collection._polylinesRemoved) {\n    collection._polylinesRemoved = false;\n    const definedPolylines = [];\n    const definedPolylinesToUpdate = [];\n    let polyIndex = 0;\n    let polyline;\n\n    const length = collection._polylines.length;\n    for (let i = 0; i < length; ++i) {\n      polyline = collection._polylines[i];\n      if (!polyline.isDestroyed) {\n        polyline._index = polyIndex++;\n        definedPolylinesToUpdate.push(polyline);\n        definedPolylines.push(polyline);\n      }\n    }\n\n    collection._polylines = definedPolylines;\n    collection._polylinesToUpdate = definedPolylinesToUpdate;\n  }\n}\n\nfunction releaseShaders(collection) {\n  const polylines = collection._polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      const bucket = polylines[i]._bucket;\n      if (defined(bucket)) {\n        bucket.shaderProgram =\n          bucket.shaderProgram && bucket.shaderProgram.destroy();\n      }\n    }\n  }\n}\n\nfunction destroyVertexArrays(collection) {\n  const length = collection._vertexArrays.length;\n  for (let t = 0; t < length; ++t) {\n    collection._vertexArrays[t].va.destroy();\n  }\n  collection._vertexArrays.length = 0;\n}\n\nPolylineCollection.prototype._updatePolyline = function (\n  polyline,\n  propertyChanged\n) {\n  this._polylinesUpdated = true;\n  if (!polyline._dirty) {\n    this._polylinesToUpdate.push(polyline);\n  }\n  ++this._propertiesChanged[propertyChanged];\n};\n\nfunction destroyPolylines(collection) {\n  const polylines = collection._polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    if (!polylines[i].isDestroyed) {\n      polylines[i]._destroy();\n    }\n  }\n}\n\nfunction VertexArrayBucketLocator(count, offset, bucket) {\n  this.count = count;\n  this.offset = offset;\n  this.bucket = bucket;\n}\n\nfunction PolylineBucket(material, mode, modelMatrix) {\n  this.polylines = [];\n  this.lengthOfPositions = 0;\n  this.material = material;\n  this.shaderProgram = undefined;\n  this.mode = mode;\n  this.modelMatrix = modelMatrix;\n}\n\nPolylineBucket.prototype.addPolyline = function (p) {\n  const polylines = this.polylines;\n  polylines.push(p);\n  p._actualLength = this.getPolylinePositionsLength(p);\n  this.lengthOfPositions += p._actualLength;\n  p._bucket = this;\n};\n\nPolylineBucket.prototype.updateShader = function (\n  context,\n  batchTable,\n  useHighlightColor\n) {\n  if (defined(this.shaderProgram)) {\n    return;\n  }\n\n  const defines = [\"DISTANCE_DISPLAY_CONDITION\"];\n  if (useHighlightColor) {\n    defines.push(\"VECTOR_TILE\");\n  }\n\n  // Check for use of v_polylineAngle in material shader\n  if (\n    this.material.shaderSource.search(/varying\\s+float\\s+v_polylineAngle;/g) !==\n    -1\n  ) {\n    defines.push(\"POLYLINE_DASH\");\n  }\n\n  if (!FeatureDetection.isInternetExplorer()) {\n    defines.push(\"CLIP_POLYLINE\");\n  }\n\n  const fs = new ShaderSource({\n    defines: defines,\n    sources: [\n      \"varying vec4 v_pickColor;\\n\",\n      this.material.shaderSource,\n      PolylineFS,\n    ],\n  });\n\n  const vsSource = batchTable.getVertexShaderCallback()(PolylineVS);\n  const vs = new ShaderSource({\n    defines: defines,\n    sources: [PolylineCommon, vsSource],\n  });\n\n  this.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n};\n\nfunction intersectsIDL(polyline) {\n  return (\n    Cartesian3.dot(Cartesian3.UNIT_X, polyline._boundingVolume.center) < 0 ||\n    polyline._boundingVolume.intersectPlane(Plane.ORIGIN_ZX_PLANE) ===\n      Intersect.INTERSECTING\n  );\n}\n\nPolylineBucket.prototype.getPolylinePositionsLength = function (polyline) {\n  let length;\n  if (this.mode === SceneMode.SCENE3D || !intersectsIDL(polyline)) {\n    length = polyline._actualPositions.length;\n    return length * 4.0 - 4.0;\n  }\n\n  let count = 0;\n  const segmentLengths = polyline._segments.lengths;\n  length = segmentLengths.length;\n  for (let i = 0; i < length; ++i) {\n    count += segmentLengths[i] * 4.0 - 4.0;\n  }\n\n  return count;\n};\n\nconst scratchWritePosition = new Cartesian3();\nconst scratchWritePrevPosition = new Cartesian3();\nconst scratchWriteNextPosition = new Cartesian3();\nconst scratchWriteVector = new Cartesian3();\nconst scratchPickColorCartesian = new Cartesian4();\nconst scratchWidthShowCartesian = new Cartesian2();\n\nPolylineBucket.prototype.write = function (\n  positionArray,\n  texCoordExpandAndBatchIndexArray,\n  positionIndex,\n  colorIndex,\n  texCoordExpandAndBatchIndexIndex,\n  batchTable,\n  context,\n  projection\n) {\n  const mode = this.mode;\n  const maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n  const polylines = this.polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const polyline = polylines[i];\n    const width = polyline.width;\n    const show = polyline.show && width > 0.0;\n    const polylineBatchIndex = polyline._index;\n    const segments = this.getSegments(polyline, projection);\n    const positions = segments.positions;\n    const lengths = segments.lengths;\n    const positionsLength = positions.length;\n\n    const pickColor = polyline.getPickId(context).color;\n\n    let segmentIndex = 0;\n    let count = 0;\n    let position;\n\n    for (let j = 0; j < positionsLength; ++j) {\n      if (j === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[j - 1];\n      }\n\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[j], scratchWritePosition);\n\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(\n            positions[positionsLength - 1],\n            positions[positionsLength - 2],\n            position\n          );\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[j + 1];\n      }\n\n      Cartesian3.clone(position, scratchWriteNextPosition);\n\n      const segmentLength = lengths[segmentIndex];\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      const segmentStart = j - count === 0;\n      const segmentEnd = j === count + lengths[segmentIndex] - 1;\n\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if (\n          (segmentStart || segmentEnd) &&\n          maxLon - Math.abs(scratchWritePosition.x) < 1.0\n        ) {\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWritePrevPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWriteNextPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n\n      const startK = segmentStart ? 2 : 0;\n      const endK = segmentEnd ? 2 : 4;\n\n      for (let k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(\n          scratchWritePosition,\n          positionArray,\n          positionIndex\n        );\n        EncodedCartesian3.writeElements(\n          scratchWritePrevPosition,\n          positionArray,\n          positionIndex + 6\n        );\n        EncodedCartesian3.writeElements(\n          scratchWriteNextPosition,\n          positionArray,\n          positionIndex + 12\n        );\n\n        const direction = k - 2 < 0 ? -1.0 : 1.0;\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex] =\n          j / (positionsLength - 1); // s tex coord\n        texCoordExpandAndBatchIndexArray[texCoordExpandAndBatchIndexIndex + 1] =\n          2 * (k % 2) - 1; // expand direction\n        texCoordExpandAndBatchIndexArray[\n          texCoordExpandAndBatchIndexIndex + 2\n        ] = direction;\n        texCoordExpandAndBatchIndexArray[\n          texCoordExpandAndBatchIndexIndex + 3\n        ] = polylineBatchIndex;\n\n        positionIndex += 6 * 3;\n        texCoordExpandAndBatchIndexIndex += 4;\n      }\n    }\n\n    const colorCartesian = scratchPickColorCartesian;\n    colorCartesian.x = Color.floatToByte(pickColor.red);\n    colorCartesian.y = Color.floatToByte(pickColor.green);\n    colorCartesian.z = Color.floatToByte(pickColor.blue);\n    colorCartesian.w = Color.floatToByte(pickColor.alpha);\n\n    const widthShowCartesian = scratchWidthShowCartesian;\n    widthShowCartesian.x = width;\n    widthShowCartesian.y = show ? 1.0 : 0.0;\n\n    const boundingSphere =\n      mode === SceneMode.SCENE2D\n        ? polyline._boundingVolume2D\n        : polyline._boundingVolumeWC;\n    const encodedCenter = EncodedCartesian3.fromCartesian(\n      boundingSphere.center,\n      scratchUpdatePolylineEncodedCartesian\n    );\n    const high = encodedCenter.high;\n    const low = Cartesian4.fromElements(\n      encodedCenter.low.x,\n      encodedCenter.low.y,\n      encodedCenter.low.z,\n      boundingSphere.radius,\n      scratchUpdatePolylineCartesian4\n    );\n\n    const nearFarCartesian = scratchNearFarCartesian2;\n    nearFarCartesian.x = 0.0;\n    nearFarCartesian.y = Number.MAX_VALUE;\n\n    const distanceDisplayCondition = polyline.distanceDisplayCondition;\n    if (defined(distanceDisplayCondition)) {\n      nearFarCartesian.x = distanceDisplayCondition.near;\n      nearFarCartesian.y = distanceDisplayCondition.far;\n    }\n\n    batchTable.setBatchedAttribute(polylineBatchIndex, 0, widthShowCartesian);\n    batchTable.setBatchedAttribute(polylineBatchIndex, 1, colorCartesian);\n\n    if (batchTable.attributes.length > 2) {\n      batchTable.setBatchedAttribute(polylineBatchIndex, 2, high);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 3, low);\n      batchTable.setBatchedAttribute(polylineBatchIndex, 4, nearFarCartesian);\n    }\n  }\n};\n\nconst morphPositionScratch = new Cartesian3();\nconst morphPrevPositionScratch = new Cartesian3();\nconst morphNextPositionScratch = new Cartesian3();\nconst morphVectorScratch = new Cartesian3();\n\nPolylineBucket.prototype.writeForMorph = function (\n  positionArray,\n  positionIndex\n) {\n  const modelMatrix = this.modelMatrix;\n  const polylines = this.polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const polyline = polylines[i];\n    const positions = polyline._segments.positions;\n    const lengths = polyline._segments.lengths;\n    const positionsLength = positions.length;\n\n    let segmentIndex = 0;\n    let count = 0;\n\n    for (let j = 0; j < positionsLength; ++j) {\n      let prevPosition;\n      if (j === 0) {\n        if (polyline._loop) {\n          prevPosition = positions[positionsLength - 2];\n        } else {\n          prevPosition = morphVectorScratch;\n          Cartesian3.subtract(positions[0], positions[1], prevPosition);\n          Cartesian3.add(positions[0], prevPosition, prevPosition);\n        }\n      } else {\n        prevPosition = positions[j - 1];\n      }\n\n      prevPosition = Matrix4.multiplyByPoint(\n        modelMatrix,\n        prevPosition,\n        morphPrevPositionScratch\n      );\n\n      const position = Matrix4.multiplyByPoint(\n        modelMatrix,\n        positions[j],\n        morphPositionScratch\n      );\n\n      let nextPosition;\n      if (j === positionsLength - 1) {\n        if (polyline._loop) {\n          nextPosition = positions[1];\n        } else {\n          nextPosition = morphVectorScratch;\n          Cartesian3.subtract(\n            positions[positionsLength - 1],\n            positions[positionsLength - 2],\n            nextPosition\n          );\n          Cartesian3.add(\n            positions[positionsLength - 1],\n            nextPosition,\n            nextPosition\n          );\n        }\n      } else {\n        nextPosition = positions[j + 1];\n      }\n\n      nextPosition = Matrix4.multiplyByPoint(\n        modelMatrix,\n        nextPosition,\n        morphNextPositionScratch\n      );\n\n      const segmentLength = lengths[segmentIndex];\n      if (j === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      const segmentStart = j - count === 0;\n      const segmentEnd = j === count + lengths[segmentIndex] - 1;\n\n      const startK = segmentStart ? 2 : 0;\n      const endK = segmentEnd ? 2 : 4;\n\n      for (let k = startK; k < endK; ++k) {\n        EncodedCartesian3.writeElements(position, positionArray, positionIndex);\n        EncodedCartesian3.writeElements(\n          prevPosition,\n          positionArray,\n          positionIndex + 6\n        );\n        EncodedCartesian3.writeElements(\n          nextPosition,\n          positionArray,\n          positionIndex + 12\n        );\n\n        positionIndex += 6 * 3;\n      }\n    }\n  }\n};\n\nconst scratchSegmentLengths = new Array(1);\n\nPolylineBucket.prototype.updateIndices = function (\n  totalIndices,\n  vertexBufferOffset,\n  vertexArrayBuckets,\n  offset\n) {\n  let vaCount = vertexArrayBuckets.length - 1;\n  let bucketLocator = new VertexArrayBucketLocator(0, offset, this);\n  vertexArrayBuckets[vaCount].push(bucketLocator);\n  let count = 0;\n  let indices = totalIndices[totalIndices.length - 1];\n  let indicesCount = 0;\n  if (indices.length > 0) {\n    indicesCount = indices[indices.length - 1] + 1;\n  }\n  const polylines = this.polylines;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const polyline = polylines[i];\n    polyline._locatorBuckets = [];\n\n    let segments;\n    if (this.mode === SceneMode.SCENE3D) {\n      segments = scratchSegmentLengths;\n      const positionsLength = polyline._actualPositions.length;\n      if (positionsLength > 0) {\n        segments[0] = positionsLength;\n      } else {\n        continue;\n      }\n    } else {\n      segments = polyline._segments.lengths;\n    }\n\n    const numberOfSegments = segments.length;\n    if (numberOfSegments > 0) {\n      let segmentIndexCount = 0;\n      for (let j = 0; j < numberOfSegments; ++j) {\n        const segmentLength = segments[j] - 1.0;\n        for (let k = 0; k < segmentLength; ++k) {\n          if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n            polyline._locatorBuckets.push({\n              locator: bucketLocator,\n              count: segmentIndexCount,\n            });\n            segmentIndexCount = 0;\n            vertexBufferOffset.push(4);\n            indices = [];\n            totalIndices.push(indices);\n            indicesCount = 0;\n            bucketLocator.count = count;\n            count = 0;\n            offset = 0;\n            bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n            vertexArrayBuckets[++vaCount] = [bucketLocator];\n          }\n\n          indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\n          indices.push(indicesCount + 1, indicesCount + 2, indicesCount + 3);\n\n          segmentIndexCount += 6;\n          count += 6;\n          offset += 6;\n          indicesCount += 4;\n        }\n      }\n\n      polyline._locatorBuckets.push({\n        locator: bucketLocator,\n        count: segmentIndexCount,\n      });\n\n      if (indicesCount + 4 > CesiumMath.SIXTY_FOUR_KILOBYTES) {\n        vertexBufferOffset.push(0);\n        indices = [];\n        totalIndices.push(indices);\n        indicesCount = 0;\n        bucketLocator.count = count;\n        offset = 0;\n        count = 0;\n        bucketLocator = new VertexArrayBucketLocator(0, 0, this);\n        vertexArrayBuckets[++vaCount] = [bucketLocator];\n      }\n    }\n    polyline._clean();\n  }\n  bucketLocator.count = count;\n  return offset;\n};\n\nPolylineBucket.prototype.getPolylineStartIndex = function (polyline) {\n  const polylines = this.polylines;\n  let positionIndex = 0;\n  const length = polylines.length;\n  for (let i = 0; i < length; ++i) {\n    const p = polylines[i];\n    if (p === polyline) {\n      break;\n    }\n    positionIndex += p._actualLength;\n  }\n  return positionIndex;\n};\n\nconst scratchSegments = {\n  positions: undefined,\n  lengths: undefined,\n};\nconst scratchLengths = new Array(1);\nconst pscratch = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n\nPolylineBucket.prototype.getSegments = function (polyline, projection) {\n  let positions = polyline._actualPositions;\n\n  if (this.mode === SceneMode.SCENE3D) {\n    scratchLengths[0] = positions.length;\n    scratchSegments.positions = positions;\n    scratchSegments.lengths = scratchLengths;\n    return scratchSegments;\n  }\n\n  if (intersectsIDL(polyline)) {\n    positions = polyline._segments.positions;\n  }\n\n  const ellipsoid = projection.ellipsoid;\n  const newPositions = [];\n  const modelMatrix = this.modelMatrix;\n  const length = positions.length;\n  let position;\n  let p = pscratch;\n\n  for (let n = 0; n < length; ++n) {\n    position = positions[n];\n    p = Matrix4.multiplyByPoint(modelMatrix, position, p);\n    newPositions.push(\n      projection.project(\n        ellipsoid.cartesianToCartographic(p, scratchCartographic)\n      )\n    );\n  }\n\n  if (newPositions.length > 0) {\n    polyline._boundingVolume2D = BoundingSphere.fromPoints(\n      newPositions,\n      polyline._boundingVolume2D\n    );\n    const center2D = polyline._boundingVolume2D.center;\n    polyline._boundingVolume2D.center = new Cartesian3(\n      center2D.z,\n      center2D.x,\n      center2D.y\n    );\n  }\n\n  scratchSegments.positions = newPositions;\n  scratchSegments.lengths = polyline._segments.lengths;\n  return scratchSegments;\n};\n\nlet scratchPositionsArray;\n\nPolylineBucket.prototype.writeUpdate = function (\n  index,\n  polyline,\n  positionBuffer,\n  projection\n) {\n  const mode = this.mode;\n  const maxLon = projection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n  let positionsLength = polyline._actualLength;\n  if (positionsLength) {\n    index += this.getPolylineStartIndex(polyline);\n\n    let positionArray = scratchPositionsArray;\n    const positionsArrayLength = 6 * positionsLength * 3;\n\n    if (\n      !defined(positionArray) ||\n      positionArray.length < positionsArrayLength\n    ) {\n      positionArray = scratchPositionsArray = new Float32Array(\n        positionsArrayLength\n      );\n    } else if (positionArray.length > positionsArrayLength) {\n      positionArray = new Float32Array(\n        positionArray.buffer,\n        0,\n        positionsArrayLength\n      );\n    }\n\n    const segments = this.getSegments(polyline, projection);\n    const positions = segments.positions;\n    const lengths = segments.lengths;\n\n    let positionIndex = 0;\n    let segmentIndex = 0;\n    let count = 0;\n    let position;\n\n    positionsLength = positions.length;\n    for (let i = 0; i < positionsLength; ++i) {\n      if (i === 0) {\n        if (polyline._loop) {\n          position = positions[positionsLength - 2];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(positions[0], positions[1], position);\n          Cartesian3.add(positions[0], position, position);\n        }\n      } else {\n        position = positions[i - 1];\n      }\n\n      Cartesian3.clone(position, scratchWritePrevPosition);\n      Cartesian3.clone(positions[i], scratchWritePosition);\n\n      if (i === positionsLength - 1) {\n        if (polyline._loop) {\n          position = positions[1];\n        } else {\n          position = scratchWriteVector;\n          Cartesian3.subtract(\n            positions[positionsLength - 1],\n            positions[positionsLength - 2],\n            position\n          );\n          Cartesian3.add(positions[positionsLength - 1], position, position);\n        }\n      } else {\n        position = positions[i + 1];\n      }\n\n      Cartesian3.clone(position, scratchWriteNextPosition);\n\n      const segmentLength = lengths[segmentIndex];\n      if (i === count + segmentLength) {\n        count += segmentLength;\n        ++segmentIndex;\n      }\n\n      const segmentStart = i - count === 0;\n      const segmentEnd = i === count + lengths[segmentIndex] - 1;\n\n      if (mode === SceneMode.SCENE2D) {\n        scratchWritePrevPosition.z = 0.0;\n        scratchWritePosition.z = 0.0;\n        scratchWriteNextPosition.z = 0.0;\n      }\n\n      if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n        if (\n          (segmentStart || segmentEnd) &&\n          maxLon - Math.abs(scratchWritePosition.x) < 1.0\n        ) {\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWritePrevPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWritePrevPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWritePrevPosition);\n          }\n\n          if (\n            (scratchWritePosition.x < 0.0 &&\n              scratchWriteNextPosition.x > 0.0) ||\n            (scratchWritePosition.x > 0.0 && scratchWriteNextPosition.x < 0.0)\n          ) {\n            Cartesian3.clone(scratchWritePosition, scratchWriteNextPosition);\n          }\n        }\n      }\n\n      const startJ = segmentStart ? 2 : 0;\n      const endJ = segmentEnd ? 2 : 4;\n\n      for (let j = startJ; j < endJ; ++j) {\n        EncodedCartesian3.writeElements(\n          scratchWritePosition,\n          positionArray,\n          positionIndex\n        );\n        EncodedCartesian3.writeElements(\n          scratchWritePrevPosition,\n          positionArray,\n          positionIndex + 6\n        );\n        EncodedCartesian3.writeElements(\n          scratchWriteNextPosition,\n          positionArray,\n          positionIndex + 12\n        );\n        positionIndex += 6 * 3;\n      }\n    }\n\n    positionBuffer.copyFromArrayView(\n      positionArray,\n      6 * 3 * Float32Array.BYTES_PER_ELEMENT * index\n    );\n  }\n};\nexport default PolylineCollection;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport PerInstanceFlatColorAppearanceFS from \"../Shaders/Appearances/PerInstanceFlatColorAppearanceFS.js\";\nimport PolylineColorAppearanceVS from \"../Shaders/Appearances/PolylineColorAppearanceVS.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport Appearance from \"./Appearance.js\";\n\nlet defaultVertexShaderSource = `${PolylineCommon}\\n${PolylineColorAppearanceVS}`;\nconst defaultFragmentShaderSource = PerInstanceFlatColorAppearanceFS;\n\nif (!FeatureDetection.isInternetExplorer()) {\n  defaultVertexShaderSource = `#define CLIP_POLYLINE \\n${defaultVertexShaderSource}`;\n}\n\n/**\n * An appearance for {@link GeometryInstance} instances with color attributes and\n * {@link PolylineGeometry} or {@link GroundPolylineGeometry}.\n * This allows several geometry instances, each with a different color, to\n * be drawn with the same {@link Primitive}.\n *\n * @alias PolylineColorAppearance\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineColorAppearance#renderState} has alpha blending enabled.\n * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n * @param {Object} [options.renderState] Optional render state to override the default render state.\n *\n * @example\n * // A solid white line segment\n * const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.PolylineGeometry({\n *       positions : Cesium.Cartesian3.fromDegreesArray([\n *         0.0, 0.0,\n *         5.0, 0.0\n *       ]),\n *       width : 10.0,\n *       vertexFormat : Cesium.PolylineColorAppearance.VERTEX_FORMAT\n *     }),\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))\n *     }\n *   }),\n *   appearance : new Cesium.PolylineColorAppearance({\n *     translucent : false\n *   })\n * });\n */\nfunction PolylineColorAppearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const translucent = defaultValue(options.translucent, true);\n  const closed = false;\n  const vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;\n\n  /**\n   * This property is part of the {@link Appearance} interface, but is not\n   * used by {@link PolylineColorAppearance} since a fully custom fragment shader is used.\n   *\n   * @type Material\n   *\n   * @default undefined\n   */\n  this.material = undefined;\n\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent so\n   * {@link PolylineColorAppearance#renderState} has alpha blending enabled.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.translucent = translucent;\n\n  this._vertexShaderSource = defaultValue(\n    options.vertexShaderSource,\n    defaultVertexShaderSource\n  );\n  this._fragmentShaderSource = defaultValue(\n    options.fragmentShaderSource,\n    defaultFragmentShaderSource\n  );\n  this._renderState = Appearance.getDefaultRenderState(\n    translucent,\n    closed,\n    options.renderState\n  );\n  this._closed = closed;\n\n  // Non-derived members\n\n  this._vertexFormat = vertexFormat;\n}\n\nObject.defineProperties(PolylineColorAppearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof PolylineColorAppearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    },\n  },\n\n  /**\n   * The GLSL source code for the fragment shader.\n   *\n   * @memberof PolylineColorAppearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   * <p>\n   * The render state can be explicitly defined when constructing a {@link PolylineColorAppearance}\n   * instance, or it is set implicitly via {@link PolylineColorAppearance#translucent}.\n   * </p>\n   *\n   * @memberof PolylineColorAppearance.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be closed so\n   * {@link PolylineColorAppearance#renderState} has backface culling enabled.\n   * This is always <code>false</code> for <code>PolylineColorAppearance</code>.\n   *\n   * @memberof PolylineColorAppearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    },\n  },\n\n  /**\n   * The {@link VertexFormat} that this appearance instance is compatible with.\n   * A geometry can have more vertex attributes and still be compatible - at a\n   * potential performance cost - but it can't have less.\n   *\n   * @memberof PolylineColorAppearance.prototype\n   *\n   * @type VertexFormat\n   * @readonly\n   *\n   * @default {@link PolylineColorAppearance.VERTEX_FORMAT}\n   */\n  vertexFormat: {\n    get: function () {\n      return this._vertexFormat;\n    },\n  },\n});\n\n/**\n * The {@link VertexFormat} that all {@link PolylineColorAppearance} instances\n * are compatible with. This requires only a <code>position</code> attribute.\n *\n * @type VertexFormat\n *\n * @constant\n */\nPolylineColorAppearance.VERTEX_FORMAT = VertexFormat.POSITION_ONLY;\n\n/**\n * Procedurally creates the full GLSL fragment shader source.\n *\n * @function\n *\n * @returns {String} The full GLSL fragment shader source.\n */\nPolylineColorAppearance.prototype.getFragmentShaderSource =\n  Appearance.prototype.getFragmentShaderSource;\n\n/**\n * Determines if the geometry is translucent based on {@link PolylineColorAppearance#translucent}.\n *\n * @function\n *\n * @returns {Boolean} <code>true</code> if the appearance is translucent.\n */\nPolylineColorAppearance.prototype.isTranslucent =\n  Appearance.prototype.isTranslucent;\n\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @function\n *\n * @returns {Object} The render state.\n */\nPolylineColorAppearance.prototype.getRenderState =\n  Appearance.prototype.getRenderState;\nexport default PolylineColorAppearance;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport PolylineMaterialAppearanceVS from \"../Shaders/Appearances/PolylineMaterialAppearanceVS.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport PolylineFS from \"../Shaders/PolylineFS.js\";\nimport Appearance from \"./Appearance.js\";\nimport Material from \"./Material.js\";\n\nlet defaultVertexShaderSource = `${PolylineCommon}\\n${PolylineMaterialAppearanceVS}`;\nconst defaultFragmentShaderSource = PolylineFS;\n\nif (!FeatureDetection.isInternetExplorer()) {\n  defaultVertexShaderSource = `#define CLIP_POLYLINE \\n${defaultVertexShaderSource}`;\n}\n\n/**\n * An appearance for {@link PolylineGeometry} that supports shading with materials.\n *\n * @alias PolylineMaterialAppearance\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineMaterialAppearance#renderState} has alpha blending enabled.\n * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n * @param {Object} [options.renderState] Optional render state to override the default render state.\n *\n * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n *\n * @example\n * const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.PolylineGeometry({\n *       positions : Cesium.Cartesian3.fromDegreesArray([\n *         0.0, 0.0,\n *         5.0, 0.0\n *       ]),\n *       width : 10.0,\n *       vertexFormat : Cesium.PolylineMaterialAppearance.VERTEX_FORMAT\n *     })\n *   }),\n *   appearance : new Cesium.PolylineMaterialAppearance({\n *     material : Cesium.Material.fromType('Color')\n *   })\n * });\n */\nfunction PolylineMaterialAppearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const translucent = defaultValue(options.translucent, true);\n  const closed = false;\n  const vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;\n\n  /**\n   * The material used to determine the fragment color.  Unlike other {@link PolylineMaterialAppearance}\n   * properties, this is not read-only, so an appearance's material can change on the fly.\n   *\n   * @type Material\n   *\n   * @default {@link Material.ColorType}\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n  this.material = defined(options.material)\n    ? options.material\n    : Material.fromType(Material.ColorType);\n\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent so\n   * {@link PolylineMaterialAppearance#renderState} has alpha blending enabled.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.translucent = translucent;\n\n  this._vertexShaderSource = defaultValue(\n    options.vertexShaderSource,\n    defaultVertexShaderSource\n  );\n  this._fragmentShaderSource = defaultValue(\n    options.fragmentShaderSource,\n    defaultFragmentShaderSource\n  );\n  this._renderState = Appearance.getDefaultRenderState(\n    translucent,\n    closed,\n    options.renderState\n  );\n  this._closed = closed;\n\n  // Non-derived members\n\n  this._vertexFormat = vertexFormat;\n}\n\nObject.defineProperties(PolylineMaterialAppearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof PolylineMaterialAppearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      let vs = this._vertexShaderSource;\n      if (\n        this.material.shaderSource.search(\n          /varying\\s+float\\s+v_polylineAngle;/g\n        ) !== -1\n      ) {\n        vs = `#define POLYLINE_DASH\\n${vs}`;\n      }\n      return vs;\n    },\n  },\n\n  /**\n   * The GLSL source code for the fragment shader.\n   *\n   * @memberof PolylineMaterialAppearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   * <p>\n   * The render state can be explicitly defined when constructing a {@link PolylineMaterialAppearance}\n   * instance, or it is set implicitly via {@link PolylineMaterialAppearance#translucent}\n   * and {@link PolylineMaterialAppearance#closed}.\n   * </p>\n   *\n   * @memberof PolylineMaterialAppearance.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be closed so\n   * {@link PolylineMaterialAppearance#renderState} has backface culling enabled.\n   * This is always <code>false</code> for <code>PolylineMaterialAppearance</code>.\n   *\n   * @memberof PolylineMaterialAppearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    },\n  },\n\n  /**\n   * The {@link VertexFormat} that this appearance instance is compatible with.\n   * A geometry can have more vertex attributes and still be compatible - at a\n   * potential performance cost - but it can't have less.\n   *\n   * @memberof PolylineMaterialAppearance.prototype\n   *\n   * @type VertexFormat\n   * @readonly\n   *\n   * @default {@link PolylineMaterialAppearance.VERTEX_FORMAT}\n   */\n  vertexFormat: {\n    get: function () {\n      return this._vertexFormat;\n    },\n  },\n});\n\n/**\n * The {@link VertexFormat} that all {@link PolylineMaterialAppearance} instances\n * are compatible with. This requires <code>position</code> and <code>st</code> attributes.\n *\n * @type VertexFormat\n *\n * @constant\n */\nPolylineMaterialAppearance.VERTEX_FORMAT = VertexFormat.POSITION_AND_ST;\n\n/**\n * Procedurally creates the full GLSL fragment shader source.  For {@link PolylineMaterialAppearance},\n * this is derived from {@link PolylineMaterialAppearance#fragmentShaderSource} and {@link PolylineMaterialAppearance#material}.\n *\n * @function\n *\n * @returns {String} The full GLSL fragment shader source.\n */\nPolylineMaterialAppearance.prototype.getFragmentShaderSource =\n  Appearance.prototype.getFragmentShaderSource;\n\n/**\n * Determines if the geometry is translucent based on {@link PolylineMaterialAppearance#translucent} and {@link Material#isTranslucent}.\n *\n * @function\n *\n * @returns {Boolean} <code>true</code> if the appearance is translucent.\n */\nPolylineMaterialAppearance.prototype.isTranslucent =\n  Appearance.prototype.isTranslucent;\n\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @function\n *\n * @returns {Object} The render state.\n */\nPolylineMaterialAppearance.prototype.getRenderState =\n  Appearance.prototype.getRenderState;\nexport default PolylineMaterialAppearance;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport PostProcessStageSampleMode from \"./PostProcessStageSampleMode.js\";\n\n/**\n * Runs a post-process stage on either the texture rendered by the scene or the output of a previous post-process stage.\n *\n * @alias PostProcessStage\n * @constructor\n *\n * @param {Object} options An object with the following properties:\n * @param {String} options.fragmentShader The fragment shader to use. The default <code>sampler2D</code> uniforms are <code>colorTexture</code> and <code>depthTexture</code>. The color texture is the output of rendering the scene or the previous stage. The depth texture is the output from rendering the scene. The shader should contain one or both uniforms. There is also a <code>vec2</code> varying named <code>v_textureCoordinates</code> that can be used to sample the textures.\n * @param {Object} [options.uniforms] An object whose properties will be used to set the shaders uniforms. The properties can be constant values or a function. A constant value can also be a URI, data URI, or HTML element to use as a texture.\n * @param {Number} [options.textureScale=1.0] A number in the range (0.0, 1.0] used to scale the texture dimensions. A scale of 1.0 will render this post-process stage  to a texture the size of the viewport.\n * @param {Boolean} [options.forcePowerOfTwo=false] Whether or not to force the texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.\n * @param {PostProcessStageSampleMode} [options.sampleMode=PostProcessStageSampleMode.NEAREST] How to sample the input color texture.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The color pixel format of the output texture.\n * @param {PixelDatatype} [options.pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The pixel data type of the output texture.\n * @param {Color} [options.clearColor=Color.BLACK] The color to clear the output texture to.\n * @param {BoundingRectangle} [options.scissorRectangle] The rectangle to use for the scissor test.\n * @param {String} [options.name=createGuid()] The unique name of this post-process stage for reference by other stages in a composite. If a name is not supplied, a GUID will be generated.\n *\n * @exception {DeveloperError} options.textureScale must be greater than 0.0 and less than or equal to 1.0.\n * @exception {DeveloperError} options.pixelFormat must be a color format.\n * @exception {DeveloperError} When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture.\n *\n * @see PostProcessStageComposite\n *\n * @example\n * // Simple stage to change the color\n * const fs =\n *     'uniform sampler2D colorTexture;\\n' +\n *     'varying vec2 v_textureCoordinates;\\n' +\n *     'uniform float scale;\\n' +\n *     'uniform vec3 offset;\\n' +\n *     'void main() {\\n' +\n *     '    vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n' +\n *     '    gl_FragColor = vec4(color.rgb * scale + offset, 1.0);\\n' +\n *     '}\\n';\n * scene.postProcessStages.add(new Cesium.PostProcessStage({\n *     fragmentShader : fs,\n *     uniforms : {\n *         scale : 1.1,\n *         offset : function() {\n *             return new Cesium.Cartesian3(0.1, 0.2, 0.3);\n *         }\n *     }\n * }));\n *\n * @example\n * // Simple stage to change the color of what is selected.\n * // If czm_selected returns true, the current fragment belongs to geometry in the selected array.\n * const fs =\n *     'uniform sampler2D colorTexture;\\n' +\n *     'varying vec2 v_textureCoordinates;\\n' +\n *     'uniform vec4 highlight;\\n' +\n *     'void main() {\\n' +\n *     '    vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n' +\n *     '    if (czm_selected()) {\\n' +\n *     '        vec3 highlighted = highlight.a * highlight.rgb + (1.0 - highlight.a) * color.rgb;\\n' +\n *     '        gl_FragColor = vec4(highlighted, 1.0);\\n' +\n *     '    } else { \\n' +\n *     '        gl_FragColor = color;\\n' +\n *     '    }\\n' +\n *     '}\\n';\n * const stage = scene.postProcessStages.add(new Cesium.PostProcessStage({\n *     fragmentShader : fs,\n *     uniforms : {\n *         highlight : function() {\n *             return new Cesium.Color(1.0, 0.0, 0.0, 0.5);\n *         }\n *     }\n * }));\n * stage.selected = [cesium3DTileFeature];\n */\nfunction PostProcessStage(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const fragmentShader = options.fragmentShader;\n  const textureScale = defaultValue(options.textureScale, 1.0);\n  const pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.fragmentShader\", fragmentShader);\n  Check.typeOf.number.greaterThan(\"options.textureScale\", textureScale, 0.0);\n  Check.typeOf.number.lessThanOrEquals(\n    \"options.textureScale\",\n    textureScale,\n    1.0\n  );\n  if (!PixelFormat.isColorFormat(pixelFormat)) {\n    throw new DeveloperError(\"options.pixelFormat must be a color format.\");\n  }\n  //>>includeEnd('debug');\n\n  this._fragmentShader = fragmentShader;\n  this._uniforms = options.uniforms;\n  this._textureScale = textureScale;\n  this._forcePowerOfTwo = defaultValue(options.forcePowerOfTwo, false);\n  this._sampleMode = defaultValue(\n    options.sampleMode,\n    PostProcessStageSampleMode.NEAREST\n  );\n  this._pixelFormat = pixelFormat;\n  this._pixelDatatype = defaultValue(\n    options.pixelDatatype,\n    PixelDatatype.UNSIGNED_BYTE\n  );\n  this._clearColor = defaultValue(options.clearColor, Color.BLACK);\n\n  this._uniformMap = undefined;\n  this._command = undefined;\n\n  this._colorTexture = undefined;\n  this._depthTexture = undefined;\n  this._idTexture = undefined;\n\n  this._actualUniforms = {};\n  this._dirtyUniforms = [];\n  this._texturesToRelease = [];\n  this._texturesToCreate = [];\n  this._texturePromise = undefined;\n\n  const passState = new PassState();\n  passState.scissorTest = {\n    enabled: true,\n    rectangle: defined(options.scissorRectangle)\n      ? BoundingRectangle.clone(options.scissorRectangle)\n      : new BoundingRectangle(),\n  };\n  this._passState = passState;\n\n  this._ready = false;\n\n  let name = options.name;\n  if (!defined(name)) {\n    name = createGuid();\n  }\n  this._name = name;\n\n  this._logDepthChanged = undefined;\n  this._useLogDepth = undefined;\n\n  this._selectedIdTexture = undefined;\n  this._selected = undefined;\n  this._selectedShadow = undefined;\n  this._parentSelected = undefined;\n  this._parentSelectedShadow = undefined;\n  this._combinedSelected = undefined;\n  this._combinedSelectedShadow = undefined;\n  this._selectedLength = 0;\n  this._parentSelectedLength = 0;\n  this._selectedDirty = true;\n\n  // set by PostProcessStageCollection\n  this._textureCache = undefined;\n  this._index = undefined;\n\n  /**\n   * Whether or not to execute this post-process stage when ready.\n   *\n   * @type {Boolean}\n   */\n  this.enabled = true;\n  this._enabled = true;\n}\n\nObject.defineProperties(PostProcessStage.prototype, {\n  /**\n   * Determines if this post-process stage is ready to be executed. A stage is only executed when both <code>ready</code>\n   * and {@link PostProcessStage#enabled} are <code>true</code>. A stage will not be ready while it is waiting on textures\n   * to load.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n  /**\n   * The unique name of this post-process stage for reference by other stages in a {@link PostProcessStageComposite}.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * The fragment shader to use when execute this post-process stage.\n   * <p>\n   * The shader must contain a sampler uniform declaration for <code>colorTexture</code>, <code>depthTexture</code>,\n   * or both.\n   * </p>\n   * <p>\n   * The shader must contain a <code>vec2</code> varying declaration for <code>v_textureCoordinates</code> for sampling\n   * the texture uniforms.\n   * </p>\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {String}\n   * @readonly\n   */\n  fragmentShader: {\n    get: function () {\n      return this._fragmentShader;\n    },\n  },\n  /**\n   * An object whose properties are used to set the uniforms of the fragment shader.\n   * <p>\n   * The object property values can be either a constant or a function. The function will be called\n   * each frame before the post-process stage is executed.\n   * </p>\n   * <p>\n   * A constant value can also be a URI to an image, a data URI, or an HTML element that can be used as a texture, such as HTMLImageElement or HTMLCanvasElement.\n   * </p>\n   * <p>\n   * If this post-process stage is part of a {@link PostProcessStageComposite} that does not execute in series, the constant value can also be\n   * the name of another stage in a composite. This will set the uniform to the output texture the stage with that name.\n   * </p>\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Object}\n   * @readonly\n   */\n  uniforms: {\n    get: function () {\n      return this._uniforms;\n    },\n  },\n  /**\n   * A number in the range (0.0, 1.0] used to scale the output texture dimensions. A scale of 1.0 will render this post-process stage to a texture the size of the viewport.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Number}\n   * @readonly\n   */\n  textureScale: {\n    get: function () {\n      return this._textureScale;\n    },\n  },\n  /**\n   * Whether or not to force the output texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Number}\n   * @readonly\n   */\n  forcePowerOfTwo: {\n    get: function () {\n      return this._forcePowerOfTwo;\n    },\n  },\n  /**\n   * How to sample the input color texture.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {PostProcessStageSampleMode}\n   * @readonly\n   */\n  sampleMode: {\n    get: function () {\n      return this._sampleMode;\n    },\n  },\n  /**\n   * The color pixel format of the output texture.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {PixelFormat}\n   * @readonly\n   */\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    },\n  },\n  /**\n   * The pixel data type of the output texture.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {PixelDatatype}\n   * @readonly\n   */\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    },\n  },\n  /**\n   * The color to clear the output texture to.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Color}\n   * @readonly\n   */\n  clearColor: {\n    get: function () {\n      return this._clearColor;\n    },\n  },\n  /**\n   * The {@link BoundingRectangle} to use for the scissor test. A default bounding rectangle will disable the scissor test.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {BoundingRectangle}\n   * @readonly\n   */\n  scissorRectangle: {\n    get: function () {\n      return this._passState.scissorTest.rectangle;\n    },\n  },\n  /**\n   * A reference to the texture written to when executing this post process stage.\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  outputTexture: {\n    get: function () {\n      if (defined(this._textureCache)) {\n        const framebuffer = this._textureCache.getFramebuffer(this._name);\n        if (defined(framebuffer)) {\n          return framebuffer.getColorTexture(0);\n        }\n      }\n      return undefined;\n    },\n  },\n  /**\n   * The features selected for applying the post-process.\n   * <p>\n   * In the fragment shader, use <code>czm_selected</code> to determine whether or not to apply the post-process\n   * stage to that fragment. For example:\n   * <code>\n   * if (czm_selected(v_textureCoordinates)) {\n   *     // apply post-process stage\n   * } else {\n   *     gl_FragColor = texture2D(colorTexture, v_textureCordinates);\n   * }\n   * </code>\n   * </p>\n   *\n   * @memberof PostProcessStage.prototype\n   * @type {Array}\n   */\n  selected: {\n    get: function () {\n      return this._selected;\n    },\n    set: function (value) {\n      this._selected = value;\n    },\n  },\n  /**\n   * @private\n   */\n  parentSelected: {\n    get: function () {\n      return this._parentSelected;\n    },\n    set: function (value) {\n      this._parentSelected = value;\n    },\n  },\n});\n\nconst depthTextureRegex = /uniform\\s+sampler2D\\s+depthTexture/g;\n\n/**\n * @private\n */\nPostProcessStage.prototype._isSupported = function (context) {\n  return !depthTextureRegex.test(this._fragmentShader) || context.depthTexture;\n};\n\nfunction getUniformValueGetterAndSetter(stage, uniforms, name) {\n  const currentValue = uniforms[name];\n  if (\n    typeof currentValue === \"string\" ||\n    currentValue instanceof HTMLCanvasElement ||\n    currentValue instanceof HTMLImageElement ||\n    currentValue instanceof HTMLVideoElement ||\n    currentValue instanceof ImageData\n  ) {\n    stage._dirtyUniforms.push(name);\n  }\n\n  return {\n    get: function () {\n      return uniforms[name];\n    },\n    set: function (value) {\n      const currentValue = uniforms[name];\n      uniforms[name] = value;\n\n      const actualUniforms = stage._actualUniforms;\n      const actualValue = actualUniforms[name];\n      if (\n        defined(actualValue) &&\n        actualValue !== currentValue &&\n        actualValue instanceof Texture &&\n        !defined(stage._textureCache.getStageByName(name))\n      ) {\n        stage._texturesToRelease.push(actualValue);\n        delete actualUniforms[name];\n        delete actualUniforms[`${name}Dimensions`];\n      }\n\n      if (currentValue instanceof Texture) {\n        stage._texturesToRelease.push(currentValue);\n      }\n\n      if (\n        typeof value === \"string\" ||\n        value instanceof HTMLCanvasElement ||\n        value instanceof HTMLImageElement ||\n        value instanceof HTMLVideoElement ||\n        value instanceof ImageData\n      ) {\n        stage._dirtyUniforms.push(name);\n      } else {\n        actualUniforms[name] = value;\n      }\n    },\n  };\n}\n\nfunction getUniformMapFunction(stage, name) {\n  return function () {\n    const value = stage._actualUniforms[name];\n    if (typeof value === \"function\") {\n      return value();\n    }\n    return value;\n  };\n}\n\nfunction getUniformMapDimensionsFunction(uniformMap, name) {\n  return function () {\n    const texture = uniformMap[name]();\n    if (defined(texture)) {\n      return texture.dimensions;\n    }\n    return undefined;\n  };\n}\n\nfunction createUniformMap(stage) {\n  if (defined(stage._uniformMap)) {\n    return;\n  }\n\n  const uniformMap = {};\n  const newUniforms = {};\n  const uniforms = stage._uniforms;\n  const actualUniforms = stage._actualUniforms;\n  for (const name in uniforms) {\n    if (uniforms.hasOwnProperty(name)) {\n      if (typeof uniforms[name] !== \"function\") {\n        uniformMap[name] = getUniformMapFunction(stage, name);\n        newUniforms[name] = getUniformValueGetterAndSetter(\n          stage,\n          uniforms,\n          name\n        );\n      } else {\n        uniformMap[name] = uniforms[name];\n        newUniforms[name] = uniforms[name];\n      }\n\n      actualUniforms[name] = uniforms[name];\n\n      const value = uniformMap[name]();\n      if (\n        typeof value === \"string\" ||\n        value instanceof Texture ||\n        value instanceof HTMLImageElement ||\n        value instanceof HTMLCanvasElement ||\n        value instanceof HTMLVideoElement\n      ) {\n        uniformMap[`${name}Dimensions`] = getUniformMapDimensionsFunction(\n          uniformMap,\n          name\n        );\n      }\n    }\n  }\n\n  stage._uniforms = {};\n  Object.defineProperties(stage._uniforms, newUniforms);\n\n  stage._uniformMap = combine(uniformMap, {\n    colorTexture: function () {\n      return stage._colorTexture;\n    },\n    colorTextureDimensions: function () {\n      return stage._colorTexture.dimensions;\n    },\n    depthTexture: function () {\n      return stage._depthTexture;\n    },\n    depthTextureDimensions: function () {\n      return stage._depthTexture.dimensions;\n    },\n    czm_idTexture: function () {\n      return stage._idTexture;\n    },\n    czm_selectedIdTexture: function () {\n      return stage._selectedIdTexture;\n    },\n    czm_selectedIdTextureStep: function () {\n      return 1.0 / stage._selectedIdTexture.width;\n    },\n  });\n}\n\nfunction createDrawCommand(stage, context) {\n  if (\n    defined(stage._command) &&\n    !stage._logDepthChanged &&\n    !stage._selectedDirty\n  ) {\n    return;\n  }\n\n  let fs = stage._fragmentShader;\n  if (defined(stage._selectedIdTexture)) {\n    const width = stage._selectedIdTexture.width;\n\n    fs = fs.replace(/varying\\s+vec2\\s+v_textureCoordinates;/g, \"\");\n    fs =\n      `${\n        \"#define CZM_SELECTED_FEATURE \\n\" +\n        \"uniform sampler2D czm_idTexture; \\n\" +\n        \"uniform sampler2D czm_selectedIdTexture; \\n\" +\n        \"uniform float czm_selectedIdTextureStep; \\n\" +\n        \"varying vec2 v_textureCoordinates; \\n\" +\n        \"bool czm_selected(vec2 offset) \\n\" +\n        \"{ \\n\" +\n        \"    bool selected = false;\\n\" +\n        \"    vec4 id = texture2D(czm_idTexture, v_textureCoordinates + offset); \\n\" +\n        \"    for (int i = 0; i < \"\n      }${width}; ++i) \\n` +\n      `    { \\n` +\n      `        vec4 selectedId = texture2D(czm_selectedIdTexture, vec2((float(i) + 0.5) * czm_selectedIdTextureStep, 0.5)); \\n` +\n      `        if (all(equal(id, selectedId))) \\n` +\n      `        { \\n` +\n      `            return true; \\n` +\n      `        } \\n` +\n      `    } \\n` +\n      `    return false; \\n` +\n      `} \\n\\n` +\n      `bool czm_selected() \\n` +\n      `{ \\n` +\n      `    return czm_selected(vec2(0.0)); \\n` +\n      `} \\n\\n${fs}`;\n  }\n\n  const fragmentShader = new ShaderSource({\n    defines: [stage._useLogDepth ? \"LOG_DEPTH\" : \"\"],\n    sources: [fs],\n  });\n  stage._command = context.createViewportQuadCommand(fragmentShader, {\n    uniformMap: stage._uniformMap,\n    owner: stage,\n  });\n}\n\nfunction createSampler(stage) {\n  const mode = stage._sampleMode;\n\n  let minFilter;\n  let magFilter;\n\n  if (mode === PostProcessStageSampleMode.LINEAR) {\n    minFilter = TextureMinificationFilter.LINEAR;\n    magFilter = TextureMagnificationFilter.LINEAR;\n  } else {\n    minFilter = TextureMinificationFilter.NEAREST;\n    magFilter = TextureMagnificationFilter.NEAREST;\n  }\n\n  const sampler = stage._sampler;\n  if (\n    !defined(sampler) ||\n    sampler.minificationFilter !== minFilter ||\n    sampler.magnificationFilter !== magFilter\n  ) {\n    stage._sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: minFilter,\n      magnificationFilter: magFilter,\n    });\n  }\n}\n\nfunction createLoadImageFunction(stage, name) {\n  return function (image) {\n    stage._texturesToCreate.push({\n      name: name,\n      source: image,\n    });\n  };\n}\n\nfunction createStageOutputTextureFunction(stage, name) {\n  return function () {\n    return stage._textureCache.getOutputTexture(name);\n  };\n}\n\nfunction updateUniformTextures(stage, context) {\n  let i;\n  let texture;\n  let name;\n\n  const texturesToRelease = stage._texturesToRelease;\n  let length = texturesToRelease.length;\n  for (i = 0; i < length; ++i) {\n    texture = texturesToRelease[i];\n    texture = texture && texture.destroy();\n  }\n  texturesToRelease.length = 0;\n\n  const texturesToCreate = stage._texturesToCreate;\n  length = texturesToCreate.length;\n  for (i = 0; i < length; ++i) {\n    const textureToCreate = texturesToCreate[i];\n    name = textureToCreate.name;\n    const source = textureToCreate.source;\n    stage._actualUniforms[name] = new Texture({\n      context: context,\n      source: source,\n    });\n  }\n  texturesToCreate.length = 0;\n\n  const dirtyUniforms = stage._dirtyUniforms;\n  if (dirtyUniforms.length === 0 && !defined(stage._texturePromise)) {\n    stage._ready = true;\n    return;\n  }\n\n  if (dirtyUniforms.length === 0 || defined(stage._texturePromise)) {\n    return;\n  }\n\n  length = dirtyUniforms.length;\n  const uniforms = stage._uniforms;\n  const promises = [];\n  for (i = 0; i < length; ++i) {\n    name = dirtyUniforms[i];\n    const stageNameUrlOrImage = uniforms[name];\n    const stageWithName = stage._textureCache.getStageByName(\n      stageNameUrlOrImage\n    );\n    if (defined(stageWithName)) {\n      stage._actualUniforms[name] = createStageOutputTextureFunction(\n        stage,\n        stageNameUrlOrImage\n      );\n    } else if (typeof stageNameUrlOrImage === \"string\") {\n      const resource = new Resource({\n        url: stageNameUrlOrImage,\n      });\n\n      promises.push(\n        resource.fetchImage().then(createLoadImageFunction(stage, name))\n      );\n    } else {\n      stage._texturesToCreate.push({\n        name: name,\n        source: stageNameUrlOrImage,\n      });\n    }\n  }\n\n  dirtyUniforms.length = 0;\n\n  if (promises.length > 0) {\n    stage._ready = false;\n    stage._texturePromise = Promise.all(promises).then(function () {\n      stage._ready = true;\n      stage._texturePromise = undefined;\n    });\n  } else {\n    stage._ready = true;\n  }\n}\n\nfunction releaseResources(stage) {\n  if (defined(stage._command)) {\n    stage._command.shaderProgram =\n      stage._command.shaderProgram && stage._command.shaderProgram.destroy();\n    stage._command = undefined;\n  }\n\n  stage._selectedIdTexture =\n    stage._selectedIdTexture && stage._selectedIdTexture.destroy();\n\n  const textureCache = stage._textureCache;\n  if (!defined(textureCache)) {\n    return;\n  }\n\n  const uniforms = stage._uniforms;\n  const actualUniforms = stage._actualUniforms;\n  for (const name in actualUniforms) {\n    if (actualUniforms.hasOwnProperty(name)) {\n      if (actualUniforms[name] instanceof Texture) {\n        if (!defined(textureCache.getStageByName(uniforms[name]))) {\n          actualUniforms[name].destroy();\n        }\n        stage._dirtyUniforms.push(name);\n      }\n    }\n  }\n}\n\nfunction isSelectedTextureDirty(stage) {\n  let length = defined(stage._selected) ? stage._selected.length : 0;\n  const parentLength = defined(stage._parentSelected)\n    ? stage._parentSelected\n    : 0;\n  let dirty =\n    stage._selected !== stage._selectedShadow ||\n    length !== stage._selectedLength;\n  dirty =\n    dirty ||\n    stage._parentSelected !== stage._parentSelectedShadow ||\n    parentLength !== stage._parentSelectedLength;\n\n  if (defined(stage._selected) && defined(stage._parentSelected)) {\n    stage._combinedSelected = stage._selected.concat(stage._parentSelected);\n  } else if (defined(stage._parentSelected)) {\n    stage._combinedSelected = stage._parentSelected;\n  } else {\n    stage._combinedSelected = stage._selected;\n  }\n\n  if (!dirty && defined(stage._combinedSelected)) {\n    if (!defined(stage._combinedSelectedShadow)) {\n      return true;\n    }\n\n    length = stage._combinedSelected.length;\n    for (let i = 0; i < length; ++i) {\n      if (stage._combinedSelected[i] !== stage._combinedSelectedShadow[i]) {\n        return true;\n      }\n    }\n  }\n  return dirty;\n}\n\nfunction createSelectedTexture(stage, context) {\n  if (!stage._selectedDirty) {\n    return;\n  }\n\n  stage._selectedIdTexture =\n    stage._selectedIdTexture && stage._selectedIdTexture.destroy();\n  stage._selectedIdTexture = undefined;\n\n  const features = stage._combinedSelected;\n  if (!defined(features)) {\n    return;\n  }\n\n  let i;\n  let feature;\n\n  let textureLength = 0;\n  const length = features.length;\n  for (i = 0; i < length; ++i) {\n    feature = features[i];\n    if (defined(feature.pickIds)) {\n      textureLength += feature.pickIds.length;\n    } else if (defined(feature.pickId)) {\n      ++textureLength;\n    }\n  }\n\n  if (length === 0 || textureLength === 0) {\n    // max pick id is reserved\n    const empty = new Uint8Array(4);\n    empty[0] = 255;\n    empty[1] = 255;\n    empty[2] = 255;\n    empty[3] = 255;\n\n    stage._selectedIdTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: empty,\n        width: 1,\n        height: 1,\n      },\n      sampler: Sampler.NEAREST,\n    });\n    return;\n  }\n\n  let pickColor;\n  let offset = 0;\n  const ids = new Uint8Array(textureLength * 4);\n  for (i = 0; i < length; ++i) {\n    feature = features[i];\n    if (defined(feature.pickIds)) {\n      const pickIds = feature.pickIds;\n      const pickIdsLength = pickIds.length;\n      for (let j = 0; j < pickIdsLength; ++j) {\n        pickColor = pickIds[j].color;\n        ids[offset] = Color.floatToByte(pickColor.red);\n        ids[offset + 1] = Color.floatToByte(pickColor.green);\n        ids[offset + 2] = Color.floatToByte(pickColor.blue);\n        ids[offset + 3] = Color.floatToByte(pickColor.alpha);\n        offset += 4;\n      }\n    } else if (defined(feature.pickId)) {\n      pickColor = feature.pickId.color;\n      ids[offset] = Color.floatToByte(pickColor.red);\n      ids[offset + 1] = Color.floatToByte(pickColor.green);\n      ids[offset + 2] = Color.floatToByte(pickColor.blue);\n      ids[offset + 3] = Color.floatToByte(pickColor.alpha);\n      offset += 4;\n    }\n  }\n\n  stage._selectedIdTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      arrayBufferView: ids,\n      width: textureLength,\n      height: 1,\n    },\n    sampler: Sampler.NEAREST,\n  });\n}\n\n/**\n * A function that will be called before execute. Used to create WebGL resources and load any textures.\n * @param {Context} context The context.\n * @param {Boolean} useLogDepth Whether the scene uses a logarithmic depth buffer.\n * @private\n */\nPostProcessStage.prototype.update = function (context, useLogDepth) {\n  if (this.enabled !== this._enabled && !this.enabled) {\n    releaseResources(this);\n  }\n\n  this._enabled = this.enabled;\n  if (!this._enabled) {\n    return;\n  }\n\n  this._logDepthChanged = useLogDepth !== this._useLogDepth;\n  this._useLogDepth = useLogDepth;\n\n  this._selectedDirty = isSelectedTextureDirty(this);\n\n  this._selectedShadow = this._selected;\n  this._parentSelectedShadow = this._parentSelected;\n  this._combinedSelectedShadow = this._combinedSelected;\n  this._selectedLength = defined(this._selected) ? this._selected.length : 0;\n  this._parentSelectedLength = defined(this._parentSelected)\n    ? this._parentSelected.length\n    : 0;\n\n  createSelectedTexture(this, context);\n  createUniformMap(this);\n  updateUniformTextures(this, context);\n  createDrawCommand(this, context);\n  createSampler(this);\n\n  this._selectedDirty = false;\n\n  if (!this._ready) {\n    return;\n  }\n\n  const framebuffer = this._textureCache.getFramebuffer(this._name);\n  this._command.framebuffer = framebuffer;\n\n  if (!defined(framebuffer)) {\n    return;\n  }\n\n  const colorTexture = framebuffer.getColorTexture(0);\n  let renderState;\n  if (\n    colorTexture.width !== context.drawingBufferWidth ||\n    colorTexture.height !== context.drawingBufferHeight\n  ) {\n    renderState = this._renderState;\n    if (\n      !defined(renderState) ||\n      colorTexture.width !== renderState.viewport.width ||\n      colorTexture.height !== renderState.viewport.height\n    ) {\n      this._renderState = RenderState.fromCache({\n        viewport: new BoundingRectangle(\n          0,\n          0,\n          colorTexture.width,\n          colorTexture.height\n        ),\n      });\n    }\n  }\n\n  this._command.renderState = renderState;\n};\n\n/**\n * Executes the post-process stage. The color texture is the texture rendered to by the scene or from the previous stage.\n * @param {Context} context The context.\n * @param {Texture} colorTexture The input color texture.\n * @param {Texture} depthTexture The input depth texture.\n * @param {Texture} idTexture The id texture.\n * @private\n */\nPostProcessStage.prototype.execute = function (\n  context,\n  colorTexture,\n  depthTexture,\n  idTexture\n) {\n  if (\n    !defined(this._command) ||\n    !defined(this._command.framebuffer) ||\n    !this._ready ||\n    !this._enabled\n  ) {\n    return;\n  }\n\n  this._colorTexture = colorTexture;\n  this._depthTexture = depthTexture;\n  this._idTexture = idTexture;\n\n  if (!Sampler.equals(this._colorTexture.sampler, this._sampler)) {\n    this._colorTexture.sampler = this._sampler;\n  }\n\n  const passState =\n    this.scissorRectangle.width > 0 && this.scissorRectangle.height > 0\n      ? this._passState\n      : undefined;\n  if (defined(passState)) {\n    passState.context = context;\n  }\n\n  this._command.execute(context, passState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStage#destroy\n */\nPostProcessStage.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStage#isDestroyed\n */\nPostProcessStage.prototype.destroy = function () {\n  releaseResources(this);\n  return destroyObject(this);\n};\nexport default PostProcessStage;\n","import arraySlice from \"../Core/arraySlice.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport PassThrough from \"../Shaders/PostProcessStages/PassThrough.js\";\nimport PostProcessStageLibrary from \"./PostProcessStageLibrary.js\";\nimport PostProcessStageTextureCache from \"./PostProcessStageTextureCache.js\";\nimport Tonemapper from \"./Tonemapper.js\";\n\nconst stackScratch = [];\n\n/**\n * A collection of {@link PostProcessStage}s and/or {@link PostProcessStageComposite}s.\n * <p>\n * The input texture for each post-process stage is the texture rendered to by the scene or the texture rendered\n * to by the previous stage in the collection.\n * </p>\n * <p>\n * If the ambient occlusion or bloom stages are enabled, they will execute before all other stages.\n * </p>\n * <p>\n * If the FXAA stage is enabled, it will execute after all other stages.\n * </p>\n *\n * @alias PostProcessStageCollection\n * @constructor\n */\nfunction PostProcessStageCollection() {\n  const fxaa = PostProcessStageLibrary.createFXAAStage();\n  const ao = PostProcessStageLibrary.createAmbientOcclusionStage();\n  const bloom = PostProcessStageLibrary.createBloomStage();\n\n  // Auto-exposure is currently disabled because most shaders output a value in [0.0, 1.0].\n  // Some shaders, such as the atmosphere and ground atmosphere, output values slightly over 1.0.\n  this._autoExposureEnabled = false;\n  this._autoExposure = PostProcessStageLibrary.createAutoExposureStage();\n  this._tonemapping = undefined;\n  this._tonemapper = undefined;\n\n  // set tonemapper and tonemapping\n  this.tonemapper = Tonemapper.ACES;\n\n  const tonemapping = this._tonemapping;\n\n  fxaa.enabled = false;\n  ao.enabled = false;\n  bloom.enabled = false;\n  tonemapping.enabled = false; // will be enabled if necessary in update\n\n  const textureCache = new PostProcessStageTextureCache(this);\n\n  const stageNames = {};\n  const stack = stackScratch;\n  stack.push(fxaa, ao, bloom, tonemapping);\n  while (stack.length > 0) {\n    const stage = stack.pop();\n    stageNames[stage.name] = stage;\n    stage._textureCache = textureCache;\n\n    const length = stage.length;\n    if (defined(length)) {\n      for (let i = 0; i < length; ++i) {\n        stack.push(stage.get(i));\n      }\n    }\n  }\n\n  this._stages = [];\n  this._activeStages = [];\n  this._previousActiveStages = [];\n\n  this._randomTexture = undefined; // For AO\n\n  const that = this;\n  ao.uniforms.randomTexture = function () {\n    return that._randomTexture;\n  };\n\n  this._ao = ao;\n  this._bloom = bloom;\n  this._fxaa = fxaa;\n\n  this._aoEnabled = undefined;\n  this._bloomEnabled = undefined;\n  this._tonemappingEnabled = undefined;\n  this._fxaaEnabled = undefined;\n\n  this._activeStagesChanged = false;\n  this._stagesRemoved = false;\n  this._textureCacheDirty = false;\n\n  this._stageNames = stageNames;\n  this._textureCache = textureCache;\n}\n\nObject.defineProperties(PostProcessStageCollection.prototype, {\n  /**\n   * Determines if all of the post-process stages in the collection are ready to be executed.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      let readyAndEnabled = false;\n      const stages = this._stages;\n      const length = stages.length;\n      for (let i = length - 1; i >= 0; --i) {\n        const stage = stages[i];\n        readyAndEnabled = readyAndEnabled || (stage.ready && stage.enabled);\n      }\n\n      const fxaa = this._fxaa;\n      const ao = this._ao;\n      const bloom = this._bloom;\n      const tonemapping = this._tonemapping;\n\n      readyAndEnabled = readyAndEnabled || (fxaa.ready && fxaa.enabled);\n      readyAndEnabled = readyAndEnabled || (ao.ready && ao.enabled);\n      readyAndEnabled = readyAndEnabled || (bloom.ready && bloom.enabled);\n      readyAndEnabled =\n        readyAndEnabled || (tonemapping.ready && tonemapping.enabled);\n\n      return readyAndEnabled;\n    },\n  },\n  /**\n   * A post-process stage for Fast Approximate Anti-aliasing.\n   * <p>\n   * When enabled, this stage will execute after all others.\n   * </p>\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {PostProcessStage}\n   * @readonly\n   */\n  fxaa: {\n    get: function () {\n      return this._fxaa;\n    },\n  },\n  /**\n   * A post-process stage that applies Horizon-based Ambient Occlusion (HBAO) to the input texture.\n   * <p>\n   * Ambient occlusion simulates shadows from ambient light. These shadows would always be present when the\n   * surface receives light and regardless of the light's position.\n   * </p>\n   * <p>\n   * The uniforms have the following properties: <code>intensity</code>, <code>bias</code>, <code>lengthCap</code>,\n   * <code>stepSize</code>, <code>frustumLength</code>, <code>ambientOcclusionOnly</code>,\n   * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code>.\n   * </p>\n   * <ul>\n   * <li><code>intensity</code> is a scalar value used to lighten or darken the shadows exponentially. Higher values make the shadows darker. The default value is <code>3.0</code>.</li>\n   *\n   * <li><code>bias</code> is a scalar value representing an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value,\n   * sampling stops in the current direction. This is used to remove shadows from near planar edges. The default value is <code>0.1</code>.</li>\n   *\n   * <li><code>lengthCap</code> is a scalar value representing a length in meters. If the distance from the current sample to first sample is greater than this value,\n   * sampling stops in the current direction. The default value is <code>0.26</code>.</li>\n   *\n   * <li><code>stepSize</code> is a scalar value indicating the distance to the next texel sample in the current direction. The default value is <code>1.95</code>.</li>\n   *\n   * <li><code>frustumLength</code> is a scalar value in meters. If the current fragment has a distance from the camera greater than this value, ambient occlusion is not computed for the fragment.\n   * The default value is <code>1000.0</code>.</li>\n   *\n   * <li><code>ambientOcclusionOnly</code> is a boolean value. When <code>true</code>, only the shadows generated are written to the output. When <code>false</code>, the input texture is modulated\n   * with the ambient occlusion. This is a useful debug option for seeing the effects of changing the uniform values. The default value is <code>false</code>.</li>\n   * </ul>\n   * <p>\n   * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n   * The blur is applied to the shadows generated from the image to make them smoother.\n   * </p>\n   * <p>\n   * When enabled, this stage will execute before all others.\n   * </p>\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {PostProcessStageComposite}\n   * @readonly\n   */\n  ambientOcclusion: {\n    get: function () {\n      return this._ao;\n    },\n  },\n  /**\n   * A post-process stage for a bloom effect.\n   * <p>\n   * A bloom effect adds glow effect, makes bright areas brighter, and dark areas darker.\n   * </p>\n   * <p>\n   * This stage has the following uniforms: <code>contrast</code>, <code>brightness</code>, <code>glowOnly</code>,\n   * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n   * </p>\n   * <ul>\n   * <li><code>contrast</code> is a scalar value in the range [-255.0, 255.0] and affects the contract of the effect. The default value is <code>128.0</code>.</li>\n   *\n   * <li><code>brightness</code> is a scalar value. The input texture RGB value is converted to hue, saturation, and brightness (HSB) then this value is\n   * added to the brightness. The default value is <code>-0.3</code>.</li>\n   *\n   * <li><code>glowOnly</code> is a boolean value. When <code>true</code>, only the glow effect will be shown. When <code>false</code>, the glow will be added to the input texture.\n   * The default value is <code>false</code>. This is a debug option for viewing the effects when changing the other uniform values.</li>\n   * </ul>\n   * <p>\n   * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n   * The blur is applied to the shadows generated from the image to make them smoother.\n   * </p>\n   * <p>\n   * When enabled, this stage will execute before all others.\n   * </p>\n   *\n   * @memberOf PostProcessStageCollection.prototype\n   * @type {PostProcessStageComposite}\n   * @readonly\n   */\n  bloom: {\n    get: function () {\n      return this._bloom;\n    },\n  },\n  /**\n   * The number of post-process stages in this collection.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      removeStages(this);\n      return this._stages.length;\n    },\n  },\n  /**\n   * A reference to the last texture written to when executing the post-process stages in this collection.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  outputTexture: {\n    get: function () {\n      const fxaa = this._fxaa;\n      if (fxaa.enabled && fxaa.ready) {\n        return this.getOutputTexture(fxaa.name);\n      }\n\n      const stages = this._stages;\n      const length = stages.length;\n      for (let i = length - 1; i >= 0; --i) {\n        const stage = stages[i];\n        if (defined(stage) && stage.ready && stage.enabled) {\n          return this.getOutputTexture(stage.name);\n        }\n      }\n\n      const tonemapping = this._tonemapping;\n      if (tonemapping.enabled && tonemapping.ready) {\n        return this.getOutputTexture(tonemapping.name);\n      }\n\n      const bloom = this._bloom;\n      if (bloom.enabled && bloom.ready) {\n        return this.getOutputTexture(bloom.name);\n      }\n\n      const ao = this._ao;\n      if (ao.enabled && ao.ready) {\n        return this.getOutputTexture(ao.name);\n      }\n\n      return undefined;\n    },\n  },\n  /**\n   * Whether the collection has a stage that has selected features.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  hasSelected: {\n    get: function () {\n      const stages = arraySlice(this._stages);\n      while (stages.length > 0) {\n        const stage = stages.pop();\n        if (!defined(stage)) {\n          continue;\n        }\n        if (defined(stage.selected)) {\n          return true;\n        }\n        const length = stage.length;\n        if (defined(length)) {\n          for (let i = 0; i < length; ++i) {\n            stages.push(stage.get(i));\n          }\n        }\n      }\n      return false;\n    },\n  },\n\n  /**\n   * Gets and sets the tonemapping algorithm used when rendering with high dynamic range.\n   *\n   * @memberof PostProcessStageCollection.prototype\n   * @type {Tonemapper}\n   * @private\n   */\n  tonemapper: {\n    get: function () {\n      return this._tonemapper;\n    },\n    set: function (value) {\n      if (this._tonemapper === value) {\n        return;\n      }\n      //>>includeStart('debug', pragmas.debug);\n      if (!Tonemapper.validate(value)) {\n        throw new DeveloperError(\"tonemapper was set to an invalid value.\");\n      }\n      //>>includeEnd('debug');\n\n      if (defined(this._tonemapping)) {\n        delete this._stageNames[this._tonemapping.name];\n        this._tonemapping.destroy();\n      }\n\n      const useAutoExposure = this._autoExposureEnabled;\n      let tonemapper;\n\n      switch (value) {\n        case Tonemapper.REINHARD:\n          tonemapper = PostProcessStageLibrary.createReinhardTonemappingStage(\n            useAutoExposure\n          );\n          break;\n        case Tonemapper.MODIFIED_REINHARD:\n          tonemapper = PostProcessStageLibrary.createModifiedReinhardTonemappingStage(\n            useAutoExposure\n          );\n          break;\n        case Tonemapper.FILMIC:\n          tonemapper = PostProcessStageLibrary.createFilmicTonemappingStage(\n            useAutoExposure\n          );\n          break;\n        default:\n          tonemapper = PostProcessStageLibrary.createAcesTonemappingStage(\n            useAutoExposure\n          );\n          break;\n      }\n\n      if (useAutoExposure) {\n        const autoexposure = this._autoExposure;\n        tonemapper.uniforms.autoExposure = function () {\n          return autoexposure.outputTexture;\n        };\n      }\n\n      this._tonemapper = value;\n      this._tonemapping = tonemapper;\n\n      if (defined(this._stageNames)) {\n        this._stageNames[tonemapper.name] = tonemapper;\n        tonemapper._textureCache = this._textureCache;\n      }\n\n      this._textureCacheDirty = true;\n    },\n  },\n});\n\nfunction removeStages(collection) {\n  if (!collection._stagesRemoved) {\n    return;\n  }\n\n  collection._stagesRemoved = false;\n\n  const newStages = [];\n  const stages = collection._stages;\n  const length = stages.length;\n  for (let i = 0, j = 0; i < length; ++i) {\n    const stage = stages[i];\n    if (stage) {\n      stage._index = j++;\n      newStages.push(stage);\n    }\n  }\n\n  collection._stages = newStages;\n}\n\n/**\n * Adds the post-process stage to the collection.\n *\n * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage to add to the collection.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage that was added to the collection.\n *\n * @exception {DeveloperError} The post-process stage has already been added to the collection or does not have a unique name.\n */\nPostProcessStageCollection.prototype.add = function (stage) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"stage\", stage);\n  //>>includeEnd('debug');\n\n  const stageNames = this._stageNames;\n\n  const stack = stackScratch;\n  stack.push(stage);\n  while (stack.length > 0) {\n    const currentStage = stack.pop();\n    //>>includeStart('debug', pragmas.debug);\n    if (defined(stageNames[currentStage.name])) {\n      throw new DeveloperError(\n        `${currentStage.name} has already been added to the collection or does not have a unique name.`\n      );\n    }\n    //>>includeEnd('debug');\n    stageNames[currentStage.name] = currentStage;\n    currentStage._textureCache = this._textureCache;\n\n    const length = currentStage.length;\n    if (defined(length)) {\n      for (let i = 0; i < length; ++i) {\n        stack.push(currentStage.get(i));\n      }\n    }\n  }\n\n  const stages = this._stages;\n  stage._index = stages.length;\n  stages.push(stage);\n  this._textureCacheDirty = true;\n  return stage;\n};\n\n/**\n * Removes a post-process stage from the collection and destroys it.\n *\n * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage to remove from the collection.\n * @return {Boolean} Whether the post-process stage was removed.\n */\nPostProcessStageCollection.prototype.remove = function (stage) {\n  if (!this.contains(stage)) {\n    return false;\n  }\n\n  const stageNames = this._stageNames;\n\n  const stack = stackScratch;\n  stack.push(stage);\n  while (stack.length > 0) {\n    const currentStage = stack.pop();\n    delete stageNames[currentStage.name];\n\n    const length = currentStage.length;\n    if (defined(length)) {\n      for (let i = 0; i < length; ++i) {\n        stack.push(currentStage.get(i));\n      }\n    }\n  }\n\n  this._stages[stage._index] = undefined;\n  this._stagesRemoved = true;\n  this._textureCacheDirty = true;\n  stage._index = undefined;\n  stage._textureCache = undefined;\n  stage.destroy();\n  return true;\n};\n\n/**\n * Returns whether the collection contains a post-process stage.\n *\n * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage.\n * @return {Boolean} Whether the collection contains the post-process stage.\n */\nPostProcessStageCollection.prototype.contains = function (stage) {\n  return (\n    defined(stage) &&\n    defined(stage._index) &&\n    stage._textureCache === this._textureCache\n  );\n};\n\n/**\n * Gets the post-process stage at <code>index</code>.\n *\n * @param {Number} index The index of the post-process stage.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage at index.\n */\nPostProcessStageCollection.prototype.get = function (index) {\n  removeStages(this);\n  const stages = this._stages;\n  //>>includeStart('debug', pragmas.debug);\n  const length = stages.length;\n  Check.typeOf.number.greaterThanOrEquals(\"stages length\", length, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThan(\"index\", index, length);\n  //>>includeEnd('debug');\n  return stages[index];\n};\n\n/**\n * Removes all post-process stages from the collection and destroys them.\n */\nPostProcessStageCollection.prototype.removeAll = function () {\n  const stages = this._stages;\n  const length = stages.length;\n  for (let i = 0; i < length; ++i) {\n    this.remove(stages[i]);\n  }\n  stages.length = 0;\n};\n\n/**\n * Gets a post-process stage in the collection by its name.\n *\n * @param {String} name The name of the post-process stage.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage.\n *\n * @private\n */\nPostProcessStageCollection.prototype.getStageByName = function (name) {\n  return this._stageNames[name];\n};\n\n/**\n * Called before the post-process stages in the collection are executed. Calls update for each stage and creates WebGL resources.\n *\n * @param {Context} context The context.\n * @param {Boolean} useLogDepth Whether the scene uses a logarithmic depth buffer.\n *\n * @private\n */\nPostProcessStageCollection.prototype.update = function (\n  context,\n  useLogDepth,\n  useHdr\n) {\n  removeStages(this);\n\n  const previousActiveStages = this._activeStages;\n  const activeStages = (this._activeStages = this._previousActiveStages);\n  this._previousActiveStages = previousActiveStages;\n\n  const stages = this._stages;\n  let length = (activeStages.length = stages.length);\n\n  let i;\n  let stage;\n  let count = 0;\n  for (i = 0; i < length; ++i) {\n    stage = stages[i];\n    if (stage.ready && stage.enabled && stage._isSupported(context)) {\n      activeStages[count++] = stage;\n    }\n  }\n\n  activeStages.length = count;\n\n  let activeStagesChanged = count !== previousActiveStages.length;\n  if (!activeStagesChanged) {\n    for (i = 0; i < count; ++i) {\n      if (activeStages[i] !== previousActiveStages[i]) {\n        activeStagesChanged = true;\n        break;\n      }\n    }\n  }\n\n  const ao = this._ao;\n  const bloom = this._bloom;\n  const autoexposure = this._autoExposure;\n  const tonemapping = this._tonemapping;\n  const fxaa = this._fxaa;\n\n  tonemapping.enabled = useHdr;\n\n  const aoEnabled = ao.enabled && ao._isSupported(context);\n  const bloomEnabled = bloom.enabled && bloom._isSupported(context);\n  const tonemappingEnabled =\n    tonemapping.enabled && tonemapping._isSupported(context);\n  const fxaaEnabled = fxaa.enabled && fxaa._isSupported(context);\n\n  if (\n    activeStagesChanged ||\n    this._textureCacheDirty ||\n    aoEnabled !== this._aoEnabled ||\n    bloomEnabled !== this._bloomEnabled ||\n    tonemappingEnabled !== this._tonemappingEnabled ||\n    fxaaEnabled !== this._fxaaEnabled\n  ) {\n    // The number of stages to execute has changed.\n    // Update dependencies and recreate framebuffers.\n    this._textureCache.updateDependencies();\n\n    this._aoEnabled = aoEnabled;\n    this._bloomEnabled = bloomEnabled;\n    this._tonemappingEnabled = tonemappingEnabled;\n    this._fxaaEnabled = fxaaEnabled;\n    this._textureCacheDirty = false;\n  }\n\n  if (defined(this._randomTexture) && !aoEnabled) {\n    this._randomTexture.destroy();\n    this._randomTexture = undefined;\n  }\n\n  if (!defined(this._randomTexture) && aoEnabled) {\n    length = 256 * 256 * 3;\n    const random = new Uint8Array(length);\n    for (i = 0; i < length; i += 3) {\n      random[i] = Math.floor(Math.random() * 255.0);\n    }\n\n    this._randomTexture = new Texture({\n      context: context,\n      pixelFormat: PixelFormat.RGB,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: random,\n        width: 256,\n        height: 256,\n      },\n      sampler: new Sampler({\n        wrapS: TextureWrap.REPEAT,\n        wrapT: TextureWrap.REPEAT,\n        minificationFilter: TextureMinificationFilter.NEAREST,\n        magnificationFilter: TextureMagnificationFilter.NEAREST,\n      }),\n    });\n  }\n\n  this._textureCache.update(context);\n\n  fxaa.update(context, useLogDepth);\n  ao.update(context, useLogDepth);\n  bloom.update(context, useLogDepth);\n  tonemapping.update(context, useLogDepth);\n\n  if (this._autoExposureEnabled) {\n    autoexposure.update(context, useLogDepth);\n  }\n\n  length = stages.length;\n  for (i = 0; i < length; ++i) {\n    stages[i].update(context, useLogDepth);\n  }\n\n  count = 0;\n  for (i = 0; i < length; ++i) {\n    stage = stages[i];\n    if (stage.ready && stage.enabled && stage._isSupported(context)) {\n      count++;\n    }\n  }\n\n  activeStagesChanged = count !== activeStages.length;\n  if (activeStagesChanged) {\n    this.update(context, useLogDepth, useHdr);\n  }\n};\n\n/**\n * Clears all of the framebuffers used by the stages.\n *\n * @param {Context} context The context.\n *\n * @private\n */\nPostProcessStageCollection.prototype.clear = function (context) {\n  this._textureCache.clear(context);\n\n  if (this._autoExposureEnabled) {\n    this._autoExposure.clear(context);\n  }\n};\n\nfunction getOutputTexture(stage) {\n  while (defined(stage.length)) {\n    stage = stage.get(stage.length - 1);\n  }\n  return stage.outputTexture;\n}\n\n/**\n * Gets the output texture of a stage with the given name.\n *\n * @param {String} stageName The name of the stage.\n * @return {Texture|undefined} The texture rendered to by the stage with the given name.\n *\n * @private\n */\nPostProcessStageCollection.prototype.getOutputTexture = function (stageName) {\n  const stage = this.getStageByName(stageName);\n  if (!defined(stage)) {\n    return undefined;\n  }\n  return getOutputTexture(stage);\n};\n\nfunction execute(stage, context, colorTexture, depthTexture, idTexture) {\n  if (defined(stage.execute)) {\n    stage.execute(context, colorTexture, depthTexture, idTexture);\n    return;\n  }\n\n  const length = stage.length;\n  let i;\n\n  if (stage.inputPreviousStageTexture) {\n    execute(stage.get(0), context, colorTexture, depthTexture, idTexture);\n    for (i = 1; i < length; ++i) {\n      execute(\n        stage.get(i),\n        context,\n        getOutputTexture(stage.get(i - 1)),\n        depthTexture,\n        idTexture\n      );\n    }\n  } else {\n    for (i = 0; i < length; ++i) {\n      execute(stage.get(i), context, colorTexture, depthTexture, idTexture);\n    }\n  }\n}\n\n/**\n * Executes all ready and enabled stages in the collection.\n *\n * @param {Context} context The context.\n * @param {Texture} colorTexture The color texture rendered to by the scene.\n * @param {Texture} depthTexture The depth texture written to by the scene.\n * @param {Texture} idTexture The id texture written to by the scene.\n *\n * @private\n */\nPostProcessStageCollection.prototype.execute = function (\n  context,\n  colorTexture,\n  depthTexture,\n  idTexture\n) {\n  const activeStages = this._activeStages;\n  const length = activeStages.length;\n  const fxaa = this._fxaa;\n  const ao = this._ao;\n  const bloom = this._bloom;\n  const autoexposure = this._autoExposure;\n  const tonemapping = this._tonemapping;\n\n  const aoEnabled = ao.enabled && ao._isSupported(context);\n  const bloomEnabled = bloom.enabled && bloom._isSupported(context);\n  const autoExposureEnabled = this._autoExposureEnabled;\n  const tonemappingEnabled =\n    tonemapping.enabled && tonemapping._isSupported(context);\n  const fxaaEnabled = fxaa.enabled && fxaa._isSupported(context);\n\n  if (\n    !fxaaEnabled &&\n    !aoEnabled &&\n    !bloomEnabled &&\n    !tonemappingEnabled &&\n    length === 0\n  ) {\n    return;\n  }\n\n  let initialTexture = colorTexture;\n  if (aoEnabled && ao.ready) {\n    execute(ao, context, initialTexture, depthTexture, idTexture);\n    initialTexture = getOutputTexture(ao);\n  }\n  if (bloomEnabled && bloom.ready) {\n    execute(bloom, context, initialTexture, depthTexture, idTexture);\n    initialTexture = getOutputTexture(bloom);\n  }\n  if (autoExposureEnabled && autoexposure.ready) {\n    execute(autoexposure, context, initialTexture, depthTexture, idTexture);\n  }\n  if (tonemappingEnabled && tonemapping.ready) {\n    execute(tonemapping, context, initialTexture, depthTexture, idTexture);\n    initialTexture = getOutputTexture(tonemapping);\n  }\n\n  let lastTexture = initialTexture;\n\n  if (length > 0) {\n    execute(activeStages[0], context, initialTexture, depthTexture, idTexture);\n    for (let i = 1; i < length; ++i) {\n      execute(\n        activeStages[i],\n        context,\n        getOutputTexture(activeStages[i - 1]),\n        depthTexture,\n        idTexture\n      );\n    }\n    lastTexture = getOutputTexture(activeStages[length - 1]);\n  }\n\n  if (fxaaEnabled && fxaa.ready) {\n    execute(fxaa, context, lastTexture, depthTexture, idTexture);\n  }\n};\n\n/**\n * Copies the output of all executed stages to the color texture of a framebuffer.\n *\n * @param {Context} context The context.\n * @param {Framebuffer} framebuffer The framebuffer to copy to.\n *\n * @private\n */\nPostProcessStageCollection.prototype.copy = function (context, framebuffer) {\n  if (!defined(this._copyColorCommand)) {\n    const that = this;\n    this._copyColorCommand = context.createViewportQuadCommand(PassThrough, {\n      uniformMap: {\n        colorTexture: function () {\n          return that.outputTexture;\n        },\n      },\n      owner: this,\n    });\n  }\n\n  this._copyColorCommand.framebuffer = framebuffer;\n  this._copyColorCommand.execute(context);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStageCollection#destroy\n */\nPostProcessStageCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStageCollection#isDestroyed\n */\nPostProcessStageCollection.prototype.destroy = function () {\n  this._fxaa.destroy();\n  this._ao.destroy();\n  this._bloom.destroy();\n  this._autoExposure.destroy();\n  this._tonemapping.destroy();\n  this.removeAll();\n  this._textureCache = this._textureCache && this._textureCache.destroy();\n  return destroyObject(this);\n};\nexport default PostProcessStageCollection;\n","import Check from \"../Core/Check.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\n\n/**\n * A collection of {@link PostProcessStage}s or other post-process composite stages that execute together logically.\n * <p>\n * All stages are executed in the order of the array. The input texture changes based on the value of <code>inputPreviousStageTexture</code>.\n * If <code>inputPreviousStageTexture</code> is <code>true</code>, the input to each stage is the output texture rendered to by the scene or of the stage that executed before it.\n * If <code>inputPreviousStageTexture</code> is <code>false</code>, the input texture is the same for each stage in the composite. The input texture is the texture rendered to by the scene\n * or the output texture of the previous stage.\n * </p>\n *\n * @alias PostProcessStageComposite\n * @constructor\n *\n * @param {Object} options An object with the following properties:\n * @param {Array} options.stages An array of {@link PostProcessStage}s or composites to be executed in order.\n * @param {Boolean} [options.inputPreviousStageTexture=true] Whether to execute each post-process stage where the input to one stage is the output of the previous. Otherwise, the input to each contained stage is the output of the stage that executed before the composite.\n * @param {String} [options.name=createGuid()] The unique name of this post-process stage for reference by other composites. If a name is not supplied, a GUID will be generated.\n * @param {Object} [options.uniforms] An alias to the uniforms of post-process stages.\n *\n * @exception {DeveloperError} options.stages.length must be greater than 0.0.\n *\n * @see PostProcessStage\n *\n * @example\n * // Example 1: separable blur filter\n * // The input to blurXDirection is the texture rendered to by the scene or the output of the previous stage.\n * // The input to blurYDirection is the texture rendered to by blurXDirection.\n * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({\n *     stages : [blurXDirection, blurYDirection]\n * }));\n *\n * @example\n * // Example 2: referencing the output of another post-process stage\n * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({\n *     inputPreviousStageTexture : false,\n *     stages : [\n *         // The same as Example 1.\n *         new Cesium.PostProcessStageComposite({\n *             inputPreviousStageTexture : true\n *             stages : [blurXDirection, blurYDirection],\n *             name : 'blur'\n *         }),\n *         // The input texture for this stage is the same input texture to blurXDirection since inputPreviousStageTexture is false\n *         new Cesium.PostProcessStage({\n *             fragmentShader : compositeShader,\n *             uniforms : {\n *                 blurTexture : 'blur' // The output of the composite with name 'blur' (the texture that blurYDirection rendered to).\n *             }\n *         })\n *     ]\n * });\n *\n * @example\n * // Example 3: create a uniform alias\n * const uniforms = {};\n * Cesium.defineProperties(uniforms, {\n *     filterSize : {\n *         get : function() {\n *             return blurXDirection.uniforms.filterSize;\n *         },\n *         set : function(value) {\n *             blurXDirection.uniforms.filterSize = blurYDirection.uniforms.filterSize = value;\n *         }\n *     }\n * });\n * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({\n *     stages : [blurXDirection, blurYDirection],\n *     uniforms : uniforms\n * }));\n */\nfunction PostProcessStageComposite(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.stages\", options.stages);\n  Check.typeOf.number.greaterThan(\n    \"options.stages.length\",\n    options.stages.length,\n    0\n  );\n  //>>includeEnd('debug');\n\n  this._stages = options.stages;\n  this._inputPreviousStageTexture = defaultValue(\n    options.inputPreviousStageTexture,\n    true\n  );\n\n  let name = options.name;\n  if (!defined(name)) {\n    name = createGuid();\n  }\n  this._name = name;\n\n  this._uniforms = options.uniforms;\n\n  // used by PostProcessStageCollection\n  this._textureCache = undefined;\n  this._index = undefined;\n\n  this._selected = undefined;\n  this._selectedShadow = undefined;\n  this._parentSelected = undefined;\n  this._parentSelectedShadow = undefined;\n  this._combinedSelected = undefined;\n  this._combinedSelectedShadow = undefined;\n  this._selectedLength = 0;\n  this._parentSelectedLength = 0;\n  this._selectedDirty = true;\n}\n\nObject.defineProperties(PostProcessStageComposite.prototype, {\n  /**\n   * Determines if this post-process stage is ready to be executed.\n   *\n   * @memberof PostProcessStageComposite.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      const stages = this._stages;\n      const length = stages.length;\n      for (let i = 0; i < length; ++i) {\n        if (!stages[i].ready) {\n          return false;\n        }\n      }\n      return true;\n    },\n  },\n  /**\n   * The unique name of this post-process stage for reference by other stages in a PostProcessStageComposite.\n   *\n   * @memberof PostProcessStageComposite.prototype\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * Whether or not to execute this post-process stage when ready.\n   *\n   * @memberof PostProcessStageComposite.prototype\n   * @type {Boolean}\n   */\n  enabled: {\n    get: function () {\n      return this._stages[0].enabled;\n    },\n    set: function (value) {\n      const stages = this._stages;\n      const length = stages.length;\n      for (let i = 0; i < length; ++i) {\n        stages[i].enabled = value;\n      }\n    },\n  },\n  /**\n   * An alias to the uniform values of the post-process stages. May be <code>undefined</code>; in which case, get each stage to set uniform values.\n   * @memberof PostProcessStageComposite.prototype\n   * @type {Object}\n   */\n  uniforms: {\n    get: function () {\n      return this._uniforms;\n    },\n  },\n  /**\n   * All post-process stages are executed in the order of the array. The input texture changes based on the value of <code>inputPreviousStageTexture</code>.\n   * If <code>inputPreviousStageTexture</code> is <code>true</code>, the input to each stage is the output texture rendered to by the scene or of the stage that executed before it.\n   * If <code>inputPreviousStageTexture</code> is <code>false</code>, the input texture is the same for each stage in the composite. The input texture is the texture rendered to by the scene\n   * or the output texture of the previous stage.\n   *\n   * @memberof PostProcessStageComposite.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  inputPreviousStageTexture: {\n    get: function () {\n      return this._inputPreviousStageTexture;\n    },\n  },\n  /**\n   * The number of post-process stages in this composite.\n   *\n   * @memberof PostProcessStageComposite.prototype\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._stages.length;\n    },\n  },\n  /**\n   * The features selected for applying the post-process.\n   *\n   * @memberof PostProcessStageComposite.prototype\n   * @type {Array}\n   */\n  selected: {\n    get: function () {\n      return this._selected;\n    },\n    set: function (value) {\n      this._selected = value;\n    },\n  },\n  /**\n   * @private\n   */\n  parentSelected: {\n    get: function () {\n      return this._parentSelected;\n    },\n    set: function (value) {\n      this._parentSelected = value;\n    },\n  },\n});\n\n/**\n * @private\n */\nPostProcessStageComposite.prototype._isSupported = function (context) {\n  const stages = this._stages;\n  const length = stages.length;\n  for (let i = 0; i < length; ++i) {\n    if (!stages[i]._isSupported(context)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Gets the post-process stage at <code>index</code>\n *\n * @param {Number} index The index of the post-process stage or composite.\n * @return {PostProcessStage|PostProcessStageComposite} The post-process stage or composite at index.\n *\n * @exception {DeveloperError} index must be greater than or equal to 0.\n * @exception {DeveloperError} index must be less than {@link PostProcessStageComposite#length}.\n */\nPostProcessStageComposite.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThan(\"index\", index, this.length);\n  //>>includeEnd('debug');\n  return this._stages[index];\n};\n\nfunction isSelectedTextureDirty(stage) {\n  let length = defined(stage._selected) ? stage._selected.length : 0;\n  const parentLength = defined(stage._parentSelected)\n    ? stage._parentSelected\n    : 0;\n  let dirty =\n    stage._selected !== stage._selectedShadow ||\n    length !== stage._selectedLength;\n  dirty =\n    dirty ||\n    stage._parentSelected !== stage._parentSelectedShadow ||\n    parentLength !== stage._parentSelectedLength;\n\n  if (defined(stage._selected) && defined(stage._parentSelected)) {\n    stage._combinedSelected = stage._selected.concat(stage._parentSelected);\n  } else if (defined(stage._parentSelected)) {\n    stage._combinedSelected = stage._parentSelected;\n  } else {\n    stage._combinedSelected = stage._selected;\n  }\n\n  if (!dirty && defined(stage._combinedSelected)) {\n    if (!defined(stage._combinedSelectedShadow)) {\n      return true;\n    }\n\n    length = stage._combinedSelected.length;\n    for (let i = 0; i < length; ++i) {\n      if (stage._combinedSelected[i] !== stage._combinedSelectedShadow[i]) {\n        return true;\n      }\n    }\n  }\n  return dirty;\n}\n\n/**\n * A function that will be called before execute. Updates each post-process stage in the composite.\n * @param {Context} context The context.\n * @param {Boolean} useLogDepth Whether the scene uses a logarithmic depth buffer.\n * @private\n */\nPostProcessStageComposite.prototype.update = function (context, useLogDepth) {\n  this._selectedDirty = isSelectedTextureDirty(this);\n\n  this._selectedShadow = this._selected;\n  this._parentSelectedShadow = this._parentSelected;\n  this._combinedSelectedShadow = this._combinedSelected;\n  this._selectedLength = defined(this._selected) ? this._selected.length : 0;\n  this._parentSelectedLength = defined(this._parentSelected)\n    ? this._parentSelected.length\n    : 0;\n\n  const stages = this._stages;\n  const length = stages.length;\n  for (let i = 0; i < length; ++i) {\n    const stage = stages[i];\n    if (this._selectedDirty) {\n      stage.parentSelected = this._combinedSelected;\n    }\n    stage.update(context, useLogDepth);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStageComposite#destroy\n */\nPostProcessStageComposite.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStageComposite#isDestroyed\n */\nPostProcessStageComposite.prototype.destroy = function () {\n  const stages = this._stages;\n  const length = stages.length;\n  for (let i = 0; i < length; ++i) {\n    stages[i].destroy();\n  }\n  return destroyObject(this);\n};\nexport default PostProcessStageComposite;\n","import buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport AcesTonemapping from \"../Shaders/PostProcessStages/AcesTonemappingStage.js\";\nimport AmbientOcclusionGenerate from \"../Shaders/PostProcessStages/AmbientOcclusionGenerate.js\";\nimport AmbientOcclusionModulate from \"../Shaders/PostProcessStages/AmbientOcclusionModulate.js\";\nimport BlackAndWhite from \"../Shaders/PostProcessStages/BlackAndWhite.js\";\nimport BloomComposite from \"../Shaders/PostProcessStages/BloomComposite.js\";\nimport Brightness from \"../Shaders/PostProcessStages/Brightness.js\";\nimport ContrastBias from \"../Shaders/PostProcessStages/ContrastBias.js\";\nimport DepthOfField from \"../Shaders/PostProcessStages/DepthOfField.js\";\nimport DepthView from \"../Shaders/PostProcessStages/DepthView.js\";\nimport EdgeDetection from \"../Shaders/PostProcessStages/EdgeDetection.js\";\nimport FilmicTonemapping from \"../Shaders/PostProcessStages/FilmicTonemapping.js\";\nimport FXAA from \"../Shaders/PostProcessStages/FXAA.js\";\nimport GaussianBlur1D from \"../Shaders/PostProcessStages/GaussianBlur1D.js\";\nimport LensFlare from \"../Shaders/PostProcessStages/LensFlare.js\";\nimport ModifiedReinhardTonemapping from \"../Shaders/PostProcessStages/ModifiedReinhardTonemapping.js\";\nimport NightVision from \"../Shaders/PostProcessStages/NightVision.js\";\nimport ReinhardTonemapping from \"../Shaders/PostProcessStages/ReinhardTonemapping.js\";\nimport Silhouette from \"../Shaders/PostProcessStages/Silhouette.js\";\nimport FXAA3_11 from \"../Shaders/FXAA3_11.js\";\nimport AutoExposure from \"./AutoExposure.js\";\nimport PostProcessStage from \"./PostProcessStage.js\";\nimport PostProcessStageComposite from \"./PostProcessStageComposite.js\";\nimport PostProcessStageSampleMode from \"./PostProcessStageSampleMode.js\";\n\n/**\n * Contains functions for creating common post-process stages.\n *\n * @namespace PostProcessStageLibrary\n */\nconst PostProcessStageLibrary = {};\n\nfunction createBlur(name) {\n  const delta = 1.0;\n  const sigma = 2.0;\n  const stepSize = 1.0;\n\n  const blurShader = `#define USE_STEP_SIZE\\n${GaussianBlur1D}`;\n  const blurX = new PostProcessStage({\n    name: `${name}_x_direction`,\n    fragmentShader: blurShader,\n    uniforms: {\n      delta: delta,\n      sigma: sigma,\n      stepSize: stepSize,\n      direction: 0.0,\n    },\n    sampleMode: PostProcessStageSampleMode.LINEAR,\n  });\n  const blurY = new PostProcessStage({\n    name: `${name}_y_direction`,\n    fragmentShader: blurShader,\n    uniforms: {\n      delta: delta,\n      sigma: sigma,\n      stepSize: stepSize,\n      direction: 1.0,\n    },\n    sampleMode: PostProcessStageSampleMode.LINEAR,\n  });\n\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    delta: {\n      get: function () {\n        return blurX.uniforms.delta;\n      },\n      set: function (value) {\n        const blurXUniforms = blurX.uniforms;\n        const blurYUniforms = blurY.uniforms;\n        blurXUniforms.delta = blurYUniforms.delta = value;\n      },\n    },\n    sigma: {\n      get: function () {\n        return blurX.uniforms.sigma;\n      },\n      set: function (value) {\n        const blurXUniforms = blurX.uniforms;\n        const blurYUniforms = blurY.uniforms;\n        blurXUniforms.sigma = blurYUniforms.sigma = value;\n      },\n    },\n    stepSize: {\n      get: function () {\n        return blurX.uniforms.stepSize;\n      },\n      set: function (value) {\n        const blurXUniforms = blurX.uniforms;\n        const blurYUniforms = blurY.uniforms;\n        blurXUniforms.stepSize = blurYUniforms.stepSize = value;\n      },\n    },\n  });\n  return new PostProcessStageComposite({\n    name: name,\n    stages: [blurX, blurY],\n    uniforms: uniforms,\n  });\n}\n\n/**\n * Creates a post-process stage that applies a Gaussian blur to the input texture. This stage is usually applied in conjunction with another stage.\n * <p>\n * This stage has the following uniforms: <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n * </p>\n * <p>\n * <code>delta</code> and <code>sigma</code> are used to compute the weights of a Gaussian filter. The equation is <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>.\n * The default value for <code>delta</code> is <code>1.0</code>. The default value for <code>sigma</code> is <code>2.0</code>.\n * <code>stepSize</code> is the distance to the next texel. The default is <code>1.0</code>.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage that applies a Gaussian blur to the input texture.\n */\nPostProcessStageLibrary.createBlurStage = function () {\n  return createBlur(\"czm_blur\");\n};\n\n/**\n * Creates a post-process stage that applies a depth of field effect.\n * <p>\n * Depth of field simulates camera focus. Objects in the scene that are in focus\n * will be clear whereas objects not in focus will be blurred.\n * </p>\n * <p>\n * This stage has the following uniforms: <code>focalDistance</code>, <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n * </p>\n * <p>\n * <code>focalDistance</code> is the distance in meters from the camera to set the camera focus.\n * </p>\n * <p>\n * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n * The blur is applied to the areas out of focus.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage that applies a depth of field effect.\n */\nPostProcessStageLibrary.createDepthOfFieldStage = function () {\n  const blur = createBlur(\"czm_depth_of_field_blur\");\n  const dof = new PostProcessStage({\n    name: \"czm_depth_of_field_composite\",\n    fragmentShader: DepthOfField,\n    uniforms: {\n      focalDistance: 5.0,\n      blurTexture: blur.name,\n    },\n  });\n\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    focalDistance: {\n      get: function () {\n        return dof.uniforms.focalDistance;\n      },\n      set: function (value) {\n        dof.uniforms.focalDistance = value;\n      },\n    },\n    delta: {\n      get: function () {\n        return blur.uniforms.delta;\n      },\n      set: function (value) {\n        blur.uniforms.delta = value;\n      },\n    },\n    sigma: {\n      get: function () {\n        return blur.uniforms.sigma;\n      },\n      set: function (value) {\n        blur.uniforms.sigma = value;\n      },\n    },\n    stepSize: {\n      get: function () {\n        return blur.uniforms.stepSize;\n      },\n      set: function (value) {\n        blur.uniforms.stepSize = value;\n      },\n    },\n  });\n  return new PostProcessStageComposite({\n    name: \"czm_depth_of_field\",\n    stages: [blur, dof],\n    inputPreviousStageTexture: false,\n    uniforms: uniforms,\n  });\n};\n\n/**\n * Whether or not a depth of field stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {Boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isDepthOfFieldSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\n/**\n * Creates a post-process stage that detects edges.\n * <p>\n * Writes the color to the output texture with alpha set to 1.0 when it is on an edge.\n * </p>\n * <p>\n * This stage has the following uniforms: <code>color</code> and <code>length</code>\n * </p>\n * <ul>\n * <li><code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.</li>\n * <li><code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.</li>\n * </ul>\n * <p>\n * This stage is not supported in 2D.\n * </p>\n * @return {PostProcessStage} A post-process stage that applies an edge detection effect.\n *\n * @example\n * // multiple silhouette effects\n * const yellowEdge = Cesium.PostProcessLibrary.createEdgeDetectionStage();\n * yellowEdge.uniforms.color = Cesium.Color.YELLOW;\n * yellowEdge.selected = [feature0];\n *\n * const greenEdge = Cesium.PostProcessLibrary.createEdgeDetectionStage();\n * greenEdge.uniforms.color = Cesium.Color.LIME;\n * greenEdge.selected = [feature1];\n *\n * // draw edges around feature0 and feature1\n * postProcessStages.add(Cesium.PostProcessLibrary.createSilhouetteStage([yellowEdge, greenEdge]);\n */\nPostProcessStageLibrary.createEdgeDetectionStage = function () {\n  // unique name generated on call so more than one effect can be added\n  const name = createGuid();\n  return new PostProcessStage({\n    name: `czm_edge_detection_${name}`,\n    fragmentShader: EdgeDetection,\n    uniforms: {\n      length: 0.25,\n      color: Color.clone(Color.BLACK),\n    },\n  });\n};\n\n/**\n * Whether or not an edge detection stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {Boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isEdgeDetectionSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\nfunction getSilhouetteEdgeDetection(edgeDetectionStages) {\n  if (!defined(edgeDetectionStages)) {\n    return PostProcessStageLibrary.createEdgeDetectionStage();\n  }\n\n  const edgeDetection = new PostProcessStageComposite({\n    name: \"czm_edge_detection_multiple\",\n    stages: edgeDetectionStages,\n    inputPreviousStageTexture: false,\n  });\n\n  const compositeUniforms = {};\n  let fsDecl = \"\";\n  let fsLoop = \"\";\n  for (let i = 0; i < edgeDetectionStages.length; ++i) {\n    fsDecl += `uniform sampler2D edgeTexture${i}; \\n`;\n    fsLoop +=\n      `        vec4 edge${i} = texture2D(edgeTexture${i}, v_textureCoordinates); \\n` +\n      `        if (edge${i}.a > 0.0) \\n` +\n      `        { \\n` +\n      `            color = edge${i}; \\n` +\n      `            break; \\n` +\n      `        } \\n`;\n    compositeUniforms[`edgeTexture${i}`] = edgeDetectionStages[i].name;\n  }\n\n  const fs =\n    `${fsDecl}varying vec2 v_textureCoordinates; \\n` +\n    `void main() { \\n` +\n    `    vec4 color = vec4(0.0); \\n` +\n    `    for (int i = 0; i < ${edgeDetectionStages.length}; i++) \\n` +\n    `    { \\n${fsLoop}    } \\n` +\n    `    gl_FragColor = color; \\n` +\n    `} \\n`;\n\n  const edgeComposite = new PostProcessStage({\n    name: \"czm_edge_detection_combine\",\n    fragmentShader: fs,\n    uniforms: compositeUniforms,\n  });\n  return new PostProcessStageComposite({\n    name: \"czm_edge_detection_composite\",\n    stages: [edgeDetection, edgeComposite],\n  });\n}\n\n/**\n * Creates a post-process stage that applies a silhouette effect.\n * <p>\n * A silhouette effect composites the color from the edge detection pass with input color texture.\n * </p>\n * <p>\n * This stage has the following uniforms when <code>edgeDetectionStages</code> is <code>undefined</code>: <code>color</code> and <code>length</code>\n * </p>\n * <p>\n * <code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.\n * <code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.\n * </p>\n * @param {PostProcessStage[]} [edgeDetectionStages] An array of edge detection post process stages.\n * @return {PostProcessStageComposite} A post-process stage that applies a silhouette effect.\n */\nPostProcessStageLibrary.createSilhouetteStage = function (edgeDetectionStages) {\n  const edgeDetection = getSilhouetteEdgeDetection(edgeDetectionStages);\n  const silhouetteProcess = new PostProcessStage({\n    name: \"czm_silhouette_color_edges\",\n    fragmentShader: Silhouette,\n    uniforms: {\n      silhouetteTexture: edgeDetection.name,\n    },\n  });\n\n  return new PostProcessStageComposite({\n    name: \"czm_silhouette\",\n    stages: [edgeDetection, silhouetteProcess],\n    inputPreviousStageTexture: false,\n    uniforms: edgeDetection.uniforms,\n  });\n};\n\n/**\n * Whether or not a silhouette stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {Boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isSilhouetteSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\n/**\n * Creates a post-process stage that applies a bloom effect to the input texture.\n * <p>\n * A bloom effect adds glow effect, makes bright areas brighter, and dark areas darker.\n * </p>\n * <p>\n * This post-process stage has the following uniforms: <code>contrast</code>, <code>brightness</code>, <code>glowOnly</code>,\n * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.\n * </p>\n * <ul>\n * <li><code>contrast</code> is a scalar value in the range [-255.0, 255.0] and affects the contract of the effect. The default value is <code>128.0</code>.</li>\n * <li><code>brightness</code> is a scalar value. The input texture RGB value is converted to hue, saturation, and brightness (HSB) then this value is\n * added to the brightness. The default value is <code>-0.3</code>.</li>\n * <li><code>glowOnly</code> is a boolean value. When <code>true</code>, only the glow effect will be shown. When <code>false</code>, the glow will be added to the input texture.\n * The default value is <code>false</code>. This is a debug option for viewing the effects when changing the other uniform values.</li>\n * </ul>\n * <p>\n * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage to applies a bloom effect.\n *\n * @private\n */\nPostProcessStageLibrary.createBloomStage = function () {\n  const contrastBias = new PostProcessStage({\n    name: \"czm_bloom_contrast_bias\",\n    fragmentShader: ContrastBias,\n    uniforms: {\n      contrast: 128.0,\n      brightness: -0.3,\n    },\n  });\n  const blur = createBlur(\"czm_bloom_blur\");\n  const generateComposite = new PostProcessStageComposite({\n    name: \"czm_bloom_contrast_bias_blur\",\n    stages: [contrastBias, blur],\n  });\n\n  const bloomComposite = new PostProcessStage({\n    name: \"czm_bloom_generate_composite\",\n    fragmentShader: BloomComposite,\n    uniforms: {\n      glowOnly: false,\n      bloomTexture: generateComposite.name,\n    },\n  });\n\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    glowOnly: {\n      get: function () {\n        return bloomComposite.uniforms.glowOnly;\n      },\n      set: function (value) {\n        bloomComposite.uniforms.glowOnly = value;\n      },\n    },\n    contrast: {\n      get: function () {\n        return contrastBias.uniforms.contrast;\n      },\n      set: function (value) {\n        contrastBias.uniforms.contrast = value;\n      },\n    },\n    brightness: {\n      get: function () {\n        return contrastBias.uniforms.brightness;\n      },\n      set: function (value) {\n        contrastBias.uniforms.brightness = value;\n      },\n    },\n    delta: {\n      get: function () {\n        return blur.uniforms.delta;\n      },\n      set: function (value) {\n        blur.uniforms.delta = value;\n      },\n    },\n    sigma: {\n      get: function () {\n        return blur.uniforms.sigma;\n      },\n      set: function (value) {\n        blur.uniforms.sigma = value;\n      },\n    },\n    stepSize: {\n      get: function () {\n        return blur.uniforms.stepSize;\n      },\n      set: function (value) {\n        blur.uniforms.stepSize = value;\n      },\n    },\n  });\n\n  return new PostProcessStageComposite({\n    name: \"czm_bloom\",\n    stages: [generateComposite, bloomComposite],\n    inputPreviousStageTexture: false,\n    uniforms: uniforms,\n  });\n};\n\n/**\n * Creates a post-process stage that Horizon-based Ambient Occlusion (HBAO) to the input texture.\n * <p>\n * Ambient occlusion simulates shadows from ambient light. These shadows would always be present when the\n * surface receives light and regardless of the light's position.\n * </p>\n * <p>\n * The uniforms have the following properties: <code>intensity</code>, <code>bias</code>, <code>lengthCap</code>,\n * <code>stepSize</code>, <code>frustumLength</code>, <code>randomTexture</code>, <code>ambientOcclusionOnly</code>,\n * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code>.\n * </p>\n * <ul>\n * <li><code>intensity</code> is a scalar value used to lighten or darken the shadows exponentially. Higher values make the shadows darker. The default value is <code>3.0</code>.</li>\n * <li><code>bias</code> is a scalar value representing an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value,\n * sampling stops in the current direction. This is used to remove shadows from near planar edges. The default value is <code>0.1</code>.</li>\n * <li><code>lengthCap</code> is a scalar value representing a length in meters. If the distance from the current sample to first sample is greater than this value,\n * sampling stops in the current direction. The default value is <code>0.26</code>.</li>\n * <li><code>stepSize</code> is a scalar value indicating the distance to the next texel sample in the current direction. The default value is <code>1.95</code>.</li>\n * <li><code>frustumLength</code> is a scalar value in meters. If the current fragment has a distance from the camera greater than this value, ambient occlusion is not computed for the fragment.\n * The default value is <code>1000.0</code>.</li>\n * <li><code>randomTexture</code> is a texture where the red channel is a random value in [0.0, 1.0]. The default value is <code>undefined</code>. This texture needs to be set.</li>\n * <li><code>ambientOcclusionOnly</code> is a boolean value. When <code>true</code>, only the shadows generated are written to the output. When <code>false</code>, the input texture is modulated\n * with the ambient occlusion. This is a useful debug option for seeing the effects of changing the uniform values. The default value is <code>false</code>.</li>\n * </ul>\n * <p>\n * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.\n * The blur is applied to the shadows generated from the image to make them smoother.\n * </p>\n * @return {PostProcessStageComposite} A post-process stage that applies an ambient occlusion effect.\n *\n * @private\n */\nPostProcessStageLibrary.createAmbientOcclusionStage = function () {\n  const generate = new PostProcessStage({\n    name: \"czm_ambient_occlusion_generate\",\n    fragmentShader: AmbientOcclusionGenerate,\n    uniforms: {\n      intensity: 3.0,\n      bias: 0.1,\n      lengthCap: 0.26,\n      stepSize: 1.95,\n      frustumLength: 1000.0,\n      randomTexture: undefined,\n    },\n  });\n  const blur = createBlur(\"czm_ambient_occlusion_blur\");\n  blur.uniforms.stepSize = 0.86;\n  const generateAndBlur = new PostProcessStageComposite({\n    name: \"czm_ambient_occlusion_generate_blur\",\n    stages: [generate, blur],\n  });\n\n  const ambientOcclusionModulate = new PostProcessStage({\n    name: \"czm_ambient_occlusion_composite\",\n    fragmentShader: AmbientOcclusionModulate,\n    uniforms: {\n      ambientOcclusionOnly: false,\n      ambientOcclusionTexture: generateAndBlur.name,\n    },\n  });\n\n  const uniforms = {};\n  Object.defineProperties(uniforms, {\n    intensity: {\n      get: function () {\n        return generate.uniforms.intensity;\n      },\n      set: function (value) {\n        generate.uniforms.intensity = value;\n      },\n    },\n    bias: {\n      get: function () {\n        return generate.uniforms.bias;\n      },\n      set: function (value) {\n        generate.uniforms.bias = value;\n      },\n    },\n    lengthCap: {\n      get: function () {\n        return generate.uniforms.lengthCap;\n      },\n      set: function (value) {\n        generate.uniforms.lengthCap = value;\n      },\n    },\n    stepSize: {\n      get: function () {\n        return generate.uniforms.stepSize;\n      },\n      set: function (value) {\n        generate.uniforms.stepSize = value;\n      },\n    },\n    frustumLength: {\n      get: function () {\n        return generate.uniforms.frustumLength;\n      },\n      set: function (value) {\n        generate.uniforms.frustumLength = value;\n      },\n    },\n    randomTexture: {\n      get: function () {\n        return generate.uniforms.randomTexture;\n      },\n      set: function (value) {\n        generate.uniforms.randomTexture = value;\n      },\n    },\n    delta: {\n      get: function () {\n        return blur.uniforms.delta;\n      },\n      set: function (value) {\n        blur.uniforms.delta = value;\n      },\n    },\n    sigma: {\n      get: function () {\n        return blur.uniforms.sigma;\n      },\n      set: function (value) {\n        blur.uniforms.sigma = value;\n      },\n    },\n    blurStepSize: {\n      get: function () {\n        return blur.uniforms.stepSize;\n      },\n      set: function (value) {\n        blur.uniforms.stepSize = value;\n      },\n    },\n    ambientOcclusionOnly: {\n      get: function () {\n        return ambientOcclusionModulate.uniforms.ambientOcclusionOnly;\n      },\n      set: function (value) {\n        ambientOcclusionModulate.uniforms.ambientOcclusionOnly = value;\n      },\n    },\n  });\n\n  return new PostProcessStageComposite({\n    name: \"czm_ambient_occlusion\",\n    stages: [generateAndBlur, ambientOcclusionModulate],\n    inputPreviousStageTexture: false,\n    uniforms: uniforms,\n  });\n};\n\n/**\n * Whether or not an ambient occlusion stage is supported.\n * <p>\n * This stage requires the WEBGL_depth_texture extension.\n * </p>\n *\n * @param {Scene} scene The scene.\n * @return {Boolean} Whether this post process stage is supported.\n *\n * @see {Context#depthTexture}\n * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}\n */\nPostProcessStageLibrary.isAmbientOcclusionSupported = function (scene) {\n  return scene.context.depthTexture;\n};\n\nconst fxaaFS = `#define FXAA_QUALITY_PRESET 39 \\n${FXAA3_11}\\n${FXAA}`;\n\n/**\n * Creates a post-process stage that applies Fast Approximate Anti-aliasing (FXAA) to the input texture.\n * @return {PostProcessStage} A post-process stage that applies Fast Approximate Anti-aliasing to the input texture.\n *\n * @private\n */\nPostProcessStageLibrary.createFXAAStage = function () {\n  return new PostProcessStage({\n    name: \"czm_FXAA\",\n    fragmentShader: fxaaFS,\n    sampleMode: PostProcessStageSampleMode.LINEAR,\n  });\n};\n\n/**\n * Creates a post-process stage that applies ACES tonemapping operator.\n * @param {Boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies ACES tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createAcesTonemappingStage = function (\n  useAutoExposure\n) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += AcesTonemapping;\n  return new PostProcessStage({\n    name: \"czm_aces\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that applies filmic tonemapping operator.\n * @param {Boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies filmic tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createFilmicTonemappingStage = function (\n  useAutoExposure\n) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += FilmicTonemapping;\n  return new PostProcessStage({\n    name: \"czm_filmic\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that applies Reinhard tonemapping operator.\n * @param {Boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies Reinhard tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createReinhardTonemappingStage = function (\n  useAutoExposure\n) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += ReinhardTonemapping;\n  return new PostProcessStage({\n    name: \"czm_reinhard\",\n    fragmentShader: fs,\n    uniforms: {\n      autoExposure: undefined,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that applies modified Reinhard tonemapping operator.\n * @param {Boolean} useAutoExposure Whether or not to use auto-exposure.\n * @return {PostProcessStage} A post-process stage that applies modified Reinhard tonemapping operator.\n * @private\n */\nPostProcessStageLibrary.createModifiedReinhardTonemappingStage = function (\n  useAutoExposure\n) {\n  let fs = useAutoExposure ? \"#define AUTO_EXPOSURE\\n\" : \"\";\n  fs += ModifiedReinhardTonemapping;\n  return new PostProcessStage({\n    name: \"czm_modified_reinhard\",\n    fragmentShader: fs,\n    uniforms: {\n      white: Color.WHITE,\n      autoExposure: undefined,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that finds the average luminance of the input texture.\n * @return {PostProcessStage} A post-process stage that finds the average luminance of the input texture.\n * @private\n */\nPostProcessStageLibrary.createAutoExposureStage = function () {\n  return new AutoExposure();\n};\n\n/**\n * Creates a post-process stage that renders the input texture with black and white gradations.\n * <p>\n * This stage has one uniform value, <code>gradations</code>, which scales the luminance of each pixel.\n * </p>\n * @return {PostProcessStage} A post-process stage that renders the input texture with black and white gradations.\n */\nPostProcessStageLibrary.createBlackAndWhiteStage = function () {\n  return new PostProcessStage({\n    name: \"czm_black_and_white\",\n    fragmentShader: BlackAndWhite,\n    uniforms: {\n      gradations: 5.0,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that saturates the input texture.\n * <p>\n * This stage has one uniform value, <code>brightness</code>, which scales the saturation of each pixel.\n * </p>\n * @return {PostProcessStage} A post-process stage that saturates the input texture.\n */\nPostProcessStageLibrary.createBrightnessStage = function () {\n  return new PostProcessStage({\n    name: \"czm_brightness\",\n    fragmentShader: Brightness,\n    uniforms: {\n      brightness: 0.5,\n    },\n  });\n};\n\n/**\n * Creates a post-process stage that adds a night vision effect to the input texture.\n * @return {PostProcessStage} A post-process stage that adds a night vision effect to the input texture.\n */\nPostProcessStageLibrary.createNightVisionStage = function () {\n  return new PostProcessStage({\n    name: \"czm_night_vision\",\n    fragmentShader: NightVision,\n  });\n};\n\n/**\n * Creates a post-process stage that replaces the input color texture with a black and white texture representing the fragment depth at each pixel.\n * @return {PostProcessStage} A post-process stage that replaces the input color texture with a black and white texture representing the fragment depth at each pixel.\n *\n * @private\n */\nPostProcessStageLibrary.createDepthViewStage = function () {\n  return new PostProcessStage({\n    name: \"czm_depth_view\",\n    fragmentShader: DepthView,\n  });\n};\n\n/**\n * Creates a post-process stage that applies an effect simulating light flaring a camera lens.\n * <p>\n * This stage has the following uniforms: <code>dirtTexture</code>, <code>starTexture</code>, <code>intensity</code>, <code>distortion</code>, <code>ghostDispersal</code>,\n * <code>haloWidth</code>, <code>dirtAmount</code>, and <code>earthRadius</code>.\n * <ul>\n * <li><code>dirtTexture</code> is a texture sampled to simulate dirt on the lens.</li>\n * <li><code>starTexture</code> is the texture sampled for the star pattern of the flare.</li>\n * <li><code>intensity</code> is a scalar multiplied by the result of the lens flare. The default value is <code>2.0</code>.</li>\n * <li><code>distortion</code> is a scalar value that affects the chromatic effect distortion. The default value is <code>10.0</code>.</li>\n * <li><code>ghostDispersal</code> is a scalar indicating how far the halo effect is from the center of the texture. The default value is <code>0.4</code>.</li>\n * <li><code>haloWidth</code> is a scalar representing the width of the halo  from the ghost dispersal. The default value is <code>0.4</code>.</li>\n * <li><code>dirtAmount</code> is a scalar representing the amount of dirt on the lens. The default value is <code>0.4</code>.</li>\n * <li><code>earthRadius</code> is the maximum radius of the earth. The default value is <code>Ellipsoid.WGS84.maximumRadius</code>.</li>\n * </ul>\n * </p>\n * @return {PostProcessStage} A post-process stage for applying a lens flare effect.\n */\nPostProcessStageLibrary.createLensFlareStage = function () {\n  return new PostProcessStage({\n    name: \"czm_lens_flare\",\n    fragmentShader: LensFlare,\n    uniforms: {\n      dirtTexture: buildModuleUrl(\"Assets/Textures/LensFlare/DirtMask.jpg\"),\n      starTexture: buildModuleUrl(\"Assets/Textures/LensFlare/StarBurst.jpg\"),\n      intensity: 2.0,\n      distortion: 10.0,\n      ghostDispersal: 0.4,\n      haloWidth: 0.4,\n      dirtAmount: 0.4,\n      earthRadius: Ellipsoid.WGS84.maximumRadius,\n    },\n  });\n};\nexport default PostProcessStageLibrary;\n","/**\n * Determines how input texture to a {@link PostProcessStage} is sampled.\n *\n * @enum {Number}\n */\nconst PostProcessStageSampleMode = {\n  /**\n   * Samples the texture by returning the closest texel.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NEAREST: 0,\n  /**\n   * Samples the texture through bi-linear interpolation of the four nearest texels.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LINEAR: 1,\n};\nexport default PostProcessStageSampleMode;\n","import Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\n\n/**\n * Creates a minimal amount of textures and framebuffers.\n *\n * @alias PostProcessStageTextureCache\n * @constructor\n *\n * @param {PostProcessStageCollection} postProcessStageCollection The post process collection.\n *\n * @private\n */\nfunction PostProcessStageTextureCache(postProcessStageCollection) {\n  this._collection = postProcessStageCollection;\n\n  this._framebuffers = [];\n  this._stageNameToFramebuffer = {};\n\n  this._width = undefined;\n  this._height = undefined;\n  this._updateDependencies = false;\n}\n\nfunction getLastStageName(stage) {\n  while (defined(stage.length)) {\n    stage = stage.get(stage.length - 1);\n  }\n  return stage.name;\n}\n\nfunction getStageDependencies(\n  collection,\n  context,\n  dependencies,\n  stage,\n  previousName\n) {\n  if (!stage.enabled || !stage._isSupported(context)) {\n    return previousName;\n  }\n\n  const stageDependencies = (dependencies[stage.name] = {});\n  if (defined(previousName)) {\n    const previous = collection.getStageByName(previousName);\n    stageDependencies[getLastStageName(previous)] = true;\n  }\n  const uniforms = stage.uniforms;\n  if (defined(uniforms)) {\n    const uniformNames = Object.getOwnPropertyNames(uniforms);\n    const uniformNamesLength = uniformNames.length;\n    for (let i = 0; i < uniformNamesLength; ++i) {\n      const value = uniforms[uniformNames[i]];\n      if (typeof value === \"string\") {\n        const dependent = collection.getStageByName(value);\n        if (defined(dependent)) {\n          stageDependencies[getLastStageName(dependent)] = true;\n        }\n      }\n    }\n  }\n\n  return stage.name;\n}\n\nfunction getCompositeDependencies(\n  collection,\n  context,\n  dependencies,\n  composite,\n  previousName\n) {\n  if (\n    (defined(composite.enabled) && !composite.enabled) ||\n    (defined(composite._isSupported) && !composite._isSupported(context))\n  ) {\n    return previousName;\n  }\n\n  const originalDependency = previousName;\n\n  const inSeries =\n    !defined(composite.inputPreviousStageTexture) ||\n    composite.inputPreviousStageTexture;\n  let currentName = previousName;\n  const length = composite.length;\n  for (let i = 0; i < length; ++i) {\n    const stage = composite.get(i);\n    if (defined(stage.length)) {\n      currentName = getCompositeDependencies(\n        collection,\n        context,\n        dependencies,\n        stage,\n        previousName\n      );\n    } else {\n      currentName = getStageDependencies(\n        collection,\n        context,\n        dependencies,\n        stage,\n        previousName\n      );\n    }\n    // Stages in a series only depend on the previous stage\n    if (inSeries) {\n      previousName = currentName;\n    }\n  }\n\n  // Stages not in a series depend on every stage executed before it since it could reference it as a uniform.\n  // This prevents looking at the dependencies of each stage in the composite, but might create more framebuffers than necessary.\n  // In practice, there are only 2-3 stages in these composites.\n  let j;\n  let name;\n  if (!inSeries) {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n      const currentDependencies = dependencies[name];\n      for (let k = 0; k < j; ++k) {\n        currentDependencies[getLastStageName(composite.get(k))] = true;\n      }\n    }\n  } else {\n    for (j = 1; j < length; ++j) {\n      name = getLastStageName(composite.get(j));\n      if (!defined(dependencies[name])) {\n        dependencies[name] = {};\n      }\n      dependencies[name][originalDependency] = true;\n    }\n  }\n\n  return currentName;\n}\n\nfunction getDependencies(collection, context) {\n  const dependencies = {};\n\n  if (defined(collection.ambientOcclusion)) {\n    const ao = collection.ambientOcclusion;\n    const bloom = collection.bloom;\n    const tonemapping = collection._tonemapping;\n    const fxaa = collection.fxaa;\n\n    let previousName = getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      ao,\n      undefined\n    );\n    previousName = getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      bloom,\n      previousName\n    );\n    previousName = getStageDependencies(\n      collection,\n      context,\n      dependencies,\n      tonemapping,\n      previousName\n    );\n    previousName = getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      collection,\n      previousName\n    );\n    getStageDependencies(collection, context, dependencies, fxaa, previousName);\n  } else {\n    getCompositeDependencies(\n      collection,\n      context,\n      dependencies,\n      collection,\n      undefined\n    );\n  }\n\n  return dependencies;\n}\n\nfunction getFramebuffer(cache, stageName, dependencies) {\n  const collection = cache._collection;\n  const stage = collection.getStageByName(stageName);\n\n  const textureScale = stage._textureScale;\n  const forcePowerOfTwo = stage._forcePowerOfTwo;\n  const pixelFormat = stage._pixelFormat;\n  const pixelDatatype = stage._pixelDatatype;\n  const clearColor = stage._clearColor;\n\n  let i;\n  let framebuffer;\n  const framebuffers = cache._framebuffers;\n  const length = framebuffers.length;\n  for (i = 0; i < length; ++i) {\n    framebuffer = framebuffers[i];\n\n    if (\n      textureScale !== framebuffer.textureScale ||\n      forcePowerOfTwo !== framebuffer.forcePowerOfTwo ||\n      pixelFormat !== framebuffer.pixelFormat ||\n      pixelDatatype !== framebuffer.pixelDatatype ||\n      !Color.equals(clearColor, framebuffer.clearColor)\n    ) {\n      continue;\n    }\n\n    const stageNames = framebuffer.stages;\n    const stagesLength = stageNames.length;\n    let foundConflict = false;\n    for (let j = 0; j < stagesLength; ++j) {\n      if (dependencies[stageNames[j]]) {\n        foundConflict = true;\n        break;\n      }\n    }\n\n    if (!foundConflict) {\n      break;\n    }\n  }\n\n  if (defined(framebuffer) && i < length) {\n    framebuffer.stages.push(stageName);\n    return framebuffer;\n  }\n\n  framebuffer = {\n    textureScale: textureScale,\n    forcePowerOfTwo: forcePowerOfTwo,\n    pixelFormat: pixelFormat,\n    pixelDatatype: pixelDatatype,\n    clearColor: clearColor,\n    stages: [stageName],\n    buffer: new FramebufferManager({\n      pixelFormat: pixelFormat,\n      pixelDatatype: pixelDatatype,\n    }),\n    clear: undefined,\n  };\n\n  framebuffers.push(framebuffer);\n  return framebuffer;\n}\n\nfunction createFramebuffers(cache, context) {\n  const dependencies = getDependencies(cache._collection, context);\n  for (const stageName in dependencies) {\n    if (dependencies.hasOwnProperty(stageName)) {\n      cache._stageNameToFramebuffer[stageName] = getFramebuffer(\n        cache,\n        stageName,\n        dependencies[stageName]\n      );\n    }\n  }\n}\n\nfunction releaseResources(cache) {\n  const framebuffers = cache._framebuffers;\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    const framebuffer = framebuffers[i];\n    framebuffer.buffer.destroy();\n  }\n}\n\nfunction updateFramebuffers(cache, context) {\n  const width = cache._width;\n  const height = cache._height;\n\n  const framebuffers = cache._framebuffers;\n  const length = framebuffers.length;\n  for (let i = 0; i < length; ++i) {\n    const framebuffer = framebuffers[i];\n\n    const scale = framebuffer.textureScale;\n    let textureWidth = Math.ceil(width * scale);\n    let textureHeight = Math.ceil(height * scale);\n\n    let size = Math.min(textureWidth, textureHeight);\n    if (framebuffer.forcePowerOfTwo) {\n      if (!CesiumMath.isPowerOfTwo(size)) {\n        size = CesiumMath.nextPowerOfTwo(size);\n      }\n      textureWidth = size;\n      textureHeight = size;\n    }\n\n    framebuffer.buffer.update(context, textureWidth, textureHeight);\n    framebuffer.clear = new ClearCommand({\n      color: framebuffer.clearColor,\n      framebuffer: framebuffer.buffer.framebuffer,\n    });\n  }\n}\n\nPostProcessStageTextureCache.prototype.updateDependencies = function () {\n  this._updateDependencies = true;\n};\n\n/**\n * Called before the stages in the collection are executed. Creates the minimum amount of framebuffers for a post-process collection.\n *\n * @param {Context} context The context.\n */\nPostProcessStageTextureCache.prototype.update = function (context) {\n  const collection = this._collection;\n  const updateDependencies = this._updateDependencies;\n  const aoEnabled =\n    defined(collection.ambientOcclusion) &&\n    collection.ambientOcclusion.enabled &&\n    collection.ambientOcclusion._isSupported(context);\n  const bloomEnabled =\n    defined(collection.bloom) &&\n    collection.bloom.enabled &&\n    collection.bloom._isSupported(context);\n  const tonemappingEnabled =\n    defined(collection._tonemapping) &&\n    collection._tonemapping.enabled &&\n    collection._tonemapping._isSupported(context);\n  const fxaaEnabled =\n    defined(collection.fxaa) &&\n    collection.fxaa.enabled &&\n    collection.fxaa._isSupported(context);\n  const needsCheckDimensionsUpdate =\n    !defined(collection._activeStages) ||\n    collection._activeStages.length > 0 ||\n    aoEnabled ||\n    bloomEnabled ||\n    tonemappingEnabled ||\n    fxaaEnabled;\n  if (\n    updateDependencies ||\n    (!needsCheckDimensionsUpdate && this._framebuffers.length > 0)\n  ) {\n    releaseResources(this);\n    this._framebuffers.length = 0;\n    this._stageNameToFramebuffer = {};\n    this._width = undefined;\n    this._height = undefined;\n  }\n\n  if (!updateDependencies && !needsCheckDimensionsUpdate) {\n    return;\n  }\n\n  if (this._framebuffers.length === 0) {\n    createFramebuffers(this, context);\n  }\n\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n  const dimensionsChanged = this._width !== width || this._height !== height;\n  if (!updateDependencies && !dimensionsChanged) {\n    return;\n  }\n\n  this._width = width;\n  this._height = height;\n  this._updateDependencies = false;\n  releaseResources(this);\n  updateFramebuffers(this, context);\n};\n\n/**\n * Clears all of the framebuffers.\n *\n * @param {Context} context The context.\n */\nPostProcessStageTextureCache.prototype.clear = function (context) {\n  const framebuffers = this._framebuffers;\n  for (let i = 0; i < framebuffers.length; ++i) {\n    framebuffers[i].clear.execute(context);\n  }\n};\n\n/**\n * Gets the stage with the given name.\n * @param {String} name The name of the stage.\n * @return {PostProcessStage|PostProcessStageComposite}\n */\nPostProcessStageTextureCache.prototype.getStageByName = function (name) {\n  return this._collection.getStageByName(name);\n};\n\n/**\n * Gets the output texture for a stage with the given name.\n * @param {String} name The name of the stage.\n * @return {Texture|undefined} The output texture of the stage with the given name.\n */\nPostProcessStageTextureCache.prototype.getOutputTexture = function (name) {\n  return this._collection.getOutputTexture(name);\n};\n\n/**\n * Gets the framebuffer for a stage with the given name.\n *\n * @param {String} name The name of the stage.\n * @return {Framebuffer|undefined} The framebuffer for the stage with the given name.\n */\nPostProcessStageTextureCache.prototype.getFramebuffer = function (name) {\n  const framebuffer = this._stageNameToFramebuffer[name];\n  if (!defined(framebuffer)) {\n    return undefined;\n  }\n  return framebuffer.buffer.framebuffer;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see PostProcessStageTextureCache#destroy\n */\nPostProcessStageTextureCache.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PostProcessStageTextureCache#isDestroyed\n */\nPostProcessStageTextureCache.prototype.destroy = function () {\n  releaseResources(this);\n  return destroyObject(this);\n};\nexport default PostProcessStageTextureCache;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport subdivideArray from \"../Core/subdivideArray.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport CullFace from \"./CullFace.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PrimitivePipeline from \"./PrimitivePipeline.js\";\nimport PrimitiveState from \"./PrimitiveState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}\n * as shown in example 1 below, or from an array of instances, even if the geometry is from different\n * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.\n * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using\n * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.\n * </p>\n * <p>\n * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples\n * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example\n * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.\n * </p>\n *\n * @alias Primitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {GeometryInstance[]|GeometryInstance} [options.geometryInstances] The geometry instances - or a single geometry instance - to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive.\n * @param {Appearance} [options.depthFailAppearance] The appearance used to shade this primitive when it fails the depth test.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.cull=true] When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {ShadowMode} [options.shadows=ShadowMode.DISABLED] Determines whether this primitive casts or receives shadows from light sources.\n *\n * @example\n * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n * @example\n * // 2. Draw different instances each with a unique color\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),\n *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * const ellipsoidInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipsoidGeometry({\n *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *   id : 'ellipsoid',\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   }\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : [rectangleInstance, ellipsoidInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @example\n * // 3. Create the geometry on the main thread.\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({\n *       radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *     })),\n *     modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *       Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *     id : 'ellipsoid',\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *     }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance(),\n *   asynchronous : false\n * }));\n *\n * @see GeometryInstance\n * @see Appearance\n * @see ClassificationPrimitive\n * @see GroundPrimitive\n */\nfunction Primitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type GeometryInstance[]|GeometryInstance\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = options.appearance;\n  this._appearance = undefined;\n  this._material = undefined;\n\n  /**\n   * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * <p>\n   * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,\n   * add a depthFailColor per-instance attribute instead.\n   * </p>\n   *\n   * <p>\n   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,\n   * there may be artifacts.\n   * </p>\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.depthFailAppearance = options.depthFailAppearance;\n  this._depthFailAppearance = undefined;\n  this._depthFailMaterial = undefined;\n\n  /**\n   * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n   * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * <p>\n   * This property is only supported in 3D mode.\n   * </p>\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   *\n   * @example\n   * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = new Matrix4();\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type Boolean\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  this._vertexCacheOptimize = defaultValue(options.vertexCacheOptimize, false);\n  this._interleave = defaultValue(options.interleave, false);\n  this._releaseGeometryInstances = defaultValue(\n    options.releaseGeometryInstances,\n    true\n  );\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._asynchronous = defaultValue(options.asynchronous, true);\n  this._compressVertices = defaultValue(options.compressVertices, true);\n\n  /**\n   * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands\n   * based on their bounding volume.  Set this to <code>false</code> for a small performance gain\n   * if you are manually culling the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.cull = defaultValue(options.cull, true);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * @private\n   */\n  this.rtcCenter = options.rtcCenter;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(this.rtcCenter) &&\n    (!defined(this.geometryInstances) ||\n      (Array.isArray(this.geometryInstances) &&\n        this.geometryInstances.length !== 1))\n  ) {\n    throw new DeveloperError(\n      \"Relative-to-center rendering only supports one geometry instance.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * Determines whether this primitive casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.DISABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.DISABLED);\n\n  this._translucent = undefined;\n\n  this._state = PrimitiveState.READY;\n  this._geometries = [];\n  this._error = undefined;\n  this._numberOfInstances = 0;\n\n  this._boundingSpheres = [];\n  this._boundingSphereWC = [];\n  this._boundingSphereCV = [];\n  this._boundingSphere2D = [];\n  this._boundingSphereMorph = [];\n  this._perInstanceAttributeCache = [];\n  this._instanceIds = [];\n  this._lastPerInstanceAttributeIndex = 0;\n\n  this._va = [];\n  this._attributeLocations = undefined;\n  this._primitiveType = undefined;\n\n  this._frontFaceRS = undefined;\n  this._backFaceRS = undefined;\n  this._sp = undefined;\n\n  this._depthFailAppearance = undefined;\n  this._spDepthFail = undefined;\n  this._frontFaceDepthFailRS = undefined;\n  this._backFaceDepthFailRS = undefined;\n\n  this._pickIds = [];\n\n  this._colorCommands = [];\n  this._pickCommands = [];\n\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._createRenderStatesFunction = options._createRenderStatesFunction;\n  this._createShaderProgramFunction = options._createShaderProgramFunction;\n  this._createCommandsFunction = options._createCommandsFunction;\n  this._updateAndQueueCommandsFunction =\n    options._updateAndQueueCommandsFunction;\n\n  this._createPickOffsets = options._createPickOffsets;\n  this._pickOffsets = undefined;\n\n  this._createGeometryResults = undefined;\n  this._ready = false;\n  this._readyPromise = defer();\n\n  this._batchTable = undefined;\n  this._batchTableAttributeIndices = undefined;\n  this._offsetInstanceExtend = undefined;\n  this._batchTableOffsetAttribute2DIndex = undefined;\n  this._batchTableOffsetsUpdated = false;\n  this._instanceBoundingSpheres = undefined;\n  this._instanceBoundingSpheresCV = undefined;\n  this._tempBoundingSpheres = undefined;\n  this._recomputeBoundingSpheres = false;\n  this._batchTableBoundingSpheresUpdated = false;\n  this._batchTableBoundingSphereAttributeIndices = undefined;\n}\n\nObject.defineProperties(Primitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link Primitive#update}\n   * is called.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Primitive.prototype\n   * @type {Promise.<Primitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\nfunction getCommonPerInstanceAttributeNames(instances) {\n  const length = instances.length;\n\n  const attributesInAllInstances = [];\n  const attributes0 = instances[0].attributes;\n  let name;\n\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name])) {\n      const attribute = attributes0[name];\n      let inAllInstances = true;\n\n      // Does this same attribute exist in all instances?\n      for (let i = 1; i < length; ++i) {\n        const otherAttribute = instances[i].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllInstances = false;\n          break;\n        }\n      }\n\n      if (inAllInstances) {\n        attributesInAllInstances.push(name);\n      }\n    }\n  }\n\n  return attributesInAllInstances;\n}\n\nconst scratchGetAttributeCartesian2 = new Cartesian2();\nconst scratchGetAttributeCartesian3 = new Cartesian3();\nconst scratchGetAttributeCartesian4 = new Cartesian4();\n\nfunction getAttributeValue(value) {\n  const componentsPerAttribute = value.length;\n  if (componentsPerAttribute === 1) {\n    return value[0];\n  } else if (componentsPerAttribute === 2) {\n    return Cartesian2.unpack(value, 0, scratchGetAttributeCartesian2);\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3.unpack(value, 0, scratchGetAttributeCartesian3);\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4.unpack(value, 0, scratchGetAttributeCartesian4);\n  }\n}\n\nfunction createBatchTable(primitive, context) {\n  const geometryInstances = primitive.geometryInstances;\n  const instances = Array.isArray(geometryInstances)\n    ? geometryInstances\n    : [geometryInstances];\n  const numberOfInstances = instances.length;\n  if (numberOfInstances === 0) {\n    return;\n  }\n\n  const names = getCommonPerInstanceAttributeNames(instances);\n  const length = names.length;\n\n  const attributes = [];\n  const attributeIndices = {};\n  const boundingSphereAttributeIndices = {};\n  let offset2DIndex;\n\n  const firstInstance = instances[0];\n  let instanceAttributes = firstInstance.attributes;\n\n  let i;\n  let name;\n  let attribute;\n\n  for (i = 0; i < length; ++i) {\n    name = names[i];\n    attribute = instanceAttributes[name];\n\n    attributeIndices[name] = i;\n    attributes.push({\n      functionName: `czm_batchTable_${name}`,\n      componentDatatype: attribute.componentDatatype,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      normalize: attribute.normalize,\n    });\n  }\n\n  if (names.indexOf(\"distanceDisplayCondition\") !== -1) {\n    attributes.push(\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereRadius\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 1,\n      }\n    );\n    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;\n    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;\n    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;\n    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;\n    boundingSphereAttributeIndices.radius = attributes.length - 1;\n  }\n\n  if (names.indexOf(\"offset\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_offset2D\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n    });\n    offset2DIndex = attributes.length - 1;\n  }\n\n  attributes.push({\n    functionName: \"czm_batchTable_pickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true,\n  });\n\n  const attributesLength = attributes.length;\n  const batchTable = new BatchTable(context, attributes, numberOfInstances);\n\n  for (i = 0; i < numberOfInstances; ++i) {\n    const instance = instances[i];\n    instanceAttributes = instance.attributes;\n\n    for (let j = 0; j < length; ++j) {\n      name = names[j];\n      attribute = instanceAttributes[name];\n      const value = getAttributeValue(attribute.value);\n      const attributeIndex = attributeIndices[name];\n      batchTable.setBatchedAttribute(i, attributeIndex, value);\n    }\n\n    const pickObject = {\n      primitive: defaultValue(instance.pickPrimitive, primitive),\n    };\n\n    if (defined(instance.id)) {\n      pickObject.id = instance.id;\n    }\n\n    const pickId = context.createPickId(pickObject);\n    primitive._pickIds.push(pickId);\n\n    const pickColor = pickId.color;\n    const color = scratchGetAttributeCartesian4;\n    color.x = Color.floatToByte(pickColor.red);\n    color.y = Color.floatToByte(pickColor.green);\n    color.z = Color.floatToByte(pickColor.blue);\n    color.w = Color.floatToByte(pickColor.alpha);\n\n    batchTable.setBatchedAttribute(i, attributesLength - 1, color);\n  }\n\n  primitive._batchTable = batchTable;\n  primitive._batchTableAttributeIndices = attributeIndices;\n  primitive._batchTableBoundingSphereAttributeIndices = boundingSphereAttributeIndices;\n  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;\n}\n\nfunction cloneAttribute(attribute) {\n  let clonedValues;\n  if (Array.isArray(attribute.values)) {\n    clonedValues = attribute.values.slice(0);\n  } else {\n    clonedValues = new attribute.values.constructor(attribute.values);\n  }\n  return new GeometryAttribute({\n    componentDatatype: attribute.componentDatatype,\n    componentsPerAttribute: attribute.componentsPerAttribute,\n    normalize: attribute.normalize,\n    values: clonedValues,\n  });\n}\n\nfunction cloneGeometry(geometry) {\n  const attributes = geometry.attributes;\n  const newAttributes = new GeometryAttributes();\n  for (const property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n      newAttributes[property] = cloneAttribute(attributes[property]);\n    }\n  }\n\n  let indices;\n  if (defined(geometry.indices)) {\n    const sourceValues = geometry.indices;\n    if (Array.isArray(sourceValues)) {\n      indices = sourceValues.slice(0);\n    } else {\n      indices = new sourceValues.constructor(sourceValues);\n    }\n  }\n\n  return new Geometry({\n    attributes: newAttributes,\n    indices: indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: BoundingSphere.clone(geometry.boundingSphere),\n  });\n}\n\nfunction cloneInstance(instance, geometry) {\n  return {\n    geometry: geometry,\n    attributes: instance.attributes,\n    modelMatrix: Matrix4.clone(instance.modelMatrix),\n    pickPrimitive: instance.pickPrimitive,\n    id: instance.id,\n  };\n}\n\nconst positionRegex = /attribute\\s+vec(?:3|4)\\s+(.*)3DHigh;/g;\n\nPrimitive._modifyShaderPosition = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly\n) {\n  let match;\n\n  let forwardDecl = \"\";\n  let attributes = \"\";\n  let computeFunctions = \"\";\n\n  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {\n    const name = match[1];\n\n    const functionName = `vec4 czm_compute${name[0].toUpperCase()}${name.substr(\n      1\n    )}()`;\n\n    // Don't forward-declare czm_computePosition because computePosition.glsl already does.\n    if (functionName !== \"vec4 czm_computePosition()\") {\n      forwardDecl += `${functionName};\\n`;\n    }\n\n    if (!defined(primitive.rtcCenter)) {\n      // Use GPU RTE\n      if (!scene3DOnly) {\n        attributes +=\n          `attribute vec3 ${name}2DHigh;\\n` + `attribute vec3 ${name}2DLow;\\n`;\n\n        computeFunctions +=\n          `${functionName}\\n` +\n          `{\\n` +\n          `    vec4 p;\\n` +\n          `    if (czm_morphTime == 1.0)\\n` +\n          `    {\\n` +\n          `        p = czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);\\n` +\n          `    }\\n` +\n          `    else if (czm_morphTime == 0.0)\\n` +\n          `    {\\n` +\n          `        p = czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy);\\n` +\n          `    }\\n` +\n          `    else\\n` +\n          `    {\\n` +\n          `        p = czm_columbusViewMorph(\\n` +\n          `                czm_translateRelativeToEye(${name}2DHigh.zxy, ${name}2DLow.zxy),\\n` +\n          `                czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow),\\n` +\n          `                czm_morphTime);\\n` +\n          `    }\\n` +\n          `    return p;\\n` +\n          `}\\n\\n`;\n      } else {\n        computeFunctions +=\n          `${functionName}\\n` +\n          `{\\n` +\n          `    return czm_translateRelativeToEye(${name}3DHigh, ${name}3DLow);\\n` +\n          `}\\n\\n`;\n      }\n    } else {\n      // Use RTC\n      vertexShaderSource = vertexShaderSource.replace(\n        /attribute\\s+vec(?:3|4)\\s+position3DHigh;/g,\n        \"\"\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /attribute\\s+vec(?:3|4)\\s+position3DLow;/g,\n        \"\"\n      );\n\n      forwardDecl += \"uniform mat4 u_modifiedModelView;\\n\";\n      attributes += \"attribute vec4 position;\\n\";\n\n      computeFunctions +=\n        `${functionName}\\n` +\n        `{\\n` +\n        `    return u_modifiedModelView * position;\\n` +\n        `}\\n\\n`;\n\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewRelativeToEye\\s+\\*\\s+/g,\n        \"\"\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewProjectionRelativeToEye/g,\n        \"czm_projection\"\n      );\n    }\n  }\n\n  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(\n    \"\\n\"\n  );\n};\n\nPrimitive._appendShowToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.show)) {\n    return vertexShaderSource;\n  }\n\n  const renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_show_main\"\n  );\n  const showMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_show_main(); \\n\" +\n    \"    gl_Position *= czm_batchTable_show(batchId); \\n\" +\n    \"}\";\n\n  return `${renamedVS}\\n${showMain}`;\n};\n\nPrimitive._updateColorAttribute = function (\n  primitive,\n  vertexShaderSource,\n  isDepthFail\n) {\n  // some appearances have a color attribute for per vertex color.\n  // only remove if color is a per instance attribute.\n  if (\n    !defined(primitive._batchTableAttributeIndices.color) &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    return vertexShaderSource;\n  }\n\n  if (vertexShaderSource.search(/attribute\\s+vec4\\s+color;/g) === -1) {\n    return vertexShaderSource;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isDepthFail &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    throw new DeveloperError(\n      \"A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec4\\s+color;/g, \"\");\n  if (!isDepthFail) {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_color(batchId)$2\"\n    );\n  } else {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_depthFailColor(batchId)$2\"\n    );\n  }\n  return modifiedVS;\n};\n\nfunction appendPickToVertexShader(source) {\n  const renamedVS = ShaderSource.replaceMain(source, \"czm_non_pick_main\");\n  const pickMain =\n    \"varying vec4 v_pickColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_pick_main(); \\n\" +\n    \"    v_pickColor = czm_batchTable_pickColor(batchId); \\n\" +\n    \"}\";\n\n  return `${renamedVS}\\n${pickMain}`;\n}\n\nfunction appendPickToFragmentShader(source) {\n  return `varying vec4 v_pickColor;\\n${source}`;\n}\n\nPrimitive._updatePickColorAttribute = function (source) {\n  let vsPick = source.replace(/attribute\\s+vec4\\s+pickColor;/g, \"\");\n  vsPick = vsPick.replace(\n    /(\\b)pickColor(\\b)/g,\n    \"$1czm_batchTable_pickColor(batchId)$2\"\n  );\n  return vsPick;\n};\n\nPrimitive._appendOffsetToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.offset)) {\n    return vertexShaderSource;\n  }\n\n  let attr = \"attribute float batchId;\\n\";\n  attr += \"attribute float applyOffset;\";\n  let modifiedShader = vertexShaderSource.replace(\n    /attribute\\s+float\\s+batchId;/g,\n    attr\n  );\n\n  let str = \"vec4 $1 = czm_computePosition();\\n\";\n  str += \"    if (czm_sceneMode == czm_sceneMode3D)\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  str += \"    else\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  modifiedShader = modifiedShader.replace(\n    /vec4\\s+([A-Za-z0-9_]+)\\s+=\\s+czm_computePosition\\(\\);/g,\n    str\n  );\n  return modifiedShader;\n};\n\nPrimitive._appendDistanceDisplayConditionToShader = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly\n) {\n  if (\n    !defined(primitive._batchTableAttributeIndices.distanceDisplayCondition)\n  ) {\n    return vertexShaderSource;\n  }\n\n  const renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_distanceDisplayCondition_main\"\n  );\n  let distanceDisplayConditionMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_distanceDisplayCondition_main(); \\n\" +\n    \"    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\\n\" +\n    \"    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\\n\";\n\n  if (!scene3DOnly) {\n    distanceDisplayConditionMain +=\n      \"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\\n\" +\n      \"    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\\n\" +\n      \"    vec4 centerRTE;\\n\" +\n      \"    if (czm_morphTime == 1.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\" +\n      \"    }\\n\" +\n      \"    else if (czm_morphTime == 0.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\\n\" +\n      \"    }\\n\" +\n      \"    else\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_columbusViewMorph(\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\\n\" +\n      \"                czm_morphTime);\\n\" +\n      \"    }\\n\";\n  } else {\n    distanceDisplayConditionMain +=\n      \"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\";\n  }\n\n  distanceDisplayConditionMain +=\n    \"    float radiusSq = boundingSphereRadius * boundingSphereRadius; \\n\" +\n    \"    float distanceSq; \\n\" +\n    \"    if (czm_sceneMode == czm_sceneMode2D) \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = czm_eyeHeight2D.y - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    else \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    distanceSq = max(distanceSq, 0.0); \\n\" +\n    \"    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \\n\" +\n    \"    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \\n\" +\n    \"    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \\n\" +\n    \"    gl_Position *= show; \\n\" +\n    \"}\";\n  return `${renamedVS}\\n${distanceDisplayConditionMain}`;\n};\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  const containsNormal =\n    vertexShaderSource.search(/attribute\\s+vec3\\s+normal;/g) !== -1;\n  const containsSt =\n    vertexShaderSource.search(/attribute\\s+vec2\\s+st;/g) !== -1;\n  if (!containsNormal && !containsSt) {\n    return vertexShaderSource;\n  }\n\n  const containsTangent =\n    vertexShaderSource.search(/attribute\\s+vec3\\s+tangent;/g) !== -1;\n  const containsBitangent =\n    vertexShaderSource.search(/attribute\\s+vec3\\s+bitangent;/g) !== -1;\n\n  let numComponents = containsSt && containsNormal ? 2.0 : 1.0;\n  numComponents += containsTangent || containsBitangent ? 1 : 0;\n\n  const type = numComponents > 1 ? `vec${numComponents}` : \"float\";\n\n  const attributeName = \"compressedAttributes\";\n  const attributeDecl = `attribute ${type} ${attributeName};`;\n\n  let globalDecl = \"\";\n  let decode = \"\";\n\n  if (containsSt) {\n    globalDecl += \"vec2 st;\\n\";\n    const stComponent =\n      numComponents > 1 ? `${attributeName}.x` : attributeName;\n    decode += `    st = czm_decompressTextureCoordinates(${stComponent});\\n`;\n  }\n\n  if (containsNormal && containsTangent && containsBitangent) {\n    globalDecl += \"vec3 normal;\\n\" + \"vec3 tangent;\\n\" + \"vec3 bitangent;\\n\";\n    decode += `    czm_octDecode(${attributeName}.${\n      containsSt ? \"yz\" : \"xy\"\n    }, normal, tangent, bitangent);\\n`;\n  } else {\n    if (containsNormal) {\n      globalDecl += \"vec3 normal;\\n\";\n      decode += `    normal = czm_octDecode(${attributeName}${\n        numComponents > 1 ? `.${containsSt ? \"y\" : \"x\"}` : \"\"\n      });\\n`;\n    }\n\n    if (containsTangent) {\n      globalDecl += \"vec3 tangent;\\n\";\n      decode += `    tangent = czm_octDecode(${attributeName}.${\n        containsSt && containsNormal ? \"z\" : \"y\"\n      });\\n`;\n    }\n\n    if (containsBitangent) {\n      globalDecl += \"vec3 bitangent;\\n\";\n      decode += `    bitangent = czm_octDecode(${attributeName}.${\n        containsSt && containsNormal ? \"z\" : \"y\"\n      });\\n`;\n    }\n  }\n\n  let modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+normal;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec2\\s+st;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+tangent;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+bitangent;/g, \"\");\n  modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n  const compressedMain =\n    `${\"void main() \\n\" + \"{ \\n\"}${decode}    czm_non_compressed_main(); \\n` +\n    `}`;\n\n  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n}\n\nfunction depthClampVS(vertexShaderSource) {\n  let modifiedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_depth_clamp_main\"\n  );\n  modifiedVS +=\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"    gl_Position = czm_depthClamp(gl_Position);\" +\n    \"}\\n\";\n  return modifiedVS;\n}\n\nfunction depthClampFS(fragmentShaderSource) {\n  let modifiedFS = ShaderSource.replaceMain(\n    fragmentShaderSource,\n    \"czm_non_depth_clamp_main\"\n  );\n  modifiedFS +=\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"#if defined(GL_EXT_frag_depth)\\n\" +\n    \"    #if defined(LOG_DEPTH)\\n\" +\n    \"        czm_writeLogDepth();\\n\" +\n    \"    #else\\n\" +\n    \"        czm_writeDepthClamp();\\n\" +\n    \"    #endif\\n\" +\n    \"#endif\\n\" +\n    \"}\\n\";\n  modifiedFS = `${\n    \"#ifdef GL_EXT_frag_depth\\n\" +\n    \"#extension GL_EXT_frag_depth : enable\\n\" +\n    \"#endif\\n\"\n  }${modifiedFS}`;\n  return modifiedFS;\n}\n\nfunction validateShaderMatching(shaderProgram, attributeLocations) {\n  // For a VAO and shader program to be compatible, the VAO must have\n  // all active attribute in the shader program.  The VAO may have\n  // extra attributes with the only concern being a potential\n  // performance hit due to extra memory bandwidth and cache pollution.\n  // The shader source could have extra attributes that are not used,\n  // but there is no guarantee they will be optimized out.\n  //\n  // Here, we validate that the VAO has all attributes required\n  // to match the shader program.\n  const shaderAttributes = shaderProgram.vertexAttributes;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (const name in shaderAttributes) {\n    if (shaderAttributes.hasOwnProperty(name)) {\n      if (!defined(attributeLocations[name])) {\n        throw new DeveloperError(\n          `Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '${name}', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.`\n        );\n      }\n    }\n  }\n  //>>includeEnd('debug');\n}\n\nfunction getUniformFunction(uniforms, name) {\n  return function () {\n    return uniforms[name];\n  };\n}\n\nconst numberOfCreationWorkers = Math.max(\n  FeatureDetection.hardwareConcurrency - 1,\n  1\n);\nlet createGeometryTaskProcessors;\nconst combineGeometryTaskProcessor = new TaskProcessor(\"combineGeometry\");\n\nfunction loadAsynchronous(primitive, frameState) {\n  let instances;\n  let geometry;\n  let i;\n  let j;\n\n  const instanceIds = primitive._instanceIds;\n\n  if (primitive._state === PrimitiveState.READY) {\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n    const length = (primitive._numberOfInstances = instances.length);\n\n    const promises = [];\n    let subTasks = [];\n    for (i = 0; i < length; ++i) {\n      geometry = instances[i].geometry;\n      instanceIds.push(instances[i].id);\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(geometry._workerName)) {\n        throw new DeveloperError(\n          \"_workerName must be defined for asynchronous geometry.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      subTasks.push({\n        moduleName: geometry._workerName,\n        geometry: geometry,\n      });\n    }\n\n    if (!defined(createGeometryTaskProcessors)) {\n      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);\n      for (i = 0; i < numberOfCreationWorkers; i++) {\n        createGeometryTaskProcessors[i] = new TaskProcessor(\"createGeometry\");\n      }\n    }\n\n    let subTask;\n    subTasks = subdivideArray(subTasks, numberOfCreationWorkers);\n\n    for (i = 0; i < subTasks.length; i++) {\n      let packedLength = 0;\n      const workerSubTasks = subTasks[i];\n      const workerSubTasksLength = workerSubTasks.length;\n      for (j = 0; j < workerSubTasksLength; ++j) {\n        subTask = workerSubTasks[j];\n        geometry = subTask.geometry;\n        if (defined(geometry.constructor.pack)) {\n          subTask.offset = packedLength;\n          packedLength += defaultValue(\n            geometry.constructor.packedLength,\n            geometry.packedLength\n          );\n        }\n      }\n\n      let subTaskTransferableObjects;\n\n      if (packedLength > 0) {\n        const array = new Float64Array(packedLength);\n        subTaskTransferableObjects = [array.buffer];\n\n        for (j = 0; j < workerSubTasksLength; ++j) {\n          subTask = workerSubTasks[j];\n          geometry = subTask.geometry;\n          if (defined(geometry.constructor.pack)) {\n            geometry.constructor.pack(geometry, array, subTask.offset);\n            subTask.geometry = array;\n          }\n        }\n      }\n\n      promises.push(\n        createGeometryTaskProcessors[i].scheduleTask(\n          {\n            subTasks: subTasks[i],\n          },\n          subTaskTransferableObjects\n        )\n      );\n    }\n\n    primitive._state = PrimitiveState.CREATING;\n\n    Promise.all(promises)\n      .then(function (results) {\n        primitive._createGeometryResults = results;\n        primitive._state = PrimitiveState.CREATED;\n      })\n      .catch(function (error) {\n        setReady(primitive, frameState, PrimitiveState.FAILED, error);\n      });\n  } else if (primitive._state === PrimitiveState.CREATED) {\n    const transferableObjects = [];\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n\n    const scene3DOnly = frameState.scene3DOnly;\n    const projection = frameState.mapProjection;\n\n    const promise = combineGeometryTaskProcessor.scheduleTask(\n      PrimitivePipeline.packCombineGeometryParameters(\n        {\n          createGeometryResults: primitive._createGeometryResults,\n          instances: instances,\n          ellipsoid: projection.ellipsoid,\n          projection: projection,\n          elementIndexUintSupported: frameState.context.elementIndexUint,\n          scene3DOnly: scene3DOnly,\n          vertexCacheOptimize: primitive.vertexCacheOptimize,\n          compressVertices: primitive.compressVertices,\n          modelMatrix: primitive.modelMatrix,\n          createPickOffsets: primitive._createPickOffsets,\n        },\n        transferableObjects\n      ),\n      transferableObjects\n    );\n\n    primitive._createGeometryResults = undefined;\n    primitive._state = PrimitiveState.COMBINING;\n\n    Promise.resolve(promise)\n      .then(function (packedResult) {\n        const result = PrimitivePipeline.unpackCombineGeometryResults(\n          packedResult\n        );\n        primitive._geometries = result.geometries;\n        primitive._attributeLocations = result.attributeLocations;\n        primitive.modelMatrix = Matrix4.clone(\n          result.modelMatrix,\n          primitive.modelMatrix\n        );\n        primitive._pickOffsets = result.pickOffsets;\n        primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n        primitive._instanceBoundingSpheres = result.boundingSpheres;\n        primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n        if (\n          defined(primitive._geometries) &&\n          primitive._geometries.length > 0\n        ) {\n          primitive._recomputeBoundingSpheres = true;\n          primitive._state = PrimitiveState.COMBINED;\n        } else {\n          setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n        }\n      })\n      .catch(function (error) {\n        setReady(primitive, frameState, PrimitiveState.FAILED, error);\n      });\n  }\n}\n\nfunction loadSynchronous(primitive, frameState) {\n  const instances = Array.isArray(primitive.geometryInstances)\n    ? primitive.geometryInstances\n    : [primitive.geometryInstances];\n  const length = (primitive._numberOfInstances = instances.length);\n  const clonedInstances = new Array(length);\n  const instanceIds = primitive._instanceIds;\n\n  let instance;\n  let i;\n\n  let geometryIndex = 0;\n  for (i = 0; i < length; i++) {\n    instance = instances[i];\n    const geometry = instance.geometry;\n\n    let createdGeometry;\n    if (defined(geometry.attributes) && defined(geometry.primitiveType)) {\n      createdGeometry = cloneGeometry(geometry);\n    } else {\n      createdGeometry = geometry.constructor.createGeometry(geometry);\n    }\n\n    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);\n    instanceIds.push(instance.id);\n  }\n\n  clonedInstances.length = geometryIndex;\n\n  const scene3DOnly = frameState.scene3DOnly;\n  const projection = frameState.mapProjection;\n\n  const result = PrimitivePipeline.combineGeometry({\n    instances: clonedInstances,\n    ellipsoid: projection.ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: frameState.context.elementIndexUint,\n    scene3DOnly: scene3DOnly,\n    vertexCacheOptimize: primitive.vertexCacheOptimize,\n    compressVertices: primitive.compressVertices,\n    modelMatrix: primitive.modelMatrix,\n    createPickOffsets: primitive._createPickOffsets,\n  });\n\n  primitive._geometries = result.geometries;\n  primitive._attributeLocations = result.attributeLocations;\n  primitive.modelMatrix = Matrix4.clone(\n    result.modelMatrix,\n    primitive.modelMatrix\n  );\n  primitive._pickOffsets = result.pickOffsets;\n  primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n  primitive._instanceBoundingSpheres = result.boundingSpheres;\n  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n  if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n    primitive._recomputeBoundingSpheres = true;\n    primitive._state = PrimitiveState.COMBINED;\n  } else {\n    setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n  }\n}\n\nfunction recomputeBoundingSpheres(primitive, frameState) {\n  const offsetIndex = primitive._batchTableAttributeIndices.offset;\n  if (!primitive._recomputeBoundingSpheres || !defined(offsetIndex)) {\n    primitive._recomputeBoundingSpheres = false;\n    return;\n  }\n\n  let i;\n  const offsetInstanceExtend = primitive._offsetInstanceExtend;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n  let newBoundingSpheres = primitive._tempBoundingSpheres;\n  if (!defined(newBoundingSpheres)) {\n    newBoundingSpheres = new Array(length);\n    for (i = 0; i < length; i++) {\n      newBoundingSpheres[i] = new BoundingSphere();\n    }\n    primitive._tempBoundingSpheres = newBoundingSpheres;\n  }\n  for (i = 0; i < length; ++i) {\n    let newBS = newBoundingSpheres[i];\n    const offset = primitive._batchTable.getBatchedAttribute(\n      i,\n      offsetIndex,\n      new Cartesian3()\n    );\n    newBS = boundingSpheres[i].clone(newBS);\n    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);\n  }\n  const combinedBS = [];\n  const combinedWestBS = [];\n  const combinedEastBS = [];\n\n  for (i = 0; i < length; ++i) {\n    const bs = newBoundingSpheres[i];\n\n    const minX = bs.center.x - bs.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(bs, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      combinedBS.push(bs);\n    } else {\n      combinedWestBS.push(bs);\n      combinedEastBS.push(bs);\n    }\n  }\n\n  let resultBS1 = combinedBS[0];\n  let resultBS2 = combinedEastBS[0];\n  let resultBS3 = combinedWestBS[0];\n\n  for (i = 1; i < combinedBS.length; i++) {\n    resultBS1 = BoundingSphere.union(resultBS1, combinedBS[i]);\n  }\n  for (i = 1; i < combinedEastBS.length; i++) {\n    resultBS2 = BoundingSphere.union(resultBS2, combinedEastBS[i]);\n  }\n  for (i = 1; i < combinedWestBS.length; i++) {\n    resultBS3 = BoundingSphere.union(resultBS3, combinedWestBS[i]);\n  }\n  const result = [];\n  if (defined(resultBS1)) {\n    result.push(resultBS1);\n  }\n  if (defined(resultBS2)) {\n    result.push(resultBS2);\n  }\n  if (defined(resultBS3)) {\n    result.push(resultBS3);\n  }\n\n  for (i = 0; i < result.length; i++) {\n    const boundingSphere = result[i].clone(primitive._boundingSpheres[i]);\n    primitive._boundingSpheres[i] = boundingSphere;\n    primitive._boundingSphereCV[i] = BoundingSphere.projectTo2D(\n      boundingSphere,\n      frameState.mapProjection,\n      primitive._boundingSphereCV[i]\n    );\n  }\n\n  Primitive._updateBoundingVolumes(\n    primitive,\n    frameState,\n    primitive.modelMatrix,\n    true\n  );\n  primitive._recomputeBoundingSpheres = false;\n}\n\nconst scratchBoundingSphereCenterEncoded = new EncodedCartesian3();\nconst scratchBoundingSphereCartographic = new Cartographic();\nconst scratchBoundingSphereCenter2D = new Cartesian3();\nconst scratchBoundingSphere = new BoundingSphere();\n\nfunction updateBatchTableBoundingSpheres(primitive, frameState) {\n  const hasDistanceDisplayCondition = defined(\n    primitive._batchTableAttributeIndices.distanceDisplayCondition\n  );\n  if (\n    !hasDistanceDisplayCondition ||\n    primitive._batchTableBoundingSpheresUpdated\n  ) {\n    return;\n  }\n\n  const indices = primitive._batchTableBoundingSphereAttributeIndices;\n  const center3DHighIndex = indices.center3DHigh;\n  const center3DLowIndex = indices.center3DLow;\n  const center2DHighIndex = indices.center2DHigh;\n  const center2DLowIndex = indices.center2DLow;\n  const radiusIndex = indices.radius;\n\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  const batchTable = primitive._batchTable;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n\n  for (let i = 0; i < length; ++i) {\n    let boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n\n    const modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere\n      );\n    }\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let encodedCenter = EncodedCartesian3.fromCartesian(\n      center,\n      scratchBoundingSphereCenterEncoded\n    );\n    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);\n    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);\n\n    if (!frameState.scene3DOnly) {\n      const cartographic = ellipsoid.cartesianToCartographic(\n        center,\n        scratchBoundingSphereCartographic\n      );\n      const center2D = projection.project(\n        cartographic,\n        scratchBoundingSphereCenter2D\n      );\n      encodedCenter = EncodedCartesian3.fromCartesian(\n        center2D,\n        scratchBoundingSphereCenterEncoded\n      );\n      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);\n      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);\n    }\n\n    batchTable.setBatchedAttribute(i, radiusIndex, radius);\n  }\n\n  primitive._batchTableBoundingSpheresUpdated = true;\n}\n\nconst offsetScratchCartesian = new Cartesian3();\nconst offsetCenterScratch = new Cartesian3();\nfunction updateBatchTableOffsets(primitive, frameState) {\n  const hasOffset = defined(primitive._batchTableAttributeIndices.offset);\n  if (\n    !hasOffset ||\n    primitive._batchTableOffsetsUpdated ||\n    frameState.scene3DOnly\n  ) {\n    return;\n  }\n\n  const index2D = primitive._batchTableOffsetAttribute2DIndex;\n\n  const projection = frameState.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  const batchTable = primitive._batchTable;\n  const boundingSpheres = primitive._instanceBoundingSpheres;\n  const length = boundingSpheres.length;\n\n  for (let i = 0; i < length; ++i) {\n    let boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n    const offset = batchTable.getBatchedAttribute(\n      i,\n      primitive._batchTableAttributeIndices.offset\n    );\n    if (Cartesian3.equals(offset, Cartesian3.ZERO)) {\n      batchTable.setBatchedAttribute(i, index2D, Cartesian3.ZERO);\n      continue;\n    }\n\n    const modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere\n      );\n    }\n\n    let center = boundingSphere.center;\n    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);\n    let cartographic = ellipsoid.cartesianToCartographic(\n      center,\n      scratchBoundingSphereCartographic\n    );\n    const center2D = projection.project(\n      cartographic,\n      scratchBoundingSphereCenter2D\n    );\n\n    const newPoint = Cartesian3.add(offset, center, offsetScratchCartesian);\n    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);\n\n    const newPointProjected = projection.project(\n      cartographic,\n      offsetScratchCartesian\n    );\n\n    const newVector = Cartesian3.subtract(\n      newPointProjected,\n      center2D,\n      offsetScratchCartesian\n    );\n\n    const x = newVector.x;\n    newVector.x = newVector.z;\n    newVector.z = newVector.y;\n    newVector.y = x;\n\n    batchTable.setBatchedAttribute(i, index2D, newVector);\n  }\n\n  primitive._batchTableOffsetsUpdated = true;\n}\n\nfunction createVertexArray(primitive, frameState) {\n  const attributeLocations = primitive._attributeLocations;\n  const geometries = primitive._geometries;\n  const scene3DOnly = frameState.scene3DOnly;\n  const context = frameState.context;\n\n  const va = [];\n  const length = geometries.length;\n  for (let i = 0; i < length; ++i) {\n    const geometry = geometries[i];\n\n    va.push(\n      VertexArray.fromGeometry({\n        context: context,\n        geometry: geometry,\n        attributeLocations: attributeLocations,\n        bufferUsage: BufferUsage.STATIC_DRAW,\n        interleave: primitive._interleave,\n      })\n    );\n\n    if (defined(primitive._createBoundingVolumeFunction)) {\n      primitive._createBoundingVolumeFunction(frameState, geometry);\n    } else {\n      primitive._boundingSpheres.push(\n        BoundingSphere.clone(geometry.boundingSphere)\n      );\n      primitive._boundingSphereWC.push(new BoundingSphere());\n\n      if (!scene3DOnly) {\n        const center = geometry.boundingSphereCV.center;\n        const x = center.x;\n        const y = center.y;\n        const z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n\n        primitive._boundingSphereCV.push(\n          BoundingSphere.clone(geometry.boundingSphereCV)\n        );\n        primitive._boundingSphere2D.push(new BoundingSphere());\n        primitive._boundingSphereMorph.push(new BoundingSphere());\n      }\n    }\n  }\n\n  primitive._va = va;\n  primitive._primitiveType = geometries[0].primitiveType;\n\n  if (primitive.releaseGeometryInstances) {\n    primitive.geometryInstances = undefined;\n  }\n\n  primitive._geometries = undefined;\n  setReady(primitive, frameState, PrimitiveState.COMPLETE, undefined);\n}\n\nfunction createRenderStates(primitive, context, appearance, twoPasses) {\n  let renderState = appearance.getRenderState();\n  let rs;\n\n  if (twoPasses) {\n    rs = clone(renderState, false);\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK,\n    };\n    primitive._frontFaceRS = RenderState.fromCache(rs);\n\n    rs.cull.face = CullFace.FRONT;\n    primitive._backFaceRS = RenderState.fromCache(rs);\n  } else {\n    primitive._frontFaceRS = RenderState.fromCache(renderState);\n    primitive._backFaceRS = primitive._frontFaceRS;\n  }\n\n  rs = clone(renderState, false);\n  if (defined(primitive._depthFailAppearance)) {\n    rs.depthTest.enabled = false;\n  }\n\n  if (defined(primitive._depthFailAppearance)) {\n    renderState = primitive._depthFailAppearance.getRenderState();\n    rs = clone(renderState, false);\n    rs.depthTest.func = DepthFunction.GREATER;\n    if (twoPasses) {\n      rs.cull = {\n        enabled: true,\n        face: CullFace.BACK,\n      };\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n\n      rs.cull.face = CullFace.FRONT;\n      primitive._backFaceDepthFailRS = RenderState.fromCache(rs);\n    } else {\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      primitive._backFaceDepthFailRS = primitive._frontFaceRS;\n    }\n  }\n}\n\nfunction createShaderProgram(primitive, frameState, appearance) {\n  const context = frameState.context;\n\n  const attributeLocations = primitive._attributeLocations;\n\n  let vs = primitive._batchTable.getVertexShaderCallback()(\n    appearance.vertexShaderSource\n  );\n  vs = Primitive._appendOffsetToShader(primitive, vs);\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(\n    primitive,\n    vs,\n    frameState.scene3DOnly\n  );\n  vs = appendPickToVertexShader(vs);\n  vs = Primitive._updateColorAttribute(primitive, vs, false);\n  vs = modifyForEncodedNormals(primitive, vs);\n  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n  let fs = appearance.getFragmentShaderSource();\n  fs = appendPickToFragmentShader(fs);\n\n  primitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n  validateShaderMatching(primitive._sp, attributeLocations);\n\n  if (defined(primitive._depthFailAppearance)) {\n    vs = primitive._batchTable.getVertexShaderCallback()(\n      primitive._depthFailAppearance.vertexShaderSource\n    );\n    vs = Primitive._appendShowToShader(primitive, vs);\n    vs = Primitive._appendDistanceDisplayConditionToShader(\n      primitive,\n      vs,\n      frameState.scene3DOnly\n    );\n    vs = appendPickToVertexShader(vs);\n    vs = Primitive._updateColorAttribute(primitive, vs, true);\n    vs = modifyForEncodedNormals(primitive, vs);\n    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n    vs = depthClampVS(vs);\n\n    fs = primitive._depthFailAppearance.getFragmentShaderSource();\n    fs = appendPickToFragmentShader(fs);\n    fs = depthClampFS(fs);\n\n    primitive._spDepthFail = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: primitive._spDepthFail,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations,\n    });\n    validateShaderMatching(primitive._spDepthFail, attributeLocations);\n  }\n}\n\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\n\nfunction getUniforms(primitive, appearance, material, frameState) {\n  // Create uniform map by combining uniforms from the appearance and material if either have uniforms.\n  const materialUniformMap = defined(material) ? material._uniforms : undefined;\n  const appearanceUniformMap = {};\n  const appearanceUniforms = appearance.uniforms;\n  if (defined(appearanceUniforms)) {\n    // Convert to uniform map of functions for the renderer\n    for (const name in appearanceUniforms) {\n      if (appearanceUniforms.hasOwnProperty(name)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(materialUniformMap) && defined(materialUniformMap[name])) {\n          // Later, we could rename uniforms behind-the-scenes if needed.\n          throw new DeveloperError(\n            `Appearance and material have a uniform with the same name: ${name}`\n          );\n        }\n        //>>includeEnd('debug');\n\n        appearanceUniformMap[name] = getUniformFunction(\n          appearanceUniforms,\n          name\n        );\n      }\n    }\n  }\n  let uniforms = combine(appearanceUniformMap, materialUniformMap);\n  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);\n\n  if (defined(primitive.rtcCenter)) {\n    uniforms.u_modifiedModelView = function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      Matrix4.multiply(\n        viewMatrix,\n        primitive._modelMatrix,\n        modifiedModelViewScratch\n      );\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive.rtcCenter,\n        rtcScratch\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch\n      );\n      return modifiedModelViewScratch;\n    };\n  }\n\n  return uniforms;\n}\n\nfunction createCommands(\n  primitive,\n  appearance,\n  material,\n  translucent,\n  twoPasses,\n  colorCommands,\n  pickCommands,\n  frameState\n) {\n  const uniforms = getUniforms(primitive, appearance, material, frameState);\n\n  let depthFailUniforms;\n  if (defined(primitive._depthFailAppearance)) {\n    depthFailUniforms = getUniforms(\n      primitive,\n      primitive._depthFailAppearance,\n      primitive._depthFailAppearance.material,\n      frameState\n    );\n  }\n\n  const pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n\n  let multiplier = twoPasses ? 2 : 1;\n  multiplier *= defined(primitive._depthFailAppearance) ? 2 : 1;\n  colorCommands.length = primitive._va.length * multiplier;\n\n  const length = colorCommands.length;\n  let vaIndex = 0;\n  for (let i = 0; i < length; ++i) {\n    let colorCommand;\n\n    if (twoPasses) {\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._backFaceRS;\n      colorCommand.shaderProgram = primitive._sp;\n      colorCommand.uniformMap = uniforms;\n      colorCommand.pass = pass;\n\n      ++i;\n    }\n\n    colorCommand = colorCommands[i];\n    if (!defined(colorCommand)) {\n      colorCommand = colorCommands[i] = new DrawCommand({\n        owner: primitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n    colorCommand.vertexArray = primitive._va[vaIndex];\n    colorCommand.renderState = primitive._frontFaceRS;\n    colorCommand.shaderProgram = primitive._sp;\n    colorCommand.uniformMap = uniforms;\n    colorCommand.pass = pass;\n\n    if (defined(primitive._depthFailAppearance)) {\n      if (twoPasses) {\n        ++i;\n\n        colorCommand = colorCommands[i];\n        if (!defined(colorCommand)) {\n          colorCommand = colorCommands[i] = new DrawCommand({\n            owner: primitive,\n            primitiveType: primitive._primitiveType,\n          });\n        }\n        colorCommand.vertexArray = primitive._va[vaIndex];\n        colorCommand.renderState = primitive._backFaceDepthFailRS;\n        colorCommand.shaderProgram = primitive._spDepthFail;\n        colorCommand.uniformMap = depthFailUniforms;\n        colorCommand.pass = pass;\n      }\n\n      ++i;\n\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._frontFaceDepthFailRS;\n      colorCommand.shaderProgram = primitive._spDepthFail;\n      colorCommand.uniformMap = depthFailUniforms;\n      colorCommand.pass = pass;\n    }\n\n    ++vaIndex;\n  }\n}\n\nPrimitive._updateBoundingVolumes = function (\n  primitive,\n  frameState,\n  modelMatrix,\n  forceUpdate\n) {\n  let i;\n  let length;\n  let boundingSphere;\n\n  if (forceUpdate || !Matrix4.equals(modelMatrix, primitive._modelMatrix)) {\n    Matrix4.clone(modelMatrix, primitive._modelMatrix);\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      if (defined(boundingSphere)) {\n        primitive._boundingSphereWC[i] = BoundingSphere.transform(\n          boundingSphere,\n          modelMatrix,\n          primitive._boundingSphereWC[i]\n        );\n        if (!frameState.scene3DOnly) {\n          primitive._boundingSphere2D[i] = BoundingSphere.clone(\n            primitive._boundingSphereCV[i],\n            primitive._boundingSphere2D[i]\n          );\n          primitive._boundingSphere2D[i].center.x = 0.0;\n          primitive._boundingSphereMorph[i] = BoundingSphere.union(\n            primitive._boundingSphereWC[i],\n            primitive._boundingSphereCV[i]\n          );\n        }\n      }\n    }\n  }\n\n  // Update bounding volumes for primitives that are sized in pixels.\n  // The pixel size in meters varies based on the distance from the camera.\n  const pixelSize = primitive.appearance.pixelSize;\n  if (defined(pixelSize)) {\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      const boundingSphereWC = primitive._boundingSphereWC[i];\n      const pixelSizeInMeters = frameState.camera.getPixelSize(\n        boundingSphere,\n        frameState.context.drawingBufferWidth,\n        frameState.context.drawingBufferHeight\n      );\n      const sizeInMeters = pixelSizeInMeters * pixelSize;\n      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;\n    }\n  }\n};\n\nfunction updateAndQueueCommands(\n  primitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    !Matrix4.equals(modelMatrix, Matrix4.IDENTITY)\n  ) {\n    throw new DeveloperError(\n      \"Primitive.modelMatrix is only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  let boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  const commandList = frameState.commandList;\n  const passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    const allowPicking = primitive.allowPicking;\n    const castShadows = ShadowMode.castShadows(primitive.shadows);\n    const receiveShadows = ShadowMode.receiveShadows(primitive.shadows);\n    const colorLength = colorCommands.length;\n\n    let factor = twoPasses ? 2 : 1;\n    factor *= defined(primitive._depthFailAppearance) ? 2 : 1;\n\n    for (let j = 0; j < colorLength; ++j) {\n      const sphereIndex = Math.floor(j / factor);\n      const colorCommand = colorCommands[j];\n      colorCommand.modelMatrix = modelMatrix;\n      colorCommand.boundingVolume = boundingSpheres[sphereIndex];\n      colorCommand.cull = cull;\n      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;\n      colorCommand.castShadows = castShadows;\n      colorCommand.receiveShadows = receiveShadows;\n\n      if (allowPicking) {\n        colorCommand.pickId = \"v_pickColor\";\n      } else {\n        colorCommand.pickId = undefined;\n      }\n\n      commandList.push(colorCommand);\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Primitive.modelMatrix is only supported in 3D mode.\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPrimitive.prototype.update = function (frameState) {\n  if (\n    (!defined(this.geometryInstances) && this._va.length === 0) ||\n    (defined(this.geometryInstances) &&\n      Array.isArray(this.geometryInstances) &&\n      this.geometryInstances.length === 0) ||\n    !defined(this.appearance) ||\n    (frameState.mode !== SceneMode.SCENE3D && frameState.scene3DOnly) ||\n    (!frameState.passes.render && !frameState.passes.pick)\n  ) {\n    return;\n  }\n\n  if (defined(this._error)) {\n    throw this._error;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(this.rtcCenter) && !frameState.scene3DOnly) {\n    throw new DeveloperError(\n      \"RTC rendering is only available for 3D only scenes.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (this._state === PrimitiveState.FAILED) {\n    return;\n  }\n\n  const context = frameState.context;\n  if (!defined(this._batchTable)) {\n    createBatchTable(this, context);\n  }\n  if (this._batchTable.attributes.length > 0) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\n        \"Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\"\n      );\n    }\n    this._batchTable.update(frameState);\n  }\n\n  if (\n    this._state !== PrimitiveState.COMPLETE &&\n    this._state !== PrimitiveState.COMBINED\n  ) {\n    if (this.asynchronous) {\n      loadAsynchronous(this, frameState);\n    } else {\n      loadSynchronous(this, frameState);\n    }\n  }\n\n  if (this._state === PrimitiveState.COMBINED) {\n    updateBatchTableBoundingSpheres(this, frameState);\n    updateBatchTableOffsets(this, frameState);\n    createVertexArray(this, frameState);\n  }\n\n  if (!this.show || this._state !== PrimitiveState.COMPLETE) {\n    return;\n  }\n\n  if (!this._batchTableOffsetsUpdated) {\n    updateBatchTableOffsets(this, frameState);\n  }\n  if (this._recomputeBoundingSpheres) {\n    recomputeBoundingSpheres(this, frameState);\n  }\n\n  // Create or recreate render state and shader program if appearance/material changed\n  const appearance = this.appearance;\n  const material = appearance.material;\n  let createRS = false;\n  let createSP = false;\n\n  if (this._appearance !== appearance) {\n    this._appearance = appearance;\n    this._material = material;\n    createRS = true;\n    createSP = true;\n  } else if (this._material !== material) {\n    this._material = material;\n    createSP = true;\n  }\n\n  const depthFailAppearance = this.depthFailAppearance;\n  const depthFailMaterial = defined(depthFailAppearance)\n    ? depthFailAppearance.material\n    : undefined;\n\n  if (this._depthFailAppearance !== depthFailAppearance) {\n    this._depthFailAppearance = depthFailAppearance;\n    this._depthFailMaterial = depthFailMaterial;\n    createRS = true;\n    createSP = true;\n  } else if (this._depthFailMaterial !== depthFailMaterial) {\n    this._depthFailMaterial = depthFailMaterial;\n    createSP = true;\n  }\n\n  const translucent = this._appearance.isTranslucent();\n  if (this._translucent !== translucent) {\n    this._translucent = translucent;\n    createRS = true;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(context);\n  }\n\n  const twoPasses = appearance.closed && translucent;\n\n  if (createRS) {\n    const rsFunc = defaultValue(\n      this._createRenderStatesFunction,\n      createRenderStates\n    );\n    rsFunc(this, context, appearance, twoPasses);\n  }\n\n  if (createSP) {\n    const spFunc = defaultValue(\n      this._createShaderProgramFunction,\n      createShaderProgram\n    );\n    spFunc(this, frameState, appearance);\n  }\n\n  if (createRS || createSP) {\n    const commandFunc = defaultValue(\n      this._createCommandsFunction,\n      createCommands\n    );\n    commandFunc(\n      this,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      this._colorCommands,\n      this._pickCommands,\n      frameState\n    );\n  }\n\n  const updateAndQueueCommandsFunc = defaultValue(\n    this._updateAndQueueCommandsFunction,\n    updateAndQueueCommands\n  );\n  updateAndQueueCommandsFunc(\n    this,\n    frameState,\n    this._colorCommands,\n    this._pickCommands,\n    this.modelMatrix,\n    this.cull,\n    this.debugShowBoundingVolume,\n    twoPasses\n  );\n};\n\nconst offsetBoundingSphereScratch1 = new BoundingSphere();\nconst offsetBoundingSphereScratch2 = new BoundingSphere();\nfunction transformBoundingSphere(boundingSphere, offset, offsetAttribute) {\n  if (offsetAttribute === GeometryOffsetAttribute.TOP) {\n    const origBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch1\n    );\n    const offsetBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch2\n    );\n    offsetBS.center = Cartesian3.add(offsetBS.center, offset, offsetBS.center);\n    boundingSphere = BoundingSphere.union(origBS, offsetBS, boundingSphere);\n  } else if (offsetAttribute === GeometryOffsetAttribute.ALL) {\n    boundingSphere.center = Cartesian3.add(\n      boundingSphere.center,\n      offset,\n      boundingSphere.center\n    );\n  }\n\n  return boundingSphere;\n}\n\nfunction createGetFunction(batchTable, instanceIndex, attributeIndex) {\n  return function () {\n    const attributeValue = batchTable.getBatchedAttribute(\n      instanceIndex,\n      attributeIndex\n    );\n    const attribute = batchTable.attributes[attributeIndex];\n    const componentsPerAttribute = attribute.componentsPerAttribute;\n    const value = ComponentDatatype.createTypedArray(\n      attribute.componentDatatype,\n      componentsPerAttribute\n    );\n    if (defined(attributeValue.constructor.pack)) {\n      attributeValue.constructor.pack(attributeValue, value, 0);\n    } else {\n      value[0] = attributeValue;\n    }\n    return value;\n  };\n}\n\nfunction createSetFunction(\n  batchTable,\n  instanceIndex,\n  attributeIndex,\n  primitive,\n  name\n) {\n  return function (value) {\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !defined(value) ||\n      !defined(value.length) ||\n      value.length < 1 ||\n      value.length > 4\n    ) {\n      throw new DeveloperError(\n        \"value must be and array with length between 1 and 4.\"\n      );\n    }\n    //>>includeEnd('debug');\n    const attributeValue = getAttributeValue(value);\n    batchTable.setBatchedAttribute(\n      instanceIndex,\n      attributeIndex,\n      attributeValue\n    );\n    if (name === \"offset\") {\n      primitive._recomputeBoundingSpheres = true;\n      primitive._batchTableOffsetsUpdated = false;\n    }\n  };\n}\n\nconst offsetScratch = new Cartesian3();\n\nfunction createBoundingSphereProperties(primitive, properties, index) {\n  properties.boundingSphere = {\n    get: function () {\n      let boundingSphere = primitive._instanceBoundingSpheres[index];\n      if (defined(boundingSphere)) {\n        boundingSphere = boundingSphere.clone();\n        const modelMatrix = primitive.modelMatrix;\n        const offset = properties.offset;\n        if (defined(offset)) {\n          transformBoundingSphere(\n            boundingSphere,\n            Cartesian3.fromArray(offset.get(), 0, offsetScratch),\n            primitive._offsetInstanceExtend[index]\n          );\n        }\n        if (defined(modelMatrix)) {\n          boundingSphere = BoundingSphere.transform(\n            boundingSphere,\n            modelMatrix\n          );\n        }\n      }\n\n      return boundingSphere;\n    },\n  };\n  properties.boundingSphereCV = {\n    get: function () {\n      return primitive._instanceBoundingSpheresCV[index];\n    },\n  };\n}\n\nfunction createPickIdProperty(primitive, properties, index) {\n  properties.pickId = {\n    get: function () {\n      return primitive._pickIds[index];\n    },\n  };\n}\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);\n */\nPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n  if (!defined(this._batchTable)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let index = -1;\n  const lastIndex = this._lastPerInstanceAttributeIndex;\n  const ids = this._instanceIds;\n  const length = ids.length;\n  for (let i = 0; i < length; ++i) {\n    const curIndex = (lastIndex + i) % length;\n    if (id === ids[curIndex]) {\n      index = curIndex;\n      break;\n    }\n  }\n\n  if (index === -1) {\n    return undefined;\n  }\n\n  let attributes = this._perInstanceAttributeCache[index];\n  if (defined(attributes)) {\n    return attributes;\n  }\n\n  const batchTable = this._batchTable;\n  const perInstanceAttributeIndices = this._batchTableAttributeIndices;\n  attributes = {};\n  const properties = {};\n\n  for (const name in perInstanceAttributeIndices) {\n    if (perInstanceAttributeIndices.hasOwnProperty(name)) {\n      const attributeIndex = perInstanceAttributeIndices[name];\n      properties[name] = {\n        get: createGetFunction(batchTable, index, attributeIndex),\n        set: createSetFunction(batchTable, index, attributeIndex, this, name),\n      };\n    }\n  }\n\n  createBoundingSphereProperties(this, properties, index);\n  createPickIdProperty(this, properties, index);\n  Object.defineProperties(attributes, properties);\n\n  this._lastPerInstanceAttributeIndex = index;\n  this._perInstanceAttributeCache[index] = attributes;\n  return attributes;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Primitive#destroy\n */\nPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see Primitive#isDestroyed\n */\nPrimitive.prototype.destroy = function () {\n  let length;\n  let i;\n\n  this._sp = this._sp && this._sp.destroy();\n  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();\n\n  const va = this._va;\n  length = va.length;\n  for (i = 0; i < length; ++i) {\n    va[i].destroy();\n  }\n  this._va = undefined;\n\n  const pickIds = this._pickIds;\n  length = pickIds.length;\n  for (i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n  this._pickIds = undefined;\n\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n\n  //These objects may be fairly large and reference other large objects (like Entities)\n  //We explicitly set them to undefined here so that the memory can be freed\n  //even if a reference to the destroyed Primitive has been kept around.\n  this._instanceIds = undefined;\n  this._perInstanceAttributeCache = undefined;\n  this._attributeLocations = undefined;\n\n  return destroyObject(this);\n};\n\nfunction setReady(primitive, frameState, state, error) {\n  primitive._error = error;\n  primitive._state = state;\n  frameState.afterRender.push(function () {\n    primitive._ready =\n      primitive._state === PrimitiveState.COMPLETE ||\n      primitive._state === PrimitiveState.FAILED;\n    if (!defined(error)) {\n      primitive._readyPromise.resolve(primitive);\n    } else {\n      primitive._readyPromise.reject(error);\n    }\n  });\n}\nexport default Primitive;\n","import createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * A collection of primitives.  This is most often used with {@link Scene#primitives},\n * but <code>PrimitiveCollection</code> is also a primitive itself so collections can\n * be added to collections forming a hierarchy.\n *\n * @alias PrimitiveCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.show=true] Determines if the primitives in the collection will be shown.\n * @param {Boolean} [options.destroyPrimitives=true] Determines if primitives in the collection are destroyed when they are removed.\n *\n * @example\n * const billboards = new Cesium.BillboardCollection();\n * const labels = new Cesium.LabelCollection();\n *\n * const collection = new Cesium.PrimitiveCollection();\n * collection.add(billboards);\n *\n * scene.primitives.add(collection);  // Add collection\n * scene.primitives.add(labels);      // Add regular primitive\n */\nfunction PrimitiveCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._primitives = [];\n  this._guid = createGuid();\n\n  // Used by the OrderedGroundPrimitiveCollection\n  this._zIndex = undefined;\n\n  /**\n   * Determines if primitives in this collection will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * Determines if primitives in the collection are destroyed when they are removed by\n   * {@link PrimitiveCollection#destroy} or  {@link PrimitiveCollection#remove} or implicitly\n   * by {@link PrimitiveCollection#removeAll}.\n   *\n   * @type {Boolean}\n   * @default true\n   *\n   * @example\n   * // Example 1. Primitives are destroyed by default.\n   * const primitives = new Cesium.PrimitiveCollection();\n   * const labels = primitives.add(new Cesium.LabelCollection());\n   * primitives = primitives.destroy();\n   * const b = labels.isDestroyed(); // true\n   *\n   * @example\n   * // Example 2. Do not destroy primitives in a collection.\n   * const primitives = new Cesium.PrimitiveCollection();\n   * primitives.destroyPrimitives = false;\n   * const labels = primitives.add(new Cesium.LabelCollection());\n   * primitives = primitives.destroy();\n   * const b = labels.isDestroyed(); // false\n   * labels = labels.destroy();    // explicitly destroy\n   */\n  this.destroyPrimitives = defaultValue(options.destroyPrimitives, true);\n}\n\nObject.defineProperties(PrimitiveCollection.prototype, {\n  /**\n   * Gets the number of primitives in the collection.\n   *\n   * @memberof PrimitiveCollection.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._primitives.length;\n    },\n  },\n});\n\n/**\n * Adds a primitive to the collection.\n *\n * @param {Object} primitive The primitive to add.\n * @param {Number} [index] The index to add the layer at.  If omitted, the primitive will be added at the bottom of all existing primitives.\n * @returns {Object} The primitive added to the collection.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n */\nPrimitiveCollection.prototype.add = function (primitive, index) {\n  const hasIndex = defined(index);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(primitive)) {\n    throw new DeveloperError(\"primitive is required.\");\n  }\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._primitives.length) {\n      throw new DeveloperError(\n        \"index must be less than or equal to the number of primitives.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  const external = (primitive._external = primitive._external || {});\n  const composites = (external._composites = external._composites || {});\n  composites[this._guid] = {\n    collection: this,\n  };\n\n  if (!hasIndex) {\n    this._primitives.push(primitive);\n  } else {\n    this._primitives.splice(index, 0, primitive);\n  }\n\n  return primitive;\n};\n\n/**\n * Removes a primitive from the collection.\n *\n * @param {Object} [primitive] The primitive to remove.\n * @returns {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const billboards = scene.primitives.add(new Cesium.BillboardCollection());\n * scene.primitives.remove(billboards);  // Returns true\n *\n * @see PrimitiveCollection#destroyPrimitives\n */\nPrimitiveCollection.prototype.remove = function (primitive) {\n  // PERFORMANCE_IDEA:  We can obviously make this a lot faster.\n  if (this.contains(primitive)) {\n    const index = this._primitives.indexOf(primitive);\n    if (index !== -1) {\n      this._primitives.splice(index, 1);\n\n      delete primitive._external._composites[this._guid];\n\n      if (this.destroyPrimitives) {\n        primitive.destroy();\n      }\n\n      return true;\n    }\n    // else ... this is not possible, I swear.\n  }\n\n  return false;\n};\n\n/**\n * Removes and destroys a primitive, regardless of destroyPrimitives setting.\n * @private\n */\nPrimitiveCollection.prototype.removeAndDestroy = function (primitive) {\n  const removed = this.remove(primitive);\n  if (removed && !this.destroyPrimitives) {\n    primitive.destroy();\n  }\n  return removed;\n};\n\n/**\n * Removes all primitives in the collection.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PrimitiveCollection#destroyPrimitives\n */\nPrimitiveCollection.prototype.removeAll = function () {\n  const primitives = this._primitives;\n  const length = primitives.length;\n  for (let i = 0; i < length; ++i) {\n    delete primitives[i]._external._composites[this._guid];\n    if (this.destroyPrimitives) {\n      primitives[i].destroy();\n    }\n  }\n  this._primitives = [];\n};\n\n/**\n * Determines if this collection contains a primitive.\n *\n * @param {Object} [primitive] The primitive to check for.\n * @returns {Boolean} <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PrimitiveCollection#get\n */\nPrimitiveCollection.prototype.contains = function (primitive) {\n  return !!(\n    defined(primitive) &&\n    primitive._external &&\n    primitive._external._composites &&\n    primitive._external._composites[this._guid]\n  );\n};\n\nfunction getPrimitiveIndex(compositePrimitive, primitive) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!compositePrimitive.contains(primitive)) {\n    throw new DeveloperError(\"primitive is not in this collection.\");\n  }\n  //>>includeEnd('debug');\n\n  return compositePrimitive._primitives.indexOf(primitive);\n}\n\n/**\n * Raises a primitive \"up one\" in the collection.  If all primitives in the collection are drawn\n * on the globe surface, this visually moves the primitive up one.\n *\n * @param {Object} [primitive] The primitive to raise.\n *\n * @exception {DeveloperError} primitive is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PrimitiveCollection#raiseToTop\n * @see PrimitiveCollection#lower\n * @see PrimitiveCollection#lowerToBottom\n */\nPrimitiveCollection.prototype.raise = function (primitive) {\n  if (defined(primitive)) {\n    const index = getPrimitiveIndex(this, primitive);\n    const primitives = this._primitives;\n\n    if (index !== primitives.length - 1) {\n      const p = primitives[index];\n      primitives[index] = primitives[index + 1];\n      primitives[index + 1] = p;\n    }\n  }\n};\n\n/**\n * Raises a primitive to the \"top\" of the collection.  If all primitives in the collection are drawn\n * on the globe surface, this visually moves the primitive to the top.\n *\n * @param {Object} [primitive] The primitive to raise the top.\n *\n * @exception {DeveloperError} primitive is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PrimitiveCollection#raise\n * @see PrimitiveCollection#lower\n * @see PrimitiveCollection#lowerToBottom\n */\nPrimitiveCollection.prototype.raiseToTop = function (primitive) {\n  if (defined(primitive)) {\n    const index = getPrimitiveIndex(this, primitive);\n    const primitives = this._primitives;\n\n    if (index !== primitives.length - 1) {\n      // PERFORMANCE_IDEA:  Could be faster\n      primitives.splice(index, 1);\n      primitives.push(primitive);\n    }\n  }\n};\n\n/**\n * Lowers a primitive \"down one\" in the collection.  If all primitives in the collection are drawn\n * on the globe surface, this visually moves the primitive down one.\n *\n * @param {Object} [primitive] The primitive to lower.\n *\n * @exception {DeveloperError} primitive is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PrimitiveCollection#lowerToBottom\n * @see PrimitiveCollection#raise\n * @see PrimitiveCollection#raiseToTop\n */\nPrimitiveCollection.prototype.lower = function (primitive) {\n  if (defined(primitive)) {\n    const index = getPrimitiveIndex(this, primitive);\n    const primitives = this._primitives;\n\n    if (index !== 0) {\n      const p = primitives[index];\n      primitives[index] = primitives[index - 1];\n      primitives[index - 1] = p;\n    }\n  }\n};\n\n/**\n * Lowers a primitive to the \"bottom\" of the collection.  If all primitives in the collection are drawn\n * on the globe surface, this visually moves the primitive to the bottom.\n *\n * @param {Object} [primitive] The primitive to lower to the bottom.\n *\n * @exception {DeveloperError} primitive is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see PrimitiveCollection#lower\n * @see PrimitiveCollection#raise\n * @see PrimitiveCollection#raiseToTop\n */\nPrimitiveCollection.prototype.lowerToBottom = function (primitive) {\n  if (defined(primitive)) {\n    const index = getPrimitiveIndex(this, primitive);\n    const primitives = this._primitives;\n\n    if (index !== 0) {\n      // PERFORMANCE_IDEA:  Could be faster\n      primitives.splice(index, 1);\n      primitives.unshift(primitive);\n    }\n  }\n};\n\n/**\n * Returns the primitive in the collection at the specified index.\n *\n * @param {Number} index The zero-based index of the primitive to return.\n * @returns {Object} The primitive at the <code>index</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every primitive in the collection.\n * const primitives = scene.primitives;\n * const length = primitives.length;\n * for (let i = 0; i < length; ++i) {\n *   const p = primitives.get(i);\n *   p.show = !p.show;\n * }\n *\n * @see PrimitiveCollection#length\n */\nPrimitiveCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._primitives[index];\n};\n\n/**\n * @private\n */\nPrimitiveCollection.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  const primitives = this._primitives;\n  // Using primitives.length in the loop is a temporary workaround\n  // to allow quadtree updates to add and remove primitives in\n  // update().  This will be changed to manage added and removed lists.\n  for (let i = 0; i < primitives.length; ++i) {\n    primitives[i].update(frameState);\n  }\n};\n\n/**\n * @private\n */\nPrimitiveCollection.prototype.prePassesUpdate = function (frameState) {\n  const primitives = this._primitives;\n  // Using primitives.length in the loop is a temporary workaround\n  // to allow quadtree updates to add and remove primitives in\n  // update().  This will be changed to manage added and removed lists.\n  for (let i = 0; i < primitives.length; ++i) {\n    const primitive = primitives[i];\n    if (defined(primitive.prePassesUpdate)) {\n      primitive.prePassesUpdate(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nPrimitiveCollection.prototype.updateForPass = function (frameState, passState) {\n  const primitives = this._primitives;\n  // Using primitives.length in the loop is a temporary workaround\n  // to allow quadtree updates to add and remove primitives in\n  // update().  This will be changed to manage added and removed lists.\n  for (let i = 0; i < primitives.length; ++i) {\n    const primitive = primitives[i];\n    if (defined(primitive.updateForPass)) {\n      primitive.updateForPass(frameState, passState);\n    }\n  }\n};\n\n/**\n * @private\n */\nPrimitiveCollection.prototype.postPassesUpdate = function (frameState) {\n  const primitives = this._primitives;\n  // Using primitives.length in the loop is a temporary workaround\n  // to allow quadtree updates to add and remove primitives in\n  // update().  This will be changed to manage added and removed lists.\n  for (let i = 0; i < primitives.length; ++i) {\n    const primitive = primitives[i];\n    if (defined(primitive.postPassesUpdate)) {\n      primitive.postPassesUpdate(frameState);\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see PrimitiveCollection#destroy\n */\nPrimitiveCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this\n * collection allows for deterministic release of WebGL resources, instead of relying on the garbage\n * collector to destroy this collection.\n * <br /><br />\n * Since destroying a collection destroys all the contained primitives, only destroy a collection\n * when you are sure no other code is still using any of the contained primitives.\n * <br /><br />\n * Once this collection is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * primitives = primitives && primitives.destroy();\n *\n * @see PrimitiveCollection#isDestroyed\n */\nPrimitiveCollection.prototype.destroy = function () {\n  this.removeAll();\n  return destroyObject(this);\n};\nexport default PrimitiveCollection;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OffsetGeometryInstanceAttribute from \"../Core/OffsetGeometryInstanceAttribute.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\n\nfunction transformToWorldCoordinates(\n  instances,\n  primitiveModelMatrix,\n  scene3DOnly\n) {\n  let toWorld = !scene3DOnly;\n  const length = instances.length;\n  let i;\n\n  if (!toWorld && length > 1) {\n    const modelMatrix = instances[0].modelMatrix;\n\n    for (i = 1; i < length; ++i) {\n      if (!Matrix4.equals(modelMatrix, instances[i].modelMatrix)) {\n        toWorld = true;\n        break;\n      }\n    }\n  }\n\n  if (toWorld) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.transformToWorldCoordinates(instances[i]);\n      }\n    }\n  } else {\n    // Leave geometry in local coordinate system; auto update model-matrix.\n    Matrix4.multiplyTransformation(\n      primitiveModelMatrix,\n      instances[0].modelMatrix,\n      primitiveModelMatrix\n    );\n  }\n}\n\nfunction addGeometryBatchId(geometry, batchId) {\n  const attributes = geometry.attributes;\n  const positionAttr = attributes.position;\n  const numberOfComponents =\n    positionAttr.values.length / positionAttr.componentsPerAttribute;\n\n  attributes.batchId = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 1,\n    values: new Float32Array(numberOfComponents),\n  });\n\n  const values = attributes.batchId.values;\n  for (let j = 0; j < numberOfComponents; ++j) {\n    values[j] = batchId;\n  }\n}\n\nfunction addBatchIds(instances) {\n  const length = instances.length;\n\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    if (defined(instance.geometry)) {\n      addGeometryBatchId(instance.geometry, i);\n    } else if (\n      defined(instance.westHemisphereGeometry) &&\n      defined(instance.eastHemisphereGeometry)\n    ) {\n      addGeometryBatchId(instance.westHemisphereGeometry, i);\n      addGeometryBatchId(instance.eastHemisphereGeometry, i);\n    }\n  }\n}\n\nfunction geometryPipeline(parameters) {\n  const instances = parameters.instances;\n  const projection = parameters.projection;\n  const uintIndexSupport = parameters.elementIndexUintSupported;\n  const scene3DOnly = parameters.scene3DOnly;\n  const vertexCacheOptimize = parameters.vertexCacheOptimize;\n  const compressVertices = parameters.compressVertices;\n  const modelMatrix = parameters.modelMatrix;\n\n  let i;\n  let geometry;\n  let primitiveType;\n  let length = instances.length;\n\n  for (i = 0; i < length; ++i) {\n    if (defined(instances[i].geometry)) {\n      primitiveType = instances[i].geometry.primitiveType;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (\n      defined(instances[i].geometry) &&\n      instances[i].geometry.primitiveType !== primitiveType\n    ) {\n      throw new DeveloperError(\n        \"All instance geometries must have the same primitiveType.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Unify to world coordinates before combining.\n  transformToWorldCoordinates(instances, modelMatrix, scene3DOnly);\n\n  // Clip to IDL\n  if (!scene3DOnly) {\n    for (i = 0; i < length; ++i) {\n      if (defined(instances[i].geometry)) {\n        GeometryPipeline.splitLongitude(instances[i]);\n      }\n    }\n  }\n\n  addBatchIds(instances);\n\n  // Optimize for vertex shader caches\n  if (vertexCacheOptimize) {\n    for (i = 0; i < length; ++i) {\n      const instance = instances[i];\n      if (defined(instance.geometry)) {\n        GeometryPipeline.reorderForPostVertexCache(instance.geometry);\n        GeometryPipeline.reorderForPreVertexCache(instance.geometry);\n      } else if (\n        defined(instance.westHemisphereGeometry) &&\n        defined(instance.eastHemisphereGeometry)\n      ) {\n        GeometryPipeline.reorderForPostVertexCache(\n          instance.westHemisphereGeometry\n        );\n        GeometryPipeline.reorderForPreVertexCache(\n          instance.westHemisphereGeometry\n        );\n\n        GeometryPipeline.reorderForPostVertexCache(\n          instance.eastHemisphereGeometry\n        );\n        GeometryPipeline.reorderForPreVertexCache(\n          instance.eastHemisphereGeometry\n        );\n      }\n    }\n  }\n\n  // Combine into single geometry for better rendering performance.\n  let geometries = GeometryPipeline.combineInstances(instances);\n\n  length = geometries.length;\n  for (i = 0; i < length; ++i) {\n    geometry = geometries[i];\n\n    // Split positions for GPU RTE\n    const attributes = geometry.attributes;\n    if (!scene3DOnly) {\n      for (const name in attributes) {\n        if (\n          attributes.hasOwnProperty(name) &&\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\n        ) {\n          const name3D = `${name}3D`;\n          const name2D = `${name}2D`;\n\n          // Compute 2D positions\n          GeometryPipeline.projectTo2D(\n            geometry,\n            name,\n            name3D,\n            name2D,\n            projection\n          );\n          if (defined(geometry.boundingSphere) && name === \"position\") {\n            geometry.boundingSphereCV = BoundingSphere.fromVertices(\n              geometry.attributes.position2D.values\n            );\n          }\n\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name3D,\n            `${name3D}High`,\n            `${name3D}Low`\n          );\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name2D,\n            `${name2D}High`,\n            `${name2D}Low`\n          );\n        }\n      }\n    } else {\n      for (const name in attributes) {\n        if (\n          attributes.hasOwnProperty(name) &&\n          attributes[name].componentDatatype === ComponentDatatype.DOUBLE\n        ) {\n          GeometryPipeline.encodeAttribute(\n            geometry,\n            name,\n            `${name}3DHigh`,\n            `${name}3DLow`\n          );\n        }\n      }\n    }\n\n    // oct encode and pack normals, compress texture coordinates\n    if (compressVertices) {\n      GeometryPipeline.compressVertices(geometry);\n    }\n  }\n\n  if (!uintIndexSupport) {\n    // Break into multiple geometries to fit within unsigned short indices if needed\n    let splitGeometries = [];\n    length = geometries.length;\n    for (i = 0; i < length; ++i) {\n      geometry = geometries[i];\n      splitGeometries = splitGeometries.concat(\n        GeometryPipeline.fitToUnsignedShortIndices(geometry)\n      );\n    }\n\n    geometries = splitGeometries;\n  }\n\n  return geometries;\n}\n\nfunction createPickOffsets(instances, geometryName, geometries, pickOffsets) {\n  let offset;\n  let indexCount;\n  let geometryIndex;\n\n  const offsetIndex = pickOffsets.length - 1;\n  if (offsetIndex >= 0) {\n    const pickOffset = pickOffsets[offsetIndex];\n    offset = pickOffset.offset + pickOffset.count;\n    geometryIndex = pickOffset.index;\n    indexCount = geometries[geometryIndex].indices.length;\n  } else {\n    offset = 0;\n    geometryIndex = 0;\n    indexCount = geometries[geometryIndex].indices.length;\n  }\n\n  const length = instances.length;\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    const geometry = instance[geometryName];\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    const count = geometry.indices.length;\n\n    if (offset + count > indexCount) {\n      offset = 0;\n      indexCount = geometries[++geometryIndex].indices.length;\n    }\n\n    pickOffsets.push({\n      index: geometryIndex,\n      offset: offset,\n      count: count,\n    });\n    offset += count;\n  }\n}\n\nfunction createInstancePickOffsets(instances, geometries) {\n  const pickOffsets = [];\n  createPickOffsets(instances, \"geometry\", geometries, pickOffsets);\n  createPickOffsets(\n    instances,\n    \"westHemisphereGeometry\",\n    geometries,\n    pickOffsets\n  );\n  createPickOffsets(\n    instances,\n    \"eastHemisphereGeometry\",\n    geometries,\n    pickOffsets\n  );\n  return pickOffsets;\n}\n\n/**\n * @private\n */\nconst PrimitivePipeline = {};\n\n/**\n * @private\n */\nPrimitivePipeline.combineGeometry = function (parameters) {\n  let geometries;\n  let attributeLocations;\n  const instances = parameters.instances;\n  const length = instances.length;\n  let pickOffsets;\n\n  let offsetInstanceExtend;\n  let hasOffset = false;\n  if (length > 0) {\n    geometries = geometryPipeline(parameters);\n    if (geometries.length > 0) {\n      attributeLocations = GeometryPipeline.createAttributeLocations(\n        geometries[0]\n      );\n      if (parameters.createPickOffsets) {\n        pickOffsets = createInstancePickOffsets(instances, geometries);\n      }\n    }\n    if (\n      defined(instances[0].attributes) &&\n      defined(instances[0].attributes.offset)\n    ) {\n      offsetInstanceExtend = new Array(length);\n      hasOffset = true;\n    }\n  }\n\n  const boundingSpheres = new Array(length);\n  const boundingSpheresCV = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n    const geometry = instance.geometry;\n    if (defined(geometry)) {\n      boundingSpheres[i] = geometry.boundingSphere;\n      boundingSpheresCV[i] = geometry.boundingSphereCV;\n      if (hasOffset) {\n        offsetInstanceExtend[i] = instance.geometry.offsetAttribute;\n      }\n    }\n\n    const eastHemisphereGeometry = instance.eastHemisphereGeometry;\n    const westHemisphereGeometry = instance.westHemisphereGeometry;\n    if (defined(eastHemisphereGeometry) && defined(westHemisphereGeometry)) {\n      if (\n        defined(eastHemisphereGeometry.boundingSphere) &&\n        defined(westHemisphereGeometry.boundingSphere)\n      ) {\n        boundingSpheres[i] = BoundingSphere.union(\n          eastHemisphereGeometry.boundingSphere,\n          westHemisphereGeometry.boundingSphere\n        );\n      }\n      if (\n        defined(eastHemisphereGeometry.boundingSphereCV) &&\n        defined(westHemisphereGeometry.boundingSphereCV)\n      ) {\n        boundingSpheresCV[i] = BoundingSphere.union(\n          eastHemisphereGeometry.boundingSphereCV,\n          westHemisphereGeometry.boundingSphereCV\n        );\n      }\n    }\n  }\n\n  return {\n    geometries: geometries,\n    modelMatrix: parameters.modelMatrix,\n    attributeLocations: attributeLocations,\n    pickOffsets: pickOffsets,\n    offsetInstanceExtend: offsetInstanceExtend,\n    boundingSpheres: boundingSpheres,\n    boundingSpheresCV: boundingSpheresCV,\n  };\n};\n\nfunction transferGeometry(geometry, transferableObjects) {\n  const attributes = geometry.attributes;\n  for (const name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      const attribute = attributes[name];\n\n      if (defined(attribute) && defined(attribute.values)) {\n        transferableObjects.push(attribute.values.buffer);\n      }\n    }\n  }\n\n  if (defined(geometry.indices)) {\n    transferableObjects.push(geometry.indices.buffer);\n  }\n}\n\nfunction transferGeometries(geometries, transferableObjects) {\n  const length = geometries.length;\n  for (let i = 0; i < length; ++i) {\n    transferGeometry(geometries[i], transferableObjects);\n  }\n}\n\n// This function was created by simplifying packCreateGeometryResults into a count-only operation.\nfunction countCreateGeometryResults(items) {\n  let count = 1;\n  const length = items.length;\n  for (let i = 0; i < length; i++) {\n    const geometry = items[i];\n    ++count;\n\n    if (!defined(geometry)) {\n      continue;\n    }\n\n    const attributes = geometry.attributes;\n\n    count +=\n      7 +\n      2 * BoundingSphere.packedLength +\n      (defined(geometry.indices) ? geometry.indices.length : 0);\n\n    for (const property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property])\n      ) {\n        const attribute = attributes[property];\n        count += 5 + attribute.values.length;\n      }\n    }\n  }\n\n  return count;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCreateGeometryResults = function (\n  items,\n  transferableObjects\n) {\n  const packedData = new Float64Array(countCreateGeometryResults(items));\n  const stringTable = [];\n  const stringHash = {};\n\n  const length = items.length;\n  let count = 0;\n  packedData[count++] = length;\n  for (let i = 0; i < length; i++) {\n    const geometry = items[i];\n\n    const validGeometry = defined(geometry);\n    packedData[count++] = validGeometry ? 1.0 : 0.0;\n\n    if (!validGeometry) {\n      continue;\n    }\n\n    packedData[count++] = geometry.primitiveType;\n    packedData[count++] = geometry.geometryType;\n    packedData[count++] = defaultValue(geometry.offsetAttribute, -1);\n\n    const validBoundingSphere = defined(geometry.boundingSphere) ? 1.0 : 0.0;\n    packedData[count++] = validBoundingSphere;\n    if (validBoundingSphere) {\n      BoundingSphere.pack(geometry.boundingSphere, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n\n    const validBoundingSphereCV = defined(geometry.boundingSphereCV)\n      ? 1.0\n      : 0.0;\n    packedData[count++] = validBoundingSphereCV;\n    if (validBoundingSphereCV) {\n      BoundingSphere.pack(geometry.boundingSphereCV, packedData, count);\n    }\n\n    count += BoundingSphere.packedLength;\n\n    const attributes = geometry.attributes;\n    const attributesToWrite = [];\n    for (const property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property])\n      ) {\n        attributesToWrite.push(property);\n        if (!defined(stringHash[property])) {\n          stringHash[property] = stringTable.length;\n          stringTable.push(property);\n        }\n      }\n    }\n\n    packedData[count++] = attributesToWrite.length;\n    for (let q = 0; q < attributesToWrite.length; q++) {\n      const name = attributesToWrite[q];\n      const attribute = attributes[name];\n      packedData[count++] = stringHash[name];\n      packedData[count++] = attribute.componentDatatype;\n      packedData[count++] = attribute.componentsPerAttribute;\n      packedData[count++] = attribute.normalize ? 1 : 0;\n      packedData[count++] = attribute.values.length;\n      packedData.set(attribute.values, count);\n      count += attribute.values.length;\n    }\n\n    const indicesLength = defined(geometry.indices)\n      ? geometry.indices.length\n      : 0;\n    packedData[count++] = indicesLength;\n\n    if (indicesLength > 0) {\n      packedData.set(geometry.indices, count);\n      count += indicesLength;\n    }\n  }\n\n  transferableObjects.push(packedData.buffer);\n\n  return {\n    stringTable: stringTable,\n    packedData: packedData,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCreateGeometryResults = function (\n  createGeometryResult\n) {\n  const stringTable = createGeometryResult.stringTable;\n  const packedGeometry = createGeometryResult.packedData;\n\n  let i;\n  const result = new Array(packedGeometry[0]);\n  let resultIndex = 0;\n\n  let packedGeometryIndex = 1;\n  while (packedGeometryIndex < packedGeometry.length) {\n    const valid = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (!valid) {\n      result[resultIndex++] = undefined;\n      continue;\n    }\n\n    const primitiveType = packedGeometry[packedGeometryIndex++];\n    const geometryType = packedGeometry[packedGeometryIndex++];\n    let offsetAttribute = packedGeometry[packedGeometryIndex++];\n    if (offsetAttribute === -1) {\n      offsetAttribute = undefined;\n    }\n\n    let boundingSphere;\n    let boundingSphereCV;\n\n    const validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphere) {\n      boundingSphere = BoundingSphere.unpack(\n        packedGeometry,\n        packedGeometryIndex\n      );\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n\n    const validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1.0;\n    if (validBoundingSphereCV) {\n      boundingSphereCV = BoundingSphere.unpack(\n        packedGeometry,\n        packedGeometryIndex\n      );\n    }\n\n    packedGeometryIndex += BoundingSphere.packedLength;\n\n    let length;\n    let values;\n    let componentsPerAttribute;\n    const attributes = new GeometryAttributes();\n    const numAttributes = packedGeometry[packedGeometryIndex++];\n    for (i = 0; i < numAttributes; i++) {\n      const name = stringTable[packedGeometry[packedGeometryIndex++]];\n      const componentDatatype = packedGeometry[packedGeometryIndex++];\n      componentsPerAttribute = packedGeometry[packedGeometryIndex++];\n      const normalize = packedGeometry[packedGeometryIndex++] !== 0;\n\n      length = packedGeometry[packedGeometryIndex++];\n      values = ComponentDatatype.createTypedArray(componentDatatype, length);\n      for (let valuesIndex = 0; valuesIndex < length; valuesIndex++) {\n        values[valuesIndex] = packedGeometry[packedGeometryIndex++];\n      }\n\n      attributes[name] = new GeometryAttribute({\n        componentDatatype: componentDatatype,\n        componentsPerAttribute: componentsPerAttribute,\n        normalize: normalize,\n        values: values,\n      });\n    }\n\n    let indices;\n    length = packedGeometry[packedGeometryIndex++];\n\n    if (length > 0) {\n      const numberOfVertices = values.length / componentsPerAttribute;\n      indices = IndexDatatype.createTypedArray(numberOfVertices, length);\n      for (i = 0; i < length; i++) {\n        indices[i] = packedGeometry[packedGeometryIndex++];\n      }\n    }\n\n    result[resultIndex++] = new Geometry({\n      primitiveType: primitiveType,\n      geometryType: geometryType,\n      boundingSphere: boundingSphere,\n      boundingSphereCV: boundingSphereCV,\n      indices: indices,\n      attributes: attributes,\n      offsetAttribute: offsetAttribute,\n    });\n  }\n\n  return result;\n};\n\nfunction packInstancesForCombine(instances, transferableObjects) {\n  const length = instances.length;\n  const packedData = new Float64Array(1 + length * 19);\n  let count = 0;\n  packedData[count++] = length;\n  for (let i = 0; i < length; i++) {\n    const instance = instances[i];\n    Matrix4.pack(instance.modelMatrix, packedData, count);\n    count += Matrix4.packedLength;\n    if (defined(instance.attributes) && defined(instance.attributes.offset)) {\n      const values = instance.attributes.offset.value;\n      packedData[count] = values[0];\n      packedData[count + 1] = values[1];\n      packedData[count + 2] = values[2];\n    }\n    count += 3;\n  }\n  transferableObjects.push(packedData.buffer);\n\n  return packedData;\n}\n\nfunction unpackInstancesForCombine(data) {\n  const packedInstances = data;\n  const result = new Array(packedInstances[0]);\n  let count = 0;\n\n  let i = 1;\n  while (i < packedInstances.length) {\n    const modelMatrix = Matrix4.unpack(packedInstances, i);\n    let attributes;\n    i += Matrix4.packedLength;\n    if (defined(packedInstances[i])) {\n      attributes = {\n        offset: new OffsetGeometryInstanceAttribute(\n          packedInstances[i],\n          packedInstances[i + 1],\n          packedInstances[i + 2]\n        ),\n      };\n    }\n    i += 3;\n\n    result[count++] = {\n      modelMatrix: modelMatrix,\n      attributes: attributes,\n    };\n  }\n\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryParameters = function (\n  parameters,\n  transferableObjects\n) {\n  const createGeometryResults = parameters.createGeometryResults;\n  const length = createGeometryResults.length;\n\n  for (let i = 0; i < length; i++) {\n    transferableObjects.push(createGeometryResults[i].packedData.buffer);\n  }\n\n  return {\n    createGeometryResults: parameters.createGeometryResults,\n    packedInstances: packInstancesForCombine(\n      parameters.instances,\n      transferableObjects\n    ),\n    ellipsoid: parameters.ellipsoid,\n    isGeographic: parameters.projection instanceof GeographicProjection,\n    elementIndexUintSupported: parameters.elementIndexUintSupported,\n    scene3DOnly: parameters.scene3DOnly,\n    vertexCacheOptimize: parameters.vertexCacheOptimize,\n    compressVertices: parameters.compressVertices,\n    modelMatrix: parameters.modelMatrix,\n    createPickOffsets: parameters.createPickOffsets,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryParameters = function (\n  packedParameters\n) {\n  const instances = unpackInstancesForCombine(packedParameters.packedInstances);\n  const createGeometryResults = packedParameters.createGeometryResults;\n  const length = createGeometryResults.length;\n  let instanceIndex = 0;\n\n  for (let resultIndex = 0; resultIndex < length; resultIndex++) {\n    const geometries = PrimitivePipeline.unpackCreateGeometryResults(\n      createGeometryResults[resultIndex]\n    );\n    const geometriesLength = geometries.length;\n    for (\n      let geometryIndex = 0;\n      geometryIndex < geometriesLength;\n      geometryIndex++\n    ) {\n      const geometry = geometries[geometryIndex];\n      const instance = instances[instanceIndex];\n      instance.geometry = geometry;\n      ++instanceIndex;\n    }\n  }\n\n  const ellipsoid = Ellipsoid.clone(packedParameters.ellipsoid);\n  const projection = packedParameters.isGeographic\n    ? new GeographicProjection(ellipsoid)\n    : new WebMercatorProjection(ellipsoid);\n\n  return {\n    instances: instances,\n    ellipsoid: ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: packedParameters.elementIndexUintSupported,\n    scene3DOnly: packedParameters.scene3DOnly,\n    vertexCacheOptimize: packedParameters.vertexCacheOptimize,\n    compressVertices: packedParameters.compressVertices,\n    modelMatrix: Matrix4.clone(packedParameters.modelMatrix),\n    createPickOffsets: packedParameters.createPickOffsets,\n  };\n};\n\nfunction packBoundingSpheres(boundingSpheres) {\n  const length = boundingSpheres.length;\n  const bufferLength = 1 + (BoundingSphere.packedLength + 1) * length;\n  const buffer = new Float32Array(bufferLength);\n\n  let bufferIndex = 0;\n  buffer[bufferIndex++] = length;\n\n  for (let i = 0; i < length; ++i) {\n    const bs = boundingSpheres[i];\n    if (!defined(bs)) {\n      buffer[bufferIndex++] = 0.0;\n    } else {\n      buffer[bufferIndex++] = 1.0;\n      BoundingSphere.pack(boundingSpheres[i], buffer, bufferIndex);\n    }\n    bufferIndex += BoundingSphere.packedLength;\n  }\n\n  return buffer;\n}\n\nfunction unpackBoundingSpheres(buffer) {\n  const result = new Array(buffer[0]);\n  let count = 0;\n\n  let i = 1;\n  while (i < buffer.length) {\n    if (buffer[i++] === 1.0) {\n      result[count] = BoundingSphere.unpack(buffer, i);\n    }\n    ++count;\n    i += BoundingSphere.packedLength;\n  }\n\n  return result;\n}\n\n/**\n * @private\n */\nPrimitivePipeline.packCombineGeometryResults = function (\n  results,\n  transferableObjects\n) {\n  if (defined(results.geometries)) {\n    transferGeometries(results.geometries, transferableObjects);\n  }\n\n  const packedBoundingSpheres = packBoundingSpheres(results.boundingSpheres);\n  const packedBoundingSpheresCV = packBoundingSpheres(\n    results.boundingSpheresCV\n  );\n  transferableObjects.push(\n    packedBoundingSpheres.buffer,\n    packedBoundingSpheresCV.buffer\n  );\n\n  return {\n    geometries: results.geometries,\n    attributeLocations: results.attributeLocations,\n    modelMatrix: results.modelMatrix,\n    pickOffsets: results.pickOffsets,\n    offsetInstanceExtend: results.offsetInstanceExtend,\n    boundingSpheres: packedBoundingSpheres,\n    boundingSpheresCV: packedBoundingSpheresCV,\n  };\n};\n\n/**\n * @private\n */\nPrimitivePipeline.unpackCombineGeometryResults = function (packedResult) {\n  return {\n    geometries: packedResult.geometries,\n    attributeLocations: packedResult.attributeLocations,\n    modelMatrix: packedResult.modelMatrix,\n    pickOffsets: packedResult.pickOffsets,\n    offsetInstanceExtend: packedResult.offsetInstanceExtend,\n    boundingSpheres: unpackBoundingSpheres(packedResult.boundingSpheres),\n    boundingSpheresCV: unpackBoundingSpheres(packedResult.boundingSpheresCV),\n  };\n};\nexport default PrimitivePipeline;\n","/**\n * @private\n */\nconst PrimitiveState = {\n  READY: 0,\n  CREATING: 1,\n  CREATED: 2,\n  COMBINING: 3,\n  COMBINED: 4,\n  COMPLETE: 5,\n  FAILED: 6,\n};\nexport default Object.freeze(PrimitiveState);\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport PropertyAttributeProperty from \"./PropertyAttributeProperty.js\";\n\n/**\n * A property attribute; a collection of per-point properties stored as custom\n * vertex attributes.\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension}\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} [options.name] Optional human-readable name to describe the attribute\n * @param {Number} [options.id] A unique id to identify the property attribute, useful for debugging. This is the array index in the property attributes array\n * @param {Object} options.propertyAttribute The property attribute JSON, following the EXT_structural_metadata schema.\n * @param {MetadataClass} options.class The class that properties conform to.\n *\n * @alias PropertyAttribute\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function PropertyAttribute(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const propertyAttribute = options.propertyAttribute;\n  const classDefinition = options.class;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.propertyAttribute\", propertyAttribute);\n  Check.typeOf.object(\"options.class\", classDefinition);\n  //>>includeEnd('debug');\n\n  const properties = {};\n  if (defined(propertyAttribute.properties)) {\n    for (const propertyId in propertyAttribute.properties) {\n      if (propertyAttribute.properties.hasOwnProperty(propertyId)) {\n        properties[propertyId] = new PropertyAttributeProperty({\n          property: propertyAttribute.properties[propertyId],\n          classProperty: classDefinition.properties[propertyId],\n        });\n      }\n    }\n  }\n\n  this._name = options.name;\n  this._id = options.id;\n  this._class = classDefinition;\n  this._properties = properties;\n  this._extras = propertyAttribute.extras;\n  this._extensions = propertyAttribute.extensions;\n}\n\nObject.defineProperties(PropertyAttribute.prototype, {\n  /**\n   * A human-readable name for this attribute\n   *\n   * @memberof PropertyAttribute.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * An identifier for this attribute. Useful for debugging.\n   *\n   * @memberof PropertyAttribute.prototype\n   *\n   * @type {String|Number}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof PropertyAttribute.prototype\n   *\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    get: function () {\n      return this._class;\n    },\n  },\n\n  /**\n   * The properties in this property attribute.\n   *\n   * @memberof PropertyAttribute.prototype\n   *\n   * @type {PropertyAttributeProperty}\n   * @readonly\n   * @private\n   */\n  properties: {\n    get: function () {\n      return this._properties;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof PropertyAttribute.prototype\n   *\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof PropertyAttribute.prototype\n   *\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * Gets the property with the given property ID.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {PropertyAttributeProperty|undefined} The property, or <code>undefined</code> if the property does not exist.\n * @private\n */\nPropertyAttribute.prototype.getProperty = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  return this._properties[propertyId];\n};\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * A property in a property attribute from EXT_structural_metadata.\n *\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension}\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.property The property JSON object.\n * @param {MetadataClassProperty} options.classProperty The class property.\n *\n * @alias PropertyAttributeProperty\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function PropertyAttributeProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const property = options.property;\n  const classProperty = options.classProperty;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.object(\"options.classProperty\", classProperty);\n  //>>includeEnd('debug');\n\n  this._attribute = property.attribute;\n  this._classProperty = classProperty;\n  this._min = property.min;\n  this._max = property.max;\n\n  let offset = property.offset;\n  let scale = property.scale;\n\n  // This needs to be set before handling default values\n  const hasValueTransform =\n    classProperty.hasValueTransform || defined(offset) || defined(scale);\n\n  // If the property attribute does not define an offset/scale, it inherits from\n  // the class property. The class property handles setting the default of\n  // identity: (offset 0, scale 1) with the same scalar/vector/matrix types.\n  // array types are disallowed by the spec.\n  offset = defaultValue(offset, classProperty.offset);\n  scale = defaultValue(scale, classProperty.scale);\n\n  // offset and scale are applied on the GPU, so unpack the values\n  // as math types we can use in uniform callbacks.\n  offset = classProperty.unpackVectorAndMatrixTypes(offset);\n  scale = classProperty.unpackVectorAndMatrixTypes(scale);\n\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n\n  this._extras = property.extras;\n  this._extensions = property.extensions;\n}\n\nObject.defineProperties(PropertyAttributeProperty.prototype, {\n  /**\n   * The attribute semantic\n   *\n   * @memberof PropertyAttributeProperty.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  attribute: {\n    get: function () {\n      return this._attribute;\n    },\n  },\n\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    },\n  },\n\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @readonly\n   * @private\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    },\n  },\n\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @readonly\n   * @private\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof PropertyAttributeProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof PropertyAttributeProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * A property table for use with the <code>EXT_structural_metadata</code> extension or\n * legacy <code>EXT_feature_metadata</code> glTF extension. It also includes some\n * options to be compatible with the 3D Tiles 1.0 batch table.\n * <p>\n * For batch tables, properties are resolved in the following order:\n * </p>\n * <ol>\n *   <li>binary properties from options.metadataTable</li>\n *   <li>JSON properties from options.jsonMetadataTable</li>\n *   <li>batch table hierarchy properties from options.batchTableHierarchy</li>\n * </ol>\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} [options.name] Human-readable name to describe the table\n * @param {String|Number} [options.id] A unique id to identify the property table, useful for debugging. For <code>EXT_structural_metadata</code>, this is the array index in the property tables array, for <code>EXT_feature_metadata</code> this is the dictionary key in the property tables dictionary.\n * @param {Number} options.count The number of features in the table.\n * @param {MetadataTable} [options.metadataTable] A table of binary properties.\n * @param {JsonMetadataTable} [options.jsonMetadataTable] For compatibility with the old batch table, free-form JSON properties can be passed in.\n * @param {BatchTableHierarchy} [options.batchTableHierarchy] For compatibility with the <code>3DTILES_batch_table_hierarchy</code> extension, a hierarchy can be provided.\n * @param {Object} [options.extras] Extra user-defined properties\n * @param {Object} [options.extensions] An object containing extensions\n *\n * @alias PropertyTable\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction PropertyTable(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.count\", options.count);\n  //>>includeEnd('debug');\n\n  this._name = options.name;\n  this._id = options.id;\n  this._count = options.count;\n  this._extras = options.extras;\n  this._extensions = options.extensions;\n  this._metadataTable = options.metadataTable;\n  this._jsonMetadataTable = options.jsonMetadataTable;\n  this._batchTableHierarchy = options.batchTableHierarchy;\n}\n\nObject.defineProperties(PropertyTable.prototype, {\n  /**\n   * A human-readable name for this table\n   *\n   * @memberof PropertyTable.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * An identifier for this table. Useful for debugging.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {String|Number}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * The number of features in the table.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  count: {\n    get: function () {\n      return this._count;\n    },\n  },\n\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {MetadataClass}\n   * @readonly\n   */\n  class: {\n    get: function () {\n      if (defined(this._metadataTable)) {\n        return this._metadataTable.class;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof PropertyTable.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * Returns whether the feature has this property. For compatibility with the <code>3DTILES_batch_table_hierarchy</code> extension, this is computed for a specific feature.\n *\n * @param {Number} index The index of the feature.\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the feature has this property.\n * @private\n */\nPropertyTable.prototype.hasProperty = function (index, propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  if (\n    defined(this._metadataTable) &&\n    this._metadataTable.hasProperty(propertyId)\n  ) {\n    return true;\n  }\n\n  if (\n    defined(this._jsonMetadataTable) &&\n    this._jsonMetadataTable.hasProperty(propertyId)\n  ) {\n    return true;\n  }\n\n  if (\n    defined(this._batchTableHierarchy) &&\n    this._batchTableHierarchy.hasProperty(index, propertyId)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Returns whether the feature has a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {Boolean} Whether the feature has a property with the given semantic.\n * @private\n */\nPropertyTable.prototype.hasPropertyBySemantic = function (index, semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.hasPropertyBySemantic(semantic);\n  }\n\n  return false;\n};\n\n/**\n * Returns whether any feature has this property.\n * This is mainly useful for checking whether a property exists in the class\n * hierarchy when using the <code>3DTILES_batch_table_hierarchy</code> extension.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether any feature has this property.\n * @private\n */\nPropertyTable.prototype.propertyExists = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  if (\n    defined(this._metadataTable) &&\n    this._metadataTable.hasProperty(propertyId)\n  ) {\n    return true;\n  }\n\n  if (\n    defined(this._jsonMetadataTable) &&\n    this._jsonMetadataTable.hasProperty(propertyId)\n  ) {\n    return true;\n  }\n\n  if (\n    defined(this._batchTableHierarchy) &&\n    this._batchTableHierarchy.propertyExists(propertyId)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Returns whether any feature has a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {Boolean} Whether any feature has a property with the given semantic.\n * @private\n */\nPropertyTable.prototype.propertyExistsBySemantic = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.hasPropertyBySemantic(semantic);\n  }\n\n  return false;\n};\n\nconst scratchResults = [];\n\n/**\n * Returns an array of property IDs. For compatibility with the <code>3DTILES_batch_table_hierarchy</code> extension, this is computed for a specific feature.\n *\n * @param {Number} index The index of the feature.\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nPropertyTable.prototype.getPropertyIds = function (index, results) {\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  if (defined(this._metadataTable)) {\n    // concat in place to avoid unnecessary array allocation\n    results.push.apply(\n      results,\n      this._metadataTable.getPropertyIds(scratchResults)\n    );\n  }\n\n  if (defined(this._jsonMetadataTable)) {\n    results.push.apply(\n      results,\n      this._jsonMetadataTable.getPropertyIds(scratchResults)\n    );\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    results.push.apply(\n      results,\n      this._batchTableHierarchy.getPropertyIds(index, scratchResults)\n    );\n  }\n\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {Number} index The index of the feature.\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n * @private\n */\nPropertyTable.prototype.getProperty = function (index, propertyId) {\n  let result;\n  if (defined(this._metadataTable)) {\n    result = this._metadataTable.getProperty(index, propertyId);\n    if (defined(result)) {\n      return result;\n    }\n  }\n\n  if (defined(this._jsonMetadataTable)) {\n    result = this._jsonMetadataTable.getProperty(index, propertyId);\n    if (defined(result)) {\n      return result;\n    }\n  }\n\n  if (defined(this._batchTableHierarchy)) {\n    result = this._batchTableHierarchy.getProperty(index, propertyId);\n    if (defined(result)) {\n      return result;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {Number} index The index of the feature.\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nPropertyTable.prototype.setProperty = function (index, propertyId, value) {\n  if (\n    defined(this._metadataTable) &&\n    this._metadataTable.setProperty(index, propertyId, value)\n  ) {\n    return true;\n  }\n\n  if (\n    defined(this._jsonMetadataTable) &&\n    this._jsonMetadataTable.setProperty(index, propertyId, value)\n  ) {\n    return true;\n  }\n\n  return (\n    defined(this._batchTableHierarchy) &&\n    this._batchTableHierarchy.setProperty(index, propertyId, value)\n  );\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not have\n * semantics.\n * </p>\n *\n * @param {Number} index The index of the feature.\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this semantic.\n * @private\n */\nPropertyTable.prototype.getPropertyBySemantic = function (index, semantic) {\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.getPropertyBySemantic(index, semantic);\n  }\n\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given semantic.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not have\n * semantics.\n * </p>\n *\n * @param {Number} index The index of the feature.\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nPropertyTable.prototype.setPropertyBySemantic = function (\n  index,\n  semantic,\n  value\n) {\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.setPropertyBySemantic(index, semantic, value);\n  }\n\n  return false;\n};\n\n/**\n * Returns a typed array containing the property values for a given propertyId.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not store\n * values in typed arrays.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nPropertyTable.prototype.getPropertyTypedArray = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.getPropertyTypedArray(propertyId);\n  }\n\n  return undefined;\n};\n\n/**\n * Returns a typed array containing the property values for the property with the given semantic.\n * <p>\n * This only operates on the underlying {@link MetadataTable} (if present) as\n * {@link JsonMetadataTable} and {@link BatchTableHierarchy} do not have\n * semantics.\n * </p>\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nPropertyTable.prototype.getPropertyTypedArrayBySemantic = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  if (defined(this._metadataTable)) {\n    return this._metadataTable.getPropertyTypedArrayBySemantic(semantic);\n  }\n\n  return undefined;\n};\n\nexport default PropertyTable;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport PropertyTextureProperty from \"./PropertyTextureProperty.js\";\n\n/**\n * A property texture.\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} [options.name] Optional human-readable name to describe the texture\n * @param {String|Number} [options.id] A unique id to identify the property texture, useful for debugging. For <code>EXT_structural_metadata</code>, this is the array index in the property textures array, for <code>EXT_feature_metadata</code> this is the dictionary key in the property textures dictionary.\n * @param {Object} options.propertyTexture The property texture JSON, following the EXT_structural_metadata schema.\n * @param {MetadataClass} options.class The class that properties conform to.\n * @param {Object.<String, Texture>} options.textures An object mapping texture IDs to {@link Texture} objects.\n *\n * @alias PropertyTexture\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction PropertyTexture(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const propertyTexture = options.propertyTexture;\n  const classDefinition = options.class;\n  const textures = options.textures;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.propertyTexture\", propertyTexture);\n  Check.typeOf.object(\"options.class\", classDefinition);\n  Check.typeOf.object(\"options.textures\", textures);\n  //>>includeEnd('debug');\n\n  const extensions = propertyTexture.extensions;\n  const extras = propertyTexture.extras;\n\n  const properties = {};\n  if (defined(propertyTexture.properties)) {\n    for (const propertyId in propertyTexture.properties) {\n      if (propertyTexture.properties.hasOwnProperty(propertyId)) {\n        properties[propertyId] = new PropertyTextureProperty({\n          property: propertyTexture.properties[propertyId],\n          classProperty: classDefinition.properties[propertyId],\n          textures: textures,\n        });\n      }\n    }\n  }\n\n  this._name = options.name;\n  this._id = options.id;\n  this._class = classDefinition;\n  this._properties = properties;\n  this._extras = extras;\n  this._extensions = extensions;\n}\n\nObject.defineProperties(PropertyTexture.prototype, {\n  /**\n   * A human-readable name for this texture\n   *\n   * @memberof PropertyTexture.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n  /**\n   * An identifier for this texture. Useful for debugging.\n   *\n   * @memberof PropertyTexture.prototype\n   * @type {String|Number}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof PropertyTexture.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    get: function () {\n      return this._class;\n    },\n  },\n\n  /**\n   * The properties in this property texture.\n   *\n   * @memberof PropertyTexture.prototype\n   *\n   * @type {PropertyTextureProperty}\n   * @readonly\n   * @private\n   */\n  properties: {\n    get: function () {\n      return this._properties;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof PropertyTexture.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof PropertyTexture.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * Gets the property with the given property ID.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {PropertyTextureProperty|undefined} The property, or <code>undefined</code> if the property does not exist.\n * @private\n */\nPropertyTexture.prototype.getProperty = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  return this._properties[propertyId];\n};\n\nexport default PropertyTexture;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\n\n/**\n * A property in a property texture.\n *\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.property The property JSON object.\n * @param {MetadataClassProperty} options.classProperty The class property.\n * @param {Object.<Number, Texture>} options.textures An object mapping texture IDs to {@link Texture} objects.\n *\n * @alias PropertyTextureProperty\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction PropertyTextureProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const property = options.property;\n  const classProperty = options.classProperty;\n  const textures = options.textures;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.object(\"options.classProperty\", classProperty);\n  Check.typeOf.object(\"options.textures\", textures);\n  //>>includeEnd('debug');\n\n  // in EXT_structural_metadata, the property is a valid glTF textureInfo\n  const textureInfo = property;\n  const textureReader = GltfLoaderUtil.createModelTextureReader({\n    textureInfo: textureInfo,\n    channels: reformatChannels(property.channels),\n    texture: textures[textureInfo.index],\n  });\n\n  this._min = property.min;\n  this._max = property.max;\n\n  let offset = property.offset;\n  let scale = property.scale;\n\n  // This needs to be set before handling default values\n  const hasValueTransform =\n    classProperty.hasValueTransform || defined(offset) || defined(scale);\n\n  // If the property attribute does not define an offset/scale, it inherits from\n  // the class property. The class property handles setting the default of\n  // identity: (offset 0, scale 1) with the same scalar/vector/matrix types.\n  // array types are disallowed by the spec.\n  offset = defaultValue(offset, classProperty.offset);\n  scale = defaultValue(scale, classProperty.scale);\n\n  // offset and scale are applied on the GPU, so unpack the values\n  // as math types we can use in uniform callbacks.\n  offset = classProperty.unpackVectorAndMatrixTypes(offset);\n  scale = classProperty.unpackVectorAndMatrixTypes(scale);\n\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n\n  this._textureReader = textureReader;\n  this._classProperty = classProperty;\n  this._extras = property.extras;\n  this._extensions = property.extensions;\n}\n\nObject.defineProperties(PropertyTextureProperty.prototype, {\n  /**\n   * The texture reader.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {ModelComponents.TextureReader}\n   * @readonly\n   * @private\n   */\n  textureReader: {\n    get: function () {\n      return this._textureReader;\n    },\n  },\n\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    },\n  },\n\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @readonly\n   * @private\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    },\n  },\n\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @readonly\n   * @private\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof PropertyTextureProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\nPropertyTextureProperty.prototype.isGpuCompatible = function () {\n  const classProperty = this._classProperty;\n  const type = classProperty.type;\n  const componentType = classProperty.componentType;\n\n  if (classProperty.isArray) {\n    // only support arrays of 1-4 UINT8 scalars (normalized or unnormalized)\n    return (\n      !classProperty.isVariableLengthArray &&\n      classProperty.arrayLength <= 4 &&\n      type === MetadataType.SCALAR &&\n      componentType === MetadataComponentType.UINT8\n    );\n  }\n\n  if (MetadataType.isVectorType(type) || type === MetadataType.SCALAR) {\n    return componentType === MetadataComponentType.UINT8;\n  }\n\n  // For this initial implementation, only UINT8-based properties\n  // are supported.\n  return false;\n};\n\nconst floatTypesByComponentCount = [undefined, \"float\", \"vec2\", \"vec3\", \"vec4\"];\nconst integerTypesByComponentCount = [\n  undefined,\n  \"int\",\n  \"ivec2\",\n  \"ivec3\",\n  \"ivec4\",\n];\nPropertyTextureProperty.prototype.getGlslType = function () {\n  const classProperty = this._classProperty;\n\n  let componentCount = MetadataType.getComponentCount(classProperty.type);\n  if (classProperty.isArray) {\n    // fixed-sized arrays of length 2-4 UINT8s are represented as vectors as the\n    // shader since those are more useful in GLSL.\n    componentCount = classProperty.arrayLength;\n  }\n\n  // Normalized UINT8 properties are float types in the shader\n  if (classProperty.normalized) {\n    return floatTypesByComponentCount[componentCount];\n  }\n\n  // other UINT8-based properties are represented as integer types.\n  return integerTypesByComponentCount[componentCount];\n};\n\nPropertyTextureProperty.prototype.unpackInShader = function (packedValueGlsl) {\n  const classProperty = this._classProperty;\n\n  // no unpacking needed if for normalized types\n  if (classProperty.normalized) {\n    return packedValueGlsl;\n  }\n\n  // integer types are read from the texture as normalized float values.\n  // these need to be rescaled to [0, 255] and cast to the appropriate integer\n  // type.\n  const glslType = this.getGlslType();\n  return `${glslType}(255.0 * ${packedValueGlsl})`;\n};\n\n/**\n * Reformat from an array of channel indices like <code>[0, 1]</code> to a\n * string of channels as would be used in GLSL swizzling (e.g. \"rg\")\n *\n * @param {Number[]} channels the channel indices\n * @return {String} The channels as a string of \"r\", \"g\", \"b\" or \"a\" characters.\n * @private\n */\nfunction reformatChannels(channels) {\n  return channels\n    .map(function (channelIndex) {\n      return \"rgba\".charAt(channelIndex);\n    })\n    .join(\"\");\n}\n\nexport default PropertyTextureProperty;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport EllipsoidalOccluder from \"../Core/EllipsoidalOccluder.js\";\n\n/**\n * A set of occluders that can be used to test quadtree tiles for occlusion.\n *\n * @alias QuadtreeOccluders\n * @constructor\n * @private\n *\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid that potentially occludes tiles.\n */\nfunction QuadtreeOccluders(options) {\n  this._ellipsoid = new EllipsoidalOccluder(options.ellipsoid, Cartesian3.ZERO);\n}\n\nObject.defineProperties(QuadtreeOccluders.prototype, {\n  /**\n   * Gets the {@link EllipsoidalOccluder} that can be used to determine if a point is\n   * occluded by an {@link Ellipsoid}.\n   * @type {EllipsoidalOccluder}\n   * @memberof QuadtreeOccluders.prototype\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\nexport default QuadtreeOccluders;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport QuadtreeOccluders from \"./QuadtreeOccluders.js\";\nimport QuadtreeTile from \"./QuadtreeTile.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TileReplacementQueue from \"./TileReplacementQueue.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Renders massive sets of data by utilizing level-of-detail and culling.  The globe surface is divided into\n * a quadtree of tiles with large, low-detail tiles at the root and small, high-detail tiles at the leaves.\n * The set of tiles to render is selected by projecting an estimate of the geometric error in a tile onto\n * the screen to estimate screen-space error, in pixels, which must be below a user-specified threshold.\n * The actual content of the tiles is arbitrary and is specified using a {@link QuadtreeTileProvider}.\n *\n * @alias QuadtreePrimitive\n * @constructor\n * @private\n *\n * @param {QuadtreeTileProvider} options.tileProvider The tile provider that loads, renders, and estimates\n *        the distance to individual tiles.\n * @param {Number} [options.maximumScreenSpaceError=2] The maximum screen-space error, in pixels, that is allowed.\n *        A higher maximum error will render fewer tiles and improve performance, while a lower\n *        value will improve visual quality.\n * @param {Number} [options.tileCacheSize=100] The maximum number of tiles that will be retained in the tile cache.\n *        Note that tiles will never be unloaded if they were used for rendering the last\n *        frame, so the actual number of resident tiles may be higher.  The value of\n *        this property will not affect visual quality.\n */\nfunction QuadtreePrimitive(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.tileProvider)) {\n    throw new DeveloperError(\"options.tileProvider is required.\");\n  }\n  if (defined(options.tileProvider.quadtree)) {\n    throw new DeveloperError(\n      \"A QuadtreeTileProvider can only be used with a single QuadtreePrimitive\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._tileProvider = options.tileProvider;\n  this._tileProvider.quadtree = this;\n\n  this._debug = {\n    enableDebugOutput: false,\n\n    maxDepth: 0,\n    maxDepthVisited: 0,\n    tilesVisited: 0,\n    tilesCulled: 0,\n    tilesRendered: 0,\n    tilesWaitingForChildren: 0,\n\n    lastMaxDepth: -1,\n    lastMaxDepthVisited: -1,\n    lastTilesVisited: -1,\n    lastTilesCulled: -1,\n    lastTilesRendered: -1,\n    lastTilesWaitingForChildren: -1,\n\n    suspendLodUpdate: false,\n  };\n\n  const tilingScheme = this._tileProvider.tilingScheme;\n  const ellipsoid = tilingScheme.ellipsoid;\n\n  this._tilesToRender = [];\n  this._tileLoadQueueHigh = []; // high priority tiles are preventing refinement\n  this._tileLoadQueueMedium = []; // medium priority tiles are being rendered\n  this._tileLoadQueueLow = []; // low priority tiles were refined past or are non-visible parts of quads.\n  this._tileReplacementQueue = new TileReplacementQueue();\n  this._levelZeroTiles = undefined;\n  this._loadQueueTimeSlice = 5.0;\n  this._tilesInvalidated = false;\n\n  this._addHeightCallbacks = [];\n  this._removeHeightCallbacks = [];\n\n  this._tileToUpdateHeights = [];\n  this._lastTileIndex = 0;\n  this._updateHeightsTimeSlice = 2.0;\n\n  // If a culled tile contains _cameraPositionCartographic or _cameraReferenceFrameOriginCartographic, it will be marked\n  // TileSelectionResult.CULLED_BUT_NEEDED and added to the list of tiles to update heights,\n  // even though it is not rendered.\n  // These are updated each frame in `selectTilesForRendering`.\n  this._cameraPositionCartographic = undefined;\n  this._cameraReferenceFrameOriginCartographic = undefined;\n\n  /**\n   * Gets or sets the maximum screen-space error, in pixels, that is allowed.\n   * A higher maximum error will render fewer tiles and improve performance, while a lower\n   * value will improve visual quality.\n   * @type {Number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = defaultValue(\n    options.maximumScreenSpaceError,\n    2\n  );\n\n  /**\n   * Gets or sets the maximum number of tiles that will be retained in the tile cache.\n   * Note that tiles will never be unloaded if they were used for rendering the last\n   * frame, so the actual number of resident tiles may be higher.  The value of\n   * this property will not affect visual quality.\n   * @type {Number}\n   * @default 100\n   */\n  this.tileCacheSize = defaultValue(options.tileCacheSize, 100);\n\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {Number}\n   * @default 20\n   */\n  this.loadingDescendantLimit = 20;\n\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {Boolean}\n   * @default true\n   */\n  this.preloadAncestors = true;\n\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {Boolean}\n   * @default false\n   */\n  this.preloadSiblings = false;\n\n  this._occluders = new QuadtreeOccluders({\n    ellipsoid: ellipsoid,\n  });\n\n  this._tileLoadProgressEvent = new Event();\n  this._lastTileLoadQueueLength = 0;\n\n  this._lastSelectionFrameNumber = undefined;\n}\n\nObject.defineProperties(QuadtreePrimitive.prototype, {\n  /**\n   * Gets the provider of {@link QuadtreeTile} instances for this quadtree.\n   * @type {QuadtreeTile}\n   * @memberof QuadtreePrimitive.prototype\n   */\n  tileProvider: {\n    get: function () {\n      return this._tileProvider;\n    },\n  },\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof QuadtreePrimitive.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._tileLoadProgressEvent;\n    },\n  },\n\n  occluders: {\n    get: function () {\n      return this._occluders;\n    },\n  },\n});\n\n/**\n * Invalidates and frees all the tiles in the quadtree.  The tiles must be reloaded\n * before they can be displayed.\n *\n * @memberof QuadtreePrimitive\n */\nQuadtreePrimitive.prototype.invalidateAllTiles = function () {\n  this._tilesInvalidated = true;\n};\n\nfunction invalidateAllTiles(primitive) {\n  // Clear the replacement queue\n  const replacementQueue = primitive._tileReplacementQueue;\n  replacementQueue.head = undefined;\n  replacementQueue.tail = undefined;\n  replacementQueue.count = 0;\n\n  clearTileLoadQueue(primitive);\n\n  // Free and recreate the level zero tiles.\n  const levelZeroTiles = primitive._levelZeroTiles;\n  if (defined(levelZeroTiles)) {\n    for (let i = 0; i < levelZeroTiles.length; ++i) {\n      const tile = levelZeroTiles[i];\n      const customData = tile.customData;\n      const customDataLength = customData.length;\n\n      for (let j = 0; j < customDataLength; ++j) {\n        const data = customData[j];\n        data.level = 0;\n        primitive._addHeightCallbacks.push(data);\n      }\n\n      levelZeroTiles[i].freeResources();\n    }\n  }\n\n  primitive._levelZeroTiles = undefined;\n\n  primitive._tileProvider.cancelReprojections();\n}\n\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that is partially\n * or completely loaded.\n *\n * @param {Function} tileFunction The function to invoke for each loaded tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\nQuadtreePrimitive.prototype.forEachLoadedTile = function (tileFunction) {\n  let tile = this._tileReplacementQueue.head;\n  while (defined(tile)) {\n    if (tile.state !== QuadtreeTileLoadState.START) {\n      tileFunction(tile);\n    }\n    tile = tile.replacementNext;\n  }\n};\n\n/**\n * Invokes a specified function for each {@link QuadtreeTile} that was rendered\n * in the most recent frame.\n *\n * @param {Function} tileFunction The function to invoke for each rendered tile.  The\n *        function is passed a reference to the tile as its only parameter.\n */\nQuadtreePrimitive.prototype.forEachRenderedTile = function (tileFunction) {\n  const tilesRendered = this._tilesToRender;\n  for (let i = 0, len = tilesRendered.length; i < len; ++i) {\n    tileFunction(tilesRendered[i]);\n  }\n};\n\n/**\n * Calls the callback when a new tile is rendered that contains the given cartographic. The only parameter\n * is the cartesian position on the tile.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Function} callback The function to be called when a new tile is loaded containing cartographic.\n * @returns {Function} The function to remove this callback from the quadtree.\n */\nQuadtreePrimitive.prototype.updateHeight = function (cartographic, callback) {\n  const primitive = this;\n  const object = {\n    positionOnEllipsoidSurface: undefined,\n    positionCartographic: cartographic,\n    level: -1,\n    callback: callback,\n  };\n\n  object.removeFunc = function () {\n    const addedCallbacks = primitive._addHeightCallbacks;\n    const length = addedCallbacks.length;\n    for (let i = 0; i < length; ++i) {\n      if (addedCallbacks[i] === object) {\n        addedCallbacks.splice(i, 1);\n        break;\n      }\n    }\n    primitive._removeHeightCallbacks.push(object);\n    if (object.callback) {\n      object.callback = undefined;\n    }\n  };\n\n  primitive._addHeightCallbacks.push(object);\n  return object.removeFunc;\n};\n\n/**\n * Updates the tile provider imagery and continues to process the tile load queue.\n * @private\n */\nQuadtreePrimitive.prototype.update = function (frameState) {\n  if (defined(this._tileProvider.update)) {\n    this._tileProvider.update(frameState);\n  }\n};\n\nfunction clearTileLoadQueue(primitive) {\n  const debug = primitive._debug;\n  debug.maxDepth = 0;\n  debug.maxDepthVisited = 0;\n  debug.tilesVisited = 0;\n  debug.tilesCulled = 0;\n  debug.tilesRendered = 0;\n  debug.tilesWaitingForChildren = 0;\n\n  primitive._tileLoadQueueHigh.length = 0;\n  primitive._tileLoadQueueMedium.length = 0;\n  primitive._tileLoadQueueLow.length = 0;\n}\n\n/**\n * Initializes values for a new render frame and prepare the tile load queue.\n * @private\n */\nQuadtreePrimitive.prototype.beginFrame = function (frameState) {\n  const passes = frameState.passes;\n  if (!passes.render) {\n    return;\n  }\n\n  if (this._tilesInvalidated) {\n    invalidateAllTiles(this);\n    this._tilesInvalidated = false;\n  }\n\n  // Gets commands for any texture re-projections\n  this._tileProvider.initialize(frameState);\n\n  clearTileLoadQueue(this);\n\n  if (this._debug.suspendLodUpdate) {\n    return;\n  }\n\n  this._tileReplacementQueue.markStartOfRenderFrame();\n};\n\n/**\n * Selects new tiles to load based on the frame state and creates render commands.\n * @private\n */\nQuadtreePrimitive.prototype.render = function (frameState) {\n  const passes = frameState.passes;\n  const tileProvider = this._tileProvider;\n\n  if (passes.render) {\n    tileProvider.beginUpdate(frameState);\n\n    selectTilesForRendering(this, frameState);\n    createRenderCommandsForSelectedTiles(this, frameState);\n\n    tileProvider.endUpdate(frameState);\n  }\n\n  if (passes.pick && this._tilesToRender.length > 0) {\n    tileProvider.updateForPick(frameState);\n  }\n};\n\n/**\n * Checks if the load queue length has changed since the last time we raised a queue change event - if so, raises\n * a new change event at the end of the render cycle.\n * @private\n */\nfunction updateTileLoadProgress(primitive, frameState) {\n  const currentLoadQueueLength =\n    primitive._tileLoadQueueHigh.length +\n    primitive._tileLoadQueueMedium.length +\n    primitive._tileLoadQueueLow.length;\n\n  if (\n    currentLoadQueueLength !== primitive._lastTileLoadQueueLength ||\n    primitive._tilesInvalidated\n  ) {\n    frameState.afterRender.push(\n      Event.prototype.raiseEvent.bind(\n        primitive._tileLoadProgressEvent,\n        currentLoadQueueLength\n      )\n    );\n    primitive._lastTileLoadQueueLength = currentLoadQueueLength;\n  }\n\n  const debug = primitive._debug;\n  if (debug.enableDebugOutput && !debug.suspendLodUpdate) {\n    debug.maxDepth = primitive._tilesToRender.reduce(function (max, tile) {\n      return Math.max(max, tile.level);\n    }, -1);\n    debug.tilesRendered = primitive._tilesToRender.length;\n\n    if (\n      debug.tilesVisited !== debug.lastTilesVisited ||\n      debug.tilesRendered !== debug.lastTilesRendered ||\n      debug.tilesCulled !== debug.lastTilesCulled ||\n      debug.maxDepth !== debug.lastMaxDepth ||\n      debug.tilesWaitingForChildren !== debug.lastTilesWaitingForChildren ||\n      debug.maxDepthVisited !== debug.lastMaxDepthVisited\n    ) {\n      console.log(\n        `Visited ${debug.tilesVisited}, Rendered: ${debug.tilesRendered}, Culled: ${debug.tilesCulled}, Max Depth Rendered: ${debug.maxDepth}, Max Depth Visited: ${debug.maxDepthVisited}, Waiting for children: ${debug.tilesWaitingForChildren}`\n      );\n\n      debug.lastTilesVisited = debug.tilesVisited;\n      debug.lastTilesRendered = debug.tilesRendered;\n      debug.lastTilesCulled = debug.tilesCulled;\n      debug.lastMaxDepth = debug.maxDepth;\n      debug.lastTilesWaitingForChildren = debug.tilesWaitingForChildren;\n      debug.lastMaxDepthVisited = debug.maxDepthVisited;\n    }\n  }\n}\n\n/**\n * Updates terrain heights.\n * @private\n */\nQuadtreePrimitive.prototype.endFrame = function (frameState) {\n  const passes = frameState.passes;\n  if (!passes.render || frameState.mode === SceneMode.MORPHING) {\n    // Only process the load queue for a single pass.\n    // Don't process the load queue or update heights during the morph flights.\n    return;\n  }\n\n  // Load/create resources for terrain and imagery. Prepare texture re-projections for the next frame.\n  processTileLoadQueue(this, frameState);\n  updateHeights(this, frameState);\n  updateTileLoadProgress(this, frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @memberof QuadtreePrimitive\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see QuadtreePrimitive#destroy\n */\nQuadtreePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @memberof QuadtreePrimitive\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * primitive = primitive && primitive.destroy();\n *\n * @see QuadtreePrimitive#isDestroyed\n */\nQuadtreePrimitive.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n};\n\nlet comparisonPoint;\nconst centerScratch = new Cartographic();\nfunction compareDistanceToPoint(a, b) {\n  let center = Rectangle.center(a.rectangle, centerScratch);\n  const alon = center.longitude - comparisonPoint.longitude;\n  const alat = center.latitude - comparisonPoint.latitude;\n\n  center = Rectangle.center(b.rectangle, centerScratch);\n  const blon = center.longitude - comparisonPoint.longitude;\n  const blat = center.latitude - comparisonPoint.latitude;\n\n  return alon * alon + alat * alat - (blon * blon + blat * blat);\n}\n\nconst cameraOriginScratch = new Cartesian3();\nlet rootTraversalDetails = [];\n\nfunction selectTilesForRendering(primitive, frameState) {\n  const debug = primitive._debug;\n  if (debug.suspendLodUpdate) {\n    return;\n  }\n\n  // Clear the render list.\n  const tilesToRender = primitive._tilesToRender;\n  tilesToRender.length = 0;\n\n  // We can't render anything before the level zero tiles exist.\n  let i;\n  const tileProvider = primitive._tileProvider;\n  if (!defined(primitive._levelZeroTiles)) {\n    if (tileProvider.ready) {\n      const tilingScheme = tileProvider.tilingScheme;\n      primitive._levelZeroTiles = QuadtreeTile.createLevelZeroTiles(\n        tilingScheme\n      );\n      const numberOfRootTiles = primitive._levelZeroTiles.length;\n      if (rootTraversalDetails.length < numberOfRootTiles) {\n        rootTraversalDetails = new Array(numberOfRootTiles);\n        for (i = 0; i < numberOfRootTiles; ++i) {\n          if (rootTraversalDetails[i] === undefined) {\n            rootTraversalDetails[i] = new TraversalDetails();\n          }\n        }\n      }\n    } else {\n      // Nothing to do until the provider is ready.\n      return;\n    }\n  }\n\n  primitive._occluders.ellipsoid.cameraPosition = frameState.camera.positionWC;\n\n  let tile;\n  const levelZeroTiles = primitive._levelZeroTiles;\n  const occluders =\n    levelZeroTiles.length > 1 ? primitive._occluders : undefined;\n\n  // Sort the level zero tiles by the distance from the center to the camera.\n  // The level zero tiles aren't necessarily a nice neat quad, so we can't use the\n  // quadtree ordering we use elsewhere in the tree\n  comparisonPoint = frameState.camera.positionCartographic;\n  levelZeroTiles.sort(compareDistanceToPoint);\n\n  const customDataAdded = primitive._addHeightCallbacks;\n  const customDataRemoved = primitive._removeHeightCallbacks;\n  const frameNumber = frameState.frameNumber;\n\n  let len;\n  if (customDataAdded.length > 0 || customDataRemoved.length > 0) {\n    for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n      tile = levelZeroTiles[i];\n      tile._updateCustomData(frameNumber, customDataAdded, customDataRemoved);\n    }\n\n    customDataAdded.length = 0;\n    customDataRemoved.length = 0;\n  }\n\n  const camera = frameState.camera;\n\n  primitive._cameraPositionCartographic = camera.positionCartographic;\n  const cameraFrameOrigin = Matrix4.getTranslation(\n    camera.transform,\n    cameraOriginScratch\n  );\n  primitive._cameraReferenceFrameOriginCartographic = primitive.tileProvider.tilingScheme.ellipsoid.cartesianToCartographic(\n    cameraFrameOrigin,\n    primitive._cameraReferenceFrameOriginCartographic\n  );\n\n  // Traverse in depth-first, near-to-far order.\n  for (i = 0, len = levelZeroTiles.length; i < len; ++i) {\n    tile = levelZeroTiles[i];\n    primitive._tileReplacementQueue.markTileRendered(tile);\n    if (!tile.renderable) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n      ++debug.tilesWaitingForChildren;\n    } else {\n      visitIfVisible(\n        primitive,\n        tile,\n        tileProvider,\n        frameState,\n        occluders,\n        false,\n        rootTraversalDetails[i]\n      );\n    }\n  }\n\n  primitive._lastSelectionFrameNumber = frameNumber;\n}\n\nfunction queueTileLoad(primitive, queue, tile, frameState) {\n  if (!tile.needsLoading) {\n    return;\n  }\n\n  if (primitive.tileProvider.computeTileLoadPriority !== undefined) {\n    tile._loadPriority = primitive.tileProvider.computeTileLoadPriority(\n      tile,\n      frameState\n    );\n  }\n  queue.push(tile);\n}\n\n/**\n * Tracks details of traversing a tile while selecting tiles for rendering.\n * @alias TraversalDetails\n * @constructor\n * @private\n */\nfunction TraversalDetails() {\n  /**\n   * True if all selected (i.e. not culled or refined) tiles in this tile's subtree\n   * are renderable. If the subtree is renderable, we'll render it; no drama.\n   */\n  this.allAreRenderable = true;\n\n  /**\n   * True if any tiles in this tile's subtree were rendered last frame. If any\n   * were, we must render the subtree rather than this tile, because rendering\n   * this tile would cause detail to vanish that was visible last frame, and\n   * that's no good.\n   */\n  this.anyWereRenderedLastFrame = false;\n\n  /**\n   * Counts the number of selected tiles in this tile's subtree that are\n   * not yet ready to be rendered because they need more loading. Note that\n   * this value will _not_ necessarily be zero when\n   * {@link TraversalDetails#allAreRenderable} is true, for subtle reasons.\n   * When {@link TraversalDetails#allAreRenderable} and\n   * {@link TraversalDetails#anyWereRenderedLastFrame} are both false, we\n   * will render this tile instead of any tiles in its subtree and\n   * the `allAreRenderable` value for this tile will reflect only whether _this_\n   * tile is renderable. The `notYetRenderableCount` value, however, will still\n   * reflect the total number of tiles that we are waiting on, including the\n   * ones that we're not rendering. `notYetRenderableCount` is only reset\n   * when a subtree is removed from the render queue because the\n   * `notYetRenderableCount` exceeds the\n   * {@link QuadtreePrimitive#loadingDescendantLimit}.\n   */\n  this.notYetRenderableCount = 0;\n}\n\nfunction TraversalQuadDetails() {\n  this.southwest = new TraversalDetails();\n  this.southeast = new TraversalDetails();\n  this.northwest = new TraversalDetails();\n  this.northeast = new TraversalDetails();\n}\n\nTraversalQuadDetails.prototype.combine = function (result) {\n  const southwest = this.southwest;\n  const southeast = this.southeast;\n  const northwest = this.northwest;\n  const northeast = this.northeast;\n\n  result.allAreRenderable =\n    southwest.allAreRenderable &&\n    southeast.allAreRenderable &&\n    northwest.allAreRenderable &&\n    northeast.allAreRenderable;\n  result.anyWereRenderedLastFrame =\n    southwest.anyWereRenderedLastFrame ||\n    southeast.anyWereRenderedLastFrame ||\n    northwest.anyWereRenderedLastFrame ||\n    northeast.anyWereRenderedLastFrame;\n  result.notYetRenderableCount =\n    southwest.notYetRenderableCount +\n    southeast.notYetRenderableCount +\n    northwest.notYetRenderableCount +\n    northeast.notYetRenderableCount;\n};\n\nconst traversalQuadsByLevel = new Array(31); // level 30 tiles are ~2cm wide at the equator, should be good enough.\nfor (let i = 0; i < traversalQuadsByLevel.length; ++i) {\n  traversalQuadsByLevel[i] = new TraversalQuadDetails();\n}\n\n/**\n * Visits a tile for possible rendering. When we call this function with a tile:\n *\n *    * the tile has been determined to be visible (possibly based on a bounding volume that is not very tight-fitting)\n *    * its parent tile does _not_ meet the SSE (unless ancestorMeetsSse=true, see comments below)\n *    * the tile may or may not be renderable\n *\n * @private\n *\n * @param {Primitive} primitive The QuadtreePrimitive.\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to visit\n * @param {Boolean} ancestorMeetsSse True if a tile higher in the tile tree already met the SSE and we're refining further only\n *                  to maintain detail while that higher tile loads.\n * @param {TraversalDetails} traveralDetails On return, populated with details of how the traversal of this tile went.\n */\nfunction visitTile(\n  primitive,\n  frameState,\n  tile,\n  ancestorMeetsSse,\n  traversalDetails\n) {\n  const debug = primitive._debug;\n\n  ++debug.tilesVisited;\n\n  primitive._tileReplacementQueue.markTileRendered(tile);\n  tile._updateCustomData(frameState.frameNumber);\n\n  if (tile.level > debug.maxDepthVisited) {\n    debug.maxDepthVisited = tile.level;\n  }\n\n  const meetsSse =\n    screenSpaceError(primitive, frameState, tile) <\n    primitive.maximumScreenSpaceError;\n\n  const southwestChild = tile.southwestChild;\n  const southeastChild = tile.southeastChild;\n  const northwestChild = tile.northwestChild;\n  const northeastChild = tile.northeastChild;\n\n  const lastFrame = primitive._lastSelectionFrameNumber;\n  const lastFrameSelectionResult =\n    tile._lastSelectionResultFrame === lastFrame\n      ? tile._lastSelectionResult\n      : TileSelectionResult.NONE;\n\n  const tileProvider = primitive.tileProvider;\n\n  if (meetsSse || ancestorMeetsSse) {\n    // This tile (or an ancestor) is the one we want to render this frame, but we'll do different things depending\n    // on the state of this tile and on what we did _last_ frame.\n\n    // We can render it if _any_ of the following are true:\n    // 1. We rendered it (or kicked it) last frame.\n    // 2. This tile was culled last frame, or it wasn't even visited because an ancestor was culled.\n    // 3. The tile is completely done loading.\n    // 4. a) Terrain is ready, and\n    //    b) All necessary imagery is ready. Necessary imagery is imagery that was rendered with this tile\n    //       or any descendants last frame. Such imagery is required because rendering this tile without\n    //       it would cause detail to disappear.\n    //\n    // Determining condition 4 is more expensive, so we check the others first.\n    //\n    // Note that even if we decide to render a tile here, it may later get \"kicked\" in favor of an ancestor.\n\n    const oneRenderedLastFrame =\n      TileSelectionResult.originalResult(lastFrameSelectionResult) ===\n      TileSelectionResult.RENDERED;\n    const twoCulledOrNotVisited =\n      TileSelectionResult.originalResult(lastFrameSelectionResult) ===\n        TileSelectionResult.CULLED ||\n      lastFrameSelectionResult === TileSelectionResult.NONE;\n    const threeCompletelyLoaded = tile.state === QuadtreeTileLoadState.DONE;\n\n    let renderable =\n      oneRenderedLastFrame || twoCulledOrNotVisited || threeCompletelyLoaded;\n\n    if (!renderable) {\n      // Check the more expensive condition 4 above. This requires details of the thing\n      // we're rendering (e.g. the globe surface), so delegate it to the tile provider.\n      if (defined(tileProvider.canRenderWithoutLosingDetail)) {\n        renderable = tileProvider.canRenderWithoutLosingDetail(tile);\n      }\n    }\n\n    if (renderable) {\n      // Only load this tile if it (not just an ancestor) meets the SSE.\n      if (meetsSse) {\n        queueTileLoad(\n          primitive,\n          primitive._tileLoadQueueMedium,\n          tile,\n          frameState\n        );\n      }\n      addTileToRenderList(primitive, tile);\n\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame =\n        lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n\n      return;\n    }\n\n    // Otherwise, we can't render this tile (or its fill) because doing so would cause detail to disappear\n    // that was visible last frame. Instead, keep rendering any still-visible descendants that were rendered\n    // last frame and render fills for newly-visible descendants. E.g. if we were rendering level 15 last\n    // frame but this frame we want level 14 and the closest renderable level <= 14 is 0, rendering level\n    // zero would be pretty jarring so instead we keep rendering level 15 even though its SSE is better\n    // than required. So fall through to continue traversal...\n    ancestorMeetsSse = true;\n\n    // Load this blocker tile with high priority, but only if this tile (not just an ancestor) meets the SSE.\n    if (meetsSse) {\n      queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n    }\n  }\n\n  if (tileProvider.canRefine(tile)) {\n    const allAreUpsampled =\n      southwestChild.upsampledFromParent &&\n      southeastChild.upsampledFromParent &&\n      northwestChild.upsampledFromParent &&\n      northeastChild.upsampledFromParent;\n\n    if (allAreUpsampled) {\n      // No point in rendering the children because they're all upsampled.  Render this tile instead.\n      addTileToRenderList(primitive, tile);\n\n      // Rendered tile that's not waiting on children loads with medium priority.\n      queueTileLoad(\n        primitive,\n        primitive._tileLoadQueueMedium,\n        tile,\n        frameState\n      );\n\n      // Make sure we don't unload the children and forget they're upsampled.\n      primitive._tileReplacementQueue.markTileRendered(southwestChild);\n      primitive._tileReplacementQueue.markTileRendered(southeastChild);\n      primitive._tileReplacementQueue.markTileRendered(northwestChild);\n      primitive._tileReplacementQueue.markTileRendered(northeastChild);\n\n      traversalDetails.allAreRenderable = tile.renderable;\n      traversalDetails.anyWereRenderedLastFrame =\n        lastFrameSelectionResult === TileSelectionResult.RENDERED;\n      traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n\n      tile._lastSelectionResultFrame = frameState.frameNumber;\n      tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n      if (!traversalDetails.anyWereRenderedLastFrame) {\n        // Tile is newly-rendered this frame, so update its heights.\n        primitive._tileToUpdateHeights.push(tile);\n      }\n\n      return;\n    }\n\n    // SSE is not good enough, so refine.\n    tile._lastSelectionResultFrame = frameState.frameNumber;\n    tile._lastSelectionResult = TileSelectionResult.REFINED;\n\n    const firstRenderedDescendantIndex = primitive._tilesToRender.length;\n    const loadIndexLow = primitive._tileLoadQueueLow.length;\n    const loadIndexMedium = primitive._tileLoadQueueMedium.length;\n    const loadIndexHigh = primitive._tileLoadQueueHigh.length;\n    const tilesToUpdateHeightsIndex = primitive._tileToUpdateHeights.length;\n\n    // No need to add the children to the load queue because they'll be added (if necessary) when they're visited.\n    visitVisibleChildrenNearToFar(\n      primitive,\n      southwestChild,\n      southeastChild,\n      northwestChild,\n      northeastChild,\n      frameState,\n      ancestorMeetsSse,\n      traversalDetails\n    );\n\n    // If no descendant tiles were added to the render list by the function above, it means they were all\n    // culled even though this tile was deemed visible. That's pretty common.\n\n    if (firstRenderedDescendantIndex !== primitive._tilesToRender.length) {\n      // At least one descendant tile was added to the render list.\n      // The traversalDetails tell us what happened while visiting the children.\n\n      const allAreRenderable = traversalDetails.allAreRenderable;\n      const anyWereRenderedLastFrame =\n        traversalDetails.anyWereRenderedLastFrame;\n      const notYetRenderableCount = traversalDetails.notYetRenderableCount;\n      let queuedForLoad = false;\n\n      if (!allAreRenderable && !anyWereRenderedLastFrame) {\n        // Some of our descendants aren't ready to render yet, and none were rendered last frame,\n        // so kick them all out of the render list and render this tile instead. Continue to load them though!\n\n        // Mark the rendered descendants and their ancestors - up to this tile - as kicked.\n        const renderList = primitive._tilesToRender;\n        for (let i = firstRenderedDescendantIndex; i < renderList.length; ++i) {\n          let workTile = renderList[i];\n          while (\n            workTile !== undefined &&\n            workTile._lastSelectionResult !== TileSelectionResult.KICKED &&\n            workTile !== tile\n          ) {\n            workTile._lastSelectionResult = TileSelectionResult.kick(\n              workTile._lastSelectionResult\n            );\n            workTile = workTile.parent;\n          }\n        }\n\n        // Remove all descendants from the render list and add this tile.\n        primitive._tilesToRender.length = firstRenderedDescendantIndex;\n        primitive._tileToUpdateHeights.length = tilesToUpdateHeightsIndex;\n        addTileToRenderList(primitive, tile);\n\n        tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n        // If we're waiting on heaps of descendants, the above will take too long. So in that case,\n        // load this tile INSTEAD of loading any of the descendants, and tell the up-level we're only waiting\n        // on this tile. Keep doing this until we actually manage to render this tile.\n        const wasRenderedLastFrame =\n          lastFrameSelectionResult === TileSelectionResult.RENDERED;\n        if (\n          !wasRenderedLastFrame &&\n          notYetRenderableCount > primitive.loadingDescendantLimit\n        ) {\n          // Remove all descendants from the load queues.\n          primitive._tileLoadQueueLow.length = loadIndexLow;\n          primitive._tileLoadQueueMedium.length = loadIndexMedium;\n          primitive._tileLoadQueueHigh.length = loadIndexHigh;\n          queueTileLoad(\n            primitive,\n            primitive._tileLoadQueueMedium,\n            tile,\n            frameState\n          );\n          traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n          queuedForLoad = true;\n        }\n\n        traversalDetails.allAreRenderable = tile.renderable;\n        traversalDetails.anyWereRenderedLastFrame = wasRenderedLastFrame;\n\n        if (!wasRenderedLastFrame) {\n          // Tile is newly-rendered this frame, so update its heights.\n          primitive._tileToUpdateHeights.push(tile);\n        }\n\n        ++debug.tilesWaitingForChildren;\n      }\n\n      if (primitive.preloadAncestors && !queuedForLoad) {\n        queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n      }\n    }\n\n    return;\n  }\n\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n  tile._lastSelectionResult = TileSelectionResult.RENDERED;\n\n  // We'd like to refine but can't because we have no availability data for this tile's children,\n  // so we have no idea if refinining would involve a load or an upsample. We'll have to finish\n  // loading this tile first in order to find that out, so load this refinement blocker with\n  // high priority.\n  addTileToRenderList(primitive, tile);\n  queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);\n\n  traversalDetails.allAreRenderable = tile.renderable;\n  traversalDetails.anyWereRenderedLastFrame =\n    lastFrameSelectionResult === TileSelectionResult.RENDERED;\n  traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;\n}\n\nfunction visitVisibleChildrenNearToFar(\n  primitive,\n  southwest,\n  southeast,\n  northwest,\n  northeast,\n  frameState,\n  ancestorMeetsSse,\n  traversalDetails\n) {\n  const cameraPosition = frameState.camera.positionCartographic;\n  const tileProvider = primitive._tileProvider;\n  const occluders = primitive._occluders;\n\n  const quadDetails = traversalQuadsByLevel[southwest.level];\n  const southwestDetails = quadDetails.southwest;\n  const southeastDetails = quadDetails.southeast;\n  const northwestDetails = quadDetails.northwest;\n  const northeastDetails = quadDetails.northeast;\n\n  if (cameraPosition.longitude < southwest.rectangle.east) {\n    if (cameraPosition.latitude < southwest.rectangle.north) {\n      // Camera in southwest quadrant\n      visitIfVisible(\n        primitive,\n        southwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southwestDetails\n      );\n      visitIfVisible(\n        primitive,\n        southeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southeastDetails\n      );\n      visitIfVisible(\n        primitive,\n        northwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northwestDetails\n      );\n      visitIfVisible(\n        primitive,\n        northeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northeastDetails\n      );\n    } else {\n      // Camera in northwest quadrant\n      visitIfVisible(\n        primitive,\n        northwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northwestDetails\n      );\n      visitIfVisible(\n        primitive,\n        southwest,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southwestDetails\n      );\n      visitIfVisible(\n        primitive,\n        northeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        northeastDetails\n      );\n      visitIfVisible(\n        primitive,\n        southeast,\n        tileProvider,\n        frameState,\n        occluders,\n        ancestorMeetsSse,\n        southeastDetails\n      );\n    }\n  } else if (cameraPosition.latitude < southwest.rectangle.north) {\n    // Camera southeast quadrant\n    visitIfVisible(\n      primitive,\n      southeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southeastDetails\n    );\n    visitIfVisible(\n      primitive,\n      southwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southwestDetails\n    );\n    visitIfVisible(\n      primitive,\n      northeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northeastDetails\n    );\n    visitIfVisible(\n      primitive,\n      northwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northwestDetails\n    );\n  } else {\n    // Camera in northeast quadrant\n    visitIfVisible(\n      primitive,\n      northeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northeastDetails\n    );\n    visitIfVisible(\n      primitive,\n      northwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      northwestDetails\n    );\n    visitIfVisible(\n      primitive,\n      southeast,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southeastDetails\n    );\n    visitIfVisible(\n      primitive,\n      southwest,\n      tileProvider,\n      frameState,\n      occluders,\n      ancestorMeetsSse,\n      southwestDetails\n    );\n  }\n\n  quadDetails.combine(traversalDetails);\n}\n\nfunction containsNeededPosition(primitive, tile) {\n  const rectangle = tile.rectangle;\n  return (\n    (defined(primitive._cameraPositionCartographic) &&\n      Rectangle.contains(rectangle, primitive._cameraPositionCartographic)) ||\n    (defined(primitive._cameraReferenceFrameOriginCartographic) &&\n      Rectangle.contains(\n        rectangle,\n        primitive._cameraReferenceFrameOriginCartographic\n      ))\n  );\n}\n\nfunction visitIfVisible(\n  primitive,\n  tile,\n  tileProvider,\n  frameState,\n  occluders,\n  ancestorMeetsSse,\n  traversalDetails\n) {\n  if (\n    tileProvider.computeTileVisibility(tile, frameState, occluders) !==\n    Visibility.NONE\n  ) {\n    return visitTile(\n      primitive,\n      frameState,\n      tile,\n      ancestorMeetsSse,\n      traversalDetails\n    );\n  }\n\n  ++primitive._debug.tilesCulled;\n  primitive._tileReplacementQueue.markTileRendered(tile);\n\n  traversalDetails.allAreRenderable = true;\n  traversalDetails.anyWereRenderedLastFrame = false;\n  traversalDetails.notYetRenderableCount = 0;\n\n  if (containsNeededPosition(primitive, tile)) {\n    // Load the tile(s) that contains the camera's position and\n    // the origin of its reference frame with medium priority.\n    // But we only need to load until the terrain is available, no need to load imagery.\n    if (!defined(tile.data) || !defined(tile.data.vertexArray)) {\n      queueTileLoad(\n        primitive,\n        primitive._tileLoadQueueMedium,\n        tile,\n        frameState\n      );\n    }\n\n    const lastFrame = primitive._lastSelectionFrameNumber;\n    const lastFrameSelectionResult =\n      tile._lastSelectionResultFrame === lastFrame\n        ? tile._lastSelectionResult\n        : TileSelectionResult.NONE;\n    if (\n      lastFrameSelectionResult !== TileSelectionResult.CULLED_BUT_NEEDED &&\n      lastFrameSelectionResult !== TileSelectionResult.RENDERED\n    ) {\n      primitive._tileToUpdateHeights.push(tile);\n    }\n\n    tile._lastSelectionResult = TileSelectionResult.CULLED_BUT_NEEDED;\n  } else if (primitive.preloadSiblings || tile.level === 0) {\n    // Load culled level zero tiles with low priority.\n    // For all other levels, only load culled tiles if preloadSiblings is enabled.\n    queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  } else {\n    tile._lastSelectionResult = TileSelectionResult.CULLED;\n  }\n\n  tile._lastSelectionResultFrame = frameState.frameNumber;\n}\n\nfunction screenSpaceError(primitive, frameState, tile) {\n  if (\n    frameState.mode === SceneMode.SCENE2D ||\n    frameState.camera.frustum instanceof OrthographicFrustum ||\n    frameState.camera.frustum instanceof OrthographicOffCenterFrustum\n  ) {\n    return screenSpaceError2D(primitive, frameState, tile);\n  }\n\n  const maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(\n    tile.level\n  );\n\n  const distance = tile._distance;\n  const height = frameState.context.drawingBufferHeight;\n  const sseDenominator = frameState.camera.frustum.sseDenominator;\n\n  let error = (maxGeometricError * height) / (distance * sseDenominator);\n\n  if (frameState.fog.enabled) {\n    error -=\n      CesiumMath.fog(distance, frameState.fog.density) * frameState.fog.sse;\n  }\n\n  error /= frameState.pixelRatio;\n\n  return error;\n}\n\nfunction screenSpaceError2D(primitive, frameState, tile) {\n  const camera = frameState.camera;\n  let frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  const context = frameState.context;\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n\n  const maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(\n    tile.level\n  );\n  const pixelSize =\n    Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) /\n    Math.max(width, height);\n  let error = maxGeometricError / pixelSize;\n\n  if (frameState.fog.enabled && frameState.mode !== SceneMode.SCENE2D) {\n    error -=\n      CesiumMath.fog(tile._distance, frameState.fog.density) *\n      frameState.fog.sse;\n  }\n\n  error /= frameState.pixelRatio;\n\n  return error;\n}\n\nfunction addTileToRenderList(primitive, tile) {\n  primitive._tilesToRender.push(tile);\n}\n\nfunction processTileLoadQueue(primitive, frameState) {\n  const tileLoadQueueHigh = primitive._tileLoadQueueHigh;\n  const tileLoadQueueMedium = primitive._tileLoadQueueMedium;\n  const tileLoadQueueLow = primitive._tileLoadQueueLow;\n\n  if (\n    tileLoadQueueHigh.length === 0 &&\n    tileLoadQueueMedium.length === 0 &&\n    tileLoadQueueLow.length === 0\n  ) {\n    return;\n  }\n\n  // Remove any tiles that were not used this frame beyond the number\n  // we're allowed to keep.\n  primitive._tileReplacementQueue.trimTiles(primitive.tileCacheSize);\n\n  const endTime = getTimestamp() + primitive._loadQueueTimeSlice;\n  const tileProvider = primitive._tileProvider;\n\n  let didSomeLoading = processSinglePriorityLoadQueue(\n    primitive,\n    frameState,\n    tileProvider,\n    endTime,\n    tileLoadQueueHigh,\n    false\n  );\n  didSomeLoading = processSinglePriorityLoadQueue(\n    primitive,\n    frameState,\n    tileProvider,\n    endTime,\n    tileLoadQueueMedium,\n    didSomeLoading\n  );\n  processSinglePriorityLoadQueue(\n    primitive,\n    frameState,\n    tileProvider,\n    endTime,\n    tileLoadQueueLow,\n    didSomeLoading\n  );\n}\n\nfunction sortByLoadPriority(a, b) {\n  return a._loadPriority - b._loadPriority;\n}\n\nfunction processSinglePriorityLoadQueue(\n  primitive,\n  frameState,\n  tileProvider,\n  endTime,\n  loadQueue,\n  didSomeLoading\n) {\n  if (tileProvider.computeTileLoadPriority !== undefined) {\n    loadQueue.sort(sortByLoadPriority);\n  }\n\n  for (\n    let i = 0, len = loadQueue.length;\n    i < len && (getTimestamp() < endTime || !didSomeLoading);\n    ++i\n  ) {\n    const tile = loadQueue[i];\n    primitive._tileReplacementQueue.markTileRendered(tile);\n    tileProvider.loadTile(frameState, tile);\n    didSomeLoading = true;\n  }\n\n  return didSomeLoading;\n}\n\nconst scratchRay = new Ray();\nconst scratchCartographic = new Cartographic();\nconst scratchPosition = new Cartesian3();\nconst scratchArray = [];\n\nfunction updateHeights(primitive, frameState) {\n  if (!primitive.tileProvider.ready) {\n    return;\n  }\n\n  const tryNextFrame = scratchArray;\n  tryNextFrame.length = 0;\n  const tilesToUpdateHeights = primitive._tileToUpdateHeights;\n\n  const startTime = getTimestamp();\n  const timeSlice = primitive._updateHeightsTimeSlice;\n  const endTime = startTime + timeSlice;\n\n  const mode = frameState.mode;\n  const projection = frameState.mapProjection;\n  const ellipsoid = primitive.tileProvider.tilingScheme.ellipsoid;\n  let i;\n\n  while (tilesToUpdateHeights.length > 0) {\n    const tile = tilesToUpdateHeights[0];\n    if (!defined(tile.data) || !defined(tile.data.mesh)) {\n      // Tile isn't loaded enough yet, so try again next frame if this tile is still\n      // being rendered.\n      const selectionResult =\n        tile._lastSelectionResultFrame === primitive._lastSelectionFrameNumber\n          ? tile._lastSelectionResult\n          : TileSelectionResult.NONE;\n      if (\n        selectionResult === TileSelectionResult.RENDERED ||\n        selectionResult === TileSelectionResult.CULLED_BUT_NEEDED\n      ) {\n        tryNextFrame.push(tile);\n      }\n      tilesToUpdateHeights.shift();\n      primitive._lastTileIndex = 0;\n      continue;\n    }\n    const customData = tile.customData;\n    const customDataLength = customData.length;\n\n    let timeSliceMax = false;\n    for (i = primitive._lastTileIndex; i < customDataLength; ++i) {\n      const data = customData[i];\n\n      // No need to run this code when the tile is upsampled, because the height will be the same as its parent.\n      const terrainData = tile.data.terrainData;\n      const upsampledGeometryFromParent =\n        defined(terrainData) && terrainData.wasCreatedByUpsampling();\n\n      if (tile.level > data.level && !upsampledGeometryFromParent) {\n        if (!defined(data.positionOnEllipsoidSurface)) {\n          // cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n          data.positionOnEllipsoidSurface = Cartesian3.fromRadians(\n            data.positionCartographic.longitude,\n            data.positionCartographic.latitude,\n            0.0,\n            ellipsoid\n          );\n        }\n\n        if (mode === SceneMode.SCENE3D) {\n          const surfaceNormal = ellipsoid.geodeticSurfaceNormal(\n            data.positionOnEllipsoidSurface,\n            scratchRay.direction\n          );\n\n          // compute origin point\n\n          // Try to find the intersection point between the surface normal and z-axis.\n          // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n          const rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(\n            data.positionOnEllipsoidSurface,\n            11500.0,\n            scratchRay.origin\n          );\n\n          // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n          if (!defined(rayOrigin)) {\n            // intersection point is outside the ellipsoid, try other value\n            // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n            let minimumHeight = 0.0;\n            if (defined(tile.data.tileBoundingRegion)) {\n              minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n            }\n            const magnitude = Math.min(minimumHeight, -11500.0);\n\n            // multiply by the *positive* value of the magnitude\n            const vectorToMinimumPoint = Cartesian3.multiplyByScalar(\n              surfaceNormal,\n              Math.abs(magnitude) + 1,\n              scratchPosition\n            );\n            Cartesian3.subtract(\n              data.positionOnEllipsoidSurface,\n              vectorToMinimumPoint,\n              scratchRay.origin\n            );\n          }\n        } else {\n          Cartographic.clone(data.positionCartographic, scratchCartographic);\n\n          // minimum height for the terrain set, need to get this information from the terrain provider\n          scratchCartographic.height = -11500.0;\n          projection.project(scratchCartographic, scratchPosition);\n          Cartesian3.fromElements(\n            scratchPosition.z,\n            scratchPosition.x,\n            scratchPosition.y,\n            scratchPosition\n          );\n          Cartesian3.clone(scratchPosition, scratchRay.origin);\n          Cartesian3.clone(Cartesian3.UNIT_X, scratchRay.direction);\n        }\n\n        const position = tile.data.pick(\n          scratchRay,\n          mode,\n          projection,\n          false,\n          scratchPosition\n        );\n        if (defined(position)) {\n          if (defined(data.callback)) {\n            data.callback(position);\n          }\n          data.level = tile.level;\n        }\n      }\n\n      if (getTimestamp() >= endTime) {\n        timeSliceMax = true;\n        break;\n      }\n    }\n\n    if (timeSliceMax) {\n      primitive._lastTileIndex = i;\n      break;\n    } else {\n      primitive._lastTileIndex = 0;\n      tilesToUpdateHeights.shift();\n    }\n  }\n  for (i = 0; i < tryNextFrame.length; i++) {\n    tilesToUpdateHeights.push(tryNextFrame[i]);\n  }\n}\n\nfunction createRenderCommandsForSelectedTiles(primitive, frameState) {\n  const tileProvider = primitive._tileProvider;\n  const tilesToRender = primitive._tilesToRender;\n\n  for (let i = 0, len = tilesToRender.length; i < len; ++i) {\n    const tile = tilesToRender[i];\n    tileProvider.showTileThisFrame(tile, frameState);\n  }\n}\nexport default QuadtreePrimitive;\n","import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * A single tile in a {@link QuadtreePrimitive}.\n *\n * @alias QuadtreeTile\n * @constructor\n * @private\n *\n * @param {Number} options.level The level of the tile in the quadtree.\n * @param {Number} options.x The X coordinate of the tile in the quadtree.  0 is the westernmost tile.\n * @param {Number} options.y The Y coordinate of the tile in the quadtree.  0 is the northernmost tile.\n * @param {TilingScheme} options.tilingScheme The tiling scheme in which this tile exists.\n * @param {QuadtreeTile} [options.parent] This tile's parent, or undefined if this is a root tile.\n */\nfunction QuadtreeTile(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.x)) {\n    throw new DeveloperError(\"options.x is required.\");\n  } else if (!defined(options.y)) {\n    throw new DeveloperError(\"options.y is required.\");\n  } else if (options.x < 0 || options.y < 0) {\n    throw new DeveloperError(\n      \"options.x and options.y must be greater than or equal to zero.\"\n    );\n  }\n  if (!defined(options.level)) {\n    throw new DeveloperError(\n      \"options.level is required and must be greater than or equal to zero.\"\n    );\n  }\n  if (!defined(options.tilingScheme)) {\n    throw new DeveloperError(\"options.tilingScheme is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._tilingScheme = options.tilingScheme;\n  this._x = options.x;\n  this._y = options.y;\n  this._level = options.level;\n  this._parent = options.parent;\n  this._rectangle = this._tilingScheme.tileXYToRectangle(\n    this._x,\n    this._y,\n    this._level\n  );\n\n  this._southwestChild = undefined;\n  this._southeastChild = undefined;\n  this._northwestChild = undefined;\n  this._northeastChild = undefined;\n\n  // TileReplacementQueue gets/sets these private properties.\n  this.replacementPrevious = undefined;\n  this.replacementNext = undefined;\n\n  // The distance from the camera to this tile, updated when the tile is selected\n  // for rendering.  We can get rid of this if we have a better way to sort by\n  // distance - for example, by using the natural ordering of a quadtree.\n  // QuadtreePrimitive gets/sets this private property.\n  this._distance = 0.0;\n  this._loadPriority = 0.0;\n\n  this._customData = [];\n  this._frameUpdated = undefined;\n  this._lastSelectionResult = TileSelectionResult.NONE;\n  this._lastSelectionResultFrame = undefined;\n  this._loadedCallbacks = {};\n\n  /**\n   * Gets or sets the current state of the tile in the tile load pipeline.\n   * @type {QuadtreeTileLoadState}\n   * @default {@link QuadtreeTileLoadState.START}\n   */\n  this.state = QuadtreeTileLoadState.START;\n\n  /**\n   * Gets or sets a value indicating whether or not the tile is currently renderable.\n   * @type {Boolean}\n   * @default false\n   */\n  this.renderable = false;\n\n  /**\n   * Gets or set a value indicating whether or not the tile was entirely upsampled from its\n   * parent tile.  If all four children of a parent tile were upsampled from the parent,\n   * we will render the parent instead of the children even if the LOD indicates that\n   * the children would be preferable.\n   * @type {Boolean}\n   * @default false\n   */\n  this.upsampledFromParent = false;\n\n  /**\n   * Gets or sets the additional data associated with this tile.  The exact content is specific to the\n   * {@link QuadtreeTileProvider}.\n   * @type {Object}\n   * @default undefined\n   */\n  this.data = undefined;\n}\n\n/**\n * Creates a rectangular set of tiles for level of detail zero, the coarsest, least detailed level.\n *\n * @memberof QuadtreeTile\n *\n * @param {TilingScheme} tilingScheme The tiling scheme for which the tiles are to be created.\n * @returns {QuadtreeTile[]} An array containing the tiles at level of detail zero, starting with the\n * tile in the northwest corner and followed by the tile (if any) to its east.\n */\nQuadtreeTile.createLevelZeroTiles = function (tilingScheme) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numberOfLevelZeroTilesX = tilingScheme.getNumberOfXTilesAtLevel(0);\n  const numberOfLevelZeroTilesY = tilingScheme.getNumberOfYTilesAtLevel(0);\n\n  const result = new Array(numberOfLevelZeroTilesX * numberOfLevelZeroTilesY);\n\n  let index = 0;\n  for (let y = 0; y < numberOfLevelZeroTilesY; ++y) {\n    for (let x = 0; x < numberOfLevelZeroTilesX; ++x) {\n      result[index++] = new QuadtreeTile({\n        tilingScheme: tilingScheme,\n        x: x,\n        y: y,\n        level: 0,\n      });\n    }\n  }\n\n  return result;\n};\n\nQuadtreeTile.prototype._updateCustomData = function (\n  frameNumber,\n  added,\n  removed\n) {\n  let customData = this.customData;\n\n  let i;\n  let data;\n  let rectangle;\n\n  if (defined(added) && defined(removed)) {\n    customData = customData.filter(function (value) {\n      return removed.indexOf(value) === -1;\n    });\n    this._customData = customData;\n\n    rectangle = this._rectangle;\n    for (i = 0; i < added.length; ++i) {\n      data = added[i];\n      if (Rectangle.contains(rectangle, data.positionCartographic)) {\n        customData.push(data);\n      }\n    }\n\n    this._frameUpdated = frameNumber;\n  } else {\n    // interior or leaf tile, update from parent\n    const parent = this._parent;\n    if (defined(parent) && this._frameUpdated !== parent._frameUpdated) {\n      customData.length = 0;\n\n      rectangle = this._rectangle;\n      const parentCustomData = parent.customData;\n      for (i = 0; i < parentCustomData.length; ++i) {\n        data = parentCustomData[i];\n        if (Rectangle.contains(rectangle, data.positionCartographic)) {\n          customData.push(data);\n        }\n      }\n\n      this._frameUpdated = parent._frameUpdated;\n    }\n  }\n};\n\nObject.defineProperties(QuadtreeTile.prototype, {\n  /**\n   * Gets the tiling scheme used to tile the surface.\n   * @memberof QuadtreeTile.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the tile X coordinate.\n   * @memberof QuadtreeTile.prototype\n   * @type {Number}\n   */\n  x: {\n    get: function () {\n      return this._x;\n    },\n  },\n\n  /**\n   * Gets the tile Y coordinate.\n   * @memberof QuadtreeTile.prototype\n   * @type {Number}\n   */\n  y: {\n    get: function () {\n      return this._y;\n    },\n  },\n\n  /**\n   * Gets the level-of-detail, where zero is the coarsest, least-detailed.\n   * @memberof QuadtreeTile.prototype\n   * @type {Number}\n   */\n  level: {\n    get: function () {\n      return this._level;\n    },\n  },\n\n  /**\n   * Gets the parent tile of this tile.\n   * @memberof QuadtreeTile.prototype\n   * @type {QuadtreeTile}\n   */\n  parent: {\n    get: function () {\n      return this._parent;\n    },\n  },\n\n  /**\n   * Gets the cartographic rectangle of the tile, with north, south, east and\n   * west properties in radians.\n   * @memberof QuadtreeTile.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * An array of tiles that is at the next level of the tile tree.\n   * @memberof QuadtreeTile.prototype\n   * @type {QuadtreeTile[]}\n   */\n  children: {\n    get: function () {\n      return [\n        this.northwestChild,\n        this.northeastChild,\n        this.southwestChild,\n        this.southeastChild,\n      ];\n    },\n  },\n\n  /**\n   * Gets the southwest child tile.\n   * @memberof QuadtreeTile.prototype\n   * @type {QuadtreeTile}\n   */\n  southwestChild: {\n    get: function () {\n      if (!defined(this._southwestChild)) {\n        this._southwestChild = new QuadtreeTile({\n          tilingScheme: this.tilingScheme,\n          x: this.x * 2,\n          y: this.y * 2 + 1,\n          level: this.level + 1,\n          parent: this,\n        });\n      }\n      return this._southwestChild;\n    },\n  },\n\n  /**\n   * Gets the southeast child tile.\n   * @memberof QuadtreeTile.prototype\n   * @type {QuadtreeTile}\n   */\n  southeastChild: {\n    get: function () {\n      if (!defined(this._southeastChild)) {\n        this._southeastChild = new QuadtreeTile({\n          tilingScheme: this.tilingScheme,\n          x: this.x * 2 + 1,\n          y: this.y * 2 + 1,\n          level: this.level + 1,\n          parent: this,\n        });\n      }\n      return this._southeastChild;\n    },\n  },\n\n  /**\n   * Gets the northwest child tile.\n   * @memberof QuadtreeTile.prototype\n   * @type {QuadtreeTile}\n   */\n  northwestChild: {\n    get: function () {\n      if (!defined(this._northwestChild)) {\n        this._northwestChild = new QuadtreeTile({\n          tilingScheme: this.tilingScheme,\n          x: this.x * 2,\n          y: this.y * 2,\n          level: this.level + 1,\n          parent: this,\n        });\n      }\n      return this._northwestChild;\n    },\n  },\n\n  /**\n   * Gets the northeast child tile.\n   * @memberof QuadtreeTile.prototype\n   * @type {QuadtreeTile}\n   */\n  northeastChild: {\n    get: function () {\n      if (!defined(this._northeastChild)) {\n        this._northeastChild = new QuadtreeTile({\n          tilingScheme: this.tilingScheme,\n          x: this.x * 2 + 1,\n          y: this.y * 2,\n          level: this.level + 1,\n          parent: this,\n        });\n      }\n      return this._northeastChild;\n    },\n  },\n\n  /**\n   * An array of objects associated with this tile.\n   * @memberof QuadtreeTile.prototype\n   * @type {Array}\n   */\n  customData: {\n    get: function () {\n      return this._customData;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not this tile needs further loading.\n   * This property will return true if the {@link QuadtreeTile#state} is\n   * <code>START</code> or <code>LOADING</code>.\n   * @memberof QuadtreeTile.prototype\n   * @type {Boolean}\n   */\n  needsLoading: {\n    get: function () {\n      return this.state < QuadtreeTileLoadState.DONE;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not this tile is eligible to be unloaded.\n   * Typically, a tile is ineligible to be unloaded while an asynchronous operation,\n   * such as a request for data, is in progress on it.  A tile will never be\n   * unloaded while it is needed for rendering, regardless of the value of this\n   * property.  If {@link QuadtreeTile#data} is defined and has an\n   * <code>eligibleForUnloading</code> property, the value of that property is returned.\n   * Otherwise, this property returns true.\n   * @memberof QuadtreeTile.prototype\n   * @type {Boolean}\n   */\n  eligibleForUnloading: {\n    get: function () {\n      let result = true;\n\n      if (defined(this.data)) {\n        result = this.data.eligibleForUnloading;\n        if (!defined(result)) {\n          result = true;\n        }\n      }\n\n      return result;\n    },\n  },\n});\n\nQuadtreeTile.prototype.findLevelZeroTile = function (levelZeroTiles, x, y) {\n  const xTiles = this.tilingScheme.getNumberOfXTilesAtLevel(0);\n  if (x < 0) {\n    x += xTiles;\n  } else if (x >= xTiles) {\n    x -= xTiles;\n  }\n\n  if (y < 0 || y >= this.tilingScheme.getNumberOfYTilesAtLevel(0)) {\n    return undefined;\n  }\n\n  return levelZeroTiles.filter(function (tile) {\n    return tile.x === x && tile.y === y;\n  })[0];\n};\n\nQuadtreeTile.prototype.findTileToWest = function (levelZeroTiles) {\n  const parent = this.parent;\n  if (parent === undefined) {\n    return this.findLevelZeroTile(levelZeroTiles, this.x - 1, this.y);\n  }\n\n  if (parent.southeastChild === this) {\n    return parent.southwestChild;\n  } else if (parent.northeastChild === this) {\n    return parent.northwestChild;\n  }\n\n  const westOfParent = parent.findTileToWest(levelZeroTiles);\n  if (westOfParent === undefined) {\n    return undefined;\n  } else if (parent.southwestChild === this) {\n    return westOfParent.southeastChild;\n  }\n  return westOfParent.northeastChild;\n};\n\nQuadtreeTile.prototype.findTileToEast = function (levelZeroTiles) {\n  const parent = this.parent;\n  if (parent === undefined) {\n    return this.findLevelZeroTile(levelZeroTiles, this.x + 1, this.y);\n  }\n\n  if (parent.southwestChild === this) {\n    return parent.southeastChild;\n  } else if (parent.northwestChild === this) {\n    return parent.northeastChild;\n  }\n\n  const eastOfParent = parent.findTileToEast(levelZeroTiles);\n  if (eastOfParent === undefined) {\n    return undefined;\n  } else if (parent.southeastChild === this) {\n    return eastOfParent.southwestChild;\n  }\n  return eastOfParent.northwestChild;\n};\n\nQuadtreeTile.prototype.findTileToSouth = function (levelZeroTiles) {\n  const parent = this.parent;\n  if (parent === undefined) {\n    return this.findLevelZeroTile(levelZeroTiles, this.x, this.y + 1);\n  }\n\n  if (parent.northwestChild === this) {\n    return parent.southwestChild;\n  } else if (parent.northeastChild === this) {\n    return parent.southeastChild;\n  }\n\n  const southOfParent = parent.findTileToSouth(levelZeroTiles);\n  if (southOfParent === undefined) {\n    return undefined;\n  } else if (parent.southwestChild === this) {\n    return southOfParent.northwestChild;\n  }\n  return southOfParent.northeastChild;\n};\n\nQuadtreeTile.prototype.findTileToNorth = function (levelZeroTiles) {\n  const parent = this.parent;\n  if (parent === undefined) {\n    return this.findLevelZeroTile(levelZeroTiles, this.x, this.y - 1);\n  }\n\n  if (parent.southwestChild === this) {\n    return parent.northwestChild;\n  } else if (parent.southeastChild === this) {\n    return parent.northeastChild;\n  }\n\n  const northOfParent = parent.findTileToNorth(levelZeroTiles);\n  if (northOfParent === undefined) {\n    return undefined;\n  } else if (parent.northwestChild === this) {\n    return northOfParent.southwestChild;\n  }\n  return northOfParent.southeastChild;\n};\n\n/**\n * Frees the resources associated with this tile and returns it to the <code>START</code>\n * {@link QuadtreeTileLoadState}.  If the {@link QuadtreeTile#data} property is defined and it\n * has a <code>freeResources</code> method, the method will be invoked.\n *\n * @memberof QuadtreeTile\n */\nQuadtreeTile.prototype.freeResources = function () {\n  this.state = QuadtreeTileLoadState.START;\n  this.renderable = false;\n  this.upsampledFromParent = false;\n\n  if (defined(this.data) && defined(this.data.freeResources)) {\n    this.data.freeResources();\n  }\n\n  freeTile(this._southwestChild);\n  this._southwestChild = undefined;\n  freeTile(this._southeastChild);\n  this._southeastChild = undefined;\n  freeTile(this._northwestChild);\n  this._northwestChild = undefined;\n  freeTile(this._northeastChild);\n  this._northeastChild = undefined;\n};\n\nfunction freeTile(tile) {\n  if (defined(tile)) {\n    tile.freeResources();\n  }\n}\nexport default QuadtreeTile;\n","/**\n * The state of a {@link QuadtreeTile} in the tile load pipeline.\n * @enum {Number}\n * @private\n */\nconst QuadtreeTileLoadState = {\n  /**\n   * The tile is new and loading has not yet begun.\n   * @type QuadtreeTileLoadState\n   * @constant\n   * @default 0\n   */\n  START: 0,\n\n  /**\n   * Loading is in progress.\n   * @type QuadtreeTileLoadState\n   * @constant\n   * @default 1\n   */\n  LOADING: 1,\n\n  /**\n   * Loading is complete.\n   * @type QuadtreeTileLoadState\n   * @constant\n   * @default 2\n   */\n  DONE: 2,\n\n  /**\n   * The tile has failed to load.\n   * @type QuadtreeTileLoadState\n   * @constant\n   * @default 3\n   */\n  FAILED: 3,\n};\nexport default Object.freeze(QuadtreeTileLoadState);\n","import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * Provides general quadtree tiles to be displayed on or near the surface of an ellipsoid.  It is intended to be\n * used with the {@link QuadtreePrimitive}.  This type describes an interface and is not intended to be\n * instantiated directly.\n *\n * @alias QuadtreeTileProvider\n * @constructor\n * @private\n */\nfunction QuadtreeTileProvider() {\n  DeveloperError.throwInstantiationError();\n}\n\n/**\n * Computes the default geometric error for level zero of the quadtree.\n *\n * @memberof QuadtreeTileProvider\n *\n * @param {TilingScheme} tilingScheme The tiling scheme for which to compute the geometric error.\n * @returns {Number} The maximum geometric error at level zero, in meters.\n */\nQuadtreeTileProvider.computeDefaultLevelZeroMaximumGeometricError = function (\n  tilingScheme\n) {\n  return (\n    (tilingScheme.ellipsoid.maximumRadius * 2 * Math.PI * 0.25) /\n    (65 * tilingScheme.getNumberOfXTilesAtLevel(0))\n  );\n};\n\nObject.defineProperties(QuadtreeTileProvider.prototype, {\n  /**\n   * Gets or sets the {@link QuadtreePrimitive} for which this provider is\n   * providing tiles.\n   * @memberof QuadtreeTileProvider.prototype\n   * @type {QuadtreePrimitive}\n   */\n  quadtree: {\n    get: DeveloperError.throwInstantiationError,\n    set: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof QuadtreeTileProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This property should\n   * not be accessed before {@link QuadtreeTileProvider#ready} returns true.\n   * @memberof QuadtreeTileProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets an event that is raised when the geometry provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof QuadtreeTileProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\n/**\n * Called at the beginning of the update cycle, regardless of id a new frame is being rendered, before {@link QuadtreeTileProvider#beginUpdate}\n * @memberof QuadtreeTileProvider\n * @function\n *\n * @param {Context} context The rendering context.\n * @param {FrameState} frameState The frame state.\n */\nQuadtreeTileProvider.prototype.update = DeveloperError.throwInstantiationError;\n\n/**\n * Called at the beginning of the update cycle for each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * or any other functions.\n * @memberof QuadtreeTileProvider\n * @function\n *\n * @param {Context} context The rendering context.\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} commandList An array of rendering commands.  This method may push\n *        commands into this array.\n */\nQuadtreeTileProvider.prototype.beginUpdate =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}\n * and any other functions.\n * @memberof QuadtreeTileProvider\n * @function\n *\n * @param {Context} context The rendering context.\n * @param {FrameState} frameState The frame state.\n * @param {DrawCommand[]} commandList An array of rendering commands.  This method may push\n *        commands into this array.\n */\nQuadtreeTileProvider.prototype.endUpdate =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level, in meters.  This function should not be\n * called before {@link QuadtreeTileProvider#ready} returns true.\n *\n * @see QuadtreeTileProvider#computeDefaultLevelZeroMaximumGeometricError\n *\n * @memberof QuadtreeTileProvider\n * @function\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error in meters.\n */\nQuadtreeTileProvider.prototype.getLevelMaximumGeometricError =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Loads, or continues loading, a given tile.  This function will continue to be called\n * until {@link QuadtreeTile#state} is no longer {@link QuadtreeTileLoadState#LOADING}.  This function should\n * not be called before {@link QuadtreeTileProvider#ready} returns true.\n *\n * @memberof QuadtreeTileProvider\n * @function\n *\n * @param {Context} context The rendering context.\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to load.\n *\n * @exception {DeveloperError} <code>loadTile</code> must not be called before the tile provider is ready.\n */\nQuadtreeTileProvider.prototype.loadTile =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Determines the visibility of a given tile.  The tile may be fully visible, partially visible, or not\n * visible at all.  Tiles that are renderable and are at least partially visible will be shown by a call\n * to {@link QuadtreeTileProvider#showTileThisFrame}.\n *\n * @memberof QuadtreeTileProvider\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information about the current frame.\n * @param {QuadtreeOccluders} occluders The objects that may occlude this tile.\n *\n * @returns {Visibility} The visibility of the tile.\n */\nQuadtreeTileProvider.prototype.computeTileVisibility =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Shows a specified tile in this frame.  The provider can cause the tile to be shown by adding\n * render commands to the commandList, or use any other method as appropriate.  The tile is not\n * expected to be visible next frame as well, unless this method is call next frame, too.\n *\n * @memberof QuadtreeTileProvider\n * @function\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {Context} context The rendering context.\n * @param {FrameState} frameState The state information of the current rendering frame.\n * @param {DrawCommand[]} commandList The list of rendering commands.  This method may add additional commands to this list.\n */\nQuadtreeTileProvider.prototype.showTileThisFrame =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.\n *\n * @memberof QuadtreeTileProvider\n * @function\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n *\n * @returns {Number} The distance from the camera to the closest point on the tile, in meters.\n */\nQuadtreeTileProvider.prototype.computeDistanceToTile =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @memberof QuadtreeTileProvider\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see QuadtreeTileProvider#destroy\n */\nQuadtreeTileProvider.prototype.isDestroyed =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @memberof QuadtreeTileProvider\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * provider = provider && provider();\n *\n * @see QuadtreeTileProvider#isDestroyed\n */\nQuadtreeTileProvider.prototype.destroy = DeveloperError.throwInstantiationError;\nexport default QuadtreeTileProvider;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport BufferLoader from \"./BufferLoader.js\";\nimport GltfBufferViewLoader from \"./GltfBufferViewLoader.js\";\nimport GltfDracoLoader from \"./GltfDracoLoader.js\";\nimport GltfImageLoader from \"./GltfImageLoader.js\";\nimport GltfIndexBufferLoader from \"./GltfIndexBufferLoader.js\";\nimport GltfJsonLoader from \"./GltfJsonLoader.js\";\nimport GltfTextureLoader from \"./GltfTextureLoader.js\";\nimport GltfVertexBufferLoader from \"./GltfVertexBufferLoader.js\";\nimport MetadataSchemaLoader from \"./MetadataSchemaLoader.js\";\nimport ResourceCacheKey from \"./ResourceCacheKey.js\";\n\n/**\n * Cache for resources shared across 3D Tiles and glTF.\n *\n * @namespace ResourceCache\n *\n * @private\n */\nfunction ResourceCache() {}\n\nResourceCache.cacheEntries = {};\n\n/**\n * A reference-counted cache entry.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @alias CacheEntry\n * @constructor\n *\n * @private\n */\nfunction CacheEntry(resourceLoader) {\n  this.referenceCount = 1;\n  this.resourceLoader = resourceLoader;\n}\n\n/**\n * Gets a resource from the cache. If the resource exists its reference count is\n * incremented. Otherwise, if no resource loader exists, undefined is returned.\n *\n * @param {String} cacheKey The cache key of the resource.\n *\n * @returns {ResourceLoader|undefined} The resource.\n * @private\n */\nResourceCache.get = function (cacheKey) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"cacheKey\", cacheKey);\n  //>>includeEnd('debug');\n\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n  if (defined(cacheEntry)) {\n    ++cacheEntry.referenceCount;\n    return cacheEntry.resourceLoader;\n  }\n  return undefined;\n};\n\n/**\n * Loads a resource and adds it to the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {ResourceLoader} options.resourceLoader The resource.\n *\n * @exception {DeveloperError} Resource with this cacheKey is already in the cach\n * @private\n */\nResourceCache.load = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceLoader = options.resourceLoader;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.resourceLoader.cacheKey\", cacheKey);\n\n  if (defined(ResourceCache.cacheEntries[cacheKey])) {\n    throw new DeveloperError(\n      `Resource with this cacheKey is already in the cache: ${cacheKey}`\n    );\n  }\n  //>>includeEnd('debug');\n\n  ResourceCache.cacheEntries[cacheKey] = new CacheEntry(resourceLoader);\n\n  resourceLoader.load();\n};\n\n/**\n * Unloads a resource from the cache. When the reference count hits zero the\n * resource is destroyed.\n *\n * @param {ResourceLoader} resourceLoader The resource.\n *\n * @exception {DeveloperError} Resource is not in the cache.\n * @exception {DeveloperError} Cannot unload resource that has no references.\n * @private\n */\nResourceCache.unload = function (resourceLoader) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resourceLoader\", resourceLoader);\n  //>>includeEnd('debug');\n\n  const cacheKey = resourceLoader.cacheKey;\n  const cacheEntry = ResourceCache.cacheEntries[cacheKey];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cacheEntry)) {\n    throw new DeveloperError(`Resource is not in the cache: ${cacheKey}`);\n  }\n  //>>includeEnd('debug');\n\n  --cacheEntry.referenceCount;\n\n  if (cacheEntry.referenceCount === 0) {\n    resourceLoader.destroy();\n    delete ResourceCache.cacheEntries[cacheKey];\n  }\n};\n\n/**\n * Loads a schema from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} [options.schema] An object that explicitly defines a schema JSON. Mutually exclusive with options.resource.\n * @param {Resource} [options.resource] The {@link Resource} pointing to the schema JSON. Mutually exclusive with options.schema.\n *\n * @returns {MetadataSchemaLoader} The schema resource.\n *\n * @exception {DeveloperError} One of options.schema and options.resource must be defined.\n * @private\n */\nResourceCache.loadSchema = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const schema = options.schema;\n  const resource = options.resource;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(schema) === defined(resource)) {\n    throw new DeveloperError(\n      \"One of options.schema and options.resource must be defined.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getSchemaCacheKey({\n    schema: schema,\n    resource: resource,\n  });\n\n  let schemaLoader = ResourceCache.get(cacheKey);\n  if (defined(schemaLoader)) {\n    return schemaLoader;\n  }\n\n  schemaLoader = new MetadataSchemaLoader({\n    schema: schema,\n    resource: resource,\n    cacheKey: cacheKey,\n  });\n\n  ResourceCache.load({\n    resourceLoader: schemaLoader,\n  });\n\n  return schemaLoader;\n};\n\n/**\n * Load an embedded buffer from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.parentResource The {@link Resource} containing the embedded buffer.\n * @param {Number} options.bufferId A unique identifier of the embedded buffer within the parent resource.\n * @param {Uint8Array} [options.typedArray] The typed array containing the embedded buffer contents.\n *\n * @returns {BufferLoader} The buffer loader.\n * @private\n */\nResourceCache.loadEmbeddedBuffer = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const parentResource = options.parentResource;\n  const bufferId = options.bufferId;\n  const typedArray = options.typedArray;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.parentResource\", parentResource);\n  Check.typeOf.number(\"options.bufferId\", bufferId);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getEmbeddedBufferCacheKey({\n    parentResource: parentResource,\n    bufferId: bufferId,\n  });\n\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.typedArray\", typedArray);\n  //>>includeEnd('debug');\n\n  bufferLoader = new BufferLoader({\n    typedArray: typedArray,\n    cacheKey: cacheKey,\n  });\n\n  ResourceCache.load({\n    resourceLoader: bufferLoader,\n  });\n\n  return bufferLoader;\n};\n\n/**\n * Loads an external buffer from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.resource The {@link Resource} pointing to the external buffer.\n *\n * @returns {BufferLoader} The buffer loader.\n * @private\n */\nResourceCache.loadExternalBuffer = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resource = options.resource;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.resource\", resource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getExternalBufferCacheKey({\n    resource: resource,\n  });\n\n  let bufferLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferLoader)) {\n    return bufferLoader;\n  }\n\n  bufferLoader = new BufferLoader({\n    resource: resource,\n    cacheKey: cacheKey,\n  });\n\n  ResourceCache.load({\n    resourceLoader: bufferLoader,\n  });\n\n  return bufferLoader;\n};\n\n/**\n * Loads a glTF JSON from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Uint8Array} [options.typedArray] The typed array containing the glTF contents.\n * @param {Object} [options.gltfJson] The parsed glTF JSON contents.\n *\n * @returns {GltfJsonLoader} The glTF JSON.\n * @private\n */\nResourceCache.loadGltfJson = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const typedArray = options.typedArray;\n  const gltfJson = options.gltfJson;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getGltfCacheKey({\n    gltfResource: gltfResource,\n  });\n\n  let gltfJsonLoader = ResourceCache.get(cacheKey);\n  if (defined(gltfJsonLoader)) {\n    return gltfJsonLoader;\n  }\n\n  gltfJsonLoader = new GltfJsonLoader({\n    resourceCache: ResourceCache,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    typedArray: typedArray,\n    gltfJson: gltfJson,\n    cacheKey: cacheKey,\n  });\n\n  ResourceCache.load({\n    resourceLoader: gltfJsonLoader,\n  });\n\n  return gltfJsonLoader;\n};\n\n/**\n * Loads a glTF buffer view from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.bufferViewId The bufferView ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfBufferViewLoader} The buffer view loader.\n * @private\n */\nResourceCache.loadBufferView = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const bufferViewId = options.bufferViewId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.bufferViewId\", bufferViewId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getBufferViewCacheKey({\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let bufferViewLoader = ResourceCache.get(cacheKey);\n  if (defined(bufferViewLoader)) {\n    return bufferViewLoader;\n  }\n\n  bufferViewLoader = new GltfBufferViewLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  ResourceCache.load({\n    resourceLoader: bufferViewLoader,\n  });\n\n  return bufferViewLoader;\n};\n\n/**\n * Loads Draco data from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Object} options.draco The Draco extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfDracoLoader} The Draco loader.\n * @private\n */\nResourceCache.loadDraco = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const draco = options.draco;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.draco\", draco);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getDracoCacheKey({\n    gltf: gltf,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let dracoLoader = ResourceCache.get(cacheKey);\n  if (defined(dracoLoader)) {\n    return dracoLoader;\n  }\n\n  dracoLoader = new GltfDracoLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    draco: draco,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  ResourceCache.load({\n    resourceLoader: dracoLoader,\n  });\n\n  return dracoLoader;\n};\n\n/**\n * Loads a glTF vertex buffer from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {Object} [options.draco] The Draco extension object.\n * @param {String} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {Number} [options.accessorId] The accessor ID.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {Boolean} [options.dequantize=false] Determines whether or not the vertex buffer will be dequantized on the CPU.\n * @param {Boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {Boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @returns {GltfVertexBufferLoader} The vertex buffer loader.\n * @private\n */\nResourceCache.loadVertexBuffer = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const bufferViewId = options.bufferViewId;\n  const draco = options.draco;\n  const attributeSemantic = options.attributeSemantic;\n  const accessorId = options.accessorId;\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const dequantize = defaultValue(options.dequantize, false);\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\"\n    );\n  }\n\n  const hasBufferViewId = defined(bufferViewId);\n  const hasDraco = defined(draco);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n\n  if (hasBufferViewId === hasDraco) {\n    throw new DeveloperError(\n      \"One of options.bufferViewId and options.draco must be defined.\"\n    );\n  }\n\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.attributeSemantic must also be defined.\"\n    );\n  }\n\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.haAccessorId must also be defined.\"\n    );\n  }\n\n  if (hasDraco) {\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getVertexBufferCacheKey({\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    attributeSemantic: attributeSemantic,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  let vertexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(vertexBufferLoader)) {\n    return vertexBufferLoader;\n  }\n\n  vertexBufferLoader = new GltfVertexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    attributeSemantic: attributeSemantic,\n    accessorId: accessorId,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  ResourceCache.load({\n    resourceLoader: vertexBufferLoader,\n  });\n\n  return vertexBufferLoader;\n};\n\n/**\n * Loads a glTF index buffer from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Object} [options.draco] The Draco extension object.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {Boolean} [options.loadBuffer=false] Load index buffer as a GPU index buffer.\n * @param {Boolean} [options.loadTypedArray=false] Load index buffer as a typed array.\n * @returns {GltfIndexBufferLoader} The index buffer loader.\n * @private\n */\nResourceCache.loadIndexBuffer = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const accessorId = options.accessorId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const draco = options.draco;\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getIndexBufferCacheKey({\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    draco: draco,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  let indexBufferLoader = ResourceCache.get(cacheKey);\n  if (defined(indexBufferLoader)) {\n    return indexBufferLoader;\n  }\n\n  indexBufferLoader = new GltfIndexBufferLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    draco: draco,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  ResourceCache.load({\n    resourceLoader: indexBufferLoader,\n  });\n\n  return indexBufferLoader;\n};\n\n/**\n * Loads a glTF image from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.imageId The image ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {GltfImageLoader} The image loader.\n * @private\n */\nResourceCache.loadImage = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const imageId = options.imageId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.imageId\", imageId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getImageCacheKey({\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n  });\n\n  let imageLoader = ResourceCache.get(cacheKey);\n  if (defined(imageLoader)) {\n    return imageLoader;\n  }\n\n  imageLoader = new GltfImageLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    imageId: imageId,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    cacheKey: cacheKey,\n  });\n\n  ResourceCache.load({\n    resourceLoader: imageLoader,\n  });\n\n  return imageLoader;\n};\n\n/**\n * Loads a glTF texture from the cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Object} options.textureInfo The texture info object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @returns {GltfTextureLoader} The texture loader.\n * @private\n */\nResourceCache.loadTexture = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const textureInfo = options.textureInfo;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const supportedImageFormats = options.supportedImageFormats;\n  const asynchronous = defaultValue(options.asynchronous, true);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const cacheKey = ResourceCacheKey.getTextureCacheKey({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n  });\n\n  let textureLoader = ResourceCache.get(cacheKey);\n  if (defined(textureLoader)) {\n    return textureLoader;\n  }\n\n  textureLoader = new GltfTextureLoader({\n    resourceCache: ResourceCache,\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: gltfResource,\n    baseResource: baseResource,\n    supportedImageFormats: supportedImageFormats,\n    cacheKey: cacheKey,\n    asynchronous: asynchronous,\n  });\n\n  ResourceCache.load({\n    resourceLoader: textureLoader,\n  });\n\n  return textureLoader;\n};\n\n/**\n * Unload everything from the cache. This is used for unit testing.\n *\n * @private\n */\nResourceCache.clearForSpecs = function () {\n  // Unload in the order below. This prevents an unload function from unloading\n  // a resource that has already been unloaded.\n  const precedence = [\n    GltfVertexBufferLoader,\n    GltfIndexBufferLoader,\n    GltfDracoLoader,\n    GltfTextureLoader,\n    GltfImageLoader,\n    GltfBufferViewLoader,\n    BufferLoader,\n    MetadataSchemaLoader,\n    GltfJsonLoader,\n  ];\n\n  let cacheKey;\n  const cacheEntries = ResourceCache.cacheEntries;\n\n  const cacheEntriesSorted = [];\n  for (cacheKey in cacheEntries) {\n    if (cacheEntries.hasOwnProperty(cacheKey)) {\n      cacheEntriesSorted.push(cacheEntries[cacheKey]);\n    }\n  }\n\n  cacheEntriesSorted.sort(function (a, b) {\n    const indexA = precedence.indexOf(a.resourceLoader.constructor);\n    const indexB = precedence.indexOf(b.resourceLoader.constructor);\n    return indexA - indexB;\n  });\n\n  const cacheEntriesLength = cacheEntriesSorted.length;\n  for (let i = 0; i < cacheEntriesLength; ++i) {\n    const cacheEntry = cacheEntriesSorted[i];\n    cacheKey = cacheEntry.resourceLoader.cacheKey;\n    if (defined(cacheEntries[cacheKey])) {\n      cacheEntry.resourceLoader.destroy();\n      delete cacheEntries[cacheKey];\n    }\n  }\n};\n\nexport default ResourceCache;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getAbsoluteUri from \"../Core/getAbsoluteUri.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport hasExtension from \"./hasExtension.js\";\n\n/**\n * Compute cache keys for resources in {@link ResourceCache}.\n *\n * @namespace ResourceCacheKey\n *\n * @private\n */\nconst ResourceCacheKey = {};\n\nfunction getExternalResourceCacheKey(resource) {\n  return getAbsoluteUri(resource.url);\n}\n\nfunction getBufferViewCacheKey(bufferView) {\n  let byteOffset = bufferView.byteOffset;\n  let byteLength = bufferView.byteLength;\n\n  if (hasExtension(bufferView, \"EXT_meshopt_compression\")) {\n    const meshopt = bufferView.extensions.EXT_meshopt_compression;\n    byteOffset = defaultValue(meshopt.byteOffset, 0);\n    byteLength = meshopt.byteLength;\n  }\n\n  return `${byteOffset}-${byteOffset + byteLength}`;\n}\n\nfunction getAccessorCacheKey(accessor, bufferView) {\n  const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  const componentType = accessor.componentType;\n  const type = accessor.type;\n  const count = accessor.count;\n  return `${byteOffset}-${componentType}-${type}-${count}`;\n}\n\nfunction getExternalBufferCacheKey(resource) {\n  return getExternalResourceCacheKey(resource);\n}\n\nfunction getEmbeddedBufferCacheKey(parentResource, bufferId) {\n  const parentCacheKey = getExternalResourceCacheKey(parentResource);\n  return `${parentCacheKey}-buffer-id-${bufferId}`;\n}\n\nfunction getBufferCacheKey(buffer, bufferId, gltfResource, baseResource) {\n  if (defined(buffer.uri)) {\n    const resource = baseResource.getDerivedResource({\n      url: buffer.uri,\n    });\n    return getExternalBufferCacheKey(resource);\n  }\n\n  return getEmbeddedBufferCacheKey(gltfResource, bufferId);\n}\n\nfunction getDracoCacheKey(gltf, draco, gltfResource, baseResource) {\n  const bufferViewId = draco.bufferView;\n  const bufferView = gltf.bufferViews[bufferViewId];\n  const bufferId = bufferView.buffer;\n  const buffer = gltf.buffers[bufferId];\n\n  const bufferCacheKey = getBufferCacheKey(\n    buffer,\n    bufferId,\n    gltfResource,\n    baseResource\n  );\n\n  const bufferViewCacheKey = getBufferViewCacheKey(bufferView);\n\n  return `${bufferCacheKey}-range-${bufferViewCacheKey}`;\n}\n\nfunction getImageCacheKey(gltf, imageId, gltfResource, baseResource) {\n  const image = gltf.images[imageId];\n  const bufferViewId = image.bufferView;\n  const uri = image.uri;\n\n  if (defined(uri)) {\n    const resource = baseResource.getDerivedResource({\n      url: uri,\n    });\n    return getExternalResourceCacheKey(resource);\n  }\n\n  const bufferView = gltf.bufferViews[bufferViewId];\n  const bufferId = bufferView.buffer;\n  const buffer = gltf.buffers[bufferId];\n\n  const bufferCacheKey = getBufferCacheKey(\n    buffer,\n    bufferId,\n    gltfResource,\n    baseResource\n  );\n\n  const bufferViewCacheKey = getBufferViewCacheKey(bufferView);\n\n  return `${bufferCacheKey}-range-${bufferViewCacheKey}`;\n}\n\nfunction getSamplerCacheKey(gltf, textureInfo) {\n  const sampler = GltfLoaderUtil.createSampler({\n    gltf: gltf,\n    textureInfo: textureInfo,\n  });\n\n  return `${sampler.wrapS}-${sampler.wrapT}-${sampler.minificationFilter}-${sampler.magnificationFilter}`;\n}\n\n/**\n * Gets the schema cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} [options.schema] An object that explicitly defines a schema JSON. Mutually exclusive with options.resource.\n * @param {Resource} [options.resource] The {@link Resource} pointing to the schema JSON. Mutually exclusive with options.schema.\n *\n * @returns {String} The schema cache key.\n *\n * @exception {DeveloperError} One of options.schema and options.resource must be defined.\n * @private\n */\nResourceCacheKey.getSchemaCacheKey = function (options) {\n  const schema = options.schema;\n  const resource = options.resource;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(schema) === defined(resource)) {\n    throw new DeveloperError(\n      \"One of options.schema and options.resource must be defined.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (defined(schema)) {\n    return `embedded-schema:${JSON.stringify(schema)}`;\n  }\n\n  return `external-schema:${getExternalResourceCacheKey(resource)}`;\n};\n\n/**\n * Gets the external buffer cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.resource The {@link Resource} pointing to the external buffer.\n *\n * @returns {String} The external buffer cache key.\n * @private\n */\nResourceCacheKey.getExternalBufferCacheKey = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resource = options.resource;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.resource\", resource);\n  //>>includeEnd('debug');\n\n  return `external-buffer:${getExternalBufferCacheKey(resource)}`;\n};\n\n/**\n * Gets the embedded buffer cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.parentResource The {@link Resource} containing the embedded buffer.\n * @param {Number} options.bufferId A unique identifier of the embedded buffer within the parent resource.\n *\n * @returns {String} The embedded buffer cache key.\n * @private\n */\nResourceCacheKey.getEmbeddedBufferCacheKey = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const parentResource = options.parentResource;\n  const bufferId = options.bufferId;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.parentResource\", parentResource);\n  Check.typeOf.number(\"options.bufferId\", bufferId);\n  //>>includeEnd('debug');\n\n  return `embedded-buffer:${getEmbeddedBufferCacheKey(\n    parentResource,\n    bufferId\n  )}`;\n};\n\n/**\n * Gets the glTF cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n *\n * @returns {String} The glTF cache key.\n * @private\n */\nResourceCacheKey.getGltfCacheKey = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltfResource = options.gltfResource;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  //>>includeEnd('debug');\n\n  return `gltf:${getExternalResourceCacheKey(gltfResource)}`;\n};\n\n/**\n * Gets the buffer view cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.bufferViewId The bufferView ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {String} The buffer view cache key.\n * @private\n */\nResourceCacheKey.getBufferViewCacheKey = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const bufferViewId = options.bufferViewId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.bufferViewId\", bufferViewId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const bufferView = gltf.bufferViews[bufferViewId];\n  let bufferId = bufferView.buffer;\n  const buffer = gltf.buffers[bufferId];\n  if (hasExtension(bufferView, \"EXT_meshopt_compression\")) {\n    const meshopt = bufferView.extensions.EXT_meshopt_compression;\n    bufferId = meshopt.buffer;\n  }\n\n  const bufferCacheKey = getBufferCacheKey(\n    buffer,\n    bufferId,\n    gltfResource,\n    baseResource\n  );\n\n  const bufferViewCacheKey = getBufferViewCacheKey(bufferView);\n\n  return `buffer-view:${bufferCacheKey}-range-${bufferViewCacheKey}`;\n};\n\n/**\n * Gets the Draco cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Object} options.draco The Draco extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {String} The Draco cache key.\n * @private\n */\nResourceCacheKey.getDracoCacheKey = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const draco = options.draco;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.draco\", draco);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  return `draco:${getDracoCacheKey(gltf, draco, gltfResource, baseResource)}`;\n};\n\n/**\n * Gets the vertex buffer cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {Object} [options.draco] The Draco extension object.\n * @param {String} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {Boolean} [options.dequantize=false] Determines whether or not the vertex buffer will be dequantized on the CPU.\n * @param {Boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {Boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n *\n * @returns {String} The vertex buffer cache key.\n * @private\n */\nResourceCacheKey.getVertexBufferCacheKey = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const bufferViewId = options.bufferViewId;\n  const draco = options.draco;\n  const attributeSemantic = options.attributeSemantic;\n  const dequantize = defaultValue(options.dequantize, false);\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n\n  const hasBufferViewId = defined(bufferViewId);\n  const hasDraco = defined(draco);\n  const hasAttributeSemantic = defined(attributeSemantic);\n\n  if (hasBufferViewId === hasDraco) {\n    throw new DeveloperError(\n      \"One of options.bufferViewId and options.draco must be defined.\"\n    );\n  }\n\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.attributeSemantic must also be defined.\"\n    );\n  }\n\n  if (hasDraco) {\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n  }\n\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let cacheKeySuffix = \"\";\n  if (dequantize) {\n    cacheKeySuffix += \"-dequantize\";\n  }\n\n  if (loadBuffer) {\n    cacheKeySuffix += \"-buffer\";\n  }\n\n  if (loadTypedArray) {\n    cacheKeySuffix += \"-typed-array\";\n  }\n\n  if (defined(draco)) {\n    const dracoCacheKey = getDracoCacheKey(\n      gltf,\n      draco,\n      gltfResource,\n      baseResource\n    );\n    return `vertex-buffer:${dracoCacheKey}-draco-${attributeSemantic}${cacheKeySuffix}`;\n  }\n\n  const bufferView = gltf.bufferViews[bufferViewId];\n  const bufferId = bufferView.buffer;\n  const buffer = gltf.buffers[bufferId];\n\n  const bufferCacheKey = getBufferCacheKey(\n    buffer,\n    bufferId,\n    gltfResource,\n    baseResource\n  );\n\n  const bufferViewCacheKey = getBufferViewCacheKey(bufferView);\n\n  return `vertex-buffer:${bufferCacheKey}-range-${bufferViewCacheKey}${cacheKeySuffix}`;\n};\n\n/**\n * Gets the index buffer cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Object} [options.draco] The Draco extension object.\n * @param {Boolean} [options.loadBuffer=false] Load index buffer as a GPU index buffer.\n * @param {Boolean} [options.loadTypedArray=false] Load index buffer as a typed array.\n *\n * @returns {String} The index buffer cache key.\n * @private\n */\nResourceCacheKey.getIndexBufferCacheKey = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const accessorId = options.accessorId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const draco = options.draco;\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let cacheKeySuffix = \"\";\n  if (loadBuffer) {\n    cacheKeySuffix += \"-buffer\";\n  }\n\n  if (loadTypedArray) {\n    cacheKeySuffix += \"-typed-array\";\n  }\n\n  if (defined(draco)) {\n    const dracoCacheKey = getDracoCacheKey(\n      gltf,\n      draco,\n      gltfResource,\n      baseResource\n    );\n    return `index-buffer:${dracoCacheKey}-draco${cacheKeySuffix}`;\n  }\n\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n  const bufferView = gltf.bufferViews[bufferViewId];\n  const bufferId = bufferView.buffer;\n  const buffer = gltf.buffers[bufferId];\n\n  const bufferCacheKey = getBufferCacheKey(\n    buffer,\n    bufferId,\n    gltfResource,\n    baseResource\n  );\n\n  const accessorCacheKey = getAccessorCacheKey(accessor, bufferView);\n\n  return `index-buffer:${bufferCacheKey}-accessor-${accessorCacheKey}${cacheKeySuffix}`;\n};\n\n/**\n * Gets the image cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.imageId The image ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n *\n * @returns {String} The image cache key.\n * @private\n */\nResourceCacheKey.getImageCacheKey = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const imageId = options.imageId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.imageId\", imageId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const imageCacheKey = getImageCacheKey(\n    gltf,\n    imageId,\n    gltfResource,\n    baseResource\n  );\n\n  return `image:${imageCacheKey}`;\n};\n\n/**\n * Gets the texture cache key.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Object} options.textureInfo The texture info object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n *\n * @returns {String} The texture cache key.\n * @private\n */\nResourceCacheKey.getTextureCacheKey = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const textureInfo = options.textureInfo;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const supportedImageFormats = options.supportedImageFormats;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  //>>includeEnd('debug');\n\n  const textureId = textureInfo.index;\n\n  const imageId = GltfLoaderUtil.getImageIdFromTexture({\n    gltf: gltf,\n    textureId: textureId,\n    supportedImageFormats: supportedImageFormats,\n  });\n\n  const imageCacheKey = getImageCacheKey(\n    gltf,\n    imageId,\n    gltfResource,\n    baseResource\n  );\n\n  // Include the sampler cache key in the texture cache key since textures and\n  // samplers are coupled in WebGL 1. When upgrading to WebGL 2 consider\n  // removing the sampleCacheKey here.\n  const samplerCacheKey = getSamplerCacheKey(gltf, textureInfo);\n\n  return `texture:${imageCacheKey}-sampler-${samplerCacheKey}`;\n};\n\nexport default ResourceCacheKey;\n","import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * A cache resource.\n * <p>\n * This type describes an interface and is not intended to be instantiated directly.\n * </p>\n *\n * @alias ResourceLoader\n * @constructor\n *\n * @see ResourceCache\n *\n * @private\n */\nexport default function ResourceLoader() {}\n\nObject.defineProperties(ResourceLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof ResourceLoader.prototype\n   *\n   * @type {Promise.<ResourceLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof ResourceLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<ResourceLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nResourceLoader.prototype.load = function () {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nResourceLoader.prototype.unload = function () {};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nResourceLoader.prototype.process = function (frameState) {};\n\n/**\n * Constructs a {@link RuntimeError} from an errorMessage and an error.\n *\n * @param {String} errorMessage The error message.\n * @param {Error} [error] The error.\n *\n * @returns {RuntimeError} The runtime error.\n * @private\n */\nResourceLoader.prototype.getError = function (errorMessage, error) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"errorMessage\", errorMessage);\n  //>>includeEnd('debug');\n\n  if (defined(error)) {\n    errorMessage += `\\n${error.message}`;\n  }\n  return new RuntimeError(errorMessage);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ResourceLoader#destroy\n * @private\n */\nResourceLoader.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the loaded resource.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * resourceLoader = resourceLoader && resourceLoader.destroy();\n *\n * @see ResourceLoader#isDestroyed\n * @private\n */\nResourceLoader.prototype.destroy = function () {\n  this.unload();\n  return destroyObject(this);\n};\n","/**\n * The {@link ResourceLoader} state.\n *\n * @private\n */\nconst ResourceLoaderState = {\n  /**\n   * The resource has not yet been loaded.\n   *\n   * @type {Number}\n   * @constant\n   * @private\n   */\n  UNLOADED: 0,\n  /**\n   * The resource is loading. In this state, external resources are fetched as needed.\n   *\n   * @type {Number}\n   * @constant\n   * @private\n   */\n  LOADING: 1,\n  /**\n   * The resource has finished loading, but requires further processing. GPU resources are allocated in this state as needed.\n   *\n   * @type {Number}\n   * @constant\n   * @private\n   */\n  PROCESSING: 2,\n  /**\n   * The resource has finished loading and processing; the results are ready to be used.\n   *\n   * @type {Number}\n   * @constant\n   * @private\n   */\n  READY: 3,\n  /**\n   * The resource loading or processing has failed due to an error.\n   *\n   * @type {Number}\n   * @constant\n   * @private\n   */\n  FAILED: 4,\n};\nexport default Object.freeze(ResourceLoaderState);\n","/**\n * Settings for the generation of signed distance field glyphs\n *\n * @private\n */\nconst SDFSettings = {\n  /**\n   * The font size in pixels\n   *\n   * @type {Number}\n   * @constant\n   */\n  FONT_SIZE: 48.0,\n\n  /**\n   * Whitespace padding around glyphs.\n   *\n   * @type {Number}\n   * @constant\n   */\n  PADDING: 10.0,\n\n  /**\n   * How many pixels around the glyph shape to use for encoding distance\n   *\n   * @type {Number}\n   * @constant\n   */\n  RADIUS: 8.0,\n\n  /**\n   * How much of the radius (relative) is used for the inside part the glyph.\n   *\n   * @type {Number}\n   * @constant\n   */\n  CUTOFF: 0.25,\n};\nexport default Object.freeze(SDFSettings);\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport mergeSort from \"../Core/mergeSort.js\";\nimport Occluder from \"../Core/Occluder.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport RequestScheduler from \"../Core/RequestScheduler.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport ComputeEngine from \"../Renderer/ComputeEngine.js\";\nimport Context from \"../Renderer/Context.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport BrdfLutGenerator from \"./BrdfLutGenerator.js\";\nimport Camera from \"./Camera.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTilePassState from \"./Cesium3DTilePassState.js\";\nimport CreditDisplay from \"./CreditDisplay.js\";\nimport DebugCameraPrimitive from \"./DebugCameraPrimitive.js\";\nimport DepthPlane from \"./DepthPlane.js\";\nimport DerivedCommand from \"./DerivedCommand.js\";\nimport DeviceOrientationCameraController from \"./DeviceOrientationCameraController.js\";\nimport Fog from \"./Fog.js\";\nimport FrameState from \"./FrameState.js\";\nimport GlobeTranslucencyState from \"./GlobeTranslucencyState.js\";\nimport InvertClassification from \"./InvertClassification.js\";\nimport JobScheduler from \"./JobScheduler.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport OctahedralProjectedCubeMap from \"./OctahedralProjectedCubeMap.js\";\nimport PerformanceDisplay from \"./PerformanceDisplay.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Picking from \"./Picking.js\";\nimport PostProcessStageCollection from \"./PostProcessStageCollection.js\";\nimport Primitive from \"./Primitive.js\";\nimport PrimitiveCollection from \"./PrimitiveCollection.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport SceneTransitioner from \"./SceneTransitioner.js\";\nimport ScreenSpaceCameraController from \"./ScreenSpaceCameraController.js\";\nimport ShadowMap from \"./ShadowMap.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport SunLight from \"./SunLight.js\";\nimport SunPostProcess from \"./SunPostProcess.js\";\nimport TweenCollection from \"./TweenCollection.js\";\nimport View from \"./View.js\";\nimport DebugInspector from \"./DebugInspector.js\";\n\nconst requestRenderAfterFrame = function (scene) {\n  return function () {\n    scene.frameState.afterRender.push(function () {\n      scene.requestRender();\n    });\n  };\n};\n\n/**\n * The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,\n * a scene is not created directly; instead, it is implicitly created by {@link CesiumWidget}.\n * <p>\n * <em><code>contextOptions</code> parameter details:</em>\n * </p>\n * <p>\n * The default values are:\n * <code>\n * {\n *   webgl : {\n *     alpha : false,\n *     depth : true,\n *     stencil : false,\n *     antialias : true,\n *     powerPreference: 'high-performance',\n *     premultipliedAlpha : true,\n *     preserveDrawingBuffer : false,\n *     failIfMajorPerformanceCaveat : false\n *   },\n *   allowTextureFilterAnisotropic : true\n * }\n * </code>\n * </p>\n * <p>\n * The <code>webgl</code> property corresponds to the {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}\n * object used to create the WebGL context.\n * </p>\n * <p>\n * <code>webgl.alpha</code> defaults to false, which can improve performance compared to the standard WebGL default\n * of true.  If an application needs to composite Cesium above other HTML elements using alpha-blending, set\n * <code>webgl.alpha</code> to true.\n * </p>\n * <p>\n * The other <code>webgl</code> properties match the WebGL defaults for {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}.\n * </p>\n * <p>\n * <code>allowTextureFilterAnisotropic</code> defaults to true, which enables anisotropic texture filtering when the\n * WebGL extension is supported.  Setting this to false will improve performance, but hurt visual quality, especially for horizon views.\n * </p>\n *\n * @alias Scene\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {HTMLCanvasElement} options.canvas The HTML canvas element to create the scene for.\n * @param {Object} [options.contextOptions] Context and WebGL creation properties.  See details above.\n * @param {Element} [options.creditContainer] The HTML element in which the credits will be displayed.\n * @param {Element} [options.creditViewport] The HTML element in which to display the credit popup.  If not specified, the viewport will be a added as a sibling of the canvas.\n * @param {MapProjection} [options.mapProjection=new GeographicProjection()] The map projection to use in 2D and Columbus View modes.\n * @param {Boolean} [options.orderIndependentTranslucency=true] If true and the configuration supports it, use order independent translucency.\n * @param {Boolean} [options.scene3DOnly=false] If true, optimizes memory use and performance for 3D mode but disables the ability to use 2D or Columbus View.\n * @param {Boolean} [options.shadows=false] Determines if shadows are cast by light sources.\n * @param {MapMode2D} [options.mapMode2D=MapMode2D.INFINITE_SCROLL] Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.\n * @param {Boolean} [options.requestRenderMode=false] If true, rendering a frame will only occur when needed as determined by changes within the scene. Enabling improves performance of the application, but requires using {@link Scene#requestRender} to render a new frame explicitly in this mode. This will be necessary in many cases after making changes to the scene in other parts of the API. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.\n * @param {Number} [options.maximumRenderTimeChange=0.0] If requestRenderMode is true, this value defines the maximum change in simulation time allowed before a render is requested. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.\n * @param {Number} [depthPlaneEllipsoidOffset=0.0] Adjust the DepthPlane to address rendering artefacts below ellipsoid zero elevation.\n * @param {Number} [options.msaaSamples=1] If provided, this value controls the rate of multisample antialiasing. Typical multisampling rates are 2, 4, and sometimes 8 samples per pixel. Higher sampling rates of MSAA may impact performance in exchange for improved visual quality. This value only applies to WebGL2 contexts that support multisample render targets.\n *\n * @see CesiumWidget\n * @see {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}\n *\n * @exception {DeveloperError} options and options.canvas are required.\n *\n * @example\n * // Create scene without anisotropic texture filtering\n * const scene = new Cesium.Scene({\n *   canvas : canvas,\n *   contextOptions : {\n *     allowTextureFilterAnisotropic : false\n *   }\n * });\n */\nfunction Scene(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const canvas = options.canvas;\n  let creditContainer = options.creditContainer;\n  let creditViewport = options.creditViewport;\n\n  let contextOptions = clone(options.contextOptions);\n  if (!defined(contextOptions)) {\n    contextOptions = {};\n  }\n  if (!defined(contextOptions.webgl)) {\n    contextOptions.webgl = {};\n  }\n  contextOptions.webgl.powerPreference = defaultValue(\n    contextOptions.webgl.powerPreference,\n    \"high-performance\"\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(canvas)) {\n    throw new DeveloperError(\"options and options.canvas are required.\");\n  }\n  //>>includeEnd('debug');\n  const hasCreditContainer = defined(creditContainer);\n  const context = new Context(canvas, contextOptions);\n  if (!hasCreditContainer) {\n    creditContainer = document.createElement(\"div\");\n    creditContainer.style.position = \"absolute\";\n    creditContainer.style.bottom = \"0\";\n    creditContainer.style[\"text-shadow\"] = \"0 0 2px #000000\";\n    creditContainer.style.color = \"#ffffff\";\n    creditContainer.style[\"font-size\"] = \"10px\";\n    creditContainer.style[\"padding-right\"] = \"5px\";\n    canvas.parentNode.appendChild(creditContainer);\n  }\n  if (!defined(creditViewport)) {\n    creditViewport = canvas.parentNode;\n  }\n\n  this._id = createGuid();\n  this._jobScheduler = new JobScheduler();\n  this._frameState = new FrameState(\n    context,\n    new CreditDisplay(creditContainer, \" • \", creditViewport),\n    this._jobScheduler\n  );\n  this._frameState.scene3DOnly = defaultValue(options.scene3DOnly, false);\n  this._removeCreditContainer = !hasCreditContainer;\n  this._creditContainer = creditContainer;\n\n  this._canvas = canvas;\n  this._context = context;\n  this._computeEngine = new ComputeEngine(context);\n  this._globe = undefined;\n  this._globeTranslucencyState = new GlobeTranslucencyState();\n  this._primitives = new PrimitiveCollection();\n  this._groundPrimitives = new PrimitiveCollection();\n\n  this._globeHeight = undefined;\n  this._cameraUnderground = false;\n\n  this._logDepthBuffer = context.fragmentDepth;\n  this._logDepthBufferDirty = true;\n\n  this._tweens = new TweenCollection();\n\n  this._shaderFrameCount = 0;\n\n  this._sunPostProcess = undefined;\n\n  this._computeCommandList = [];\n  this._overlayCommandList = [];\n\n  this._useOIT = defaultValue(options.orderIndependentTranslucency, true);\n  this._executeOITFunction = undefined;\n\n  this._depthPlane = new DepthPlane(options.depthPlaneEllipsoidOffset);\n\n  this._clearColorCommand = new ClearCommand({\n    color: new Color(),\n    stencil: 0,\n    owner: this,\n  });\n  this._depthClearCommand = new ClearCommand({\n    depth: 1.0,\n    owner: this,\n  });\n  this._stencilClearCommand = new ClearCommand({\n    stencil: 0,\n  });\n  this._classificationStencilClearCommand = new ClearCommand({\n    stencil: 0,\n    renderState: RenderState.fromCache({\n      stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    }),\n  });\n\n  this._depthOnlyRenderStateCache = {};\n\n  this._transitioner = new SceneTransitioner(this);\n\n  this._preUpdate = new Event();\n  this._postUpdate = new Event();\n\n  this._renderError = new Event();\n  this._preRender = new Event();\n  this._postRender = new Event();\n\n  this._minimumDisableDepthTestDistance = 0.0;\n  this._debugInspector = new DebugInspector();\n\n  this._msaaSamples = defaultValue(options.msaaSamples, 1);\n\n  /**\n   * Exceptions occurring in <code>render</code> are always caught in order to raise the\n   * <code>renderError</code> event.  If this property is true, the error is rethrown\n   * after the event is raised.  If this property is false, the <code>render</code> function\n   * returns normally after raising the event.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.rethrowRenderErrors = false;\n\n  /**\n   * Determines whether or not to instantly complete the\n   * scene transition animation on user input.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.completeMorphOnUserInput = true;\n\n  /**\n   * The event fired at the beginning of a scene transition.\n   * @type {Event}\n   * @default Event()\n   */\n  this.morphStart = new Event();\n\n  /**\n   * The event fired at the completion of a scene transition.\n   * @type {Event}\n   * @default Event()\n   */\n  this.morphComplete = new Event();\n\n  /**\n   * The {@link SkyBox} used to draw the stars.\n   *\n   * @type {SkyBox}\n   * @default undefined\n   *\n   * @see Scene#backgroundColor\n   */\n  this.skyBox = undefined;\n\n  /**\n   * The sky atmosphere drawn around the globe.\n   *\n   * @type {SkyAtmosphere}\n   * @default undefined\n   */\n  this.skyAtmosphere = undefined;\n\n  /**\n   * The {@link Sun}.\n   *\n   * @type {Sun}\n   * @default undefined\n   */\n  this.sun = undefined;\n\n  /**\n   * Uses a bloom filter on the sun when enabled.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.sunBloom = true;\n  this._sunBloom = undefined;\n\n  /**\n   * The {@link Moon}\n   *\n   * @type Moon\n   * @default undefined\n   */\n  this.moon = undefined;\n\n  /**\n   * The background color, which is only visible if there is no sky box, i.e., {@link Scene#skyBox} is undefined.\n   *\n   * @type {Color}\n   * @default {@link Color.BLACK}\n   *\n   * @see Scene#skyBox\n   */\n  this.backgroundColor = Color.clone(Color.BLACK);\n\n  this._mode = SceneMode.SCENE3D;\n\n  this._mapProjection = defined(options.mapProjection)\n    ? options.mapProjection\n    : new GeographicProjection();\n\n  /**\n   * The current morph transition time between 2D/Columbus View and 3D,\n   * with 0.0 being 2D or Columbus View and 1.0 being 3D.\n   *\n   * @type {Number}\n   * @default 1.0\n   */\n  this.morphTime = 1.0;\n\n  /**\n   * The far-to-near ratio of the multi-frustum when using a normal depth buffer.\n   * <p>\n   * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used\n   * when {@link Scene#logarithmicDepthBuffer} is <code>false</code>. When <code>logarithmicDepthBuffer</code> is\n   * <code>true</code>, use {@link Scene#logarithmicDepthFarToNearRatio}.\n   * </p>\n   *\n   * @type {Number}\n   * @default 1000.0\n   */\n  this.farToNearRatio = 1000.0;\n\n  /**\n   * The far-to-near ratio of the multi-frustum when using a logarithmic depth buffer.\n   * <p>\n   * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used\n   * when {@link Scene#logarithmicDepthBuffer} is <code>true</code>. When <code>logarithmicDepthBuffer</code> is\n   * <code>false</code>, use {@link Scene#farToNearRatio}.\n   * </p>\n   *\n   * @type {Number}\n   * @default 1e9\n   */\n  this.logarithmicDepthFarToNearRatio = 1e9;\n\n  /**\n   * Determines the uniform depth size in meters of each frustum of the multifrustum in 2D. If a primitive or model close\n   * to the surface shows z-fighting, decreasing this will eliminate the artifact, but decrease performance. On the\n   * other hand, increasing this will increase performance but may cause z-fighting among primitives close to the surface.\n   *\n   * @type {Number}\n   * @default 1.75e6\n   */\n  this.nearToFarDistance2D = 1.75e6;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * A function that determines what commands are executed.  As shown in the examples below,\n   * the function receives the command's <code>owner</code> as an argument, and returns a boolean indicating if the\n   * command should be executed.\n   * </p>\n   * <p>\n   * The default is <code>undefined</code>, indicating that all commands are executed.\n   * </p>\n   *\n   * @type Function\n   *\n   * @default undefined\n   *\n   * @example\n   * // Do not execute any commands.\n   * scene.debugCommandFilter = function(command) {\n   *     return false;\n   * };\n   *\n   * // Execute only the billboard's commands.  That is, only draw the billboard.\n   * const billboards = new Cesium.BillboardCollection();\n   * scene.debugCommandFilter = function(command) {\n   *     return command.owner === billboards;\n   * };\n   */\n  this.debugCommandFilter = undefined;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When <code>true</code>, commands are randomly shaded.  This is useful\n   * for performance analysis to see what parts of a scene or model are\n   * command-dense and could benefit from batching.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.debugShowCommands = false;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When <code>true</code>, commands are shaded based on the frustums they\n   * overlap.  Commands in the closest frustum are tinted red, commands in\n   * the next closest are green, and commands in the farthest frustum are\n   * blue.  If a command overlaps more than one frustum, the color components\n   * are combined, e.g., a command overlapping the first two frustums is tinted\n   * yellow.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.debugShowFrustums = false;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * Displays frames per second and time between frames.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.debugShowFramesPerSecond = false;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * Indicates which frustum will have depth information displayed.\n   * </p>\n   *\n   * @type Number\n   *\n   * @default 1\n   */\n  this.debugShowDepthFrustum = 1;\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When <code>true</code>, draws outlines to show the boundaries of the camera frustums\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.debugShowFrustumPlanes = false;\n  this._debugShowFrustumPlanes = false;\n  this._debugFrustumPlanes = undefined;\n\n  /**\n   * When <code>true</code>, enables picking using the depth buffer.\n   *\n   * @type Boolean\n   * @default true\n   */\n  this.useDepthPicking = true;\n\n  /**\n   * When <code>true</code>, enables picking translucent geometry using the depth buffer. Note that {@link Scene#useDepthPicking} must also be true for enabling this to work.\n   *\n   * <p>\n   * There is a decrease in performance when enabled. There are extra draw calls to write depth for\n   * translucent geometry.\n   * </p>\n   *\n   * @example\n   * // picking the position of a translucent primitive\n   * viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {\n   *      const pickedFeature = viewer.scene.pick(movement.position);\n   *      if (!Cesium.defined(pickedFeature)) {\n   *          // nothing picked\n   *          return;\n   *      }\n   *      const worldPosition = viewer.scene.pickPosition(movement.position);\n   * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.pickTranslucentDepth = false;\n\n  /**\n   * The time in milliseconds to wait before checking if the camera has not moved and fire the cameraMoveEnd event.\n   * @type {Number}\n   * @default 500.0\n   * @private\n   */\n  this.cameraEventWaitTime = 500.0;\n\n  /**\n   * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional\n   * performance improvements by rendering less geometry and dispatching less terrain requests.\n   * @type {Fog}\n   */\n  this.fog = new Fog();\n\n  this._shadowMapCamera = new Camera(this);\n\n  /**\n   * The shadow map for the scene's light source. When enabled, models, primitives, and the globe may cast and receive shadows.\n   * @type {ShadowMap}\n   */\n  this.shadowMap = new ShadowMap({\n    context: context,\n    lightCamera: this._shadowMapCamera,\n    enabled: defaultValue(options.shadows, false),\n  });\n\n  /**\n   * When <code>false</code>, 3D Tiles will render normally. When <code>true</code>, classified 3D Tile geometry will render normally and\n   * unclassified 3D Tile geometry will render with the color multiplied by {@link Scene#invertClassificationColor}.\n   * @type {Boolean}\n   * @default false\n   */\n  this.invertClassification = false;\n\n  /**\n   * The highlight color of unclassified 3D Tile geometry when {@link Scene#invertClassification} is <code>true</code>.\n   * <p>When the color's alpha is less than 1.0, the unclassified portions of the 3D Tiles will not blend correctly with the classified positions of the 3D Tiles.</p>\n   * <p>Also, when the color's alpha is less than 1.0, the WEBGL_depth_texture and EXT_frag_depth WebGL extensions must be supported.</p>\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  this.invertClassificationColor = Color.clone(Color.WHITE);\n\n  this._actualInvertClassificationColor = Color.clone(\n    this._invertClassificationColor\n  );\n  this._invertClassification = new InvertClassification();\n\n  /**\n   * The focal length for use when with cardboard or WebVR.\n   * @type {Number}\n   */\n  this.focalLength = undefined;\n\n  /**\n   * The eye separation distance in meters for use with cardboard or WebVR.\n   * @type {Number}\n   */\n  this.eyeSeparation = undefined;\n\n  /**\n   * Post processing effects applied to the final render.\n   * @type {PostProcessStageCollection}\n   */\n  this.postProcessStages = new PostProcessStageCollection();\n\n  this._brdfLutGenerator = new BrdfLutGenerator();\n\n  this._performanceDisplay = undefined;\n  this._debugVolume = undefined;\n\n  this._screenSpaceCameraController = new ScreenSpaceCameraController(this);\n  this._cameraUnderground = false;\n  this._mapMode2D = defaultValue(options.mapMode2D, MapMode2D.INFINITE_SCROLL);\n\n  // Keeps track of the state of a frame. FrameState is the state across\n  // the primitives of the scene. This state is for internally keeping track\n  // of celestial and environment effects that need to be updated/rendered in\n  // a certain order as well as updating/tracking framebuffer usage.\n  this._environmentState = {\n    skyBoxCommand: undefined,\n    skyAtmosphereCommand: undefined,\n    sunDrawCommand: undefined,\n    sunComputeCommand: undefined,\n    moonCommand: undefined,\n\n    isSunVisible: false,\n    isMoonVisible: false,\n    isReadyForAtmosphere: false,\n    isSkyAtmosphereVisible: false,\n\n    clearGlobeDepth: false,\n    useDepthPlane: false,\n    renderTranslucentDepthForPick: false,\n\n    originalFramebuffer: undefined,\n    useGlobeDepthFramebuffer: false,\n    useOIT: false,\n    useInvertClassification: false,\n    usePostProcess: false,\n    usePostProcessSelected: false,\n    useWebVR: false,\n  };\n\n  this._useWebVR = false;\n  this._cameraVR = undefined;\n  this._aspectRatioVR = undefined;\n\n  /**\n   * When <code>true</code>, rendering a frame will only occur when needed as determined by changes within the scene.\n   * Enabling improves performance of the application, but requires using {@link Scene#requestRender}\n   * to render a new frame explicitly in this mode. This will be necessary in many cases after making changes\n   * to the scene in other parts of the API.\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#maximumRenderTimeChange\n   * @see Scene#requestRender\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.requestRenderMode = defaultValue(options.requestRenderMode, false);\n  this._renderRequested = true;\n\n  /**\n   * If {@link Scene#requestRenderMode} is <code>true</code>, this value defines the maximum change in\n   * simulation time allowed before a render is requested. Lower values increase the number of frames rendered\n   * and higher values decrease the number of frames rendered. If <code>undefined</code>, changes to\n   * the simulation time will never request a render.\n   * This value impacts the rate of rendering for changes in the scene like lighting, entity property updates,\n   * and animations.\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#requestRenderMode\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.maximumRenderTimeChange = defaultValue(\n    options.maximumRenderTimeChange,\n    0.0\n  );\n  this._lastRenderTime = undefined;\n  this._frameRateMonitor = undefined;\n\n  this._removeRequestListenerCallback = RequestScheduler.requestCompletedEvent.addEventListener(\n    requestRenderAfterFrame(this)\n  );\n  this._removeTaskProcessorListenerCallback = TaskProcessor.taskCompletedEvent.addEventListener(\n    requestRenderAfterFrame(this)\n  );\n  this._removeGlobeCallbacks = [];\n\n  const viewport = new BoundingRectangle(\n    0,\n    0,\n    context.drawingBufferWidth,\n    context.drawingBufferHeight\n  );\n  const camera = new Camera(this);\n\n  if (this._logDepthBuffer) {\n    camera.frustum.near = 0.1;\n    camera.frustum.far = 10000000000.0;\n  }\n\n  /**\n   * The camera view for the scene camera flight destination. Used for preloading flight destination tiles.\n   * @type {Camera}\n   * @private\n   */\n  this.preloadFlightCamera = new Camera(this);\n\n  /**\n   * The culling volume for the scene camera flight destination. Used for preloading flight destination tiles.\n   * @type {CullingVolume}\n   * @private\n   */\n  this.preloadFlightCullingVolume = undefined;\n\n  this._picking = new Picking(this);\n  this._defaultView = new View(this, camera, viewport);\n  this._view = this._defaultView;\n\n  this._hdr = undefined;\n  this._hdrDirty = undefined;\n  this.highDynamicRange = false;\n  this.gamma = 2.2;\n\n  /**\n   * The spherical harmonic coefficients for image-based lighting of PBR models.\n   * @type {Cartesian3[]}\n   */\n  this.sphericalHarmonicCoefficients = undefined;\n\n  /**\n   * The url to the KTX2 file containing the specular environment map and convoluted mipmaps for image-based lighting of PBR models.\n   * @type {String}\n   */\n  this.specularEnvironmentMaps = undefined;\n  this._specularEnvironmentMapAtlas = undefined;\n\n  /**\n   * The light source for shading. Defaults to a directional light from the Sun.\n   * @type {Light}\n   */\n  this.light = new SunLight();\n\n  // Give frameState, camera, and screen space camera controller initial state before rendering\n  updateFrameNumber(this, 0.0, JulianDate.now());\n  this.updateFrameState();\n  this.initializeFrame();\n}\n\nfunction updateGlobeListeners(scene, globe) {\n  for (let i = 0; i < scene._removeGlobeCallbacks.length; ++i) {\n    scene._removeGlobeCallbacks[i]();\n  }\n  scene._removeGlobeCallbacks.length = 0;\n\n  const removeGlobeCallbacks = [];\n  if (defined(globe)) {\n    removeGlobeCallbacks.push(\n      globe.imageryLayersUpdatedEvent.addEventListener(\n        requestRenderAfterFrame(scene)\n      )\n    );\n    removeGlobeCallbacks.push(\n      globe.terrainProviderChanged.addEventListener(\n        requestRenderAfterFrame(scene)\n      )\n    );\n  }\n  scene._removeGlobeCallbacks = removeGlobeCallbacks;\n}\n\nObject.defineProperties(Scene.prototype, {\n  /**\n   * Gets the canvas element to which this scene is bound.\n   * @memberof Scene.prototype\n   *\n   * @type {HTMLCanvasElement}\n   * @readonly\n   */\n  canvas: {\n    get: function () {\n      return this._canvas;\n    },\n  },\n\n  /**\n   * The drawingBufferHeight of the underlying GL context.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferHeight|drawingBufferHeight}\n   */\n  drawingBufferHeight: {\n    get: function () {\n      return this._context.drawingBufferHeight;\n    },\n  },\n\n  /**\n   * The drawingBufferHeight of the underlying GL context.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferHeight|drawingBufferHeight}\n   */\n  drawingBufferWidth: {\n    get: function () {\n      return this._context.drawingBufferWidth;\n    },\n  },\n\n  /**\n   * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.\n   */\n  maximumAliasedLineWidth: {\n    get: function () {\n      return ContextLimits.maximumAliasedLineWidth;\n    },\n  },\n\n  /**\n   * The maximum length in pixels of one edge of a cube map, supported by this WebGL implementation.  It will be at least 16.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>.\n   */\n  maximumCubeMapSize: {\n    get: function () {\n      return ContextLimits.maximumCubeMapSize;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#pickPosition} function is supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#pickPosition\n   */\n  pickPositionSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#sampleHeight} and {@link Scene#sampleHeightMostDetailed} functions are supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#sampleHeight\n   * @see Scene#sampleHeightMostDetailed\n   */\n  sampleHeightSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#clampToHeight} and {@link Scene#clampToHeightMostDetailed} functions are supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#clampToHeight\n   * @see Scene#clampToHeightMostDetailed\n   */\n  clampToHeightSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if the {@link Scene#invertClassification} is supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#invertClassification\n   */\n  invertClassificationSupported: {\n    get: function () {\n      return this._context.depthTexture;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if specular environment maps are supported.\n   * @memberof Scene.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @see Scene#specularEnvironmentMaps\n   */\n  specularEnvironmentMapsSupported: {\n    get: function () {\n      return OctahedralProjectedCubeMap.isSupported(this._context);\n    },\n  },\n\n  /**\n   * Gets or sets the depth-test ellipsoid.\n   * @memberof Scene.prototype\n   *\n   * @type {Globe}\n   */\n  globe: {\n    get: function () {\n      return this._globe;\n    },\n\n    set: function (globe) {\n      this._globe = this._globe && this._globe.destroy();\n      this._globe = globe;\n\n      updateGlobeListeners(this, globe);\n    },\n  },\n\n  /**\n   * Gets the collection of primitives.\n   * @memberof Scene.prototype\n   *\n   * @type {PrimitiveCollection}\n   * @readonly\n   */\n  primitives: {\n    get: function () {\n      return this._primitives;\n    },\n  },\n\n  /**\n   * Gets the collection of ground primitives.\n   * @memberof Scene.prototype\n   *\n   * @type {PrimitiveCollection}\n   * @readonly\n   */\n  groundPrimitives: {\n    get: function () {\n      return this._groundPrimitives;\n    },\n  },\n\n  /**\n   * Gets or sets the camera.\n   * @memberof Scene.prototype\n   *\n   * @type {Camera}\n   * @readonly\n   */\n  camera: {\n    get: function () {\n      return this._view.camera;\n    },\n    set: function (camera) {\n      // For internal use only. Documentation is still @readonly.\n      this._view.camera = camera;\n    },\n  },\n\n  /**\n   * Gets or sets the view.\n   * @memberof Scene.prototype\n   *\n   * @type {View}\n   * @readonly\n   *\n   * @private\n   */\n  view: {\n    get: function () {\n      return this._view;\n    },\n    set: function (view) {\n      // For internal use only. Documentation is still @readonly.\n      this._view = view;\n    },\n  },\n\n  /**\n   * Gets the default view.\n   * @memberof Scene.prototype\n   *\n   * @type {View}\n   * @readonly\n   *\n   * @private\n   */\n  defaultView: {\n    get: function () {\n      return this._defaultView;\n    },\n  },\n\n  /**\n   * Gets picking functions and state\n   * @memberof Scene.prototype\n   *\n   * @type {Picking}\n   * @readonly\n   *\n   * @private\n   */\n  picking: {\n    get: function () {\n      return this._picking;\n    },\n  },\n\n  /**\n   * Gets the controller for camera input handling.\n   * @memberof Scene.prototype\n   *\n   * @type {ScreenSpaceCameraController}\n   * @readonly\n   */\n  screenSpaceCameraController: {\n    get: function () {\n      return this._screenSpaceCameraController;\n    },\n  },\n\n  /**\n   * Get the map projection to use in 2D and Columbus View modes.\n   * @memberof Scene.prototype\n   *\n   * @type {MapProjection}\n   * @readonly\n   *\n   * @default new GeographicProjection()\n   */\n  mapProjection: {\n    get: function () {\n      return this._mapProjection;\n    },\n  },\n\n  /**\n   * Gets the job scheduler\n   * @memberof Scene.prototype\n   * @type {JobScheduler}\n   * @readonly\n   *\n   * @private\n   */\n  jobScheduler: {\n    get: function () {\n      return this._jobScheduler;\n    },\n  },\n\n  /**\n   * Gets state information about the current scene. If called outside of a primitive's <code>update</code>\n   * function, the previous frame's state is returned.\n   * @memberof Scene.prototype\n   *\n   * @type {FrameState}\n   * @readonly\n   *\n   * @private\n   */\n  frameState: {\n    get: function () {\n      return this._frameState;\n    },\n  },\n\n  /**\n   * Gets the environment state.\n   * @memberof Scene.prototype\n   *\n   * @type {EnvironmentState}\n   * @readonly\n   *\n   * @private\n   */\n  environmentState: {\n    get: function () {\n      return this._environmentState;\n    },\n  },\n\n  /**\n   * Gets the collection of tweens taking place in the scene.\n   * @memberof Scene.prototype\n   *\n   * @type {TweenCollection}\n   * @readonly\n   *\n   * @private\n   */\n  tweens: {\n    get: function () {\n      return this._tweens;\n    },\n  },\n\n  /**\n   * Gets the collection of image layers that will be rendered on the globe.\n   * @memberof Scene.prototype\n   *\n   * @type {ImageryLayerCollection}\n   * @readonly\n   */\n  imageryLayers: {\n    get: function () {\n      if (!defined(this.globe)) {\n        return undefined;\n      }\n\n      return this.globe.imageryLayers;\n    },\n  },\n\n  /**\n   * The terrain provider providing surface geometry for the globe.\n   * @memberof Scene.prototype\n   *\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      if (!defined(this.globe)) {\n        return undefined;\n      }\n\n      return this.globe.terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (defined(this.globe)) {\n        this.globe.terrainProvider = terrainProvider;\n      }\n    },\n  },\n\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   * @memberof Scene.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function () {\n      if (!defined(this.globe)) {\n        return undefined;\n      }\n\n      return this.globe.terrainProviderChanged;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised before the scene is updated or rendered.  Subscribers to the event\n   * receive the Scene instance as the first parameter and the current time as the second parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#postUpdate\n   * @see Scene#preRender\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  preUpdate: {\n    get: function () {\n      return this._preUpdate;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised immediately after the scene is updated and before the scene is rendered.\n   * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second\n   * parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#preUpdate\n   * @see Scene#preRender\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  postUpdate: {\n    get: function () {\n      return this._postUpdate;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when an error is thrown inside the <code>render</code> function.\n   * The Scene instance and the thrown error are the only two parameters passed to the event handler.\n   * By default, errors are not rethrown after this event is raised, but that can be changed by setting\n   * the <code>rethrowRenderErrors</code> property.\n   * @memberof Scene.prototype\n   *\n   * @type {Event}\n   * @readonly\n   */\n  renderError: {\n    get: function () {\n      return this._renderError;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised after the scene is updated and immediately before the scene is rendered.\n   * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second\n   * parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#preUpdate\n   * @see Scene#postUpdate\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  preRender: {\n    get: function () {\n      return this._preRender;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised immediately after the scene is rendered.  Subscribers to the event\n   * receive the Scene instance as the first parameter and the current time as the second parameter.\n   * @memberof Scene.prototype\n   *\n   * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}\n   * @see Scene#preUpdate\n   * @see Scene#postUpdate\n   * @see Scene#postRender\n   *\n   * @type {Event}\n   * @readonly\n   */\n  postRender: {\n    get: function () {\n      return this._postRender;\n    },\n  },\n\n  /**\n   * Gets the simulation time when the scene was last rendered. Returns undefined if the scene has not yet been\n   * rendered.\n   * @memberof Scene.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   */\n  lastRenderTime: {\n    get: function () {\n      return this._lastRenderTime;\n    },\n  },\n\n  /**\n   * @memberof Scene.prototype\n   * @private\n   * @readonly\n   */\n  context: {\n    get: function () {\n      return this._context;\n    },\n  },\n\n  /**\n   * This property is for debugging only; it is not for production use.\n   * <p>\n   * When {@link Scene.debugShowFrustums} is <code>true</code>, this contains\n   * properties with statistics about the number of command execute per frustum.\n   * <code>totalCommands</code> is the total number of commands executed, ignoring\n   * overlap. <code>commandsInFrustums</code> is an array with the number of times\n   * commands are executed redundantly, e.g., how many commands overlap two or\n   * three frustums.\n   * </p>\n   *\n   * @memberof Scene.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  debugFrustumStatistics: {\n    get: function () {\n      return this._view.debugFrustumStatistics;\n    },\n  },\n\n  /**\n   * Gets whether or not the scene is optimized for 3D only viewing.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  scene3DOnly: {\n    get: function () {\n      return this._frameState.scene3DOnly;\n    },\n  },\n\n  /**\n   * Gets whether or not the scene has order independent translucency enabled.\n   * Note that this only reflects the original construction option, and there are\n   * other factors that could prevent OIT from functioning on a given system configuration.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  orderIndependentTranslucency: {\n    get: function () {\n      return this._useOIT;\n    },\n  },\n\n  /**\n   * Gets the unique identifier for this scene.\n   * @memberof Scene.prototype\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * Gets or sets the current mode of the scene.\n   * @memberof Scene.prototype\n   * @type {SceneMode}\n   * @default {@link SceneMode.SCENE3D}\n   */\n  mode: {\n    get: function () {\n      return this._mode;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (this.scene3DOnly && value !== SceneMode.SCENE3D) {\n        throw new DeveloperError(\n          \"Only SceneMode.SCENE3D is valid when scene3DOnly is true.\"\n        );\n      }\n      //>>includeEnd('debug');\n      if (value === SceneMode.SCENE2D) {\n        this.morphTo2D(0);\n      } else if (value === SceneMode.SCENE3D) {\n        this.morphTo3D(0);\n      } else if (value === SceneMode.COLUMBUS_VIEW) {\n        this.morphToColumbusView(0);\n        //>>includeStart('debug', pragmas.debug);\n      } else {\n        throw new DeveloperError(\n          \"value must be a valid SceneMode enumeration.\"\n        );\n        //>>includeEnd('debug');\n      }\n      this._mode = value;\n    },\n  },\n\n  /**\n   * Gets the number of frustums used in the last frame.\n   * @memberof Scene.prototype\n   * @type {FrustumCommands[]}\n   *\n   * @private\n   */\n  frustumCommandsList: {\n    get: function () {\n      return this._view.frustumCommandsList;\n    },\n  },\n\n  /**\n   * Gets the number of frustums used in the last frame.\n   * @memberof Scene.prototype\n   * @type {Number}\n   *\n   * @private\n   */\n  numberOfFrustums: {\n    get: function () {\n      return this._view.frustumCommandsList.length;\n    },\n  },\n\n  /**\n   * When <code>true</code>, splits the scene into two viewports with steroscopic views for the left and right eyes.\n   * Used for cardboard and WebVR.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  useWebVR: {\n    get: function () {\n      return this._useWebVR;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (this.camera.frustum instanceof OrthographicFrustum) {\n        throw new DeveloperError(\n          \"VR is unsupported with an orthographic projection.\"\n        );\n      }\n      //>>includeEnd('debug');\n      this._useWebVR = value;\n      if (this._useWebVR) {\n        this._frameState.creditDisplay.container.style.visibility = \"hidden\";\n        this._cameraVR = new Camera(this);\n        if (!defined(this._deviceOrientationCameraController)) {\n          this._deviceOrientationCameraController = new DeviceOrientationCameraController(\n            this\n          );\n        }\n\n        this._aspectRatioVR = this.camera.frustum.aspectRatio;\n      } else {\n        this._frameState.creditDisplay.container.style.visibility = \"visible\";\n        this._cameraVR = undefined;\n        this._deviceOrientationCameraController =\n          this._deviceOrientationCameraController &&\n          !this._deviceOrientationCameraController.isDestroyed() &&\n          this._deviceOrientationCameraController.destroy();\n\n        this.camera.frustum.aspectRatio = this._aspectRatioVR;\n        this.camera.frustum.xOffset = 0.0;\n      }\n    },\n  },\n\n  /**\n   * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.\n   * @memberof Scene.prototype\n   * @type {MapMode2D}\n   * @readonly\n   */\n  mapMode2D: {\n    get: function () {\n      return this._mapMode2D;\n    },\n  },\n\n  /**\n   * Gets or sets the position of the splitter within the viewport.  Valid values are between 0.0 and 1.0.\n   * @memberof Scene.prototype\n   *\n   * @type {Number}\n   */\n  splitPosition: {\n    get: function () {\n      return this._frameState.splitPosition;\n    },\n    set: function (value) {\n      this._frameState.splitPosition = value;\n    },\n  },\n\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied. Setting the disableDepthTestDistance\n   * property of a billboard, label or point will override this value.\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 0.0\n   */\n  minimumDisableDepthTestDistance: {\n    get: function () {\n      return this._minimumDisableDepthTestDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value) || value < 0.0) {\n        throw new DeveloperError(\n          \"minimumDisableDepthTestDistance must be greater than or equal to 0.0.\"\n        );\n      }\n      //>>includeEnd('debug');\n      this._minimumDisableDepthTestDistance = value;\n    },\n  },\n\n  /**\n   * Whether or not to use a logarithmic depth buffer. Enabling this option will allow for less frustums in the multi-frustum,\n   * increasing performance. This property relies on fragmentDepth being supported.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   */\n  logarithmicDepthBuffer: {\n    get: function () {\n      return this._logDepthBuffer;\n    },\n    set: function (value) {\n      value = this._context.fragmentDepth && value;\n      if (this._logDepthBuffer !== value) {\n        this._logDepthBuffer = value;\n        this._logDepthBufferDirty = true;\n      }\n    },\n  },\n\n  /**\n   * The value used for gamma correction. This is only used when rendering with high dynamic range.\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 2.2\n   */\n  gamma: {\n    get: function () {\n      return this._context.uniformState.gamma;\n    },\n    set: function (value) {\n      this._context.uniformState.gamma = value;\n    },\n  },\n\n  /**\n   * Whether or not to use high dynamic range rendering.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  highDynamicRange: {\n    get: function () {\n      return this._hdr;\n    },\n    set: function (value) {\n      const context = this._context;\n      const hdr =\n        value &&\n        context.depthTexture &&\n        (context.colorBufferFloat || context.colorBufferHalfFloat);\n      this._hdrDirty = hdr !== this._hdr;\n      this._hdr = hdr;\n    },\n  },\n\n  /**\n   * Whether or not high dynamic range rendering is supported.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   * @default true\n   */\n  highDynamicRangeSupported: {\n    get: function () {\n      const context = this._context;\n      return (\n        context.depthTexture &&\n        (context.colorBufferFloat || context.colorBufferHalfFloat)\n      );\n    },\n  },\n\n  /**\n   * Whether or not the camera is underneath the globe.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   * @default false\n   */\n  cameraUnderground: {\n    get: function () {\n      return this._cameraUnderground;\n    },\n  },\n\n  /**\n   * The sample rate of multisample antialiasing (values greater than 1 enable MSAA).\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 1\n   */\n  msaaSamples: {\n    get: function () {\n      return this._msaaSamples;\n    },\n    set: function (value) {\n      value = Math.min(value, ContextLimits.maximumSamples);\n      this._msaaSamples = value;\n    },\n  },\n\n  /**\n   * Returns <code>true</code> if the Scene's context supports MSAA.\n   * @memberof Scene.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  msaaSupported: {\n    get: function () {\n      return this._context.msaa;\n    },\n  },\n\n  /**\n   * Ratio between a pixel and a density-independent pixel. Provides a standard unit of\n   * measure for real pixel measurements appropriate to a particular device.\n   *\n   * @memberof Scene.prototype\n   * @type {Number}\n   * @default 1.0\n   * @private\n   */\n  pixelRatio: {\n    get: function () {\n      return this._frameState.pixelRatio;\n    },\n    set: function (value) {\n      this._frameState.pixelRatio = value;\n    },\n  },\n\n  /**\n   * @private\n   */\n  opaqueFrustumNearOffset: {\n    get: function () {\n      return 0.9999;\n    },\n  },\n\n  /**\n   * @private\n   */\n  globeHeight: {\n    get: function () {\n      return this._globeHeight;\n    },\n  },\n});\n\n/**\n * Determines if a compressed texture format is supported.\n * @param {String} format The texture format. May be the name of the format or the WebGL extension name, e.g. s3tc or WEBGL_compressed_texture_s3tc.\n * @return {boolean} Whether or not the format is supported.\n */\nScene.prototype.getCompressedTextureFormatSupported = function (format) {\n  const context = this.context;\n  return (\n    ((format === \"WEBGL_compressed_texture_s3tc\" || format === \"s3tc\") &&\n      context.s3tc) ||\n    ((format === \"WEBGL_compressed_texture_pvrtc\" || format === \"pvrtc\") &&\n      context.pvrtc) ||\n    ((format === \"WEBGL_compressed_texture_etc\" || format === \"etc\") &&\n      context.etc) ||\n    ((format === \"WEBGL_compressed_texture_etc1\" || format === \"etc1\") &&\n      context.etc1) ||\n    ((format === \"WEBGL_compressed_texture_astc\" || format === \"astc\") &&\n      context.astc) ||\n    ((format === \"EXT_texture_compression_bptc\" || format === \"bc7\") &&\n      context.bc7)\n  );\n};\n\nfunction updateDerivedCommands(scene, command, shadowsDirty) {\n  const frameState = scene._frameState;\n  const context = scene._context;\n  const oit = scene._view.oit;\n  const lightShadowMaps = frameState.shadowState.lightShadowMaps;\n  const lightShadowsEnabled = frameState.shadowState.lightShadowsEnabled;\n\n  let derivedCommands = command.derivedCommands;\n\n  if (defined(command.pickId)) {\n    derivedCommands.picking = DerivedCommand.createPickDerivedCommand(\n      scene,\n      command,\n      context,\n      derivedCommands.picking\n    );\n  }\n\n  if (!command.pickOnly) {\n    derivedCommands.depth = DerivedCommand.createDepthOnlyDerivedCommand(\n      scene,\n      command,\n      context,\n      derivedCommands.depth\n    );\n  }\n\n  derivedCommands.originalCommand = command;\n\n  if (scene._hdr) {\n    derivedCommands.hdr = DerivedCommand.createHdrCommand(\n      command,\n      context,\n      derivedCommands.hdr\n    );\n    command = derivedCommands.hdr.command;\n    derivedCommands = command.derivedCommands;\n  }\n\n  if (lightShadowsEnabled && command.receiveShadows) {\n    derivedCommands.shadows = ShadowMap.createReceiveDerivedCommand(\n      lightShadowMaps,\n      command,\n      shadowsDirty,\n      context,\n      derivedCommands.shadows\n    );\n  }\n\n  if (command.pass === Pass.TRANSLUCENT && defined(oit) && oit.isSupported()) {\n    if (lightShadowsEnabled && command.receiveShadows) {\n      derivedCommands.oit = defined(derivedCommands.oit)\n        ? derivedCommands.oit\n        : {};\n      derivedCommands.oit.shadows = oit.createDerivedCommands(\n        derivedCommands.shadows.receiveCommand,\n        context,\n        derivedCommands.oit.shadows\n      );\n    } else {\n      derivedCommands.oit = oit.createDerivedCommands(\n        command,\n        context,\n        derivedCommands.oit\n      );\n    }\n  }\n}\n\n/**\n * @private\n */\nScene.prototype.updateDerivedCommands = function (command) {\n  if (!defined(command.derivedCommands)) {\n    // Is not a DrawCommand\n    return;\n  }\n\n  const frameState = this._frameState;\n  const context = this._context;\n\n  // Update derived commands when any shadow maps become dirty\n  let shadowsDirty = false;\n  const lastDirtyTime = frameState.shadowState.lastDirtyTime;\n  if (command.lastDirtyTime !== lastDirtyTime) {\n    command.lastDirtyTime = lastDirtyTime;\n    command.dirty = true;\n    shadowsDirty = true;\n  }\n\n  const useLogDepth = frameState.useLogDepth;\n  const useHdr = this._hdr;\n  const derivedCommands = command.derivedCommands;\n  const hasLogDepthDerivedCommands = defined(derivedCommands.logDepth);\n  const hasHdrCommands = defined(derivedCommands.hdr);\n  const hasDerivedCommands = defined(derivedCommands.originalCommand);\n  const needsLogDepthDerivedCommands =\n    useLogDepth && !hasLogDepthDerivedCommands;\n  const needsHdrCommands = useHdr && !hasHdrCommands;\n  const needsDerivedCommands = (!useLogDepth || !useHdr) && !hasDerivedCommands;\n  command.dirty =\n    command.dirty ||\n    needsLogDepthDerivedCommands ||\n    needsHdrCommands ||\n    needsDerivedCommands;\n\n  if (command.dirty) {\n    command.dirty = false;\n\n    const shadowMaps = frameState.shadowState.shadowMaps;\n    const shadowsEnabled = frameState.shadowState.shadowsEnabled;\n    if (shadowsEnabled && command.castShadows) {\n      derivedCommands.shadows = ShadowMap.createCastDerivedCommand(\n        shadowMaps,\n        command,\n        shadowsDirty,\n        context,\n        derivedCommands.shadows\n      );\n    }\n\n    if (hasLogDepthDerivedCommands || needsLogDepthDerivedCommands) {\n      derivedCommands.logDepth = DerivedCommand.createLogDepthCommand(\n        command,\n        context,\n        derivedCommands.logDepth\n      );\n      updateDerivedCommands(\n        this,\n        derivedCommands.logDepth.command,\n        shadowsDirty\n      );\n    }\n    if (hasDerivedCommands || needsDerivedCommands) {\n      updateDerivedCommands(this, command, shadowsDirty);\n    }\n  }\n};\n\nconst renderTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.RENDER,\n});\n\nconst preloadTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PRELOAD,\n});\n\nconst preloadFlightTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PRELOAD_FLIGHT,\n});\n\nconst requestRenderModeDeferCheckPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.REQUEST_RENDER_MODE_DEFER_CHECK,\n});\n\nconst scratchOccluderBoundingSphere = new BoundingSphere();\nlet scratchOccluder;\n\nfunction getOccluder(scene) {\n  // TODO: The occluder is the top-level globe. When we add\n  //       support for multiple central bodies, this should be the closest one.\n  const globe = scene.globe;\n  if (\n    scene._mode === SceneMode.SCENE3D &&\n    defined(globe) &&\n    globe.show &&\n    !scene._cameraUnderground &&\n    !scene._globeTranslucencyState.translucent\n  ) {\n    const ellipsoid = globe.ellipsoid;\n    const minimumTerrainHeight = scene.frameState.minimumTerrainHeight;\n    scratchOccluderBoundingSphere.radius =\n      ellipsoid.minimumRadius + minimumTerrainHeight;\n    scratchOccluder = Occluder.fromBoundingSphere(\n      scratchOccluderBoundingSphere,\n      scene.camera.positionWC,\n      scratchOccluder\n    );\n    return scratchOccluder;\n  }\n\n  return undefined;\n}\n\n/**\n * @private\n */\nScene.prototype.clearPasses = function (passes) {\n  passes.render = false;\n  passes.pick = false;\n  passes.depth = false;\n  passes.postProcess = false;\n  passes.offscreen = false;\n};\n\nfunction updateFrameNumber(scene, frameNumber, time) {\n  const frameState = scene._frameState;\n  frameState.frameNumber = frameNumber;\n  frameState.time = JulianDate.clone(time, frameState.time);\n}\n\n/**\n * @private\n */\nScene.prototype.updateFrameState = function () {\n  const camera = this.camera;\n\n  const frameState = this._frameState;\n  frameState.commandList.length = 0;\n  frameState.shadowMaps.length = 0;\n  frameState.brdfLutGenerator = this._brdfLutGenerator;\n  frameState.environmentMap = this.skyBox && this.skyBox._cubeMap;\n  frameState.mode = this._mode;\n  frameState.morphTime = this.morphTime;\n  frameState.mapProjection = this.mapProjection;\n  frameState.camera = camera;\n  frameState.cullingVolume = camera.frustum.computeCullingVolume(\n    camera.positionWC,\n    camera.directionWC,\n    camera.upWC\n  );\n  frameState.occluder = getOccluder(this);\n  frameState.minimumTerrainHeight = 0.0;\n  frameState.minimumDisableDepthTestDistance = this._minimumDisableDepthTestDistance;\n  frameState.invertClassification = this.invertClassification;\n  frameState.useLogDepth =\n    this._logDepthBuffer &&\n    !(\n      this.camera.frustum instanceof OrthographicFrustum ||\n      this.camera.frustum instanceof OrthographicOffCenterFrustum\n    );\n  frameState.light = this.light;\n  frameState.cameraUnderground = this._cameraUnderground;\n  frameState.globeTranslucencyState = this._globeTranslucencyState;\n\n  if (defined(this.globe)) {\n    frameState.terrainExaggeration = this.globe.terrainExaggeration;\n    frameState.terrainExaggerationRelativeHeight = this.globe.terrainExaggerationRelativeHeight;\n  }\n\n  if (\n    defined(this._specularEnvironmentMapAtlas) &&\n    this._specularEnvironmentMapAtlas.ready\n  ) {\n    frameState.specularEnvironmentMaps = this._specularEnvironmentMapAtlas.texture;\n    frameState.specularEnvironmentMapsMaximumLOD = this._specularEnvironmentMapAtlas.maximumMipmapLevel;\n  } else {\n    frameState.specularEnvironmentMaps = undefined;\n    frameState.specularEnvironmentMapsMaximumLOD = undefined;\n  }\n\n  frameState.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients;\n\n  this._actualInvertClassificationColor = Color.clone(\n    this.invertClassificationColor,\n    this._actualInvertClassificationColor\n  );\n  if (!InvertClassification.isTranslucencySupported(this._context)) {\n    this._actualInvertClassificationColor.alpha = 1.0;\n  }\n\n  frameState.invertClassificationColor = this._actualInvertClassificationColor;\n\n  if (defined(this.globe)) {\n    frameState.maximumScreenSpaceError = this.globe.maximumScreenSpaceError;\n  } else {\n    frameState.maximumScreenSpaceError = 2;\n  }\n\n  this.clearPasses(frameState.passes);\n\n  frameState.tilesetPassState = undefined;\n};\n\n/**\n * @private\n */\nScene.prototype.isVisible = function (command, cullingVolume, occluder) {\n  return (\n    defined(command) &&\n    (!defined(command.boundingVolume) ||\n      !command.cull ||\n      (cullingVolume.computeVisibility(command.boundingVolume) !==\n        Intersect.OUTSIDE &&\n        (!defined(occluder) ||\n          !command.occlude ||\n          !command.boundingVolume.isOccluded(occluder))))\n  );\n};\n\nlet transformFrom2D = new Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\ntransformFrom2D = Matrix4.inverseTransformation(\n  transformFrom2D,\n  transformFrom2D\n);\n\nfunction debugShowBoundingVolume(command, scene, passState, debugFramebuffer) {\n  // Debug code to draw bounding volume for command.  Not optimized!\n  // Assumes bounding volume is a bounding sphere or box\n  const frameState = scene._frameState;\n  const context = frameState.context;\n  const boundingVolume = command.boundingVolume;\n\n  if (defined(scene._debugVolume)) {\n    scene._debugVolume.destroy();\n  }\n\n  let geometry;\n\n  let center = Cartesian3.clone(boundingVolume.center);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    center = Matrix4.multiplyByPoint(transformFrom2D, center, center);\n    const projection = frameState.mapProjection;\n    const centerCartographic = projection.unproject(center);\n    center = projection.ellipsoid.cartographicToCartesian(centerCartographic);\n  }\n\n  if (defined(boundingVolume.radius)) {\n    const radius = boundingVolume.radius;\n\n    geometry = GeometryPipeline.toWireframe(\n      EllipsoidGeometry.createGeometry(\n        new EllipsoidGeometry({\n          radii: new Cartesian3(radius, radius, radius),\n          vertexFormat: PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,\n        })\n      )\n    );\n\n    scene._debugVolume = new Primitive({\n      geometryInstances: new GeometryInstance({\n        geometry: geometry,\n        modelMatrix: Matrix4.fromTranslation(center),\n        attributes: {\n          color: new ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 1.0),\n        },\n      }),\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: false,\n      }),\n      asynchronous: false,\n    });\n  } else {\n    const halfAxes = boundingVolume.halfAxes;\n\n    geometry = GeometryPipeline.toWireframe(\n      BoxGeometry.createGeometry(\n        BoxGeometry.fromDimensions({\n          dimensions: new Cartesian3(2.0, 2.0, 2.0),\n          vertexFormat: PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,\n        })\n      )\n    );\n\n    scene._debugVolume = new Primitive({\n      geometryInstances: new GeometryInstance({\n        geometry: geometry,\n        modelMatrix: Matrix4.fromRotationTranslation(\n          halfAxes,\n          center,\n          new Matrix4()\n        ),\n        attributes: {\n          color: new ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 1.0),\n        },\n      }),\n      appearance: new PerInstanceColorAppearance({\n        flat: true,\n        translucent: false,\n      }),\n      asynchronous: false,\n    });\n  }\n\n  const savedCommandList = frameState.commandList;\n  const commandList = (frameState.commandList = []);\n  scene._debugVolume.update(frameState);\n\n  command = commandList[0];\n\n  if (frameState.useLogDepth) {\n    const logDepth = DerivedCommand.createLogDepthCommand(command, context);\n    command = logDepth.command;\n  }\n\n  let framebuffer;\n  if (defined(debugFramebuffer)) {\n    framebuffer = passState.framebuffer;\n    passState.framebuffer = debugFramebuffer;\n  }\n\n  command.execute(context, passState);\n\n  if (defined(framebuffer)) {\n    passState.framebuffer = framebuffer;\n  }\n\n  frameState.commandList = savedCommandList;\n}\n\nfunction executeCommand(command, scene, context, passState, debugFramebuffer) {\n  const frameState = scene._frameState;\n\n  if (defined(scene.debugCommandFilter) && !scene.debugCommandFilter(command)) {\n    return;\n  }\n\n  if (command instanceof ClearCommand) {\n    command.execute(context, passState);\n    return;\n  }\n\n  if (command.debugShowBoundingVolume && defined(command.boundingVolume)) {\n    debugShowBoundingVolume(command, scene, passState, debugFramebuffer);\n  }\n\n  if (frameState.useLogDepth && defined(command.derivedCommands.logDepth)) {\n    command = command.derivedCommands.logDepth.command;\n  }\n\n  const passes = frameState.passes;\n  if (\n    !passes.pick &&\n    !passes.depth &&\n    scene._hdr &&\n    defined(command.derivedCommands) &&\n    defined(command.derivedCommands.hdr)\n  ) {\n    command = command.derivedCommands.hdr.command;\n  }\n\n  if (passes.pick || passes.depth) {\n    if (\n      passes.pick &&\n      !passes.depth &&\n      defined(command.derivedCommands.picking)\n    ) {\n      command = command.derivedCommands.picking.pickCommand;\n      command.execute(context, passState);\n      return;\n    } else if (defined(command.derivedCommands.depth)) {\n      command = command.derivedCommands.depth.depthOnlyCommand;\n      command.execute(context, passState);\n      return;\n    }\n  }\n\n  if (scene.debugShowCommands || scene.debugShowFrustums) {\n    scene._debugInspector.executeDebugShowFrustumsCommand(\n      scene,\n      command,\n      passState\n    );\n    return;\n  }\n\n  if (\n    frameState.shadowState.lightShadowsEnabled &&\n    command.receiveShadows &&\n    defined(command.derivedCommands.shadows)\n  ) {\n    // If the command receives shadows, execute the derived shadows command.\n    // Some commands, such as OIT derived commands, do not have derived shadow commands themselves\n    // and instead shadowing is built-in. In this case execute the command regularly below.\n    command.derivedCommands.shadows.receiveCommand.execute(context, passState);\n  } else {\n    command.execute(context, passState);\n  }\n}\n\nfunction executeIdCommand(command, scene, context, passState) {\n  const frameState = scene._frameState;\n  let derivedCommands = command.derivedCommands;\n  if (!defined(derivedCommands)) {\n    return;\n  }\n\n  if (frameState.useLogDepth && defined(derivedCommands.logDepth)) {\n    command = derivedCommands.logDepth.command;\n  }\n\n  derivedCommands = command.derivedCommands;\n  if (defined(derivedCommands.picking)) {\n    command = derivedCommands.picking.pickCommand;\n    command.execute(context, passState);\n  } else if (defined(derivedCommands.depth)) {\n    command = derivedCommands.depth.depthOnlyCommand;\n    command.execute(context, passState);\n  }\n}\n\nfunction backToFront(a, b, position) {\n  return (\n    b.boundingVolume.distanceSquaredTo(position) -\n    a.boundingVolume.distanceSquaredTo(position)\n  );\n}\n\nfunction frontToBack(a, b, position) {\n  // When distances are equal equal favor sorting b before a. This gives render priority to commands later in the list.\n  return (\n    a.boundingVolume.distanceSquaredTo(position) -\n    b.boundingVolume.distanceSquaredTo(position) +\n    CesiumMath.EPSILON12\n  );\n}\n\nfunction executeTranslucentCommandsBackToFront(\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification\n) {\n  const context = scene.context;\n\n  mergeSort(commands, backToFront, scene.camera.positionWC);\n\n  if (defined(invertClassification)) {\n    executeFunction(\n      invertClassification.unclassifiedCommand,\n      scene,\n      context,\n      passState\n    );\n  }\n\n  const length = commands.length;\n  for (let i = 0; i < length; ++i) {\n    executeFunction(commands[i], scene, context, passState);\n  }\n}\n\nfunction executeTranslucentCommandsFrontToBack(\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification\n) {\n  const context = scene.context;\n\n  mergeSort(commands, frontToBack, scene.camera.positionWC);\n\n  if (defined(invertClassification)) {\n    executeFunction(\n      invertClassification.unclassifiedCommand,\n      scene,\n      context,\n      passState\n    );\n  }\n\n  const length = commands.length;\n  for (let i = 0; i < length; ++i) {\n    executeFunction(commands[i], scene, context, passState);\n  }\n}\n\nconst scratchPerspectiveFrustum = new PerspectiveFrustum();\nconst scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();\nconst scratchOrthographicFrustum = new OrthographicFrustum();\nconst scratchOrthographicOffCenterFrustum = new OrthographicOffCenterFrustum();\n\nfunction executeCommands(scene, passState) {\n  const camera = scene.camera;\n  const context = scene.context;\n  const frameState = scene.frameState;\n  const us = context.uniformState;\n\n  us.updateCamera(camera);\n\n  // Create a working frustum from the original camera frustum.\n  let frustum;\n  if (defined(camera.frustum.fov)) {\n    frustum = camera.frustum.clone(scratchPerspectiveFrustum);\n  } else if (defined(camera.frustum.infiniteProjectionMatrix)) {\n    frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);\n  } else if (defined(camera.frustum.width)) {\n    frustum = camera.frustum.clone(scratchOrthographicFrustum);\n  } else {\n    frustum = camera.frustum.clone(scratchOrthographicOffCenterFrustum);\n  }\n\n  // Ideally, we would render the sky box and atmosphere last for\n  // early-z, but we would have to draw it in each frustum\n  frustum.near = camera.frustum.near;\n  frustum.far = camera.frustum.far;\n  us.updateFrustum(frustum);\n  us.updatePass(Pass.ENVIRONMENT);\n\n  const passes = frameState.passes;\n  const picking = passes.pick;\n  const environmentState = scene._environmentState;\n  const view = scene._view;\n  const renderTranslucentDepthForPick =\n    environmentState.renderTranslucentDepthForPick;\n  const useWebVR = environmentState.useWebVR;\n\n  // Do not render environment primitives during a pick pass since they do not generate picking commands.\n  if (!picking) {\n    const skyBoxCommand = environmentState.skyBoxCommand;\n    if (defined(skyBoxCommand)) {\n      executeCommand(skyBoxCommand, scene, context, passState);\n    }\n\n    if (environmentState.isSkyAtmosphereVisible) {\n      executeCommand(\n        environmentState.skyAtmosphereCommand,\n        scene,\n        context,\n        passState\n      );\n    }\n\n    if (environmentState.isSunVisible) {\n      environmentState.sunDrawCommand.execute(context, passState);\n      if (scene.sunBloom && !useWebVR) {\n        let framebuffer;\n        if (environmentState.useGlobeDepthFramebuffer) {\n          framebuffer = view.globeDepth.framebuffer;\n        } else if (environmentState.usePostProcess) {\n          framebuffer = view.sceneFramebuffer.framebuffer;\n        } else {\n          framebuffer = environmentState.originalFramebuffer;\n        }\n        scene._sunPostProcess.execute(context);\n        scene._sunPostProcess.copy(context, framebuffer);\n        passState.framebuffer = framebuffer;\n      }\n    }\n\n    // Moon can be seen through the atmosphere, since the sun is rendered after the atmosphere.\n    if (environmentState.isMoonVisible) {\n      environmentState.moonCommand.execute(context, passState);\n    }\n  }\n\n  // Determine how translucent surfaces will be handled.\n  let executeTranslucentCommands;\n  if (environmentState.useOIT) {\n    if (!defined(scene._executeOITFunction)) {\n      scene._executeOITFunction = function (\n        scene,\n        executeFunction,\n        passState,\n        commands,\n        invertClassification\n      ) {\n        view.globeDepth.prepareColorTextures(context);\n        view.oit.executeCommands(\n          scene,\n          executeFunction,\n          passState,\n          commands,\n          invertClassification\n        );\n      };\n    }\n    executeTranslucentCommands = scene._executeOITFunction;\n  } else if (passes.render) {\n    executeTranslucentCommands = executeTranslucentCommandsBackToFront;\n  } else {\n    executeTranslucentCommands = executeTranslucentCommandsFrontToBack;\n  }\n\n  const frustumCommandsList = view.frustumCommandsList;\n  const numFrustums = frustumCommandsList.length;\n\n  const clearGlobeDepth = environmentState.clearGlobeDepth;\n  const useDepthPlane = environmentState.useDepthPlane;\n  const globeTranslucencyState = scene._globeTranslucencyState;\n  const globeTranslucent = globeTranslucencyState.translucent;\n  const globeTranslucencyFramebuffer = scene._view.globeTranslucencyFramebuffer;\n  const clearDepth = scene._depthClearCommand;\n  const clearStencil = scene._stencilClearCommand;\n  const clearClassificationStencil = scene._classificationStencilClearCommand;\n  const depthPlane = scene._depthPlane;\n  const usePostProcessSelected = environmentState.usePostProcessSelected;\n\n  const height2D = camera.position.z;\n\n  // Execute commands in each frustum in back to front order\n  let j;\n  for (let i = 0; i < numFrustums; ++i) {\n    const index = numFrustums - i - 1;\n    const frustumCommands = frustumCommandsList[index];\n\n    if (scene.mode === SceneMode.SCENE2D) {\n      // To avoid z-fighting in 2D, move the camera to just before the frustum\n      // and scale the frustum depth to be in [1.0, nearToFarDistance2D].\n      camera.position.z = height2D - frustumCommands.near + 1.0;\n      frustum.far = Math.max(1.0, frustumCommands.far - frustumCommands.near);\n      frustum.near = 1.0;\n      us.update(frameState);\n      us.updateFrustum(frustum);\n    } else {\n      // Avoid tearing artifacts between adjacent frustums in the opaque passes\n      frustum.near =\n        index !== 0\n          ? frustumCommands.near * scene.opaqueFrustumNearOffset\n          : frustumCommands.near;\n      frustum.far = frustumCommands.far;\n      us.updateFrustum(frustum);\n    }\n\n    clearDepth.execute(context, passState);\n\n    if (context.stencilBuffer) {\n      clearStencil.execute(context, passState);\n    }\n\n    us.updatePass(Pass.GLOBE);\n    let commands = frustumCommands.commands[Pass.GLOBE];\n    let length = frustumCommands.indices[Pass.GLOBE];\n\n    if (globeTranslucent) {\n      globeTranslucencyState.executeGlobeCommands(\n        frustumCommands,\n        executeCommand,\n        globeTranslucencyFramebuffer,\n        scene,\n        passState\n      );\n    } else {\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n    }\n\n    const globeDepth = view.globeDepth;\n    if (defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n      globeDepth.executeCopyDepth(context, passState);\n    }\n\n    // Draw terrain classification\n    if (!environmentState.renderTranslucentDepthForPick) {\n      us.updatePass(Pass.TERRAIN_CLASSIFICATION);\n      commands = frustumCommands.commands[Pass.TERRAIN_CLASSIFICATION];\n      length = frustumCommands.indices[Pass.TERRAIN_CLASSIFICATION];\n\n      if (globeTranslucent) {\n        globeTranslucencyState.executeGlobeClassificationCommands(\n          frustumCommands,\n          executeCommand,\n          globeTranslucencyFramebuffer,\n          scene,\n          passState\n        );\n      } else {\n        for (j = 0; j < length; ++j) {\n          executeCommand(commands[j], scene, context, passState);\n        }\n      }\n    }\n\n    if (clearGlobeDepth) {\n      clearDepth.execute(context, passState);\n      if (useDepthPlane) {\n        depthPlane.execute(context, passState);\n      }\n    }\n\n    if (\n      !environmentState.useInvertClassification ||\n      picking ||\n      environmentState.renderTranslucentDepthForPick\n    ) {\n      // Common/fastest path. Draw 3D Tiles and classification normally.\n\n      // Draw 3D Tiles\n      us.updatePass(Pass.CESIUM_3D_TILE);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE];\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n\n      if (length > 0) {\n        if (defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n          // When clearGlobeDepth is true, executeUpdateDepth needs\n          // a globe depth texture with resolved stencil bits.\n          globeDepth.prepareColorTextures(context, clearGlobeDepth);\n          globeDepth.executeUpdateDepth(\n            context,\n            passState,\n            clearGlobeDepth,\n            globeDepth.depthStencilTexture\n          );\n        }\n\n        // Draw classifications. Modifies 3D Tiles color.\n        if (!environmentState.renderTranslucentDepthForPick) {\n          us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION);\n          commands =\n            frustumCommands.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n          length = frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n          for (j = 0; j < length; ++j) {\n            executeCommand(commands[j], scene, context, passState);\n          }\n        }\n      }\n    } else {\n      // When the invert classification color is opaque:\n      //    Main FBO (FBO1):                   Main_Color   + Main_DepthStencil\n      //    Invert classification FBO (FBO2) : Invert_Color + Main_DepthStencil\n      //\n      //    1. Clear FBO2 color to vec4(0.0) for each frustum\n      //    2. Draw 3D Tiles to FBO2\n      //    3. Draw classification to FBO2\n      //    4. Fullscreen pass to FBO1, draw Invert_Color when:\n      //           * Main_DepthStencil has the stencil bit set > 0 (classified)\n      //    5. Fullscreen pass to FBO1, draw Invert_Color * czm_invertClassificationColor when:\n      //           * Main_DepthStencil has stencil bit set to 0 (unclassified) and\n      //           * Invert_Color !== vec4(0.0)\n      //\n      // When the invert classification color is translucent:\n      //    Main FBO (FBO1):                  Main_Color         + Main_DepthStencil\n      //    Invert classification FBO (FBO2): Invert_Color       + Invert_DepthStencil\n      //    IsClassified FBO (FBO3):          IsClassified_Color + Invert_DepthStencil\n      //\n      //    1. Clear FBO2 and FBO3 color to vec4(0.0), stencil to 0, and depth to 1.0\n      //    2. Draw 3D Tiles to FBO2\n      //    3. Draw classification to FBO2\n      //    4. Fullscreen pass to FBO3, draw any color when\n      //           * Invert_DepthStencil has the stencil bit set > 0 (classified)\n      //    5. Fullscreen pass to FBO1, draw Invert_Color when:\n      //           * Invert_Color !== vec4(0.0) and\n      //           * IsClassified_Color !== vec4(0.0)\n      //    6. Fullscreen pass to FBO1, draw Invert_Color * czm_invertClassificationColor when:\n      //           * Invert_Color !== vec4(0.0) and\n      //           * IsClassified_Color === vec4(0.0)\n      //\n      // NOTE: Step six when translucent invert color occurs after the TRANSLUCENT pass\n      //\n      scene._invertClassification.clear(context, passState);\n\n      const opaqueClassificationFramebuffer = passState.framebuffer;\n      passState.framebuffer = scene._invertClassification._fbo.framebuffer;\n\n      // Draw normally\n      us.updatePass(Pass.CESIUM_3D_TILE);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE];\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n\n      if (defined(globeDepth) && environmentState.useGlobeDepthFramebuffer) {\n        scene._invertClassification.prepareTextures(context);\n        globeDepth.executeUpdateDepth(\n          context,\n          passState,\n          clearGlobeDepth,\n          scene._invertClassification._fbo.getDepthStencilTexture()\n        );\n      }\n\n      // Set stencil\n      us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW);\n      commands =\n        frustumCommands.commands[\n          Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW\n        ];\n      length =\n        frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW];\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n\n      passState.framebuffer = opaqueClassificationFramebuffer;\n\n      // Fullscreen pass to copy classified fragments\n      scene._invertClassification.executeClassified(context, passState);\n      if (frameState.invertClassificationColor.alpha === 1.0) {\n        // Fullscreen pass to copy unclassified fragments when alpha == 1.0\n        scene._invertClassification.executeUnclassified(context, passState);\n      }\n\n      // Clear stencil set by the classification for the next classification pass\n      if (length > 0 && context.stencilBuffer) {\n        clearClassificationStencil.execute(context, passState);\n      }\n\n      // Draw style over classification.\n      us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION);\n      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n      length = frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n      for (j = 0; j < length; ++j) {\n        executeCommand(commands[j], scene, context, passState);\n      }\n    }\n\n    if (length > 0 && context.stencilBuffer) {\n      clearStencil.execute(context, passState);\n    }\n\n    us.updatePass(Pass.OPAQUE);\n    commands = frustumCommands.commands[Pass.OPAQUE];\n    length = frustumCommands.indices[Pass.OPAQUE];\n    for (j = 0; j < length; ++j) {\n      executeCommand(commands[j], scene, context, passState);\n    }\n\n    if (index !== 0 && scene.mode !== SceneMode.SCENE2D) {\n      // Do not overlap frustums in the translucent pass to avoid blending artifacts\n      frustum.near = frustumCommands.near;\n      us.updateFrustum(frustum);\n    }\n\n    let invertClassification;\n    if (\n      !picking &&\n      environmentState.useInvertClassification &&\n      frameState.invertClassificationColor.alpha < 1.0\n    ) {\n      // Fullscreen pass to copy unclassified fragments when alpha < 1.0.\n      // Not executed when undefined.\n      invertClassification = scene._invertClassification;\n    }\n\n    us.updatePass(Pass.TRANSLUCENT);\n    commands = frustumCommands.commands[Pass.TRANSLUCENT];\n    commands.length = frustumCommands.indices[Pass.TRANSLUCENT];\n    executeTranslucentCommands(\n      scene,\n      executeCommand,\n      passState,\n      commands,\n      invertClassification\n    );\n\n    // Classification for translucent 3D Tiles\n    const has3DTilesClassificationCommands =\n      frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION] > 0;\n    if (\n      has3DTilesClassificationCommands &&\n      view.translucentTileClassification.isSupported()\n    ) {\n      view.translucentTileClassification.executeTranslucentCommands(\n        scene,\n        executeCommand,\n        passState,\n        commands,\n        globeDepth.depthStencilTexture\n      );\n      view.translucentTileClassification.executeClassificationCommands(\n        scene,\n        executeCommand,\n        passState,\n        frustumCommands\n      );\n    }\n\n    if (\n      context.depthTexture &&\n      scene.useDepthPicking &&\n      (environmentState.useGlobeDepthFramebuffer ||\n        renderTranslucentDepthForPick)\n    ) {\n      // PERFORMANCE_IDEA: Use MRT to avoid the extra copy.\n      const depthStencilTexture = globeDepth.depthStencilTexture;\n      const pickDepth = scene._picking.getPickDepth(scene, index);\n      pickDepth.update(context, depthStencilTexture);\n      pickDepth.executeCopyDepth(context, passState);\n    }\n\n    if (picking || !usePostProcessSelected) {\n      continue;\n    }\n\n    const originalFramebuffer = passState.framebuffer;\n    passState.framebuffer = view.sceneFramebuffer.getIdFramebuffer();\n\n    // reset frustum\n    frustum.near =\n      index !== 0\n        ? frustumCommands.near * scene.opaqueFrustumNearOffset\n        : frustumCommands.near;\n    frustum.far = frustumCommands.far;\n    us.updateFrustum(frustum);\n\n    us.updatePass(Pass.GLOBE);\n    commands = frustumCommands.commands[Pass.GLOBE];\n    length = frustumCommands.indices[Pass.GLOBE];\n\n    if (globeTranslucent) {\n      globeTranslucencyState.executeGlobeCommands(\n        frustumCommands,\n        executeIdCommand,\n        globeTranslucencyFramebuffer,\n        scene,\n        passState\n      );\n    } else {\n      for (j = 0; j < length; ++j) {\n        executeIdCommand(commands[j], scene, context, passState);\n      }\n    }\n\n    if (clearGlobeDepth) {\n      clearDepth.framebuffer = passState.framebuffer;\n      clearDepth.execute(context, passState);\n      clearDepth.framebuffer = undefined;\n    }\n\n    if (clearGlobeDepth && useDepthPlane) {\n      depthPlane.execute(context, passState);\n    }\n\n    us.updatePass(Pass.CESIUM_3D_TILE);\n    commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];\n    length = frustumCommands.indices[Pass.CESIUM_3D_TILE];\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    us.updatePass(Pass.OPAQUE);\n    commands = frustumCommands.commands[Pass.OPAQUE];\n    length = frustumCommands.indices[Pass.OPAQUE];\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    us.updatePass(Pass.TRANSLUCENT);\n    commands = frustumCommands.commands[Pass.TRANSLUCENT];\n    length = frustumCommands.indices[Pass.TRANSLUCENT];\n    for (j = 0; j < length; ++j) {\n      executeIdCommand(commands[j], scene, context, passState);\n    }\n\n    passState.framebuffer = originalFramebuffer;\n  }\n}\n\nfunction executeComputeCommands(scene) {\n  const us = scene.context.uniformState;\n  us.updatePass(Pass.COMPUTE);\n\n  const sunComputeCommand = scene._environmentState.sunComputeCommand;\n  if (defined(sunComputeCommand)) {\n    sunComputeCommand.execute(scene._computeEngine);\n  }\n\n  const commandList = scene._computeCommandList;\n  const length = commandList.length;\n  for (let i = 0; i < length; ++i) {\n    commandList[i].execute(scene._computeEngine);\n  }\n}\n\nfunction executeOverlayCommands(scene, passState) {\n  const us = scene.context.uniformState;\n  us.updatePass(Pass.OVERLAY);\n\n  const context = scene.context;\n  const commandList = scene._overlayCommandList;\n  const length = commandList.length;\n  for (let i = 0; i < length; ++i) {\n    commandList[i].execute(context, passState);\n  }\n}\n\nfunction insertShadowCastCommands(scene, commandList, shadowMap) {\n  const shadowVolume = shadowMap.shadowMapCullingVolume;\n  const isPointLight = shadowMap.isPointLight;\n  const passes = shadowMap.passes;\n  const numberOfPasses = passes.length;\n\n  const length = commandList.length;\n  for (let i = 0; i < length; ++i) {\n    const command = commandList[i];\n    scene.updateDerivedCommands(command);\n\n    if (\n      command.castShadows &&\n      (command.pass === Pass.GLOBE ||\n        command.pass === Pass.CESIUM_3D_TILE ||\n        command.pass === Pass.OPAQUE ||\n        command.pass === Pass.TRANSLUCENT)\n    ) {\n      if (scene.isVisible(command, shadowVolume)) {\n        if (isPointLight) {\n          for (let k = 0; k < numberOfPasses; ++k) {\n            passes[k].commandList.push(command);\n          }\n        } else if (numberOfPasses === 1) {\n          passes[0].commandList.push(command);\n        } else {\n          let wasVisible = false;\n          // Loop over cascades from largest to smallest\n          for (let j = numberOfPasses - 1; j >= 0; --j) {\n            const cascadeVolume = passes[j].cullingVolume;\n            if (scene.isVisible(command, cascadeVolume)) {\n              passes[j].commandList.push(command);\n              wasVisible = true;\n            } else if (wasVisible) {\n              // If it was visible in the previous cascade but now isn't\n              // then there is no need to check any more cascades\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction executeShadowMapCastCommands(scene) {\n  const frameState = scene.frameState;\n  const shadowMaps = frameState.shadowState.shadowMaps;\n  const shadowMapLength = shadowMaps.length;\n\n  if (!frameState.shadowState.shadowsEnabled) {\n    return;\n  }\n\n  const context = scene.context;\n  const uniformState = context.uniformState;\n\n  for (let i = 0; i < shadowMapLength; ++i) {\n    const shadowMap = shadowMaps[i];\n    if (shadowMap.outOfView) {\n      continue;\n    }\n\n    // Reset the command lists\n    const passes = shadowMap.passes;\n    const numberOfPasses = passes.length;\n    for (let j = 0; j < numberOfPasses; ++j) {\n      passes[j].commandList.length = 0;\n    }\n\n    // Insert the primitive/model commands into the command lists\n    const sceneCommands = scene.frameState.commandList;\n    insertShadowCastCommands(scene, sceneCommands, shadowMap);\n\n    for (let j = 0; j < numberOfPasses; ++j) {\n      const pass = shadowMap.passes[j];\n      uniformState.updateCamera(pass.camera);\n      shadowMap.updatePass(context, j);\n      const numberOfCommands = pass.commandList.length;\n      for (let k = 0; k < numberOfCommands; ++k) {\n        const command = pass.commandList[k];\n        // Set the correct pass before rendering into the shadow map because some shaders\n        // conditionally render based on whether the pass is translucent or opaque.\n        uniformState.updatePass(command.pass);\n        executeCommand(\n          command.derivedCommands.shadows.castCommands[i],\n          scene,\n          context,\n          pass.passState\n        );\n      }\n    }\n  }\n}\n\nconst scratchEyeTranslation = new Cartesian3();\n\n/**\n * @private\n */\nScene.prototype.updateAndExecuteCommands = function (\n  passState,\n  backgroundColor\n) {\n  const frameState = this._frameState;\n  const mode = frameState.mode;\n  const useWebVR = this._environmentState.useWebVR;\n\n  if (useWebVR) {\n    executeWebVRCommands(this, passState, backgroundColor);\n  } else if (\n    mode !== SceneMode.SCENE2D ||\n    this._mapMode2D === MapMode2D.ROTATE\n  ) {\n    executeCommandsInViewport(true, this, passState, backgroundColor);\n  } else {\n    updateAndClearFramebuffers(this, passState, backgroundColor);\n    execute2DViewportCommands(this, passState);\n  }\n};\n\nfunction executeWebVRCommands(scene, passState, backgroundColor) {\n  const view = scene._view;\n  const camera = view.camera;\n  const environmentState = scene._environmentState;\n  const renderTranslucentDepthForPick =\n    environmentState.renderTranslucentDepthForPick;\n\n  updateAndClearFramebuffers(scene, passState, backgroundColor);\n\n  updateAndRenderPrimitives(scene);\n\n  view.createPotentiallyVisibleSet(scene);\n\n  executeComputeCommands(scene);\n\n  if (!renderTranslucentDepthForPick) {\n    executeShadowMapCastCommands(scene);\n  }\n\n  // Based on Calculating Stereo pairs by Paul Bourke\n  // http://paulbourke.net/stereographics/stereorender/\n  const viewport = passState.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = viewport.width * 0.5;\n\n  const savedCamera = Camera.clone(camera, scene._cameraVR);\n  savedCamera.frustum = camera.frustum;\n\n  const near = camera.frustum.near;\n  const fo = near * defaultValue(scene.focalLength, 5.0);\n  const eyeSeparation = defaultValue(scene.eyeSeparation, fo / 30.0);\n  const eyeTranslation = Cartesian3.multiplyByScalar(\n    savedCamera.right,\n    eyeSeparation * 0.5,\n    scratchEyeTranslation\n  );\n\n  camera.frustum.aspectRatio = viewport.width / viewport.height;\n\n  const offset = (0.5 * eyeSeparation * near) / fo;\n\n  Cartesian3.add(savedCamera.position, eyeTranslation, camera.position);\n  camera.frustum.xOffset = offset;\n\n  executeCommands(scene, passState);\n\n  viewport.x = viewport.width;\n\n  Cartesian3.subtract(savedCamera.position, eyeTranslation, camera.position);\n  camera.frustum.xOffset = -offset;\n\n  executeCommands(scene, passState);\n\n  Camera.clone(savedCamera, camera);\n}\n\nconst scratch2DViewportCartographic = new Cartographic(\n  Math.PI,\n  CesiumMath.PI_OVER_TWO\n);\nconst scratch2DViewportMaxCoord = new Cartesian3();\nconst scratch2DViewportSavedPosition = new Cartesian3();\nconst scratch2DViewportTransform = new Matrix4();\nconst scratch2DViewportCameraTransform = new Matrix4();\nconst scratch2DViewportEyePoint = new Cartesian3();\nconst scratch2DViewportWindowCoords = new Cartesian3();\nconst scratch2DViewport = new BoundingRectangle();\n\nfunction execute2DViewportCommands(scene, passState) {\n  const context = scene.context;\n  const frameState = scene.frameState;\n  const camera = scene.camera;\n\n  const originalViewport = passState.viewport;\n  const viewport = BoundingRectangle.clone(originalViewport, scratch2DViewport);\n  passState.viewport = viewport;\n\n  const maxCartographic = scratch2DViewportCartographic;\n  const maxCoord = scratch2DViewportMaxCoord;\n\n  const projection = scene.mapProjection;\n  projection.project(maxCartographic, maxCoord);\n\n  const position = Cartesian3.clone(\n    camera.position,\n    scratch2DViewportSavedPosition\n  );\n  const transform = Matrix4.clone(\n    camera.transform,\n    scratch2DViewportCameraTransform\n  );\n  const frustum = camera.frustum.clone();\n\n  camera._setTransform(Matrix4.IDENTITY);\n\n  const viewportTransformation = Matrix4.computeViewportTransformation(\n    viewport,\n    0.0,\n    1.0,\n    scratch2DViewportTransform\n  );\n  const projectionMatrix = camera.frustum.projectionMatrix;\n\n  const x = camera.positionWC.y;\n  const eyePoint = Cartesian3.fromElements(\n    CesiumMath.sign(x) * maxCoord.x - x,\n    0.0,\n    -camera.positionWC.x,\n    scratch2DViewportEyePoint\n  );\n  const windowCoordinates = Transforms.pointToGLWindowCoordinates(\n    projectionMatrix,\n    viewportTransformation,\n    eyePoint,\n    scratch2DViewportWindowCoords\n  );\n\n  windowCoordinates.x = Math.floor(windowCoordinates.x);\n\n  const viewportX = viewport.x;\n  const viewportWidth = viewport.width;\n\n  if (\n    x === 0.0 ||\n    windowCoordinates.x <= viewportX ||\n    windowCoordinates.x >= viewportX + viewportWidth\n  ) {\n    executeCommandsInViewport(true, scene, passState);\n  } else if (\n    Math.abs(viewportX + viewportWidth * 0.5 - windowCoordinates.x) < 1.0\n  ) {\n    viewport.width = windowCoordinates.x - viewport.x;\n\n    camera.position.x *= CesiumMath.sign(camera.position.x);\n\n    camera.frustum.right = 0.0;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(true, scene, passState);\n\n    viewport.x = windowCoordinates.x;\n\n    camera.position.x = -camera.position.x;\n\n    camera.frustum.right = -camera.frustum.left;\n    camera.frustum.left = 0.0;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(false, scene, passState);\n  } else if (windowCoordinates.x > viewportX + viewportWidth * 0.5) {\n    viewport.width = windowCoordinates.x - viewportX;\n\n    const right = camera.frustum.right;\n    camera.frustum.right = maxCoord.x - x;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(true, scene, passState);\n\n    viewport.x = windowCoordinates.x;\n    viewport.width = viewportX + viewportWidth - windowCoordinates.x;\n\n    camera.position.x = -camera.position.x;\n\n    camera.frustum.left = -camera.frustum.right;\n    camera.frustum.right = right - camera.frustum.right * 2.0;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(false, scene, passState);\n  } else {\n    viewport.x = windowCoordinates.x;\n    viewport.width = viewportX + viewportWidth - windowCoordinates.x;\n\n    const left = camera.frustum.left;\n    camera.frustum.left = -maxCoord.x - x;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(true, scene, passState);\n\n    viewport.x = viewportX;\n    viewport.width = windowCoordinates.x - viewportX;\n\n    camera.position.x = -camera.position.x;\n\n    camera.frustum.right = -camera.frustum.left;\n    camera.frustum.left = left - camera.frustum.left * 2.0;\n\n    frameState.cullingVolume = camera.frustum.computeCullingVolume(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC\n    );\n    context.uniformState.update(frameState);\n\n    executeCommandsInViewport(false, scene, passState);\n  }\n\n  camera._setTransform(transform);\n  Cartesian3.clone(position, camera.position);\n  camera.frustum = frustum.clone();\n  passState.viewport = originalViewport;\n}\n\nfunction executeCommandsInViewport(\n  firstViewport,\n  scene,\n  passState,\n  backgroundColor\n) {\n  const environmentState = scene._environmentState;\n  const view = scene._view;\n  const renderTranslucentDepthForPick =\n    environmentState.renderTranslucentDepthForPick;\n\n  if (!firstViewport) {\n    scene.frameState.commandList.length = 0;\n  }\n\n  updateAndRenderPrimitives(scene);\n\n  view.createPotentiallyVisibleSet(scene);\n\n  if (firstViewport) {\n    if (defined(backgroundColor)) {\n      updateAndClearFramebuffers(scene, passState, backgroundColor);\n    }\n    executeComputeCommands(scene);\n    if (!renderTranslucentDepthForPick) {\n      executeShadowMapCastCommands(scene);\n    }\n  }\n\n  executeCommands(scene, passState);\n}\n\nconst scratchCullingVolume = new CullingVolume();\n\n/**\n * @private\n */\nScene.prototype.updateEnvironment = function () {\n  const frameState = this._frameState;\n  const view = this._view;\n\n  // Update celestial and terrestrial environment effects.\n  const environmentState = this._environmentState;\n  const renderPass = frameState.passes.render;\n  const offscreenPass = frameState.passes.offscreen;\n  const skyAtmosphere = this.skyAtmosphere;\n  const globe = this.globe;\n  const globeTranslucencyState = this._globeTranslucencyState;\n\n  if (\n    !renderPass ||\n    (this._mode !== SceneMode.SCENE2D &&\n      view.camera.frustum instanceof OrthographicFrustum) ||\n    !globeTranslucencyState.environmentVisible\n  ) {\n    environmentState.skyAtmosphereCommand = undefined;\n    environmentState.skyBoxCommand = undefined;\n    environmentState.sunDrawCommand = undefined;\n    environmentState.sunComputeCommand = undefined;\n    environmentState.moonCommand = undefined;\n  } else {\n    if (defined(skyAtmosphere)) {\n      if (defined(globe)) {\n        skyAtmosphere.setDynamicAtmosphereColor(\n          globe.enableLighting && globe.dynamicAtmosphereLighting,\n          globe.dynamicAtmosphereLightingFromSun\n        );\n        environmentState.isReadyForAtmosphere =\n          environmentState.isReadyForAtmosphere ||\n          globe._surface._tilesToRender.length > 0;\n      }\n      environmentState.skyAtmosphereCommand = skyAtmosphere.update(\n        frameState,\n        globe\n      );\n      if (defined(environmentState.skyAtmosphereCommand)) {\n        this.updateDerivedCommands(environmentState.skyAtmosphereCommand);\n      }\n    } else {\n      environmentState.skyAtmosphereCommand = undefined;\n    }\n\n    environmentState.skyBoxCommand = defined(this.skyBox)\n      ? this.skyBox.update(frameState, this._hdr)\n      : undefined;\n    const sunCommands = defined(this.sun)\n      ? this.sun.update(frameState, view.passState, this._hdr)\n      : undefined;\n    environmentState.sunDrawCommand = defined(sunCommands)\n      ? sunCommands.drawCommand\n      : undefined;\n    environmentState.sunComputeCommand = defined(sunCommands)\n      ? sunCommands.computeCommand\n      : undefined;\n    environmentState.moonCommand = defined(this.moon)\n      ? this.moon.update(frameState)\n      : undefined;\n  }\n\n  const clearGlobeDepth = (environmentState.clearGlobeDepth =\n    defined(globe) &&\n    globe.show &&\n    (!globe.depthTestAgainstTerrain || this.mode === SceneMode.SCENE2D));\n  const useDepthPlane = (environmentState.useDepthPlane =\n    clearGlobeDepth &&\n    this.mode === SceneMode.SCENE3D &&\n    globeTranslucencyState.useDepthPlane);\n  if (useDepthPlane) {\n    // Update the depth plane that is rendered in 3D when the primitives are\n    // not depth tested against terrain so primitives on the backface\n    // of the globe are not picked.\n    this._depthPlane.update(frameState);\n  }\n\n  environmentState.renderTranslucentDepthForPick = false;\n  environmentState.useWebVR =\n    this._useWebVR && this.mode !== SceneMode.SCENE2D && !offscreenPass;\n\n  const occluder =\n    frameState.mode === SceneMode.SCENE3D &&\n    !globeTranslucencyState.sunVisibleThroughGlobe\n      ? frameState.occluder\n      : undefined;\n  let cullingVolume = frameState.cullingVolume;\n\n  // get user culling volume minus the far plane.\n  const planes = scratchCullingVolume.planes;\n  for (let k = 0; k < 5; ++k) {\n    planes[k] = cullingVolume.planes[k];\n  }\n  cullingVolume = scratchCullingVolume;\n\n  // Determine visibility of celestial and terrestrial environment effects.\n  environmentState.isSkyAtmosphereVisible =\n    defined(environmentState.skyAtmosphereCommand) &&\n    environmentState.isReadyForAtmosphere;\n  environmentState.isSunVisible = this.isVisible(\n    environmentState.sunDrawCommand,\n    cullingVolume,\n    occluder\n  );\n  environmentState.isMoonVisible = this.isVisible(\n    environmentState.moonCommand,\n    cullingVolume,\n    occluder\n  );\n\n  const envMaps = this.specularEnvironmentMaps;\n  let envMapAtlas = this._specularEnvironmentMapAtlas;\n  if (\n    defined(envMaps) &&\n    (!defined(envMapAtlas) || envMapAtlas.url !== envMaps)\n  ) {\n    envMapAtlas = envMapAtlas && envMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = new OctahedralProjectedCubeMap(envMaps);\n  } else if (!defined(envMaps) && defined(envMapAtlas)) {\n    envMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = undefined;\n  }\n\n  if (defined(this._specularEnvironmentMapAtlas)) {\n    this._specularEnvironmentMapAtlas.update(frameState);\n  }\n};\n\nfunction updateDebugFrustumPlanes(scene) {\n  const frameState = scene._frameState;\n  if (scene.debugShowFrustumPlanes !== scene._debugShowFrustumPlanes) {\n    if (scene.debugShowFrustumPlanes) {\n      scene._debugFrustumPlanes = new DebugCameraPrimitive({\n        camera: scene.camera,\n        updateOnChange: false,\n        frustumSplits: frameState.frustumSplits,\n      });\n    } else {\n      scene._debugFrustumPlanes =\n        scene._debugFrustumPlanes && scene._debugFrustumPlanes.destroy();\n    }\n    scene._debugShowFrustumPlanes = scene.debugShowFrustumPlanes;\n  }\n\n  if (defined(scene._debugFrustumPlanes)) {\n    scene._debugFrustumPlanes.update(frameState);\n  }\n}\n\nfunction updateShadowMaps(scene) {\n  const frameState = scene._frameState;\n  const shadowMaps = frameState.shadowMaps;\n  const length = shadowMaps.length;\n\n  const shadowsEnabled =\n    length > 0 && !frameState.passes.pick && scene.mode === SceneMode.SCENE3D;\n  if (shadowsEnabled !== frameState.shadowState.shadowsEnabled) {\n    // Update derived commands when shadowsEnabled changes\n    ++frameState.shadowState.lastDirtyTime;\n    frameState.shadowState.shadowsEnabled = shadowsEnabled;\n  }\n\n  frameState.shadowState.lightShadowsEnabled = false;\n\n  if (!shadowsEnabled) {\n    return;\n  }\n\n  // Check if the shadow maps are different than the shadow maps last frame.\n  // If so, the derived commands need to be updated.\n  for (let j = 0; j < length; ++j) {\n    if (shadowMaps[j] !== frameState.shadowState.shadowMaps[j]) {\n      ++frameState.shadowState.lastDirtyTime;\n      break;\n    }\n  }\n\n  frameState.shadowState.shadowMaps.length = 0;\n  frameState.shadowState.lightShadowMaps.length = 0;\n\n  for (let i = 0; i < length; ++i) {\n    const shadowMap = shadowMaps[i];\n    shadowMap.update(frameState);\n\n    frameState.shadowState.shadowMaps.push(shadowMap);\n\n    if (shadowMap.fromLightSource) {\n      frameState.shadowState.lightShadowMaps.push(shadowMap);\n      frameState.shadowState.lightShadowsEnabled = true;\n    }\n\n    if (shadowMap.dirty) {\n      ++frameState.shadowState.lastDirtyTime;\n      shadowMap.dirty = false;\n    }\n  }\n}\n\nfunction updateAndRenderPrimitives(scene) {\n  const frameState = scene._frameState;\n\n  scene._groundPrimitives.update(frameState);\n  scene._primitives.update(frameState);\n\n  updateDebugFrustumPlanes(scene);\n  updateShadowMaps(scene);\n\n  if (scene._globe) {\n    scene._globe.render(frameState);\n  }\n}\n\nfunction updateAndClearFramebuffers(scene, passState, clearColor) {\n  const context = scene._context;\n  const frameState = scene._frameState;\n  const environmentState = scene._environmentState;\n  const view = scene._view;\n\n  const passes = scene._frameState.passes;\n  const picking = passes.pick;\n  if (defined(view.globeDepth)) {\n    view.globeDepth.picking = picking;\n  }\n  const useWebVR = environmentState.useWebVR;\n\n  // Preserve the reference to the original framebuffer.\n  environmentState.originalFramebuffer = passState.framebuffer;\n\n  // Manage sun bloom post-processing effect.\n  if (defined(scene.sun) && scene.sunBloom !== scene._sunBloom) {\n    if (scene.sunBloom && !useWebVR) {\n      scene._sunPostProcess = new SunPostProcess();\n    } else if (defined(scene._sunPostProcess)) {\n      scene._sunPostProcess = scene._sunPostProcess.destroy();\n    }\n\n    scene._sunBloom = scene.sunBloom;\n  } else if (!defined(scene.sun) && defined(scene._sunPostProcess)) {\n    scene._sunPostProcess = scene._sunPostProcess.destroy();\n    scene._sunBloom = false;\n  }\n\n  // Clear the pass state framebuffer.\n  const clear = scene._clearColorCommand;\n  Color.clone(clearColor, clear.color);\n  clear.execute(context, passState);\n\n  // Update globe depth rendering based on the current context and clear the globe depth framebuffer.\n  // Globe depth is copied for the pick pass to support picking batched geometries in GroundPrimitives.\n  const useGlobeDepthFramebuffer = (environmentState.useGlobeDepthFramebuffer = defined(\n    view.globeDepth\n  ));\n  if (useGlobeDepthFramebuffer) {\n    view.globeDepth.update(\n      context,\n      passState,\n      view.viewport,\n      scene.msaaSamples,\n      scene._hdr,\n      environmentState.clearGlobeDepth\n    );\n    view.globeDepth.clear(context, passState, clearColor);\n  }\n\n  // If supported, configure OIT to use the globe depth framebuffer and clear the OIT framebuffer.\n  const oit = view.oit;\n  const useOIT = (environmentState.useOIT =\n    !picking && defined(oit) && oit.isSupported());\n  if (useOIT) {\n    oit.update(\n      context,\n      passState,\n      view.globeDepth.colorFramebufferManager,\n      scene._hdr,\n      scene.msaaSamples\n    );\n    oit.clear(context, passState, clearColor);\n    environmentState.useOIT = oit.isSupported();\n  }\n\n  const postProcess = scene.postProcessStages;\n  let usePostProcess = (environmentState.usePostProcess =\n    !picking &&\n    (scene._hdr ||\n      postProcess.length > 0 ||\n      postProcess.ambientOcclusion.enabled ||\n      postProcess.fxaa.enabled ||\n      postProcess.bloom.enabled));\n  environmentState.usePostProcessSelected = false;\n  if (usePostProcess) {\n    view.sceneFramebuffer.update(\n      context,\n      view.viewport,\n      scene._hdr,\n      scene.msaaSamples\n    );\n    view.sceneFramebuffer.clear(context, passState, clearColor);\n\n    postProcess.update(context, frameState.useLogDepth, scene._hdr);\n    postProcess.clear(context);\n\n    usePostProcess = environmentState.usePostProcess = postProcess.ready;\n    environmentState.usePostProcessSelected =\n      usePostProcess && postProcess.hasSelected;\n  }\n\n  if (environmentState.isSunVisible && scene.sunBloom && !useWebVR) {\n    passState.framebuffer = scene._sunPostProcess.update(passState);\n    scene._sunPostProcess.clear(context, passState, clearColor);\n  } else if (useGlobeDepthFramebuffer) {\n    passState.framebuffer = view.globeDepth.framebuffer;\n  } else if (usePostProcess) {\n    passState.framebuffer = view.sceneFramebuffer.framebuffer;\n  }\n\n  if (defined(passState.framebuffer)) {\n    clear.execute(context, passState);\n  }\n\n  const useInvertClassification = (environmentState.useInvertClassification =\n    !picking && defined(passState.framebuffer) && scene.invertClassification);\n  if (useInvertClassification) {\n    let depthFramebuffer;\n    if (scene.frameState.invertClassificationColor.alpha === 1.0) {\n      if (environmentState.useGlobeDepthFramebuffer) {\n        depthFramebuffer = view.globeDepth.framebuffer;\n      }\n    }\n\n    if (defined(depthFramebuffer) || context.depthTexture) {\n      scene._invertClassification.previousFramebuffer = depthFramebuffer;\n      scene._invertClassification.update(\n        context,\n        scene.msaaSamples,\n        view.globeDepth.colorFramebufferManager\n      );\n      scene._invertClassification.clear(context, passState);\n\n      if (scene.frameState.invertClassificationColor.alpha < 1.0 && useOIT) {\n        const command = scene._invertClassification.unclassifiedCommand;\n        const derivedCommands = command.derivedCommands;\n        derivedCommands.oit = oit.createDerivedCommands(\n          command,\n          context,\n          derivedCommands.oit\n        );\n      }\n    } else {\n      environmentState.useInvertClassification = false;\n    }\n  }\n\n  if (scene._globeTranslucencyState.translucent) {\n    view.globeTranslucencyFramebuffer.updateAndClear(\n      scene._hdr,\n      view.viewport,\n      context,\n      passState\n    );\n  }\n}\n\n/**\n * @private\n */\nScene.prototype.resolveFramebuffers = function (passState) {\n  const context = this._context;\n  const environmentState = this._environmentState;\n  const view = this._view;\n  const globeDepth = view.globeDepth;\n  if (defined(globeDepth)) {\n    globeDepth.prepareColorTextures(context);\n  }\n\n  const useOIT = environmentState.useOIT;\n  const useGlobeDepthFramebuffer = environmentState.useGlobeDepthFramebuffer;\n  const usePostProcess = environmentState.usePostProcess;\n\n  const defaultFramebuffer = environmentState.originalFramebuffer;\n  const globeFramebuffer = useGlobeDepthFramebuffer\n    ? globeDepth.colorFramebufferManager\n    : undefined;\n  const sceneFramebuffer = view.sceneFramebuffer._colorFramebuffer;\n  const idFramebuffer = view.sceneFramebuffer.idFramebuffer;\n\n  if (useOIT) {\n    passState.framebuffer = usePostProcess\n      ? sceneFramebuffer.framebuffer\n      : defaultFramebuffer;\n    view.oit.execute(context, passState);\n  }\n\n  const translucentTileClassification = view.translucentTileClassification;\n  if (\n    translucentTileClassification.hasTranslucentDepth &&\n    translucentTileClassification.isSupported()\n  ) {\n    translucentTileClassification.execute(this, passState);\n  }\n\n  if (usePostProcess) {\n    view.sceneFramebuffer.prepareColorTextures(context);\n    let inputFramebuffer = sceneFramebuffer;\n    if (useGlobeDepthFramebuffer && !useOIT) {\n      inputFramebuffer = globeFramebuffer;\n    }\n\n    const postProcess = this.postProcessStages;\n    const colorTexture = inputFramebuffer.getColorTexture(0);\n    const idTexture = idFramebuffer.getColorTexture(0);\n    const depthTexture = defaultValue(\n      globeFramebuffer,\n      sceneFramebuffer\n    ).getDepthStencilTexture();\n    postProcess.execute(context, colorTexture, depthTexture, idTexture);\n    postProcess.copy(context, defaultFramebuffer);\n  }\n\n  if (!useOIT && !usePostProcess && useGlobeDepthFramebuffer) {\n    passState.framebuffer = defaultFramebuffer;\n    globeDepth.executeCopyColor(context, passState);\n  }\n};\n\nfunction callAfterRenderFunctions(scene) {\n  // Functions are queued up during primitive update and executed here in case\n  // the function modifies scene state that should remain constant over the frame.\n  const functions = scene._frameState.afterRender;\n  for (let i = 0, length = functions.length; i < length; ++i) {\n    functions[i]();\n    scene.requestRender();\n  }\n\n  functions.length = 0;\n}\n\nfunction getGlobeHeight(scene) {\n  const globe = scene._globe;\n  const camera = scene.camera;\n  const cartographic = camera.positionCartographic;\n  if (defined(globe) && globe.show && defined(cartographic)) {\n    return globe.getHeight(cartographic);\n  }\n  return undefined;\n}\n\nfunction isCameraUnderground(scene) {\n  const camera = scene.camera;\n  const mode = scene._mode;\n  const globe = scene.globe;\n  const cameraController = scene._screenSpaceCameraController;\n  const cartographic = camera.positionCartographic;\n\n  if (!defined(cartographic)) {\n    return false;\n  }\n\n  if (!cameraController.onMap() && cartographic.height < 0.0) {\n    // The camera can go off the map while in Columbus View.\n    // Make a best guess as to whether it's underground by checking if its height is less than zero.\n    return true;\n  }\n\n  if (\n    !defined(globe) ||\n    !globe.show ||\n    mode === SceneMode.SCENE2D ||\n    mode === SceneMode.MORPHING\n  ) {\n    return false;\n  }\n\n  const globeHeight = scene._globeHeight;\n  return defined(globeHeight) && cartographic.height < globeHeight;\n}\n\n/**\n * @private\n */\nScene.prototype.initializeFrame = function () {\n  // Destroy released shaders and textures once every 120 frames to avoid thrashing the cache\n  if (this._shaderFrameCount++ === 120) {\n    this._shaderFrameCount = 0;\n    this._context.shaderCache.destroyReleasedShaderPrograms();\n    this._context.textureCache.destroyReleasedTextures();\n  }\n\n  this._tweens.update();\n\n  this._globeHeight = getGlobeHeight(this);\n  this._cameraUnderground = isCameraUnderground(this);\n  this._globeTranslucencyState.update(this);\n\n  this._screenSpaceCameraController.update();\n  if (defined(this._deviceOrientationCameraController)) {\n    this._deviceOrientationCameraController.update();\n  }\n\n  this.camera.update(this._mode);\n  this.camera._updateCameraChanged();\n};\n\nfunction updateDebugShowFramesPerSecond(scene, renderedThisFrame) {\n  if (scene.debugShowFramesPerSecond) {\n    if (!defined(scene._performanceDisplay)) {\n      const performanceContainer = document.createElement(\"div\");\n      performanceContainer.className =\n        \"cesium-performanceDisplay-defaultContainer\";\n      const container = scene._canvas.parentNode;\n      container.appendChild(performanceContainer);\n      const performanceDisplay = new PerformanceDisplay({\n        container: performanceContainer,\n      });\n      scene._performanceDisplay = performanceDisplay;\n      scene._performanceContainer = performanceContainer;\n    }\n\n    scene._performanceDisplay.throttled = scene.requestRenderMode;\n    scene._performanceDisplay.update(renderedThisFrame);\n  } else if (defined(scene._performanceDisplay)) {\n    scene._performanceDisplay =\n      scene._performanceDisplay && scene._performanceDisplay.destroy();\n    scene._performanceContainer.parentNode.removeChild(\n      scene._performanceContainer\n    );\n  }\n}\n\nfunction prePassesUpdate(scene) {\n  scene._jobScheduler.resetBudgets();\n\n  const frameState = scene._frameState;\n  const primitives = scene.primitives;\n  primitives.prePassesUpdate(frameState);\n\n  if (defined(scene.globe)) {\n    scene.globe.update(frameState);\n  }\n\n  scene._picking.update();\n  frameState.creditDisplay.update();\n}\n\nfunction postPassesUpdate(scene) {\n  const frameState = scene._frameState;\n  const primitives = scene.primitives;\n  primitives.postPassesUpdate(frameState);\n\n  RequestScheduler.update();\n}\n\nconst scratchBackgroundColor = new Color();\n\nfunction render(scene) {\n  const frameState = scene._frameState;\n\n  const context = scene.context;\n  const us = context.uniformState;\n\n  const view = scene._defaultView;\n  scene._view = view;\n\n  scene.updateFrameState();\n  frameState.passes.render = true;\n  frameState.passes.postProcess = scene.postProcessStages.hasSelected;\n  frameState.tilesetPassState = renderTilesetPassState;\n\n  let backgroundColor = defaultValue(scene.backgroundColor, Color.BLACK);\n  if (scene._hdr) {\n    backgroundColor = Color.clone(backgroundColor, scratchBackgroundColor);\n    backgroundColor.red = Math.pow(backgroundColor.red, scene.gamma);\n    backgroundColor.green = Math.pow(backgroundColor.green, scene.gamma);\n    backgroundColor.blue = Math.pow(backgroundColor.blue, scene.gamma);\n  }\n  frameState.backgroundColor = backgroundColor;\n\n  scene.fog.update(frameState);\n\n  us.update(frameState);\n\n  const shadowMap = scene.shadowMap;\n  if (defined(shadowMap) && shadowMap.enabled) {\n    if (!defined(scene.light) || scene.light instanceof SunLight) {\n      // Negate the sun direction so that it is from the Sun, not to the Sun\n      Cartesian3.negate(us.sunDirectionWC, scene._shadowMapCamera.direction);\n    } else {\n      Cartesian3.clone(scene.light.direction, scene._shadowMapCamera.direction);\n    }\n    frameState.shadowMaps.push(shadowMap);\n  }\n\n  scene._computeCommandList.length = 0;\n  scene._overlayCommandList.length = 0;\n\n  const viewport = view.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  const passState = view.passState;\n  passState.framebuffer = undefined;\n  passState.blendingEnabled = undefined;\n  passState.scissorTest = undefined;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  if (defined(scene.globe)) {\n    scene.globe.beginFrame(frameState);\n  }\n\n  scene.updateEnvironment();\n  scene.updateAndExecuteCommands(passState, backgroundColor);\n  scene.resolveFramebuffers(passState);\n\n  passState.framebuffer = undefined;\n  executeOverlayCommands(scene, passState);\n\n  if (defined(scene.globe)) {\n    scene.globe.endFrame(frameState);\n\n    if (!scene.globe.tilesLoaded) {\n      scene._renderRequested = true;\n    }\n  }\n\n  context.endFrame();\n}\n\nfunction tryAndCatchError(scene, functionToExecute) {\n  try {\n    functionToExecute(scene);\n  } catch (error) {\n    scene._renderError.raiseEvent(scene, error);\n\n    if (scene.rethrowRenderErrors) {\n      throw error;\n    }\n  }\n}\n\nfunction updateMostDetailedRayPicks(scene) {\n  return scene._picking.updateMostDetailedRayPicks(scene);\n}\n\n/**\n * Update and render the scene. It is usually not necessary to call this function\n * directly because {@link CesiumWidget} or {@link Viewer} do it automatically.\n * @param {JulianDate} [time] The simulation time at which to render.\n */\nScene.prototype.render = function (time) {\n  /**\n   *\n   * Pre passes update. Execute any pass invariant code that should run before the passes here.\n   *\n   */\n  this._preUpdate.raiseEvent(this, time);\n\n  const frameState = this._frameState;\n  frameState.newFrame = false;\n\n  if (!defined(time)) {\n    time = JulianDate.now();\n  }\n\n  // Determine if shouldRender\n  const cameraChanged = this._view.checkForCameraUpdates(this);\n  let shouldRender =\n    !this.requestRenderMode ||\n    this._renderRequested ||\n    cameraChanged ||\n    this._logDepthBufferDirty ||\n    this._hdrDirty ||\n    this.mode === SceneMode.MORPHING;\n  if (\n    !shouldRender &&\n    defined(this.maximumRenderTimeChange) &&\n    defined(this._lastRenderTime)\n  ) {\n    const difference = Math.abs(\n      JulianDate.secondsDifference(this._lastRenderTime, time)\n    );\n    shouldRender = shouldRender || difference > this.maximumRenderTimeChange;\n  }\n\n  if (shouldRender) {\n    this._lastRenderTime = JulianDate.clone(time, this._lastRenderTime);\n    this._renderRequested = false;\n    this._logDepthBufferDirty = false;\n    this._hdrDirty = false;\n\n    const frameNumber = CesiumMath.incrementWrap(\n      frameState.frameNumber,\n      15000000.0,\n      1.0\n    );\n    updateFrameNumber(this, frameNumber, time);\n    frameState.newFrame = true;\n  }\n\n  tryAndCatchError(this, prePassesUpdate);\n\n  /**\n   *\n   * Passes update. Add any passes here\n   *\n   */\n  if (this.primitives.show) {\n    tryAndCatchError(this, updateMostDetailedRayPicks);\n    tryAndCatchError(this, updatePreloadPass);\n    tryAndCatchError(this, updatePreloadFlightPass);\n    if (!shouldRender) {\n      tryAndCatchError(this, updateRequestRenderModeDeferCheckPass);\n    }\n  }\n\n  this._postUpdate.raiseEvent(this, time);\n\n  if (shouldRender) {\n    this._preRender.raiseEvent(this, time);\n    frameState.creditDisplay.beginFrame();\n    tryAndCatchError(this, render);\n  }\n\n  /**\n   *\n   * Post passes update. Execute any pass invariant code that should run after the passes here.\n   *\n   */\n  updateDebugShowFramesPerSecond(this, shouldRender);\n  tryAndCatchError(this, postPassesUpdate);\n\n  // Often used to trigger events (so don't want in trycatch) that the user might be subscribed to. Things like the tile load events, ready promises, etc.\n  // We don't want those events to resolve during the render loop because the events might add new primitives\n  callAfterRenderFunctions(this);\n\n  if (shouldRender) {\n    this._postRender.raiseEvent(this, time);\n    frameState.creditDisplay.endFrame();\n  }\n};\n\n/**\n * Update and render the scene. Always forces a new render frame regardless of whether a render was\n * previously requested.\n * @param {JulianDate} [time] The simulation time at which to render.\n *\n * @private\n */\nScene.prototype.forceRender = function (time) {\n  this._renderRequested = true;\n  this.render(time);\n};\n\n/**\n * Requests a new rendered frame when {@link Scene#requestRenderMode} is set to <code>true</code>.\n * The render rate will not exceed the {@link CesiumWidget#targetFrameRate}.\n *\n * @see Scene#requestRenderMode\n */\nScene.prototype.requestRender = function () {\n  this._renderRequested = true;\n};\n\n/**\n * @private\n */\nScene.prototype.clampLineWidth = function (width) {\n  return Math.max(\n    ContextLimits.minimumAliasedLineWidth,\n    Math.min(width, ContextLimits.maximumAliasedLineWidth)\n  );\n};\n\n/**\n * Returns an object with a `primitive` property that contains the first (top) primitive in the scene\n * at a particular window coordinate or undefined if nothing is at the location. Other properties may\n * potentially be set depending on the type of primitive and may be used to further identify the picked object.\n * <p>\n * When a feature of a 3D Tiles tileset is picked, <code>pick</code> returns a {@link Cesium3DTileFeature} object.\n * </p>\n *\n * @example\n * // On mouse over, color the feature yellow.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.Cesium3DTileFeature) {\n *         feature.color = Cesium.Color.YELLOW;\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Number} [width=3] Width of the pick rectangle.\n * @param {Number} [height=3] Height of the pick rectangle.\n * @returns {Object} Object containing the picked primitive.\n */\nScene.prototype.pick = function (windowPosition, width, height) {\n  return this._picking.pick(this, windowPosition, width, height);\n};\n\n/**\n * Returns the cartesian position reconstructed from the depth buffer and window position.\n * The returned position is in world coordinates. Used internally by camera functions to\n * prevent conversion to projected 2D coordinates and then back.\n * <p>\n * Set {@link Scene#pickTranslucentDepth} to <code>true</code> to include the depth of\n * translucent primitives; otherwise, this essentially picks through translucent primitives.\n * </p>\n *\n * @private\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Cartesian3} [result] The object on which to restore the result.\n * @returns {Cartesian3} The cartesian position in world coordinates.\n *\n * @exception {DeveloperError} Picking from the depth buffer is not supported. Check pickPositionSupported.\n */\nScene.prototype.pickPositionWorldCoordinates = function (\n  windowPosition,\n  result\n) {\n  return this._picking.pickPositionWorldCoordinates(\n    this,\n    windowPosition,\n    result\n  );\n};\n\n/**\n * Returns the cartesian position reconstructed from the depth buffer and window position.\n * <p>\n * The position reconstructed from the depth buffer in 2D may be slightly different from those\n * reconstructed in 3D and Columbus view. This is caused by the difference in the distribution\n * of depth values of perspective and orthographic projection.\n * </p>\n * <p>\n * Set {@link Scene#pickTranslucentDepth} to <code>true</code> to include the depth of\n * translucent primitives; otherwise, this essentially picks through translucent primitives.\n * </p>\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Cartesian3} [result] The object on which to restore the result.\n * @returns {Cartesian3} The cartesian position.\n *\n * @exception {DeveloperError} Picking from the depth buffer is not supported. Check pickPositionSupported.\n */\nScene.prototype.pickPosition = function (windowPosition, result) {\n  return this._picking.pickPosition(this, windowPosition, result);\n};\n\n/**\n * Returns a list of objects, each containing a `primitive` property, for all primitives at\n * a particular window coordinate position. Other properties may also be set depending on the\n * type of primitive and may be used to further identify the picked object. The primitives in\n * the list are ordered by their visual order in the scene (front to back).\n *\n * @param {Cartesian2} windowPosition Window coordinates to perform picking on.\n * @param {Number} [limit] If supplied, stop drilling after collecting this many picks.\n * @param {Number} [width=3] Width of the pick rectangle.\n * @param {Number} [height=3] Height of the pick rectangle.\n * @returns {Array.<*>} Array of objects, each containing 1 picked primitives.\n *\n * @exception {DeveloperError} windowPosition is undefined.\n *\n * @example\n * const pickedObjects = scene.drillPick(new Cesium.Cartesian2(100.0, 200.0));\n *\n * @see Scene#pick\n */\nScene.prototype.drillPick = function (windowPosition, limit, width, height) {\n  return this._picking.drillPick(this, windowPosition, limit, width, height);\n};\n\nfunction updatePreloadPass(scene) {\n  const frameState = scene._frameState;\n  preloadTilesetPassState.camera = frameState.camera;\n  preloadTilesetPassState.cullingVolume = frameState.cullingVolume;\n\n  const primitives = scene.primitives;\n  primitives.updateForPass(frameState, preloadTilesetPassState);\n}\n\nfunction updatePreloadFlightPass(scene) {\n  const frameState = scene._frameState;\n  const camera = frameState.camera;\n  if (!camera.canPreloadFlight()) {\n    return;\n  }\n\n  preloadFlightTilesetPassState.camera = scene.preloadFlightCamera;\n  preloadFlightTilesetPassState.cullingVolume =\n    scene.preloadFlightCullingVolume;\n\n  const primitives = scene.primitives;\n  primitives.updateForPass(frameState, preloadFlightTilesetPassState);\n}\n\nfunction updateRequestRenderModeDeferCheckPass(scene) {\n  // Check if any ignored requests are ready to go (to wake rendering up again)\n  scene.primitives.updateForPass(\n    scene._frameState,\n    requestRenderModeDeferCheckPassState\n  );\n}\n\n/**\n * Returns an object containing the first object intersected by the ray and the position of intersection,\n * or <code>undefined</code> if there were no intersections. The intersected object has a <code>primitive</code>\n * property that contains the intersected primitive. Other properties may be set depending on the type of primitive\n * and may be used to further identify the picked object. The ray must be given in world coordinates.\n * <p>\n * This function only picks globe tiles and 3D Tiles that are rendered in the current view. Picks all other\n * primitives regardless of their visibility.\n * </p>\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Object} An object containing the object and position of the first intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\nScene.prototype.pickFromRay = function (ray, objectsToExclude, width) {\n  return this._picking.pickFromRay(this, ray, objectsToExclude, width);\n};\n\n/**\n * Returns a list of objects, each containing the object intersected by the ray and the position of intersection.\n * The intersected object has a <code>primitive</code> property that contains the intersected primitive. Other\n * properties may also be set depending on the type of primitive and may be used to further identify the picked object.\n * The primitives in the list are ordered by first intersection to last intersection. The ray must be given in\n * world coordinates.\n * <p>\n * This function only picks globe tiles and 3D Tiles that are rendered in the current view. Picks all other\n * primitives regardless of their visibility.\n * </p>\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Number} [limit=Number.MAX_VALUE] If supplied, stop finding intersections after this many intersections.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Object[]} List of objects containing the object and position of each intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\nScene.prototype.drillPickFromRay = function (\n  ray,\n  limit,\n  objectsToExclude,\n  width\n) {\n  return this._picking.drillPickFromRay(\n    this,\n    ray,\n    limit,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Initiates an asynchronous {@link Scene#pickFromRay} request using the maximum level of detail for 3D Tilesets\n * regardless of visibility.\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Object>} A promise that resolves to an object containing the object and position of the first intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\nScene.prototype.pickFromRayMostDetailed = function (\n  ray,\n  objectsToExclude,\n  width\n) {\n  return this._picking.pickFromRayMostDetailed(\n    this,\n    ray,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Initiates an asynchronous {@link Scene#drillPickFromRay} request using the maximum level of detail for 3D Tilesets\n * regardless of visibility.\n *\n * @private\n *\n * @param {Ray} ray The ray.\n * @param {Number} [limit=Number.MAX_VALUE] If supplied, stop finding intersections after this many intersections.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to exclude from the ray intersection.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Object[]>} A promise that resolves to a list of objects containing the object and position of each intersection.\n *\n * @exception {DeveloperError} Ray intersections are only supported in 3D mode.\n */\nScene.prototype.drillPickFromRayMostDetailed = function (\n  ray,\n  limit,\n  objectsToExclude,\n  width\n) {\n  return this._picking.drillPickFromRayMostDetailed(\n    this,\n    ray,\n    limit,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Returns the height of scene geometry at the given cartographic position or <code>undefined</code> if there was no\n * scene geometry to sample height from. The height of the input position is ignored. May be used to clamp objects to\n * the globe, 3D Tiles, or primitives in the scene.\n * <p>\n * This function only samples height from globe tiles and 3D Tiles that are rendered in the current view. Samples height\n * from all other primitives regardless of their visibility.\n * </p>\n *\n * @param {Cartographic} position The cartographic position to sample height from.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not sample height from.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Number} The height. This may be <code>undefined</code> if there was no scene geometry to sample height from.\n *\n * @example\n * const position = new Cesium.Cartographic(-1.31968, 0.698874);\n * const height = viewer.scene.sampleHeight(position);\n * console.log(height);\n *\n * @see Scene#clampToHeight\n * @see Scene#clampToHeightMostDetailed\n * @see Scene#sampleHeightMostDetailed\n *\n * @exception {DeveloperError} sampleHeight is only supported in 3D mode.\n * @exception {DeveloperError} sampleHeight requires depth texture support. Check sampleHeightSupported.\n */\nScene.prototype.sampleHeight = function (position, objectsToExclude, width) {\n  return this._picking.sampleHeight(this, position, objectsToExclude, width);\n};\n\n/**\n * Clamps the given cartesian position to the scene geometry along the geodetic surface normal. Returns the\n * clamped position or <code>undefined</code> if there was no scene geometry to clamp to. May be used to clamp\n * objects to the globe, 3D Tiles, or primitives in the scene.\n * <p>\n * This function only clamps to globe tiles and 3D Tiles that are rendered in the current view. Clamps to\n * all other primitives regardless of their visibility.\n * </p>\n *\n * @param {Cartesian3} cartesian The cartesian position.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not clamp to.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @param {Cartesian3} [result] An optional object to return the clamped position.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. This may be <code>undefined</code> if there was no scene geometry to clamp to.\n *\n * @example\n * // Clamp an entity to the underlying scene geometry\n * const position = entity.position.getValue(Cesium.JulianDate.now());\n * entity.position = viewer.scene.clampToHeight(position);\n *\n * @see Scene#sampleHeight\n * @see Scene#sampleHeightMostDetailed\n * @see Scene#clampToHeightMostDetailed\n *\n * @exception {DeveloperError} clampToHeight is only supported in 3D mode.\n * @exception {DeveloperError} clampToHeight requires depth texture support. Check clampToHeightSupported.\n */\nScene.prototype.clampToHeight = function (\n  cartesian,\n  objectsToExclude,\n  width,\n  result\n) {\n  return this._picking.clampToHeight(\n    this,\n    cartesian,\n    objectsToExclude,\n    width,\n    result\n  );\n};\n\n/**\n * Initiates an asynchronous {@link Scene#sampleHeight} query for an array of {@link Cartographic} positions\n * using the maximum level of detail for 3D Tilesets in the scene. The height of the input positions is ignored.\n * Returns a promise that is resolved when the query completes. Each point height is modified in place.\n * If a height cannot be determined because no geometry can be sampled at that location, or another error occurs,\n * the height is set to undefined.\n *\n * @param {Cartographic[]} positions The cartographic positions to update with sampled heights.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not sample height from.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Cartographic[]>} A promise that resolves to the provided list of positions when the query has completed.\n *\n * @example\n * const positions = [\n *     new Cesium.Cartographic(-1.31968, 0.69887),\n *     new Cesium.Cartographic(-1.10489, 0.83923)\n * ];\n * const promise = viewer.scene.sampleHeightMostDetailed(positions);\n * promise.then(function(updatedPosition) {\n *     // positions[0].height and positions[1].height have been updated.\n *     // updatedPositions is just a reference to positions.\n * }\n *\n * @see Scene#sampleHeight\n *\n * @exception {DeveloperError} sampleHeightMostDetailed is only supported in 3D mode.\n * @exception {DeveloperError} sampleHeightMostDetailed requires depth texture support. Check sampleHeightSupported.\n */\nScene.prototype.sampleHeightMostDetailed = function (\n  positions,\n  objectsToExclude,\n  width\n) {\n  return this._picking.sampleHeightMostDetailed(\n    this,\n    positions,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Initiates an asynchronous {@link Scene#clampToHeight} query for an array of {@link Cartesian3} positions\n * using the maximum level of detail for 3D Tilesets in the scene. Returns a promise that is resolved when\n * the query completes. Each position is modified in place. If a position cannot be clamped because no geometry\n * can be sampled at that location, or another error occurs, the element in the array is set to undefined.\n *\n * @param {Cartesian3[]} cartesians The cartesian positions to update with clamped positions.\n * @param {Object[]} [objectsToExclude] A list of primitives, entities, or 3D Tiles features to not clamp to.\n * @param {Number} [width=0.1] Width of the intersection volume in meters.\n * @returns {Promise.<Cartesian3[]>} A promise that resolves to the provided list of positions when the query has completed.\n *\n * @example\n * const cartesians = [\n *     entities[0].position.getValue(Cesium.JulianDate.now()),\n *     entities[1].position.getValue(Cesium.JulianDate.now())\n * ];\n * const promise = viewer.scene.clampToHeightMostDetailed(cartesians);\n * promise.then(function(updatedCartesians) {\n *     entities[0].position = updatedCartesians[0];\n *     entities[1].position = updatedCartesians[1];\n * }\n *\n * @see Scene#clampToHeight\n *\n * @exception {DeveloperError} clampToHeightMostDetailed is only supported in 3D mode.\n * @exception {DeveloperError} clampToHeightMostDetailed requires depth texture support. Check clampToHeightSupported.\n */\nScene.prototype.clampToHeightMostDetailed = function (\n  cartesians,\n  objectsToExclude,\n  width\n) {\n  return this._picking.clampToHeightMostDetailed(\n    this,\n    cartesians,\n    objectsToExclude,\n    width\n  );\n};\n\n/**\n * Transforms a position in cartesian coordinates to canvas coordinates.  This is commonly used to place an\n * HTML element at the same screen position as an object in the scene.\n *\n * @param {Cartesian3} position The position in cartesian coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to canvas coordinates.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the canvas position of longitude/latitude (0, 0) every time the mouse moves.\n * const scene = widget.scene;\n * const ellipsoid = scene.globe.ellipsoid;\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(scene.cartesianToCanvasCoordinates(position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nScene.prototype.cartesianToCanvasCoordinates = function (position, result) {\n  return SceneTransforms.wgs84ToWindowCoordinates(this, position, result);\n};\n\n/**\n * Instantly completes an active transition.\n */\nScene.prototype.completeMorph = function () {\n  this._transitioner.completeMorph();\n};\n\n/**\n * Asynchronously transitions the scene to 2D.\n * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.\n */\nScene.prototype.morphTo2D = function (duration) {\n  let ellipsoid;\n  const globe = this.globe;\n  if (defined(globe)) {\n    ellipsoid = globe.ellipsoid;\n  } else {\n    ellipsoid = this.mapProjection.ellipsoid;\n  }\n  duration = defaultValue(duration, 2.0);\n  this._transitioner.morphTo2D(duration, ellipsoid);\n};\n\n/**\n * Asynchronously transitions the scene to Columbus View.\n * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.\n */\nScene.prototype.morphToColumbusView = function (duration) {\n  let ellipsoid;\n  const globe = this.globe;\n  if (defined(globe)) {\n    ellipsoid = globe.ellipsoid;\n  } else {\n    ellipsoid = this.mapProjection.ellipsoid;\n  }\n  duration = defaultValue(duration, 2.0);\n  this._transitioner.morphToColumbusView(duration, ellipsoid);\n};\n\n/**\n * Asynchronously transitions the scene to 3D.\n * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.\n */\nScene.prototype.morphTo3D = function (duration) {\n  let ellipsoid;\n  const globe = this.globe;\n  if (defined(globe)) {\n    ellipsoid = globe.ellipsoid;\n  } else {\n    ellipsoid = this.mapProjection.ellipsoid;\n  }\n  duration = defaultValue(duration, 2.0);\n  this._transitioner.morphTo3D(duration, ellipsoid);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Scene#destroy\n */\nScene.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * scene = scene && scene.destroy();\n *\n * @see Scene#isDestroyed\n */\nScene.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._computeEngine = this._computeEngine && this._computeEngine.destroy();\n  this._screenSpaceCameraController =\n    this._screenSpaceCameraController &&\n    this._screenSpaceCameraController.destroy();\n  this._deviceOrientationCameraController =\n    this._deviceOrientationCameraController &&\n    !this._deviceOrientationCameraController.isDestroyed() &&\n    this._deviceOrientationCameraController.destroy();\n  this._primitives = this._primitives && this._primitives.destroy();\n  this._groundPrimitives =\n    this._groundPrimitives && this._groundPrimitives.destroy();\n  this._globe = this._globe && this._globe.destroy();\n  this.skyBox = this.skyBox && this.skyBox.destroy();\n  this.skyAtmosphere = this.skyAtmosphere && this.skyAtmosphere.destroy();\n  this._debugSphere = this._debugSphere && this._debugSphere.destroy();\n  this.sun = this.sun && this.sun.destroy();\n  this._sunPostProcess = this._sunPostProcess && this._sunPostProcess.destroy();\n  this._depthPlane = this._depthPlane && this._depthPlane.destroy();\n  this._transitioner = this._transitioner && this._transitioner.destroy();\n  this._debugFrustumPlanes =\n    this._debugFrustumPlanes && this._debugFrustumPlanes.destroy();\n  this._brdfLutGenerator =\n    this._brdfLutGenerator && this._brdfLutGenerator.destroy();\n  this._picking = this._picking && this._picking.destroy();\n\n  this._defaultView = this._defaultView && this._defaultView.destroy();\n  this._view = undefined;\n\n  if (this._removeCreditContainer) {\n    this._canvas.parentNode.removeChild(this._creditContainer);\n  }\n\n  this.postProcessStages =\n    this.postProcessStages && this.postProcessStages.destroy();\n\n  this._context = this._context && this._context.destroy();\n  this._frameState.creditDisplay =\n    this._frameState.creditDisplay && this._frameState.creditDisplay.destroy();\n\n  if (defined(this._performanceDisplay)) {\n    this._performanceDisplay =\n      this._performanceDisplay && this._performanceDisplay.destroy();\n    this._performanceContainer.parentNode.removeChild(\n      this._performanceContainer\n    );\n  }\n\n  this._removeRequestListenerCallback();\n  this._removeTaskProcessorListenerCallback();\n  for (let i = 0; i < this._removeGlobeCallbacks.length; ++i) {\n    this._removeGlobeCallbacks[i]();\n  }\n  this._removeGlobeCallbacks.length = 0;\n\n  return destroyObject(this);\n};\nexport default Scene;\n","import Color from \"../Core/Color.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\n\n/**\n * @private\n */\nfunction SceneFramebuffer() {\n  this._numSamples = 1;\n  this._colorFramebuffer = new FramebufferManager({\n    depthStencil: true,\n    supportsDepthTexture: true,\n  });\n  this._idFramebuffer = new FramebufferManager({\n    depthStencil: true,\n    supportsDepthTexture: true,\n  });\n\n  this._idClearColor = new Color(0.0, 0.0, 0.0, 0.0);\n\n  this._clearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    depth: 1.0,\n    owner: this,\n  });\n}\n\nfunction destroyResources(post) {\n  post._colorFramebuffer.destroy();\n  post._idFramebuffer.destroy();\n}\n\nObject.defineProperties(SceneFramebuffer.prototype, {\n  framebuffer: {\n    get: function () {\n      return this._colorFramebuffer.framebuffer;\n    },\n  },\n  idFramebuffer: {\n    get: function () {\n      return this._idFramebuffer.framebuffer;\n    },\n  },\n  depthStencilTexture: {\n    get: function () {\n      return this._colorFramebuffer.getDepthStencilTexture();\n    },\n  },\n});\n\nSceneFramebuffer.prototype.update = function (\n  context,\n  viewport,\n  hdr,\n  numSamples\n) {\n  const width = viewport.width;\n  const height = viewport.height;\n  const pixelDatatype = hdr\n    ? context.halfFloatingPointTexture\n      ? PixelDatatype.HALF_FLOAT\n      : PixelDatatype.FLOAT\n    : PixelDatatype.UNSIGNED_BYTE;\n  this._numSamples = numSamples;\n  this._colorFramebuffer.update(\n    context,\n    width,\n    height,\n    numSamples,\n    pixelDatatype\n  );\n  this._idFramebuffer.update(context, width, height);\n};\n\nSceneFramebuffer.prototype.clear = function (context, passState, clearColor) {\n  Color.clone(clearColor, this._clearCommand.color);\n  Color.clone(this._idClearColor, this._clearCommand.color);\n  this._colorFramebuffer.clear(context, this._clearCommand, passState);\n  this._idFramebuffer.clear(context, this._clearCommand, passState);\n};\n\nSceneFramebuffer.prototype.getFramebuffer = function () {\n  return this._colorFramebuffer.framebuffer;\n};\n\nSceneFramebuffer.prototype.getIdFramebuffer = function () {\n  return this._idFramebuffer.framebuffer;\n};\n\nSceneFramebuffer.prototype.prepareColorTextures = function (context) {\n  if (this._numSamples > 1) {\n    this._colorFramebuffer.prepareTextures(context);\n  }\n};\n\nSceneFramebuffer.prototype.isDestroyed = function () {\n  return false;\n};\n\nSceneFramebuffer.prototype.destroy = function () {\n  destroyResources(this);\n  return destroyObject(this);\n};\nexport default SceneFramebuffer;\n","/**\n * Indicates if the scene is viewed in 3D, 2D, or 2.5D Columbus view.\n *\n * @enum {Number}\n * @see Scene#mode\n */\nconst SceneMode = {\n  /**\n   * Morphing between mode, e.g., 3D to 2D.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MORPHING: 0,\n\n  /**\n   * Columbus View mode.  A 2.5D perspective view where the map is laid out\n   * flat and objects with non-zero height are drawn above it.\n   *\n   * @type {Number}\n   * @constant\n   */\n  COLUMBUS_VIEW: 1,\n\n  /**\n   * 2D mode.  The map is viewed top-down with an orthographic projection.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SCENE2D: 2,\n\n  /**\n   * 3D mode.  A traditional 3D perspective view of the globe.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SCENE3D: 3,\n};\n\n/**\n * Returns the morph time for the given scene mode.\n *\n * @param {SceneMode} value The scene mode\n * @returns {Number} The morph time\n */\nSceneMode.getMorphTime = function (value) {\n  if (value === SceneMode.SCENE3D) {\n    return 1.0;\n  } else if (value === SceneMode.MORPHING) {\n    return undefined;\n  }\n  return 0.0;\n};\nexport default Object.freeze(SceneMode);\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Functions that do scene-dependent transforms between rendering-related coordinate systems.\n *\n * @namespace SceneTransforms\n */\nconst SceneTransforms = {};\n\nconst actualPositionScratch = new Cartesian4(0, 0, 0, 1);\nlet positionCC = new Cartesian4();\nconst scratchViewport = new BoundingRectangle();\n\nconst scratchWindowCoord0 = new Cartesian2();\nconst scratchWindowCoord1 = new Cartesian2();\n\n/**\n * Transforms a position in WGS84 coordinates to window coordinates.  This is commonly used to place an\n * HTML element at the same screen position as an object in the scene.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in WGS84 (world) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const scene = widget.scene;\n * const ellipsoid = scene.globe.ellipsoid;\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nSceneTransforms.wgs84ToWindowCoordinates = function (scene, position, result) {\n  return SceneTransforms.wgs84WithEyeOffsetToWindowCoordinates(\n    scene,\n    position,\n    Cartesian3.ZERO,\n    result\n  );\n};\n\nconst scratchCartesian4 = new Cartesian4();\nconst scratchEyeOffset = new Cartesian3();\n\nfunction worldToClip(position, eyeOffset, camera, result) {\n  const viewMatrix = camera.viewMatrix;\n\n  const positionEC = Matrix4.multiplyByVector(\n    viewMatrix,\n    Cartesian4.fromElements(\n      position.x,\n      position.y,\n      position.z,\n      1,\n      scratchCartesian4\n    ),\n    scratchCartesian4\n  );\n\n  const zEyeOffset = Cartesian3.multiplyComponents(\n    eyeOffset,\n    Cartesian3.normalize(positionEC, scratchEyeOffset),\n    scratchEyeOffset\n  );\n  positionEC.x += eyeOffset.x + zEyeOffset.x;\n  positionEC.y += eyeOffset.y + zEyeOffset.y;\n  positionEC.z += zEyeOffset.z;\n\n  return Matrix4.multiplyByVector(\n    camera.frustum.projectionMatrix,\n    positionEC,\n    result\n  );\n}\n\nconst scratchMaxCartographic = new Cartographic(\n  Math.PI,\n  CesiumMath.PI_OVER_TWO\n);\nconst scratchProjectedCartesian = new Cartesian3();\nconst scratchCameraPosition = new Cartesian3();\n\n/**\n * @private\n */\nSceneTransforms.wgs84WithEyeOffsetToWindowCoordinates = function (\n  scene,\n  position,\n  eyeOffset,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // Transform for 3D, 2D, or Columbus view\n  const frameState = scene.frameState;\n  const actualPosition = SceneTransforms.computeActualWgs84Position(\n    frameState,\n    position,\n    actualPositionScratch\n  );\n\n  if (!defined(actualPosition)) {\n    return undefined;\n  }\n\n  // Assuming viewport takes up the entire canvas...\n  const canvas = scene.canvas;\n  const viewport = scratchViewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = canvas.clientWidth;\n  viewport.height = canvas.clientHeight;\n\n  const camera = scene.camera;\n  let cameraCentered = false;\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    const projection = scene.mapProjection;\n    const maxCartographic = scratchMaxCartographic;\n    const maxCoord = projection.project(\n      maxCartographic,\n      scratchProjectedCartesian\n    );\n\n    const cameraPosition = Cartesian3.clone(\n      camera.position,\n      scratchCameraPosition\n    );\n    const frustum = camera.frustum.clone();\n\n    const viewportTransformation = Matrix4.computeViewportTransformation(\n      viewport,\n      0.0,\n      1.0,\n      new Matrix4()\n    );\n    const projectionMatrix = camera.frustum.projectionMatrix;\n\n    const x = camera.positionWC.y;\n    const eyePoint = Cartesian3.fromElements(\n      CesiumMath.sign(x) * maxCoord.x - x,\n      0.0,\n      -camera.positionWC.x\n    );\n    const windowCoordinates = Transforms.pointToGLWindowCoordinates(\n      projectionMatrix,\n      viewportTransformation,\n      eyePoint\n    );\n\n    if (\n      x === 0.0 ||\n      windowCoordinates.x <= 0.0 ||\n      windowCoordinates.x >= canvas.clientWidth\n    ) {\n      cameraCentered = true;\n    } else {\n      if (windowCoordinates.x > canvas.clientWidth * 0.5) {\n        viewport.width = windowCoordinates.x;\n\n        camera.frustum.right = maxCoord.x - x;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord0\n        );\n\n        viewport.x += windowCoordinates.x;\n\n        camera.position.x = -camera.position.x;\n\n        const right = camera.frustum.right;\n        camera.frustum.right = -camera.frustum.left;\n        camera.frustum.left = -right;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord1\n        );\n      } else {\n        viewport.x += windowCoordinates.x;\n        viewport.width -= windowCoordinates.x;\n\n        camera.frustum.left = -maxCoord.x - x;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord0\n        );\n\n        viewport.x = viewport.x - viewport.width;\n\n        camera.position.x = -camera.position.x;\n\n        const left = camera.frustum.left;\n        camera.frustum.left = -camera.frustum.right;\n        camera.frustum.right = -left;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord1\n        );\n      }\n\n      Cartesian3.clone(cameraPosition, camera.position);\n      camera.frustum = frustum.clone();\n\n      result = Cartesian2.clone(scratchWindowCoord0, result);\n      if (result.x < 0.0 || result.x > canvas.clientWidth) {\n        result.x = scratchWindowCoord1.x;\n      }\n    }\n  }\n\n  if (frameState.mode !== SceneMode.SCENE2D || cameraCentered) {\n    // View-projection matrix to transform from world coordinates to clip coordinates\n    positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n    if (\n      positionCC.z < 0 &&\n      !(camera.frustum instanceof OrthographicFrustum) &&\n      !(camera.frustum instanceof OrthographicOffCenterFrustum)\n    ) {\n      return undefined;\n    }\n\n    result = SceneTransforms.clipToGLWindowCoordinates(\n      viewport,\n      positionCC,\n      result\n    );\n  }\n\n  result.y = canvas.clientHeight - result.y;\n  return result;\n};\n\n/**\n * Transforms a position in WGS84 coordinates to drawing buffer coordinates.  This may produce different\n * results from SceneTransforms.wgs84ToWindowCoordinates when the browser zoom is not 100%, or on high-DPI displays.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in WGS84 (world) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * const scene = widget.scene;\n * const ellipsoid = scene.globe.ellipsoid;\n * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nSceneTransforms.wgs84ToDrawingBufferCoordinates = function (\n  scene,\n  position,\n  result\n) {\n  result = SceneTransforms.wgs84ToWindowCoordinates(scene, position, result);\n  if (!defined(result)) {\n    return undefined;\n  }\n\n  return SceneTransforms.transformWindowToDrawingBuffer(scene, result, result);\n};\n\nconst projectedPosition = new Cartesian3();\nconst positionInCartographic = new Cartographic();\n\n/**\n * @private\n */\nSceneTransforms.computeActualWgs84Position = function (\n  frameState,\n  position,\n  result\n) {\n  const mode = frameState.mode;\n\n  if (mode === SceneMode.SCENE3D) {\n    return Cartesian3.clone(position, result);\n  }\n\n  const projection = frameState.mapProjection;\n  const cartographic = projection.ellipsoid.cartesianToCartographic(\n    position,\n    positionInCartographic\n  );\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n\n  projection.project(cartographic, projectedPosition);\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return Cartesian3.fromElements(\n      projectedPosition.z,\n      projectedPosition.x,\n      projectedPosition.y,\n      result\n    );\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    return Cartesian3.fromElements(\n      0.0,\n      projectedPosition.x,\n      projectedPosition.y,\n      result\n    );\n  }\n\n  // mode === SceneMode.MORPHING\n  const morphTime = frameState.morphTime;\n  return Cartesian3.fromElements(\n    CesiumMath.lerp(projectedPosition.z, position.x, morphTime),\n    CesiumMath.lerp(projectedPosition.x, position.y, morphTime),\n    CesiumMath.lerp(projectedPosition.y, position.z, morphTime),\n    result\n  );\n};\n\nconst positionNDC = new Cartesian3();\nconst positionWC = new Cartesian3();\nconst viewportTransform = new Matrix4();\n\n/**\n * @private\n */\nSceneTransforms.clipToGLWindowCoordinates = function (\n  viewport,\n  position,\n  result\n) {\n  // Perspective divide to transform from clip coordinates to normalized device coordinates\n  Cartesian3.divideByScalar(position, position.w, positionNDC);\n\n  // Viewport transform to transform from clip coordinates to window coordinates\n  Matrix4.computeViewportTransformation(viewport, 0.0, 1.0, viewportTransform);\n  Matrix4.multiplyByPoint(viewportTransform, positionNDC, positionWC);\n\n  return Cartesian2.fromCartesian3(positionWC, result);\n};\n\n/**\n * @private\n */\nSceneTransforms.transformWindowToDrawingBuffer = function (\n  scene,\n  windowPosition,\n  result\n) {\n  const canvas = scene.canvas;\n  const xScale = scene.drawingBufferWidth / canvas.clientWidth;\n  const yScale = scene.drawingBufferHeight / canvas.clientHeight;\n  return Cartesian2.fromElements(\n    windowPosition.x * xScale,\n    windowPosition.y * yScale,\n    result\n  );\n};\n\nconst scratchNDC = new Cartesian4();\nconst scratchWorldCoords = new Cartesian4();\n\n/**\n * @private\n */\nSceneTransforms.drawingBufferToWgs84Coordinates = function (\n  scene,\n  drawingBufferPosition,\n  depth,\n  result\n) {\n  const context = scene.context;\n  const uniformState = context.uniformState;\n\n  const currentFrustum = uniformState.currentFrustum;\n  const near = currentFrustum.x;\n  const far = currentFrustum.y;\n\n  if (scene.frameState.useLogDepth) {\n    // transforming logarithmic depth of form\n    // log2(z + 1) / log2( far + 1);\n    // to perspective form\n    // (far - far * near / z) / (far - near)\n    const log2Depth = depth * uniformState.log2FarDepthFromNearPlusOne;\n    const depthFromNear = Math.pow(2.0, log2Depth) - 1.0;\n    depth = (far * (1.0 - near / (depthFromNear + near))) / (far - near);\n  }\n\n  const viewport = scene.view.passState.viewport;\n  const ndc = Cartesian4.clone(Cartesian4.UNIT_W, scratchNDC);\n  ndc.x = ((drawingBufferPosition.x - viewport.x) / viewport.width) * 2.0 - 1.0;\n  ndc.y =\n    ((drawingBufferPosition.y - viewport.y) / viewport.height) * 2.0 - 1.0;\n  ndc.z = depth * 2.0 - 1.0;\n  ndc.w = 1.0;\n\n  let worldCoords;\n  let frustum = scene.camera.frustum;\n  if (!defined(frustum.fovy)) {\n    if (defined(frustum._offCenterFrustum)) {\n      frustum = frustum._offCenterFrustum;\n    }\n    worldCoords = scratchWorldCoords;\n    worldCoords.x =\n      (ndc.x * (frustum.right - frustum.left) + frustum.left + frustum.right) *\n      0.5;\n    worldCoords.y =\n      (ndc.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) *\n      0.5;\n    worldCoords.z = (ndc.z * (near - far) - near - far) * 0.5;\n    worldCoords.w = 1.0;\n\n    worldCoords = Matrix4.multiplyByVector(\n      uniformState.inverseView,\n      worldCoords,\n      worldCoords\n    );\n  } else {\n    worldCoords = Matrix4.multiplyByVector(\n      uniformState.inverseViewProjection,\n      ndc,\n      scratchWorldCoords\n    );\n\n    // Reverse perspective divide\n    const w = 1.0 / worldCoords.w;\n    Cartesian3.multiplyByScalar(worldCoords, w, worldCoords);\n  }\n  return Cartesian3.fromCartesian4(worldCoords, result);\n};\nexport default SceneTransforms;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport ScreenSpaceEventHandler from \"../Core/ScreenSpaceEventHandler.js\";\nimport ScreenSpaceEventType from \"../Core/ScreenSpaceEventType.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Camera from \"./Camera.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * @private\n */\nfunction SceneTransitioner(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  this._scene = scene;\n  this._currentTweens = [];\n  this._morphHandler = undefined;\n  this._morphCancelled = false;\n  this._completeMorph = undefined;\n  this._morphToOrthographic = false;\n}\n\nSceneTransitioner.prototype.completeMorph = function () {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\n\nSceneTransitioner.prototype.morphTo2D = function (duration, ellipsoid) {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n\n  const scene = this._scene;\n  this._previousMode = scene.mode;\n  this._morphToOrthographic =\n    scene.camera.frustum instanceof OrthographicFrustum;\n\n  if (\n    this._previousMode === SceneMode.SCENE2D ||\n    this._previousMode === SceneMode.MORPHING\n  ) {\n    return;\n  }\n  this._scene.morphStart.raiseEvent(\n    this,\n    this._previousMode,\n    SceneMode.SCENE2D,\n    true\n  );\n\n  scene._mode = SceneMode.MORPHING;\n  scene.camera._setTransform(Matrix4.IDENTITY);\n\n  if (this._previousMode === SceneMode.COLUMBUS_VIEW) {\n    morphFromColumbusViewTo2D(this, duration);\n  } else {\n    morphFrom3DTo2D(this, duration, ellipsoid);\n  }\n\n  if (duration === 0.0 && defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\n\nconst scratchToCVPosition = new Cartesian3();\nconst scratchToCVDirection = new Cartesian3();\nconst scratchToCVUp = new Cartesian3();\nconst scratchToCVPosition2D = new Cartesian3();\nconst scratchToCVDirection2D = new Cartesian3();\nconst scratchToCVUp2D = new Cartesian3();\nconst scratchToCVSurfacePosition = new Cartesian3();\nconst scratchToCVCartographic = new Cartographic();\nconst scratchToCVToENU = new Matrix4();\nconst scratchToCVFrustumPerspective = new PerspectiveFrustum();\nconst scratchToCVFrustumOrthographic = new OrthographicFrustum();\nconst scratchToCVCamera = {\n  position: undefined,\n  direction: undefined,\n  up: undefined,\n  position2D: undefined,\n  direction2D: undefined,\n  up2D: undefined,\n  frustum: undefined,\n};\n\nSceneTransitioner.prototype.morphToColumbusView = function (\n  duration,\n  ellipsoid\n) {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n\n  const scene = this._scene;\n  this._previousMode = scene.mode;\n\n  if (\n    this._previousMode === SceneMode.COLUMBUS_VIEW ||\n    this._previousMode === SceneMode.MORPHING\n  ) {\n    return;\n  }\n  this._scene.morphStart.raiseEvent(\n    this,\n    this._previousMode,\n    SceneMode.COLUMBUS_VIEW,\n    true\n  );\n\n  scene.camera._setTransform(Matrix4.IDENTITY);\n\n  let position = scratchToCVPosition;\n  const direction = scratchToCVDirection;\n  const up = scratchToCVUp;\n\n  if (duration > 0.0) {\n    position.x = 0.0;\n    position.y = -1.0;\n    position.z = 1.0;\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(position, position),\n      5.0 * ellipsoid.maximumRadius,\n      position\n    );\n\n    Cartesian3.negate(Cartesian3.normalize(position, direction), direction);\n    Cartesian3.cross(Cartesian3.UNIT_X, direction, up);\n  } else {\n    const camera = scene.camera;\n    if (this._previousMode === SceneMode.SCENE2D) {\n      Cartesian3.clone(camera.position, position);\n      position.z = camera.frustum.right - camera.frustum.left;\n      Cartesian3.negate(Cartesian3.UNIT_Z, direction);\n      Cartesian3.clone(Cartesian3.UNIT_Y, up);\n    } else {\n      Cartesian3.clone(camera.positionWC, position);\n      Cartesian3.clone(camera.directionWC, direction);\n      Cartesian3.clone(camera.upWC, up);\n\n      const surfacePoint = ellipsoid.scaleToGeodeticSurface(\n        position,\n        scratchToCVSurfacePosition\n      );\n      const toENU = Transforms.eastNorthUpToFixedFrame(\n        surfacePoint,\n        ellipsoid,\n        scratchToCVToENU\n      );\n      Matrix4.inverseTransformation(toENU, toENU);\n\n      scene.mapProjection.project(\n        ellipsoid.cartesianToCartographic(position, scratchToCVCartographic),\n        position\n      );\n      Matrix4.multiplyByPointAsVector(toENU, direction, direction);\n      Matrix4.multiplyByPointAsVector(toENU, up, up);\n    }\n  }\n\n  let frustum;\n  if (this._morphToOrthographic) {\n    frustum = scratchToCVFrustumOrthographic;\n    frustum.width = scene.camera.frustum.right - scene.camera.frustum.left;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  } else {\n    frustum = scratchToCVFrustumPerspective;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n    frustum.fov = CesiumMath.toRadians(60.0);\n  }\n\n  const cameraCV = scratchToCVCamera;\n  cameraCV.position = position;\n  cameraCV.direction = direction;\n  cameraCV.up = up;\n  cameraCV.frustum = frustum;\n\n  const complete = completeColumbusViewCallback(cameraCV);\n  createMorphHandler(this, complete);\n\n  if (this._previousMode === SceneMode.SCENE2D) {\n    morphFrom2DToColumbusView(this, duration, cameraCV, complete);\n  } else {\n    cameraCV.position2D = Matrix4.multiplyByPoint(\n      Camera.TRANSFORM_2D,\n      position,\n      scratchToCVPosition2D\n    );\n    cameraCV.direction2D = Matrix4.multiplyByPointAsVector(\n      Camera.TRANSFORM_2D,\n      direction,\n      scratchToCVDirection2D\n    );\n    cameraCV.up2D = Matrix4.multiplyByPointAsVector(\n      Camera.TRANSFORM_2D,\n      up,\n      scratchToCVUp2D\n    );\n\n    scene._mode = SceneMode.MORPHING;\n    morphFrom3DToColumbusView(this, duration, cameraCV, complete);\n  }\n\n  if (duration === 0.0 && defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\n\nconst scratchCVTo3DCamera = {\n  position: new Cartesian3(),\n  direction: new Cartesian3(),\n  up: new Cartesian3(),\n  frustum: undefined,\n};\nconst scratch2DTo3DFrustumPersp = new PerspectiveFrustum();\n\nSceneTransitioner.prototype.morphTo3D = function (duration, ellipsoid) {\n  if (defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n\n  const scene = this._scene;\n  this._previousMode = scene.mode;\n\n  if (\n    this._previousMode === SceneMode.SCENE3D ||\n    this._previousMode === SceneMode.MORPHING\n  ) {\n    return;\n  }\n  this._scene.morphStart.raiseEvent(\n    this,\n    this._previousMode,\n    SceneMode.SCENE3D,\n    true\n  );\n\n  scene._mode = SceneMode.MORPHING;\n  scene.camera._setTransform(Matrix4.IDENTITY);\n\n  if (this._previousMode === SceneMode.SCENE2D) {\n    morphFrom2DTo3D(this, duration, ellipsoid);\n  } else {\n    let camera3D;\n    if (duration > 0.0) {\n      camera3D = scratchCVTo3DCamera;\n      Cartesian3.fromDegrees(\n        0.0,\n        0.0,\n        5.0 * ellipsoid.maximumRadius,\n        ellipsoid,\n        camera3D.position\n      );\n      Cartesian3.negate(camera3D.position, camera3D.direction);\n      Cartesian3.normalize(camera3D.direction, camera3D.direction);\n      Cartesian3.clone(Cartesian3.UNIT_Z, camera3D.up);\n    } else {\n      camera3D = getColumbusViewTo3DCamera(this, ellipsoid);\n    }\n\n    let frustum;\n    const camera = scene.camera;\n    if (camera.frustum instanceof OrthographicFrustum) {\n      frustum = camera.frustum.clone();\n    } else {\n      frustum = scratch2DTo3DFrustumPersp;\n      frustum.aspectRatio =\n        scene.drawingBufferWidth / scene.drawingBufferHeight;\n      frustum.fov = CesiumMath.toRadians(60.0);\n    }\n    camera3D.frustum = frustum;\n\n    const complete = complete3DCallback(camera3D);\n    createMorphHandler(this, complete);\n\n    morphFromColumbusViewTo3D(this, duration, camera3D, complete);\n  }\n\n  if (duration === 0.0 && defined(this._completeMorph)) {\n    this._completeMorph();\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nSceneTransitioner.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * transitioner = transitioner && transitioner.destroy();\n */\nSceneTransitioner.prototype.destroy = function () {\n  destroyMorphHandler(this);\n  return destroyObject(this);\n};\n\nfunction createMorphHandler(transitioner, completeMorphFunction) {\n  if (transitioner._scene.completeMorphOnUserInput) {\n    transitioner._morphHandler = new ScreenSpaceEventHandler(\n      transitioner._scene.canvas\n    );\n\n    const completeMorph = function () {\n      transitioner._morphCancelled = true;\n      transitioner._scene.camera.cancelFlight();\n      completeMorphFunction(transitioner);\n    };\n    transitioner._completeMorph = completeMorph;\n    transitioner._morphHandler.setInputAction(\n      completeMorph,\n      ScreenSpaceEventType.LEFT_DOWN\n    );\n    transitioner._morphHandler.setInputAction(\n      completeMorph,\n      ScreenSpaceEventType.MIDDLE_DOWN\n    );\n    transitioner._morphHandler.setInputAction(\n      completeMorph,\n      ScreenSpaceEventType.RIGHT_DOWN\n    );\n    transitioner._morphHandler.setInputAction(\n      completeMorph,\n      ScreenSpaceEventType.WHEEL\n    );\n  }\n}\n\nfunction destroyMorphHandler(transitioner) {\n  const tweens = transitioner._currentTweens;\n  for (let i = 0; i < tweens.length; ++i) {\n    tweens[i].cancelTween();\n  }\n  transitioner._currentTweens.length = 0;\n  transitioner._morphHandler =\n    transitioner._morphHandler && transitioner._morphHandler.destroy();\n}\n\nconst scratchCVTo3DCartographic = new Cartographic();\nconst scratchCVTo3DSurfacePoint = new Cartesian3();\nconst scratchCVTo3DFromENU = new Matrix4();\n\nfunction getColumbusViewTo3DCamera(transitioner, ellipsoid) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const camera3D = scratchCVTo3DCamera;\n  const position = camera3D.position;\n  const direction = camera3D.direction;\n  const up = camera3D.up;\n\n  const positionCarto = scene.mapProjection.unproject(\n    camera.position,\n    scratchCVTo3DCartographic\n  );\n  ellipsoid.cartographicToCartesian(positionCarto, position);\n  const surfacePoint = ellipsoid.scaleToGeodeticSurface(\n    position,\n    scratchCVTo3DSurfacePoint\n  );\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    surfacePoint,\n    ellipsoid,\n    scratchCVTo3DFromENU\n  );\n\n  Matrix4.multiplyByPointAsVector(fromENU, camera.direction, direction);\n  Matrix4.multiplyByPointAsVector(fromENU, camera.up, up);\n\n  return camera3D;\n}\n\nconst scratchCVTo3DStartPos = new Cartesian3();\nconst scratchCVTo3DStartDir = new Cartesian3();\nconst scratchCVTo3DStartUp = new Cartesian3();\nconst scratchCVTo3DEndPos = new Cartesian3();\nconst scratchCVTo3DEndDir = new Cartesian3();\nconst scratchCVTo3DEndUp = new Cartesian3();\n\nfunction morphFromColumbusViewTo3D(\n  transitioner,\n  duration,\n  endCamera,\n  complete\n) {\n  duration *= 0.5;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const startPos = Cartesian3.clone(camera.position, scratchCVTo3DStartPos);\n  const startDir = Cartesian3.clone(camera.direction, scratchCVTo3DStartDir);\n  const startUp = Cartesian3.clone(camera.up, scratchCVTo3DStartUp);\n\n  const endPos = Matrix4.multiplyByPoint(\n    Camera.TRANSFORM_2D_INVERSE,\n    endCamera.position,\n    scratchCVTo3DEndPos\n  );\n  const endDir = Matrix4.multiplyByPointAsVector(\n    Camera.TRANSFORM_2D_INVERSE,\n    endCamera.direction,\n    scratchCVTo3DEndDir\n  );\n  const endUp = Matrix4.multiplyByPointAsVector(\n    Camera.TRANSFORM_2D_INVERSE,\n    endCamera.up,\n    scratchCVTo3DEndUp\n  );\n\n  function update(value) {\n    columbusViewMorph(startPos, endPos, value.time, camera.position);\n    columbusViewMorph(startDir, endDir, value.time, camera.direction);\n    columbusViewMorph(startUp, endUp, value.time, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n  }\n\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: update,\n    complete: function () {\n      addMorphTimeAnimations(transitioner, scene, 0.0, 1.0, duration, complete);\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nconst scratch2DTo3DFrustumOrtho = new OrthographicFrustum();\nconst scratch3DToCVStartPos = new Cartesian3();\nconst scratch3DToCVStartDir = new Cartesian3();\nconst scratch3DToCVStartUp = new Cartesian3();\nconst scratch3DToCVEndPos = new Cartesian3();\nconst scratch3DToCVEndDir = new Cartesian3();\nconst scratch3DToCVEndUp = new Cartesian3();\n\nfunction morphFrom2DTo3D(transitioner, duration, ellipsoid) {\n  duration /= 3.0;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  let camera3D;\n  if (duration > 0.0) {\n    camera3D = scratchCVTo3DCamera;\n    Cartesian3.fromDegrees(\n      0.0,\n      0.0,\n      5.0 * ellipsoid.maximumRadius,\n      ellipsoid,\n      camera3D.position\n    );\n    Cartesian3.negate(camera3D.position, camera3D.direction);\n    Cartesian3.normalize(camera3D.direction, camera3D.direction);\n    Cartesian3.clone(Cartesian3.UNIT_Z, camera3D.up);\n  } else {\n    camera.position.z = camera.frustum.right - camera.frustum.left;\n\n    camera3D = getColumbusViewTo3DCamera(transitioner, ellipsoid);\n  }\n\n  let frustum;\n  if (transitioner._morphToOrthographic) {\n    frustum = scratch2DTo3DFrustumOrtho;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n    frustum.width = camera.frustum.right - camera.frustum.left;\n  } else {\n    frustum = scratch2DTo3DFrustumPersp;\n    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n    frustum.fov = CesiumMath.toRadians(60.0);\n  }\n\n  camera3D.frustum = frustum;\n\n  const complete = complete3DCallback(camera3D);\n  createMorphHandler(transitioner, complete);\n\n  let morph;\n  if (transitioner._morphToOrthographic) {\n    morph = function () {\n      morphFromColumbusViewTo3D(transitioner, duration, camera3D, complete);\n    };\n  } else {\n    morph = function () {\n      morphOrthographicToPerspective(\n        transitioner,\n        duration,\n        camera3D,\n        function () {\n          morphFromColumbusViewTo3D(transitioner, duration, camera3D, complete);\n        }\n      );\n    };\n  }\n\n  if (duration > 0.0) {\n    scene._mode = SceneMode.SCENE2D;\n    camera.flyTo({\n      duration: duration,\n      destination: Cartesian3.fromDegrees(\n        0.0,\n        0.0,\n        5.0 * ellipsoid.maximumRadius,\n        ellipsoid,\n        scratch3DToCVEndPos\n      ),\n      complete: function () {\n        scene._mode = SceneMode.MORPHING;\n        morph();\n      },\n    });\n  } else {\n    morph();\n  }\n}\n\nfunction columbusViewMorph(startPosition, endPosition, time, result) {\n  // Just linear for now.\n  return Cartesian3.lerp(startPosition, endPosition, time, result);\n}\n\nfunction morphPerspectiveToOrthographic(\n  transitioner,\n  duration,\n  endCamera,\n  updateHeight,\n  complete\n) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    return;\n  }\n\n  const startFOV = camera.frustum.fov;\n  const endFOV = CesiumMath.RADIANS_PER_DEGREE * 0.5;\n  const d = endCamera.position.z * Math.tan(startFOV * 0.5);\n  camera.frustum.far = d / Math.tan(endFOV * 0.5) + 10000000.0;\n\n  function update(value) {\n    camera.frustum.fov = CesiumMath.lerp(startFOV, endFOV, value.time);\n    const height = d / Math.tan(camera.frustum.fov * 0.5);\n    updateHeight(camera, height);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: update,\n    complete: function () {\n      camera.frustum = endCamera.frustum.clone();\n      complete(transitioner);\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nconst scratchCVTo2DStartPos = new Cartesian3();\nconst scratchCVTo2DStartDir = new Cartesian3();\nconst scratchCVTo2DStartUp = new Cartesian3();\nconst scratchCVTo2DEndPos = new Cartesian3();\nconst scratchCVTo2DEndDir = new Cartesian3();\nconst scratchCVTo2DEndUp = new Cartesian3();\nconst scratchCVTo2DFrustum = new OrthographicOffCenterFrustum();\nconst scratchCVTo2DRay = new Ray();\nconst scratchCVTo2DPickPos = new Cartesian3();\nconst scratchCVTo2DCamera = {\n  position: undefined,\n  direction: undefined,\n  up: undefined,\n  frustum: undefined,\n};\n\nfunction morphFromColumbusViewTo2D(transitioner, duration) {\n  duration *= 0.5;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const startPos = Cartesian3.clone(camera.position, scratchCVTo2DStartPos);\n  const startDir = Cartesian3.clone(camera.direction, scratchCVTo2DStartDir);\n  const startUp = Cartesian3.clone(camera.up, scratchCVTo2DStartUp);\n\n  const endDir = Cartesian3.negate(Cartesian3.UNIT_Z, scratchCVTo2DEndDir);\n  const endUp = Cartesian3.clone(Cartesian3.UNIT_Y, scratchCVTo2DEndUp);\n\n  const endPos = scratchCVTo2DEndPos;\n\n  if (duration > 0.0) {\n    Cartesian3.clone(Cartesian3.ZERO, scratchCVTo2DEndPos);\n    endPos.z = 5.0 * scene.mapProjection.ellipsoid.maximumRadius;\n  } else {\n    Cartesian3.clone(startPos, scratchCVTo2DEndPos);\n\n    const ray = scratchCVTo2DRay;\n    Matrix4.multiplyByPoint(Camera.TRANSFORM_2D, startPos, ray.origin);\n    Matrix4.multiplyByPointAsVector(\n      Camera.TRANSFORM_2D,\n      startDir,\n      ray.direction\n    );\n\n    const globe = scene.globe;\n    if (defined(globe)) {\n      const pickPos = globe.pickWorldCoordinates(\n        ray,\n        scene,\n        true,\n        scratchCVTo2DPickPos\n      );\n      if (defined(pickPos)) {\n        Matrix4.multiplyByPoint(Camera.TRANSFORM_2D_INVERSE, pickPos, endPos);\n        endPos.z += Cartesian3.distance(startPos, endPos);\n      }\n    }\n  }\n\n  const frustum = scratchCVTo2DFrustum;\n  frustum.right = endPos.z * 0.5;\n  frustum.left = -frustum.right;\n  frustum.top =\n    frustum.right * (scene.drawingBufferHeight / scene.drawingBufferWidth);\n  frustum.bottom = -frustum.top;\n\n  const camera2D = scratchCVTo2DCamera;\n  camera2D.position = endPos;\n  camera2D.direction = endDir;\n  camera2D.up = endUp;\n  camera2D.frustum = frustum;\n\n  const complete = complete2DCallback(camera2D);\n  createMorphHandler(transitioner, complete);\n\n  function updateCV(value) {\n    columbusViewMorph(startPos, endPos, value.time, camera.position);\n    columbusViewMorph(startDir, endDir, value.time, camera.direction);\n    columbusViewMorph(startUp, endUp, value.time, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n    camera._adjustOrthographicFrustum(true);\n  }\n\n  function updateHeight(camera, height) {\n    camera.position.z = height;\n  }\n\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: updateCV,\n    complete: function () {\n      morphPerspectiveToOrthographic(\n        transitioner,\n        duration,\n        camera2D,\n        updateHeight,\n        complete\n      );\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nconst scratch3DTo2DCartographic = new Cartographic();\nconst scratch3DTo2DCamera = {\n  position: new Cartesian3(),\n  direction: new Cartesian3(),\n  up: new Cartesian3(),\n  position2D: new Cartesian3(),\n  direction2D: new Cartesian3(),\n  up2D: new Cartesian3(),\n  frustum: new OrthographicOffCenterFrustum(),\n};\nconst scratch3DTo2DEndCamera = {\n  position: new Cartesian3(),\n  direction: new Cartesian3(),\n  up: new Cartesian3(),\n  frustum: undefined,\n};\nconst scratch3DTo2DPickPosition = new Cartesian3();\nconst scratch3DTo2DRay = new Ray();\nconst scratch3DTo2DToENU = new Matrix4();\nconst scratch3DTo2DSurfacePoint = new Cartesian3();\n\nfunction morphFrom3DTo2D(transitioner, duration, ellipsoid) {\n  duration *= 0.5;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n  const camera2D = scratch3DTo2DCamera;\n\n  if (duration > 0.0) {\n    Cartesian3.clone(Cartesian3.ZERO, camera2D.position);\n    camera2D.position.z = 5.0 * ellipsoid.maximumRadius;\n    Cartesian3.negate(Cartesian3.UNIT_Z, camera2D.direction);\n    Cartesian3.clone(Cartesian3.UNIT_Y, camera2D.up);\n  } else {\n    ellipsoid.cartesianToCartographic(\n      camera.positionWC,\n      scratch3DTo2DCartographic\n    );\n    scene.mapProjection.project(scratch3DTo2DCartographic, camera2D.position);\n\n    Cartesian3.negate(Cartesian3.UNIT_Z, camera2D.direction);\n    Cartesian3.clone(Cartesian3.UNIT_Y, camera2D.up);\n\n    const ray = scratch3DTo2DRay;\n    Cartesian3.clone(camera2D.position2D, ray.origin);\n    const rayDirection = Cartesian3.clone(camera.directionWC, ray.direction);\n    const surfacePoint = ellipsoid.scaleToGeodeticSurface(\n      camera.positionWC,\n      scratch3DTo2DSurfacePoint\n    );\n    const toENU = Transforms.eastNorthUpToFixedFrame(\n      surfacePoint,\n      ellipsoid,\n      scratch3DTo2DToENU\n    );\n    Matrix4.inverseTransformation(toENU, toENU);\n    Matrix4.multiplyByPointAsVector(toENU, rayDirection, rayDirection);\n    Matrix4.multiplyByPointAsVector(\n      Camera.TRANSFORM_2D,\n      rayDirection,\n      rayDirection\n    );\n\n    const globe = scene.globe;\n    if (defined(globe)) {\n      const pickedPos = globe.pickWorldCoordinates(\n        ray,\n        scene,\n        true,\n        scratch3DTo2DPickPosition\n      );\n      if (defined(pickedPos)) {\n        const height = Cartesian3.distance(camera2D.position2D, pickedPos);\n        pickedPos.x += height;\n        Cartesian3.clone(pickedPos, camera2D.position2D);\n      }\n    }\n  }\n\n  function updateHeight(camera, height) {\n    camera.position.x = height;\n  }\n\n  Matrix4.multiplyByPoint(\n    Camera.TRANSFORM_2D,\n    camera2D.position,\n    camera2D.position2D\n  );\n  Matrix4.multiplyByPointAsVector(\n    Camera.TRANSFORM_2D,\n    camera2D.direction,\n    camera2D.direction2D\n  );\n  Matrix4.multiplyByPointAsVector(\n    Camera.TRANSFORM_2D,\n    camera2D.up,\n    camera2D.up2D\n  );\n\n  const frustum = camera2D.frustum;\n  frustum.right = camera2D.position.z * 0.5;\n  frustum.left = -frustum.right;\n  frustum.top =\n    frustum.right * (scene.drawingBufferHeight / scene.drawingBufferWidth);\n  frustum.bottom = -frustum.top;\n\n  const endCamera = scratch3DTo2DEndCamera;\n  Matrix4.multiplyByPoint(\n    Camera.TRANSFORM_2D_INVERSE,\n    camera2D.position2D,\n    endCamera.position\n  );\n  Cartesian3.clone(camera2D.direction, endCamera.direction);\n  Cartesian3.clone(camera2D.up, endCamera.up);\n  endCamera.frustum = frustum;\n\n  const complete = complete2DCallback(endCamera);\n  createMorphHandler(transitioner, complete);\n\n  function completeCallback() {\n    morphPerspectiveToOrthographic(\n      transitioner,\n      duration,\n      camera2D,\n      updateHeight,\n      complete\n    );\n  }\n  morphFrom3DToColumbusView(transitioner, duration, camera2D, completeCallback);\n}\n\nfunction morphOrthographicToPerspective(\n  transitioner,\n  duration,\n  cameraCV,\n  complete\n) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const height = camera.frustum.right - camera.frustum.left;\n  camera.frustum = cameraCV.frustum.clone();\n\n  const endFOV = camera.frustum.fov;\n  const startFOV = CesiumMath.RADIANS_PER_DEGREE * 0.5;\n  const d = height * Math.tan(endFOV * 0.5);\n  camera.frustum.far = d / Math.tan(startFOV * 0.5) + 10000000.0;\n  camera.frustum.fov = startFOV;\n\n  function update(value) {\n    camera.frustum.fov = CesiumMath.lerp(startFOV, endFOV, value.time);\n    camera.position.z = d / Math.tan(camera.frustum.fov * 0.5);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: update,\n    complete: function () {\n      complete(transitioner);\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nfunction morphFrom2DToColumbusView(transitioner, duration, cameraCV, complete) {\n  duration *= 0.5;\n\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const endPos = Cartesian3.clone(cameraCV.position, scratch3DToCVEndPos);\n  const endDir = Cartesian3.clone(cameraCV.direction, scratch3DToCVEndDir);\n  const endUp = Cartesian3.clone(cameraCV.up, scratch3DToCVEndUp);\n\n  scene._mode = SceneMode.MORPHING;\n\n  function morph() {\n    camera.frustum = cameraCV.frustum.clone();\n\n    const startPos = Cartesian3.clone(camera.position, scratch3DToCVStartPos);\n    const startDir = Cartesian3.clone(camera.direction, scratch3DToCVStartDir);\n    const startUp = Cartesian3.clone(camera.up, scratch3DToCVStartUp);\n    startPos.z = endPos.z;\n\n    function update(value) {\n      columbusViewMorph(startPos, endPos, value.time, camera.position);\n      columbusViewMorph(startDir, endDir, value.time, camera.direction);\n      columbusViewMorph(startUp, endUp, value.time, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n    const tween = scene.tweens.add({\n      duration: duration,\n      easingFunction: EasingFunction.QUARTIC_OUT,\n      startObject: {\n        time: 0.0,\n      },\n      stopObject: {\n        time: 1.0,\n      },\n      update: update,\n      complete: function () {\n        complete(transitioner);\n      },\n    });\n    transitioner._currentTweens.push(tween);\n  }\n\n  if (transitioner._morphToOrthographic) {\n    morph();\n  } else {\n    morphOrthographicToPerspective(transitioner, 0.0, cameraCV, morph);\n  }\n}\n\nfunction morphFrom3DToColumbusView(\n  transitioner,\n  duration,\n  endCamera,\n  complete\n) {\n  const scene = transitioner._scene;\n  const camera = scene.camera;\n\n  const startPos = Cartesian3.clone(camera.position, scratch3DToCVStartPos);\n  const startDir = Cartesian3.clone(camera.direction, scratch3DToCVStartDir);\n  const startUp = Cartesian3.clone(camera.up, scratch3DToCVStartUp);\n\n  const endPos = Cartesian3.clone(endCamera.position2D, scratch3DToCVEndPos);\n  const endDir = Cartesian3.clone(endCamera.direction2D, scratch3DToCVEndDir);\n  const endUp = Cartesian3.clone(endCamera.up2D, scratch3DToCVEndUp);\n\n  function update(value) {\n    columbusViewMorph(startPos, endPos, value.time, camera.position);\n    columbusViewMorph(startDir, endDir, value.time, camera.direction);\n    columbusViewMorph(startUp, endUp, value.time, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n    camera._adjustOrthographicFrustum(true);\n  }\n  const tween = scene.tweens.add({\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    update: update,\n    complete: function () {\n      addMorphTimeAnimations(transitioner, scene, 1.0, 0.0, duration, complete);\n    },\n  });\n  transitioner._currentTweens.push(tween);\n}\n\nfunction addMorphTimeAnimations(\n  transitioner,\n  scene,\n  start,\n  stop,\n  duration,\n  complete\n) {\n  // Later, this will be linear and each object will adjust, if desired, in its vertex shader.\n  const options = {\n    object: scene,\n    property: \"morphTime\",\n    startValue: start,\n    stopValue: stop,\n    duration: duration,\n    easingFunction: EasingFunction.QUARTIC_OUT,\n  };\n\n  if (defined(complete)) {\n    options.complete = function () {\n      complete(transitioner);\n    };\n  }\n\n  const tween = scene.tweens.addProperty(options);\n  transitioner._currentTweens.push(tween);\n}\n\nfunction complete3DCallback(camera3D) {\n  return function (transitioner) {\n    const scene = transitioner._scene;\n    scene._mode = SceneMode.SCENE3D;\n    scene.morphTime = SceneMode.getMorphTime(SceneMode.SCENE3D);\n\n    destroyMorphHandler(transitioner);\n\n    const camera = scene.camera;\n    if (\n      transitioner._previousMode !== SceneMode.MORPHING ||\n      transitioner._morphCancelled\n    ) {\n      transitioner._morphCancelled = false;\n\n      Cartesian3.clone(camera3D.position, camera.position);\n      Cartesian3.clone(camera3D.direction, camera.direction);\n      Cartesian3.clone(camera3D.up, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.right, camera.right);\n\n      camera.frustum = camera3D.frustum.clone();\n    }\n\n    const frustum = camera.frustum;\n    if (scene.frameState.useLogDepth) {\n      frustum.near = 0.1;\n      frustum.far = 10000000000.0;\n    }\n\n    const wasMorphing = defined(transitioner._completeMorph);\n    transitioner._completeMorph = undefined;\n    scene.camera.update(scene.mode);\n    transitioner._scene.morphComplete.raiseEvent(\n      transitioner,\n      transitioner._previousMode,\n      SceneMode.SCENE3D,\n      wasMorphing\n    );\n  };\n}\n\nfunction complete2DCallback(camera2D) {\n  return function (transitioner) {\n    const scene = transitioner._scene;\n\n    scene._mode = SceneMode.SCENE2D;\n    scene.morphTime = SceneMode.getMorphTime(SceneMode.SCENE2D);\n\n    destroyMorphHandler(transitioner);\n\n    const camera = scene.camera;\n    Cartesian3.clone(camera2D.position, camera.position);\n    camera.position.z = scene.mapProjection.ellipsoid.maximumRadius * 2.0;\n    Cartesian3.clone(camera2D.direction, camera.direction);\n    Cartesian3.clone(camera2D.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.normalize(camera.right, camera.right);\n    camera.frustum = camera2D.frustum.clone();\n\n    const wasMorphing = defined(transitioner._completeMorph);\n    transitioner._completeMorph = undefined;\n    scene.camera.update(scene.mode);\n    transitioner._scene.morphComplete.raiseEvent(\n      transitioner,\n      transitioner._previousMode,\n      SceneMode.SCENE2D,\n      wasMorphing\n    );\n  };\n}\n\nfunction completeColumbusViewCallback(cameraCV) {\n  return function (transitioner) {\n    const scene = transitioner._scene;\n    scene._mode = SceneMode.COLUMBUS_VIEW;\n    scene.morphTime = SceneMode.getMorphTime(SceneMode.COLUMBUS_VIEW);\n\n    destroyMorphHandler(transitioner);\n\n    const camera = scene.camera;\n    if (\n      transitioner._previousModeMode !== SceneMode.MORPHING ||\n      transitioner._morphCancelled\n    ) {\n      transitioner._morphCancelled = false;\n\n      Cartesian3.clone(cameraCV.position, camera.position);\n      Cartesian3.clone(cameraCV.direction, camera.direction);\n      Cartesian3.clone(cameraCV.up, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n\n    const frustum = camera.frustum;\n    if (scene.frameState.useLogDepth) {\n      frustum.near = 0.1;\n      frustum.far = 10000000000.0;\n    }\n\n    const wasMorphing = defined(transitioner._completeMorph);\n    transitioner._completeMorph = undefined;\n    scene.camera.update(scene.mode);\n    transitioner._scene.morphComplete.raiseEvent(\n      transitioner,\n      transitioner._previousMode,\n      SceneMode.COLUMBUS_VIEW,\n      wasMorphing\n    );\n  };\n}\nexport default SceneTransitioner;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport TerrainExaggeration from \"../Core/TerrainExaggeration.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.8\n   */\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {Number}\n   * @default 0.1\n   */\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {Number}\n   * @default 3.0\n   */\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {Number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n  this.zoomEventTypes = [\n    CameraEventType.RIGHT_DRAG,\n    CameraEventType.WHEEL,\n    CameraEventType.PINCH,\n  ];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n  this.tiltEventTypes = [\n    CameraEventType.MIDDLE_DRAG,\n    CameraEventType.PINCH,\n    {\n      eventType: CameraEventType.LEFT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n    {\n      eventType: CameraEventType.RIGHT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n  ];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT,\n  };\n  /**\n   * The minimum height the camera must be before picking the terrain instead of the ellipsoid.\n   * @type {Number}\n   * @default 150000.0\n   */\n  this.minimumPickingTerrainHeight = 150000.0;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain.\n   * @type {Number}\n   * @default 15000.0\n   */\n  this.minimumCollisionTerrainHeight = 15000.0;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky or in space.\n   * @type {Number}\n   * @default 7500000.0\n   */\n  this.minimumTrackBallHeight = 7500000.0;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * Enables or disables camera collision detection with terrain.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableCollisionDetection = true;\n\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = undefined;\n\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined;\n\n  // Zoom disables tilt, spin, and translate inertia\n  // Tilt disables spin and translate inertia\n  this._inertiaDisablers = {\n    _lastInertiaZoomMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n      \"_lastInertiaTiltMovement\",\n    ],\n    _lastInertiaTiltMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n    ],\n  };\n\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n\n  this._horizontalRotationAxis = undefined;\n\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._strafeMousePosition = new Cartesian2();\n  this._strafeEndMousePosition = new Cartesian2();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._zoomingUnderground = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n  this._cameraUnderground = false;\n\n  const projection = scene.mapProjection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO)\n  );\n\n  // Constants, Make any of these public?\n  this._zoomFactor = 5.0;\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n  this._minimumUndergroundPickDistance = 2000.0;\n  this._maximumUndergroundPickDistance = 10000.0;\n}\n\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n\n  const tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\n\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(\n    movement.startPosition,\n    movement.endPosition,\n    CesiumMath.EPSILON14\n  );\n}\n\n// If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\nconst inertiaMaxClickTimeThreshold = 0.4;\n\nfunction maintainInertia(\n  aggregator,\n  type,\n  modifier,\n  decayCoef,\n  action,\n  object,\n  lastMovementName\n) {\n  let movementState = object[lastMovementName];\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      inertiaEnabled: true,\n    };\n  }\n\n  const ts = aggregator.getButtonPressTime(type, modifier);\n  const tr = aggregator.getButtonReleaseTime(type, modifier);\n\n  const threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  const now = new Date();\n  const fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    const d = decay(fromNow, decayCoef);\n\n    const lastMovement = aggregator.getLastMovement(type, modifier);\n    if (\n      !defined(lastMovement) ||\n      sameMousePosition(lastMovement) ||\n      !movementState.inertiaEnabled\n    ) {\n      return;\n    }\n\n    movementState.motion.x =\n      (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n    movementState.motion.y =\n      (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n\n    movementState.startPosition = Cartesian2.clone(\n      lastMovement.startPosition,\n      movementState.startPosition\n    );\n\n    movementState.endPosition = Cartesian2.multiplyByScalar(\n      movementState.motion,\n      d,\n      movementState.endPosition\n    );\n    movementState.endPosition = Cartesian2.add(\n      movementState.startPosition,\n      movementState.endPosition,\n      movementState.endPosition\n    );\n\n    // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n    if (\n      isNaN(movementState.endPosition.x) ||\n      isNaN(movementState.endPosition.y) ||\n      Cartesian2.distance(\n        movementState.startPosition,\n        movementState.endPosition\n      ) < 0.5\n    ) {\n      return;\n    }\n\n    if (!aggregator.isButtonDown(type, modifier)) {\n      const startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  }\n}\n\nfunction activateInertia(controller, inertiaStateName) {\n  if (defined(inertiaStateName)) {\n    // Re-enable inertia if it was disabled\n    let movementState = controller[inertiaStateName];\n    if (defined(movementState)) {\n      movementState.inertiaEnabled = true;\n    }\n    // Disable inertia on other movements\n    const inertiasToDisable = controller._inertiaDisablers[inertiaStateName];\n    if (defined(inertiasToDisable)) {\n      const length = inertiasToDisable.length;\n      for (let i = 0; i < length; ++i) {\n        movementState = controller[inertiasToDisable[i]];\n        if (defined(movementState)) {\n          movementState.inertiaEnabled = false;\n        }\n      }\n    }\n  }\n}\n\nconst scratchEventTypeArray = [];\n\nfunction reactToInput(\n  controller,\n  enabled,\n  eventTypes,\n  action,\n  inertiaConstant,\n  inertiaStateName\n) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n\n  const aggregator = controller._aggregator;\n\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n\n  const length = eventTypes.length;\n  for (let i = 0; i < length; ++i) {\n    const eventType = eventTypes[i];\n    const type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    const modifier = eventType.modifier;\n\n    const movement =\n      aggregator.isMoving(type, modifier) &&\n      aggregator.getMovement(type, modifier);\n    const startPosition = aggregator.getStartMousePosition(type, modifier);\n\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n        activateInertia(controller, inertiaStateName);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(\n          aggregator,\n          type,\n          modifier,\n          inertiaConstant,\n          action,\n          controller,\n          inertiaStateName\n        );\n      }\n    }\n  }\n}\n\nconst scratchZoomPickRay = new Ray();\nconst scratchPickCartesian = new Cartesian3();\nconst scratchZoomOffset = new Cartesian2();\nconst scratchZoomDirection = new Cartesian3();\nconst scratchCenterPixel = new Cartesian2();\nconst scratchCenterPosition = new Cartesian3();\nconst scratchPositionNormal = new Cartesian3();\nconst scratchPickNormal = new Cartesian3();\nconst scratchZoomAxis = new Cartesian3();\nconst scratchCameraPositionNormal = new Cartesian3();\n\n// Scratch variables used in zooming algorithm\nconst scratchTargetNormal = new Cartesian3();\nconst scratchCameraPosition = new Cartesian3();\nconst scratchCameraUpNormal = new Cartesian3();\nconst scratchCameraRightNormal = new Cartesian3();\nconst scratchForwardNormal = new Cartesian3();\nconst scratchPositionToTarget = new Cartesian3();\nconst scratchPositionToTargetNormal = new Cartesian3();\nconst scratchPan = new Cartesian3();\nconst scratchCenterMovement = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchCartesian = new Cartesian3();\nconst scratchCartesianTwo = new Cartesian3();\nconst scratchCartesianThree = new Cartesian3();\nconst scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll(),\n};\n\nfunction handleZoom(\n  object,\n  startPosition,\n  movement,\n  zoomFactor,\n  distanceMeasure,\n  unitPositionDotDirection\n) {\n  let percentage = 1.0;\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(\n      Math.abs(unitPositionDotDirection),\n      0.25,\n      1.0\n    );\n  }\n\n  const diff = movement.endPosition.y - movement.startPosition.y;\n\n  // distanceMeasure should be the height above the ellipsoid.\n  // When approaching the surface, the zoomRate slows and stops minimumZoomDistance above it.\n  const approachingSurface = diff > 0;\n  const minHeight = approachingSurface\n    ? object.minimumZoomDistance * percentage\n    : 0;\n  const maxHeight = object.maximumZoomDistance;\n\n  const minDistance = distanceMeasure - minHeight;\n  let zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(\n    zoomRate,\n    object._minimumZoomRate,\n    object._maximumZoomRate\n  );\n\n  let rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  let distance = zoomRate * rangeWindowRatio;\n\n  if (\n    object.enableCollisionDetection ||\n    object.minimumZoomDistance === 0.0 ||\n    !defined(object._globe) // look-at mode\n  ) {\n    if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n      return;\n    }\n\n    if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n      return;\n    }\n\n    if (distanceMeasure - distance < minHeight) {\n      distance = distanceMeasure - minHeight - 1.0;\n    } else if (distanceMeasure - distance > maxHeight) {\n      distance = distanceMeasure - maxHeight;\n    }\n  }\n\n  const scene = object._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n\n  const orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    if (Math.abs(distance) > 0.0) {\n      camera.zoomIn(distance);\n      camera._adjustOrthographicFrustum();\n    }\n    return;\n  }\n\n  const sameStartPosition = Cartesian2.equals(\n    startPosition,\n    object._zoomMouseStart\n  );\n  let zoomingOnVector = object._zoomingOnVector;\n  let rotatingZoom = object._rotatingZoom;\n  let pickedPosition;\n\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(\n      startPosition,\n      object._zoomMouseStart\n    );\n\n    if (defined(object._globe)) {\n      if (mode === SceneMode.SCENE2D) {\n        pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay)\n          .origin;\n        pickedPosition = Cartesian3.fromElements(\n          pickedPosition.y,\n          pickedPosition.z,\n          pickedPosition.x\n        );\n      } else {\n        pickedPosition = pickGlobe(object, startPosition, scratchPickCartesian);\n      }\n    }\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(\n        pickedPosition,\n        object._zoomWorldPosition\n      );\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n    object._zoomingUnderground = object._cameraUnderground;\n  }\n\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n\n  let zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      const worldPosition = object._zoomWorldPosition;\n      const endPosition = camera.position;\n\n      if (\n        !Cartesian3.equals(worldPosition, endPosition) &&\n        camera.positionCartographic.height < object._maxCoord.x * 2.0\n      ) {\n        const savedX = camera.position.x;\n\n        const direction = Cartesian3.subtract(\n          worldPosition,\n          endPosition,\n          scratchZoomDirection\n        );\n        Cartesian3.normalize(direction, direction);\n\n        const d =\n          (Cartesian3.distance(worldPosition, endPosition) * distance) /\n          (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n\n        if (\n          (camera.position.x < 0.0 && savedX > 0.0) ||\n          (camera.position.x > 0.0 && savedX < 0.0)\n        ) {\n          pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay)\n            .origin;\n          pickedPosition = Cartesian3.fromElements(\n            pickedPosition.y,\n            pickedPosition.z,\n            pickedPosition.x\n          );\n          object._zoomWorldPosition = Cartesian3.clone(\n            pickedPosition,\n            object._zoomWorldPosition\n          );\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      const cameraPositionNormal = Cartesian3.normalize(\n        camera.position,\n        scratchCameraPositionNormal\n      );\n      if (\n        object._cameraUnderground ||\n        object._zoomingUnderground ||\n        (camera.positionCartographic.height < 3000.0 &&\n          Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) <\n            0.6)\n      ) {\n        zoomOnVector = true;\n      } else {\n        const canvas = scene.canvas;\n\n        const centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        const centerPosition = pickGlobe(\n          object,\n          centerPixel,\n          scratchCenterPosition\n        );\n        // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (!defined(centerPosition)) {\n          zoomOnVector = true;\n        } else if (camera.positionCartographic.height < 1000000) {\n          // The math in the else block assumes the camera\n          // points toward the earth surface, so we check it here.\n          // Theoretically, we should check for 90 degree, but it doesn't behave well when parallel\n          // to the earth surface\n          if (Cartesian3.dot(camera.direction, cameraPositionNormal) >= -0.5) {\n            zoomOnVector = true;\n          } else {\n            const cameraPosition = scratchCameraPosition;\n            Cartesian3.clone(camera.position, cameraPosition);\n            const target = object._zoomWorldPosition;\n\n            let targetNormal = scratchTargetNormal;\n\n            targetNormal = Cartesian3.normalize(target, targetNormal);\n\n            if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n              return;\n            }\n\n            const center = scratchCenter;\n            const forward = scratchForwardNormal;\n            Cartesian3.clone(camera.direction, forward);\n            Cartesian3.add(\n              cameraPosition,\n              Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian),\n              center\n            );\n\n            const positionToTarget = scratchPositionToTarget;\n            const positionToTargetNormal = scratchPositionToTargetNormal;\n            Cartesian3.subtract(target, cameraPosition, positionToTarget);\n\n            Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n\n            const alphaDot = Cartesian3.dot(\n              cameraPositionNormal,\n              positionToTargetNormal\n            );\n            if (alphaDot >= 0.0) {\n              // We zoomed past the target, and this zoom is not valid anymore.\n              // This line causes the next zoom movement to pick a new starting point.\n              object._zoomMouseStart.x = -1;\n              return;\n            }\n            const alpha = Math.acos(-alphaDot);\n            const cameraDistance = Cartesian3.magnitude(cameraPosition);\n            const targetDistance = Cartesian3.magnitude(target);\n            const remainingDistance = cameraDistance - distance;\n            const positionToTargetDistance = Cartesian3.magnitude(\n              positionToTarget\n            );\n\n            const gamma = Math.asin(\n              CesiumMath.clamp(\n                (positionToTargetDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0\n              )\n            );\n            const delta = Math.asin(\n              CesiumMath.clamp(\n                (remainingDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0\n              )\n            );\n            const beta = gamma - delta + alpha;\n\n            const up = scratchCameraUpNormal;\n            Cartesian3.normalize(cameraPosition, up);\n            let right = scratchCameraRightNormal;\n            right = Cartesian3.cross(positionToTargetNormal, up, right);\n            right = Cartesian3.normalize(right, right);\n\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward\n            );\n\n            // Calculate new position to move to\n            Cartesian3.multiplyByScalar(\n              Cartesian3.normalize(center, scratchCartesian),\n              Cartesian3.magnitude(center) - distance,\n              center\n            );\n            Cartesian3.normalize(cameraPosition, cameraPosition);\n            Cartesian3.multiplyByScalar(\n              cameraPosition,\n              remainingDistance,\n              cameraPosition\n            );\n\n            // Pan\n            const pMid = scratchPan;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree\n                ),\n                scratchCartesian\n              ),\n              remainingDistance,\n              pMid\n            );\n            Cartesian3.add(cameraPosition, pMid, cameraPosition);\n\n            Cartesian3.normalize(center, up);\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward\n            );\n\n            const cMid = scratchCenterMovement;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree\n                ),\n                scratchCartesian\n              ),\n              Cartesian3.magnitude(center),\n              cMid\n            );\n            Cartesian3.add(center, cMid, center);\n\n            // Update camera\n\n            // Set new position\n            Cartesian3.clone(cameraPosition, camera.position);\n\n            // Set new direction\n            Cartesian3.normalize(\n              Cartesian3.subtract(center, cameraPosition, scratchCartesian),\n              camera.direction\n            );\n            Cartesian3.clone(camera.direction, camera.direction);\n\n            // Set new right & up vectors\n            Cartesian3.cross(camera.direction, camera.up, camera.right);\n            Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n            camera.setView(scratchZoomViewOptions);\n            return;\n          }\n        } else {\n          const positionNormal = Cartesian3.normalize(\n            centerPosition,\n            scratchPositionNormal\n          );\n          const pickedNormal = Cartesian3.normalize(\n            object._zoomWorldPosition,\n            scratchPickNormal\n          );\n          const dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            const angle = CesiumMath.acosClamped(dotProduct);\n            const axis = Cartesian3.cross(\n              pickedNormal,\n              positionNormal,\n              scratchZoomAxis\n            );\n\n            const denom =\n              Math.abs(angle) > CesiumMath.toRadians(20.0)\n                ? camera.positionCartographic.height * 0.75\n                : camera.positionCartographic.height - distance;\n            const scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        }\n      }\n    }\n\n    object._rotatingZoom = !zoomOnVector;\n  }\n\n  if ((!sameStartPosition && zoomOnVector) || zoomingOnVector) {\n    let ray;\n    const zoomMouseStart = SceneTransforms.wgs84ToWindowCoordinates(\n      scene,\n      object._zoomWorldPosition,\n      scratchZoomOffset\n    );\n    if (\n      mode !== SceneMode.COLUMBUS_VIEW &&\n      Cartesian2.equals(startPosition, object._zoomMouseStart) &&\n      defined(zoomMouseStart)\n    ) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n\n    const rayDirection = ray.direction;\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(\n        rayDirection.y,\n        rayDirection.z,\n        rayDirection.x,\n        rayDirection\n      );\n    }\n\n    camera.move(rayDirection, distance);\n\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n\n  if (!object._cameraUnderground) {\n    camera.setView(scratchZoomViewOptions);\n  }\n}\n\nconst translate2DStart = new Ray();\nconst translate2DEnd = new Ray();\nconst scratchTranslateP0 = new Cartesian3();\n\nfunction translate2D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  let start = camera.getPickRay(movement.startPosition, translate2DStart)\n    .origin;\n  let end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n\n  const direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  const distance = Cartesian3.magnitude(direction);\n\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\n\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller._zoomFactor,\n    camera.getMagnitude()\n  );\n}\n\nconst twist2DStart = new Cartesian2();\nconst twist2DEnd = new Cartesian2();\n\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n  const width = canvas.clientWidth;\n  const height = canvas.clientHeight;\n\n  let start = twist2DStart;\n  start.x = (2.0 / width) * movement.startPosition.x - 1.0;\n  start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n\n  let end = twist2DEnd;\n  end.x = (2.0 / width) * movement.endPosition.x - 1.0;\n  end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n\n  let startTheta = CesiumMath.acosClamped(start.x);\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n  let endTheta = CesiumMath.acosClamped(end.x);\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n  const theta = endTheta - startTheta;\n\n  camera.twistRight(theta);\n}\n\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  let rotateRate =\n    controller._rotateFactor * controller._rotateRateRangeAdjustment;\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  let phiWindowRatio =\n    (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n\n  camera.twistRight(deltaPhi);\n}\n\nfunction update2D(controller) {\n  const rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.translateEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaSpinMovement\"\n      );\n    }\n  } else {\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translate2D,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.tiltEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaTiltMovement\"\n      );\n    }\n  }\n}\n\nconst pickGlobeScratchRay = new Ray();\nconst scratchDepthIntersection = new Cartesian3();\nconst scratchRayIntersection = new Cartesian3();\n\nfunction pickGlobe(controller, mousePosition, result) {\n  const scene = controller._scene;\n  const globe = controller._globe;\n  const camera = scene.camera;\n\n  if (!defined(globe)) {\n    return undefined;\n  }\n\n  const cullBackFaces = !controller._cameraUnderground;\n\n  let depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection\n    );\n  }\n\n  const ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  const rayIntersection = globe.pickWorldCoordinates(\n    ray,\n    scene,\n    cullBackFaces,\n    scratchRayIntersection\n  );\n\n  const pickDistance = defined(depthIntersection)\n    ? Cartesian3.distance(depthIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n  const rayDistance = defined(rayIntersection)\n    ? Cartesian3.distance(rayIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  return Cartesian3.clone(rayIntersection, result);\n}\n\nconst scratchDistanceCartographic = new Cartographic();\n\nfunction getDistanceFromSurface(controller) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const mode = scene.mode;\n\n  let height = 0.0;\n  if (mode === SceneMode.SCENE3D) {\n    const cartographic = ellipsoid.cartesianToCartographic(\n      camera.position,\n      scratchDistanceCartographic\n    );\n    if (defined(cartographic)) {\n      height = cartographic.height;\n    }\n  } else {\n    height = camera.position.z;\n  }\n  const globeHeight = defaultValue(controller._scene.globeHeight, 0.0);\n  const distanceFromSurface = Math.abs(globeHeight - height);\n  return distanceFromSurface;\n}\n\nconst scratchSurfaceNormal = new Cartesian3();\n\nfunction getZoomDistanceUnderground(controller, ray) {\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  // Weight zoom distance based on how strongly the pick ray is pointing inward.\n  // Geocentric normal is accurate enough for these purposes\n  const surfaceNormal = Cartesian3.normalize(origin, scratchSurfaceNormal);\n  let strength = Math.abs(Cartesian3.dot(surfaceNormal, direction));\n  strength = Math.max(strength, 0.5) * 2.0;\n  return distanceFromSurface * strength;\n}\n\nfunction getTiltCenterUnderground(controller, ray, pickedPosition, result) {\n  let distance = Cartesian3.distance(ray.origin, pickedPosition);\n  const distanceFromSurface = getDistanceFromSurface(controller);\n\n  const maximumDistance = CesiumMath.clamp(\n    distanceFromSurface * 5.0,\n    controller._minimumUndergroundPickDistance,\n    controller._maximumUndergroundPickDistance\n  );\n\n  if (distance > maximumDistance) {\n    // Simulate look-at behavior by tilting around a small invisible sphere\n    distance = Math.min(distance, distanceFromSurface / 5.0);\n    distance = Math.max(distance, 100.0);\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nfunction getStrafeStartPositionUnderground(\n  controller,\n  ray,\n  pickedPosition,\n  result\n) {\n  let distance;\n  if (!defined(pickedPosition)) {\n    distance = getDistanceFromSurface(controller);\n  } else {\n    distance = Cartesian3.distance(ray.origin, pickedPosition);\n    if (distance > controller._maximumUndergroundPickDistance) {\n      // If the picked position is too far away set the strafe speed based on the\n      // camera's height from the globe surface\n      distance = getDistanceFromSurface(controller);\n    }\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nconst scratchInertialDelta = new Cartesian2();\n\nfunction continueStrafing(controller, movement) {\n  // Update the end position continually based on the inertial delta\n  const originalEndPosition = movement.endPosition;\n  const inertialDelta = Cartesian2.subtract(\n    movement.endPosition,\n    movement.startPosition,\n    scratchInertialDelta\n  );\n  const endPosition = controller._strafeEndMousePosition;\n  Cartesian2.add(endPosition, inertialDelta, endPosition);\n  movement.endPosition = endPosition;\n  strafe(controller, movement, controller._strafeStartPosition);\n  movement.endPosition = originalEndPosition;\n}\n\nconst translateCVStartRay = new Ray();\nconst translateCVEndRay = new Ray();\nconst translateCVStartPos = new Cartesian3();\nconst translateCVEndPos = new Cartesian3();\nconst translateCVDifference = new Cartesian3();\nconst translateCVOrigin = new Cartesian3();\nconst translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst translateCVStartMouse = new Cartesian2();\nconst translateCVEndMouse = new Cartesian2();\n\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  if (controller._strafing) {\n    continueStrafing(controller, movement);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  const startMouse = Cartesian2.clone(\n    movement.startPosition,\n    translateCVStartMouse\n  );\n  const endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  let startRay = camera.getPickRay(startMouse, translateCVStartRay);\n\n  const origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  const normal = Cartesian3.UNIT_X;\n\n  let globePos;\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickGlobe(controller, startMouse, translateCVStartPos);\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n\n  if (\n    cameraUnderground ||\n    (origin.x > camera.position.z && defined(globePos))\n  ) {\n    let pickPosition = globePos;\n    if (cameraUnderground) {\n      pickPosition = getStrafeStartPositionUnderground(\n        controller,\n        startRay,\n        globePos,\n        translateCVStartPos\n      );\n    }\n    Cartesian2.clone(startPosition, controller._strafeMousePosition);\n    Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n    Cartesian3.clone(pickPosition, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, movement, controller._strafeStartPosition);\n    return;\n  }\n\n  const plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  const startPlanePos = IntersectionTests.rayPlane(\n    startRay,\n    plane,\n    translateCVStartPos\n  );\n\n  const endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  const endPlanePos = IntersectionTests.rayPlane(\n    endRay,\n    plane,\n    translateCVEndPos\n  );\n\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n\n  const diff = Cartesian3.subtract(\n    startPlanePos,\n    endPlanePos,\n    translateCVDifference\n  );\n  const temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  const mag = Cartesian3.magnitude(diff);\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\n\nconst rotateCVWindowPos = new Cartesian2();\nconst rotateCVWindowRay = new Ray();\nconst rotateCVCenter = new Cartesian3();\nconst rotateCVVerticalCenter = new Cartesian3();\nconst rotateCVTransform = new Matrix4();\nconst rotateCVVerticalTransform = new Matrix4();\nconst rotateCVOrigin = new Cartesian3();\nconst rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst rotateCVCartesian3 = new Cartesian3();\nconst rotateCVCart = new Cartographic();\nconst rotateCVOldTransform = new Matrix4();\nconst rotateCVQuaternion = new Quaternion();\nconst rotateCVMatrix = new Matrix3();\nconst tilt3DCartesian3 = new Cartesian3();\n\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (\n    controller._tiltCVOffMap ||\n    !controller.onMap() ||\n    Math.abs(camera.position.z) > controller._minimumPickingTerrainHeight\n  ) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\n\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  const normal = Cartesian3.UNIT_X;\n\n  const position = ray.origin;\n  const direction = ray.direction;\n  let scalar;\n  const normalDotDirection = Cartesian3.dot(normal, direction);\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  const center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n\n  const projection = scene.mapProjection;\n  const ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  const cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n\n  let center;\n  let ray;\n  const normal = Cartesian3.UNIT_X;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickGlobe(controller, startPosition, rotateCVCenter);\n    }\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      const position = ray.origin;\n      const direction = ray.direction;\n\n      let scalar;\n      const normalDotDirection = Cartesian3.dot(normal, direction);\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n\n  const origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n\n  const plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  const verticalCenter = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    rotateCVVerticalCenter\n  );\n\n  const projection = camera._projection;\n  const ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  let cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform\n  );\n\n  let verticalTransform;\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(\n      verticalCenter.y,\n      verticalCenter.z,\n      verticalCenter.x,\n      verticalCenter\n    );\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(\n      verticalCenter,\n      ellipsoid,\n      rotateCVVerticalTransform\n    );\n  } else {\n    verticalTransform = transform;\n  }\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  let constrainedAxis = Cartesian3.UNIT_Z;\n\n  const oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  const tangent = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    Cartesian3.normalize(camera.position, rotateCVCartesian3),\n    rotateCVCartesian3\n  );\n  const dot = Cartesian3.dot(camera.right, tangent);\n\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  const originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    rotateCVCartesian3\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position\n      );\n    }\n\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition\n    );\n    Cartesian3.normalize(axis, axis);\n\n    const quaternion = Quaternion.fromAxisAngle(\n      axis,\n      angle,\n      rotateCVQuaternion\n    );\n    const rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nconst zoomCVWindowPos = new Cartesian2();\nconst zoomCVWindowRay = new Ray();\nconst zoomCVIntersection = new Cartesian3();\n\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const cameraUnderground = controller._cameraUnderground;\n\n  let windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  const position = ray.origin;\n  const direction = ray.direction;\n  const height = camera.position.z;\n\n  let intersection;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(position, intersection);\n  }\n\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    const normal = Cartesian3.UNIT_X;\n    distance =\n      -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller._zoomFactor,\n    distance\n  );\n}\n\nfunction updateCV(controller) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableRotate,\n      controller.rotateEventTypes,\n      rotate3D,\n      controller.inertiaSpin,\n      \"_lastInertiaSpinMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom3D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n  } else {\n    const tweens = controller._tweens;\n\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n\n    reactToInput(\n      controller,\n      controller.enableTilt,\n      controller.tiltEventTypes,\n      rotateCV,\n      controller.inertiaSpin,\n      \"_lastInertiaTiltMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translateCV,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoomCV,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableLook,\n      controller.lookEventTypes,\n      look3D\n    );\n\n    if (\n      !controller._aggregator.anyButtonDown &&\n      !tweens.contains(controller._tween)\n    ) {\n      const tween = camera.createCorrectPositionTween(\n        controller.bounceAnimationTime\n      );\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n\n    tweens.update();\n  }\n}\n\nconst scratchStrafeRay = new Ray();\nconst scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst scratchStrafeIntersection = new Cartesian3();\nconst scratchStrafeDirection = new Cartesian3();\nconst scratchMousePos = new Cartesian3();\n\nfunction strafe(controller, movement, strafeStartPosition) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const ray = camera.getPickRay(movement.endPosition, scratchStrafeRay);\n\n  let direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n\n  const plane = Plane.fromPointNormal(\n    strafeStartPosition,\n    direction,\n    scratchStrafePlane\n  );\n  const intersection = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    scratchStrafeIntersection\n  );\n  if (!defined(intersection)) {\n    return;\n  }\n\n  direction = Cartesian3.subtract(strafeStartPosition, intersection, direction);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n\n  Cartesian3.add(camera.position, direction, camera.position);\n}\n\nconst spin3DPick = new Cartesian3();\nconst scratchCartographic = new Cartographic();\nconst scratchRadii = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchLookUp = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n\nfunction spin3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n  let ellipsoid = controller._ellipsoid;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  let magnitude;\n  let radii;\n\n  const up = ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);\n\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      continueStrafing(controller, movement);\n    } else {\n      if (\n        Cartesian3.magnitude(camera.position) <\n        Cartesian3.magnitude(controller._rotateStartPosition)\n      ) {\n        // Pan action is no longer valid if camera moves below the pan ellipsoid\n        return;\n      }\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n    return;\n  }\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    scratchCartographic\n  ).height;\n  const globe = controller._globe;\n\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    const mousePos = pickGlobe(\n      controller,\n      movement.startPosition,\n      scratchMousePos\n    );\n    if (defined(mousePos)) {\n      let strafing = false;\n      const ray = camera.getPickRay(\n        movement.startPosition,\n        pickGlobeScratchRay\n      );\n\n      if (cameraUnderground) {\n        strafing = true;\n        getStrafeStartPositionUnderground(controller, ray, mousePos, mousePos);\n      } else {\n        const normal = ellipsoid.geodeticSurfaceNormal(mousePos, scratchNormal);\n        const tangentPick =\n          Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n\n        if (tangentPick) {\n          strafing = true;\n        } else {\n          strafing =\n            Cartesian3.magnitude(camera.position) <\n            Cartesian3.magnitude(mousePos);\n        }\n      }\n\n      if (strafing) {\n        Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n        controller._strafing = true;\n        strafe(controller, movement, controller._strafeStartPosition);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (\n    defined(\n      camera.pickEllipsoid(\n        movement.startPosition,\n        controller._ellipsoid,\n        spin3DPick\n      )\n    )\n  ) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\n\nfunction rotate3D(\n  controller,\n  startPosition,\n  movement,\n  constrainedAxis,\n  rotateOnlyVertical,\n  rotateOnlyHorizontal\n) {\n  rotateOnlyVertical = defaultValue(rotateOnlyVertical, false);\n  rotateOnlyHorizontal = defaultValue(rotateOnlyHorizontal, false);\n\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const oldAxis = camera.constrainedAxis;\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n\n  const rho = Cartesian3.magnitude(camera.position);\n  let rotateRate =\n    controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  let phiWindowRatio =\n    (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  let thetaWindowRatio =\n    (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(\n    thetaWindowRatio,\n    controller.maximumMovementRatio\n  );\n\n  const deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  const deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n\n  camera.constrainedAxis = oldAxis;\n}\n\nconst pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nconst pan3DTemp0 = new Cartesian3();\nconst pan3DTemp1 = new Cartesian3();\nconst pan3DTemp2 = new Cartesian3();\nconst pan3DTemp3 = new Cartesian3();\nconst pan3DStartMousePosition = new Cartesian2();\nconst pan3DEndMousePosition = new Cartesian2();\n\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const startMousePosition = Cartesian2.clone(\n    movement.startPosition,\n    pan3DStartMousePosition\n  );\n  const endMousePosition = Cartesian2.clone(\n    movement.endPosition,\n    pan3DEndMousePosition\n  );\n\n  let p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n  let p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    const dot = Cartesian3.dot(p0, p1);\n    const axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n\n    if (\n      dot < 1.0 &&\n      !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)\n    ) {\n      // dot is in [0, 1]\n      const angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    const basis0 = camera.constrainedAxis;\n    const basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    const basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n\n    const startRho = Cartesian3.magnitude(p0);\n    const startDot = Cartesian3.dot(basis0, p0);\n    const startTheta = Math.acos(startDot / startRho);\n    const startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n\n    const endRho = Cartesian3.magnitude(p1);\n    const endDot = Cartesian3.dot(basis0, p1);\n    const endTheta = Math.acos(endDot / endRho);\n    const endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n\n    let startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n\n    let endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n\n    const deltaPhi = startPhi - endPhi;\n\n    let east;\n    if (\n      Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)\n    ) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n\n    const planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    const side0 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p0, basis0, pan3DTemp1)\n    );\n    const side1 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p1, basis0, pan3DTemp1)\n    );\n\n    let deltaTheta;\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\n\nconst zoom3DUnitPosition = new Cartesian3();\nconst zoom3DCartographic = new Cartographic();\n\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const canvas = scene.canvas;\n\n  const cameraUnderground = controller._cameraUnderground;\n\n  let windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n\n  let intersection;\n  const height = ellipsoid.cartesianToCartographic(\n    camera.position,\n    zoom3DCartographic\n  ).height;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  let distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n  }\n\n  if (cameraUnderground) {\n    const distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    distance = height;\n  }\n\n  const unitPosition = Cartesian3.normalize(\n    camera.position,\n    zoom3DUnitPosition\n  );\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller._zoomFactor,\n    distance,\n    Cartesian3.dot(unitPosition, camera.direction)\n  );\n}\n\nconst tilt3DWindowPos = new Cartesian2();\nconst tilt3DRay = new Ray();\nconst tilt3DCenter = new Cartesian3();\nconst tilt3DVerticalCenter = new Cartesian3();\nconst tilt3DTransform = new Matrix4();\nconst tilt3DVerticalTransform = new Matrix4();\nconst tilt3DOldTransform = new Matrix4();\nconst tilt3DQuaternion = new Quaternion();\nconst tilt3DMatrix = new Matrix3();\nconst tilt3DCart = new Cartographic();\nconst tilt3DLookUp = new Cartesian3();\n\nfunction tilt3D(controller, startPosition, movement) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    const up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp\n    );\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n\n  const ellipsoid = controller._ellipsoid;\n  const cartographic = ellipsoid.cartesianToCartographic(\n    camera.position,\n    tilt3DCart\n  );\n\n  if (\n    controller._tiltOnEllipsoid ||\n    cartographic.height > controller._minimumCollisionTerrainHeight\n  ) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\n\nconst tilt3DOnEllipsoidCartographic = new Cartographic();\n\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const minHeight = controller.minimumZoomDistance * 0.25;\n  const height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    tilt3DOnEllipsoidCartographic\n  ).height;\n  if (\n    height - minHeight - 1.0 < CesiumMath.EPSILON3 &&\n    movement.endPosition.y - movement.startPosition.y < 0\n  ) {\n    return;\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  const ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  let center;\n  const intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    const grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(\n      ray,\n      ellipsoid\n    );\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n    const grazingAltitudeCart = ellipsoid.cartesianToCartographic(\n      grazingAltitudeLocation,\n      tilt3DCart\n    );\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(\n      grazingAltitudeCart,\n      tilt3DCenter\n    );\n  } else {\n    controller._looking = true;\n    const up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp\n    );\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  const ellipsoid = controller._ellipsoid;\n  const scene = controller._scene;\n  const camera = scene.camera;\n  const cameraUnderground = controller._cameraUnderground;\n\n  let center;\n  let ray;\n  let intersection;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickGlobe(controller, startPosition, tilt3DCenter);\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n      if (!defined(intersection)) {\n        const cartographic = ellipsoid.cartesianToCartographic(\n          camera.position,\n          tilt3DCart\n        );\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n          const up = controller._ellipsoid.geodeticSurfaceNormal(\n            camera.position,\n            tilt3DLookUp\n          );\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n        return;\n      }\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, tilt3DRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  const canvas = scene.canvas;\n\n  const windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  const mag = Cartesian3.magnitude(center);\n  const radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  const newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n  if (!defined(intersection)) {\n    return;\n  }\n\n  const t =\n    Cartesian3.magnitude(ray.origin) > mag\n      ? intersection.start\n      : intersection.stop;\n  const verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n\n  const transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform\n  );\n  const verticalTransform = Transforms.eastNorthUpToFixedFrame(\n    verticalCenter,\n    newEllipsoid,\n    tilt3DVerticalTransform\n  );\n\n  const oldGlobe = controller._globe;\n  const oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  let constrainedAxis = Cartesian3.UNIT_Z;\n\n  const oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(verticalTransform);\n\n  const tangent = Cartesian3.cross(\n    verticalCenter,\n    camera.positionWC,\n    tilt3DCartesian3\n  );\n  const dot = Cartesian3.dot(camera.rightWC, tangent);\n\n  if (dot < 0.0) {\n    const movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    const oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  camera._setTransform(transform);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  if (defined(camera.constrainedAxis)) {\n    const right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  const radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  const originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    tilt3DCartesian3\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    const magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position\n      );\n    }\n\n    const angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    const axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition\n    );\n    Cartesian3.normalize(axis, axis);\n\n    const quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    const rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nconst look3DStartPos = new Cartesian2();\nconst look3DEndPos = new Cartesian2();\nconst look3DStartRay = new Ray();\nconst look3DEndRay = new Ray();\nconst look3DNegativeRot = new Cartesian3();\nconst look3DTan = new Cartesian3();\n\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  const scene = controller._scene;\n  const camera = scene.camera;\n\n  const startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  const endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n\n  let startRay = camera.getPickRay(startPos, look3DStartRay);\n  let endRay = camera.getPickRay(endPos, look3DEndRay);\n  let angle = 0.0;\n  let start;\n  let end;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  let dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n\n  const horizontalRotationAxis = controller._horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n\n  rotationAxis = defaultValue(rotationAxis, horizontalRotationAxis);\n  if (defined(rotationAxis)) {\n    const direction = camera.direction;\n    const negativeRotationAxis = Cartesian3.negate(\n      rotationAxis,\n      look3DNegativeRot\n    );\n    const northParallel = Cartesian3.equalsEpsilon(\n      direction,\n      rotationAxis,\n      CesiumMath.EPSILON2\n    );\n    const southParallel = Cartesian3.equalsEpsilon(\n      direction,\n      negativeRotationAxis,\n      CesiumMath.EPSILON2\n    );\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      let angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      const tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\n\nfunction update3D(controller) {\n  reactToInput(\n    controller,\n    controller.enableRotate,\n    controller.rotateEventTypes,\n    spin3D,\n    controller.inertiaSpin,\n    \"_lastInertiaSpinMovement\"\n  );\n  reactToInput(\n    controller,\n    controller.enableZoom,\n    controller.zoomEventTypes,\n    zoom3D,\n    controller.inertiaZoom,\n    \"_lastInertiaZoomMovement\"\n  );\n  reactToInput(\n    controller,\n    controller.enableTilt,\n    controller.tiltEventTypes,\n    tilt3D,\n    controller.inertiaSpin,\n    \"_lastInertiaTiltMovement\"\n  );\n  reactToInput(\n    controller,\n    controller.enableLook,\n    controller.lookEventTypes,\n    look3D\n  );\n}\n\nconst scratchAdjustHeightTransform = new Matrix4();\nconst scratchAdjustHeightCartographic = new Cartographic();\n\nfunction adjustHeightForTerrain(controller) {\n  controller._adjustedHeightForTerrain = true;\n\n  const scene = controller._scene;\n  const mode = scene.mode;\n  const globe = scene.globe;\n\n  if (\n    !defined(globe) ||\n    mode === SceneMode.SCENE2D ||\n    mode === SceneMode.MORPHING\n  ) {\n    return;\n  }\n\n  const camera = scene.camera;\n  const ellipsoid = globe.ellipsoid;\n  const projection = scene.mapProjection;\n\n  let transform;\n  let mag;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n\n  const cartographic = scratchAdjustHeightCartographic;\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n\n  let heightUpdated = false;\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    const globeHeight = controller._scene.globeHeight;\n    if (defined(globeHeight)) {\n      const height = globeHeight + controller.minimumZoomDistance;\n      if (cartographic.height < height) {\n        cartographic.height = height;\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n        heightUpdated = true;\n      }\n    }\n  }\n\n  if (defined(transform)) {\n    camera._setTransform(transform);\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.max(mag, controller.minimumZoomDistance),\n        camera.position\n      );\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.onMap = function () {\n  const scene = this._scene;\n  const mode = scene.mode;\n  const camera = scene.camera;\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return (\n      Math.abs(camera.position.x) - this._maxCoord.x < 0 &&\n      Math.abs(camera.position.y) - this._maxCoord.y < 0\n    );\n  }\n\n  return true;\n};\n\nconst scratchPreviousPosition = new Cartesian3();\nconst scratchPreviousDirection = new Cartesian3();\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.update = function () {\n  const scene = this._scene;\n  const camera = scene.camera;\n  const globe = scene.globe;\n  const mode = scene.mode;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = globe;\n    this._ellipsoid = defined(this._globe)\n      ? this._globe.ellipsoid\n      : scene.mapProjection.ellipsoid;\n  }\n\n  const exaggeration = defined(this._globe)\n    ? this._globe.terrainExaggeration\n    : 1.0;\n  const exaggerationRelativeHeight = defined(this._globe)\n    ? this._globe.terrainExaggerationRelativeHeight\n    : 0.0;\n  this._minimumCollisionTerrainHeight = TerrainExaggeration.getHeight(\n    this.minimumCollisionTerrainHeight,\n    exaggeration,\n    exaggerationRelativeHeight\n  );\n  this._minimumPickingTerrainHeight = TerrainExaggeration.getHeight(\n    this.minimumPickingTerrainHeight,\n    exaggeration,\n    exaggerationRelativeHeight\n  );\n  this._minimumTrackBallHeight = TerrainExaggeration.getHeight(\n    this.minimumTrackBallHeight,\n    exaggeration,\n    exaggerationRelativeHeight\n  );\n\n  this._cameraUnderground = scene.cameraUnderground && defined(this._globe);\n\n  const radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n\n  this._adjustedHeightForTerrain = false;\n  const previousPosition = Cartesian3.clone(\n    camera.positionWC,\n    scratchPreviousPosition\n  );\n  const previousDirection = Cartesian3.clone(\n    camera.directionWC,\n    scratchPreviousDirection\n  );\n\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or inertia) and an action didn't already adjust the camera height\n    const cameraChanged =\n      !Cartesian3.equals(previousPosition, camera.positionWC) ||\n      !Cartesian3.equals(previousDirection, camera.directionWC);\n    if (cameraChanged) {\n      adjustHeightForTerrain(this);\n    }\n  }\n\n  this._aggregator.reset();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\nexport default ScreenSpaceCameraController;\n"],"names":["DecodingState","PointCloud","options","arrayBuffer","this","_parsedContent","undefined","_drawCommand","_isTranslucent","_styleTranslucent","_constantColor","_highlightColor","_pointSize","_rtcCenter","_quantizedVolumeScale","_quantizedVolumeOffset","_styleableShaderAttributes","_isQuantized","_isOctEncoded16P","_isRGB565","_hasColors","_hasNormals","_hasBatchIds","_decodingState","_dequantizeInShader","_isQuantizedDraco","_isOctEncodedDraco","_quantizedRange","_octEncodedRange","backFaceCulling","_backFaceCulling","normalShading","_normalShading","_opaqueRenderState","_translucentRenderState","_mode","_ready","_pointsLength","_geometryByteLength","_vertexShaderLoaded","vertexShaderLoaded","_fragmentShaderLoaded","fragmentShaderLoaded","_uniformMapLoaded","uniformMapLoaded","_batchTableLoaded","batchTableLoaded","_pickIdLoaded","pickIdLoaded","_opaquePass","opaquePass","_cull","cull","style","_style","styleDirty","modelMatrix","_modelMatrix","time","shadows","_boundingSphere","clippingPlanes","isClipped","clippingPlanesDirty","clippingPlanesOriginMatrix","attenuation","_attenuation","geometricError","geometricErrorScale","maximumAttenuation","splitDirection","_splittingEnabled","_resolveReadyPromise","_rejectReadyPromise","_readyPromise","pointCloud","parsedContent","byteOffset","rtcCenter","hasNormals","hasColors","hasBatchIds","isTranslucent","batchTableBinary","styleableProperties","pointsLength","batchTableJson","draco","dequantizeInShader","positions","isQuantized","quantizedVolumeScale","quantizedVolumeOffset","quantizedRange","normals","octEncoded","colors","constantColor","isRGB565","batchIds","name","semantic","setIndex","batchLength","Promise","resolve","reject","initialize","Object","defineProperties","prototype","get","geometryByteLength","ready","readyPromise","color","set","value","boundingSphere","boundingVolume","scratchMin","scratchMax","scratchPosition","randomNumberGenerator","randomValues","getRandomValues","samplesLength","Array","i","random","prepareVertexAttribute","typedArray","componentDatatype","Float32Array","scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier","scratchQuantizedVolumeScaleAndOctEncodedRange","scratchColor","scratchClippingPlanesMatrix","scratchInverseTransposeClippingPlanesMatrix","createResources","frameState","context","hasStyleableProperties","isQuantizedDraco","isOctEncoded16P","isOctEncodedDraco","octEncodedRange","componentsPerAttribute","styleableVertexAttributes","styleableShaderAttributes","attributeLocation","hasOwnProperty","property","componentCount","vertexBuffer","usage","sizeInBytes","vertexAttribute","index","normalize","offsetInBytes","strideInBytes","push","location","positionsVertexBuffer","colorsVertexBuffer","normalsVertexBuffer","batchIdsVertexBuffer","attributes","length","Math","min","maxValue","Number","MAX_VALUE","minValue","max","floor","position","radius","computeApproximateBoundingSphereFromPositions","colorComponentsPerAttribute","concat","vertexArray","opaqueRenderState","depthTest","enabled","translucentRenderState","depthMask","blending","stencilTest","stencilMask","primitiveType","count","shaderProgram","uniformMap","renderState","pass","owner","castShadows","receiveShadows","pickId","getStyleablePropertyIds","source","propertyIds","regex","matches","exec","id","parseInt","indexOf","getBuiltinPropertyNames","propertyNames","slice","getVertexAttribute","numberOfAttributes","attribute","getAttribute","builtinVariableSubstitutionMap","POSITION","POSITION_ABSOLUTE","COLOR","NORMAL","createShaders","hasStyle","colorStyleFunction","showStyleFunction","pointSizeStyleFunction","styleTranslucent","variableSubstitutionMap","propertyIdToAttributeMap","shaderState","translucent","parameterList","getColorShaderFunction","getShowShaderFunction","getPointSizeShaderFunction","hasColorStyle","hasShowStyle","hasPointSizeStyle","hasClippedContent","styleablePropertyIds","builtinPropertyNames","usesColorSemantic","usesNormalSemantic","usesColors","usesNormals","attributeLocations","a_position","a_color","a_normal","a_batchId","attributeDeclarations","propertyId","attributeName","attributeType","u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier","scratch","x","pixelRatio","y","frustum","camera","depthMultiplier","mode","POSITIVE_INFINITY","drawingBufferHeight","sseDenominator","z","w","u_highlightColor","u_constantColor","u_clippingPlanes","texture","defaultTexture","u_clippingPlanesEdgeStyle","edgeColor","alpha","edgeWidth","u_clippingPlanesMatrix","uniformState","view3D","transform","u_quantizedVolumeScaleAndOctEncodedRange","scale","createUniformMap","vs","fs","drawCommand","destroy","vertexShaderSource","fragmentShaderSource","_bind","error","scratchComputedTranslation","scratchScale","update","decoding","decodePromise","then","result","decodedPositions","array","decodedRgb","RGB","decodedRgba","RGBA","decodedNormals","decodedBatchIds","BATCH_ID","data","quantization","range","minValues","quantizationBits","batchTableProperties","decodedColors","catch","decodeDraco","shadersDirty","modelMatrixDirty","projection","mapProjection","translation","center","splittingEnabled","commandList","passes","render","pick","isDestroyed","command","PointCloud3DTileContent","tileset","tile","resource","content","_tileset","_tile","_resource","_metadata","_pickId","_batchTable","_styleDirty","_features","featurePropertiesDirty","_group","_pointCloud","getVertexShaderCallback","getFragmentShaderLoaded","getUniformMapLoaded","getBatchTableLoaded","getPickIdLoaded","getFragmentShaderCallback","getUniformMapCallback","czm_pickColor","getPickId","featuresLength","trianglesLength","texturesByteLength","batchTableByteLength","memorySizeInBytes","innerContents","url","getUrlComponent","metadata","batchTable","group","hasProperty","batchId","getFeature","features","createFeatures","applyDebugSettings","applyStyle","defaultShading","pointCloudShading","createPickId","primitive","_contentBoundingVolume","_contentBoundingVolume2D","_boundingVolume","_boundingVolume2D","computedTransform","timeSinceLoad","_isClipped","sphereVolume","contentBoundingVolume","volume","baseResolutionApproximation","baseResolution","getGeometricError","refine","maximumScreenSpaceError","PointCloudEyeDomeLighting","_framebuffer","colorAttachmentsLength","depth","supportsDepthTexture","_clearCommand","_strength","_radius","framebuffer","colorGBuffer","getColorTexture","depthGBuffer","distanceAndEdlStrengthScratch","processor","width","drawingBufferWidth","height","blendFS","defines","sources","blendUniformMap","u_pointCloud_colorGBuffer","u_pointCloud_depthGBuffer","u_distanceAndEdlStrength","blendRenderState","createViewportQuadCommand","createCommands","isSupported","drawBuffers","fragmentDepth","getECShaderProgram","shader","shaderCache","getDerivedShaderProgram","_attributeLocations","clone","map","replace","unshift","createDerivedShaderProgram","commandStart","eyeDomeLightingStrength","eyeDomeLightingRadius","commandEnd","derivedCommand","originalShaderProgram","derivedCommandObject","derivedCommands","pointCloudProcessor","dirty","clearCommand","blendCommand","PointCloudShading","eyeDomeLighting","scene","PointPrimitive","pointPrimitiveCollection","disableDepthTestDistance","translucencyByDistance","scaleByDistance","distanceDisplayCondition","far","near","_show","show","_position","_actualPosition","_color","_outlineColor","outlineColor","_outlineWidth","outlineWidth","_pixelSize","pixelSize","_scaleByDistance","_translucencyByDistance","_distanceDisplayCondition","_disableDepthTestDistance","_id","_collection","collection","_clusterShow","_pointPrimitiveCollection","_dirty","_index","SHOW_INDEX","POSITION_INDEX","COLOR_INDEX","OUTLINE_COLOR_INDEX","OUTLINE_WIDTH_INDEX","PIXEL_SIZE_INDEX","SCALE_BY_DISTANCE_INDEX","TRANSLUCENCY_BY_DISTANCE_INDEX","DISTANCE_DISPLAY_CONDITION_INDEX","DISABLE_DEPTH_DISTANCE_INDEX","makeDirty","pointPrimitive","propertyChanged","_updatePointPrimitive","NUMBER_OF_PROPERTIES","object","clusterShow","_getActualPosition","_setActualPosition","tempCartesian3","_computeActualPosition","scratchCartesian4","_computeScreenSpacePosition","positionWorld","computeScreenSpacePosition","windowCoordinates","canvas","clientHeight","getScreenSpaceBoundingBox","point","screenSpacePosition","size","halfSize","equals","other","_destroy","positionHighAndSize","positionLowAndOutline","compressedAttribute0","compressedAttribute1","distanceDisplayConditionAndDisableDepth","PointPrimitiveCollection","_sp","_spTranslucent","_rsOpaque","_rsTranslucent","_vaf","_pointPrimitives","_pointPrimitivesToUpdate","_pointPrimitivesToUpdateIndex","_pointPrimitivesRemoved","_createVertexArray","_shaderScaleByDistance","_compiledShaderScaleByDistance","_shaderTranslucencyByDistance","_compiledShaderTranslucencyByDistance","_shaderDistanceDisplayCondition","_compiledShaderDistanceDisplayCondition","_shaderDisableDepthDistance","_compiledShaderDisableDepthDistance","_propertiesChanged","Uint32Array","_maxPixelSize","_baseVolume","_baseVolumeWC","_baseVolume2D","_boundingVolumeDirty","_colorCommands","debugShowBoundingVolume","blendOption","_blendOption","_maxTotalPointSize","_buffersUsage","that","_uniforms","u_maxTotalPointSize","destroyPointPrimitives","pointPrimitives","removePointPrimitives","newPointPrimitives","j","add","p","remove","contains","removeAll","computeNewBuffersUsage","buffersUsage","usageChanged","properties","k","newUsage","writePositionScratch","writePositionSizeAndOutline","vafWriters","positionHighWriter","high","positionLowWriter","low","LEFT_SHIFT16","LEFT_SHIFT8","writeCompressedAttrib0","pickColor","red","green","blue","compressed0","compressed1","compressed2","compressed3","writer","writeCompressedAttrib1","nearValue","farValue","translucency","writeScaleByDistance","writeDistanceDisplayConditionAndDepthDisable","writePointPrimitive","recomputeActualPositions","recomputeBoundingVolume","actualPosition","scratchWriterArray","pointPrimitivesToUpdate","updateMode","pointPrimitivesLength","pointPrimitivesToUpdateLength","createVertexArray","picking","numberOfPointPrimitives","positionLowAndShow","createVAF","writers","commit","numWriters","m","b","n","h","bb","o","subCommit","endSubCommits","va","getPixelSize","updateBoundingVolume","blendOptionChanged","vaLength","func","minimumDisableDepthTestDistance","colorList","opaque","opaqueAndTranslucent","totalLength","opaqueCommand","_spPick","Polyline","polylineCollection","_width","_loop","loop","_material","material","_positions","_actualPositions","_length","_segments","_actualLength","_polylineCollection","_boundingVolumeWC","WIDTH_INDEX","MATERIAL_INDEX","POSITION_SIZE_INDEX","DISTANCE_DISPLAY_CONDITION","polyline","_updatePolyline","pop","segmentPositionsLength","segmentLengths","lengths","positionsChanged","_clean","texCoordExpandAndBatchIndex","position3DHigh","position3DLow","position2DHigh","position2DLow","prevPosition3DHigh","prevPosition3DLow","prevPosition2DHigh","prevPosition2DLow","nextPosition3DHigh","nextPosition3DLow","nextPosition2DHigh","nextPosition2DLow","PolylineCollection","_opaqueRS","_translucentRS","_polylinesUpdated","_polylinesRemoved","_polylines","_polylineBuckets","_positionBufferUsage","bufferUsage","frameCount","_polylinesToUpdate","_vertexArrays","_positionBuffer","_texCoordExpandAndBatchIndexBuffer","_createBatchTable","_useHighlightColor","_uniformMap","removePolylines","_bucket","bucket","releaseShaders","destroyPolylines","scratchUpdatePolylineEncodedCartesian","scratchUpdatePolylineCartesian4","scratchNearFarCartesian2","functionName","createBatchTable","createVertexArrays","polylinesToUpdate","updateLength","polylineBuckets","ii","writeUpdate","lengthOfPositions","setBatchedAttribute","encodedCenter","nearFarCartesian","useDepthTest","morphTime","commands","commandsLength","commandIndex","cloneBoundingSphere","vertexArrays","uniformCallback","buckets","bucketLength","bucketLocator","offset","sp","polylines","polylineLength","currentId","currentMaterial","s","mId","createMaterialId","boundingSphereScratch","locators","_locatorBuckets","locatorLength","t","locator","boundingSphereScratch2","createCommandLists","destroyVertexArrays","emptyVertexBuffer","type","PolylineBucket","addPolyline","sortPolylinesIntoBuckets","totalIndices","indices","useHighlightColor","vertexBufferOffset","vertexArrayBuckets","updateShader","positionArray","texCoordExpandAndBatchIndexArray","position3DArray","positionIndex","colorIndex","texCoordExpandAndBatchIndexIndex","write","writeForMorph","updateIndices","positionBufferUsage","texCoordExpandAndBatchIndexBufferUsage","position3DBuffer","positionSizeInBytes","BYTES_PER_ELEMENT","texCoordExpandAndBatchIndexSizeInBytes","vbo","numberOfIndicesArrays","indicesArray","Uint16Array","indexBuffer","indexDatatype","positionHighOffset","positionLowOffset","prevPositionHighOffset","prevPositionLowOffset","nextPositionHighOffset","nextPositionLowOffset","vertexTexCoordExpandAndBatchIndexBufferOffset","bufferProperty3D","buffer3D","buffer2D","bufferProperty2D","replacer","key","scratchUniformArray","uniforms","uniform","JSON","stringify","definedPolylines","definedPolylinesToUpdate","polyIndex","VertexArrayBucketLocator","intersectsIDL","intersectPlane","getPolylinePositionsLength","shaderSource","search","vsSource","scratchWritePosition","scratchWritePrevPosition","scratchWriteNextPosition","scratchWriteVector","scratchPickColorCartesian","scratchWidthShowCartesian","maxLon","ellipsoid","maximumRadius","polylineBatchIndex","segments","getSegments","positionsLength","segmentIndex","segmentLength","segmentStart","segmentEnd","abs","endK","direction","colorCartesian","widthShowCartesian","morphPositionScratch","morphPrevPositionScratch","morphNextPositionScratch","morphVectorScratch","prevPosition","nextPosition","scratchSegmentLengths","vaCount","indicesCount","numberOfSegments","segmentIndexCount","getPolylineStartIndex","scratchSegments","scratchLengths","pscratch","scratchCartographic","scratchPositionsArray","newPositions","project","cartesianToCartographic","center2D","positionBuffer","positionsArrayLength","buffer","endJ","copyFromArrayView","defaultVertexShaderSource","defaultFragmentShaderSource","PolylineColorAppearance","vertexFormat","VERTEX_FORMAT","_vertexShaderSource","_fragmentShaderSource","_renderState","_closed","_vertexFormat","closed","getFragmentShaderSource","getRenderState","PolylineMaterialAppearance","PostProcessStage","fragmentShader","textureScale","pixelFormat","_fragmentShader","_textureScale","_forcePowerOfTwo","forcePowerOfTwo","_sampleMode","sampleMode","_pixelFormat","_pixelDatatype","pixelDatatype","_clearColor","clearColor","_command","_colorTexture","_depthTexture","_idTexture","_actualUniforms","_dirtyUniforms","_texturesToRelease","_texturesToCreate","_texturePromise","passState","scissorTest","rectangle","scissorRectangle","_passState","_name","_logDepthChanged","_useLogDepth","_selectedIdTexture","_selected","_selectedShadow","_parentSelected","_parentSelectedShadow","_combinedSelected","_combinedSelectedShadow","_selectedLength","_parentSelectedLength","_selectedDirty","_textureCache","_enabled","outputTexture","getFramebuffer","selected","parentSelected","depthTextureRegex","getUniformValueGetterAndSetter","stage","currentValue","HTMLCanvasElement","HTMLImageElement","HTMLVideoElement","ImageData","actualUniforms","actualValue","getStageByName","getUniformMapFunction","getUniformMapDimensionsFunction","dimensions","createLoadImageFunction","image","createStageOutputTextureFunction","getOutputTexture","releaseResources","textureCache","_isSupported","test","depthTexture","useLogDepth","parentLength","isSelectedTextureDirty","feature","textureLength","pickIds","empty","Uint8Array","arrayBufferView","sampler","ids","pickIdsLength","createSelectedTexture","newUniforms","colorTexture","colorTextureDimensions","depthTextureDimensions","czm_idTexture","czm_selectedIdTexture","czm_selectedIdTextureStep","texturesToRelease","texturesToCreate","textureToCreate","dirtyUniforms","promises","stageNameUrlOrImage","stageWithName","fetchImage","all","updateUniformTextures","createDrawCommand","minFilter","magFilter","_sampler","minificationFilter","magnificationFilter","wrapS","wrapT","createSampler","viewport","execute","idTexture","stackScratch","PostProcessStageCollection","fxaa","ao","bloom","_autoExposureEnabled","_autoExposure","_tonemapping","_tonemapper","tonemapper","tonemapping","stageNames","stack","_stages","_activeStages","_previousActiveStages","_randomTexture","randomTexture","_ao","_bloom","_fxaa","_aoEnabled","_bloomEnabled","_tonemappingEnabled","_fxaaEnabled","_activeStagesChanged","_stagesRemoved","_textureCacheDirty","_stageNames","removeStages","newStages","stages","inputPreviousStageTexture","readyAndEnabled","ambientOcclusion","hasSelected","useAutoExposure","autoexposure","autoExposure","currentStage","useHdr","previousActiveStages","activeStages","activeStagesChanged","aoEnabled","bloomEnabled","tonemappingEnabled","fxaaEnabled","updateDependencies","clear","stageName","autoExposureEnabled","initialTexture","lastTexture","copy","_copyColorCommand","PostProcessStageComposite","_inputPreviousStageTexture","PostProcessStageLibrary","createBlur","blurShader","blurX","delta","sigma","stepSize","blurY","blurXUniforms","blurYUniforms","createBlurStage","createDepthOfFieldStage","blur","dof","focalDistance","blurTexture","isDepthOfFieldSupported","createEdgeDetectionStage","isEdgeDetectionSupported","createSilhouetteStage","edgeDetectionStages","edgeDetection","compositeUniforms","fsDecl","fsLoop","edgeComposite","getSilhouetteEdgeDetection","silhouetteProcess","silhouetteTexture","isSilhouetteSupported","createBloomStage","contrastBias","contrast","brightness","generateComposite","bloomComposite","glowOnly","bloomTexture","createAmbientOcclusionStage","generate","intensity","bias","lengthCap","frustumLength","generateAndBlur","ambientOcclusionModulate","ambientOcclusionOnly","ambientOcclusionTexture","blurStepSize","isAmbientOcclusionSupported","fxaaFS","createFXAAStage","createAcesTonemappingStage","createFilmicTonemappingStage","createReinhardTonemappingStage","createModifiedReinhardTonemappingStage","white","createAutoExposureStage","createBlackAndWhiteStage","gradations","createBrightnessStage","createNightVisionStage","createDepthViewStage","createLensFlareStage","dirtTexture","starTexture","distortion","ghostDispersal","haloWidth","dirtAmount","earthRadius","NEAREST","LINEAR","PostProcessStageTextureCache","postProcessStageCollection","_framebuffers","_stageNameToFramebuffer","_height","_updateDependencies","getLastStageName","getStageDependencies","dependencies","previousName","stageDependencies","uniformNames","getOwnPropertyNames","uniformNamesLength","dependent","getCompositeDependencies","composite","originalDependency","inSeries","currentName","currentDependencies","cache","framebuffers","stagesLength","foundConflict","createFramebuffers","getDependencies","needsCheckDimensionsUpdate","dimensionsChanged","textureWidth","ceil","textureHeight","updateFramebuffers","Primitive","geometryInstances","appearance","_appearance","depthFailAppearance","_depthFailAppearance","_depthFailMaterial","_vertexCacheOptimize","vertexCacheOptimize","_interleave","interleave","_releaseGeometryInstances","releaseGeometryInstances","_allowPicking","allowPicking","_asynchronous","asynchronous","_compressVertices","compressVertices","isArray","_translucent","_state","_geometries","_error","_numberOfInstances","_boundingSpheres","_boundingSphereWC","_boundingSphereCV","_boundingSphere2D","_boundingSphereMorph","_perInstanceAttributeCache","_instanceIds","_lastPerInstanceAttributeIndex","_va","_primitiveType","_frontFaceRS","_backFaceRS","_spDepthFail","_frontFaceDepthFailRS","_backFaceDepthFailRS","_pickIds","_pickCommands","_createBoundingVolumeFunction","_createRenderStatesFunction","_createShaderProgramFunction","_createCommandsFunction","_updateAndQueueCommandsFunction","_createPickOffsets","_pickOffsets","_createGeometryResults","_batchTableAttributeIndices","_offsetInstanceExtend","_batchTableOffsetAttribute2DIndex","_batchTableOffsetsUpdated","_instanceBoundingSpheres","_instanceBoundingSpheresCV","_tempBoundingSpheres","_recomputeBoundingSpheres","_batchTableBoundingSpheresUpdated","_batchTableBoundingSphereAttributeIndices","promise","scratchGetAttributeCartesian2","scratchGetAttributeCartesian3","scratchGetAttributeCartesian4","getAttributeValue","instances","numberOfInstances","names","attributesInAllInstances","attributes0","inAllInstances","otherAttribute","getCommonPerInstanceAttributeNames","attributeIndices","boundingSphereAttributeIndices","offset2DIndex","instanceAttributes","center3DHigh","center3DLow","center2DHigh","center2DLow","attributesLength","instance","attributeIndex","pickObject","pickPrimitive","cloneAttribute","clonedValues","values","constructor","cloneGeometry","geometry","newAttributes","sourceValues","cloneInstance","positionRegex","appendPickToVertexShader","appendPickToFragmentShader","modifyForEncodedNormals","containsNormal","containsSt","containsTangent","containsBitangent","numComponents","attributeDecl","globalDecl","decode","modifiedVS","join","validateShaderMatching","shaderAttributes","vertexAttributes","getUniformFunction","_modifyShaderPosition","scene3DOnly","match","forwardDecl","computeFunctions","toUpperCase","substr","_appendShowToShader","_updateColorAttribute","isDepthFail","depthFailColor","_updatePickColorAttribute","vsPick","_appendOffsetToShader","attr","modifiedShader","str","_appendDistanceDisplayConditionToShader","distanceDisplayConditionMain","numberOfCreationWorkers","createGeometryTaskProcessors","combineGeometryTaskProcessor","scratchBoundingSphereCenterEncoded","scratchBoundingSphereCartographic","scratchBoundingSphereCenter2D","scratchBoundingSphere","offsetScratchCartesian","offsetCenterScratch","updateBatchTableOffsets","index2D","boundingSpheres","getBatchedAttribute","scaleToGeodeticSurface","cartographic","newPoint","newPointProjected","newVector","createRenderStates","twoPasses","rs","face","createShaderProgram","depthClampVS","modifiedFS","depthClampFS","modifiedModelViewScratch","rtcScratch","getUniforms","materialUniformMap","appearanceUniformMap","appearanceUniforms","u_modifiedModelView","viewMatrix","view","colorCommands","pickCommands","depthFailUniforms","multiplier","vaIndex","colorCommand","updateAndQueueCommands","_updateBoundingVolumes","colorLength","factor","sphereIndex","forceUpdate","boundingSphereWC","sizeInMeters","instanceIds","subTask","subTasks","_workerName","moduleName","packedLength","workerSubTasks","workerSubTasksLength","pack","subTaskTransferableObjects","Float64Array","scheduleTask","results","setReady","transferableObjects","createGeometryResults","elementIndexUintSupported","elementIndexUint","createPickOffsets","packedResult","geometries","pickOffsets","offsetInstanceExtend","boundingSpheresCV","loadAsynchronous","clonedInstances","geometryIndex","createdGeometry","createGeometry","loadSynchronous","center3DHighIndex","center3DLowIndex","center2DHighIndex","center2DLowIndex","radiusIndex","updateBatchTableBoundingSpheres","boundingSphereCV","offsetIndex","newBoundingSpheres","newBS","transformBoundingSphere","combinedBS","combinedWestBS","combinedEastBS","bs","resultBS1","resultBS2","resultBS3","recomputeBoundingSpheres","createRS","createSP","depthFailMaterial","rsFunc","spFunc","commandFunc","updateAndQueueCommandsFunc","offsetBoundingSphereScratch1","offsetBoundingSphereScratch2","offsetAttribute","origBS","offsetBS","createGetFunction","instanceIndex","attributeValue","createSetFunction","offsetScratch","state","afterRender","getGeometryInstanceAttributes","lastIndex","curIndex","perInstanceAttributeIndices","createBoundingSphereProperties","createPickIdProperty","PrimitiveCollection","_primitives","_guid","_zIndex","destroyPrimitives","getPrimitiveIndex","compositePrimitive","hasIndex","external","_external","_composites","splice","removeAndDestroy","removed","primitives","raise","raiseToTop","lower","lowerToBottom","prePassesUpdate","updateForPass","postPassesUpdate","addGeometryBatchId","positionAttr","numberOfComponents","geometryPipeline","parameters","uintIndexSupport","primitiveModelMatrix","toWorld","transformToWorldCoordinates","westHemisphereGeometry","eastHemisphereGeometry","addBatchIds","name3D","name2D","position2D","splitGeometries","geometryName","indexCount","pickOffset","PrimitivePipeline","transferGeometry","packInstancesForCombine","packedData","packBoundingSpheres","bufferLength","bufferIndex","unpackBoundingSpheres","combineGeometry","hasOffset","createInstancePickOffsets","packCreateGeometryResults","items","countCreateGeometryResults","stringTable","stringHash","validGeometry","geometryType","validBoundingSphere","validBoundingSphereCV","attributesToWrite","q","indicesLength","unpackCreateGeometryResults","createGeometryResult","packedGeometry","resultIndex","packedGeometryIndex","numAttributes","valuesIndex","numberOfVertices","packCombineGeometryParameters","packedInstances","isGeographic","unpackCombineGeometryParameters","packedParameters","unpackInstancesForCombine","geometriesLength","packCombineGeometryResults","transferGeometries","packedBoundingSpheres","packedBoundingSpheresCV","unpackCombineGeometryResults","freeze","READY","CREATING","CREATED","COMBINING","COMBINED","COMPLETE","FAILED","PropertyAttribute","propertyAttribute","classDefinition","class","classProperty","_class","_properties","_extras","extras","_extensions","extensions","getProperty","PropertyAttributeProperty","_attribute","_classProperty","_min","_max","hasValueTransform","unpackVectorAndMatrixTypes","_offset","_scale","_hasValueTransform","PropertyTable","_count","_metadataTable","metadataTable","_jsonMetadataTable","jsonMetadataTable","_batchTableHierarchy","batchTableHierarchy","hasPropertyBySemantic","propertyExists","propertyExistsBySemantic","scratchResults","getPropertyIds","apply","setProperty","getPropertyBySemantic","setPropertyBySemantic","getPropertyTypedArray","getPropertyTypedArrayBySemantic","PropertyTexture","propertyTexture","textures","PropertyTextureProperty","textureInfo","textureReader","channels","channelIndex","charAt","_textureReader","isGpuCompatible","componentType","isVariableLengthArray","arrayLength","floatTypesByComponentCount","integerTypesByComponentCount","getGlslType","normalized","unpackInShader","packedValueGlsl","QuadtreeOccluders","_ellipsoid","QuadtreePrimitive","tileProvider","quadtree","_tileProvider","_debug","enableDebugOutput","maxDepth","maxDepthVisited","tilesVisited","tilesCulled","tilesRendered","tilesWaitingForChildren","lastMaxDepth","lastMaxDepthVisited","lastTilesVisited","lastTilesCulled","lastTilesRendered","lastTilesWaitingForChildren","suspendLodUpdate","tilingScheme","_tilesToRender","_tileLoadQueueHigh","_tileLoadQueueMedium","_tileLoadQueueLow","_tileReplacementQueue","_levelZeroTiles","_loadQueueTimeSlice","_tilesInvalidated","_addHeightCallbacks","_removeHeightCallbacks","_tileToUpdateHeights","_lastTileIndex","_updateHeightsTimeSlice","_cameraPositionCartographic","_cameraReferenceFrameOriginCartographic","tileCacheSize","loadingDescendantLimit","preloadAncestors","preloadSiblings","_occluders","_tileLoadProgressEvent","_lastTileLoadQueueLength","_lastSelectionFrameNumber","clearTileLoadQueue","debug","comparisonPoint","tileLoadProgressEvent","occluders","invalidateAllTiles","forEachLoadedTile","tileFunction","head","replacementNext","forEachRenderedTile","len","updateHeight","callback","positionOnEllipsoidSurface","positionCartographic","level","addedCallbacks","removeFunc","beginFrame","replacementQueue","tail","levelZeroTiles","customData","customDataLength","freeResources","cancelReprojections","markStartOfRenderFrame","beginUpdate","numberOfRootTiles","rootTraversalDetails","TraversalDetails","cameraPosition","positionWC","sort","compareDistanceToPoint","customDataAdded","customDataRemoved","frameNumber","_updateCustomData","cameraFrameOrigin","cameraOriginScratch","markTileRendered","renderable","visitIfVisible","queueTileLoad","selectTilesForRendering","tilesToRender","showTileThisFrame","createRenderCommandsForSelectedTiles","endUpdate","updateForPick","endFrame","tileLoadQueueHigh","tileLoadQueueMedium","tileLoadQueueLow","trimTiles","endTime","didSomeLoading","processSinglePriorityLoadQueue","processTileLoadQueue","tryNextFrame","scratchArray","tilesToUpdateHeights","startTime","timeSlice","mesh","selectionResult","_lastSelectionResultFrame","_lastSelectionResult","shift","timeSliceMax","terrainData","upsampledGeometryFromParent","wasCreatedByUpsampling","longitude","latitude","surfaceNormal","geodeticSurfaceNormal","scratchRay","rayOrigin","getSurfaceNormalIntersectionWithZAxis","origin","minimumHeight","tileBoundingRegion","magnitude","vectorToMinimumPoint","updateHeights","currentLoadQueueLength","reduce","updateTileLoadProgress","centerScratch","a","alon","alat","blon","blat","queue","needsLoading","computeTileLoadPriority","_loadPriority","allAreRenderable","anyWereRenderedLastFrame","notYetRenderableCount","TraversalQuadDetails","southwest","southeast","northwest","northeast","combine","traversalQuadsByLevel","visitTile","ancestorMeetsSse","traversalDetails","meetsSse","_offCenterFrustum","maxGeometricError","getLevelMaximumGeometricError","top","bottom","right","left","fog","_distance","density","sse","screenSpaceError2D","distance","screenSpaceError","southwestChild","southeastChild","northwestChild","northeastChild","lastFrame","lastFrameSelectionResult","oneRenderedLastFrame","twoCulledOrNotVisited","threeCompletelyLoaded","canRenderWithoutLosingDetail","addTileToRenderList","canRefine","upsampledFromParent","firstRenderedDescendantIndex","loadIndexLow","loadIndexMedium","loadIndexHigh","tilesToUpdateHeightsIndex","quadDetails","southwestDetails","southeastDetails","northwestDetails","northeastDetails","east","north","visitVisibleChildrenNearToFar","queuedForLoad","renderList","workTile","parent","wasRenderedLastFrame","computeTileVisibility","containsNeededPosition","sortByLoadPriority","loadQueue","loadTile","QuadtreeTile","_tilingScheme","_x","_y","_level","_parent","_rectangle","tileXYToRectangle","_southwestChild","_southeastChild","_northwestChild","_northeastChild","replacementPrevious","_customData","_frameUpdated","_loadedCallbacks","freeTile","createLevelZeroTiles","numberOfLevelZeroTilesX","getNumberOfXTilesAtLevel","numberOfLevelZeroTilesY","getNumberOfYTilesAtLevel","added","filter","parentCustomData","children","eligibleForUnloading","findLevelZeroTile","xTiles","findTileToWest","westOfParent","findTileToEast","eastOfParent","findTileToSouth","southOfParent","findTileToNorth","northOfParent","START","LOADING","DONE","QuadtreeTileProvider","computeDefaultLevelZeroMaximumGeometricError","PI","errorEvent","computeDistanceToTile","ResourceCache","CacheEntry","resourceLoader","referenceCount","cacheEntries","cacheKey","cacheEntry","load","unload","loadSchema","schema","schemaLoader","loadEmbeddedBuffer","parentResource","bufferId","bufferLoader","loadExternalBuffer","loadGltfJson","gltfResource","baseResource","gltfJson","gltfJsonLoader","resourceCache","loadBufferView","gltf","bufferViewId","bufferViewLoader","loadDraco","dracoLoader","loadVertexBuffer","attributeSemantic","accessorId","dequantize","loadBuffer","loadTypedArray","hasBufferViewId","hasDraco","hasAttributeSemantic","hasAccessorId","vertexBufferLoader","loadIndexBuffer","indexBufferLoader","loadImage","imageId","imageLoader","loadTexture","supportedImageFormats","textureLoader","clearForSpecs","precedence","cacheEntriesSorted","cacheEntriesLength","ResourceCacheKey","getExternalResourceCacheKey","getBufferViewCacheKey","bufferView","byteLength","meshopt","EXT_meshopt_compression","getExternalBufferCacheKey","getEmbeddedBufferCacheKey","getBufferCacheKey","uri","getDerivedResource","getDracoCacheKey","bufferViews","buffers","getImageCacheKey","images","getSchemaCacheKey","getGltfCacheKey","getVertexBufferCacheKey","cacheKeySuffix","getIndexBufferCacheKey","accessor","accessors","bufferCacheKey","accessorCacheKey","getAccessorCacheKey","getTextureCacheKey","textureId","imageCacheKey","samplerCacheKey","getSamplerCacheKey","ResourceLoader","process","getError","errorMessage","message","UNLOADED","PROCESSING","FONT_SIZE","PADDING","RADIUS","CUTOFF","requestRenderAfterFrame","requestRender","Scene","creditContainer","creditViewport","contextOptions","webgl","powerPreference","hasCreditContainer","document","createElement","parentNode","appendChild","_jobScheduler","_frameState","_removeCreditContainer","_creditContainer","_canvas","_context","_computeEngine","_globe","_globeTranslucencyState","_groundPrimitives","_globeHeight","_cameraUnderground","_logDepthBuffer","_logDepthBufferDirty","_tweens","_shaderFrameCount","_sunPostProcess","_computeCommandList","_overlayCommandList","_useOIT","orderIndependentTranslucency","_executeOITFunction","_depthPlane","depthPlaneEllipsoidOffset","_clearColorCommand","stencil","_depthClearCommand","_stencilClearCommand","_classificationStencilClearCommand","_depthOnlyRenderStateCache","_transitioner","_preUpdate","_postUpdate","_renderError","_preRender","_postRender","_minimumDisableDepthTestDistance","_debugInspector","_msaaSamples","msaaSamples","rethrowRenderErrors","completeMorphOnUserInput","morphStart","morphComplete","skyBox","skyAtmosphere","sun","sunBloom","_sunBloom","moon","backgroundColor","_mapProjection","farToNearRatio","logarithmicDepthFarToNearRatio","nearToFarDistance2D","debugCommandFilter","debugShowCommands","debugShowFrustums","debugShowFramesPerSecond","debugShowDepthFrustum","debugShowFrustumPlanes","_debugShowFrustumPlanes","_debugFrustumPlanes","useDepthPicking","pickTranslucentDepth","cameraEventWaitTime","_shadowMapCamera","shadowMap","lightCamera","invertClassification","invertClassificationColor","_actualInvertClassificationColor","_invertClassificationColor","_invertClassification","focalLength","eyeSeparation","postProcessStages","_brdfLutGenerator","_performanceDisplay","_debugVolume","_screenSpaceCameraController","_mapMode2D","mapMode2D","_environmentState","skyBoxCommand","skyAtmosphereCommand","sunDrawCommand","sunComputeCommand","moonCommand","isSunVisible","isMoonVisible","isReadyForAtmosphere","isSkyAtmosphereVisible","clearGlobeDepth","useDepthPlane","renderTranslucentDepthForPick","originalFramebuffer","useGlobeDepthFramebuffer","useOIT","useInvertClassification","usePostProcess","usePostProcessSelected","useWebVR","_useWebVR","_cameraVR","_aspectRatioVR","requestRenderMode","_renderRequested","maximumRenderTimeChange","_lastRenderTime","_frameRateMonitor","_removeRequestListenerCallback","_removeTaskProcessorListenerCallback","_removeGlobeCallbacks","preloadFlightCamera","preloadFlightCullingVolume","_picking","_defaultView","_view","_hdr","_hdrDirty","highDynamicRange","gamma","sphericalHarmonicCoefficients","specularEnvironmentMaps","_specularEnvironmentMapAtlas","light","updateFrameNumber","updateFrameState","initializeFrame","updateDerivedCommands","shadowsDirty","oit","lightShadowMaps","shadowState","lightShadowsEnabled","pickOnly","originalCommand","hdr","createDerivedCommands","receiveCommand","maximumAliasedLineWidth","maximumCubeMapSize","pickPositionSupported","sampleHeightSupported","clampToHeightSupported","invertClassificationSupported","specularEnvironmentMapsSupported","globe","removeGlobeCallbacks","imageryLayersUpdatedEvent","addEventListener","terrainProviderChanged","updateGlobeListeners","groundPrimitives","defaultView","screenSpaceCameraController","jobScheduler","environmentState","tweens","imageryLayers","terrainProvider","preUpdate","postUpdate","renderError","preRender","postRender","lastRenderTime","debugFrustumStatistics","morphTo2D","morphTo3D","morphToColumbusView","frustumCommandsList","numberOfFrustums","creditDisplay","container","visibility","_deviceOrientationCameraController","aspectRatio","xOffset","splitPosition","logarithmicDepthBuffer","colorBufferFloat","colorBufferHalfFloat","highDynamicRangeSupported","cameraUnderground","msaaSupported","msaa","opaqueFrustumNearOffset","globeHeight","getCompressedTextureFormatSupported","format","s3tc","pvrtc","etc","etc1","astc","bc7","lastDirtyTime","hasLogDepthDerivedCommands","logDepth","hasHdrCommands","hasDerivedCommands","needsLogDepthDerivedCommands","needsHdrCommands","needsDerivedCommands","shadowMaps","shadowsEnabled","renderTilesetPassState","preloadTilesetPassState","preloadFlightTilesetPassState","requestRenderModeDeferCheckPassState","scratchOccluderBoundingSphere","scratchOccluder","clearPasses","postProcess","offscreen","brdfLutGenerator","environmentMap","_cubeMap","cullingVolume","computeCullingVolume","directionWC","upWC","occluder","minimumTerrainHeight","minimumRadius","getOccluder","globeTranslucencyState","terrainExaggeration","terrainExaggerationRelativeHeight","specularEnvironmentMapsMaximumLOD","maximumMipmapLevel","tilesetPassState","isVisible","computeVisibility","occlude","isOccluded","transformFrom2D","executeCommand","debugFramebuffer","centerCartographic","unproject","cartographicToCartesian","radii","flat","halfAxes","savedCommandList","pickCommand","depthOnlyCommand","executeDebugShowFrustumsCommand","executeIdCommand","backToFront","distanceSquaredTo","frontToBack","executeTranslucentCommandsBackToFront","executeFunction","unclassifiedCommand","executeTranslucentCommandsFrontToBack","scratchPerspectiveFrustum","scratchPerspectiveOffCenterFrustum","scratchOrthographicFrustum","scratchOrthographicOffCenterFrustum","executeCommands","us","updateCamera","fov","infiniteProjectionMatrix","updateFrustum","updatePass","globeDepth","sceneFramebuffer","executeTranslucentCommands","prepareColorTextures","numFrustums","globeTranslucent","globeTranslucencyFramebuffer","clearDepth","clearStencil","clearClassificationStencil","depthPlane","height2D","frustumCommands","stencilBuffer","executeGlobeCommands","executeCopyDepth","executeGlobeClassificationCommands","executeUpdateDepth","depthStencilTexture","opaqueClassificationFramebuffer","_fbo","prepareTextures","getDepthStencilTexture","executeClassified","executeUnclassified","translucentTileClassification","executeClassificationCommands","pickDepth","getPickDepth","getIdFramebuffer","executeComputeCommands","insertShadowCastCommands","shadowVolume","shadowMapCullingVolume","isPointLight","numberOfPasses","wasVisible","cascadeVolume","executeShadowMapCastCommands","shadowMapLength","outOfView","numberOfCommands","castCommands","scratchEyeTranslation","updateAndExecuteCommands","updateAndClearFramebuffers","updateAndRenderPrimitives","createPotentiallyVisibleSet","savedCamera","fo","eyeTranslation","executeWebVRCommands","executeCommandsInViewport","originalViewport","scratch2DViewport","maxCartographic","scratch2DViewportCartographic","maxCoord","scratch2DViewportMaxCoord","scratch2DViewportSavedPosition","scratch2DViewportCameraTransform","_setTransform","viewportTransformation","scratch2DViewportTransform","projectionMatrix","eyePoint","scratch2DViewportEyePoint","scratch2DViewportWindowCoords","viewportX","viewportWidth","execute2DViewportCommands","firstViewport","scratchCullingVolume","updateOnChange","frustumSplits","updateDebugFrustumPlanes","fromLightSource","updateShadowMaps","colorFramebufferManager","depthFramebuffer","previousFramebuffer","updateAndClear","resetBudgets","updateEnvironment","renderPass","offscreenPass","environmentVisible","setDynamicAtmosphereColor","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","_surface","sunCommands","computeCommand","depthTestAgainstTerrain","sunVisibleThroughGlobe","planes","envMaps","envMapAtlas","resolveFramebuffers","defaultFramebuffer","globeFramebuffer","_colorFramebuffer","idFramebuffer","hasTranslucentDepth","inputFramebuffer","executeCopyColor","destroyReleasedShaderPrograms","destroyReleasedTextures","getHeight","getGlobeHeight","cameraController","onMap","isCameraUnderground","_updateCameraChanged","scratchBackgroundColor","pow","sunDirectionWC","blendingEnabled","executeOverlayCommands","tilesLoaded","tryAndCatchError","functionToExecute","raiseEvent","updateMostDetailedRayPicks","updatePreloadPass","updatePreloadFlightPass","canPreloadFlight","updateRequestRenderModeDeferCheckPass","newFrame","cameraChanged","checkForCameraUpdates","shouldRender","difference","renderedThisFrame","performanceContainer","className","performanceDisplay","_performanceContainer","throttled","removeChild","updateDebugShowFramesPerSecond","functions","callAfterRenderFunctions","forceRender","clampLineWidth","windowPosition","pickPositionWorldCoordinates","pickPosition","drillPick","limit","pickFromRay","ray","objectsToExclude","drillPickFromRay","pickFromRayMostDetailed","drillPickFromRayMostDetailed","sampleHeight","clampToHeight","cartesian","sampleHeightMostDetailed","clampToHeightMostDetailed","cartesians","cartesianToCanvasCoordinates","completeMorph","duration","_debugSphere","SceneFramebuffer","_numSamples","depthStencil","_idFramebuffer","_idClearColor","numSamples","halfFloatingPointTexture","post","SceneMode","MORPHING","COLUMBUS_VIEW","SCENE2D","SCENE3D","SceneTransforms","actualPositionScratch","positionCC","scratchViewport","scratchWindowCoord0","scratchWindowCoord1","wgs84ToWindowCoordinates","wgs84WithEyeOffsetToWindowCoordinates","scratchEyeOffset","worldToClip","eyeOffset","positionEC","zEyeOffset","scratchMaxCartographic","scratchProjectedCartesian","scratchCameraPosition","computeActualWgs84Position","clientWidth","cameraCentered","clipToGLWindowCoordinates","wgs84ToDrawingBufferCoordinates","transformWindowToDrawingBuffer","projectedPosition","positionInCartographic","positionNDC","viewportTransform","xScale","yScale","scratchNDC","scratchWorldCoords","drawingBufferToWgs84Coordinates","drawingBufferPosition","currentFrustum","log2Depth","log2FarDepthFromNearPlusOne","ndc","worldCoords","fovy","inverseViewProjection","inverseView","SceneTransitioner","_scene","_currentTweens","_morphHandler","_morphCancelled","_completeMorph","_morphToOrthographic","_previousMode","transitioner","startPos","scratchCVTo2DStartPos","startDir","scratchCVTo2DStartDir","startUp","up","scratchCVTo2DStartUp","endDir","scratchCVTo2DEndDir","endUp","scratchCVTo2DEndUp","endPos","scratchCVTo2DEndPos","scratchCVTo2DRay","pickPos","pickWorldCoordinates","scratchCVTo2DPickPos","scratchCVTo2DFrustum","camera2D","scratchCVTo2DCamera","complete","complete2DCallback","updateCV","columbusViewMorph","_adjustOrthographicFrustum","createMorphHandler","tween","easingFunction","startObject","stopObject","morphPerspectiveToOrthographic","morphFromColumbusViewTo2D","scratch3DTo2DCamera","scratch3DTo2DCartographic","scratch3DTo2DRay","rayDirection","surfacePoint","scratch3DTo2DSurfacePoint","toENU","scratch3DTo2DToENU","pickedPos","scratch3DTo2DPickPosition","direction2D","up2D","endCamera","scratch3DTo2DEndCamera","completeCallback","morphFrom3DToColumbusView","morphFrom3DTo2D","scratchToCVPosition","scratchToCVDirection","scratchToCVUp","scratchToCVPosition2D","scratchToCVDirection2D","scratchToCVUp2D","scratchToCVSurfacePosition","scratchToCVCartographic","scratchToCVToENU","scratchToCVFrustumPerspective","scratchToCVFrustumOrthographic","scratchToCVCamera","cameraCV","destroyMorphHandler","_previousModeMode","wasMorphing","completeColumbusViewCallback","scratch3DToCVEndPos","scratch3DToCVEndDir","scratch3DToCVEndUp","morph","scratch3DToCVStartPos","scratch3DToCVStartDir","scratch3DToCVStartUp","morphOrthographicToPerspective","morphFrom2DToColumbusView","scratchCVTo3DCamera","scratch2DTo3DFrustumPersp","completeMorphFunction","cancelFlight","setInputAction","cancelTween","camera3D","getColumbusViewTo3DCamera","scratch2DTo3DFrustumOrtho","complete3DCallback","morphFromColumbusViewTo3D","flyTo","destination","morphFrom2DTo3D","scratchCVTo3DCartographic","scratchCVTo3DSurfacePoint","scratchCVTo3DFromENU","positionCarto","fromENU","scratchCVTo3DStartPos","scratchCVTo3DStartDir","scratchCVTo3DStartUp","scratchCVTo3DEndPos","scratchCVTo3DEndDir","scratchCVTo3DEndUp","addMorphTimeAnimations","startPosition","endPosition","startFOV","endFOV","d","tan","start","stop","startValue","stopValue","addProperty","ScreenSpaceCameraController","enableInputs","enableTranslate","enableZoom","enableRotate","enableTilt","enableLook","inertiaSpin","inertiaTranslate","inertiaZoom","maximumMovementRatio","bounceAnimationTime","minimumZoomDistance","maximumZoomDistance","translateEventTypes","zoomEventTypes","rotateEventTypes","tiltEventTypes","eventType","modifier","lookEventTypes","minimumPickingTerrainHeight","_minimumPickingTerrainHeight","minimumCollisionTerrainHeight","_minimumCollisionTerrainHeight","minimumTrackBallHeight","_minimumTrackBallHeight","enableCollisionDetection","_aggregator","_lastInertiaSpinMovement","_lastInertiaZoomMovement","_lastInertiaTranslateMovement","_lastInertiaTiltMovement","_inertiaDisablers","_tween","_horizontalRotationAxis","_tiltCenterMousePosition","_tiltCenter","_rotateMousePosition","_rotateStartPosition","_strafeStartPosition","_strafeMousePosition","_strafeEndMousePosition","_zoomMouseStart","_zoomWorldPosition","_useZoomWorldPosition","_tiltCVOffMap","_looking","_rotating","_strafing","_zoomingOnVector","_zoomingUnderground","_rotatingZoom","_adjustedHeightForTerrain","_maxCoord","_zoomFactor","_rotateFactor","_rotateRateRangeAdjustment","_maximumRotateRate","_minimumRotateRate","_minimumZoomRate","_maximumZoomRate","_minimumUndergroundPickDistance","_maximumUndergroundPickDistance","maintainInertia","aggregator","decayCoef","action","lastMovementName","movementState","motion","inertiaEnabled","ts","getButtonPressTime","tr","getButtonReleaseTime","threshold","getTime","now","Date","fromNow","coefficient","tau","exp","decay","lastMovement","getLastMovement","movement","isNaN","isButtonDown","getStartMousePosition","activateInertia","controller","inertiaStateName","inertiasToDisable","scratchEventTypeArray","reactToInput","eventTypes","inertiaConstant","isMoving","getMovement","scratchZoomPickRay","scratchPickCartesian","scratchZoomOffset","scratchZoomDirection","scratchCenterPixel","scratchCenterPosition","scratchPositionNormal","scratchPickNormal","scratchZoomAxis","scratchCameraPositionNormal","scratchTargetNormal","scratchCameraUpNormal","scratchCameraRightNormal","scratchForwardNormal","scratchPositionToTarget","scratchPositionToTargetNormal","scratchPan","scratchCenterMovement","scratchCenter","scratchCartesian","scratchCartesianTwo","scratchCartesianThree","scratchZoomViewOptions","orientation","handleZoom","zoomFactor","distanceMeasure","unitPositionDotDirection","percentage","diff","minHeight","maxHeight","zoomRate","rangeWindowRatio","heading","pitch","roll","zoomIn","sameStartPosition","pickedPosition","zoomingOnVector","rotatingZoom","getPickRay","pickGlobe","zoomOnVector","worldPosition","savedX","getMagnitude","move","cameraPositionNormal","centerPixel","centerPosition","target","targetNormal","forward","positionToTarget","positionToTargetNormal","alphaDot","acos","cameraDistance","targetDistance","remainingDistance","positionToTargetDistance","beta","asin","sin","pMid","cos","cMid","setView","positionNormal","pickedNormal","dotProduct","angle","axis","scalar","rotate","zoomMouseStart","translate2DStart","translate2DEnd","scratchTranslateP0","translate2D","end","zoom2D","twist2DStart","twist2DEnd","twist2D","angleAndHeight","rotateRate","phiWindowRatio","deltaPhi","twistRight","singleAxisTwist2D","startTheta","endTheta","theta","pickGlobeScratchRay","scratchDepthIntersection","scratchRayIntersection","mousePosition","cullBackFaces","depthIntersection","rayIntersection","scratchDistanceCartographic","getDistanceFromSurface","scratchSurfaceNormal","getZoomDistanceUnderground","distanceFromSurface","strength","getTiltCenterUnderground","getStrafeStartPositionUnderground","scratchInertialDelta","continueStrafing","originalEndPosition","inertialDelta","strafe","translateCVStartRay","translateCVEndRay","translateCVStartPos","translateCVEndPos","translateCVDifference","translateCVOrigin","translateCVPlane","translateCVStartMouse","translateCVEndMouse","translateCV","_translateMousePosition","look3D","startMouse","endMouse","startRay","normal","globePos","plane","startPlanePos","endRay","endPlanePos","temp","mag","rotateCVWindowPos","rotateCVWindowRay","rotateCVCenter","rotateCVVerticalCenter","rotateCVTransform","rotateCVVerticalTransform","rotateCVOrigin","rotateCVPlane","rotateCVCartesian3","rotateCVCart","rotateCVOldTransform","rotateCVQuaternion","rotateCVMatrix","tilt3DCartesian3","rotateCV","normalDotDirection","cart","oldGlobe","oldEllipsoid","oldTransform","rotate3D","rotateCVOnPlane","verticalCenter","_projection","verticalTransform","constrainedAxis","tangent","dot","movementDelta","oldConstrainedAxis","originalPosition","adjustHeightForTerrain","worldToCameraCoordinatesPoint","magSqrd","sqrt","quaternion","rotation","rotateCVOnTerrain","zoomCVWindowPos","zoomCVWindowRay","zoomCVIntersection","zoomCV","intersection","distanceUnderground","scratchStrafeRay","scratchStrafePlane","scratchStrafeIntersection","scratchStrafeDirection","scratchMousePos","strafeStartPosition","spin3DPick","scratchRadii","scratchEllipsoid","scratchLookUp","scratchNormal","spin3D","pan3D","mousePos","strafing","pickEllipsoid","rotateOnlyVertical","rotateOnlyHorizontal","oldAxis","rho","thetaWindowRatio","deltaTheta","rotateRight","rotateUp","pan3DP0","pan3DP1","pan3DTemp0","pan3DTemp1","pan3DTemp2","pan3DTemp3","pan3DStartMousePosition","pan3DEndMousePosition","startMousePosition","endMousePosition","p0","p1","worldToCameraCoordinates","basis0","basis1","basis2","startRho","startDot","startRej","endRho","endDot","endRej","startPhi","endPhi","planeNormal","side0","side1","zoom3DUnitPosition","zoom3DCartographic","zoom3D","unitPosition","tilt3DWindowPos","tilt3DRay","tilt3DCenter","tilt3DVerticalCenter","tilt3DTransform","tilt3DVerticalTransform","tilt3DOldTransform","tilt3DQuaternion","tilt3DMatrix","tilt3DCart","tilt3DLookUp","tilt3D","_tiltOnEllipsoid","tilt3DOnEllipsoidCartographic","grazingAltitudeLocation","grazingAltitudeCart","tilt3DOnEllipsoid","newEllipsoid","rightWC","tilt3DOnTerrain","look3DStartPos","look3DEndPos","look3DStartRay","look3DEndRay","look3DNegativeRot","look3DTan","rotationAxis","horizontalRotationAxis","look","lookLeft","negativeRotationAxis","northParallel","southParallel","angleToAxis","lookUp","scratchAdjustHeightTransform","scratchAdjustHeightCartographic","heightUpdated","scratchPreviousPosition","scratchPreviousDirection","exaggeration","exaggerationRelativeHeight","previousPosition","previousDirection","rotatable2D","update2D","anyButtonDown","createCorrectPositionTween","reset"],"sourceRoot":""}