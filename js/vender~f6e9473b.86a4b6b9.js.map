{"version":3,"file":"js/vender~f6e9473b.86a4b6b9.js","mappings":"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","sources":["webpack:///../../../node_modules/cesium/Source/Core/GoogleEarthEnterpriseMetadata.js","webpack:///../../../node_modules/cesium/Source/Core/GoogleEarthEnterpriseTerrainData.js","webpack:///../../../node_modules/cesium/Source/Core/GoogleEarthEnterpriseTerrainProvider.js","webpack:///../../../node_modules/cesium/Source/Core/GoogleEarthEnterpriseTileInformation.js","webpack:///../../../node_modules/cesium/Source/Core/GregorianDate.js","webpack:///../../../node_modules/cesium/Source/Core/GroundPolylineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/HeadingPitchRange.js","webpack:///../../../node_modules/cesium/Source/Core/HeadingPitchRoll.js","webpack:///../../../node_modules/cesium/Source/Core/Heap.js","webpack:///../../../node_modules/cesium/Source/Core/HeightmapEncoding.js","webpack:///../../../node_modules/cesium/Source/Core/HeightmapTerrainData.js","webpack:///../../../node_modules/cesium/Source/Core/HeightmapTessellator.js","webpack:///../../../node_modules/cesium/Source/Core/HermitePolynomialApproximation.js","webpack:///../../../node_modules/cesium/Source/Core/HermiteSpline.js","webpack:///../../../node_modules/cesium/Source/Core/HilbertOrder.js","webpack:///../../../node_modules/cesium/Source/Core/Iau2000Orientation.js","webpack:///../../../node_modules/cesium/Source/Core/Iau2006XysData.js","webpack:///../../../node_modules/cesium/Source/Core/Iau2006XysSample.js","webpack:///../../../node_modules/cesium/Source/Core/IauOrientationAxes.js","webpack:///../../../node_modules/cesium/Source/Core/IauOrientationParameters.js","webpack:///../../../node_modules/cesium/Source/Core/IndexDatatype.js","webpack:///../../../node_modules/cesium/Source/Core/InterpolationAlgorithm.js","webpack:///../../../node_modules/cesium/Source/Core/InterpolationType.js","webpack:///../../../node_modules/cesium/Source/Core/Intersect.js","webpack:///../../../node_modules/cesium/Source/Core/IntersectionTests.js","webpack:///../../../node_modules/cesium/Source/Core/Intersections2D.js","webpack:///../../../node_modules/cesium/Source/Core/Interval.js","webpack:///../../../node_modules/cesium/Source/Core/Ion.js","webpack:///../../../node_modules/cesium/Source/Core/IonGeocoderService.js","webpack:///../../../node_modules/cesium/Source/Core/IonResource.js","webpack:///../../../node_modules/cesium/Source/Core/Iso8601.js","webpack:///../../../node_modules/cesium/Source/Core/JulianDate.js","webpack:///../../../node_modules/cesium/Source/Core/KTX2Transcoder.js","webpack:///../../../node_modules/cesium/Source/Core/KeyboardEventModifier.js","webpack:///../../../node_modules/cesium/Source/Core/LagrangePolynomialApproximation.js","webpack:///../../../node_modules/cesium/Source/Core/LeapSecond.js","webpack:///../../../node_modules/cesium/Source/Core/LinearApproximation.js","webpack:///../../../node_modules/cesium/Source/Core/LinearSpline.js","webpack:///../../../node_modules/cesium/Source/Core/ManagedArray.js","webpack:///../../../node_modules/cesium/Source/Core/MapProjection.js","webpack:///../../../node_modules/cesium/Source/Core/Math.js","webpack:///../../../node_modules/cesium/Source/Core/Matrix2.js","webpack:///../../../node_modules/cesium/Source/Core/Matrix3.js","webpack:///../../../node_modules/cesium/Source/Core/Matrix4.js","webpack:///../../../node_modules/cesium/Source/Core/MorphWeightSpline.js","webpack:///../../../node_modules/cesium/Source/Core/MortonOrder.js","webpack:///../../../node_modules/cesium/Source/Core/NearFarScalar.js","webpack:///../../../node_modules/cesium/Source/Core/Occluder.js","webpack:///../../../node_modules/cesium/Source/Core/OffsetGeometryInstanceAttribute.js","webpack:///../../../node_modules/cesium/Source/Core/OpenCageGeocoderService.js","webpack:///../../../node_modules/cesium/Source/Core/OrientedBoundingBox.js","webpack:///../../../node_modules/cesium/Source/Core/OrthographicFrustum.js","webpack:///../../../node_modules/cesium/Source/Core/OrthographicOffCenterFrustum.js","webpack:///../../../node_modules/cesium/Source/Core/Packable.js","webpack:///../../../node_modules/cesium/Source/Core/PackableForInterpolation.js","webpack:///../../../node_modules/cesium/Source/Core/PeliasGeocoderService.js","webpack:///../../../node_modules/cesium/Source/Core/PerspectiveFrustum.js","webpack:///../../../node_modules/cesium/Source/Core/PerspectiveOffCenterFrustum.js","webpack:///../../../node_modules/cesium/Source/Core/PinBuilder.js","webpack:///../../../node_modules/cesium/Source/Core/PixelFormat.js","webpack:///../../../node_modules/cesium/Source/Core/Plane.js","webpack:///../../../node_modules/cesium/Source/Core/PlaneGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/PlaneOutlineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/PolygonGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/PolygonGeometryLibrary.js","webpack:///../../../node_modules/cesium/Source/Core/PolygonHierarchy.js","webpack:///../../../node_modules/cesium/Source/Core/PolygonOutlineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/PolygonPipeline.js","webpack:///../../../node_modules/cesium/Source/Core/PolylineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/PolylinePipeline.js","webpack:///../../../node_modules/cesium/Source/Core/PolylineVolumeGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/PolylineVolumeGeometryLibrary.js","webpack:///../../../node_modules/cesium/Source/Core/PolylineVolumeOutlineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/PrimitiveType.js","webpack:///../../../node_modules/cesium/Source/Core/Proxy.js","webpack:///../../../node_modules/cesium/Source/Core/QuadraticRealPolynomial.js","webpack:///../../../node_modules/cesium/Source/Core/QuantizedMeshTerrainData.js","webpack:///../../../node_modules/cesium/Source/Core/QuarticRealPolynomial.js","webpack:///../../../node_modules/cesium/Source/Core/Quaternion.js","webpack:///../../../node_modules/cesium/Source/Core/QuaternionSpline.js","webpack:///../../../node_modules/cesium/Source/Core/Queue.js"],"sourcesContent":["import protobuf from \"../ThirdParty/protobufjs.js\";\nimport buildModuleUrl from \"./buildModuleUrl.js\";\nimport Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport GoogleEarthEnterpriseTileInformation from \"./GoogleEarthEnterpriseTileInformation.js\";\nimport isBitSet from \"./isBitSet.js\";\nimport loadAndExecuteScript from \"./loadAndExecuteScript.js\";\nimport CesiumMath from \"./Math.js\";\nimport Request from \"./Request.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\n\nfunction stringToBuffer(str) {\n  const len = str.length;\n  const buffer = new ArrayBuffer(len);\n  const ui8 = new Uint8Array(buffer);\n  for (let i = 0; i < len; ++i) {\n    ui8[i] = str.charCodeAt(i);\n  }\n\n  return buffer;\n}\n\n// Decodes packet with a key that has been around since the beginning of Google Earth Enterprise\nconst defaultKey = stringToBuffer(\n  \"\\x45\\xf4\\xbd\\x0b\\x79\\xe2\\x6a\\x45\\x22\\x05\\x92\\x2c\\x17\\xcd\\x06\\x71\\xf8\\x49\\x10\\x46\\x67\\x51\\x00\\x42\\x25\\xc6\\xe8\\x61\\x2c\\x66\\x29\\x08\\xc6\\x34\\xdc\\x6a\\x62\\x25\\x79\\x0a\\x77\\x1d\\x6d\\x69\\xd6\\xf0\\x9c\\x6b\\x93\\xa1\\xbd\\x4e\\x75\\xe0\\x41\\x04\\x5b\\xdf\\x40\\x56\\x0c\\xd9\\xbb\\x72\\x9b\\x81\\x7c\\x10\\x33\\x53\\xee\\x4f\\x6c\\xd4\\x71\\x05\\xb0\\x7b\\xc0\\x7f\\x45\\x03\\x56\\x5a\\xad\\x77\\x55\\x65\\x0b\\x33\\x92\\x2a\\xac\\x19\\x6c\\x35\\x14\\xc5\\x1d\\x30\\x73\\xf8\\x33\\x3e\\x6d\\x46\\x38\\x4a\\xb4\\xdd\\xf0\\x2e\\xdd\\x17\\x75\\x16\\xda\\x8c\\x44\\x74\\x22\\x06\\xfa\\x61\\x22\\x0c\\x33\\x22\\x53\\x6f\\xaf\\x39\\x44\\x0b\\x8c\\x0e\\x39\\xd9\\x39\\x13\\x4c\\xb9\\xbf\\x7f\\xab\\x5c\\x8c\\x50\\x5f\\x9f\\x22\\x75\\x78\\x1f\\xe9\\x07\\x71\\x91\\x68\\x3b\\xc1\\xc4\\x9b\\x7f\\xf0\\x3c\\x56\\x71\\x48\\x82\\x05\\x27\\x55\\x66\\x59\\x4e\\x65\\x1d\\x98\\x75\\xa3\\x61\\x46\\x7d\\x61\\x3f\\x15\\x41\\x00\\x9f\\x14\\x06\\xd7\\xb4\\x34\\x4d\\xce\\x13\\x87\\x46\\xb0\\x1a\\xd5\\x05\\x1c\\xb8\\x8a\\x27\\x7b\\x8b\\xdc\\x2b\\xbb\\x4d\\x67\\x30\\xc8\\xd1\\xf6\\x5c\\x8f\\x50\\xfa\\x5b\\x2f\\x46\\x9b\\x6e\\x35\\x18\\x2f\\x27\\x43\\x2e\\xeb\\x0a\\x0c\\x5e\\x10\\x05\\x10\\xa5\\x73\\x1b\\x65\\x34\\xe5\\x6c\\x2e\\x6a\\x43\\x27\\x63\\x14\\x23\\x55\\xa9\\x3f\\x71\\x7b\\x67\\x43\\x7d\\x3a\\xaf\\xcd\\xe2\\x54\\x55\\x9c\\xfd\\x4b\\xc6\\xe2\\x9f\\x2f\\x28\\xed\\xcb\\x5c\\xc6\\x2d\\x66\\x07\\x88\\xa7\\x3b\\x2f\\x18\\x2a\\x22\\x4e\\x0e\\xb0\\x6b\\x2e\\xdd\\x0d\\x95\\x7d\\x7d\\x47\\xba\\x43\\xb2\\x11\\xb2\\x2b\\x3e\\x4d\\xaa\\x3e\\x7d\\xe6\\xce\\x49\\x89\\xc6\\xe6\\x78\\x0c\\x61\\x31\\x05\\x2d\\x01\\xa4\\x4f\\xa5\\x7e\\x71\\x20\\x88\\xec\\x0d\\x31\\xe8\\x4e\\x0b\\x00\\x6e\\x50\\x68\\x7d\\x17\\x3d\\x08\\x0d\\x17\\x95\\xa6\\x6e\\xa3\\x68\\x97\\x24\\x5b\\x6b\\xf3\\x17\\x23\\xf3\\xb6\\x73\\xb3\\x0d\\x0b\\x40\\xc0\\x9f\\xd8\\x04\\x51\\x5d\\xfa\\x1a\\x17\\x22\\x2e\\x15\\x6a\\xdf\\x49\\x00\\xb9\\xa0\\x77\\x55\\xc6\\xef\\x10\\x6a\\xbf\\x7b\\x47\\x4c\\x7f\\x83\\x17\\x05\\xee\\xdc\\xdc\\x46\\x85\\xa9\\xad\\x53\\x07\\x2b\\x53\\x34\\x06\\x07\\xff\\x14\\x94\\x59\\x19\\x02\\xe4\\x38\\xe8\\x31\\x83\\x4e\\xb9\\x58\\x46\\x6b\\xcb\\x2d\\x23\\x86\\x92\\x70\\x00\\x35\\x88\\x22\\xcf\\x31\\xb2\\x26\\x2f\\xe7\\xc3\\x75\\x2d\\x36\\x2c\\x72\\x74\\xb0\\x23\\x47\\xb7\\xd3\\xd1\\x26\\x16\\x85\\x37\\x72\\xe2\\x00\\x8c\\x44\\xcf\\x10\\xda\\x33\\x2d\\x1a\\xde\\x60\\x86\\x69\\x23\\x69\\x2a\\x7c\\xcd\\x4b\\x51\\x0d\\x95\\x54\\x39\\x77\\x2e\\x29\\xea\\x1b\\xa6\\x50\\xa2\\x6a\\x8f\\x6f\\x50\\x99\\x5c\\x3e\\x54\\xfb\\xef\\x50\\x5b\\x0b\\x07\\x45\\x17\\x89\\x6d\\x28\\x13\\x77\\x37\\x1d\\xdb\\x8e\\x1e\\x4a\\x05\\x66\\x4a\\x6f\\x99\\x20\\xe5\\x70\\xe2\\xb9\\x71\\x7e\\x0c\\x6d\\x49\\x04\\x2d\\x7a\\xfe\\x72\\xc7\\xf2\\x59\\x30\\x8f\\xbb\\x02\\x5d\\x73\\xe5\\xc9\\x20\\xea\\x78\\xec\\x20\\x90\\xf0\\x8a\\x7f\\x42\\x17\\x7c\\x47\\x19\\x60\\xb0\\x16\\xbd\\x26\\xb7\\x71\\xb6\\xc7\\x9f\\x0e\\xd1\\x33\\x82\\x3d\\xd3\\xab\\xee\\x63\\x99\\xc8\\x2b\\x53\\xa0\\x44\\x5c\\x71\\x01\\xc6\\xcc\\x44\\x1f\\x32\\x4f\\x3c\\xca\\xc0\\x29\\x3d\\x52\\xd3\\x61\\x19\\x58\\xa9\\x7d\\x65\\xb4\\xdc\\xcf\\x0d\\xf4\\x3d\\xf1\\x08\\xa9\\x42\\xda\\x23\\x09\\xd8\\xbf\\x5e\\x50\\x49\\xf8\\x4d\\xc0\\xcb\\x47\\x4c\\x1c\\x4f\\xf7\\x7b\\x2b\\xd8\\x16\\x18\\xc5\\x31\\x92\\x3b\\xb5\\x6f\\xdc\\x6c\\x0d\\x92\\x88\\x16\\xd1\\x9e\\xdb\\x3f\\xe2\\xe9\\xda\\x5f\\xd4\\x84\\xe2\\x46\\x61\\x5a\\xde\\x1c\\x55\\xcf\\xa4\\x00\\xbe\\xfd\\xce\\x67\\xf1\\x4a\\x69\\x1c\\x97\\xe6\\x20\\x48\\xd8\\x5d\\x7f\\x7e\\xae\\x71\\x20\\x0e\\x4e\\xae\\xc0\\x56\\xa9\\x91\\x01\\x3c\\x82\\x1d\\x0f\\x72\\xe7\\x76\\xec\\x29\\x49\\xd6\\x5d\\x2d\\x83\\xe3\\xdb\\x36\\x06\\xa9\\x3b\\x66\\x13\\x97\\x87\\x6a\\xd5\\xb6\\x3d\\x50\\x5e\\x52\\xb9\\x4b\\xc7\\x73\\x57\\x78\\xc9\\xf4\\x2e\\x59\\x07\\x95\\x93\\x6f\\xd0\\x4b\\x17\\x57\\x19\\x3e\\x27\\x27\\xc7\\x60\\xdb\\x3b\\xed\\x9a\\x0e\\x53\\x44\\x16\\x3e\\x3f\\x8d\\x92\\x6d\\x77\\xa2\\x0a\\xeb\\x3f\\x52\\xa8\\xc6\\x55\\x5e\\x31\\x49\\x37\\x85\\xf4\\xc5\\x1f\\x26\\x2d\\xa9\\x1c\\xbf\\x8b\\x27\\x54\\xda\\xc3\\x6a\\x20\\xe5\\x2a\\x78\\x04\\xb0\\xd6\\x90\\x70\\x72\\xaa\\x8b\\x68\\xbd\\x88\\xf7\\x02\\x5f\\x48\\xb1\\x7e\\xc0\\x58\\x4c\\x3f\\x66\\x1a\\xf9\\x3e\\xe1\\x65\\xc0\\x70\\xa7\\xcf\\x38\\x69\\xaf\\xf0\\x56\\x6c\\x64\\x49\\x9c\\x27\\xad\\x78\\x74\\x4f\\xc2\\x87\\xde\\x56\\x39\\x00\\xda\\x77\\x0b\\xcb\\x2d\\x1b\\x89\\xfb\\x35\\x4f\\x02\\xf5\\x08\\x51\\x13\\x60\\xc1\\x0a\\x5a\\x47\\x4d\\x26\\x1c\\x33\\x30\\x78\\xda\\xc0\\x9c\\x46\\x47\\xe2\\x5b\\x79\\x60\\x49\\x6e\\x37\\x67\\x53\\x0a\\x3e\\xe9\\xec\\x46\\x39\\xb2\\xf1\\x34\\x0d\\xc6\\x84\\x53\\x75\\x6e\\xe1\\x0c\\x59\\xd9\\x1e\\xde\\x29\\x85\\x10\\x7b\\x49\\x49\\xa5\\x77\\x79\\xbe\\x49\\x56\\x2e\\x36\\xe7\\x0b\\x3a\\xbb\\x4f\\x03\\x62\\x7b\\xd2\\x4d\\x31\\x95\\x2f\\xbd\\x38\\x7b\\xa8\\x4f\\x21\\xe1\\xec\\x46\\x70\\x76\\x95\\x7d\\x29\\x22\\x78\\x88\\x0a\\x90\\xdd\\x9d\\x5c\\xda\\xde\\x19\\x51\\xcf\\xf0\\xfc\\x59\\x52\\x65\\x7c\\x33\\x13\\xdf\\xf3\\x48\\xda\\xbb\\x2a\\x75\\xdb\\x60\\xb2\\x02\\x15\\xd4\\xfc\\x19\\xed\\x1b\\xec\\x7f\\x35\\xa8\\xff\\x28\\x31\\x07\\x2d\\x12\\xc8\\xdc\\x88\\x46\\x7c\\x8a\\x5b\\x22\"\n);\n\n/**\n * Provides metadata using the Google Earth Enterprise REST API. This is used by the GoogleEarthEnterpriseImageryProvider\n *  and GoogleEarthEnterpriseTerrainProvider to share metadata requests.\n *\n * @alias GoogleEarthEnterpriseMetadata\n * @constructor\n *\n * @param {Resource|String} resourceOrUrl The url of the Google Earth Enterprise server hosting the imagery\n *\n * @see GoogleEarthEnterpriseImageryProvider\n * @see GoogleEarthEnterpriseTerrainProvider\n *\n */\nfunction GoogleEarthEnterpriseMetadata(resourceOrUrl) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"resourceOrUrl\", resourceOrUrl);\n  //>>includeEnd('debug');\n\n  let url = resourceOrUrl;\n\n  if (typeof url !== \"string\" && !(url instanceof Resource)) {\n    //>>includeStart('debug', pragmas.debug);\n    Check.typeOf.string(\"resourceOrUrl.url\", resourceOrUrl.url);\n    //>>includeEnd('debug');\n\n    url = resourceOrUrl.url;\n  }\n\n  const resource = Resource.createIfNeeded(url);\n  resource.appendForwardSlash();\n  this._resource = resource;\n\n  /**\n   * True if imagery is available.\n   * @type {Boolean}\n   * @default true\n   */\n  this.imageryPresent = true;\n\n  /**\n   * True if imagery is sent as a protocol buffer, false if sent as plain images. If undefined we will try both.\n   * @type {Boolean}\n   * @default undefined\n   */\n  this.protoImagery = undefined;\n\n  /**\n   * True if terrain is available.\n   * @type {Boolean}\n   * @default true\n   */\n  this.terrainPresent = true;\n\n  /**\n   * Exponent used to compute constant to calculate negative height values.\n   * @type {Number}\n   * @default 32\n   */\n  this.negativeAltitudeExponentBias = 32;\n\n  /**\n   * Threshold where any numbers smaller are actually negative values. They are multiplied by -2^negativeAltitudeExponentBias.\n   * @type {Number}\n   * @default EPSILON12\n   */\n  this.negativeAltitudeThreshold = CesiumMath.EPSILON12;\n\n  /**\n   * Dictionary of provider id to copyright strings.\n   * @type {Object}\n   * @default {}\n   */\n  this.providers = {};\n\n  /**\n   * Key used to decode packets\n   * @type {ArrayBuffer}\n   */\n  this.key = undefined;\n\n  this._quadPacketVersion = 1;\n\n  this._tileInfo = {};\n  this._subtreePromises = {};\n\n  const that = this;\n  this._readyPromise = requestDbRoot(this)\n    .then(function () {\n      return that.getQuadTreePacket(\"\", that._quadPacketVersion);\n    })\n    .then(function () {\n      return true;\n    })\n    .catch(function (e) {\n      const message = `An error occurred while accessing ${\n        getMetadataResource(that, \"\", 1).url\n      }.`;\n      return Promise.reject(new RuntimeError(message));\n    });\n}\n\nObject.defineProperties(GoogleEarthEnterpriseMetadata.prototype, {\n  /**\n   * Gets the name of the Google Earth Enterprise server.\n   * @memberof GoogleEarthEnterpriseMetadata.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._resource.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used for metadata requests.\n   * @memberof GoogleEarthEnterpriseMetadata.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._resource.proxy;\n    },\n  },\n\n  /**\n   * Gets the resource used for metadata requests.\n   * @memberof GoogleEarthEnterpriseMetadata.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the metadata is ready for use.\n   * @memberof GoogleEarthEnterpriseMetadata.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n});\n\n/**\n * Converts a tiles (x, y, level) position into a quadkey used to request an image\n * from a Google Earth Enterprise server.\n *\n * @param {Number} x The tile's x coordinate.\n * @param {Number} y The tile's y coordinate.\n * @param {Number} level The tile's zoom level.\n *\n * @see GoogleEarthEnterpriseMetadata#quadKeyToTileXY\n */\nGoogleEarthEnterpriseMetadata.tileXYToQuadKey = function (x, y, level) {\n  let quadkey = \"\";\n  for (let i = level; i >= 0; --i) {\n    const bitmask = 1 << i;\n    let digit = 0;\n\n    // Tile Layout\n    // ___ ___\n    //|   |   |\n    //| 3 | 2 |\n    //|-------|\n    //| 0 | 1 |\n    //|___|___|\n    //\n\n    if (!isBitSet(y, bitmask)) {\n      // Top Row\n      digit |= 2;\n      if (!isBitSet(x, bitmask)) {\n        // Right to left\n        digit |= 1;\n      }\n    } else if (isBitSet(x, bitmask)) {\n      // Left to right\n      digit |= 1;\n    }\n\n    quadkey += digit;\n  }\n  return quadkey;\n};\n\n/**\n * Converts a tile's quadkey used to request an image from a Google Earth Enterprise server into the\n * (x, y, level) position.\n *\n * @param {String} quadkey The tile's quad key\n *\n * @see GoogleEarthEnterpriseMetadata#tileXYToQuadKey\n */\nGoogleEarthEnterpriseMetadata.quadKeyToTileXY = function (quadkey) {\n  let x = 0;\n  let y = 0;\n  const level = quadkey.length - 1;\n  for (let i = level; i >= 0; --i) {\n    const bitmask = 1 << i;\n    const digit = +quadkey[level - i];\n\n    if (isBitSet(digit, 2)) {\n      // Top Row\n      if (!isBitSet(digit, 1)) {\n        // // Right to left\n        x |= bitmask;\n      }\n    } else {\n      y |= bitmask;\n      if (isBitSet(digit, 1)) {\n        // Left to right\n        x |= bitmask;\n      }\n    }\n  }\n  return {\n    x: x,\n    y: y,\n    level: level,\n  };\n};\n\nGoogleEarthEnterpriseMetadata.prototype.isValid = function (quadKey) {\n  let info = this.getTileInformationFromQuadKey(quadKey);\n  if (defined(info)) {\n    return info !== null;\n  }\n\n  let valid = true;\n  let q = quadKey;\n  let last;\n  while (q.length > 1) {\n    last = q.substring(q.length - 1);\n    q = q.substring(0, q.length - 1);\n    info = this.getTileInformationFromQuadKey(q);\n    if (defined(info)) {\n      if (!info.hasSubtree() && !info.hasChild(parseInt(last))) {\n        // We have no subtree or child available at some point in this node's ancestry\n        valid = false;\n      }\n\n      break;\n    } else if (info === null) {\n      // Some node in the ancestry was loaded and said there wasn't a subtree\n      valid = false;\n      break;\n    }\n  }\n\n  return valid;\n};\n\nconst taskProcessor = new TaskProcessor(\"decodeGoogleEarthEnterprisePacket\");\n\n/**\n * Retrieves a Google Earth Enterprise quadtree packet.\n *\n * @param {String} [quadKey=''] The quadkey to retrieve the packet for.\n * @param {Number} [version=1] The cnode version to be used in the request.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @private\n */\nGoogleEarthEnterpriseMetadata.prototype.getQuadTreePacket = function (\n  quadKey,\n  version,\n  request\n) {\n  version = defaultValue(version, 1);\n  quadKey = defaultValue(quadKey, \"\");\n  const resource = getMetadataResource(this, quadKey, version, request);\n\n  const promise = resource.fetchArrayBuffer();\n\n  if (!defined(promise)) {\n    return undefined; // Throttled\n  }\n\n  const tileInfo = this._tileInfo;\n  const key = this.key;\n  return promise.then(function (metadata) {\n    const decodePromise = taskProcessor.scheduleTask(\n      {\n        buffer: metadata,\n        quadKey: quadKey,\n        type: \"Metadata\",\n        key: key,\n      },\n      [metadata]\n    );\n\n    return decodePromise.then(function (result) {\n      let root;\n      let topLevelKeyLength = -1;\n      if (quadKey !== \"\") {\n        // Root tile has no data except children bits, so put them into the tile info\n        topLevelKeyLength = quadKey.length + 1;\n        const top = result[quadKey];\n        root = tileInfo[quadKey];\n        root._bits |= top._bits;\n\n        delete result[quadKey];\n      }\n\n      // Copy the resulting objects into tileInfo\n      // Make sure we start with shorter quadkeys first, so we know the parents have\n      //  already been processed. Otherwise we can lose ancestorHasTerrain along the way.\n      const keys = Object.keys(result);\n      keys.sort(function (a, b) {\n        return a.length - b.length;\n      });\n      const keysLength = keys.length;\n      for (let i = 0; i < keysLength; ++i) {\n        const key = keys[i];\n        const r = result[key];\n        if (r !== null) {\n          const info = GoogleEarthEnterpriseTileInformation.clone(result[key]);\n          const keyLength = key.length;\n          if (keyLength === topLevelKeyLength) {\n            info.setParent(root);\n          } else if (keyLength > 1) {\n            const parent = tileInfo[key.substring(0, key.length - 1)];\n            info.setParent(parent);\n          }\n          tileInfo[key] = info;\n        } else {\n          tileInfo[key] = null;\n        }\n      }\n    });\n  });\n};\n\n/**\n * Populates the metadata subtree down to the specified tile.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise<GoogleEarthEnterpriseTileInformation>} A promise that resolves to the tile info for the requested quad key\n *\n * @private\n */\nGoogleEarthEnterpriseMetadata.prototype.populateSubtree = function (\n  x,\n  y,\n  level,\n  request\n) {\n  const quadkey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  return populateSubtree(this, quadkey, request);\n};\n\nfunction populateSubtree(that, quadKey, request) {\n  const tileInfo = that._tileInfo;\n  let q = quadKey;\n  let t = tileInfo[q];\n  // If we have tileInfo make sure sure it is not a node with a subtree that's not loaded\n  if (defined(t) && (!t.hasSubtree() || t.hasChildren())) {\n    return t;\n  }\n\n  while (t === undefined && q.length > 1) {\n    q = q.substring(0, q.length - 1);\n    t = tileInfo[q];\n  }\n\n  let subtreeRequest;\n  const subtreePromises = that._subtreePromises;\n  let promise = subtreePromises[q];\n  if (defined(promise)) {\n    return promise.then(function () {\n      // Recursively call this in case we need multiple subtree requests\n      subtreeRequest = new Request({\n        throttle: request.throttle,\n        throttleByServer: request.throttleByServer,\n        type: request.type,\n        priorityFunction: request.priorityFunction,\n      });\n      return populateSubtree(that, quadKey, subtreeRequest);\n    });\n  }\n\n  // t is either\n  //   null so one of its parents was a leaf node, so this tile doesn't exist\n  //   exists but doesn't have a subtree to request\n  //   undefined so no parent exists - this shouldn't ever happen once the provider is ready\n  if (!defined(t) || !t.hasSubtree()) {\n    return Promise.reject(\n      new RuntimeError(`Couldn't load metadata for tile ${quadKey}`)\n    );\n  }\n\n  // We need to split up the promise here because when will execute syncronously if getQuadTreePacket\n  //  is already resolved (like in the tests), so subtreePromises will never get cleared out.\n  //  Only the initial request will also remove the promise from subtreePromises.\n  promise = that.getQuadTreePacket(q, t.cnodeVersion, request);\n  if (!defined(promise)) {\n    return undefined;\n  }\n  subtreePromises[q] = promise;\n\n  return promise\n    .then(function () {\n      // Recursively call this in case we need multiple subtree requests\n      subtreeRequest = new Request({\n        throttle: request.throttle,\n        throttleByServer: request.throttleByServer,\n        type: request.type,\n        priorityFunction: request.priorityFunction,\n      });\n      return populateSubtree(that, quadKey, subtreeRequest);\n    })\n    .finally(function () {\n      delete subtreePromises[q];\n    });\n}\n\n/**\n * Gets information about a tile\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @returns {GoogleEarthEnterpriseTileInformation|undefined} Information about the tile or undefined if it isn't loaded.\n *\n * @private\n */\nGoogleEarthEnterpriseMetadata.prototype.getTileInformation = function (\n  x,\n  y,\n  level\n) {\n  const quadkey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  return this._tileInfo[quadkey];\n};\n\n/**\n * Gets information about a tile from a quadKey\n *\n * @param {String} quadkey The quadkey for the tile\n * @returns {GoogleEarthEnterpriseTileInformation|undefined} Information about the tile or undefined if it isn't loaded.\n *\n * @private\n */\nGoogleEarthEnterpriseMetadata.prototype.getTileInformationFromQuadKey = function (\n  quadkey\n) {\n  return this._tileInfo[quadkey];\n};\n\nfunction getMetadataResource(that, quadKey, version, request) {\n  return that._resource.getDerivedResource({\n    url: `flatfile?q2-0${quadKey}-q.${version.toString()}`,\n    request: request,\n  });\n}\n\nlet dbrootParser;\nlet dbrootParserPromise;\nfunction requestDbRoot(that) {\n  const resource = that._resource.getDerivedResource({\n    url: \"dbRoot.v5\",\n    queryParameters: {\n      output: \"proto\",\n    },\n  });\n\n  if (!defined(dbrootParserPromise)) {\n    const url = buildModuleUrl(\"ThirdParty/google-earth-dbroot-parser.js\");\n    const oldValue = window.cesiumGoogleEarthDbRootParser;\n    dbrootParserPromise = loadAndExecuteScript(url).then(function () {\n      dbrootParser = window.cesiumGoogleEarthDbRootParser(protobuf);\n      if (defined(oldValue)) {\n        window.cesiumGoogleEarthDbRootParser = oldValue;\n      } else {\n        delete window.cesiumGoogleEarthDbRootParser;\n      }\n    });\n  }\n\n  return dbrootParserPromise\n    .then(function () {\n      return resource.fetchArrayBuffer();\n    })\n    .then(function (buf) {\n      const encryptedDbRootProto = dbrootParser.EncryptedDbRootProto.decode(\n        new Uint8Array(buf)\n      );\n\n      let byteArray = encryptedDbRootProto.encryptionData;\n      let offset = byteArray.byteOffset;\n      let end = offset + byteArray.byteLength;\n      const key = (that.key = byteArray.buffer.slice(offset, end));\n\n      byteArray = encryptedDbRootProto.dbrootData;\n      offset = byteArray.byteOffset;\n      end = offset + byteArray.byteLength;\n      const dbRootCompressed = byteArray.buffer.slice(offset, end);\n      return taskProcessor.scheduleTask(\n        {\n          buffer: dbRootCompressed,\n          type: \"DbRoot\",\n          key: key,\n        },\n        [dbRootCompressed]\n      );\n    })\n    .then(function (result) {\n      const dbRoot = dbrootParser.DbRootProto.decode(\n        new Uint8Array(result.buffer)\n      );\n      that.imageryPresent = defaultValue(\n        dbRoot.imageryPresent,\n        that.imageryPresent\n      );\n      that.protoImagery = dbRoot.protoImagery;\n      that.terrainPresent = defaultValue(\n        dbRoot.terrainPresent,\n        that.terrainPresent\n      );\n      if (defined(dbRoot.endSnippet) && defined(dbRoot.endSnippet.model)) {\n        const model = dbRoot.endSnippet.model;\n        that.negativeAltitudeExponentBias = defaultValue(\n          model.negativeAltitudeExponentBias,\n          that.negativeAltitudeExponentBias\n        );\n        that.negativeAltitudeThreshold = defaultValue(\n          model.compressedNegativeAltitudeThreshold,\n          that.negativeAltitudeThreshold\n        );\n      }\n      if (defined(dbRoot.databaseVersion)) {\n        that._quadPacketVersion = defaultValue(\n          dbRoot.databaseVersion.quadtreeVersion,\n          that._quadPacketVersion\n        );\n      }\n      const providers = that.providers;\n      const providerInfo = defaultValue(dbRoot.providerInfo, []);\n      const count = providerInfo.length;\n      for (let i = 0; i < count; ++i) {\n        const provider = providerInfo[i];\n        const copyrightString = provider.copyrightString;\n        if (defined(copyrightString)) {\n          providers[provider.providerId] = new Credit(copyrightString.value);\n        }\n      }\n    })\n    .catch(function () {\n      // Just eat the error and use the default values.\n      console.log(`Failed to retrieve ${resource.url}. Using defaults.`);\n      that.key = defaultKey;\n    });\n}\nexport default GoogleEarthEnterpriseMetadata;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile from a Google Earth Enterprise server.\n *\n * @alias GoogleEarthEnterpriseTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {ArrayBuffer} options.buffer The buffer containing terrain data.\n * @param {Number} options.negativeAltitudeExponentBias Multiplier for negative terrain heights that are encoded as very small positive values.\n * @param {Number} options.negativeElevationThreshold Threshold for negative values\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * const buffer = ...\n * const childTileMask = ...\n * const terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({\n *   buffer : heightBuffer,\n *   childTileMask : childTileMask\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see QuantizedMeshTerrainData\n */\nfunction GoogleEarthEnterpriseTerrainData(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.buffer\", options.buffer);\n  Check.typeOf.number(\n    \"options.negativeAltitudeExponentBias\",\n    options.negativeAltitudeExponentBias\n  );\n  Check.typeOf.number(\n    \"options.negativeElevationThreshold\",\n    options.negativeElevationThreshold\n  );\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._credits = options.credits;\n  this._negativeAltitudeExponentBias = options.negativeAltitudeExponentBias;\n  this._negativeElevationThreshold = options.negativeElevationThreshold;\n\n  // Convert from google layout to layout of other providers\n  // 3 2 -> 2 3\n  // 0 1 -> 0 1\n  const googleChildTileMask = defaultValue(options.childTileMask, 15);\n  let childTileMask = googleChildTileMask & 3; // Bottom row is identical\n  childTileMask |= googleChildTileMask & 4 ? 8 : 0; // NE\n  childTileMask |= googleChildTileMask & 8 ? 4 : 0; // NW\n\n  this._childTileMask = childTileMask;\n\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n\n  this._skirtHeight = undefined;\n  this._bufferType = this._buffer.constructor;\n  this._mesh = undefined;\n  this._minimumHeight = undefined;\n  this._maximumHeight = undefined;\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainData.prototype, {\n  /**\n   * An array of credits for this tile\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\nconst createMeshTaskName = \"createVerticesFromGoogleEarthEnterpriseBuffer\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks\n);\n\nconst nativeRectangleScratch = new Rectangle();\nconst rectangleScratch = new Rectangle();\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Number} [options.exaggerationRelativeHeight=0.0] The height from which terrain is exaggerated.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nGoogleEarthEnterpriseTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(\n    options.exaggerationRelativeHeight,\n    0.0\n  );\n  const throttle = defaultValue(options.throttle, true);\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  tilingScheme.tileXYToNativeRectangle(x, y, level, nativeRectangleScratch);\n  tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(\n    Rectangle.center(rectangleScratch)\n  );\n\n  const levelZeroMaxError = 40075.16; // From Google's Doc\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 8.0, 1000.0);\n\n  const createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    buffer: this._buffer,\n    nativeRectangle: nativeRectangleScratch,\n    rectangle: rectangleScratch,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n    includeWebMercatorT: true,\n    negativeAltitudeExponentBias: this._negativeAltitudeExponentBias,\n    negativeElevationThreshold: this._negativeElevationThreshold,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return verticesPromise.then(function (result) {\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      center,\n      new Float32Array(result.vertices),\n      new Uint16Array(result.indices),\n      result.indexCountWithoutSkirts,\n      result.vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      BoundingSphere.clone(result.boundingSphere3D),\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      TerrainEncoding.clone(result.encoding),\n      result.westIndicesSouthToNorth,\n      result.southIndicesEastToWest,\n      result.eastIndicesNorthToSouth,\n      result.northIndicesWestToEast\n    );\n\n    that._minimumHeight = result.minimumHeight;\n    that._maximumHeight = result.maximumHeight;\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nGoogleEarthEnterpriseTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  const u = CesiumMath.clamp(\n    (longitude - rectangle.west) / rectangle.width,\n    0.0,\n    1.0\n  );\n  const v = CesiumMath.clamp(\n    (latitude - rectangle.south) / rectangle.height,\n    0.0,\n    1.0\n  );\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v, rectangle);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nconst upsampleTaskProcessor = new TaskProcessor(\n  \"upsampleQuantizedTerrainMesh\",\n  TerrainData.maximumAsynchronousTasks\n);\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nGoogleEarthEnterpriseTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tilingScheme\", tilingScheme);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"thisLevel\", thisLevel);\n  Check.typeOf.number(\"descendantX\", descendantX);\n  Check.typeOf.number(\"descendantY\", descendantY);\n  Check.typeOf.number(\"descendantLevel\", descendantLevel);\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  const isEastChild = thisX * 2 !== descendantX;\n  const isNorthChild = thisY * 2 === descendantY;\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const childRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  const upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return upsamplePromise.then(function (result) {\n    const quantizedVertices = new Uint16Array(result.vertices);\n    const indicesTypedArray = IndexDatatype.createTypedArray(\n      quantizedVertices.length / 3,\n      result.indices\n    );\n\n    const skirtHeight = that._skirtHeight;\n\n    // Use QuantizedMeshTerrainData since we have what we need already parsed\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(\n        result.orientedBoundingBox\n      ),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: skirtHeight,\n      southSkirtHeight: skirtHeight,\n      eastSkirtHeight: skirtHeight,\n      northSkirtHeight: skirtHeight,\n      childTileMask: 0,\n      createdByUpsampling: true,\n      credits: that._credits,\n    });\n  });\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"childX\", childX);\n  Check.typeOf.number(\"childY\", childY);\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nconst texCoordScratch0 = new Cartesian2();\nconst texCoordScratch1 = new Cartesian2();\nconst texCoordScratch2 = new Cartesian2();\nconst barycentricCoordinateScratch = new Cartesian3();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  const mesh = terrainData._mesh;\n  const vertices = mesh.vertices;\n  const encoding = mesh.encoding;\n  const indices = mesh.indices;\n\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const uv0 = encoding.decodeTextureCoordinates(\n      vertices,\n      i0,\n      texCoordScratch0\n    );\n    const uv1 = encoding.decodeTextureCoordinates(\n      vertices,\n      i1,\n      texCoordScratch1\n    );\n    const uv2 = encoding.decodeTextureCoordinates(\n      vertices,\n      i2,\n      texCoordScratch2\n    );\n\n    const barycentric = Intersections2D.computeBarycentricCoordinates(\n      u,\n      v,\n      uv0.x,\n      uv0.y,\n      uv1.x,\n      uv1.y,\n      uv2.x,\n      uv2.y,\n      barycentricCoordinateScratch\n    );\n    if (\n      barycentric.x >= -1e-15 &&\n      barycentric.y >= -1e-15 &&\n      barycentric.z >= -1e-15\n    ) {\n      const h0 = encoding.decodeHeight(vertices, i0);\n      const h1 = encoding.decodeHeight(vertices, i1);\n      const h2 = encoding.decodeHeight(vertices, i2);\n      return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\nconst sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nconst sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nconst sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nconst sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\n\nfunction interpolateHeight(terrainData, u, v, rectangle) {\n  const buffer = terrainData._buffer;\n  let quad = 0; // SW\n  let uStart = 0.0;\n  let vStart = 0.0;\n  if (v > 0.5) {\n    // Upper row\n    if (u > 0.5) {\n      // NE\n      quad = 2;\n      uStart = 0.5;\n    } else {\n      // NW\n      quad = 3;\n    }\n    vStart = 0.5;\n  } else if (u > 0.5) {\n    // SE\n    quad = 1;\n    uStart = 0.5;\n  }\n\n  const dv = new DataView(buffer);\n  let offset = 0;\n  for (let q = 0; q < quad; ++q) {\n    offset += dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n  }\n  offset += sizeOfUint32; // Skip length of quad\n  offset += 2 * sizeOfDouble; // Skip origin\n\n  // Read sizes\n  const xSize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n  const ySize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n\n  // Samples per quad\n  const xScale = rectangle.width / xSize / 2;\n  const yScale = rectangle.height / ySize / 2;\n\n  // Number of points\n  const numPoints = dv.getInt32(offset, true);\n  offset += sizeOfInt32;\n\n  // Number of faces\n  const numIndices = dv.getInt32(offset, true) * 3;\n  offset += sizeOfInt32;\n\n  offset += sizeOfInt32; // Skip Level\n\n  const uBuffer = new Array(numPoints);\n  const vBuffer = new Array(numPoints);\n  const heights = new Array(numPoints);\n  let i;\n  for (i = 0; i < numPoints; ++i) {\n    uBuffer[i] = uStart + dv.getUint8(offset++) * xScale;\n    vBuffer[i] = vStart + dv.getUint8(offset++) * yScale;\n\n    // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n    heights[i] = dv.getFloat32(offset, true) * 6371010.0;\n    offset += sizeOfFloat;\n  }\n\n  const indices = new Array(numIndices);\n  for (i = 0; i < numIndices; ++i) {\n    indices[i] = dv.getUint16(offset, true);\n    offset += sizeOfUint16;\n  }\n\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const u0 = uBuffer[i0];\n    const u1 = uBuffer[i1];\n    const u2 = uBuffer[i2];\n\n    const v0 = vBuffer[i0];\n    const v1 = vBuffer[i1];\n    const v2 = vBuffer[i2];\n\n    const barycentric = Intersections2D.computeBarycentricCoordinates(\n      u,\n      v,\n      u0,\n      v0,\n      u1,\n      v1,\n      u2,\n      v2,\n      barycentricCoordinateScratch\n    );\n    if (\n      barycentric.x >= -1e-15 &&\n      barycentric.y >= -1e-15 &&\n      barycentric.z >= -1e-15\n    ) {\n      return (\n        barycentric.x * heights[i0] +\n        barycentric.y * heights[i1] +\n        barycentric.z * heights[i2]\n      );\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\nexport default GoogleEarthEnterpriseTerrainData;\n","import Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport GoogleEarthEnterpriseMetadata from \"./GoogleEarthEnterpriseMetadata.js\";\nimport GoogleEarthEnterpriseTerrainData from \"./GoogleEarthEnterpriseTerrainData.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TileProviderError from \"./TileProviderError.js\";\n\nconst TerrainState = {\n  UNKNOWN: 0,\n  NONE: 1,\n  SELF: 2,\n  PARENT: 3,\n};\n\nconst julianDateScratch = new JulianDate();\n\nfunction TerrainCache() {\n  this._terrainCache = {};\n  this._lastTidy = JulianDate.now();\n}\n\nTerrainCache.prototype.add = function (quadKey, buffer) {\n  this._terrainCache[quadKey] = {\n    buffer: buffer,\n    timestamp: JulianDate.now(),\n  };\n};\n\nTerrainCache.prototype.get = function (quadKey) {\n  const terrainCache = this._terrainCache;\n  const result = terrainCache[quadKey];\n  if (defined(result)) {\n    delete this._terrainCache[quadKey];\n    return result.buffer;\n  }\n};\n\nTerrainCache.prototype.tidy = function () {\n  JulianDate.now(julianDateScratch);\n  if (JulianDate.secondsDifference(julianDateScratch, this._lastTidy) > 10) {\n    const terrainCache = this._terrainCache;\n    const keys = Object.keys(terrainCache);\n    const count = keys.length;\n    for (let i = 0; i < count; ++i) {\n      const k = keys[i];\n      const e = terrainCache[k];\n      if (JulianDate.secondsDifference(julianDateScratch, e.timestamp) > 10) {\n        delete terrainCache[k];\n      }\n    }\n\n    JulianDate.clone(julianDateScratch, this._lastTidy);\n  }\n};\n\n/**\n * Provides tiled terrain using the Google Earth Enterprise REST API.\n *\n * @alias GoogleEarthEnterpriseTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url of the Google Earth Enterprise server hosting the imagery.\n * @param {GoogleEarthEnterpriseMetadata} options.metadata A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseImageryProvider.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @see GoogleEarthEnterpriseImageryProvider\n * @see CesiumTerrainProvider\n *\n * @example\n * const geeMetadata = new GoogleEarthEnterpriseMetadata('http://www.earthenterprise.org/3d');\n * const gee = new Cesium.GoogleEarthEnterpriseTerrainProvider({\n *     metadata : geeMetadata\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nfunction GoogleEarthEnterpriseTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!(defined(options.url) || defined(options.metadata))) {\n    throw new DeveloperError(\"options.url or options.metadata is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let metadata;\n  if (defined(options.metadata)) {\n    metadata = options.metadata;\n  } else {\n    const resource = Resource.createIfNeeded(options.url);\n    metadata = new GoogleEarthEnterpriseMetadata(resource);\n  }\n\n  this._metadata = metadata;\n  this._tilingScheme = new GeographicTilingScheme({\n    numberOfLevelZeroTilesX: 2,\n    numberOfLevelZeroTilesY: 2,\n    rectangle: new Rectangle(\n      -CesiumMath.PI,\n      -CesiumMath.PI,\n      CesiumMath.PI,\n      CesiumMath.PI\n    ),\n    ellipsoid: options.ellipsoid,\n  });\n\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Pulled from Google's documentation\n  this._levelZeroMaximumGeometricError = 40075.16;\n\n  this._terrainCache = new TerrainCache();\n  this._terrainPromises = {};\n  this._terrainRequests = {};\n\n  this._errorEvent = new Event();\n\n  this._ready = false;\n  const that = this;\n  let metadataError;\n  this._readyPromise = metadata.readyPromise\n    .then(function (result) {\n      if (!metadata.terrainPresent) {\n        const e = new RuntimeError(\n          `The server ${metadata.url} doesn't have terrain`\n        );\n        metadataError = TileProviderError.handleError(\n          metadataError,\n          that,\n          that._errorEvent,\n          e.message,\n          undefined,\n          undefined,\n          undefined,\n          e\n        );\n        return Promise.reject(e);\n      }\n\n      TileProviderError.handleSuccess(metadataError);\n      that._ready = result;\n      return result;\n    })\n    .catch(function (e) {\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        e.message,\n        undefined,\n        undefined,\n        undefined,\n        e\n      );\n      return Promise.reject(e);\n    });\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainProvider.prototype, {\n  /**\n   * Gets the name of the Google Earth Enterprise server url hosting the imagery.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._metadata.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._metadata.proxy;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\nconst taskProcessor = new TaskProcessor(\"decodeGoogleEarthEnterprisePacket\");\n\n// If the tile has its own terrain, then you can just use its child bitmask. If it was requested using it's parent\n//  then you need to check all of its children to see if they have terrain.\nfunction computeChildMask(quadKey, info, metadata) {\n  let childMask = info.getChildBitmask();\n  if (info.terrainState === TerrainState.PARENT) {\n    childMask = 0;\n    for (let i = 0; i < 4; ++i) {\n      const child = metadata.getTileInformationFromQuadKey(\n        quadKey + i.toString()\n      );\n      if (defined(child) && child.hasTerrain()) {\n        childMask |= 1 << i;\n      }\n    }\n  }\n\n  return childMask;\n}\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n *\n * @exception {DeveloperError} This function must not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready}\n *            returns true.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestTileGeometry must not be called before the terrain provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  const terrainCache = this._terrainCache;\n  const metadata = this._metadata;\n  const info = metadata.getTileInformationFromQuadKey(quadKey);\n\n  // Check if this tile is even possibly available\n  if (!defined(info)) {\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  let terrainState = info.terrainState;\n  if (!defined(terrainState)) {\n    // First time we have tried to load this tile, so set terrain state to UNKNOWN\n    terrainState = info.terrainState = TerrainState.UNKNOWN;\n  }\n\n  // If its in the cache, return it\n  const buffer = terrainCache.get(quadKey);\n  if (defined(buffer)) {\n    const credit = metadata.providers[info.terrainProvider];\n    return Promise.resolve(\n      new GoogleEarthEnterpriseTerrainData({\n        buffer: buffer,\n        childTileMask: computeChildMask(quadKey, info, metadata),\n        credits: defined(credit) ? [credit] : undefined,\n        negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n        negativeElevationThreshold: metadata.negativeAltitudeThreshold,\n      })\n    );\n  }\n\n  // Clean up the cache\n  terrainCache.tidy();\n\n  // We have a tile, check to see if no ancestors have terrain or that we know for sure it doesn't\n  if (!info.ancestorHasTerrain) {\n    // We haven't reached a level with terrain, so return the ellipsoid\n    return Promise.resolve(\n      new HeightmapTerrainData({\n        buffer: new Uint8Array(16 * 16),\n        width: 16,\n        height: 16,\n      })\n    );\n  } else if (terrainState === TerrainState.NONE) {\n    // Already have info and there isn't any terrain here\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  // Figure out where we are getting the terrain and what version\n  let parentInfo;\n  let q = quadKey;\n  let terrainVersion = -1;\n  switch (terrainState) {\n    case TerrainState.SELF: // We have terrain and have retrieved it before\n      terrainVersion = info.terrainVersion;\n      break;\n    case TerrainState.PARENT: // We have terrain in our parent\n      q = q.substring(0, q.length - 1);\n      parentInfo = metadata.getTileInformationFromQuadKey(q);\n      terrainVersion = parentInfo.terrainVersion;\n      break;\n    case TerrainState.UNKNOWN: // We haven't tried to retrieve terrain yet\n      if (info.hasTerrain()) {\n        terrainVersion = info.terrainVersion; // We should have terrain\n      } else {\n        q = q.substring(0, q.length - 1);\n        parentInfo = metadata.getTileInformationFromQuadKey(q);\n        if (defined(parentInfo) && parentInfo.hasTerrain()) {\n          terrainVersion = parentInfo.terrainVersion; // Try checking in the parent\n        }\n      }\n      break;\n  }\n\n  // We can't figure out where to get the terrain\n  if (terrainVersion < 0) {\n    return Promise.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  // Load that terrain\n  const terrainPromises = this._terrainPromises;\n  const terrainRequests = this._terrainRequests;\n  let sharedPromise;\n  let sharedRequest;\n  if (defined(terrainPromises[q])) {\n    // Already being loaded possibly from another child, so return existing promise\n    sharedPromise = terrainPromises[q];\n    sharedRequest = terrainRequests[q];\n  } else {\n    // Create new request for terrain\n    sharedRequest = request;\n    const requestPromise = buildTerrainResource(\n      this,\n      q,\n      terrainVersion,\n      sharedRequest\n    ).fetchArrayBuffer();\n\n    if (!defined(requestPromise)) {\n      return undefined; // Throttled\n    }\n\n    sharedPromise = requestPromise.then(function (terrain) {\n      if (defined(terrain)) {\n        return taskProcessor\n          .scheduleTask(\n            {\n              buffer: terrain,\n              type: \"Terrain\",\n              key: metadata.key,\n            },\n            [terrain]\n          )\n          .then(function (terrainTiles) {\n            // Add requested tile and mark it as SELF\n            const requestedInfo = metadata.getTileInformationFromQuadKey(q);\n            requestedInfo.terrainState = TerrainState.SELF;\n            terrainCache.add(q, terrainTiles[0]);\n            const provider = requestedInfo.terrainProvider;\n\n            // Add children to cache\n            const count = terrainTiles.length - 1;\n            for (let j = 0; j < count; ++j) {\n              const childKey = q + j.toString();\n              const child = metadata.getTileInformationFromQuadKey(childKey);\n              if (defined(child)) {\n                terrainCache.add(childKey, terrainTiles[j + 1]);\n                child.terrainState = TerrainState.PARENT;\n                if (child.terrainProvider === 0) {\n                  child.terrainProvider = provider;\n                }\n              }\n            }\n          });\n      }\n\n      return Promise.reject(new RuntimeError(\"Failed to load terrain.\"));\n    });\n\n    terrainPromises[q] = sharedPromise; // Store promise without delete from terrainPromises\n    terrainRequests[q] = sharedRequest;\n\n    // Set promise so we remove from terrainPromises just one time\n    sharedPromise = sharedPromise.finally(function () {\n      delete terrainPromises[q];\n      delete terrainRequests[q];\n    });\n  }\n\n  return sharedPromise\n    .then(function () {\n      const buffer = terrainCache.get(quadKey);\n      if (defined(buffer)) {\n        const credit = metadata.providers[info.terrainProvider];\n        return new GoogleEarthEnterpriseTerrainData({\n          buffer: buffer,\n          childTileMask: computeChildMask(quadKey, info, metadata),\n          credits: defined(credit) ? [credit] : undefined,\n          negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n          negativeElevationThreshold: metadata.negativeAltitudeThreshold,\n        });\n      }\n\n      return Promise.reject(new RuntimeError(\"Failed to load terrain.\"));\n    })\n    .catch(function (error) {\n      if (sharedRequest.state === RequestState.CANCELLED) {\n        request.state = sharedRequest.state;\n        return Promise.reject(error);\n      }\n      info.terrainState = TerrainState.NONE;\n      return Promise.reject(error);\n    });\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  const metadata = this._metadata;\n  let quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n\n  const info = metadata.getTileInformation(x, y, level);\n  if (info === null) {\n    return false;\n  }\n\n  if (defined(info)) {\n    if (!info.ancestorHasTerrain) {\n      return true; // We'll just return the ellipsoid\n    }\n\n    const terrainState = info.terrainState;\n    if (terrainState === TerrainState.NONE) {\n      return false; // Terrain is not available\n    }\n\n    if (!defined(terrainState) || terrainState === TerrainState.UNKNOWN) {\n      info.terrainState = TerrainState.UNKNOWN;\n      if (!info.hasTerrain()) {\n        quadKey = quadKey.substring(0, quadKey.length - 1);\n        const parentInfo = metadata.getTileInformationFromQuadKey(quadKey);\n        if (!defined(parentInfo) || !parentInfo.hasTerrain()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  if (metadata.isValid(quadKey)) {\n    // We will need this tile, so request metadata and return false for now\n    const request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.TERRAIN,\n    });\n    metadata.populateSubtree(x, y, level, request);\n  }\n  return false;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined}\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n//\n// Functions to handle imagery packets\n//\nfunction buildTerrainResource(terrainProvider, quadKey, version, request) {\n  version = defined(version) && version > 0 ? version : 1;\n  return terrainProvider._metadata.resource.getDerivedResource({\n    url: `flatfile?f1c-0${quadKey}-t.${version.toString()}`,\n    request: request,\n  });\n}\nexport default GoogleEarthEnterpriseTerrainProvider;\n","import defined from \"./defined.js\";\nimport isBitSet from \"./isBitSet.js\";\n\n// Bitmask for checking tile properties\nconst childrenBitmasks = [0x01, 0x02, 0x04, 0x08];\nconst anyChildBitmask = 0x0f;\nconst cacheFlagBitmask = 0x10; // True if there is a child subtree\nconst imageBitmask = 0x40;\nconst terrainBitmask = 0x80;\n\n/**\n * Contains information about each tile from a Google Earth Enterprise server\n *\n * @param {Number} bits Bitmask that contains the type of data and available children for each tile.\n * @param {Number} cnodeVersion Version of the request for subtree metadata.\n * @param {Number} imageryVersion Version of the request for imagery tile.\n * @param {Number} terrainVersion Version of the request for terrain tile.\n * @param {Number} imageryProvider Id of imagery provider.\n * @param {Number} terrainProvider Id of terrain provider.\n *\n * @private\n */\nfunction GoogleEarthEnterpriseTileInformation(\n  bits,\n  cnodeVersion,\n  imageryVersion,\n  terrainVersion,\n  imageryProvider,\n  terrainProvider\n) {\n  this._bits = bits;\n  this.cnodeVersion = cnodeVersion;\n  this.imageryVersion = imageryVersion;\n  this.terrainVersion = terrainVersion;\n  this.imageryProvider = imageryProvider;\n  this.terrainProvider = terrainProvider;\n  this.ancestorHasTerrain = false; // Set it later once we find its parent\n  this.terrainState = undefined;\n}\n\n/**\n * Creates GoogleEarthEnterpriseTileInformation from an object\n *\n * @param {Object} info Object to be cloned\n * @param {GoogleEarthEnterpriseTileInformation} [result] The object onto which to store the result.\n * @returns {GoogleEarthEnterpriseTileInformation} The modified result parameter or a new GoogleEarthEnterpriseTileInformation instance if none was provided.\n */\nGoogleEarthEnterpriseTileInformation.clone = function (info, result) {\n  if (!defined(result)) {\n    result = new GoogleEarthEnterpriseTileInformation(\n      info._bits,\n      info.cnodeVersion,\n      info.imageryVersion,\n      info.terrainVersion,\n      info.imageryProvider,\n      info.terrainProvider\n    );\n  } else {\n    result._bits = info._bits;\n    result.cnodeVersion = info.cnodeVersion;\n    result.imageryVersion = info.imageryVersion;\n    result.terrainVersion = info.terrainVersion;\n    result.imageryProvider = info.imageryProvider;\n    result.terrainProvider = info.terrainProvider;\n  }\n  result.ancestorHasTerrain = info.ancestorHasTerrain;\n  result.terrainState = info.terrainState;\n\n  return result;\n};\n\n/**\n * Sets the parent for the tile\n *\n * @param {GoogleEarthEnterpriseTileInformation} parent Parent tile\n */\nGoogleEarthEnterpriseTileInformation.prototype.setParent = function (parent) {\n  this.ancestorHasTerrain = parent.ancestorHasTerrain || this.hasTerrain();\n};\n\n/**\n * Gets whether a subtree is available\n *\n * @returns {Boolean} true if subtree is available, false otherwise.\n */\nGoogleEarthEnterpriseTileInformation.prototype.hasSubtree = function () {\n  return isBitSet(this._bits, cacheFlagBitmask);\n};\n\n/**\n * Gets whether imagery is available\n *\n * @returns {Boolean} true if imagery is available, false otherwise.\n */\nGoogleEarthEnterpriseTileInformation.prototype.hasImagery = function () {\n  return isBitSet(this._bits, imageBitmask);\n};\n\n/**\n * Gets whether terrain is available\n *\n * @returns {Boolean} true if terrain is available, false otherwise.\n */\nGoogleEarthEnterpriseTileInformation.prototype.hasTerrain = function () {\n  return isBitSet(this._bits, terrainBitmask);\n};\n\n/**\n * Gets whether any children are present\n *\n * @returns {Boolean} true if any children are available, false otherwise.\n */\nGoogleEarthEnterpriseTileInformation.prototype.hasChildren = function () {\n  return isBitSet(this._bits, anyChildBitmask);\n};\n\n/**\n * Gets whether a specified child is available\n *\n * @param {Number} index Index of child tile\n *\n * @returns {Boolean} true if child is available, false otherwise\n */\nGoogleEarthEnterpriseTileInformation.prototype.hasChild = function (index) {\n  return isBitSet(this._bits, childrenBitmasks[index]);\n};\n\n/**\n * Gets bitmask containing children\n *\n * @returns {Number} Children bitmask\n */\nGoogleEarthEnterpriseTileInformation.prototype.getChildBitmask = function () {\n  return this._bits & anyChildBitmask;\n};\nexport default GoogleEarthEnterpriseTileInformation;\n","/**\n * Represents a Gregorian date in a more precise format than the JavaScript Date object.\n * In addition to submillisecond precision, this object can also represent leap seconds.\n * @alias GregorianDate\n * @constructor\n *\n * @param {Number} [year] The year as a whole number.\n * @param {Number} [month] The month as a whole number with range [1, 12].\n * @param {Number} [day] The day of the month as a whole number starting at 1.\n * @param {Number} [hour] The hour as a whole number with range [0, 23].\n * @param {Number} [minute] The minute of the hour as a whole number with range [0, 59].\n * @param {Number} [second] The second of the minute as a whole number with range [0, 60], with 60 representing a leap second.\n * @param {Number} [millisecond] The millisecond of the second as a floating point number with range [0.0, 1000.0).\n * @param {Boolean} [isLeapSecond] Whether this time is during a leap second.\n *\n * @see JulianDate#toGregorianDate\n */\nfunction GregorianDate(\n  year,\n  month,\n  day,\n  hour,\n  minute,\n  second,\n  millisecond,\n  isLeapSecond\n) {\n  /**\n   * Gets or sets the year as a whole number.\n   * @type {Number}\n   */\n  this.year = year;\n  /**\n   * Gets or sets the month as a whole number with range [1, 12].\n   * @type {Number}\n   */\n  this.month = month;\n  /**\n   * Gets or sets the day of the month as a whole number starting at 1.\n   * @type {Number}\n   */\n  this.day = day;\n  /**\n   * Gets or sets the hour as a whole number with range [0, 23].\n   * @type {Number}\n   */\n  this.hour = hour;\n  /**\n   * Gets or sets the minute of the hour as a whole number with range [0, 59].\n   * @type {Number}\n   */\n  this.minute = minute;\n  /**\n   * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.\n   * @type {Number}\n   */\n  this.second = second;\n  /**\n   * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).\n   * @type {Number}\n   */\n  this.millisecond = millisecond;\n  /**\n   * Gets or sets whether this time is during a leap second.\n   * @type {Boolean}\n   */\n  this.isLeapSecond = isLeapSecond;\n}\nexport default GregorianDate;\n","import ApproximateTerrainHeights from \"./ApproximateTerrainHeights.js\";\nimport ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Plane from \"./Plane.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\nconst PROJECTIONS = [GeographicProjection, WebMercatorProjection];\nconst PROJECTION_COUNT = PROJECTIONS.length;\n\nconst MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\nconst MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\n\n// Initial heights for constructing the wall.\n// Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\n// prevent precision problems with planes in the shader.\n// Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\n// which is a highly conservative bound, usually puts the plane origin several thousands\n// of meters away from the actual terrain, causing floating point problems when checking\n// fragments on terrain against the plane.\n// Ellipsoid height is generally much closer.\n// The initial max height is arbitrary.\n// Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\nconst WALL_INITIAL_MIN_HEIGHT = 0.0;\nconst WALL_INITIAL_MAX_HEIGHT = 1000.0;\n\n/**\n * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\n *\n * @alias GroundPolylineGeometry\n * @constructor\n *\n * @param {Object} options Options with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\n * @param {Number} [options.width=1.0] The screen space width in pixels.\n * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\n * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @exception {DeveloperError} At least two positions are required.\n *\n * @see GroundPolylinePrimitive\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -112.1340164450331, 36.05494287836128,\n *   -112.08821010582645, 36.097804071380715,\n *   -112.13296079730024, 36.168769146801104\n * ]);\n *\n * const geometry = new Cesium.GroundPolylineGeometry({\n *   positions : positions\n * });\n */\nfunction GroundPolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The screen space width in pixels.\n   * @type {Number}\n   */\n  this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\n\n  this._positions = positions;\n\n  /**\n   * The distance interval used for interpolating options.points. Zero indicates no interpolation.\n   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\n   * @type {Boolean}\n   * @default 9999.0\n   */\n  this.granularity = defaultValue(options.granularity, 9999.0);\n\n  /**\n   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\n   * If the geometry has two positions this parameter will be ignored.\n   * @type {Boolean}\n   * @default false\n   */\n  this.loop = defaultValue(options.loop, false);\n\n  /**\n   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n   * @type {ArcType}\n   * @default ArcType.GEODESIC\n   */\n  this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  this._ellipsoid = Ellipsoid.WGS84;\n\n  // MapProjections can't be packed, so store the index to a known MapProjection.\n  this._projectionIndex = 0;\n  this._workerName = \"createGroundPolylineGeometry\";\n\n  // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\n  this._scene3DOnly = false;\n}\n\nObject.defineProperties(GroundPolylineGeometry.prototype, {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @memberof GroundPolylineGeometry.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  packedLength: {\n    get: function () {\n      return (\n        1.0 +\n        this._positions.length * 3 +\n        1.0 +\n        1.0 +\n        1.0 +\n        Ellipsoid.packedLength +\n        1.0 +\n        1.0\n      );\n    },\n  },\n});\n\n/**\n * Set the GroundPolylineGeometry's projection and ellipsoid.\n * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\n * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\n * @private\n */\nGroundPolylineGeometry.setProjectionAndEllipsoid = function (\n  groundPolylineGeometry,\n  mapProjection\n) {\n  let projectionIndex = 0;\n  for (let i = 0; i < PROJECTION_COUNT; i++) {\n    if (mapProjection instanceof PROJECTIONS[i]) {\n      projectionIndex = i;\n      break;\n    }\n  }\n\n  groundPolylineGeometry._projectionIndex = projectionIndex;\n  groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\n};\n\nconst cart3Scratch1 = new Cartesian3();\nconst cart3Scratch2 = new Cartesian3();\nconst cart3Scratch3 = new Cartesian3();\nfunction computeRightNormal(start, end, maxHeight, ellipsoid, result) {\n  const startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\n  const startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\n  const endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\n\n  const up = direction(startTop, startBottom, cart3Scratch2);\n  const forward = direction(endBottom, startBottom, cart3Scratch3);\n\n  Cartesian3.cross(forward, up, result);\n  return Cartesian3.normalize(result, result);\n}\n\nconst interpolatedCartographicScratch = new Cartographic();\nconst interpolatedBottomScratch = new Cartesian3();\nconst interpolatedTopScratch = new Cartesian3();\nconst interpolatedNormalScratch = new Cartesian3();\nfunction interpolateSegment(\n  start,\n  end,\n  minHeight,\n  maxHeight,\n  granularity,\n  arcType,\n  ellipsoid,\n  normalsArray,\n  bottomPositionsArray,\n  topPositionsArray,\n  cartographicsArray\n) {\n  if (granularity === 0.0) {\n    return;\n  }\n\n  let ellipsoidLine;\n  if (arcType === ArcType.GEODESIC) {\n    ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\n  } else if (arcType === ArcType.RHUMB) {\n    ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\n  }\n\n  const surfaceDistance = ellipsoidLine.surfaceDistance;\n  if (surfaceDistance < granularity) {\n    return;\n  }\n\n  // Compute rightwards normal applicable at all interpolated points\n  const interpolatedNormal = computeRightNormal(\n    start,\n    end,\n    maxHeight,\n    ellipsoid,\n    interpolatedNormalScratch\n  );\n\n  const segments = Math.ceil(surfaceDistance / granularity);\n  const interpointDistance = surfaceDistance / segments;\n  let distanceFromStart = interpointDistance;\n  const pointsToAdd = segments - 1;\n  let packIndex = normalsArray.length;\n  for (let i = 0; i < pointsToAdd; i++) {\n    const interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(\n      distanceFromStart,\n      interpolatedCartographicScratch\n    );\n    const interpolatedBottom = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      minHeight,\n      interpolatedBottomScratch\n    );\n    const interpolatedTop = getPosition(\n      ellipsoid,\n      interpolatedCartographic,\n      maxHeight,\n      interpolatedTopScratch\n    );\n\n    Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\n    Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\n    Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\n    cartographicsArray.push(interpolatedCartographic.latitude);\n    cartographicsArray.push(interpolatedCartographic.longitude);\n\n    packIndex += 3;\n    distanceFromStart += interpointDistance;\n  }\n}\n\nconst heightlessCartographicScratch = new Cartographic();\nfunction getPosition(ellipsoid, cartographic, height, result) {\n  Cartographic.clone(cartographic, heightlessCartographicScratch);\n  heightlessCartographicScratch.height = height;\n  return Cartographic.toCartesian(\n    heightlessCartographicScratch,\n    ellipsoid,\n    result\n  );\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nGroundPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = defaultValue(startingIndex, 0);\n\n  const positions = value._positions;\n  const positionsLength = positions.length;\n\n  array[index++] = positionsLength;\n\n  for (let i = 0; i < positionsLength; ++i) {\n    const cartesian = positions[i];\n    Cartesian3.pack(cartesian, array, index);\n    index += 3;\n  }\n\n  array[index++] = value.granularity;\n  array[index++] = value.loop ? 1.0 : 0.0;\n  array[index++] = value.arcType;\n\n  Ellipsoid.pack(value._ellipsoid, array, index);\n  index += Ellipsoid.packedLength;\n\n  array[index++] = value._projectionIndex;\n  array[index++] = value._scene3DOnly ? 1.0 : 0.0;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nGroundPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  let index = defaultValue(startingIndex, 0);\n  const positionsLength = array[index++];\n  const positions = new Array(positionsLength);\n\n  for (let i = 0; i < positionsLength; i++) {\n    positions[i] = Cartesian3.unpack(array, index);\n    index += 3;\n  }\n\n  const granularity = array[index++];\n  const loop = array[index++] === 1.0;\n  const arcType = array[index++];\n\n  const ellipsoid = Ellipsoid.unpack(array, index);\n  index += Ellipsoid.packedLength;\n\n  const projectionIndex = array[index++];\n  const scene3DOnly = array[index++] === 1.0;\n\n  if (!defined(result)) {\n    result = new GroundPolylineGeometry({\n      positions: positions,\n    });\n  }\n\n  result._positions = positions;\n  result.granularity = granularity;\n  result.loop = loop;\n  result.arcType = arcType;\n  result._ellipsoid = ellipsoid;\n  result._projectionIndex = projectionIndex;\n  result._scene3DOnly = scene3DOnly;\n\n  return result;\n};\n\nfunction direction(target, origin, result) {\n  Cartesian3.subtract(target, origin, result);\n  Cartesian3.normalize(result, result);\n  return result;\n}\n\nfunction tangentDirection(target, origin, up, result) {\n  result = direction(target, origin, result);\n\n  // orthogonalize\n  result = Cartesian3.cross(result, up, result);\n  result = Cartesian3.normalize(result, result);\n  result = Cartesian3.cross(up, result, result);\n  return result;\n}\n\nconst toPreviousScratch = new Cartesian3();\nconst toNextScratch = new Cartesian3();\nconst forwardScratch = new Cartesian3();\nconst vertexUpScratch = new Cartesian3();\nconst cosine90 = 0.0;\nconst cosine180 = -1.0;\nfunction computeVertexMiterNormal(\n  previousBottom,\n  vertexBottom,\n  vertexTop,\n  nextBottom,\n  result\n) {\n  const up = direction(vertexTop, vertexBottom, vertexUpScratch);\n\n  // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\n  const toPrevious = tangentDirection(\n    previousBottom,\n    vertexBottom,\n    up,\n    toPreviousScratch\n  );\n  const toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\n\n  // Check if tangents are almost opposite - if so, no need to miter.\n  if (\n    CesiumMath.equalsEpsilon(\n      Cartesian3.dot(toPrevious, toNext),\n      cosine180,\n      CesiumMath.EPSILON5\n    )\n  ) {\n    result = Cartesian3.cross(up, toPrevious, result);\n    result = Cartesian3.normalize(result, result);\n    return result;\n  }\n\n  // Average directions to previous and to next in the plane of Up\n  result = Cartesian3.add(toNext, toPrevious, result);\n  result = Cartesian3.normalize(result, result);\n\n  // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\n  const forward = Cartesian3.cross(up, result, forwardScratch);\n  if (Cartesian3.dot(toNext, forward) < cosine90) {\n    result = Cartesian3.negate(result, result);\n  }\n\n  return result;\n}\n\nconst XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nconst previousBottomScratch = new Cartesian3();\nconst vertexBottomScratch = new Cartesian3();\nconst vertexTopScratch = new Cartesian3();\nconst nextBottomScratch = new Cartesian3();\nconst vertexNormalScratch = new Cartesian3();\nconst intersectionScratch = new Cartesian3();\nconst cartographicScratch0 = new Cartographic();\nconst cartographicScratch1 = new Cartographic();\nconst cartographicIntersectionScratch = new Cartographic();\n/**\n * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\n * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\n * Should not be called independent of {@link GroundPolylinePrimitive}.\n *\n * @param {GroundPolylineGeometry} groundPolylineGeometry\n * @private\n */\nGroundPolylineGeometry.createGeometry = function (groundPolylineGeometry) {\n  const compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\n  let loop = groundPolylineGeometry.loop;\n  const ellipsoid = groundPolylineGeometry._ellipsoid;\n  const granularity = groundPolylineGeometry.granularity;\n  const arcType = groundPolylineGeometry.arcType;\n  const projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](\n    ellipsoid\n  );\n\n  const minHeight = WALL_INITIAL_MIN_HEIGHT;\n  const maxHeight = WALL_INITIAL_MAX_HEIGHT;\n\n  let index;\n  let i;\n\n  const positions = groundPolylineGeometry._positions;\n  const positionsLength = positions.length;\n\n  if (positionsLength === 2) {\n    loop = false;\n  }\n\n  // Split positions across the IDL and the Prime Meridian as well.\n  // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\n  // may get split by the plane of IDL + Prime Meridian.\n  let p0;\n  let p1;\n  let c0;\n  let c1;\n  const rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  let intersection;\n  let intersectionCartographic;\n  let intersectionLongitude;\n  const splitPositions = [positions[0]];\n  for (i = 0; i < positionsLength - 1; i++) {\n    p0 = positions[i];\n    p1 = positions[i + 1];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n    splitPositions.push(p1);\n  }\n\n  if (loop) {\n    p0 = positions[positionsLength - 1];\n    p1 = positions[0];\n    intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      XZ_PLANE,\n      intersectionScratch\n    );\n    if (\n      defined(intersection) &&\n      !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n      !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n    ) {\n      if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\n        splitPositions.push(Cartesian3.clone(intersection));\n      } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\n        intersectionLongitude = ellipsoid.cartesianToCartographic(\n          intersection,\n          cartographicScratch0\n        ).longitude;\n        c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\n        c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\n        rhumbLine.setEndPoints(c0, c1);\n        intersectionCartographic = rhumbLine.findIntersectionWithLongitude(\n          intersectionLongitude,\n          cartographicIntersectionScratch\n        );\n        intersection = ellipsoid.cartographicToCartesian(\n          intersectionCartographic,\n          intersectionScratch\n        );\n        if (\n          defined(intersection) &&\n          !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\n          !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)\n        ) {\n          splitPositions.push(Cartesian3.clone(intersection));\n        }\n      }\n    }\n  }\n  let cartographicsLength = splitPositions.length;\n\n  let cartographics = new Array(cartographicsLength);\n  for (i = 0; i < cartographicsLength; i++) {\n    const cartographic = Cartographic.fromCartesian(\n      splitPositions[i],\n      ellipsoid\n    );\n    cartographic.height = 0.0;\n    cartographics[i] = cartographic;\n  }\n\n  cartographics = arrayRemoveDuplicates(\n    cartographics,\n    Cartographic.equalsEpsilon\n  );\n  cartographicsLength = cartographics.length;\n\n  if (cartographicsLength < 2) {\n    return undefined;\n  }\n\n  /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\n  // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\n  // of information about the wall. Also, this simplifies interpolation.\n  // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\n  // and we are computing normals pointing towards the local right side of the vertices in each segment.\n  const cartographicsArray = [];\n  const normalsArray = [];\n  const bottomPositionsArray = [];\n  const topPositionsArray = [];\n\n  let previousBottom = previousBottomScratch;\n  let vertexBottom = vertexBottomScratch;\n  let vertexTop = vertexTopScratch;\n  let nextBottom = nextBottomScratch;\n  let vertexNormal = vertexNormalScratch;\n\n  // First point - either loop or attach a \"perpendicular\" normal\n  const startCartographic = cartographics[0];\n  const nextCartographic = cartographics[1];\n\n  const prestartCartographic = cartographics[cartographicsLength - 1];\n  previousBottom = getPosition(\n    ellipsoid,\n    prestartCartographic,\n    minHeight,\n    previousBottom\n  );\n  nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\n  vertexBottom = getPosition(\n    ellipsoid,\n    startCartographic,\n    minHeight,\n    vertexBottom\n  );\n  vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      startCartographic,\n      nextCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal\n    );\n  }\n\n  Cartesian3.pack(vertexNormal, normalsArray, 0);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\n  Cartesian3.pack(vertexTop, topPositionsArray, 0);\n  cartographicsArray.push(startCartographic.latitude);\n  cartographicsArray.push(startCartographic.longitude);\n\n  interpolateSegment(\n    startCartographic,\n    nextCartographic,\n    minHeight,\n    maxHeight,\n    granularity,\n    arcType,\n    ellipsoid,\n    normalsArray,\n    bottomPositionsArray,\n    topPositionsArray,\n    cartographicsArray\n  );\n\n  // All inbetween points\n  for (i = 1; i < cartographicsLength - 1; ++i) {\n    previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\n    vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\n    const vertexCartographic = cartographics[i];\n    getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\n    getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\n\n    computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n\n    index = normalsArray.length;\n    Cartesian3.pack(vertexNormal, normalsArray, index);\n    Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n    Cartesian3.pack(vertexTop, topPositionsArray, index);\n    cartographicsArray.push(vertexCartographic.latitude);\n    cartographicsArray.push(vertexCartographic.longitude);\n\n    interpolateSegment(\n      cartographics[i],\n      cartographics[i + 1],\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray\n    );\n  }\n\n  // Last point - either loop or attach a normal \"perpendicular\" to the wall.\n  const endCartographic = cartographics[cartographicsLength - 1];\n  const preEndCartographic = cartographics[cartographicsLength - 2];\n\n  vertexBottom = getPosition(\n    ellipsoid,\n    endCartographic,\n    minHeight,\n    vertexBottom\n  );\n  vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\n\n  if (loop) {\n    const postEndCartographic = cartographics[0];\n    previousBottom = getPosition(\n      ellipsoid,\n      preEndCartographic,\n      minHeight,\n      previousBottom\n    );\n    nextBottom = getPosition(\n      ellipsoid,\n      postEndCartographic,\n      minHeight,\n      nextBottom\n    );\n\n    vertexNormal = computeVertexMiterNormal(\n      previousBottom,\n      vertexBottom,\n      vertexTop,\n      nextBottom,\n      vertexNormal\n    );\n  } else {\n    vertexNormal = computeRightNormal(\n      preEndCartographic,\n      endCartographic,\n      maxHeight,\n      ellipsoid,\n      vertexNormal\n    );\n  }\n\n  index = normalsArray.length;\n  Cartesian3.pack(vertexNormal, normalsArray, index);\n  Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\n  Cartesian3.pack(vertexTop, topPositionsArray, index);\n  cartographicsArray.push(endCartographic.latitude);\n  cartographicsArray.push(endCartographic.longitude);\n\n  if (loop) {\n    interpolateSegment(\n      endCartographic,\n      startCartographic,\n      minHeight,\n      maxHeight,\n      granularity,\n      arcType,\n      ellipsoid,\n      normalsArray,\n      bottomPositionsArray,\n      topPositionsArray,\n      cartographicsArray\n    );\n    index = normalsArray.length;\n    for (i = 0; i < 3; ++i) {\n      normalsArray[index + i] = normalsArray[i];\n      bottomPositionsArray[index + i] = bottomPositionsArray[i];\n      topPositionsArray[index + i] = topPositionsArray[i];\n    }\n    cartographicsArray.push(startCartographic.latitude);\n    cartographicsArray.push(startCartographic.longitude);\n  }\n\n  return generateGeometryAttributes(\n    loop,\n    projection,\n    bottomPositionsArray,\n    topPositionsArray,\n    normalsArray,\n    cartographicsArray,\n    compute2dAttributes\n  );\n};\n\n// If the end normal angle is too steep compared to the direction of the line segment,\n// \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\n// For ultra precision we would want to project into a plane, but in practice this is sufficient.\nconst lineDirectionScratch = new Cartesian3();\nconst matrix3Scratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\nfunction breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\n  const lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\n\n  const dot = Cartesian3.dot(lineDirection, endGeometryNormal);\n  if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\n    const vertexUp = direction(endTop, endBottom, vertexUpScratch);\n    const angle =\n      dot < MITER_BREAK_LARGE\n        ? CesiumMath.PI_OVER_TWO\n        : -CesiumMath.PI_OVER_TWO;\n    const quaternion = Quaternion.fromAxisAngle(\n      vertexUp,\n      angle,\n      quaternionScratch\n    );\n    const rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\n    Matrix3.multiplyByVector(\n      rotationMatrix,\n      endGeometryNormal,\n      endGeometryNormal\n    );\n    return true;\n  }\n  return false;\n}\n\nconst endPosCartographicScratch = new Cartographic();\nconst normalStartpointScratch = new Cartesian3();\nconst normalEndpointScratch = new Cartesian3();\nfunction projectNormal(\n  projection,\n  cartographic,\n  normal,\n  projectedPosition,\n  result\n) {\n  const position = Cartographic.toCartesian(\n    cartographic,\n    projection._ellipsoid,\n    normalStartpointScratch\n  );\n  let normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\n  let flipNormal = false;\n\n  const ellipsoid = projection._ellipsoid;\n  let normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n    normalEndpoint,\n    endPosCartographicScratch\n  );\n  // If normal crosses the IDL, go the other way and flip the result.\n  // In practice this almost never happens because the cartographic start\n  // and end points of each segment are \"nudged\" to be on the same side\n  // of the IDL and slightly away from the IDL.\n  if (\n    Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) >\n    CesiumMath.PI_OVER_TWO\n  ) {\n    flipNormal = true;\n    normalEndpoint = Cartesian3.subtract(\n      position,\n      normal,\n      normalEndpointScratch\n    );\n    normalEndpointCartographic = ellipsoid.cartesianToCartographic(\n      normalEndpoint,\n      endPosCartographicScratch\n    );\n  }\n\n  normalEndpointCartographic.height = 0.0;\n  const normalEndpointProjected = projection.project(\n    normalEndpointCartographic,\n    result\n  );\n  result = Cartesian3.subtract(\n    normalEndpointProjected,\n    projectedPosition,\n    result\n  );\n  result.z = 0.0;\n  result = Cartesian3.normalize(result, result);\n  if (flipNormal) {\n    Cartesian3.negate(result, result);\n  }\n  return result;\n}\n\nconst adjustHeightNormalScratch = new Cartesian3();\nconst adjustHeightOffsetScratch = new Cartesian3();\nfunction adjustHeights(\n  bottom,\n  top,\n  minHeight,\n  maxHeight,\n  adjustHeightBottom,\n  adjustHeightTop\n) {\n  // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\n  const adjustHeightNormal = Cartesian3.subtract(\n    top,\n    bottom,\n    adjustHeightNormalScratch\n  );\n  Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\n\n  const distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\n  let adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForBottom,\n    adjustHeightOffsetScratch\n  );\n  Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\n\n  const distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\n  adjustHeightOffset = Cartesian3.multiplyByScalar(\n    adjustHeightNormal,\n    distanceForTop,\n    adjustHeightOffsetScratch\n  );\n  Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\n}\n\nconst nudgeDirectionScratch = new Cartesian3();\nfunction nudgeXZ(start, end) {\n  const startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\n  const endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\n  let offset = nudgeDirectionScratch;\n  // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\n  if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\n    offset = direction(end, start, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(start, offset, start);\n  } else if (\n    CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)\n  ) {\n    offset = direction(start, end, offset);\n    Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\n    Cartesian3.add(end, offset, end);\n  }\n}\n\n// \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\n// Nudge amounts are tiny, basically just an IDL flip.\n// Only used for 2D/CV.\nfunction nudgeCartographic(start, end) {\n  const absStartLon = Math.abs(start.longitude);\n  const absEndLon = Math.abs(end.longitude);\n  if (\n    CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    const endSign = CesiumMath.sign(end.longitude);\n    start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\n    return 1;\n  } else if (\n    CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)\n  ) {\n    const startSign = CesiumMath.sign(start.longitude);\n    end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\n    return 2;\n  }\n  return 0;\n}\n\nconst startCartographicScratch = new Cartographic();\nconst endCartographicScratch = new Cartographic();\n\nconst segmentStartTopScratch = new Cartesian3();\nconst segmentEndTopScratch = new Cartesian3();\nconst segmentStartBottomScratch = new Cartesian3();\nconst segmentEndBottomScratch = new Cartesian3();\nconst segmentStartNormalScratch = new Cartesian3();\nconst segmentEndNormalScratch = new Cartesian3();\n\nconst getHeightCartographics = [\n  startCartographicScratch,\n  endCartographicScratch,\n];\nconst getHeightRectangleScratch = new Rectangle();\n\nconst adjustHeightStartTopScratch = new Cartesian3();\nconst adjustHeightEndTopScratch = new Cartesian3();\nconst adjustHeightStartBottomScratch = new Cartesian3();\nconst adjustHeightEndBottomScratch = new Cartesian3();\n\nconst segmentStart2DScratch = new Cartesian3();\nconst segmentEnd2DScratch = new Cartesian3();\nconst segmentStartNormal2DScratch = new Cartesian3();\nconst segmentEndNormal2DScratch = new Cartesian3();\n\nconst offsetScratch = new Cartesian3();\nconst startUpScratch = new Cartesian3();\nconst endUpScratch = new Cartesian3();\nconst rightScratch = new Cartesian3();\nconst startPlaneNormalScratch = new Cartesian3();\nconst endPlaneNormalScratch = new Cartesian3();\nconst encodeScratch = new EncodedCartesian3();\n\nconst encodeScratch2D = new EncodedCartesian3();\nconst forwardOffset2DScratch = new Cartesian3();\nconst right2DScratch = new Cartesian3();\n\nconst normalNudgeScratch = new Cartesian3();\n\nconst scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\n\n// Winding order is reversed so each segment's volume is inside-out\nconst REFERENCE_INDICES = [\n  0,\n  2,\n  1,\n  0,\n  3,\n  2, // right\n  0,\n  7,\n  3,\n  0,\n  4,\n  7, // start\n  0,\n  5,\n  4,\n  0,\n  1,\n  5, // bottom\n  5,\n  7,\n  4,\n  5,\n  6,\n  7, // left\n  5,\n  2,\n  6,\n  5,\n  1,\n  2, // end\n  3,\n  6,\n  2,\n  3,\n  7,\n  6, // top\n];\nconst REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\n\n// Decompose the \"wall\" into a series of shadow volumes.\n// Each shadow volume's vertices encode a description of the line it contains,\n// including mitering planes at the end points, a plane along the line itself,\n// and attributes for computing length-wise texture coordinates.\nfunction generateGeometryAttributes(\n  loop,\n  projection,\n  bottomPositionsArray,\n  topPositionsArray,\n  normalsArray,\n  cartographicsArray,\n  compute2dAttributes\n) {\n  let i;\n  let index;\n  const ellipsoid = projection._ellipsoid;\n\n  // Each segment will have 8 vertices\n  const segmentCount = bottomPositionsArray.length / 3 - 1;\n  const vertexCount = segmentCount * 8;\n  const arraySizeVec4 = vertexCount * 4;\n  const indexCount = segmentCount * 36;\n\n  const indices =\n    vertexCount > 65535\n      ? new Uint32Array(indexCount)\n      : new Uint16Array(indexCount);\n  const positionsArray = new Float64Array(vertexCount * 3);\n\n  const startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\n  const startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\n  const startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\n  const endNormalAndTextureCoordinateNormalizationX = new Float32Array(\n    arraySizeVec4\n  );\n  const rightNormalAndTextureCoordinateNormalizationY = new Float32Array(\n    arraySizeVec4\n  );\n\n  let startHiLo2D;\n  let offsetAndRight2D;\n  let startEndNormals2D;\n  let texcoordNormalization2D;\n\n  if (compute2dAttributes) {\n    startHiLo2D = new Float32Array(arraySizeVec4);\n    offsetAndRight2D = new Float32Array(arraySizeVec4);\n    startEndNormals2D = new Float32Array(arraySizeVec4);\n    texcoordNormalization2D = new Float32Array(vertexCount * 2);\n  }\n\n  /*** Compute total lengths for texture coordinate normalization ***/\n  // 2D\n  const cartographicsLength = cartographicsArray.length / 2;\n  let length2D = 0.0;\n\n  const startCartographic = startCartographicScratch;\n  startCartographic.height = 0.0;\n  const endCartographic = endCartographicScratch;\n  endCartographic.height = 0.0;\n\n  let segmentStartCartesian = segmentStartTopScratch;\n  let segmentEndCartesian = segmentEndTopScratch;\n\n  if (compute2dAttributes) {\n    index = 0;\n    for (i = 1; i < cartographicsLength; i++) {\n      // Don't clone anything from previous segment b/c possible IDL touch\n      startCartographic.latitude = cartographicsArray[index];\n      startCartographic.longitude = cartographicsArray[index + 1];\n      endCartographic.latitude = cartographicsArray[index + 2];\n      endCartographic.longitude = cartographicsArray[index + 3];\n\n      segmentStartCartesian = projection.project(\n        startCartographic,\n        segmentStartCartesian\n      );\n      segmentEndCartesian = projection.project(\n        endCartographic,\n        segmentEndCartesian\n      );\n      length2D += Cartesian3.distance(\n        segmentStartCartesian,\n        segmentEndCartesian\n      );\n      index += 2;\n    }\n  }\n\n  // 3D\n  const positionsLength = topPositionsArray.length / 3;\n  segmentEndCartesian = Cartesian3.unpack(\n    topPositionsArray,\n    0,\n    segmentEndCartesian\n  );\n  let length3D = 0.0;\n\n  index = 3;\n  for (i = 1; i < positionsLength; i++) {\n    segmentStartCartesian = Cartesian3.clone(\n      segmentEndCartesian,\n      segmentStartCartesian\n    );\n    segmentEndCartesian = Cartesian3.unpack(\n      topPositionsArray,\n      index,\n      segmentEndCartesian\n    );\n    length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\n    index += 3;\n  }\n\n  /*** Generate segments ***/\n  let j;\n  index = 3;\n  let cartographicsIndex = 0;\n  let vec2sWriteIndex = 0;\n  let vec3sWriteIndex = 0;\n  let vec4sWriteIndex = 0;\n  let miterBroken = false;\n\n  let endBottom = Cartesian3.unpack(\n    bottomPositionsArray,\n    0,\n    segmentEndBottomScratch\n  );\n  let endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\n  let endGeometryNormal = Cartesian3.unpack(\n    normalsArray,\n    0,\n    segmentEndNormalScratch\n  );\n\n  if (loop) {\n    const preEndBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      bottomPositionsArray.length - 6,\n      segmentStartBottomScratch\n    );\n    if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\n      // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\n      endGeometryNormal = Cartesian3.negate(\n        endGeometryNormal,\n        endGeometryNormal\n      );\n    }\n  }\n\n  let lengthSoFar3D = 0.0;\n  let lengthSoFar2D = 0.0;\n\n  // For translating bounding volume\n  let sumHeights = 0.0;\n\n  for (i = 0; i < segmentCount; i++) {\n    const startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\n    const startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\n    let startGeometryNormal = Cartesian3.clone(\n      endGeometryNormal,\n      segmentStartNormalScratch\n    );\n\n    if (miterBroken) {\n      startGeometryNormal = Cartesian3.negate(\n        startGeometryNormal,\n        startGeometryNormal\n      );\n    }\n\n    endBottom = Cartesian3.unpack(\n      bottomPositionsArray,\n      index,\n      segmentEndBottomScratch\n    );\n    endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\n    endGeometryNormal = Cartesian3.unpack(\n      normalsArray,\n      index,\n      segmentEndNormalScratch\n    );\n\n    miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\n\n    // 2D - don't clone anything from previous segment b/c possible IDL touch\n    startCartographic.latitude = cartographicsArray[cartographicsIndex];\n    startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\n    endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\n    endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\n    let start2D;\n    let end2D;\n    let startGeometryNormal2D;\n    let endGeometryNormal2D;\n\n    if (compute2dAttributes) {\n      const nudgeResult = nudgeCartographic(startCartographic, endCartographic);\n      start2D = projection.project(startCartographic, segmentStart2DScratch);\n      end2D = projection.project(endCartographic, segmentEnd2DScratch);\n      const direction2D = direction(end2D, start2D, forwardOffset2DScratch);\n      direction2D.y = Math.abs(direction2D.y);\n\n      startGeometryNormal2D = segmentStartNormal2DScratch;\n      endGeometryNormal2D = segmentEndNormal2DScratch;\n      if (\n        nudgeResult === 0 ||\n        Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL\n      ) {\n        // No nudge - project the original normal\n        // Or, if the line's angle relative to the IDL is very acute,\n        // in which case snapping will produce oddly shaped volumes.\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch\n        );\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch\n        );\n      } else if (nudgeResult === 1) {\n        // Start is close to IDL - snap start normal to align with IDL\n        endGeometryNormal2D = projectNormal(\n          projection,\n          endCartographic,\n          endGeometryNormal,\n          end2D,\n          segmentEndNormal2DScratch\n        );\n        startGeometryNormal2D.x = 0.0;\n        // If start longitude is negative and end longitude is less negative, relative right is unit -Y\n        // If start longitude is positive and end longitude is less positive, relative right is unit +Y\n        startGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - Math.abs(endCartographic.longitude)\n        );\n        startGeometryNormal2D.z = 0.0;\n      } else {\n        // End is close to IDL - snap end normal to align with IDL\n        startGeometryNormal2D = projectNormal(\n          projection,\n          startCartographic,\n          startGeometryNormal,\n          start2D,\n          segmentStartNormal2DScratch\n        );\n        endGeometryNormal2D.x = 0.0;\n        // If end longitude is negative and start longitude is less negative, relative right is unit Y\n        // If end longitude is positive and start longitude is less positive, relative right is unit -Y\n        endGeometryNormal2D.y = CesiumMath.sign(\n          startCartographic.longitude - endCartographic.longitude\n        );\n        endGeometryNormal2D.z = 0.0;\n      }\n    }\n\n    /****************************************\n     * Geometry descriptors of a \"line on terrain,\"\n     * as opposed to the \"shadow volume used to draw\n     * the line on terrain\":\n     * - position of start + offset to end\n     * - start, end, and right-facing planes\n     * - encoded texture coordinate offsets\n     ****************************************/\n\n    /* 3D */\n    const segmentLength3D = Cartesian3.distance(startTop, endTop);\n\n    const encodedStart = EncodedCartesian3.fromCartesian(\n      startBottom,\n      encodeScratch\n    );\n    const forwardOffset = Cartesian3.subtract(\n      endBottom,\n      startBottom,\n      offsetScratch\n    );\n    const forward = Cartesian3.normalize(forwardOffset, rightScratch);\n\n    let startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\n    startUp = Cartesian3.normalize(startUp, startUp);\n    let rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\n    rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\n\n    let startPlaneNormal = Cartesian3.cross(\n      startUp,\n      startGeometryNormal,\n      startPlaneNormalScratch\n    );\n    startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\n\n    let endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\n    endUp = Cartesian3.normalize(endUp, endUp);\n    let endPlaneNormal = Cartesian3.cross(\n      endGeometryNormal,\n      endUp,\n      endPlaneNormalScratch\n    );\n    endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\n\n    const texcoordNormalization3DX = segmentLength3D / length3D;\n    const texcoordNormalization3DY = lengthSoFar3D / length3D;\n\n    /* 2D */\n    let segmentLength2D = 0.0;\n    let encodedStart2D;\n    let forwardOffset2D;\n    let right2D;\n    let texcoordNormalization2DX = 0.0;\n    let texcoordNormalization2DY = 0.0;\n    if (compute2dAttributes) {\n      segmentLength2D = Cartesian3.distance(start2D, end2D);\n\n      encodedStart2D = EncodedCartesian3.fromCartesian(\n        start2D,\n        encodeScratch2D\n      );\n      forwardOffset2D = Cartesian3.subtract(\n        end2D,\n        start2D,\n        forwardOffset2DScratch\n      );\n\n      // Right direction is just forward direction rotated by -90 degrees around Z\n      // Similarly with plane normals\n      right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\n      const swap = right2D.x;\n      right2D.x = right2D.y;\n      right2D.y = -swap;\n\n      texcoordNormalization2DX = segmentLength2D / length2D;\n      texcoordNormalization2DY = lengthSoFar2D / length2D;\n    }\n    /** Pack **/\n    for (j = 0; j < 8; j++) {\n      const vec4Index = vec4sWriteIndex + j * 4;\n      const vec2Index = vec2sWriteIndex + j * 2;\n      const wIndex = vec4Index + 3;\n\n      // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\n      // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\n      const rightPlaneSide = j < 4 ? 1.0 : -1.0;\n      const topBottomSide =\n        j === 2 || j === 3 || j === 6 || j === 7 ? 1.0 : -1.0;\n\n      // 3D\n      Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\n      startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\n\n      Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\n      startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\n\n      Cartesian3.pack(\n        startPlaneNormal,\n        startNormalAndForwardOffsetZ,\n        vec4Index\n      );\n      startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\n\n      Cartesian3.pack(\n        endPlaneNormal,\n        endNormalAndTextureCoordinateNormalizationX,\n        vec4Index\n      );\n      endNormalAndTextureCoordinateNormalizationX[wIndex] =\n        texcoordNormalization3DX * rightPlaneSide;\n\n      Cartesian3.pack(\n        rightNormal,\n        rightNormalAndTextureCoordinateNormalizationY,\n        vec4Index\n      );\n\n      let texcoordNormalization = texcoordNormalization3DY * topBottomSide;\n      if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n        texcoordNormalization = 9.0; // some value greater than 1.0\n      }\n      rightNormalAndTextureCoordinateNormalizationY[\n        wIndex\n      ] = texcoordNormalization;\n\n      // 2D\n      if (compute2dAttributes) {\n        startHiLo2D[vec4Index] = encodedStart2D.high.x;\n        startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\n        startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\n        startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\n\n        startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\n        startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\n        startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\n\n        offsetAndRight2D[vec4Index] = forwardOffset2D.x;\n        offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\n        offsetAndRight2D[vec4Index + 2] = right2D.x;\n        offsetAndRight2D[vec4Index + 3] = right2D.y;\n\n        texcoordNormalization2D[vec2Index] =\n          texcoordNormalization2DX * rightPlaneSide;\n\n        texcoordNormalization = texcoordNormalization2DY * topBottomSide;\n        if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\n          texcoordNormalization = 9.0; // some value greater than 1.0\n        }\n        texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\n      }\n    }\n\n    // Adjust height of volume in 3D\n    const adjustHeightStartBottom = adjustHeightStartBottomScratch;\n    const adjustHeightEndBottom = adjustHeightEndBottomScratch;\n    const adjustHeightStartTop = adjustHeightStartTopScratch;\n    const adjustHeightEndTop = adjustHeightEndTopScratch;\n\n    const getHeightsRectangle = Rectangle.fromCartographicArray(\n      getHeightCartographics,\n      getHeightRectangleScratch\n    );\n    const minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(\n      getHeightsRectangle,\n      ellipsoid\n    );\n    const minHeight = minMaxHeights.minimumTerrainHeight;\n    const maxHeight = minMaxHeights.maximumTerrainHeight;\n\n    sumHeights += minHeight;\n    sumHeights += maxHeight;\n\n    adjustHeights(\n      startBottom,\n      startTop,\n      minHeight,\n      maxHeight,\n      adjustHeightStartBottom,\n      adjustHeightStartTop\n    );\n    adjustHeights(\n      endBottom,\n      endTop,\n      minHeight,\n      maxHeight,\n      adjustHeightEndBottom,\n      adjustHeightEndTop\n    );\n\n    // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\n    let normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      CesiumMath.EPSILON5,\n      normalNudgeScratch\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\n    Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\n\n    normalNudge = Cartesian3.multiplyByScalar(\n      rightNormal,\n      -2.0 * CesiumMath.EPSILON5,\n      normalNudgeScratch\n    );\n    Cartesian3.add(\n      adjustHeightStartBottom,\n      normalNudge,\n      adjustHeightStartBottom\n    );\n    Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\n    Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\n    Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\n\n    nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\n    nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\n\n    Cartesian3.pack(\n      adjustHeightStartBottom,\n      positionsArray,\n      vec3sWriteIndex + 12\n    );\n    Cartesian3.pack(\n      adjustHeightEndBottom,\n      positionsArray,\n      vec3sWriteIndex + 15\n    );\n    Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\n    Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\n\n    cartographicsIndex += 2;\n    index += 3;\n\n    vec2sWriteIndex += 16;\n    vec3sWriteIndex += 24;\n    vec4sWriteIndex += 32;\n\n    lengthSoFar3D += segmentLength3D;\n    lengthSoFar2D += segmentLength2D;\n  }\n\n  index = 0;\n  let indexOffset = 0;\n  for (i = 0; i < segmentCount; i++) {\n    for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\n      indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\n    }\n    indexOffset += 8;\n    index += REFERENCE_INDICES_LENGTH;\n  }\n\n  const boundingSpheres = scratchBoundingSpheres;\n  BoundingSphere.fromVertices(\n    bottomPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[0]\n  );\n  BoundingSphere.fromVertices(\n    topPositionsArray,\n    Cartesian3.ZERO,\n    3,\n    boundingSpheres[1]\n  );\n  const boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\n\n  // Adjust bounding sphere height and radius to cover more of the volume\n  boundingSphere.radius += sumHeights / (segmentCount * 2.0);\n\n  const attributes = {\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      normalize: false,\n      values: positionsArray,\n    }),\n    startHiAndForwardOffsetX: getVec4GeometryAttribute(\n      startHiAndForwardOffsetX\n    ),\n    startLoAndForwardOffsetY: getVec4GeometryAttribute(\n      startLoAndForwardOffsetY\n    ),\n    startNormalAndForwardOffsetZ: getVec4GeometryAttribute(\n      startNormalAndForwardOffsetZ\n    ),\n    endNormalAndTextureCoordinateNormalizationX: getVec4GeometryAttribute(\n      endNormalAndTextureCoordinateNormalizationX\n    ),\n    rightNormalAndTextureCoordinateNormalizationY: getVec4GeometryAttribute(\n      rightNormalAndTextureCoordinateNormalizationY\n    ),\n  };\n\n  if (compute2dAttributes) {\n    attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\n    attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\n    attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\n    attributes.texcoordNormalization2D = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      normalize: false,\n      values: texcoordNormalization2D,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: boundingSphere,\n  });\n}\n\nfunction getVec4GeometryAttribute(typedArray) {\n  return new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    values: typedArray,\n  });\n}\n\n/**\n * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\n * Exposed for testing.\n *\n * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\n * @param {Cartographic} cartographic The cartographic origin point of the normal.\n *   Used to check if the normal crosses the IDL during projection.\n * @param {Cartesian3} normal The normal in 3D.\n * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\n * @param {Cartesian3} result Result parameter on which to store the projected normal.\n * @private\n */\nGroundPolylineGeometry._projectNormal = projectNormal;\nexport default GroundPolylineGeometry;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Defines a heading angle, pitch angle, and range in a local frame.\n * Heading is the rotation from the local north direction where a positive angle is increasing eastward.\n * Pitch is the rotation from the local xy-plane. Positive pitch angles are above the plane. Negative pitch\n * angles are below the plane. Range is the distance from the center of the frame.\n * @alias HeadingPitchRange\n * @constructor\n *\n * @param {Number} [heading=0.0] The heading angle in radians.\n * @param {Number} [pitch=0.0] The pitch angle in radians.\n * @param {Number} [range=0.0] The distance from the center in meters.\n */\nfunction HeadingPitchRange(heading, pitch, range) {\n  /**\n   * Heading is the rotation from the local north direction where a positive angle is increasing eastward.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.heading = defaultValue(heading, 0.0);\n\n  /**\n   * Pitch is the rotation from the local xy-plane. Positive pitch angles\n   * are above the plane. Negative pitch angles are below the plane.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.pitch = defaultValue(pitch, 0.0);\n\n  /**\n   * Range is the distance from the center of the local frame.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.range = defaultValue(range, 0.0);\n}\n\n/**\n * Duplicates a HeadingPitchRange instance.\n *\n * @param {HeadingPitchRange} hpr The HeadingPitchRange to duplicate.\n * @param {HeadingPitchRange} [result] The object onto which to store the result.\n * @returns {HeadingPitchRange} The modified result parameter or a new HeadingPitchRange instance if one was not provided. (Returns undefined if hpr is undefined)\n */\nHeadingPitchRange.clone = function (hpr, result) {\n  if (!defined(hpr)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new HeadingPitchRange();\n  }\n\n  result.heading = hpr.heading;\n  result.pitch = hpr.pitch;\n  result.range = hpr.range;\n  return result;\n};\nexport default HeadingPitchRange;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n * @alias HeadingPitchRoll\n * @constructor\n *\n * @param {Number} [heading=0.0] The heading component in radians.\n * @param {Number} [pitch=0.0] The pitch component in radians.\n * @param {Number} [roll=0.0] The roll component in radians.\n */\nfunction HeadingPitchRoll(heading, pitch, roll) {\n  /**\n   * Gets or sets the heading.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.heading = defaultValue(heading, 0.0);\n  /**\n   * Gets or sets the pitch.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.pitch = defaultValue(pitch, 0.0);\n  /**\n   * Gets or sets the roll.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.roll = defaultValue(roll, 0.0);\n}\n\n/**\n * Computes the heading, pitch and roll from a quaternion (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {Quaternion} quaternion The quaternion from which to retrieve heading, pitch, and roll, all expressed in radians.\n * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.\n */\nHeadingPitchRoll.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(quaternion)) {\n    throw new DeveloperError(\"quaternion is required\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n  const test = 2 * (quaternion.w * quaternion.y - quaternion.z * quaternion.x);\n  const denominatorRoll =\n    1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);\n  const numeratorRoll =\n    2 * (quaternion.w * quaternion.x + quaternion.y * quaternion.z);\n  const denominatorHeading =\n    1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);\n  const numeratorHeading =\n    2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y);\n  result.heading = -Math.atan2(numeratorHeading, denominatorHeading);\n  result.roll = Math.atan2(numeratorRoll, denominatorRoll);\n  result.pitch = -CesiumMath.asinClamped(test);\n  return result;\n};\n\n/**\n * Returns a new HeadingPitchRoll instance from angles given in degrees.\n *\n * @param {Number} heading the heading in degrees\n * @param {Number} pitch the pitch in degrees\n * @param {Number} roll the heading in degrees\n * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.\n * @returns {HeadingPitchRoll} A new HeadingPitchRoll instance\n */\nHeadingPitchRoll.fromDegrees = function (heading, pitch, roll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(heading)) {\n    throw new DeveloperError(\"heading is required\");\n  }\n  if (!defined(pitch)) {\n    throw new DeveloperError(\"pitch is required\");\n  }\n  if (!defined(roll)) {\n    throw new DeveloperError(\"roll is required\");\n  }\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    result = new HeadingPitchRoll();\n  }\n  result.heading = heading * CesiumMath.RADIANS_PER_DEGREE;\n  result.pitch = pitch * CesiumMath.RADIANS_PER_DEGREE;\n  result.roll = roll * CesiumMath.RADIANS_PER_DEGREE;\n  return result;\n};\n\n/**\n * Duplicates a HeadingPitchRoll instance.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The HeadingPitchRoll to duplicate.\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided. (Returns undefined if headingPitchRoll is undefined)\n */\nHeadingPitchRoll.clone = function (headingPitchRoll, result) {\n  if (!defined(headingPitchRoll)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new HeadingPitchRoll(\n      headingPitchRoll.heading,\n      headingPitchRoll.pitch,\n      headingPitchRoll.roll\n    );\n  }\n  result.heading = headingPitchRoll.heading;\n  result.pitch = headingPitchRoll.pitch;\n  result.roll = headingPitchRoll.roll;\n  return result;\n};\n\n/**\n * Compares the provided HeadingPitchRolls componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.\n * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nHeadingPitchRoll.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.heading === right.heading &&\n      left.pitch === right.pitch &&\n      left.roll === right.roll)\n  );\n};\n\n/**\n * Compares the provided HeadingPitchRolls componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.\n * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nHeadingPitchRoll.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.heading,\n        right.heading,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.pitch,\n        right.pitch,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.roll,\n        right.roll,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * Duplicates this HeadingPitchRoll instance.\n *\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.\n */\nHeadingPitchRoll.prototype.clone = function (result) {\n  return HeadingPitchRoll.clone(this, result);\n};\n\n/**\n * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nHeadingPitchRoll.prototype.equals = function (right) {\n  return HeadingPitchRoll.equals(this, right);\n};\n\n/**\n * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nHeadingPitchRoll.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return HeadingPitchRoll.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this HeadingPitchRoll in the format '(heading, pitch, roll)' in radians.\n *\n * @returns {String} A string representing the provided HeadingPitchRoll in the format '(heading, pitch, roll)'.\n */\nHeadingPitchRoll.prototype.toString = function () {\n  return `(${this.heading}, ${this.pitch}, ${this.roll})`;\n};\nexport default HeadingPitchRoll;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Array implementation of a heap.\n *\n * @alias Heap\n * @constructor\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {Heap.ComparatorCallback} options.comparator The comparator to use for the heap. If comparator(a, b) is less than 0, sort a to a lower index than b, otherwise sort to a higher index.\n */\nfunction Heap(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.defined(\"options.comparator\", options.comparator);\n  //>>includeEnd('debug');\n\n  this._comparator = options.comparator;\n  this._array = [];\n  this._length = 0;\n  this._maximumLength = undefined;\n}\n\nObject.defineProperties(Heap.prototype, {\n  /**\n   * Gets the length of the heap.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n\n  /**\n   * Gets the internal array.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Array}\n   * @readonly\n   */\n  internalArray: {\n    get: function () {\n      return this._array;\n    },\n  },\n\n  /**\n   * Gets and sets the maximum length of the heap.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Number}\n   */\n  maximumLength: {\n    get: function () {\n      return this._maximumLength;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"maximumLength\", value, 0);\n      //>>includeEnd('debug');\n      const originalLength = this._length;\n      if (value < originalLength) {\n        const array = this._array;\n        // Remove trailing references\n        for (let i = value; i < originalLength; ++i) {\n          array[i] = undefined;\n        }\n        this._length = value;\n        array.length = value;\n      }\n      this._maximumLength = value;\n    },\n  },\n\n  /**\n   * The comparator to use for the heap. If comparator(a, b) is less than 0, sort a to a lower index than b, otherwise sort to a higher index.\n   *\n   * @memberof Heap.prototype\n   *\n   * @type {Heap.ComparatorCallback}\n   */\n  comparator: {\n    get: function () {\n      return this._comparator;\n    },\n  },\n});\n\nfunction swap(array, a, b) {\n  const temp = array[a];\n  array[a] = array[b];\n  array[b] = temp;\n}\n\n/**\n * Resizes the internal array of the heap.\n *\n * @param {Number} [length] The length to resize internal array to. Defaults to the current length of the heap.\n */\nHeap.prototype.reserve = function (length) {\n  length = defaultValue(length, this._length);\n  this._array.length = length;\n};\n\n/**\n * Update the heap so that index and all descendants satisfy the heap property.\n *\n * @param {Number} [index=0] The starting index to heapify from.\n */\nHeap.prototype.heapify = function (index) {\n  index = defaultValue(index, 0);\n  const length = this._length;\n  const comparator = this._comparator;\n  const array = this._array;\n  let candidate = -1;\n  let inserting = true;\n\n  while (inserting) {\n    const right = 2 * (index + 1);\n    const left = right - 1;\n\n    if (left < length && comparator(array[left], array[index]) < 0) {\n      candidate = left;\n    } else {\n      candidate = index;\n    }\n\n    if (right < length && comparator(array[right], array[candidate]) < 0) {\n      candidate = right;\n    }\n    if (candidate !== index) {\n      swap(array, candidate, index);\n      index = candidate;\n    } else {\n      inserting = false;\n    }\n  }\n};\n\n/**\n * Resort the heap.\n */\nHeap.prototype.resort = function () {\n  const length = this._length;\n  for (let i = Math.ceil(length / 2); i >= 0; --i) {\n    this.heapify(i);\n  }\n};\n\n/**\n * Insert an element into the heap. If the length would grow greater than maximumLength\n * of the heap, extra elements are removed.\n *\n * @param {*} element The element to insert\n *\n * @return {*} The element that was removed from the heap if the heap is at full capacity.\n */\nHeap.prototype.insert = function (element) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"element\", element);\n  //>>includeEnd('debug');\n\n  const array = this._array;\n  const comparator = this._comparator;\n  const maximumLength = this._maximumLength;\n\n  let index = this._length++;\n  if (index < array.length) {\n    array[index] = element;\n  } else {\n    array.push(element);\n  }\n\n  while (index !== 0) {\n    const parent = Math.floor((index - 1) / 2);\n    if (comparator(array[index], array[parent]) < 0) {\n      swap(array, index, parent);\n      index = parent;\n    } else {\n      break;\n    }\n  }\n\n  let removedElement;\n\n  if (defined(maximumLength) && this._length > maximumLength) {\n    removedElement = array[maximumLength];\n    this._length = maximumLength;\n  }\n\n  return removedElement;\n};\n\n/**\n * Remove the element specified by index from the heap and return it.\n *\n * @param {Number} [index=0] The index to remove.\n * @returns {*} The specified element of the heap.\n */\nHeap.prototype.pop = function (index) {\n  index = defaultValue(index, 0);\n  if (this._length === 0) {\n    return undefined;\n  }\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.lessThan(\"index\", index, this._length);\n  //>>includeEnd('debug');\n\n  const array = this._array;\n  const root = array[index];\n  swap(array, index, --this._length);\n  this.heapify(index);\n  array[this._length] = undefined; // Remove trailing reference\n  return root;\n};\n\n/**\n * The comparator to use for the heap.\n * @callback Heap.ComparatorCallback\n * @param {*} a An element in the heap.\n * @param {*} b An element in the heap.\n * @returns {Number} If the result of the comparison is less than 0, sort a to a lower index than b, otherwise sort to a higher index.\n */\nexport default Heap;\n","/**\n * The encoding that is used for a heightmap\n *\n * @enum {Number}\n */\nconst HeightmapEncoding = {\n  /**\n   * No encoding\n   *\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * LERC encoding\n   *\n   * @type {Number}\n   * @constant\n   *\n   * @see {@link https://github.com/Esri/lerc|The LERC specification}\n   */\n  LERC: 1,\n};\nexport default Object.freeze(HeightmapEncoding);\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTessellator from \"./HeightmapTessellator.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap\n * is a rectangular array of heights in row-major order from north to south and west to east.\n *\n * @alias HeightmapTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.buffer The buffer containing height data.\n * @param {Number} options.width The width (longitude direction) of the heightmap, in samples.\n * @param {Number} options.height The height (latitude direction) of the heightmap, in samples.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Uint8Array} [options.waterMask] The water mask included in this terrain data, if any.  A water mask is a square\n *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {HeightmapEncoding} [options.encoding=HeightmapEncoding.NONE] The encoding that is used on the buffer.\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n *\n *\n * @example\n * const buffer = ...\n * const heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * const childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * const waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * const terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n * @see TerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction HeightmapTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.buffer)) {\n    throw new DeveloperError(\"options.buffer is required.\");\n  }\n  if (!defined(options.width)) {\n    throw new DeveloperError(\"options.width is required.\");\n  }\n  if (!defined(options.height)) {\n    throw new DeveloperError(\"options.height is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._width = options.width;\n  this._height = options.height;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._encoding = defaultValue(options.encoding, HeightmapEncoding.NONE);\n\n  const defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;\n  let structure = options.structure;\n  if (!defined(structure)) {\n    structure = defaultStructure;\n  } else if (structure !== defaultStructure) {\n    structure.heightScale = defaultValue(\n      structure.heightScale,\n      defaultStructure.heightScale\n    );\n    structure.heightOffset = defaultValue(\n      structure.heightOffset,\n      defaultStructure.heightOffset\n    );\n    structure.elementsPerHeight = defaultValue(\n      structure.elementsPerHeight,\n      defaultStructure.elementsPerHeight\n    );\n    structure.stride = defaultValue(structure.stride, defaultStructure.stride);\n    structure.elementMultiplier = defaultValue(\n      structure.elementMultiplier,\n      defaultStructure.elementMultiplier\n    );\n    structure.isBigEndian = defaultValue(\n      structure.isBigEndian,\n      defaultStructure.isBigEndian\n    );\n  }\n\n  this._structure = structure;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n\n  this._skirtHeight = undefined;\n  this._bufferType =\n    this._encoding === HeightmapEncoding.LERC\n      ? Float32Array\n      : this._buffer.constructor;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(HeightmapTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a square\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n});\n\nconst createMeshTaskName = \"createVerticesFromHeightmap\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nHeightmapTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(\n    options.exaggerationRelativeHeight,\n    0.0\n  );\n  const throttle = defaultValue(options.throttle, true);\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  const structure = this._structure;\n\n  const levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    ellipsoid,\n    this._width,\n    tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  const createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n    encoding: this._encoding,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return Promise.resolve(verticesPromise).then(function (result) {\n    let indicesAndEdges;\n    if (that._skirtHeight > 0.0) {\n      indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight\n      );\n    } else {\n      indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight\n      );\n    }\n\n    const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      center,\n      new Float32Array(result.vertices),\n      indicesAndEdges.indices,\n      indicesAndEdges.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      BoundingSphere.clone(result.boundingSphere3D),\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      TerrainEncoding.clone(result.encoding),\n      indicesAndEdges.westIndicesSouthToNorth,\n      indicesAndEdges.southIndicesEastToWest,\n      indicesAndEdges.eastIndicesNorthToSouth,\n      indicesAndEdges.northIndicesWestToEast\n    );\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n *\n * @private\n */\nHeightmapTerrainData.prototype._createMeshSync = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(\n    options.exaggerationRelativeHeight,\n    0.0\n  );\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  const center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  const structure = this._structure;\n\n  const levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    ellipsoid,\n    this._width,\n    tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n  const thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  const result = HeightmapTessellator.computeVertices({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n  });\n\n  // Free memory received from server after mesh is created.\n  this._buffer = undefined;\n\n  let indicesAndEdges;\n  if (this._skirtHeight > 0.0) {\n    indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n      this._width,\n      this._height\n    );\n  } else {\n    indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n      this._width,\n      this._height\n    );\n  }\n\n  const vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n  // No need to clone here (as we do in the async version) because the result\n  // is not coming from a web worker.\n  this._mesh = new TerrainMesh(\n    center,\n    result.vertices,\n    indicesAndEdges.indices,\n    indicesAndEdges.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts,\n    result.minimumHeight,\n    result.maximumHeight,\n    result.boundingSphere3D,\n    result.occludeePointInScaledSpace,\n    result.encoding.stride,\n    result.orientedBoundingBox,\n    result.encoding,\n    indicesAndEdges.westIndicesSouthToNorth,\n    indicesAndEdges.southIndicesEastToWest,\n    indicesAndEdges.eastIndicesNorthToSouth,\n    indicesAndEdges.northIndicesWestToEast\n  );\n\n  return this._mesh;\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nHeightmapTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  const width = this._width;\n  const height = this._height;\n\n  const structure = this._structure;\n  const stride = structure.stride;\n  const elementsPerHeight = structure.elementsPerHeight;\n  const elementMultiplier = structure.elementMultiplier;\n  const isBigEndian = structure.isBigEndian;\n  const heightOffset = structure.heightOffset;\n  const heightScale = structure.heightScale;\n\n  const isMeshCreated = defined(this._mesh);\n  const isLERCEncoding = this._encoding === HeightmapEncoding.LERC;\n  const isInterpolationImpossible = !isMeshCreated && isLERCEncoding;\n  if (isInterpolationImpossible) {\n    // We can't interpolate using the buffer because it's LERC encoded\n    //  so please call createMesh() first and interpolate using the mesh;\n    //  as mesh creation will decode the LERC buffer\n    return undefined;\n  }\n\n  let heightSample;\n  if (isMeshCreated) {\n    const buffer = this._mesh.vertices;\n    const encoding = this._mesh.encoding;\n    heightSample = interpolateMeshHeight(\n      buffer,\n      encoding,\n      heightOffset,\n      heightScale,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude\n    );\n  } else {\n    heightSample = interpolateHeight(\n      this._buffer,\n      elementsPerHeight,\n      elementMultiplier,\n      stride,\n      isBigEndian,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude\n    );\n    heightSample = heightSample * heightScale + heightOffset;\n  }\n\n  return heightSample;\n};\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if the mesh is unavailable.\n */\nHeightmapTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const meshData = this._mesh;\n  if (!defined(meshData)) {\n    return undefined;\n  }\n\n  const width = this._width;\n  const height = this._height;\n  const structure = this._structure;\n  const stride = structure.stride;\n\n  const heights = new this._bufferType(width * height * stride);\n\n  const buffer = meshData.vertices;\n  const encoding = meshData.encoding;\n\n  // PERFORMANCE_IDEA: don't recompute these rectangles - the caller already knows them.\n  const sourceRectangle = tilingScheme.tileXYToRectangle(\n    thisX,\n    thisY,\n    thisLevel\n  );\n  const destinationRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  const heightOffset = structure.heightOffset;\n  const heightScale = structure.heightScale;\n\n  const elementsPerHeight = structure.elementsPerHeight;\n  const elementMultiplier = structure.elementMultiplier;\n  const isBigEndian = structure.isBigEndian;\n\n  const divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);\n\n  for (let j = 0; j < height; ++j) {\n    const latitude = CesiumMath.lerp(\n      destinationRectangle.north,\n      destinationRectangle.south,\n      j / (height - 1)\n    );\n    for (let i = 0; i < width; ++i) {\n      const longitude = CesiumMath.lerp(\n        destinationRectangle.west,\n        destinationRectangle.east,\n        i / (width - 1)\n      );\n      let heightSample = interpolateMeshHeight(\n        buffer,\n        encoding,\n        heightOffset,\n        heightScale,\n        sourceRectangle,\n        width,\n        height,\n        longitude,\n        latitude\n      );\n\n      // Use conditionals here instead of Math.min and Math.max so that an undefined\n      // lowestEncodedHeight or highestEncodedHeight has no effect.\n      heightSample =\n        heightSample < structure.lowestEncodedHeight\n          ? structure.lowestEncodedHeight\n          : heightSample;\n      heightSample =\n        heightSample > structure.highestEncodedHeight\n          ? structure.highestEncodedHeight\n          : heightSample;\n\n      setHeight(\n        heights,\n        elementsPerHeight,\n        elementMultiplier,\n        divisor,\n        stride,\n        isBigEndian,\n        j * width + i,\n        heightSample\n      );\n    }\n  }\n\n  return Promise.resolve(\n    new HeightmapTerrainData({\n      buffer: heights,\n      width: width,\n      height: height,\n      childTileMask: 0,\n      structure: this._structure,\n      createdByUpsampling: true,\n    })\n  );\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nHeightmapTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nHeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nfunction interpolateHeight(\n  sourceHeights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude\n) {\n  const fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  const fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  let westInteger = fromWest | 0;\n  let eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  let southInteger = fromSouth | 0;\n  let northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  const dx = fromWest - westInteger;\n  const dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  const southwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + westInteger\n  );\n  const southeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + eastInteger\n  );\n  const northwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + westInteger\n  );\n  const northeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + eastInteger\n  );\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n}\n\nfunction interpolateMeshHeight(\n  buffer,\n  encoding,\n  heightOffset,\n  heightScale,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude\n) {\n  // returns a height encoded according to the structure's heightScale and heightOffset.\n  const fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  const fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  let westInteger = fromWest | 0;\n  let eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  let southInteger = fromSouth | 0;\n  let northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  const dx = fromWest - westInteger;\n  const dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  const southwestHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + westInteger) -\n      heightOffset) /\n    heightScale;\n  const southeastHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + eastInteger) -\n      heightOffset) /\n    heightScale;\n  const northwestHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + westInteger) -\n      heightOffset) /\n    heightScale;\n  const northeastHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + eastInteger) -\n      heightOffset) /\n    heightScale;\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n}\n\nfunction triangleInterpolateHeight(\n  dX,\n  dY,\n  southwestHeight,\n  southeastHeight,\n  northwestHeight,\n  northeastHeight\n) {\n  // The HeightmapTessellator bisects the quad from southwest to northeast.\n  if (dY < dX) {\n    // Lower right triangle\n    return (\n      southwestHeight +\n      dX * (southeastHeight - southwestHeight) +\n      dY * (northeastHeight - southeastHeight)\n    );\n  }\n\n  // Upper left triangle\n  return (\n    southwestHeight +\n    dX * (northeastHeight - northwestHeight) +\n    dY * (northwestHeight - southwestHeight)\n  );\n}\n\nfunction getHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  index\n) {\n  index *= stride;\n\n  let height = 0;\n  let i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight; ++i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i >= 0; --i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  }\n\n  return height;\n}\n\nfunction setHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  divisor,\n  stride,\n  isBigEndian,\n  index,\n  height\n) {\n  index *= stride;\n\n  let i;\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight - 1; ++i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i > 0; --i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  }\n  heights[index + i] = height;\n}\nexport default HeightmapTerrainData;\n","import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidalOccluder from \"./EllipsoidalOccluder.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport Transforms from \"./Transforms.js\";\nimport WebMercatorProjection from \"./WebMercatorProjection.js\";\n\n/**\n * Contains functions to create a mesh from a heightmap image.\n *\n * @namespace HeightmapTessellator\n *\n * @private\n */\nconst HeightmapTessellator = {};\n\n/**\n * The default structure of a heightmap, as given to {@link HeightmapTessellator.computeVertices}.\n *\n * @constant\n */\nHeightmapTessellator.DEFAULT_STRUCTURE = Object.freeze({\n  heightScale: 1.0,\n  heightOffset: 0.0,\n  elementsPerHeight: 1,\n  stride: 1,\n  elementMultiplier: 256.0,\n  isBigEndian: false,\n});\n\nconst cartesian3Scratch = new Cartesian3();\nconst matrix4Scratch = new Matrix4();\nconst minimumScratch = new Cartesian3();\nconst maximumScratch = new Cartesian3();\n\n/**\n * Fills an array of vertices from a heightmap image.\n *\n * @param {Object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.heightmap The heightmap to tessellate.\n * @param {Number} options.width The width of the heightmap, in height samples.\n * @param {Number} options.height The height of the heightmap, in height samples.\n * @param {Number} options.skirtHeight The height of skirts to drape at the edges of the heightmap.\n * @param {Rectangle} options.nativeRectangle A rectangle in the native coordinates of the heightmap's projection.  For\n *                 a heightmap with a geographic projection, this is degrees.  For the web mercator\n *                 projection, this is meters.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Number} [options.exaggerationRelativeHeight=0.0] The height from which terrain is exaggerated.\n * @param {Rectangle} [options.rectangle] The rectangle covered by the heightmap, in geodetic coordinates with north, south, east and\n *                 west properties in radians.  Either rectangle or nativeRectangle must be provided.  If both\n *                 are provided, they're assumed to be consistent.\n * @param {Boolean} [options.isGeographic=true] True if the heightmap uses a {@link GeographicProjection}, or false if it uses\n *                  a {@link WebMercatorProjection}.\n * @param {Cartesian3} [options.relativeToCenter=Cartesian3.ZERO] The positions will be computed as <code>Cartesian3.subtract(worldPosition, relativeToCenter)</code>.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to which the heightmap applies.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n *\n * @example\n * const width = 5;\n * const height = 5;\n * const statistics = Cesium.HeightmapTessellator.computeVertices({\n *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\n *     width : width,\n *     height : height,\n *     skirtHeight : 0.0,\n *     nativeRectangle : {\n *         west : 10.0,\n *         east : 20.0,\n *         south : 30.0,\n *         north : 40.0\n *     }\n * });\n *\n * const encoding = statistics.encoding;\n * const position = encoding.decodePosition(statistics.vertices, index);\n */\nHeightmapTessellator.computeVertices = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.heightmap)) {\n    throw new DeveloperError(\"options.heightmap is required.\");\n  }\n  if (!defined(options.width) || !defined(options.height)) {\n    throw new DeveloperError(\"options.width and options.height are required.\");\n  }\n  if (!defined(options.nativeRectangle)) {\n    throw new DeveloperError(\"options.nativeRectangle is required.\");\n  }\n  if (!defined(options.skirtHeight)) {\n    throw new DeveloperError(\"options.skirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // This function tends to be a performance hotspot for terrain rendering,\n  // so it employs a lot of inlining and unrolling as an optimization.\n  // In particular, the functionality of Ellipsoid.cartographicToCartesian\n  // is inlined.\n\n  const cos = Math.cos;\n  const sin = Math.sin;\n  const sqrt = Math.sqrt;\n  const atan = Math.atan;\n  const exp = Math.exp;\n  const piOverTwo = CesiumMath.PI_OVER_TWO;\n  const toRadians = CesiumMath.toRadians;\n\n  const heightmap = options.heightmap;\n  const width = options.width;\n  const height = options.height;\n  const skirtHeight = options.skirtHeight;\n  const hasSkirts = skirtHeight > 0.0;\n\n  const isGeographic = defaultValue(options.isGeographic, true);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  const oneOverGlobeSemimajorAxis = 1.0 / ellipsoid.maximumRadius;\n\n  const nativeRectangle = Rectangle.clone(options.nativeRectangle);\n  const rectangle = Rectangle.clone(options.rectangle);\n\n  let geographicWest;\n  let geographicSouth;\n  let geographicEast;\n  let geographicNorth;\n\n  if (!defined(rectangle)) {\n    if (isGeographic) {\n      geographicWest = toRadians(nativeRectangle.west);\n      geographicSouth = toRadians(nativeRectangle.south);\n      geographicEast = toRadians(nativeRectangle.east);\n      geographicNorth = toRadians(nativeRectangle.north);\n    } else {\n      geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;\n      geographicSouth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis));\n      geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;\n      geographicNorth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis));\n    }\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n  }\n\n  let relativeToCenter = options.relativeToCenter;\n  const hasRelativeToCenter = defined(relativeToCenter);\n  relativeToCenter = hasRelativeToCenter ? relativeToCenter : Cartesian3.ZERO;\n  const includeWebMercatorT = defaultValue(options.includeWebMercatorT, false);\n\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(\n    options.exaggerationRelativeHeight,\n    0.0\n  );\n  const hasExaggeration = exaggeration !== 1.0;\n  const includeGeodeticSurfaceNormals = hasExaggeration;\n\n  const structure = defaultValue(\n    options.structure,\n    HeightmapTessellator.DEFAULT_STRUCTURE\n  );\n  const heightScale = defaultValue(\n    structure.heightScale,\n    HeightmapTessellator.DEFAULT_STRUCTURE.heightScale\n  );\n  const heightOffset = defaultValue(\n    structure.heightOffset,\n    HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset\n  );\n  const elementsPerHeight = defaultValue(\n    structure.elementsPerHeight,\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight\n  );\n  const stride = defaultValue(\n    structure.stride,\n    HeightmapTessellator.DEFAULT_STRUCTURE.stride\n  );\n  const elementMultiplier = defaultValue(\n    structure.elementMultiplier,\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier\n  );\n  const isBigEndian = defaultValue(\n    structure.isBigEndian,\n    HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian\n  );\n\n  let rectangleWidth = Rectangle.computeWidth(nativeRectangle);\n  let rectangleHeight = Rectangle.computeHeight(nativeRectangle);\n\n  const granularityX = rectangleWidth / (width - 1);\n  const granularityY = rectangleHeight / (height - 1);\n\n  if (!isGeographic) {\n    rectangleWidth *= oneOverGlobeSemimajorAxis;\n    rectangleHeight *= oneOverGlobeSemimajorAxis;\n  }\n\n  const radiiSquared = ellipsoid.radiiSquared;\n  const radiiSquaredX = radiiSquared.x;\n  const radiiSquaredY = radiiSquared.y;\n  const radiiSquaredZ = radiiSquared.z;\n\n  let minimumHeight = 65536.0;\n  let maximumHeight = -65536.0;\n\n  const fromENU = Transforms.eastNorthUpToFixedFrame(\n    relativeToCenter,\n    ellipsoid\n  );\n  const toENU = Matrix4.inverseTransformation(fromENU, matrix4Scratch);\n\n  let southMercatorY;\n  let oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      geographicSouth\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(geographicNorth) -\n        southMercatorY);\n  }\n\n  const minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n\n  const maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n\n  let hMin = Number.POSITIVE_INFINITY;\n\n  const gridVertexCount = width * height;\n  const edgeVertexCount = skirtHeight > 0.0 ? width * 2 + height * 2 : 0;\n  const vertexCount = gridVertexCount + edgeVertexCount;\n\n  const positions = new Array(vertexCount);\n  const heights = new Array(vertexCount);\n  const uvs = new Array(vertexCount);\n  const webMercatorTs = includeWebMercatorT ? new Array(vertexCount) : [];\n  const geodeticSurfaceNormals = includeGeodeticSurfaceNormals\n    ? new Array(vertexCount)\n    : [];\n\n  let startRow = 0;\n  let endRow = height;\n  let startCol = 0;\n  let endCol = width;\n\n  if (hasSkirts) {\n    --startRow;\n    ++endRow;\n    --startCol;\n    ++endCol;\n  }\n\n  const skirtOffsetPercentage = 0.00001;\n\n  for (let rowIndex = startRow; rowIndex < endRow; ++rowIndex) {\n    let row = rowIndex;\n    if (row < 0) {\n      row = 0;\n    }\n    if (row >= height) {\n      row = height - 1;\n    }\n\n    let latitude = nativeRectangle.north - granularityY * row;\n\n    if (!isGeographic) {\n      latitude =\n        piOverTwo - 2.0 * atan(exp(-latitude * oneOverGlobeSemimajorAxis));\n    } else {\n      latitude = toRadians(latitude);\n    }\n\n    let v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n    v = CesiumMath.clamp(v, 0.0, 1.0);\n\n    const isNorthEdge = rowIndex === startRow;\n    const isSouthEdge = rowIndex === endRow - 1;\n    if (skirtHeight > 0.0) {\n      if (isNorthEdge) {\n        latitude += skirtOffsetPercentage * rectangleHeight;\n      } else if (isSouthEdge) {\n        latitude -= skirtOffsetPercentage * rectangleHeight;\n      }\n    }\n\n    const cosLatitude = cos(latitude);\n    const nZ = sin(latitude);\n    const kZ = radiiSquaredZ * nZ;\n\n    let webMercatorT;\n    if (includeWebMercatorT) {\n      webMercatorT =\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    for (let colIndex = startCol; colIndex < endCol; ++colIndex) {\n      let col = colIndex;\n      if (col < 0) {\n        col = 0;\n      }\n      if (col >= width) {\n        col = width - 1;\n      }\n\n      const terrainOffset = row * (width * stride) + col * stride;\n\n      let heightSample;\n      if (elementsPerHeight === 1) {\n        heightSample = heightmap[terrainOffset];\n      } else {\n        heightSample = 0;\n\n        let elementOffset;\n        if (isBigEndian) {\n          for (\n            elementOffset = 0;\n            elementOffset < elementsPerHeight;\n            ++elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        } else {\n          for (\n            elementOffset = elementsPerHeight - 1;\n            elementOffset >= 0;\n            --elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        }\n      }\n\n      heightSample = heightSample * heightScale + heightOffset;\n\n      maximumHeight = Math.max(maximumHeight, heightSample);\n      minimumHeight = Math.min(minimumHeight, heightSample);\n\n      let longitude = nativeRectangle.west + granularityX * col;\n\n      if (!isGeographic) {\n        longitude = longitude * oneOverGlobeSemimajorAxis;\n      } else {\n        longitude = toRadians(longitude);\n      }\n\n      let u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = CesiumMath.clamp(u, 0.0, 1.0);\n\n      let index = row * width + col;\n\n      if (skirtHeight > 0.0) {\n        const isWestEdge = colIndex === startCol;\n        const isEastEdge = colIndex === endCol - 1;\n        const isEdge = isNorthEdge || isSouthEdge || isWestEdge || isEastEdge;\n        const isCorner =\n          (isNorthEdge || isSouthEdge) && (isWestEdge || isEastEdge);\n        if (isCorner) {\n          // Don't generate skirts on the corners.\n          continue;\n        } else if (isEdge) {\n          heightSample -= skirtHeight;\n\n          if (isWestEdge) {\n            // The outer loop iterates north to south but the indices are ordered south to north, hence the index flip below\n            index = gridVertexCount + (height - row - 1);\n            longitude -= skirtOffsetPercentage * rectangleWidth;\n          } else if (isSouthEdge) {\n            // Add after west indices. South indices are ordered east to west.\n            index = gridVertexCount + height + (width - col - 1);\n          } else if (isEastEdge) {\n            // Add after west and south indices. East indices are ordered north to south. The index is flipped like above.\n            index = gridVertexCount + height + width + row;\n            longitude += skirtOffsetPercentage * rectangleWidth;\n          } else if (isNorthEdge) {\n            // Add after west, south, and east indices. North indices are ordered west to east.\n            index = gridVertexCount + height + width + height + col;\n          }\n        }\n      }\n\n      const nX = cosLatitude * cos(longitude);\n      const nY = cosLatitude * sin(longitude);\n\n      const kX = radiiSquaredX * nX;\n      const kY = radiiSquaredY * nY;\n\n      const gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n      const oneOverGamma = 1.0 / gamma;\n\n      const rSurfaceX = kX * oneOverGamma;\n      const rSurfaceY = kY * oneOverGamma;\n      const rSurfaceZ = kZ * oneOverGamma;\n\n      const position = new Cartesian3();\n      position.x = rSurfaceX + nX * heightSample;\n      position.y = rSurfaceY + nY * heightSample;\n      position.z = rSurfaceZ + nZ * heightSample;\n\n      Matrix4.multiplyByPoint(toENU, position, cartesian3Scratch);\n      Cartesian3.minimumByComponent(cartesian3Scratch, minimum, minimum);\n      Cartesian3.maximumByComponent(cartesian3Scratch, maximum, maximum);\n      hMin = Math.min(hMin, heightSample);\n\n      positions[index] = position;\n      uvs[index] = new Cartesian2(u, v);\n      heights[index] = heightSample;\n\n      if (includeWebMercatorT) {\n        webMercatorTs[index] = webMercatorT;\n      }\n\n      if (includeGeodeticSurfaceNormals) {\n        geodeticSurfaceNormals[index] = ellipsoid.geodeticSurfaceNormal(\n          position\n        );\n      }\n    }\n  }\n\n  const boundingSphere3D = BoundingSphere.fromPoints(positions);\n  let orientedBoundingBox;\n  if (defined(rectangle)) {\n    orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minimumHeight,\n      maximumHeight,\n      ellipsoid\n    );\n  }\n\n  let occludeePointInScaledSpace;\n  if (hasRelativeToCenter) {\n    const occluder = new EllipsoidalOccluder(ellipsoid);\n    occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n      relativeToCenter,\n      positions,\n      minimumHeight\n    );\n  }\n\n  const aaBox = new AxisAlignedBoundingBox(minimum, maximum, relativeToCenter);\n  const encoding = new TerrainEncoding(\n    relativeToCenter,\n    aaBox,\n    hMin,\n    maximumHeight,\n    fromENU,\n    false,\n    includeWebMercatorT,\n    includeGeodeticSurfaceNormals,\n    exaggeration,\n    exaggerationRelativeHeight\n  );\n  const vertices = new Float32Array(vertexCount * encoding.stride);\n\n  let bufferIndex = 0;\n  for (let j = 0; j < vertexCount; ++j) {\n    bufferIndex = encoding.encode(\n      vertices,\n      bufferIndex,\n      positions[j],\n      uvs[j],\n      heights[j],\n      undefined,\n      webMercatorTs[j],\n      geodeticSurfaceNormals[j]\n    );\n  }\n\n  return {\n    vertices: vertices,\n    maximumHeight: maximumHeight,\n    minimumHeight: minimumHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\n  };\n};\nexport default HeightmapTessellator;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\nconst factorial = CesiumMath.factorial;\n\nfunction calculateCoefficientTerm(\n  x,\n  zIndices,\n  xTable,\n  derivOrder,\n  termOrder,\n  reservedIndices\n) {\n  let result = 0;\n  let reserved;\n  let i;\n  let j;\n\n  if (derivOrder > 0) {\n    for (i = 0; i < termOrder; i++) {\n      reserved = false;\n      for (j = 0; j < reservedIndices.length && !reserved; j++) {\n        if (i === reservedIndices[j]) {\n          reserved = true;\n        }\n      }\n\n      if (!reserved) {\n        reservedIndices.push(i);\n        result += calculateCoefficientTerm(\n          x,\n          zIndices,\n          xTable,\n          derivOrder - 1,\n          termOrder,\n          reservedIndices\n        );\n        reservedIndices.splice(reservedIndices.length - 1, 1);\n      }\n    }\n\n    return result;\n  }\n\n  result = 1;\n  for (i = 0; i < termOrder; i++) {\n    reserved = false;\n    for (j = 0; j < reservedIndices.length && !reserved; j++) {\n      if (i === reservedIndices[j]) {\n        reserved = true;\n      }\n    }\n\n    if (!reserved) {\n      result *= x - xTable[zIndices[i]];\n    }\n  }\n\n  return result;\n}\n\n/**\n * An {@link InterpolationAlgorithm} for performing Hermite interpolation.\n *\n * @namespace HermitePolynomialApproximation\n */\nconst HermitePolynomialApproximation = {\n  type: \"Hermite\",\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n *\n * @param {Number} degree The desired degree of interpolation.\n * @param {Number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).\n * @returns {Number} The number of required data points needed for the desired degree of interpolation.\n * @exception {DeveloperError} degree must be 0 or greater.\n * @exception {DeveloperError} inputOrder must be 0 or greater.\n */\nHermitePolynomialApproximation.getRequiredDataPoints = function (\n  degree,\n  inputOrder\n) {\n  inputOrder = defaultValue(inputOrder, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degree)) {\n    throw new DeveloperError(\"degree is required.\");\n  }\n  if (degree < 0) {\n    throw new DeveloperError(\"degree must be 0 or greater.\");\n  }\n  if (inputOrder < 0) {\n    throw new DeveloperError(\"inputOrder must be 0 or greater.\");\n  }\n  //>>includeEnd('debug');\n\n  return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);\n};\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number[]} [result] An existing array into which to store the result.\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolateOrderZero = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  result\n) {\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n\n  let i;\n  let j;\n  let d;\n  let s;\n  let len;\n  let index;\n  const length = xTable.length;\n  const coefficients = new Array(yStride);\n\n  for (i = 0; i < yStride; i++) {\n    result[i] = 0;\n\n    const l = new Array(length);\n    coefficients[i] = l;\n    for (j = 0; j < length; j++) {\n      l[j] = [];\n    }\n  }\n\n  const zIndicesLength = length,\n    zIndices = new Array(zIndicesLength);\n\n  for (i = 0; i < zIndicesLength; i++) {\n    zIndices[i] = i;\n  }\n\n  let highestNonZeroCoef = length - 1;\n  for (s = 0; s < yStride; s++) {\n    for (j = 0; j < zIndicesLength; j++) {\n      index = zIndices[j] * yStride + s;\n      coefficients[s][0].push(yTable[index]);\n    }\n\n    for (i = 1; i < zIndicesLength; i++) {\n      let nonZeroCoefficients = false;\n      for (j = 0; j < zIndicesLength - i; j++) {\n        const zj = xTable[zIndices[j]];\n        const zn = xTable[zIndices[j + i]];\n\n        let numerator;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride + yStride * i + s;\n          numerator = yTable[index];\n          coefficients[s][i].push(numerator / factorial(i));\n        } else {\n          numerator = coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j];\n          coefficients[s][i].push(numerator / (zn - zj));\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0;\n      }\n\n      if (!nonZeroCoefficients) {\n        highestNonZeroCoef = i - 1;\n      }\n    }\n  }\n\n  for (d = 0, len = 0; d <= len; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      const tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);\n      for (s = 0; s < yStride; s++) {\n        const coeff = coefficients[s][i][0];\n        result[s + d * yStride] += coeff * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nconst arrayScratch = [];\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number} inputOrder The number of derivatives supplied for input.\n * @param {Number} outputOrder The number of derivatives desired for output.\n * @param {Number[]} [result] An existing array into which to store the result.\n *\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolate = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  inputOrder,\n  outputOrder,\n  result\n) {\n  const resultLength = yStride * (outputOrder + 1);\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  }\n  for (let r = 0; r < resultLength; r++) {\n    result[r] = 0;\n  }\n\n  const length = xTable.length;\n  // The zIndices array holds copies of the addresses of the xTable values\n  // in the range we're looking at. Even though this just holds information already\n  // available in xTable this is a much more convenient format.\n  const zIndices = new Array(length * (inputOrder + 1));\n  let i;\n  for (i = 0; i < length; i++) {\n    for (let j = 0; j < inputOrder + 1; j++) {\n      zIndices[i * (inputOrder + 1) + j] = i;\n    }\n  }\n\n  const zIndiceslength = zIndices.length;\n  const coefficients = arrayScratch;\n  const highestNonZeroCoef = fillCoefficientList(\n    coefficients,\n    zIndices,\n    xTable,\n    yTable,\n    yStride,\n    inputOrder\n  );\n  const reservedIndices = [];\n\n  const tmp = (zIndiceslength * (zIndiceslength + 1)) / 2;\n  const loopStop = Math.min(highestNonZeroCoef, outputOrder);\n  for (let d = 0; d <= loopStop; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      reservedIndices.length = 0;\n      const tempTerm = calculateCoefficientTerm(\n        x,\n        zIndices,\n        xTable,\n        d,\n        i,\n        reservedIndices\n      );\n      const dimTwo = Math.floor((i * (1 - i)) / 2) + zIndiceslength * i;\n\n      for (let s = 0; s < yStride; s++) {\n        const dimOne = Math.floor(s * tmp);\n        const coef = coefficients[dimOne + dimTwo];\n        result[s + d * yStride] += coef * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nfunction fillCoefficientList(\n  coefficients,\n  zIndices,\n  xTable,\n  yTable,\n  yStride,\n  inputOrder\n) {\n  let j;\n  let index;\n  let highestNonZero = -1;\n  const zIndiceslength = zIndices.length;\n  const tmp = (zIndiceslength * (zIndiceslength + 1)) / 2;\n\n  for (let s = 0; s < yStride; s++) {\n    const dimOne = Math.floor(s * tmp);\n\n    for (j = 0; j < zIndiceslength; j++) {\n      index = zIndices[j] * yStride * (inputOrder + 1) + s;\n      coefficients[dimOne + j] = yTable[index];\n    }\n\n    for (let i = 1; i < zIndiceslength; i++) {\n      let coefIndex = 0;\n      const dimTwo = Math.floor((i * (1 - i)) / 2) + zIndiceslength * i;\n      let nonZeroCoefficients = false;\n\n      for (j = 0; j < zIndiceslength - i; j++) {\n        const zj = xTable[zIndices[j]];\n        const zn = xTable[zIndices[j + i]];\n\n        let numerator;\n        let coefficient;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;\n          numerator = yTable[index];\n          coefficient = numerator / CesiumMath.factorial(i);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        } else {\n          const dimTwoMinusOne =\n            Math.floor(((i - 1) * (2 - i)) / 2) + zIndiceslength * (i - 1);\n          numerator =\n            coefficients[dimOne + dimTwoMinusOne + j + 1] -\n            coefficients[dimOne + dimTwoMinusOne + j];\n          coefficient = numerator / (zn - zj);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0.0;\n      }\n\n      if (nonZeroCoefficients) {\n        highestNonZero = Math.max(highestNonZero, i);\n      }\n    }\n  }\n\n  return highestNonZero;\n}\nexport default HermitePolynomialApproximation;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport LinearSpline from \"./LinearSpline.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Spline from \"./Spline.js\";\nimport TridiagonalSystemSolver from \"./TridiagonalSystemSolver.js\";\n\nconst scratchLower = [];\nconst scratchDiagonal = [];\nconst scratchUpper = [];\nconst scratchRight = [];\n\nfunction generateClamped(points, firstTangent, lastTangent) {\n  const l = scratchLower;\n  const u = scratchUpper;\n  const d = scratchDiagonal;\n  const r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  let i;\n  l[0] = d[0] = 1.0;\n  u[0] = 0.0;\n\n  let right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.clone(firstTangent, right);\n\n  for (i = 1; i < l.length - 1; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  l[i] = 0.0;\n  u[i] = 1.0;\n  d[i] = 4.0;\n\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i + 1], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  d[i + 1] = 1.0;\n  right = r[i + 1];\n  if (!defined(right)) {\n    right = r[i + 1] = new Cartesian3();\n  }\n  Cartesian3.clone(lastTangent, right);\n\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\nfunction generateNatural(points) {\n  const l = scratchLower;\n  const u = scratchUpper;\n  const d = scratchDiagonal;\n  const r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  let i;\n  l[0] = u[0] = 1.0;\n  d[0] = 2.0;\n\n  let right = r[0];\n  if (!defined(right)) {\n    right = r[0] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[1], points[0], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  for (i = 1; i < l.length; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!defined(right)) {\n      right = r[i] = new Cartesian3();\n    }\n    Cartesian3.subtract(points[i + 1], points[i - 1], right);\n    Cartesian3.multiplyByScalar(right, 3.0, right);\n  }\n\n  d[i] = 2.0;\n\n  right = r[i];\n  if (!defined(right)) {\n    right = r[i] = new Cartesian3();\n  }\n  Cartesian3.subtract(points[i], points[i - 1], right);\n  Cartesian3.multiplyByScalar(right, 3.0, right);\n\n  return TridiagonalSystemSolver.solve(l, d, u, r);\n}\n\n/**\n * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times\n * must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming\n * tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and\n * <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,\n * respectively.\n *\n * @alias HermiteSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.inTangents The array of incoming tangents at each control point.\n * @param {Cartesian3[]} options.outTangents The array of outgoing tangents at each control point.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} inTangents and outTangents must have a length equal to points.length - 1.\n * @exception {DeveloperError} inTangents and outTangents must be of the same type as points.\n *\n * @example\n * // Create a G<sup>1</sup> continuous Hermite spline\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.HermiteSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     outTangents : [\n *         new Cesium.Cartesian3(1125196, -161816, 270551),\n *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),\n *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),\n *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)\n *     ],\n *     inTangents : [\n *         new Cesium.Cartesian3(-1993381, -731813, 368057),\n *         new Cesium.Cartesian3(-4193834, 96759, -585367),\n *         new Cesium.Cartesian3(-1781805, 817999, -894230),\n *         new Cesium.Cartesian3(1165345, 112641, 47281)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see LinearSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction HermiteSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const points = options.points;\n  const times = options.times;\n  const inTangents = options.inTangents;\n  const outTangents = options.outTangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(points) ||\n    !defined(times) ||\n    !defined(inTangents) ||\n    !defined(outTangents)\n  ) {\n    throw new DeveloperError(\n      \"times, points, inTangents, and outTangents are required.\"\n    );\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  if (\n    inTangents.length !== outTangents.length ||\n    inTangents.length !== points.length - 1\n  ) {\n    throw new DeveloperError(\n      \"inTangents and outTangents must have a length equal to points.length - 1.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._pointType = Spline.getPointType(points[0]);\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    this._pointType !== Spline.getPointType(inTangents[0]) ||\n    this._pointType !== Spline.getPointType(outTangents[0])\n  ) {\n    throw new DeveloperError(\n      \"inTangents and outTangents must be of the same type as points.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._inTangents = inTangents;\n  this._outTangents = outTangents;\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(HermiteSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n\n  /**\n   * An array of incoming tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  inTangents: {\n    get: function () {\n      return this._inTangents;\n    },\n  },\n\n  /**\n   * An array of outgoing tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  outTangents: {\n    get: function () {\n      return this._outTangents;\n    },\n  },\n});\n\n/**\n * Creates a spline where the tangents at each control point are the same.\n * The curves are guaranteed to be at least in the class C<sup>1</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.tangents The array of tangents at the control points.\n * @returns {HermiteSpline} A hermite spline.\n *\n * @exception {DeveloperError} points, times and tangents are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times, points and tangents must have the same length.\n *\n * @example\n * const points = [\n *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n * ];\n *\n * // Add tangents\n * const tangents = new Array(points.length);\n * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);\n * const temp = new Cesium.Cartesian3();\n * for (let i = 1; i < tangents.length - 1; ++i) {\n *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());\n * }\n * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);\n *\n * const spline = Cesium.HermiteSpline.createC1({\n *     times : times,\n *     points : points,\n *     tangents : tangents\n * });\n */\nHermiteSpline.createC1 = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const times = options.times;\n  const points = options.points;\n  const tangents = options.tangents;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times) || !defined(tangents)) {\n    throw new DeveloperError(\"points, times and tangents are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length || times.length !== tangents.length) {\n    throw new DeveloperError(\n      \"times, points and tangents must have the same length.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a natural cubic spline. The tangents at the control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @returns {HermiteSpline|LinearSpline} A hermite spline, or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points and times are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createNaturalCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n */\nHermiteSpline.createNaturalCubic = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const times = options.times;\n  const points = options.points;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times,\n    });\n  }\n\n  const tangents = generateNatural(points);\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a clamped cubic spline. The tangents at the interior control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Number[]|Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3} options.firstTangent The outgoing tangent of the first control point.\n * @param {Cartesian3} options.lastTangent The incoming tangent of the last control point.\n * @returns {HermiteSpline|LinearSpline} A hermite spline, or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points, times, firstTangent and lastTangent are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} firstTangent and lastTangent must be of the same type as points.\n *\n * @example\n * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.\n * const spline = Cesium.HermiteSpline.createClampedCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),\n *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)\n * });\n */\nHermiteSpline.createClampedCubic = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const times = options.times;\n  const points = options.points;\n  const firstTangent = options.firstTangent;\n  const lastTangent = options.lastTangent;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(points) ||\n    !defined(times) ||\n    !defined(firstTangent) ||\n    !defined(lastTangent)\n  ) {\n    throw new DeveloperError(\n      \"points, times, firstTangent and lastTangent are required.\"\n    );\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  const PointType = Spline.getPointType(points[0]);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    PointType !== Spline.getPointType(firstTangent) ||\n    PointType !== Spline.getPointType(lastTangent)\n  ) {\n    throw new DeveloperError(\n      \"firstTangent and lastTangent must be of the same type as points.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (points.length < 3) {\n    return new LinearSpline({\n      points: points,\n      times: times,\n    });\n  }\n\n  const tangents = generateClamped(points, firstTangent, lastTangent);\n  const outTangents = tangents.slice(0, tangents.length - 1);\n  const inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n//prettier-ignore\nHermiteSpline.hermiteCoefficientMatrix = new Matrix4(\n  2.0, -3.0, 0.0, 1.0,\n  -2.0, 3.0, 0.0, 0.0,\n  1.0, -2.0, 1.0, 0.0,\n  1.0, -1.0, 0.0, 0.0\n);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\nconst scratchTimeVec = new Cartesian4();\nconst scratchTemp = new Cartesian3();\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nHermiteSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nHermiteSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.evaluate = function (time, result) {\n  const points = this.points;\n  const times = this.times;\n  const inTangents = this.inTangents;\n  const outTangents = this.outTangents;\n\n  this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);\n  const i = this._lastTimeIndex;\n\n  const timesDelta = times[i + 1] - times[i];\n  const u = (time - times[i]) / timesDelta;\n\n  const timeVec = scratchTimeVec;\n  timeVec.z = u;\n  timeVec.y = u * u;\n  timeVec.x = timeVec.y * u;\n  timeVec.w = 1.0;\n\n  // Coefficients are returned in the following order:\n  // start, end, out-tangent, in-tangent\n  const coefs = Matrix4.multiplyByVector(\n    HermiteSpline.hermiteCoefficientMatrix,\n    timeVec,\n    timeVec\n  );\n\n  // Multiply the out-tangent and in-tangent values by the time delta.\n  coefs.z *= timesDelta;\n  coefs.w *= timesDelta;\n\n  const PointType = this._pointType;\n\n  if (PointType === Number) {\n    return (\n      points[i] * coefs.x +\n      points[i + 1] * coefs.y +\n      outTangents[i] * coefs.z +\n      inTangents[i] * coefs.w\n    );\n  }\n\n  if (!defined(result)) {\n    result = new PointType();\n  }\n\n  result = PointType.multiplyByScalar(points[i], coefs.x, result);\n  PointType.multiplyByScalar(points[i + 1], coefs.y, scratchTemp);\n  PointType.add(result, scratchTemp, result);\n  PointType.multiplyByScalar(outTangents[i], coefs.z, scratchTemp);\n  PointType.add(result, scratchTemp, result);\n  PointType.multiplyByScalar(inTangents[i], coefs.w, scratchTemp);\n  return PointType.add(result, scratchTemp, result);\n};\nexport default HermiteSpline;\n","import Check from \"./Check.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Hilbert Order helper functions.\n *\n * @namespace HilbertOrder\n */\nconst HilbertOrder = {};\n\n/**\n * Computes the Hilbert index at the given level from 2D coordinates.\n *\n * @param {Number} level The level of the curve\n * @param {Number} x The X coordinate\n * @param {Number} y The Y coordinate\n * @returns {Number} The Hilbert index.\n * @private\n */\nHilbertOrder.encode2D = function (level, x, y) {\n  const n = Math.pow(2, level);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (level < 1) {\n    throw new DeveloperError(\"Hilbert level cannot be less than 1.\");\n  }\n  if (x < 0 || x >= n || y < 0 || y >= n) {\n    throw new DeveloperError(\"Invalid coordinates for given level.\");\n  }\n  //>>includeEnd('debug');\n\n  const p = {\n    x: x,\n    y: y,\n  };\n  let rx,\n    ry,\n    s,\n    // eslint-disable-next-line no-undef\n    index = BigInt(0);\n\n  for (s = n / 2; s > 0; s /= 2) {\n    rx = (p.x & s) > 0 ? 1 : 0;\n    ry = (p.y & s) > 0 ? 1 : 0;\n    // eslint-disable-next-line no-undef\n    index += BigInt(((3 * rx) ^ ry) * s * s);\n    rotate(n, p, rx, ry);\n  }\n\n  return index;\n};\n\n/**\n * Computes the 2D coordinates from the Hilbert index at the given level.\n *\n * @param {Number} level The level of the curve\n * @param {BigInt} index The Hilbert index\n * @returns {Number[]} An array containing the 2D coordinates ([x, y]) corresponding to the Morton index.\n * @private\n */\nHilbertOrder.decode2D = function (level, index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.bigint(\"index\", index);\n  if (level < 1) {\n    throw new DeveloperError(\"Hilbert level cannot be less than 1.\");\n  }\n  // eslint-disable-next-line no-undef\n  if (index < BigInt(0) || index >= BigInt(Math.pow(4, level))) {\n    throw new DeveloperError(\n      \"Hilbert index exceeds valid maximum for given level.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const n = Math.pow(2, level);\n  const p = {\n    x: 0,\n    y: 0,\n  };\n  let rx, ry, s, t;\n\n  for (s = 1, t = index; s < n; s *= 2) {\n    // eslint-disable-next-line no-undef\n    rx = 1 & Number(t / BigInt(2));\n    // eslint-disable-next-line no-undef\n    ry = 1 & Number(t ^ BigInt(rx));\n    rotate(s, p, rx, ry);\n    p.x += s * rx;\n    p.y += s * ry;\n    // eslint-disable-next-line no-undef\n    t /= BigInt(4);\n  }\n\n  return [p.x, p.y];\n};\n\n/**\n * @private\n */\nfunction rotate(n, p, rx, ry) {\n  if (ry !== 0) {\n    return;\n  }\n\n  if (rx === 1) {\n    p.x = n - 1 - p.x;\n    p.y = n - 1 - p.y;\n  }\n\n  const t = p.x;\n  p.x = p.y;\n  p.y = t;\n}\n\nexport default HilbertOrder;\n","import defined from \"./defined.js\";\nimport IauOrientationParameters from \"./IauOrientationParameters.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport TimeConstants from \"./TimeConstants.js\";\n\n/**\n * This is a collection of the orientation information available for central bodies.\n * The data comes from the Report of the IAU/IAG Working Group on Cartographic\n * Coordinates and Rotational Elements: 2000.\n *\n * @namespace Iau2000Orientation\n *\n * @private\n */\nconst Iau2000Orientation = {};\n\nconst TdtMinusTai = 32.184;\nconst J2000d = 2451545.0;\n\nconst c1 = -0.0529921;\nconst c2 = -0.1059842;\nconst c3 = 13.0120009;\nconst c4 = 13.3407154;\nconst c5 = 0.9856003;\nconst c6 = 26.4057084;\nconst c7 = 13.064993;\nconst c8 = 0.3287146;\nconst c9 = 1.7484877;\nconst c10 = -0.1589763;\nconst c11 = 0.0036096;\nconst c12 = 0.1643573;\nconst c13 = 12.9590088;\nlet dateTT = new JulianDate();\n\n/**\n * Compute the orientation parameters for the Moon.\n *\n * @param {JulianDate} [date=JulianDate.now()] The date to evaluate the parameters.\n * @param {IauOrientationParameters} [result] The object onto which to store the result.\n * @returns {IauOrientationParameters} The modified result parameter or a new instance representing the orientation of the Earth's Moon.\n * @private\n */\nIau2000Orientation.ComputeMoon = function (date, result) {\n  if (!defined(date)) {\n    date = JulianDate.now();\n  }\n\n  dateTT = JulianDate.addSeconds(date, TdtMinusTai, dateTT);\n  const d = JulianDate.totalDays(dateTT) - J2000d;\n  const T = d / TimeConstants.DAYS_PER_JULIAN_CENTURY;\n\n  const E1 = (125.045 + c1 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E2 = (250.089 + c2 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E3 = (260.008 + c3 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E4 = (176.625 + c4 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E5 = (357.529 + c5 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E6 = (311.589 + c6 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E7 = (134.963 + c7 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E8 = (276.617 + c8 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E9 = (34.226 + c9 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E10 = (15.134 + c10 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E11 = (119.743 + c11 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E12 = (239.961 + c12 * d) * CesiumMath.RADIANS_PER_DEGREE;\n  const E13 = (25.053 + c13 * d) * CesiumMath.RADIANS_PER_DEGREE;\n\n  const sinE1 = Math.sin(E1);\n  const sinE2 = Math.sin(E2);\n  const sinE3 = Math.sin(E3);\n  const sinE4 = Math.sin(E4);\n  const sinE5 = Math.sin(E5);\n  const sinE6 = Math.sin(E6);\n  const sinE7 = Math.sin(E7);\n  const sinE8 = Math.sin(E8);\n  const sinE9 = Math.sin(E9);\n  const sinE10 = Math.sin(E10);\n  const sinE11 = Math.sin(E11);\n  const sinE12 = Math.sin(E12);\n  const sinE13 = Math.sin(E13);\n\n  const cosE1 = Math.cos(E1);\n  const cosE2 = Math.cos(E2);\n  const cosE3 = Math.cos(E3);\n  const cosE4 = Math.cos(E4);\n  const cosE5 = Math.cos(E5);\n  const cosE6 = Math.cos(E6);\n  const cosE7 = Math.cos(E7);\n  const cosE8 = Math.cos(E8);\n  const cosE9 = Math.cos(E9);\n  const cosE10 = Math.cos(E10);\n  const cosE11 = Math.cos(E11);\n  const cosE12 = Math.cos(E12);\n  const cosE13 = Math.cos(E13);\n\n  const rightAscension =\n    (269.9949 +\n      0.0031 * T -\n      3.8787 * sinE1 -\n      0.1204 * sinE2 +\n      0.07 * sinE3 -\n      0.0172 * sinE4 +\n      0.0072 * sinE6 -\n      0.0052 * sinE10 +\n      0.0043 * sinE13) *\n    CesiumMath.RADIANS_PER_DEGREE;\n  const declination =\n    (66.5392 +\n      0.013 * T +\n      1.5419 * cosE1 +\n      0.0239 * cosE2 -\n      0.0278 * cosE3 +\n      0.0068 * cosE4 -\n      0.0029 * cosE6 +\n      0.0009 * cosE7 +\n      0.0008 * cosE10 -\n      0.0009 * cosE13) *\n    CesiumMath.RADIANS_PER_DEGREE;\n  const rotation =\n    (38.3213 +\n      13.17635815 * d -\n      1.4e-12 * d * d +\n      3.561 * sinE1 +\n      0.1208 * sinE2 -\n      0.0642 * sinE3 +\n      0.0158 * sinE4 +\n      0.0252 * sinE5 -\n      0.0066 * sinE6 -\n      0.0047 * sinE7 -\n      0.0046 * sinE8 +\n      0.0028 * sinE9 +\n      0.0052 * sinE10 +\n      0.004 * sinE11 +\n      0.0019 * sinE12 -\n      0.0044 * sinE13) *\n    CesiumMath.RADIANS_PER_DEGREE;\n\n  const rotationRate =\n    ((13.17635815 -\n      1.4e-12 * (2.0 * d) +\n      3.561 * cosE1 * c1 +\n      0.1208 * cosE2 * c2 -\n      0.0642 * cosE3 * c3 +\n      0.0158 * cosE4 * c4 +\n      0.0252 * cosE5 * c5 -\n      0.0066 * cosE6 * c6 -\n      0.0047 * cosE7 * c7 -\n      0.0046 * cosE8 * c8 +\n      0.0028 * cosE9 * c9 +\n      0.0052 * cosE10 * c10 +\n      0.004 * cosE11 * c11 +\n      0.0019 * cosE12 * c12 -\n      0.0044 * cosE13 * c13) /\n      86400.0) *\n    CesiumMath.RADIANS_PER_DEGREE;\n\n  if (!defined(result)) {\n    result = new IauOrientationParameters();\n  }\n\n  result.rightAscension = rightAscension;\n  result.declination = declination;\n  result.rotation = rotation;\n  result.rotationRate = rotationRate;\n\n  return result;\n};\nexport default Iau2000Orientation;\n","import buildModuleUrl from \"./buildModuleUrl.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defer from \"./defer.js\";\nimport defined from \"./defined.js\";\nimport Iau2006XysSample from \"./Iau2006XysSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport Resource from \"./Resource.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\n/**\n * A set of IAU2006 XYS data that is used to evaluate the transformation between the International\n * Celestial Reference Frame (ICRF) and the International Terrestrial Reference Frame (ITRF).\n *\n * @alias Iau2006XysData\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Resource|String} [options.xysFileUrlTemplate='Assets/IAU2006_XYS/IAU2006_XYS_{0}.json'] A template URL for obtaining the XYS data.  In the template,\n *                 `{0}` will be replaced with the file index.\n * @param {Number} [options.interpolationOrder=9] The order of interpolation to perform on the XYS data.\n * @param {Number} [options.sampleZeroJulianEphemerisDate=2442396.5] The Julian ephemeris date (JED) of the\n *                 first XYS sample.\n * @param {Number} [options.stepSizeDays=1.0] The step size, in days, between successive XYS samples.\n * @param {Number} [options.samplesPerXysFile=1000] The number of samples in each XYS file.\n * @param {Number} [options.totalSamples=27426] The total number of samples in all XYS files.\n *\n * @private\n */\nfunction Iau2006XysData(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._xysFileUrlTemplate = Resource.createIfNeeded(\n    options.xysFileUrlTemplate\n  );\n  this._interpolationOrder = defaultValue(options.interpolationOrder, 9);\n  this._sampleZeroJulianEphemerisDate = defaultValue(\n    options.sampleZeroJulianEphemerisDate,\n    2442396.5\n  );\n  this._sampleZeroDateTT = new JulianDate(\n    this._sampleZeroJulianEphemerisDate,\n    0.0,\n    TimeStandard.TAI\n  );\n  this._stepSizeDays = defaultValue(options.stepSizeDays, 1.0);\n  this._samplesPerXysFile = defaultValue(options.samplesPerXysFile, 1000);\n  this._totalSamples = defaultValue(options.totalSamples, 27426);\n  this._samples = new Array(this._totalSamples * 3);\n  this._chunkDownloadsInProgress = [];\n\n  const order = this._interpolationOrder;\n\n  // Compute denominators and X values for interpolation.\n  const denom = (this._denominators = new Array(order + 1));\n  const xTable = (this._xTable = new Array(order + 1));\n\n  const stepN = Math.pow(this._stepSizeDays, order);\n\n  for (let i = 0; i <= order; ++i) {\n    denom[i] = stepN;\n    xTable[i] = i * this._stepSizeDays;\n\n    for (let j = 0; j <= order; ++j) {\n      if (j !== i) {\n        denom[i] *= i - j;\n      }\n    }\n\n    denom[i] = 1.0 / denom[i];\n  }\n\n  // Allocate scratch arrays for interpolation.\n  this._work = new Array(order + 1);\n  this._coef = new Array(order + 1);\n}\n\nconst julianDateScratch = new JulianDate(0, 0.0, TimeStandard.TAI);\n\nfunction getDaysSinceEpoch(xys, dayTT, secondTT) {\n  const dateTT = julianDateScratch;\n  dateTT.dayNumber = dayTT;\n  dateTT.secondsOfDay = secondTT;\n  return JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);\n}\n\n/**\n * Preloads XYS data for a specified date range.\n *\n * @param {Number} startDayTT The Julian day number of the beginning of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} startSecondTT The seconds past noon of the beginning of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} stopDayTT The Julian day number of the end of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} stopSecondTT The seconds past noon of the end of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @returns {Promise<void>} A promise that, when resolved, indicates that the requested interval has been\n *                    preloaded.\n */\nIau2006XysData.prototype.preload = function (\n  startDayTT,\n  startSecondTT,\n  stopDayTT,\n  stopSecondTT\n) {\n  const startDaysSinceEpoch = getDaysSinceEpoch(\n    this,\n    startDayTT,\n    startSecondTT\n  );\n  const stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);\n\n  let startIndex =\n    (startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |\n    0;\n  if (startIndex < 0) {\n    startIndex = 0;\n  }\n\n  let stopIndex =\n    (stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |\n    (0 + this._interpolationOrder);\n  if (stopIndex >= this._totalSamples) {\n    stopIndex = this._totalSamples - 1;\n  }\n\n  const startChunk = (startIndex / this._samplesPerXysFile) | 0;\n  const stopChunk = (stopIndex / this._samplesPerXysFile) | 0;\n\n  const promises = [];\n  for (let i = startChunk; i <= stopChunk; ++i) {\n    promises.push(requestXysChunk(this, i));\n  }\n\n  return Promise.all(promises);\n};\n\n/**\n * Computes the XYS values for a given date by interpolating.  If the required data is not yet downloaded,\n * this method will return undefined.\n *\n * @param {Number} dayTT The Julian day number for which to compute the XYS value, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} secondTT The seconds past noon of the date for which to compute the XYS value, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Iau2006XysSample} [result] The instance to which to copy the interpolated result.  If this parameter\n *                           is undefined, a new instance is allocated and returned.\n * @returns {Iau2006XysSample} The interpolated XYS values, or undefined if the required data for this\n *                             computation has not yet been downloaded.\n *\n * @see Iau2006XysData#preload\n */\nIau2006XysData.prototype.computeXysRadians = function (\n  dayTT,\n  secondTT,\n  result\n) {\n  const daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);\n  if (daysSinceEpoch < 0.0) {\n    // Can't evaluate prior to the epoch of the data.\n    return undefined;\n  }\n\n  const centerIndex = (daysSinceEpoch / this._stepSizeDays) | 0;\n  if (centerIndex >= this._totalSamples) {\n    // Can't evaluate after the last sample in the data.\n    return undefined;\n  }\n\n  const degree = this._interpolationOrder;\n\n  let firstIndex = centerIndex - ((degree / 2) | 0);\n  if (firstIndex < 0) {\n    firstIndex = 0;\n  }\n  let lastIndex = firstIndex + degree;\n  if (lastIndex >= this._totalSamples) {\n    lastIndex = this._totalSamples - 1;\n    firstIndex = lastIndex - degree;\n    if (firstIndex < 0) {\n      firstIndex = 0;\n    }\n  }\n\n  // Are all the samples we need present?\n  // We can assume so if the first and last are present\n  let isDataMissing = false;\n  const samples = this._samples;\n  if (!defined(samples[firstIndex * 3])) {\n    requestXysChunk(this, (firstIndex / this._samplesPerXysFile) | 0);\n    isDataMissing = true;\n  }\n\n  if (!defined(samples[lastIndex * 3])) {\n    requestXysChunk(this, (lastIndex / this._samplesPerXysFile) | 0);\n    isDataMissing = true;\n  }\n\n  if (isDataMissing) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Iau2006XysSample(0.0, 0.0, 0.0);\n  } else {\n    result.x = 0.0;\n    result.y = 0.0;\n    result.s = 0.0;\n  }\n\n  const x = daysSinceEpoch - firstIndex * this._stepSizeDays;\n\n  const work = this._work;\n  const denom = this._denominators;\n  const coef = this._coef;\n  const xTable = this._xTable;\n\n  let i, j;\n  for (i = 0; i <= degree; ++i) {\n    work[i] = x - xTable[i];\n  }\n\n  for (i = 0; i <= degree; ++i) {\n    coef[i] = 1.0;\n\n    for (j = 0; j <= degree; ++j) {\n      if (j !== i) {\n        coef[i] *= work[j];\n      }\n    }\n\n    coef[i] *= denom[i];\n\n    let sampleIndex = (firstIndex + i) * 3;\n    result.x += coef[i] * samples[sampleIndex++];\n    result.y += coef[i] * samples[sampleIndex++];\n    result.s += coef[i] * samples[sampleIndex];\n  }\n\n  return result;\n};\n\nfunction requestXysChunk(xysData, chunkIndex) {\n  if (xysData._chunkDownloadsInProgress[chunkIndex]) {\n    // Chunk has already been requested.\n    return xysData._chunkDownloadsInProgress[chunkIndex];\n  }\n\n  const deferred = defer();\n\n  xysData._chunkDownloadsInProgress[chunkIndex] = deferred;\n\n  let chunkUrl;\n  const xysFileUrlTemplate = xysData._xysFileUrlTemplate;\n  if (defined(xysFileUrlTemplate)) {\n    chunkUrl = xysFileUrlTemplate.getDerivedResource({\n      templateValues: {\n        0: chunkIndex,\n      },\n    });\n  } else {\n    chunkUrl = new Resource({\n      url: buildModuleUrl(`Assets/IAU2006_XYS/IAU2006_XYS_${chunkIndex}.json`),\n    });\n  }\n\n  chunkUrl.fetchJson().then(function (chunk) {\n    xysData._chunkDownloadsInProgress[chunkIndex] = false;\n\n    const samples = xysData._samples;\n    const newSamples = chunk.samples;\n    const startIndex = chunkIndex * xysData._samplesPerXysFile * 3;\n\n    for (let i = 0, len = newSamples.length; i < len; ++i) {\n      samples[startIndex + i] = newSamples[i];\n    }\n\n    deferred.resolve();\n  });\n\n  return deferred.promise;\n}\nexport default Iau2006XysData;\n","/**\n * An IAU 2006 XYS value sampled at a particular time.\n *\n * @alias Iau2006XysSample\n * @constructor\n *\n * @param {Number} x The X value.\n * @param {Number} y The Y value.\n * @param {Number} s The S value.\n *\n * @private\n */\nfunction Iau2006XysSample(x, y, s) {\n  /**\n   * The X value.\n   * @type {Number}\n   */\n  this.x = x;\n\n  /**\n   * The Y value.\n   * @type {Number}\n   */\n  this.y = y;\n\n  /**\n   * The S value.\n   * @type {Number}\n   */\n  this.s = s;\n}\nexport default Iau2006XysSample;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport defined from \"./defined.js\";\nimport Iau2000Orientation from \"./Iau2000Orientation.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * The Axes representing the orientation of a Globe as represented by the data\n * from the IAU/IAG Working Group reports on rotational elements.\n * @alias IauOrientationAxes\n * @constructor\n *\n * @param {IauOrientationAxes.ComputeFunction} [computeFunction] The function that computes the {@link IauOrientationParameters} given a {@link JulianDate}.\n *\n * @see Iau2000Orientation\n *\n * @private\n */\nfunction IauOrientationAxes(computeFunction) {\n  if (!defined(computeFunction) || typeof computeFunction !== \"function\") {\n    computeFunction = Iau2000Orientation.ComputeMoon;\n  }\n\n  this._computeFunction = computeFunction;\n}\n\nconst xAxisScratch = new Cartesian3();\nconst yAxisScratch = new Cartesian3();\nconst zAxisScratch = new Cartesian3();\n\nfunction computeRotationMatrix(alpha, delta, result) {\n  const xAxis = xAxisScratch;\n  xAxis.x = Math.cos(alpha + CesiumMath.PI_OVER_TWO);\n  xAxis.y = Math.sin(alpha + CesiumMath.PI_OVER_TWO);\n  xAxis.z = 0.0;\n\n  const cosDec = Math.cos(delta);\n\n  const zAxis = zAxisScratch;\n  zAxis.x = cosDec * Math.cos(alpha);\n  zAxis.y = cosDec * Math.sin(alpha);\n  zAxis.z = Math.sin(delta);\n\n  const yAxis = Cartesian3.cross(zAxis, xAxis, yAxisScratch);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = xAxis.x;\n  result[1] = yAxis.x;\n  result[2] = zAxis.x;\n  result[3] = xAxis.y;\n  result[4] = yAxis.y;\n  result[5] = zAxis.y;\n  result[6] = xAxis.z;\n  result[7] = yAxis.z;\n  result[8] = zAxis.z;\n\n  return result;\n}\n\nconst rotMtxScratch = new Matrix3();\nconst quatScratch = new Quaternion();\n\n/**\n * Computes a rotation from ICRF to a Globe's Fixed axes.\n *\n * @param {JulianDate} date The date to evaluate the matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new instance of the rotation from ICRF to Fixed.\n */\nIauOrientationAxes.prototype.evaluate = function (date, result) {\n  if (!defined(date)) {\n    date = JulianDate.now();\n  }\n\n  const alphaDeltaW = this._computeFunction(date);\n  const precMtx = computeRotationMatrix(\n    alphaDeltaW.rightAscension,\n    alphaDeltaW.declination,\n    result\n  );\n\n  const rot = CesiumMath.zeroToTwoPi(alphaDeltaW.rotation);\n  const quat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, rot, quatScratch);\n  const rotMtx = Matrix3.fromQuaternion(\n    Quaternion.conjugate(quat, quat),\n    rotMtxScratch\n  );\n\n  const cbi2cbf = Matrix3.multiply(rotMtx, precMtx, precMtx);\n  return cbi2cbf;\n};\n\n/**\n * A function that computes the {@link IauOrientationParameters} for a {@link JulianDate}.\n * @callback IauOrientationAxes.ComputeFunction\n * @param {JulianDate} date The date to evaluate the parameters.\n * @returns {IauOrientationParameters} The orientation parameters.\n * @private\n */\nexport default IauOrientationAxes;\n","/**\n * A structure containing the orientation data computed at a particular time. The data\n * represents the direction of the pole of rotation and the rotation about that pole.\n * <p>\n * These parameters correspond to the parameters in the Report from the IAU/IAG Working Group\n * except that they are expressed in radians.\n * </p>\n *\n * @namespace IauOrientationParameters\n *\n * @private\n */\nfunction IauOrientationParameters(\n  rightAscension,\n  declination,\n  rotation,\n  rotationRate\n) {\n  /**\n   * The right ascension of the north pole of the body with respect to\n   * the International Celestial Reference Frame, in radians.\n   * @type {Number}\n   *\n   * @private\n   */\n  this.rightAscension = rightAscension;\n\n  /**\n   * The declination of the north pole of the body with respect to\n   * the International Celestial Reference Frame, in radians.\n   * @type {Number}\n   *\n   * @private\n   */\n  this.declination = declination;\n\n  /**\n   * The rotation about the north pole used to align a set of axes with\n   * the meridian defined by the IAU report, in radians.\n   * @type {Number}\n   *\n   * @private\n   */\n  this.rotation = rotation;\n\n  /**\n   * The instantaneous rotation rate about the north pole, in radians per second.\n   * @type {Number}\n   *\n   * @private\n   */\n  this.rotationRate = rotationRate;\n}\nexport default IauOrientationParameters;\n","import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * Constants for WebGL index datatypes.  These corresponds to the\n * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n *\n * @enum {Number}\n */\nconst IndexDatatype = {\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_BYTE: WebGLConstants.UNSIGNED_BYTE,\n\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_SHORT: WebGLConstants.UNSIGNED_SHORT,\n\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_INT: WebGLConstants.UNSIGNED_INT,\n};\n\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n * @returns {Number} The size in bytes.\n *\n * @example\n * // Returns 2\n * const size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n */\nIndexDatatype.getSizeInBytes = function (indexDatatype) {\n  switch (indexDatatype) {\n    case IndexDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"indexDatatype is required and must be a valid IndexDatatype constant.\"\n  );\n  //>>includeEnd('debug');\n};\n\n/**\n * Gets the datatype with a given size in bytes.\n *\n * @param {Number} sizeInBytes The size of a single index in bytes.\n * @returns {IndexDatatype} The index datatype with the given size.\n */\nIndexDatatype.fromSizeInBytes = function (sizeInBytes) {\n  switch (sizeInBytes) {\n    case 2:\n      return IndexDatatype.UNSIGNED_SHORT;\n    case 4:\n      return IndexDatatype.UNSIGNED_INT;\n    case 1:\n      return IndexDatatype.UNSIGNED_BYTE;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\n        \"Size in bytes cannot be mapped to an IndexDatatype\"\n      );\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to validate.\n * @returns {Boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');\n * }\n */\nIndexDatatype.validate = function (indexDatatype) {\n  return (\n    defined(indexDatatype) &&\n    (indexDatatype === IndexDatatype.UNSIGNED_BYTE ||\n      indexDatatype === IndexDatatype.UNSIGNED_SHORT ||\n      indexDatatype === IndexDatatype.UNSIGNED_INT)\n  );\n};\n\n/**\n * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {Number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n *\n * @example\n * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n */\nIndexDatatype.createTypedArray = function (\n  numberOfVertices,\n  indicesLengthOrArray\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(indicesLengthOrArray);\n  }\n\n  return new Uint16Array(indicesLengthOrArray);\n};\n\n/**\n * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n * @param {Number} byteOffset Passed through to the typed array constructor.\n * @param {Number} length Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n *\n */\nIndexDatatype.createTypedArrayFromArrayBuffer = function (\n  numberOfVertices,\n  sourceArray,\n  byteOffset,\n  length\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(numberOfVertices)) {\n    throw new DeveloperError(\"numberOfVertices is required.\");\n  }\n  if (!defined(sourceArray)) {\n    throw new DeveloperError(\"sourceArray is required.\");\n  }\n  if (!defined(byteOffset)) {\n    throw new DeveloperError(\"byteOffset is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(sourceArray, byteOffset, length);\n  }\n\n  return new Uint16Array(sourceArray, byteOffset, length);\n};\n\n/**\n * Gets the {@link IndexDatatype} for the provided TypedArray instance.\n *\n * @param {Uint8Array|Uint16Array|Uint32Array} array The typed array.\n * @returns {IndexDatatype} The IndexDatatype for the provided array, or undefined if the array is not a Uint8Array, Uint16Array, or Uint32Array.\n */\nIndexDatatype.fromTypedArray = function (array) {\n  if (array instanceof Uint8Array) {\n    return IndexDatatype.UNSIGNED_BYTE;\n  }\n  if (array instanceof Uint16Array) {\n    return IndexDatatype.UNSIGNED_SHORT;\n  }\n  if (array instanceof Uint32Array) {\n    return IndexDatatype.UNSIGNED_INT;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"array must be a Uint8Array, Uint16Array, or Uint32Array.\"\n  );\n  //>>includeEnd('debug');\n};\n\nexport default Object.freeze(IndexDatatype);\n","import DeveloperError from \"./DeveloperError.js\";\n\n/**\n * The interface for interpolation algorithms.\n *\n * @interface InterpolationAlgorithm\n *\n * @see LagrangePolynomialApproximation\n * @see LinearApproximation\n * @see HermitePolynomialApproximation\n */\nconst InterpolationAlgorithm = {};\n\n/**\n * Gets the name of this interpolation algorithm.\n * @type {String}\n */\nInterpolationAlgorithm.type = undefined;\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n * @function\n *\n * @param {Number} degree The desired degree of interpolation.\n * @returns {Number} The number of required data points needed for the desired degree of interpolation.\n */\nInterpolationAlgorithm.getRequiredDataPoints =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Performs zero order interpolation.\n * @function\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number[]} [result] An existing array into which to store the result.\n *\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nInterpolationAlgorithm.interpolateOrderZero =\n  DeveloperError.throwInstantiationError;\n\n/**\n * Performs higher order interpolation.  Not all interpolators need to support high-order interpolation,\n * if this function remains undefined on implementing objects, interpolateOrderZero will be used instead.\n * @function\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number} inputOrder The number of derivatives supplied for input.\n * @param {Number} outputOrder The number of derivatives desired for output.\n * @param {Number[]} [result] An existing array into which to store the result.\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nInterpolationAlgorithm.interpolate = DeveloperError.throwInstantiationError;\nexport default InterpolationAlgorithm;\n","/**\n * An enum describing the type of interpolation used in a glTF animation.\n *\n * @enum {Number}\n *\n * @private\n */\nconst InterpolationType = {\n  STEP: 0,\n  LINEAR: 1,\n  CUBICSPLINE: 2,\n};\n\nexport default Object.freeze(InterpolationType);\n","/**\n * This enumerated type is used in determining where, relative to the frustum, an\n * object is located. The object can either be fully contained within the frustum (INSIDE),\n * partially inside the frustum and partially outside (INTERSECTING), or somewhere entirely\n * outside of the frustum's 6 planes (OUTSIDE).\n *\n * @enum {Number}\n */\nconst Intersect = {\n  /**\n   * Represents that an object is not contained within the frustum.\n   *\n   * @type {Number}\n   * @constant\n   */\n  OUTSIDE: -1,\n\n  /**\n   * Represents that an object intersects one of the frustum's planes.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INTERSECTING: 0,\n\n  /**\n   * Represents that an object is fully within the frustum.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INSIDE: 1,\n};\nexport default Object.freeze(Intersect);\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\nimport QuarticRealPolynomial from \"./QuarticRealPolynomial.js\";\nimport Ray from \"./Ray.js\";\n\n/**\n * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n *\n * @namespace IntersectionTests\n */\nconst IntersectionTests = {};\n\n/**\n * Computes the intersection of a ray and a plane.\n *\n * @param {Ray} ray The ray.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayPlane = function (ray, plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n  const normal = plane.normal;\n  const denominator = Cartesian3.dot(normal, direction);\n\n  if (Math.abs(denominator) < CesiumMath.EPSILON15) {\n    // Ray is parallel to plane.  The ray may be in the polygon's plane.\n    return undefined;\n  }\n\n  const t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;\n\n  if (t < 0) {\n    return undefined;\n  }\n\n  result = Cartesian3.multiplyByScalar(direction, t, result);\n  return Cartesian3.add(origin, result, result);\n};\n\nconst scratchEdge0 = new Cartesian3();\nconst scratchEdge1 = new Cartesian3();\nconst scratchPVec = new Cartesian3();\nconst scratchTVec = new Cartesian3();\nconst scratchQVec = new Cartesian3();\n\n/**\n * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @returns {Number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\n */\nIntersectionTests.rayTriangleParametric = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = defaultValue(cullBackFaces, false);\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n\n  const edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);\n  const edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);\n\n  const p = Cartesian3.cross(direction, edge1, scratchPVec);\n  const det = Cartesian3.dot(edge0, p);\n\n  let tvec;\n  let q;\n\n  let u;\n  let v;\n  let t;\n\n  if (cullBackFaces) {\n    if (det < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p);\n    if (u < 0.0 || u > det) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q);\n    if (v < 0.0 || u + v > det) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) / det;\n  } else {\n    if (Math.abs(det) < CesiumMath.EPSILON6) {\n      return undefined;\n    }\n    const invDet = 1.0 / det;\n\n    tvec = Cartesian3.subtract(origin, p0, scratchTVec);\n    u = Cartesian3.dot(tvec, p) * invDet;\n    if (u < 0.0 || u > 1.0) {\n      return undefined;\n    }\n\n    q = Cartesian3.cross(tvec, edge0, scratchQVec);\n\n    v = Cartesian3.dot(direction, q) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n      return undefined;\n    }\n\n    t = Cartesian3.dot(edge1, q) * invDet;\n  }\n\n  return t;\n};\n\n/**\n * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayTriangle = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  const t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!defined(t) || t < 0.0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nconst scratchLineSegmentTriangleRay = new Ray();\n\n/**\n * Computes the intersection of a line segment and a triangle.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} v0 The an end point of the line segment.\n * @param {Cartesian3} v1 The other end point of the line segment.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.lineSegmentTriangle = function (\n  v0,\n  v1,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(v0)) {\n    throw new DeveloperError(\"v0 is required.\");\n  }\n  if (!defined(v1)) {\n    throw new DeveloperError(\"v1 is required.\");\n  }\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(p2)) {\n    throw new DeveloperError(\"p2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentTriangleRay;\n  Cartesian3.clone(v0, ray.origin);\n  Cartesian3.subtract(v1, v0, ray.direction);\n  Cartesian3.normalize(ray.direction, ray.direction);\n\n  const t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!defined(t) || t < 0.0 || t > Cartesian3.distance(v0, v1)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  Cartesian3.multiplyByScalar(ray.direction, t, result);\n  return Cartesian3.add(ray.origin, result, result);\n};\n\nfunction solveQuadratic(a, b, c, result) {\n  const det = b * b - 4.0 * a * c;\n  if (det < 0.0) {\n    return undefined;\n  } else if (det > 0.0) {\n    const denom = 1.0 / (2.0 * a);\n    const disc = Math.sqrt(det);\n    const root0 = (-b + disc) * denom;\n    const root1 = (-b - disc) * denom;\n\n    if (root0 < root1) {\n      result.root0 = root0;\n      result.root1 = root1;\n    } else {\n      result.root0 = root1;\n      result.root1 = root0;\n    }\n\n    return result;\n  }\n\n  const root = -b / (2.0 * a);\n  if (root === 0.0) {\n    return undefined;\n  }\n\n  result.root0 = result.root1 = root;\n  return result;\n}\n\nconst raySphereRoots = {\n  root0: 0.0,\n  root1: 0.0,\n};\n\nfunction raySphere(ray, sphere, result) {\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  const origin = ray.origin;\n  const direction = ray.direction;\n\n  const center = sphere.center;\n  const radiusSquared = sphere.radius * sphere.radius;\n\n  const diff = Cartesian3.subtract(origin, center, scratchPVec);\n\n  const a = Cartesian3.dot(direction, direction);\n  const b = 2.0 * Cartesian3.dot(direction, diff);\n  const c = Cartesian3.magnitudeSquared(diff) - radiusSquared;\n\n  const roots = solveQuadratic(a, b, c, raySphereRoots);\n  if (!defined(roots)) {\n    return undefined;\n  }\n\n  result.start = roots.root0;\n  result.stop = roots.root1;\n  return result;\n}\n\n/**\n * Computes the intersection points of a ray with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.raySphere = function (ray, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  return result;\n};\n\nconst scratchLineSegmentRay = new Ray();\n\n/**\n * Computes the intersection points of a line segment with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} p0 An end point of the line segment.\n * @param {Cartesian3} p1 The other end point of the line segment.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0)) {\n    throw new DeveloperError(\"p0 is required.\");\n  }\n  if (!defined(p1)) {\n    throw new DeveloperError(\"p1 is required.\");\n  }\n  if (!defined(sphere)) {\n    throw new DeveloperError(\"sphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const ray = scratchLineSegmentRay;\n  Cartesian3.clone(p0, ray.origin);\n  const direction = Cartesian3.subtract(p1, p0, ray.direction);\n\n  const maxT = Cartesian3.magnitude(direction);\n  Cartesian3.normalize(direction, direction);\n\n  result = raySphere(ray, sphere, result);\n  if (!defined(result) || result.stop < 0.0 || result.start > maxT) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  result.stop = Math.min(result.stop, maxT);\n  return result;\n};\n\nconst scratchQ = new Cartesian3();\nconst scratchW = new Cartesian3();\n\n/**\n * Computes the intersection points of a ray with an ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.rayEllipsoid = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseRadii = ellipsoid.oneOverRadii;\n  const q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n  const w = Cartesian3.multiplyComponents(\n    inverseRadii,\n    ray.direction,\n    scratchW\n  );\n\n  const q2 = Cartesian3.magnitudeSquared(q);\n  const qw = Cartesian3.dot(q, w);\n\n  let difference, w2, product, discriminant, temp;\n\n  if (q2 > 1.0) {\n    // Outside ellipsoid.\n    if (qw >= 0.0) {\n      // Looking outward or tangent (0 intersections).\n      return undefined;\n    }\n\n    // qw < 0.0.\n    const qw2 = qw * qw;\n    difference = q2 - 1.0; // Positively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference;\n\n    if (qw2 < product) {\n      // Imaginary roots (0 intersections).\n      return undefined;\n    } else if (qw2 > product) {\n      // Distinct roots (2 intersections).\n      discriminant = qw * qw - product;\n      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n      const root0 = temp / w2;\n      const root1 = difference / temp;\n      if (root0 < root1) {\n        return new Interval(root0, root1);\n      }\n\n      return {\n        start: root1,\n        stop: root0,\n      };\n    }\n    // qw2 == product.  Repeated roots (2 intersections).\n    const root = Math.sqrt(difference / w2);\n    return new Interval(root, root);\n  } else if (q2 < 1.0) {\n    // Inside ellipsoid (2 intersections).\n    difference = q2 - 1.0; // Negatively valued.\n    w2 = Cartesian3.magnitudeSquared(w);\n    product = w2 * difference; // Negatively valued.\n\n    discriminant = qw * qw - product;\n    temp = -qw + Math.sqrt(discriminant); // Positively valued.\n    return new Interval(0.0, temp / w2);\n  }\n  // q2 == 1.0. On ellipsoid.\n  if (qw < 0.0) {\n    // Looking inward.\n    w2 = Cartesian3.magnitudeSquared(w);\n    return new Interval(0.0, -qw / w2);\n  }\n\n  // qw >= 0.0.  Looking outward or tangent.\n  return undefined;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  const difference = left + right;\n  if (\n    CesiumMath.sign(left) !== CesiumMath.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\nfunction quadraticVectorExpression(A, b, c, x, w) {\n  const xSquared = x * x;\n  const wSquared = w * w;\n\n  const l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;\n  const l1 =\n    w *\n    (x *\n      addWithCancellationCheck(\n        A[Matrix3.COLUMN1ROW0],\n        A[Matrix3.COLUMN0ROW1],\n        CesiumMath.EPSILON15\n      ) +\n      b.y);\n  const l0 =\n    A[Matrix3.COLUMN0ROW0] * xSquared +\n    A[Matrix3.COLUMN2ROW2] * wSquared +\n    x * b.x +\n    c;\n\n  const r1 =\n    wSquared *\n    addWithCancellationCheck(\n      A[Matrix3.COLUMN2ROW1],\n      A[Matrix3.COLUMN1ROW2],\n      CesiumMath.EPSILON15\n    );\n  const r0 =\n    w *\n    (x *\n      addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) +\n      b.z);\n\n  let cosines;\n  const solutions = [];\n  if (r0 === 0.0 && r1 === 0.0) {\n    cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);\n    if (cosines.length === 0) {\n      return solutions;\n    }\n\n    const cosine0 = cosines[0];\n    const sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));\n    solutions.push(new Cartesian3(x, w * cosine0, w * sine0));\n\n    if (cosines.length === 2) {\n      const cosine1 = cosines[1];\n      const sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n      solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));\n      solutions.push(new Cartesian3(x, w * cosine1, w * sine1));\n    }\n\n    return solutions;\n  }\n\n  const r0Squared = r0 * r0;\n  const r1Squared = r1 * r1;\n  const l2Squared = l2 * l2;\n  const r0r1 = r0 * r1;\n\n  const c4 = l2Squared + r1Squared;\n  const c3 = 2.0 * (l1 * l2 + r0r1);\n  const c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n  const c1 = 2.0 * (l0 * l1 - r0r1);\n  const c0 = l0 * l0 - r0Squared;\n\n  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n    return solutions;\n  }\n\n  cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);\n  const length = cosines.length;\n  if (length === 0) {\n    return solutions;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    const cosine = cosines[i];\n    const cosineSquared = cosine * cosine;\n    const sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n    const sine = Math.sqrt(sineSquared);\n\n    //const left = l2 * cosineSquared + l1 * cosine + l0;\n    let left;\n    if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l0,\n        l1 * cosine,\n        CesiumMath.EPSILON12\n      );\n    } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared,\n        l1 * cosine + l0,\n        CesiumMath.EPSILON12\n      );\n    } else {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l1 * cosine,\n        l0,\n        CesiumMath.EPSILON12\n      );\n    }\n\n    const right = addWithCancellationCheck(\n      r1 * cosine,\n      r0,\n      CesiumMath.EPSILON15\n    );\n    const product = left * right;\n\n    if (product < 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    } else if (product > 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n    } else if (sine !== 0.0) {\n      solutions.push(new Cartesian3(x, w * cosine, w * -sine));\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n      ++i;\n    } else {\n      solutions.push(new Cartesian3(x, w * cosine, w * sine));\n    }\n  }\n\n  return solutions;\n}\n\nconst firstAxisScratch = new Cartesian3();\nconst secondAxisScratch = new Cartesian3();\nconst thirdAxisScratch = new Cartesian3();\nconst referenceScratch = new Cartesian3();\nconst bCart = new Cartesian3();\nconst bScratch = new Matrix3();\nconst btScratch = new Matrix3();\nconst diScratch = new Matrix3();\nconst dScratch = new Matrix3();\nconst cScratch = new Matrix3();\nconst tempMatrix = new Matrix3();\nconst aScratch = new Matrix3();\nconst sScratch = new Cartesian3();\nconst closestScratch = new Cartesian3();\nconst surfPointScratch = new Cartographic();\n\n/**\n * Provides the point along the ray which is nearest to the ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Cartesian3} The nearest planetodetic point on the ray.\n */\nIntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required.\");\n  }\n  if (!defined(ellipsoid)) {\n    throw new DeveloperError(\"ellipsoid is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const position = ray.origin;\n  const direction = ray.direction;\n\n  if (!Cartesian3.equals(position, Cartesian3.ZERO)) {\n    const normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n    if (Cartesian3.dot(direction, normal) >= 0.0) {\n      // The location provided is the closest point in altitude\n      return position;\n    }\n  }\n\n  const intersects = defined(this.rayEllipsoid(ray, ellipsoid));\n\n  // Compute the scaled direction vector.\n  const f = ellipsoid.transformPositionToScaledSpace(\n    direction,\n    firstAxisScratch\n  );\n\n  // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n  const firstAxis = Cartesian3.normalize(f, f);\n  const reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);\n  const secondAxis = Cartesian3.normalize(\n    Cartesian3.cross(reference, firstAxis, secondAxisScratch),\n    secondAxisScratch\n  );\n  const thirdAxis = Cartesian3.normalize(\n    Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch),\n    thirdAxisScratch\n  );\n  const B = bScratch;\n  B[0] = firstAxis.x;\n  B[1] = firstAxis.y;\n  B[2] = firstAxis.z;\n  B[3] = secondAxis.x;\n  B[4] = secondAxis.y;\n  B[5] = secondAxis.z;\n  B[6] = thirdAxis.x;\n  B[7] = thirdAxis.y;\n  B[8] = thirdAxis.z;\n\n  const B_T = Matrix3.transpose(B, btScratch);\n\n  // Get the scaling matrix and its inverse.\n  const D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);\n  const D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);\n\n  const C = cScratch;\n  C[0] = 0.0;\n  C[1] = -direction.z;\n  C[2] = direction.y;\n  C[3] = direction.z;\n  C[4] = 0.0;\n  C[5] = -direction.x;\n  C[6] = -direction.y;\n  C[7] = direction.x;\n  C[8] = 0.0;\n\n  const temp = Matrix3.multiply(\n    Matrix3.multiply(B_T, D, tempMatrix),\n    C,\n    tempMatrix\n  );\n  const A = Matrix3.multiply(\n    Matrix3.multiply(temp, D_I, aScratch),\n    B,\n    aScratch\n  );\n  const b = Matrix3.multiplyByVector(temp, position, bCart);\n\n  // Solve for the solutions to the expression in standard form:\n  const solutions = quadraticVectorExpression(\n    A,\n    Cartesian3.negate(b, firstAxisScratch),\n    0.0,\n    0.0,\n    1.0\n  );\n\n  let s;\n  let altitude;\n  const length = solutions.length;\n  if (length > 0) {\n    let closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);\n    let maximumValue = Number.NEGATIVE_INFINITY;\n\n    for (let i = 0; i < length; ++i) {\n      s = Matrix3.multiplyByVector(\n        D_I,\n        Matrix3.multiplyByVector(B, solutions[i], sScratch),\n        sScratch\n      );\n      const v = Cartesian3.normalize(\n        Cartesian3.subtract(s, position, referenceScratch),\n        referenceScratch\n      );\n      const dotProduct = Cartesian3.dot(v, direction);\n\n      if (dotProduct > maximumValue) {\n        maximumValue = dotProduct;\n        closest = Cartesian3.clone(s, closest);\n      }\n    }\n\n    const surfacePoint = ellipsoid.cartesianToCartographic(\n      closest,\n      surfPointScratch\n    );\n    maximumValue = CesiumMath.clamp(maximumValue, 0.0, 1.0);\n    altitude =\n      Cartesian3.magnitude(\n        Cartesian3.subtract(closest, position, referenceScratch)\n      ) * Math.sqrt(1.0 - maximumValue * maximumValue);\n    altitude = intersects ? -altitude : altitude;\n    surfacePoint.height = altitude;\n    return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());\n  }\n\n  return undefined;\n};\n\nconst lineSegmentPlaneDifference = new Cartesian3();\n\n/**\n * Computes the intersection of a line segment and a plane.\n *\n * @param {Cartesian3} endPoint0 An end point of the line segment.\n * @param {Cartesian3} endPoint1 The other end point of the line segment.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * const intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n */\nIntersectionTests.lineSegmentPlane = function (\n  endPoint0,\n  endPoint1,\n  plane,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(endPoint0)) {\n    throw new DeveloperError(\"endPoint0 is required.\");\n  }\n  if (!defined(endPoint1)) {\n    throw new DeveloperError(\"endPoint1 is required.\");\n  }\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const difference = Cartesian3.subtract(\n    endPoint1,\n    endPoint0,\n    lineSegmentPlaneDifference\n  );\n  const normal = plane.normal;\n  const nDotDiff = Cartesian3.dot(normal, difference);\n\n  // check if the segment and plane are parallel\n  if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {\n    return undefined;\n  }\n\n  const nDotP0 = Cartesian3.dot(normal, endPoint0);\n  const t = -(plane.distance + nDotP0) / nDotDiff;\n\n  // intersection only if t is in [0, 1]\n  if (t < 0.0 || t > 1.0) {\n    return undefined;\n  }\n\n  // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n  Cartesian3.multiplyByScalar(difference, t, result);\n  Cartesian3.add(endPoint0, result, result);\n  return result;\n};\n\n/**\n * Computes the intersection of a triangle and a plane\n *\n * @param {Cartesian3} p0 First point of the triangle\n * @param {Cartesian3} p1 Second point of the triangle\n * @param {Cartesian3} p2 Third point of the triangle\n * @param {Plane} plane Intersection plane\n * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n *\n * @example\n * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * const normal = ellipsoid.geodeticSurfaceNormal(origin);\n * const plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * const p0 = new Cesium.Cartesian3(...);\n * const p1 = new Cesium.Cartesian3(...);\n * const p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane\n * const triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n */\nIntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {\n    throw new DeveloperError(\"p0, p1, p2, and plane are required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planeNormal = plane.normal;\n  const planeD = plane.distance;\n  const p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0.0;\n  const p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0.0;\n  const p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0.0;\n  // Given these dots products, the calls to lineSegmentPlaneIntersection\n  // always have defined results.\n\n  let numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  let u1, u2;\n  if (numBehind === 1 || numBehind === 2) {\n    u1 = new Cartesian3();\n    u2 = new Cartesian3();\n  }\n\n  if (numBehind === 1) {\n    if (p0Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          3,\n          4,\n\n          // In front\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n        ],\n      };\n    } else if (p1Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          3,\n          4,\n\n          // In front\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n        ],\n      };\n    } else if (p2Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          3,\n          4,\n\n          // In front\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n        ],\n      };\n    }\n  } else if (numBehind === 2) {\n    if (!p0Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n\n          // In front\n          0,\n          3,\n          4,\n        ],\n      };\n    } else if (!p1Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n\n          // In front\n          1,\n          3,\n          4,\n        ],\n      };\n    } else if (!p2Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n\n          // In front\n          2,\n          3,\n          4,\n        ],\n      };\n    }\n  }\n\n  // if numBehind is 3, the triangle is completely behind the plane;\n  // otherwise, it is completely in front (numBehind is 0).\n  return undefined;\n};\nexport default IntersectionTests;\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Contains functions for operating on 2D triangles.\n *\n * @namespace Intersections2D\n */\nconst Intersections2D = {};\n\n/**\n * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting\n * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,\n * 3, or 4 vertices.\n *\n * @param {Number} threshold The threshold coordinate value at which to clip the triangle.\n * @param {Boolean} keepAbove true to keep the portion of the triangle above the threshold, or false\n *                            to keep the portion below.\n * @param {Number} u0 The coordinate of the first vertex in the triangle, in counter-clockwise order.\n * @param {Number} u1 The coordinate of the second vertex in the triangle, in counter-clockwise order.\n * @param {Number} u2 The coordinate of the third vertex in the triangle, in counter-clockwise order.\n * @param {Number[]} [result] The array into which to copy the result.  If this parameter is not supplied,\n *                            a new array is constructed and returned.\n * @returns {Number[]} The polygon that results after the clip, specified as a list of\n *                     vertices.  The vertices are specified in counter-clockwise order.\n *                     Each vertex is either an index from the existing list (identified as\n *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.\n *                     For new vertices, the -1 is followed by three additional numbers: the\n *                     index of each of the two original vertices forming the line segment that\n *                     the new vertex lies on, and the fraction of the distance from the first\n *                     vertex to the second one.\n *\n * @example\n * const result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\n * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]\n */\nIntersections2D.clipTriangleAtAxisAlignedThreshold = function (\n  threshold,\n  keepAbove,\n  u0,\n  u1,\n  u2,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(threshold)) {\n    throw new DeveloperError(\"threshold is required.\");\n  }\n  if (!defined(keepAbove)) {\n    throw new DeveloperError(\"keepAbove is required.\");\n  }\n  if (!defined(u0)) {\n    throw new DeveloperError(\"u0 is required.\");\n  }\n  if (!defined(u1)) {\n    throw new DeveloperError(\"u1 is required.\");\n  }\n  if (!defined(u2)) {\n    throw new DeveloperError(\"u2 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  } else {\n    result.length = 0;\n  }\n\n  let u0Behind;\n  let u1Behind;\n  let u2Behind;\n  if (keepAbove) {\n    u0Behind = u0 < threshold;\n    u1Behind = u1 < threshold;\n    u2Behind = u2 < threshold;\n  } else {\n    u0Behind = u0 > threshold;\n    u1Behind = u1 > threshold;\n    u2Behind = u2 > threshold;\n  }\n\n  const numBehind = u0Behind + u1Behind + u2Behind;\n\n  let u01Ratio;\n  let u02Ratio;\n  let u12Ratio;\n  let u10Ratio;\n  let u20Ratio;\n  let u21Ratio;\n\n  if (numBehind === 1) {\n    if (u0Behind) {\n      u01Ratio = (threshold - u0) / (u1 - u0);\n      u02Ratio = (threshold - u0) / (u2 - u0);\n\n      result.push(1);\n\n      result.push(2);\n\n      if (u02Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(2);\n        result.push(u02Ratio);\n      }\n\n      if (u01Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(1);\n        result.push(u01Ratio);\n      }\n    } else if (u1Behind) {\n      u12Ratio = (threshold - u1) / (u2 - u1);\n      u10Ratio = (threshold - u1) / (u0 - u1);\n\n      result.push(2);\n\n      result.push(0);\n\n      if (u10Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(0);\n        result.push(u10Ratio);\n      }\n\n      if (u12Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(2);\n        result.push(u12Ratio);\n      }\n    } else if (u2Behind) {\n      u20Ratio = (threshold - u2) / (u0 - u2);\n      u21Ratio = (threshold - u2) / (u1 - u2);\n\n      result.push(0);\n\n      result.push(1);\n\n      if (u21Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(1);\n        result.push(u21Ratio);\n      }\n\n      if (u20Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(0);\n        result.push(u20Ratio);\n      }\n    }\n  } else if (numBehind === 2) {\n    if (!u0Behind && u0 !== threshold) {\n      u10Ratio = (threshold - u1) / (u0 - u1);\n      u20Ratio = (threshold - u2) / (u0 - u2);\n\n      result.push(0);\n\n      result.push(-1);\n      result.push(1);\n      result.push(0);\n      result.push(u10Ratio);\n\n      result.push(-1);\n      result.push(2);\n      result.push(0);\n      result.push(u20Ratio);\n    } else if (!u1Behind && u1 !== threshold) {\n      u21Ratio = (threshold - u2) / (u1 - u2);\n      u01Ratio = (threshold - u0) / (u1 - u0);\n\n      result.push(1);\n\n      result.push(-1);\n      result.push(2);\n      result.push(1);\n      result.push(u21Ratio);\n\n      result.push(-1);\n      result.push(0);\n      result.push(1);\n      result.push(u01Ratio);\n    } else if (!u2Behind && u2 !== threshold) {\n      u02Ratio = (threshold - u0) / (u2 - u0);\n      u12Ratio = (threshold - u1) / (u2 - u1);\n\n      result.push(2);\n\n      result.push(-1);\n      result.push(0);\n      result.push(2);\n      result.push(u02Ratio);\n\n      result.push(-1);\n      result.push(1);\n      result.push(2);\n      result.push(u12Ratio);\n    }\n  } else if (numBehind !== 3) {\n    // Completely in front of threshold\n    result.push(0);\n    result.push(1);\n    result.push(2);\n  }\n  // else Completely behind threshold\n\n  return result;\n};\n\n/**\n * Compute the barycentric coordinates of a 2D position within a 2D triangle.\n *\n * @param {Number} x The x coordinate of the position for which to find the barycentric coordinates.\n * @param {Number} y The y coordinate of the position for which to find the barycentric coordinates.\n * @param {Number} x1 The x coordinate of the triangle's first vertex.\n * @param {Number} y1 The y coordinate of the triangle's first vertex.\n * @param {Number} x2 The x coordinate of the triangle's second vertex.\n * @param {Number} y2 The y coordinate of the triangle's second vertex.\n * @param {Number} x3 The x coordinate of the triangle's third vertex.\n * @param {Number} y3 The y coordinate of the triangle's third vertex.\n * @param {Cartesian3} [result] The instance into to which to copy the result.  If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian3} The barycentric coordinates of the position within the triangle.\n *\n * @example\n * const result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\n * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);\n */\nIntersections2D.computeBarycentricCoordinates = function (\n  x,\n  y,\n  x1,\n  y1,\n  x2,\n  y2,\n  x3,\n  y3,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(x)) {\n    throw new DeveloperError(\"x is required.\");\n  }\n  if (!defined(y)) {\n    throw new DeveloperError(\"y is required.\");\n  }\n  if (!defined(x1)) {\n    throw new DeveloperError(\"x1 is required.\");\n  }\n  if (!defined(y1)) {\n    throw new DeveloperError(\"y1 is required.\");\n  }\n  if (!defined(x2)) {\n    throw new DeveloperError(\"x2 is required.\");\n  }\n  if (!defined(y2)) {\n    throw new DeveloperError(\"y2 is required.\");\n  }\n  if (!defined(x3)) {\n    throw new DeveloperError(\"x3 is required.\");\n  }\n  if (!defined(y3)) {\n    throw new DeveloperError(\"y3 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const x1mx3 = x1 - x3;\n  const x3mx2 = x3 - x2;\n  const y2my3 = y2 - y3;\n  const y1my3 = y1 - y3;\n  const inverseDeterminant = 1.0 / (y2my3 * x1mx3 + x3mx2 * y1my3);\n  const ymy3 = y - y3;\n  const xmx3 = x - x3;\n  const l1 = (y2my3 * xmx3 + x3mx2 * ymy3) * inverseDeterminant;\n  const l2 = (-y1my3 * xmx3 + x1mx3 * ymy3) * inverseDeterminant;\n  const l3 = 1.0 - l1 - l2;\n\n  if (defined(result)) {\n    result.x = l1;\n    result.y = l2;\n    result.z = l3;\n    return result;\n  }\n  return new Cartesian3(l1, l2, l3);\n};\n\n/**\n * Compute the intersection between 2 line segments\n *\n * @param {Number} x00 The x coordinate of the first line's first vertex.\n * @param {Number} y00 The y coordinate of the first line's first vertex.\n * @param {Number} x01 The x coordinate of the first line's second vertex.\n * @param {Number} y01 The y coordinate of the first line's second vertex.\n * @param {Number} x10 The x coordinate of the second line's first vertex.\n * @param {Number} y10 The y coordinate of the second line's first vertex.\n * @param {Number} x11 The x coordinate of the second line's second vertex.\n * @param {Number} y11 The y coordinate of the second line's second vertex.\n * @param {Cartesian2} [result] The instance into to which to copy the result. If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian2} The intersection point, undefined if there is no intersection point or lines are coincident.\n *\n * @example\n * const result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\n * // result === new Cesium.Cartesian2(0.0, 1.0);\n */\nIntersections2D.computeLineSegmentLineSegmentIntersection = function (\n  x00,\n  y00,\n  x01,\n  y01,\n  x10,\n  y10,\n  x11,\n  y11,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x00\", x00);\n  Check.typeOf.number(\"y00\", y00);\n  Check.typeOf.number(\"x01\", x01);\n  Check.typeOf.number(\"y01\", y01);\n  Check.typeOf.number(\"x10\", x10);\n  Check.typeOf.number(\"y10\", y10);\n  Check.typeOf.number(\"x11\", x11);\n  Check.typeOf.number(\"y11\", y11);\n  //>>includeEnd('debug');\n\n  const numerator1A = (x11 - x10) * (y00 - y10) - (y11 - y10) * (x00 - x10);\n  const numerator1B = (x01 - x00) * (y00 - y10) - (y01 - y00) * (x00 - x10);\n  const denominator1 = (y11 - y10) * (x01 - x00) - (x11 - x10) * (y01 - y00);\n\n  // If denominator = 0, then lines are parallel. If denominator = 0 and both numerators are 0, then coincident\n  if (denominator1 === 0) {\n    return;\n  }\n\n  const ua1 = numerator1A / denominator1;\n  const ub1 = numerator1B / denominator1;\n\n  if (ua1 >= 0 && ua1 <= 1 && ub1 >= 0 && ub1 <= 1) {\n    if (!defined(result)) {\n      result = new Cartesian2();\n    }\n\n    result.x = x00 + ua1 * (x01 - x00);\n    result.y = y00 + ua1 * (y01 - y00);\n\n    return result;\n  }\n};\nexport default Intersections2D;\n","import defaultValue from \"./defaultValue.js\";\n\n/**\n * Represents the closed interval [start, stop].\n * @alias Interval\n * @constructor\n *\n * @param {Number} [start=0.0] The beginning of the interval.\n * @param {Number} [stop=0.0] The end of the interval.\n */\nfunction Interval(start, stop) {\n  /**\n   * The beginning of the interval.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.start = defaultValue(start, 0.0);\n  /**\n   * The end of the interval.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.stop = defaultValue(stop, 0.0);\n}\nexport default Interval;\n","import Credit from \"./Credit.js\";\nimport defined from \"./defined.js\";\nimport Resource from \"./Resource.js\";\n\nlet defaultTokenCredit;\nconst defaultAccessToken =\n  \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5MTdhODgxYi1hNzE4LTRlYjAtOWY4Zi0yN2RjNmIxMDA3MWEiLCJpZCI6MjU5LCJpYXQiOjE2NTQwOTk1ODB9.6fgeb1wewbbv88IZBRvjGM6tqNXXc_3x0Lawo8lCt7c\";\n/**\n * Default settings for accessing the Cesium ion API.\n *\n * An ion access token is only required if you are using any ion related APIs.\n * A default access token is provided for evaluation purposes only.\n * Sign up for a free ion account and get your own access token at {@link https://cesium.com}\n *\n * @see IonResource\n * @see IonImageryProvider\n * @see IonGeocoderService\n * @see createWorldImagery\n * @see createWorldTerrain\n * @namespace Ion\n */\nconst Ion = {};\n\n/**\n * Gets or sets the default Cesium ion access token.\n *\n * @type {String}\n */\nIon.defaultAccessToken = defaultAccessToken;\n\n/**\n * Gets or sets the default Cesium ion server.\n *\n * @type {String|Resource}\n * @default https://api.cesium.com\n */\nIon.defaultServer = new Resource({ url: \"https://api.cesium.com/\" });\n\nIon.getDefaultTokenCredit = function (providedKey) {\n  if (providedKey !== defaultAccessToken) {\n    return undefined;\n  }\n\n  if (!defined(defaultTokenCredit)) {\n    const defaultTokenMessage =\n      '<b> \\\n            This application is using Cesium\\'s default ion access token. Please assign <i>Cesium.Ion.defaultAccessToken</i> \\\n            with an access token from your ion account before making any Cesium API calls. \\\n            You can sign up for a free ion account at <a href=\"https://cesium.com\">https://cesium.com</a>.</b>';\n\n    defaultTokenCredit = new Credit(defaultTokenMessage, true);\n  }\n\n  return defaultTokenCredit;\n};\nexport default Ion;\n","import Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ion from \"./Ion.js\";\nimport PeliasGeocoderService from \"./PeliasGeocoderService.js\";\nimport Resource from \"./Resource.js\";\n\n/**\n * Provides geocoding through Cesium ion.\n * @alias IonGeocoderService\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Scene} options.scene The scene\n * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.\n * @param {String|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.\n *\n * @see Ion\n */\nfunction IonGeocoderService(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.scene\", options.scene);\n  //>>includeEnd('debug');\n\n  const accessToken = defaultValue(options.accessToken, Ion.defaultAccessToken);\n  const server = Resource.createIfNeeded(\n    defaultValue(options.server, Ion.defaultServer)\n  );\n  server.appendForwardSlash();\n\n  const defaultTokenCredit = Ion.getDefaultTokenCredit(accessToken);\n  if (defined(defaultTokenCredit)) {\n    options.scene.frameState.creditDisplay.addDefaultCredit(\n      Credit.clone(defaultTokenCredit)\n    );\n  }\n\n  const searchEndpoint = server.getDerivedResource({\n    url: \"v1/geocode\",\n  });\n\n  if (defined(accessToken)) {\n    searchEndpoint.appendQueryParameters({ access_token: accessToken });\n  }\n\n  this._accessToken = accessToken;\n  this._server = server;\n  this._pelias = new PeliasGeocoderService(searchEndpoint);\n}\n\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.\n * @returns {Promise<GeocoderService.Result[]>}\n */\nIonGeocoderService.prototype.geocode = function (query, geocodeType) {\n  return this._pelias.geocode(query, geocodeType);\n};\nexport default IonGeocoderService;\n","import Uri from \"../ThirdParty/Uri.js\";\nimport Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ion from \"./Ion.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * A {@link Resource} instance that encapsulates Cesium ion asset access.\n * This object is normally not instantiated directly, use {@link IonResource.fromAssetId}.\n *\n * @alias IonResource\n * @constructor\n * @augments Resource\n *\n * @param {Object} endpoint The result of the Cesium ion asset endpoint service.\n * @param {Resource} endpointResource The resource used to retreive the endpoint.\n *\n * @see Ion\n * @see IonImageryProvider\n * @see createWorldTerrain\n * @see https://cesium.com\n */\nfunction IonResource(endpoint, endpointResource) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"endpoint\", endpoint);\n  Check.defined(\"endpointResource\", endpointResource);\n  //>>includeEnd('debug');\n\n  let options;\n  const externalType = endpoint.externalType;\n  const isExternal = defined(externalType);\n\n  if (!isExternal) {\n    options = {\n      url: endpoint.url,\n      retryAttempts: 1,\n      retryCallback: retryCallback,\n    };\n  } else if (\n    externalType === \"3DTILES\" ||\n    externalType === \"STK_TERRAIN_SERVER\"\n  ) {\n    // 3D Tiles and STK Terrain Server external assets can still be represented as an IonResource\n    options = { url: endpoint.options.url };\n  } else {\n    //External imagery assets have additional configuration that can't be represented as a Resource\n    throw new RuntimeError(\n      \"Ion.createResource does not support external imagery assets; use IonImageryProvider instead.\"\n    );\n  }\n\n  Resource.call(this, options);\n\n  // The asset endpoint data returned from ion.\n  this._ionEndpoint = endpoint;\n  this._ionEndpointDomain = isExternal\n    ? undefined\n    : new Uri(endpoint.url).authority();\n\n  // The endpoint resource to fetch when a new token is needed\n  this._ionEndpointResource = endpointResource;\n\n  // The primary IonResource from which an instance is derived\n  this._ionRoot = undefined;\n\n  // Shared promise for endpooint requests amd credits (only ever set on the root request)\n  this._pendingPromise = undefined;\n  this._credits = undefined;\n  this._isExternal = isExternal;\n}\n\nif (defined(Object.create)) {\n  IonResource.prototype = Object.create(Resource.prototype);\n  IonResource.prototype.constructor = IonResource;\n}\n\n/**\n * Asynchronously creates an instance.\n *\n * @param {Number} assetId The Cesium ion asset id.\n * @param {Object} [options] An object with the following properties:\n * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.\n * @param {String|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.\n * @returns {Promise.<IonResource>} A Promise to am instance representing the Cesium ion Asset.\n *\n * @example\n * //Load a Cesium3DTileset with asset ID of 124624234\n * viewer.scene.primitives.add(new Cesium.Cesium3DTileset({ url: Cesium.IonResource.fromAssetId(124624234) }));\n *\n * @example\n * //Load a CZML file with asset ID of 10890\n * Cesium.IonResource.fromAssetId(10890)\n *   .then(function (resource) {\n *     viewer.dataSources.add(Cesium.CzmlDataSource.load(resource));\n *   });\n */\nIonResource.fromAssetId = function (assetId, options) {\n  const endpointResource = IonResource._createEndpointResource(\n    assetId,\n    options\n  );\n\n  return endpointResource.fetchJson().then(function (endpoint) {\n    return new IonResource(endpoint, endpointResource);\n  });\n};\n\nObject.defineProperties(IonResource.prototype, {\n  /**\n   * Gets the credits required for attribution of the asset.\n   *\n   * @memberof IonResource.prototype\n   * @type {Credit[]}\n   * @readonly\n   */\n  credits: {\n    get: function () {\n      // Only we're not the root, return its credits;\n      if (defined(this._ionRoot)) {\n        return this._ionRoot.credits;\n      }\n\n      // We are the root\n      if (defined(this._credits)) {\n        return this._credits;\n      }\n\n      this._credits = IonResource.getCreditsFromEndpoint(\n        this._ionEndpoint,\n        this._ionEndpointResource\n      );\n\n      return this._credits;\n    },\n  },\n});\n\n/** @private */\nIonResource.getCreditsFromEndpoint = function (endpoint, endpointResource) {\n  const credits = endpoint.attributions.map(Credit.getIonCredit);\n  const defaultTokenCredit = Ion.getDefaultTokenCredit(\n    endpointResource.queryParameters.access_token\n  );\n  if (defined(defaultTokenCredit)) {\n    credits.push(Credit.clone(defaultTokenCredit));\n  }\n  return credits;\n};\n\n/** @inheritdoc */\nIonResource.prototype.clone = function (result) {\n  // We always want to use the root's information because it's the most up-to-date\n  const ionRoot = defaultValue(this._ionRoot, this);\n\n  if (!defined(result)) {\n    result = new IonResource(\n      ionRoot._ionEndpoint,\n      ionRoot._ionEndpointResource\n    );\n  }\n\n  result = Resource.prototype.clone.call(this, result);\n  result._ionRoot = ionRoot;\n  result._isExternal = this._isExternal;\n\n  return result;\n};\n\nIonResource.prototype.fetchImage = function (options) {\n  if (!this._isExternal) {\n    const userOptions = options;\n    options = {\n      preferBlob: true,\n    };\n    if (defined(userOptions)) {\n      options.flipY = userOptions.flipY;\n      options.preferImageBitmap = userOptions.preferImageBitmap;\n    }\n  }\n\n  return Resource.prototype.fetchImage.call(this, options);\n};\n\nIonResource.prototype._makeRequest = function (options) {\n  // Don't send ion access token to non-ion servers.\n  if (\n    this._isExternal ||\n    new Uri(this.url).authority() !== this._ionEndpointDomain\n  ) {\n    return Resource.prototype._makeRequest.call(this, options);\n  }\n\n  if (!defined(options.headers)) {\n    options.headers = {};\n  }\n  options.headers.Authorization = `Bearer ${this._ionEndpoint.accessToken}`;\n\n  return Resource.prototype._makeRequest.call(this, options);\n};\n\n/**\n * @private\n */\nIonResource._createEndpointResource = function (assetId, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"assetId\", assetId);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  let server = defaultValue(options.server, Ion.defaultServer);\n  const accessToken = defaultValue(options.accessToken, Ion.defaultAccessToken);\n  server = Resource.createIfNeeded(server);\n\n  const resourceOptions = {\n    url: `v1/assets/${assetId}/endpoint`,\n  };\n\n  if (defined(accessToken)) {\n    resourceOptions.queryParameters = { access_token: accessToken };\n  }\n\n  return server.getDerivedResource(resourceOptions);\n};\n\nfunction retryCallback(that, error) {\n  const ionRoot = defaultValue(that._ionRoot, that);\n  const endpointResource = ionRoot._ionEndpointResource;\n\n  // Image is not available in worker threads, so this avoids\n  // a ReferenceError\n  const imageDefined = typeof Image !== \"undefined\";\n\n  // We only want to retry in the case of invalid credentials (401) or image\n  // requests(since Image failures can not provide a status code)\n  if (\n    !defined(error) ||\n    (error.statusCode !== 401 &&\n      !(imageDefined && error.target instanceof Image))\n  ) {\n    return Promise.resolve(false);\n  }\n\n  // We use a shared pending promise for all derived assets, since they share\n  // a common access_token.  If we're already requesting a new token for this\n  // asset, we wait on the same promise.\n  if (!defined(ionRoot._pendingPromise)) {\n    ionRoot._pendingPromise = endpointResource\n      .fetchJson()\n      .then(function (newEndpoint) {\n        //Set the token for root resource so new derived resources automatically pick it up\n        ionRoot._ionEndpoint = newEndpoint;\n        return newEndpoint;\n      })\n      .finally(function (newEndpoint) {\n        // Pass or fail, we're done with this promise, the next failure should use a new one.\n        ionRoot._pendingPromise = undefined;\n        return newEndpoint;\n      });\n  }\n\n  return ionRoot._pendingPromise.then(function (newEndpoint) {\n    // Set the new token and endpoint for this resource\n    that._ionEndpoint = newEndpoint;\n    return true;\n  });\n}\nexport default IonResource;\n","import JulianDate from \"./JulianDate.js\";\nimport TimeInterval from \"./TimeInterval.js\";\n\nconst MINIMUM_VALUE = Object.freeze(\n  JulianDate.fromIso8601(\"0000-01-01T00:00:00Z\")\n);\nconst MAXIMUM_VALUE = Object.freeze(\n  JulianDate.fromIso8601(\"9999-12-31T24:00:00Z\")\n);\nconst MAXIMUM_INTERVAL = Object.freeze(\n  new TimeInterval({\n    start: MINIMUM_VALUE,\n    stop: MAXIMUM_VALUE,\n  })\n);\n\n/**\n * Constants related to ISO8601 support.\n *\n * @namespace\n *\n * @see {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601 on Wikipedia}\n * @see JulianDate\n * @see TimeInterval\n */\nconst Iso8601 = {\n  /**\n   * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.\n   * This is equivalent to the date string '0000-01-01T00:00:00Z'\n   *\n   * @type {JulianDate}\n   * @constant\n   */\n  MINIMUM_VALUE: MINIMUM_VALUE,\n\n  /**\n   * A {@link JulianDate} representing the latest time representable by an ISO8601 date.\n   * This is equivalent to the date string '9999-12-31T24:00:00Z'\n   *\n   * @type {JulianDate}\n   * @constant\n   */\n  MAXIMUM_VALUE: MAXIMUM_VALUE,\n\n  /**\n   * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.\n   * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'\n   *\n   * @type {TimeInterval}\n   * @constant\n   */\n  MAXIMUM_INTERVAL: MAXIMUM_INTERVAL,\n};\nexport default Iso8601;\n","import binarySearch from \"./binarySearch.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GregorianDate from \"./GregorianDate.js\";\nimport isLeapYear from \"./isLeapYear.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\nconst gregorianDateScratch = new GregorianDate();\nconst daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst daysInLeapFeburary = 29;\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);\n}\n\n// we don't really need a leap second instance, anything with a julianDate property will do\nconst binarySearchScratchLeapSecond = new LeapSecond();\n\nfunction convertUtcToTai(julianDate) {\n  //Even though julianDate is in UTC, we'll treat it as TAI and\n  //search the leap second table for it.\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n\n  if (index < 0) {\n    index = ~index;\n  }\n\n  if (index >= leapSeconds.length) {\n    index = leapSeconds.length - 1;\n  }\n\n  let offset = leapSeconds[index].offset;\n  if (index > 0) {\n    //Now we have the index of the closest leap second that comes on or after our UTC time.\n    //However, if the difference between the UTC date being converted and the TAI\n    //defined leap second is greater than the offset, we are off by one and need to use\n    //the previous leap second.\n    const difference = JulianDate.secondsDifference(\n      leapSeconds[index].julianDate,\n      julianDate\n    );\n    if (difference > offset) {\n      index--;\n      offset = leapSeconds[index].offset;\n    }\n  }\n\n  JulianDate.addSeconds(julianDate, offset, julianDate);\n}\n\nfunction convertTaiToUtc(julianDate, result) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n  if (index < 0) {\n    index = ~index;\n  }\n\n  //All times before our first leap second get the first offset.\n  if (index === 0) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);\n  }\n\n  //All times after our leap second get the last offset.\n  if (index >= leapSeconds.length) {\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index - 1].offset,\n      result\n    );\n  }\n\n  //Compute the difference between the found leap second and the time we are converting.\n  const difference = JulianDate.secondsDifference(\n    leapSeconds[index].julianDate,\n    julianDate\n  );\n\n  if (difference === 0) {\n    //The date is in our leap second table.\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index].offset,\n      result\n    );\n  }\n\n  if (difference <= 1.0) {\n    //The requested date is during the moment of a leap second, then we cannot convert to UTC\n    return undefined;\n  }\n\n  //The time is in between two leap seconds, index is the leap second after the date\n  //we're converting, so we subtract one to get the correct LeapSecond instance.\n  return JulianDate.addSeconds(\n    julianDate,\n    -leapSeconds[--index].offset,\n    result\n  );\n}\n\nfunction setComponents(wholeDays, secondsOfDay, julianDate) {\n  const extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;\n  wholeDays += extraDays;\n  secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;\n\n  if (secondsOfDay < 0) {\n    wholeDays--;\n    secondsOfDay += TimeConstants.SECONDS_PER_DAY;\n  }\n\n  julianDate.dayNumber = wholeDays;\n  julianDate.secondsOfDay = secondsOfDay;\n  return julianDate;\n}\n\nfunction computeJulianDateComponents(\n  year,\n  month,\n  day,\n  hour,\n  minute,\n  second,\n  millisecond\n) {\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n\n  const a = ((month - 14) / 12) | 0;\n  const b = year + 4800 + a;\n  let dayNumber =\n    (((1461 * b) / 4) | 0) +\n    (((367 * (month - 2 - 12 * a)) / 12) | 0) -\n    (((3 * (((b + 100) / 100) | 0)) / 4) | 0) +\n    day -\n    32075;\n\n  // JulianDates are noon-based\n  hour = hour - 12;\n  if (hour < 0) {\n    hour += 24;\n  }\n\n  const secondsOfDay =\n    second +\n    (hour * TimeConstants.SECONDS_PER_HOUR +\n      minute * TimeConstants.SECONDS_PER_MINUTE +\n      millisecond * TimeConstants.SECONDS_PER_MILLISECOND);\n\n  if (secondsOfDay >= 43200.0) {\n    dayNumber -= 1;\n  }\n\n  return [dayNumber, secondsOfDay];\n}\n\n//Regular expressions used for ISO8601 date parsing.\n//YYYY\nconst matchCalendarYear = /^(\\d{4})$/;\n//YYYY-MM (YYYYMM is invalid)\nconst matchCalendarMonth = /^(\\d{4})-(\\d{2})$/;\n//YYYY-DDD or YYYYDDD\nconst matchOrdinalDate = /^(\\d{4})-?(\\d{3})$/;\n//YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD\nconst matchWeekDate = /^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/;\n//YYYY-MM-DD or YYYYMMDD\nconst matchCalendarDate = /^(\\d{4})-?(\\d{2})-?(\\d{2})$/;\n// Match utc offset\nconst utcOffset = /([Z+\\-])?(\\d{2})?:?(\\d{2})?$/;\n// Match hours HH or HH.xxxxx\nconst matchHours = /^(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM HHMM.xxxxx\nconst matchHoursMinutes = /^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM:SS HHMMSS.xxxxx\nconst matchHoursMinutesSeconds =\n  /^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n\nconst iso8601ErrorMessage = \"Invalid ISO 8601 date.\";\n\n/**\n * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).\n * For increased precision, this class stores the whole number part of the date and the seconds\n * part of the date in separate components.  In order to be safe for arithmetic and represent\n * leap seconds, the date is always stored in the International Atomic Time standard\n * {@link TimeStandard.TAI}.\n * @alias JulianDate\n * @constructor\n *\n * @param {Number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.\n * @param {Number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.\n * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.\n */\nfunction JulianDate(julianDayNumber, secondsOfDay, timeStandard) {\n  /**\n   * Gets or sets the number of whole days.\n   * @type {Number}\n   */\n  this.dayNumber = undefined;\n\n  /**\n   * Gets or sets the number of seconds into the current day.\n   * @type {Number}\n   */\n  this.secondsOfDay = undefined;\n\n  julianDayNumber = defaultValue(julianDayNumber, 0.0);\n  secondsOfDay = defaultValue(secondsOfDay, 0.0);\n  timeStandard = defaultValue(timeStandard, TimeStandard.UTC);\n\n  //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.\n  const wholeDays = julianDayNumber | 0;\n  secondsOfDay =\n    secondsOfDay +\n    (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;\n\n  setComponents(wholeDays, secondsOfDay, this);\n\n  if (timeStandard === TimeStandard.UTC) {\n    convertUtcToTai(this);\n  }\n}\n\n/**\n * Creates a new instance from a GregorianDate.\n *\n * @param {GregorianDate} date A GregorianDate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid GregorianDate.\n */\nJulianDate.fromGregorianDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof GregorianDate)) {\n    throw new DeveloperError(\"date must be a valid GregorianDate.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(\n    date.year,\n    date.month,\n    date.day,\n    date.hour,\n    date.minute,\n    date.second,\n    date.millisecond\n  );\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a JavaScript Date.\n *\n * @param {Date} date A JavaScript Date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid JavaScript Date.\n */\nJulianDate.fromDate = function (date, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    throw new DeveloperError(\"date must be a valid JavaScript Date.\");\n  }\n  //>>includeEnd('debug');\n\n  const components = computeJulianDateComponents(\n    date.getUTCFullYear(),\n    date.getUTCMonth() + 1,\n    date.getUTCDate(),\n    date.getUTCHours(),\n    date.getUTCMinutes(),\n    date.getUTCSeconds(),\n    date.getUTCMilliseconds()\n  );\n  if (!defined(result)) {\n    return new JulianDate(components[0], components[1], TimeStandard.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.\n * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601\n * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.\n *\n * @param {String} iso8601String An ISO 8601 date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} Invalid ISO 8601 date.\n */\nJulianDate.fromIso8601 = function (iso8601String, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof iso8601String !== \"string\") {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug');\n\n  //Comma and decimal point both indicate a fractional number according to ISO 8601,\n  //start out by blanket replacing , with . which is the only valid such symbol in JS.\n  iso8601String = iso8601String.replace(\",\", \".\");\n\n  //Split the string into its date and time components, denoted by a mandatory T\n  let tokens = iso8601String.split(\"T\");\n  let year;\n  let month = 1;\n  let day = 1;\n  let hour = 0;\n  let minute = 0;\n  let second = 0;\n  let millisecond = 0;\n\n  //Lacking a time is okay, but a missing date is illegal.\n  const date = tokens[0];\n  const time = tokens[1];\n  let tmp;\n  let inLeapYear;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(date)) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n\n  let dashCount;\n  //>>includeEnd('debug');\n\n  //First match the date against possible regular expressions.\n  tokens = date.match(matchCalendarDate);\n  if (tokens !== null) {\n    //>>includeStart('debug', pragmas.debug);\n    dashCount = date.split(\"-\").length - 1;\n    if (dashCount > 0 && dashCount !== 2) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n    year = +tokens[1];\n    month = +tokens[2];\n    day = +tokens[3];\n  } else {\n    tokens = date.match(matchCalendarMonth);\n    if (tokens !== null) {\n      year = +tokens[1];\n      month = +tokens[2];\n    } else {\n      tokens = date.match(matchCalendarYear);\n      if (tokens !== null) {\n        year = +tokens[1];\n      } else {\n        //Not a year/month/day so it must be an ordinal date.\n        let dayOfYear;\n        tokens = date.match(matchOrdinalDate);\n        if (tokens !== null) {\n          year = +tokens[1];\n          dayOfYear = +tokens[2];\n          inLeapYear = isLeapYear(year);\n\n          //This validation is only applicable for this format.\n          //>>includeStart('debug', pragmas.debug);\n          if (\n            dayOfYear < 1 ||\n            (inLeapYear && dayOfYear > 366) ||\n            (!inLeapYear && dayOfYear > 365)\n          ) {\n            throw new DeveloperError(iso8601ErrorMessage);\n          }\n          //>>includeEnd('debug')\n        } else {\n          tokens = date.match(matchWeekDate);\n          if (tokens !== null) {\n            //ISO week date to ordinal date from\n            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775\n            year = +tokens[1];\n            const weekNumber = +tokens[2];\n            const dayOfWeek = +tokens[3] || 0;\n\n            //>>includeStart('debug', pragmas.debug);\n            dashCount = date.split(\"-\").length - 1;\n            if (\n              dashCount > 0 &&\n              ((!defined(tokens[3]) && dashCount !== 1) ||\n                (defined(tokens[3]) && dashCount !== 2))\n            ) {\n              throw new DeveloperError(iso8601ErrorMessage);\n            }\n            //>>includeEnd('debug')\n\n            const january4 = new Date(Date.UTC(year, 0, 4));\n            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;\n          } else {\n            //None of our regular expressions succeeded in parsing the date properly.\n            //>>includeStart('debug', pragmas.debug);\n            throw new DeveloperError(iso8601ErrorMessage);\n            //>>includeEnd('debug')\n          }\n        }\n        //Split an ordinal date into month/day.\n        tmp = new Date(Date.UTC(year, 0, 1));\n        tmp.setUTCDate(dayOfYear);\n        month = tmp.getUTCMonth() + 1;\n        day = tmp.getUTCDate();\n      }\n    }\n  }\n\n  //Now that we have all of the date components, validate them to make sure nothing is out of range.\n  inLeapYear = isLeapYear(year);\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    month < 1 ||\n    month > 12 ||\n    day < 1 ||\n    ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) ||\n    (inLeapYear && month === 2 && day > daysInLeapFeburary)\n  ) {\n    throw new DeveloperError(iso8601ErrorMessage);\n  }\n  //>>includeEnd('debug')\n\n  //Now move onto the time string, which is much simpler.\n  //If no time is specified, it is considered the beginning of the day, UTC to match Javascript's implementation.\n  let offsetIndex;\n  if (defined(time)) {\n    tokens = time.match(matchHoursMinutesSeconds);\n    if (tokens !== null) {\n      //>>includeStart('debug', pragmas.debug);\n      dashCount = time.split(\":\").length - 1;\n      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {\n        throw new DeveloperError(iso8601ErrorMessage);\n      }\n      //>>includeEnd('debug')\n\n      hour = +tokens[1];\n      minute = +tokens[2];\n      second = +tokens[3];\n      millisecond = +(tokens[4] || 0) * 1000.0;\n      offsetIndex = 5;\n    } else {\n      tokens = time.match(matchHoursMinutes);\n      if (tokens !== null) {\n        //>>includeStart('debug', pragmas.debug);\n        dashCount = time.split(\":\").length - 1;\n        if (dashCount > 2) {\n          throw new DeveloperError(iso8601ErrorMessage);\n        }\n        //>>includeEnd('debug')\n\n        hour = +tokens[1];\n        minute = +tokens[2];\n        second = +(tokens[3] || 0) * 60.0;\n        offsetIndex = 4;\n      } else {\n        tokens = time.match(matchHours);\n        if (tokens !== null) {\n          hour = +tokens[1];\n          minute = +(tokens[2] || 0) * 60.0;\n          offsetIndex = 3;\n        } else {\n          //>>includeStart('debug', pragmas.debug);\n          throw new DeveloperError(iso8601ErrorMessage);\n          //>>includeEnd('debug')\n        }\n      }\n    }\n\n    //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      minute >= 60 ||\n      second >= 61 ||\n      hour > 24 ||\n      (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))\n    ) {\n      throw new DeveloperError(iso8601ErrorMessage);\n    }\n    //>>includeEnd('debug');\n\n    //Check the UTC offset value, if no value exists, use local time\n    //a Z indicates UTC, + or - are offsets.\n    const offset = tokens[offsetIndex];\n    const offsetHours = +tokens[offsetIndex + 1];\n    const offsetMinutes = +(tokens[offsetIndex + 2] || 0);\n    switch (offset) {\n      case \"+\":\n        hour = hour - offsetHours;\n        minute = minute - offsetMinutes;\n        break;\n      case \"-\":\n        hour = hour + offsetHours;\n        minute = minute + offsetMinutes;\n        break;\n      case \"Z\":\n        break;\n      default:\n        minute =\n          minute +\n          new Date(\n            Date.UTC(year, month - 1, day, hour, minute)\n          ).getTimezoneOffset();\n        break;\n    }\n  }\n\n  //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.\n  //If that's the case, we need to temporarily subtract a second in order to build a UTC date.\n  //Then we add it back in after converting to TAI.\n  const isLeapSecond = second === 60;\n  if (isLeapSecond) {\n    second--;\n  }\n\n  //Even if we successfully parsed the string into its components, after applying UTC offset or\n  //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.\n\n  //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes\n  while (minute >= 60) {\n    minute -= 60;\n    hour++;\n  }\n\n  while (hour >= 24) {\n    hour -= 24;\n    day++;\n  }\n\n  tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n  while (day > tmp) {\n    day -= tmp;\n    month++;\n\n    if (month > 12) {\n      month -= 12;\n      year++;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n  }\n\n  //If UTC offset is at the beginning/end of the day, minutes can be negative.\n  while (minute < 0) {\n    minute += 60;\n    hour--;\n  }\n\n  while (hour < 0) {\n    hour += 24;\n    day--;\n  }\n\n  while (day < 1) {\n    month--;\n    if (month < 1) {\n      month += 12;\n      year--;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n    day += tmp;\n  }\n\n  //Now create the JulianDate components from the Gregorian date and actually create our instance.\n  const components = computeJulianDateComponents(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond\n  );\n\n  if (!defined(result)) {\n    result = new JulianDate(components[0], components[1], TimeStandard.UTC);\n  } else {\n    setComponents(components[0], components[1], result);\n    convertUtcToTai(result);\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    JulianDate.addSeconds(result, 1, result);\n  }\n\n  return result;\n};\n\n/**\n * Creates a new instance that represents the current system time.\n * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.now = function (result) {\n  return JulianDate.fromDate(new Date(), result);\n};\n\nconst toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);\n\n/**\n * Creates a {@link GregorianDate} from the provided instance.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {GregorianDate} [result] An existing instance to use for the result.\n * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.toGregorianDate = function (julianDate, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let isLeapSecond = false;\n  let thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);\n  if (!defined(thisUtc)) {\n    //Conversion to UTC will fail if we are during a leap second.\n    //If that's the case, subtract a second and convert again.\n    //JavaScript doesn't support leap seconds, so this results in second 59 being repeated twice.\n    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);\n    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);\n    isLeapSecond = true;\n  }\n\n  let julianDayNumber = thisUtc.dayNumber;\n  const secondsOfDay = thisUtc.secondsOfDay;\n\n  if (secondsOfDay >= 43200.0) {\n    julianDayNumber += 1;\n  }\n\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n  let L = (julianDayNumber + 68569) | 0;\n  const N = ((4 * L) / 146097) | 0;\n  L = (L - (((146097 * N + 3) / 4) | 0)) | 0;\n  const I = ((4000 * (L + 1)) / 1461001) | 0;\n  L = (L - (((1461 * I) / 4) | 0) + 31) | 0;\n  const J = ((80 * L) / 2447) | 0;\n  const day = (L - (((2447 * J) / 80) | 0)) | 0;\n  L = (J / 11) | 0;\n  const month = (J + 2 - 12 * L) | 0;\n  const year = (100 * (N - 49) + I + L) | 0;\n\n  let hour = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;\n  let remainingSeconds = secondsOfDay - hour * TimeConstants.SECONDS_PER_HOUR;\n  const minute = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;\n  remainingSeconds =\n    remainingSeconds - minute * TimeConstants.SECONDS_PER_MINUTE;\n  let second = remainingSeconds | 0;\n  const millisecond =\n    (remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND;\n\n  // JulianDates are noon-based\n  hour += 12;\n  if (hour > 23) {\n    hour -= 24;\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    second += 1;\n  }\n\n  if (!defined(result)) {\n    return new GregorianDate(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      isLeapSecond\n    );\n  }\n\n  result.year = year;\n  result.month = month;\n  result.day = day;\n  result.hour = hour;\n  result.minute = minute;\n  result.second = second;\n  result.millisecond = millisecond;\n  result.isLeapSecond = isLeapSecond;\n  return result;\n};\n\n/**\n * Creates a JavaScript Date from the provided instance.\n * Since JavaScript dates are only accurate to the nearest millisecond and\n * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.\n * If the provided JulianDate is during a leap second, the previous second is used.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @returns {Date} A new instance representing the provided date.\n */\nJulianDate.toDate = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let second = gDate.second;\n  if (gDate.isLeapSecond) {\n    second -= 1;\n  }\n  return new Date(\n    Date.UTC(\n      gDate.year,\n      gDate.month - 1,\n      gDate.day,\n      gDate.hour,\n      gDate.minute,\n      second,\n      gDate.millisecond\n    )\n  );\n};\n\n/**\n * Creates an ISO8601 representation of the provided date.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {String} The ISO8601 representation of the provided date.\n */\nJulianDate.toIso8601 = function (julianDate, precision) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  let year = gDate.year;\n  let month = gDate.month;\n  let day = gDate.day;\n  let hour = gDate.hour;\n  const minute = gDate.minute;\n  const second = gDate.second;\n  const millisecond = gDate.millisecond;\n\n  // special case - Iso8601.MAXIMUM_VALUE produces a string which we can't parse unless we adjust.\n  // 10000-01-01T00:00:00 is the same instant as 9999-12-31T24:00:00\n  if (\n    year === 10000 &&\n    month === 1 &&\n    day === 1 &&\n    hour === 0 &&\n    minute === 0 &&\n    second === 0 &&\n    millisecond === 0\n  ) {\n    year = 9999;\n    month = 12;\n    day = 31;\n    hour = 24;\n  }\n\n  let millisecondStr;\n\n  if (!defined(precision) && millisecond !== 0) {\n    //Forces milliseconds into a number with at least 3 digits to whatever the default toString() precision is.\n    millisecondStr = (millisecond * 0.01).toString().replace(\".\", \"\");\n    return `${year.toString().padStart(4, \"0\")}-${month\n      .toString()\n      .padStart(2, \"0\")}-${day\n      .toString()\n      .padStart(2, \"0\")}T${hour\n      .toString()\n      .padStart(2, \"0\")}:${minute\n      .toString()\n      .padStart(2, \"0\")}:${second\n      .toString()\n      .padStart(2, \"0\")}.${millisecondStr}Z`;\n  }\n\n  //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely\n  if (!defined(precision) || precision === 0) {\n    return `${year.toString().padStart(4, \"0\")}-${month\n      .toString()\n      .padStart(2, \"0\")}-${day\n      .toString()\n      .padStart(2, \"0\")}T${hour\n      .toString()\n      .padStart(2, \"0\")}:${minute\n      .toString()\n      .padStart(2, \"0\")}:${second.toString().padStart(2, \"0\")}Z`;\n  }\n\n  //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.\n  millisecondStr = (millisecond * 0.01)\n    .toFixed(precision)\n    .replace(\".\", \"\")\n    .slice(0, precision);\n  return `${year.toString().padStart(4, \"0\")}-${month\n    .toString()\n    .padStart(2, \"0\")}-${day\n    .toString()\n    .padStart(2, \"0\")}T${hour\n    .toString()\n    .padStart(2, \"0\")}:${minute\n    .toString()\n    .padStart(2, \"0\")}:${second\n    .toString()\n    .padStart(2, \"0\")}.${millisecondStr}Z`;\n};\n\n/**\n * Duplicates a JulianDate instance.\n *\n * @param {JulianDate} julianDate The date to duplicate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.\n */\nJulianDate.clone = function (julianDate, result) {\n  if (!defined(julianDate)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new JulianDate(\n      julianDate.dayNumber,\n      julianDate.secondsOfDay,\n      TimeStandard.TAI\n    );\n  }\n  result.dayNumber = julianDate.dayNumber;\n  result.secondsOfDay = julianDate.secondsOfDay;\n  return result;\n};\n\n/**\n * Compares two instances.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.\n */\nJulianDate.compare = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const julianDayNumberDifference = left.dayNumber - right.dayNumber;\n  if (julianDayNumberDifference !== 0) {\n    return julianDayNumberDifference;\n  }\n  return left.secondsOfDay - right.secondsOfDay;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.dayNumber === right.dayNumber &&\n      left.secondsOfDay === right.secondsOfDay)\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @param {Number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon)\n  );\n};\n\n/**\n * Computes the total number of whole and fractional days represented by the provided instance.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The Julian date as single floating point number.\n */\nJulianDate.totalDays = function (julianDate) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  //>>includeEnd('debug');\n  return (\n    julianDate.dayNumber +\n    julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY\n  );\n};\n\n/**\n * Computes the difference in seconds between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.secondsDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference =\n    (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + (left.secondsOfDay - right.secondsOfDay);\n};\n\n/**\n * Computes the difference in days between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.daysDifference = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const dayDifference = left.dayNumber - right.dayNumber;\n  const secondDifference =\n    (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;\n  return dayDifference + secondDifference;\n};\n\n/**\n * Computes the number of seconds the provided instance is ahead of UTC.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The number of seconds the provided instance is ahead of UTC\n */\nJulianDate.computeTaiMinusUtc = function (julianDate) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  const leapSeconds = JulianDate.leapSeconds;\n  let index = binarySearch(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n  if (index < 0) {\n    index = ~index;\n    --index;\n    if (index < 0) {\n      index = 0;\n    }\n  }\n  return leapSeconds[index].offset;\n};\n\n/**\n * Adds the provided number of seconds to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} seconds The number of seconds to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addSeconds = function (julianDate, seconds, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(seconds)) {\n    throw new DeveloperError(\"seconds is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return setComponents(\n    julianDate.dayNumber,\n    julianDate.secondsOfDay + seconds,\n    result\n  );\n};\n\n/**\n * Adds the provided number of minutes to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} minutes The number of minutes to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addMinutes = function (julianDate, minutes, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(minutes)) {\n    throw new DeveloperError(\"minutes is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay =\n    julianDate.secondsOfDay + minutes * TimeConstants.SECONDS_PER_MINUTE;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of hours to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} hours The number of hours to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addHours = function (julianDate, hours, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(hours)) {\n    throw new DeveloperError(\"hours is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newSecondsOfDay =\n    julianDate.secondsOfDay + hours * TimeConstants.SECONDS_PER_HOUR;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of days to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} days The number of days to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addDays = function (julianDate, days, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(julianDate)) {\n    throw new DeveloperError(\"julianDate is required.\");\n  }\n  if (!defined(days)) {\n    throw new DeveloperError(\"days is required.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"result is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const newJulianDayNumber = julianDate.dayNumber + days;\n  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThan = function (left, right) {\n  return JulianDate.compare(left, right) < 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) <= 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThan = function (left, right) {\n  return JulianDate.compare(left, right) > 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) >= 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.prototype.clone = function (result) {\n  return JulianDate.clone(this, result);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.prototype.equals = function (right) {\n  return JulianDate.equals(this, right);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [right] The second instance.\n * @param {Number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.prototype.equalsEpsilon = function (right, epsilon) {\n  return JulianDate.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this date in ISO8601 format.\n *\n * @returns {String} A string representing this date in ISO8601 format.\n */\nJulianDate.prototype.toString = function () {\n  return JulianDate.toIso8601(this);\n};\n\n/**\n * Gets or sets the list of leap seconds used throughout Cesium.\n * @memberof JulianDate\n * @type {LeapSecond[]}\n */\nJulianDate.leapSeconds = [\n  new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC\n  new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC\n  new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC\n  new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC\n  new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC\n  new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC\n  new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC\n  new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC\n  new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC\n  new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC\n  new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC\n  new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC\n  new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC\n  new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC\n  new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC\n  new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC\n  new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC\n  new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC\n  new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC\n  new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC\n  new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC\n  new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35), // July 1, 2012 00:00:00 UTC\n  new LeapSecond(new JulianDate(2457204, 43236.0, TimeStandard.TAI), 36), // July 1, 2015 00:00:00 UTC\n  new LeapSecond(new JulianDate(2457754, 43237.0, TimeStandard.TAI), 37), // January 1, 2017 00:00:00 UTC\n];\nexport default JulianDate;\n","import Check from \"./Check.js\";\nimport CompressedTextureBuffer from \"./CompressedTextureBuffer.js\";\nimport defined from \"./defined.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\n\n/**\n * Transcodes KTX2 textures using web workers.\n *\n * @private\n */\nfunction KTX2Transcoder() {}\n\nKTX2Transcoder._transcodeTaskProcessor = new TaskProcessor(\n  \"transcodeKTX2\",\n  Number.POSITIVE_INFINITY // KTX2 transcoding is used in place of Resource.fetchImage, so it can't reject as \"just soooo busy right now\"\n);\n\nKTX2Transcoder._readyPromise = undefined;\n\nfunction makeReadyPromise() {\n  const readyPromise = KTX2Transcoder._transcodeTaskProcessor\n    .initWebAssemblyModule({\n      modulePath: \"ThirdParty/Workers/basis_transcoder.js\",\n      wasmBinaryFile: \"ThirdParty/basis_transcoder.wasm\",\n    })\n    .then(function () {\n      return KTX2Transcoder._transcodeTaskProcessor;\n    });\n  KTX2Transcoder._readyPromise = readyPromise;\n}\n\nKTX2Transcoder.transcode = function (ktx2Buffer, supportedTargetFormats) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"supportedTargetFormats\", supportedTargetFormats);\n  //>>includeEnd('debug');\n\n  if (!defined(KTX2Transcoder._readyPromise)) {\n    makeReadyPromise();\n  }\n\n  return KTX2Transcoder._readyPromise\n    .then(function (taskProcessor) {\n      let parameters;\n      if (ktx2Buffer instanceof ArrayBuffer) {\n        const view = new Uint8Array(ktx2Buffer);\n        parameters = {\n          supportedTargetFormats: supportedTargetFormats,\n          ktx2Buffer: view,\n        };\n        return taskProcessor.scheduleTask(parameters, [ktx2Buffer]);\n      }\n      parameters = {\n        supportedTargetFormats: supportedTargetFormats,\n        ktx2Buffer: ktx2Buffer,\n      };\n      return taskProcessor.scheduleTask(parameters, [ktx2Buffer.buffer]);\n    })\n    .then(function (result) {\n      const levelsLength = result.length;\n      const faceKeys = Object.keys(result[0]);\n      const faceKeysLength = faceKeys.length;\n\n      let i;\n      for (i = 0; i < levelsLength; i++) {\n        const faces = result[i];\n        for (let j = 0; j < faceKeysLength; j++) {\n          const face = faces[faceKeys[j]];\n          faces[faceKeys[j]] = new CompressedTextureBuffer(\n            face.internalFormat,\n            face.datatype,\n            face.width,\n            face.height,\n            face.levelBuffer\n          );\n        }\n      }\n\n      // Cleaning up parsed result if it's a single image\n      if (faceKeysLength === 1) {\n        for (i = 0; i < levelsLength; ++i) {\n          result[i] = result[i][faceKeys[0]];\n        }\n\n        if (levelsLength === 1) {\n          result = result[0];\n        }\n      }\n      return result;\n    })\n    .catch(function (error) {\n      throw error;\n    });\n};\n\nexport default KTX2Transcoder;\n","/**\n * This enumerated type is for representing keyboard modifiers. These are keys\n * that are held down in addition to other event types.\n *\n * @enum {Number}\n */\nconst KeyboardEventModifier = {\n  /**\n   * Represents the shift key being held down.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SHIFT: 0,\n\n  /**\n   * Represents the control key being held down.\n   *\n   * @type {Number}\n   * @constant\n   */\n  CTRL: 1,\n\n  /**\n   * Represents the alt key being held down.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ALT: 2,\n};\nexport default Object.freeze(KeyboardEventModifier);\n","import defined from \"./defined.js\";\n\n/**\n * An {@link InterpolationAlgorithm} for performing Lagrange interpolation.\n *\n * @namespace LagrangePolynomialApproximation\n */\nconst LagrangePolynomialApproximation = {\n  type: \"Lagrange\",\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n *\n * @param {Number} degree The desired degree of interpolation.\n * @returns {Number} The number of required data points needed for the desired degree of interpolation.\n */\nLagrangePolynomialApproximation.getRequiredDataPoints = function (degree) {\n  return Math.max(degree + 1.0, 2);\n};\n\n/**\n * Interpolates values using Lagrange Polynomial Approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number[]} [result] An existing array into which to store the result.\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nLagrangePolynomialApproximation.interpolateOrderZero = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  result\n) {\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n\n  let i;\n  let j;\n  const length = xTable.length;\n\n  for (i = 0; i < yStride; i++) {\n    result[i] = 0;\n  }\n\n  for (i = 0; i < length; i++) {\n    let coefficient = 1;\n\n    for (j = 0; j < length; j++) {\n      if (j !== i) {\n        const diffX = xTable[i] - xTable[j];\n        coefficient *= (x - xTable[j]) / diffX;\n      }\n    }\n\n    for (j = 0; j < yStride; j++) {\n      result[j] += coefficient * yTable[i * yStride + j];\n    }\n  }\n\n  return result;\n};\nexport default LagrangePolynomialApproximation;\n","/**\n * Describes a single leap second, which is constructed from a {@link JulianDate} and a\n * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.\n * @alias LeapSecond\n * @constructor\n *\n * @param {JulianDate} [date] A Julian date representing the time of the leap second.\n * @param {Number} [offset] The cumulative number of seconds that TAI is ahead of UTC at the provided date.\n */\nfunction LeapSecond(date, offset) {\n  /**\n   * Gets or sets the date at which this leap second occurs.\n   * @type {JulianDate}\n   */\n  this.julianDate = date;\n\n  /**\n   * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time\n   * of this leap second.\n   * @type {Number}\n   */\n  this.offset = offset;\n}\nexport default LeapSecond;\n","import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * An {@link InterpolationAlgorithm} for performing linear interpolation.\n *\n * @namespace LinearApproximation\n */\nconst LinearApproximation = {\n  type: \"Linear\",\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n * Since linear interpolation can only generate a first degree polynomial, this function\n * always returns 2.\n * @param {Number} degree The desired degree of interpolation.\n * @returns {Number} This function always returns 2.\n *\n */\nLinearApproximation.getRequiredDataPoints = function (degree) {\n  return 2;\n};\n\n/**\n * Interpolates values using linear approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number[]} [result] An existing array into which to store the result.\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nLinearApproximation.interpolateOrderZero = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (xTable.length !== 2) {\n    throw new DeveloperError(\n      \"The xTable provided to the linear interpolator must have exactly two elements.\"\n    );\n  } else if (yStride <= 0) {\n    throw new DeveloperError(\n      \"There must be at least 1 dependent variable for each independent variable.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Array(yStride);\n  }\n\n  let i;\n  let y0;\n  let y1;\n  const x0 = xTable[0];\n  const x1 = xTable[1];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (x0 === x1) {\n    throw new DeveloperError(\n      \"Divide by zero error: xTable[0] and xTable[1] are equal\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  for (i = 0; i < yStride; i++) {\n    y0 = yTable[i];\n    y1 = yTable[i + yStride];\n    result[i] = ((y1 - y0) * x + x1 * y0 - x0 * y1) / (x1 - x0);\n  }\n\n  return result;\n};\nexport default LinearApproximation;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that uses piecewise linear interpolation to create a curve.\n *\n * @alias LinearSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Number[]|Cartesian3[]} options.points The array of control points.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const spline = new Cesium.LinearSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n * @see MorphWeightSpline\n */\nfunction LinearSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const points = options.points;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n  this._pointType = Spline.getPointType(points[0]);\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(LinearSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof LinearSpline.prototype\n   *\n   * @type {Number[]|Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nLinearSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nLinearSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Number|Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nLinearSpline.prototype.evaluate = function (time, result) {\n  const points = this.points;\n  const times = this.times;\n\n  const i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex\n  ));\n  const u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  const PointType = this._pointType;\n  if (PointType === Number) {\n    return (1.0 - u) * points[i] + u * points[i + 1];\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.lerp(points[i], points[i + 1], u, result);\n};\n\nexport default LinearSpline;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\n\n/**\n * A wrapper around arrays so that the internal length of the array can be manually managed.\n *\n * @alias ManagedArray\n * @constructor\n * @private\n *\n * @param {Number} [length=0] The initial length of the array.\n */\nfunction ManagedArray(length) {\n  length = defaultValue(length, 0);\n  this._array = new Array(length);\n  this._length = length;\n}\n\nObject.defineProperties(ManagedArray.prototype, {\n  /**\n   * Gets or sets the length of the array.\n   * If the set length is greater than the length of the internal array, the internal array is resized.\n   *\n   * @memberof ManagedArray.prototype\n   * @type Number\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n    set: function (length) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"length\", length, 0);\n      //>>includeEnd('debug');\n      const array = this._array;\n      const originalLength = this._length;\n      if (length < originalLength) {\n        // Remove trailing references\n        for (let i = length; i < originalLength; ++i) {\n          array[i] = undefined;\n        }\n      } else if (length > array.length) {\n        array.length = length;\n      }\n      this._length = length;\n    },\n  },\n\n  /**\n   * Gets the internal array.\n   *\n   * @memberof ManagedArray.prototype\n   * @type Array\n   * @readonly\n   */\n  values: {\n    get: function () {\n      return this._array;\n    },\n  },\n});\n\n/**\n * Gets the element at an index.\n *\n * @param {Number} index The index to get.\n */\nManagedArray.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.lessThan(\"index\", index, this._array.length);\n  //>>includeEnd('debug');\n\n  return this._array[index];\n};\n\n/**\n * Sets the element at an index. Resizes the array if index is greater than the length of the array.\n *\n * @param {Number} index The index to set.\n * @param {*} element The element to set at index.\n */\nManagedArray.prototype.set = function (index, element) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  //>>includeEnd('debug');\n\n  if (index >= this._length) {\n    this.length = index + 1;\n  }\n  this._array[index] = element;\n};\n\n/**\n * Returns the last element in the array without modifying the array.\n *\n * @returns {*} The last element in the array.\n */\nManagedArray.prototype.peek = function () {\n  return this._array[this._length - 1];\n};\n\n/**\n * Push an element into the array.\n *\n * @param {*} element The element to push.\n */\nManagedArray.prototype.push = function (element) {\n  const index = this.length++;\n  this._array[index] = element;\n};\n\n/**\n * Pop an element from the array.\n *\n * @returns {*} The last element in the array.\n */\nManagedArray.prototype.pop = function () {\n  if (this._length === 0) {\n    return undefined;\n  }\n  const element = this._array[this._length - 1];\n  --this.length;\n  return element;\n};\n\n/**\n * Resize the internal array if length > _array.length.\n *\n * @param {Number} length The length.\n */\nManagedArray.prototype.reserve = function (length) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"length\", length, 0);\n  //>>includeEnd('debug');\n\n  if (length > this._array.length) {\n    this._array.length = length;\n  }\n};\n\n/**\n * Resize the array.\n *\n * @param {Number} length The length.\n */\nManagedArray.prototype.resize = function (length) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"length\", length, 0);\n  //>>includeEnd('debug');\n\n  this.length = length;\n};\n\n/**\n * Trim the internal array to the specified length. Defaults to the current length.\n *\n * @param {Number} [length] The length.\n */\nManagedArray.prototype.trim = function (length) {\n  length = defaultValue(length, this._length);\n  this._array.length = length;\n};\nexport default ManagedArray;\n","import DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Defines how geodetic ellipsoid coordinates ({@link Cartographic}) project to a\n * flat map like Cesium's 2D and Columbus View modes.\n *\n * @alias MapProjection\n * @constructor\n * @abstract\n *\n * @see GeographicProjection\n * @see WebMercatorProjection\n */\nfunction MapProjection() {\n  DeveloperError.throwInstantiationError();\n}\n\nObject.defineProperties(MapProjection.prototype, {\n  /**\n   * Gets the {@link Ellipsoid}.\n   *\n   * @memberof MapProjection.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\n/**\n * Projects {@link Cartographic} coordinates, in radians, to projection-specific map coordinates, in meters.\n *\n * @memberof MapProjection\n * @function\n *\n * @param {Cartographic} cartographic The coordinates to project.\n * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is\n *        undefined, a new instance is created and returned.\n * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the\n *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n *          created and returned.\n */\nMapProjection.prototype.project = DeveloperError.throwInstantiationError;\n\n/**\n * Unprojects projection-specific map {@link Cartesian3} coordinates, in meters, to {@link Cartographic}\n * coordinates, in radians.\n *\n * @memberof MapProjection\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.\n * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is\n *        undefined, a new instance is created and returned.\n * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the\n *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n *          created and returned.\n */\nMapProjection.prototype.unproject = DeveloperError.throwInstantiationError;\nexport default MapProjection;\n","import MersenneTwister from \"../ThirdParty/mersenne-twister.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Math functions.\n *\n * @exports CesiumMath\n * @alias Math\n */\nconst CesiumMath = {};\n\n/**\n * 0.1\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON1 = 0.1;\n\n/**\n * 0.01\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON2 = 0.01;\n\n/**\n * 0.001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON3 = 0.001;\n\n/**\n * 0.0001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON4 = 0.0001;\n\n/**\n * 0.00001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON5 = 0.00001;\n\n/**\n * 0.000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON6 = 0.000001;\n\n/**\n * 0.0000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON7 = 0.0000001;\n\n/**\n * 0.00000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON8 = 0.00000001;\n\n/**\n * 0.000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON9 = 0.000000001;\n\n/**\n * 0.0000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON10 = 0.0000000001;\n\n/**\n * 0.00000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON11 = 0.00000000001;\n\n/**\n * 0.000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON12 = 0.000000000001;\n\n/**\n * 0.0000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON13 = 0.0000000000001;\n\n/**\n * 0.00000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON14 = 0.00000000000001;\n\n/**\n * 0.000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON15 = 0.000000000000001;\n\n/**\n * 0.0000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON16 = 0.0000000000000001;\n\n/**\n * 0.00000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON17 = 0.00000000000000001;\n\n/**\n * 0.000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON18 = 0.000000000000000001;\n\n/**\n * 0.0000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON19 = 0.0000000000000000001;\n\n/**\n * 0.00000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON20 = 0.00000000000000000001;\n\n/**\n * 0.000000000000000000001\n * @type {Number}\n * @constant\n */\nCesiumMath.EPSILON21 = 0.000000000000000000001;\n\n/**\n * The gravitational parameter of the Earth in meters cubed\n * per second squared as defined by the WGS84 model: 3.986004418e14\n * @type {Number}\n * @constant\n */\nCesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;\n\n/**\n * Radius of the sun in meters: 6.955e8\n * @type {Number}\n * @constant\n */\nCesiumMath.SOLAR_RADIUS = 6.955e8;\n\n/**\n * The mean radius of the moon, according to the \"Report of the IAU/IAG Working Group on\n * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000\",\n * Celestial Mechanics 82: 83-110, 2002.\n * @type {Number}\n * @constant\n */\nCesiumMath.LUNAR_RADIUS = 1737400.0;\n\n/**\n * 64 * 1024\n * @type {Number}\n * @constant\n */\nCesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;\n\n/**\n * 4 * 1024 * 1024 * 1024\n * @type {Number}\n * @constant\n */\nCesiumMath.FOUR_GIGABYTES = 4 * 1024 * 1024 * 1024;\n\n/**\n * Returns the sign of the value; 1 if the value is positive, -1 if the value is\n * negative, or 0 if the value is 0.\n *\n * @function\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\n// eslint-disable-next-line es/no-math-sign\nCesiumMath.sign = defaultValue(Math.sign, function sign(value) {\n  value = +value; // coerce to number\n  if (value === 0 || value !== value) {\n    // zero or NaN\n    return value;\n  }\n  return value > 0 ? 1 : -1;\n});\n\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\nCesiumMath.signNotZero = function (value) {\n  return value < 0.0 ? -1.0 : 1.0;\n};\n\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]\n * @param {Number} value The scalar value in the range [-1.0, 1.0]\n * @param {Number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns {Number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nCesiumMath.toSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return Math.round(\n    (CesiumMath.clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum\n  );\n};\n\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n * @param {Number} value SNORM value in the range [0, rangeMaximum]\n * @param {Number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns {Number} Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nCesiumMath.fromSNorm = function (value, rangeMaximum) {\n  rangeMaximum = defaultValue(rangeMaximum, 255);\n  return (\n    (CesiumMath.clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0\n  );\n};\n\n/**\n * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]\n * @param {Number} value The scalar value in the range [rangeMinimum, rangeMaximum]\n * @param {Number} rangeMinimum The minimum value in the mapped range.\n * @param {Number} rangeMaximum The maximum value in the mapped range.\n * @returns {Number} A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.\n */\nCesiumMath.normalize = function (value, rangeMinimum, rangeMaximum) {\n  rangeMaximum = Math.max(rangeMaximum - rangeMinimum, 0.0);\n  return rangeMaximum === 0.0\n    ? 0.0\n    : CesiumMath.clamp((value - rangeMinimum) / rangeMaximum, 0.0, 1.0);\n};\n\n/**\n * Returns the hyperbolic sine of a number.\n * The hyperbolic sine of <em>value</em> is defined to be\n * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is an infinity\n *     with the same sign as the argument.</li>\n *\n *     <li>If the argument is zero, then the result is a zero with the\n *     same sign as the argument.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {Number} value The number whose hyperbolic sine is to be returned.\n * @returns {Number} The hyperbolic sine of <code>value</code>.\n */\n// eslint-disable-next-line es/no-math-sinh\nCesiumMath.sinh = defaultValue(Math.sinh, function sinh(value) {\n  return (Math.exp(value) - Math.exp(-value)) / 2.0;\n});\n\n/**\n * Returns the hyperbolic cosine of a number.\n * The hyperbolic cosine of <strong>value</strong> is defined to be\n * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0\n * where <i>e</i> is Euler's number, approximately 2.71828183.\n *\n * <p>Special cases:\n *   <ul>\n *     <li>If the argument is NaN, then the result is NaN.</li>\n *\n *     <li>If the argument is infinite, then the result is positive infinity.</li>\n *\n *     <li>If the argument is zero, then the result is 1.0.</li>\n *   </ul>\n *</p>\n *\n * @function\n * @param {Number} value The number whose hyperbolic cosine is to be returned.\n * @returns {Number} The hyperbolic cosine of <code>value</code>.\n */\n// eslint-disable-next-line es/no-math-cosh\nCesiumMath.cosh = defaultValue(Math.cosh, function cosh(value) {\n  return (Math.exp(value) + Math.exp(-value)) / 2.0;\n});\n\n/**\n * Computes the linear interpolation of two values.\n *\n * @param {Number} p The start value to interpolate.\n * @param {Number} q The end value to interpolate.\n * @param {Number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.\n * @returns {Number} The linearly interpolated value.\n *\n * @example\n * const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0\n */\nCesiumMath.lerp = function (p, q, time) {\n  return (1.0 - time) * p + time * q;\n};\n\n/**\n * pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI = Math.PI;\n\n/**\n * 1/pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.ONE_OVER_PI = 1.0 / Math.PI;\n\n/**\n * pi/2\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_TWO = Math.PI / 2.0;\n\n/**\n * pi/3\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_THREE = Math.PI / 3.0;\n\n/**\n * pi/4\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_FOUR = Math.PI / 4.0;\n\n/**\n * pi/6\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.PI_OVER_SIX = Math.PI / 6.0;\n\n/**\n * 3pi/2\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) / 2.0;\n\n/**\n * 2pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.TWO_PI = 2.0 * Math.PI;\n\n/**\n * 1/2pi\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);\n\n/**\n * The number of radians in a degree.\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;\n\n/**\n * The number of degrees in a radian.\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;\n\n/**\n * The number of radians in an arc second.\n *\n * @type {Number}\n * @constant\n */\nCesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600.0;\n\n/**\n * Converts degrees to radians.\n * @param {Number} degrees The angle to convert in degrees.\n * @returns {Number} The corresponding angle in radians.\n */\nCesiumMath.toRadians = function (degrees) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(degrees)) {\n    throw new DeveloperError(\"degrees is required.\");\n  }\n  //>>includeEnd('debug');\n  return degrees * CesiumMath.RADIANS_PER_DEGREE;\n};\n\n/**\n * Converts radians to degrees.\n * @param {Number} radians The angle to convert in radians.\n * @returns {Number} The corresponding angle in degrees.\n */\nCesiumMath.toDegrees = function (radians) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(radians)) {\n    throw new DeveloperError(\"radians is required.\");\n  }\n  //>>includeEnd('debug');\n  return radians * CesiumMath.DEGREES_PER_RADIAN;\n};\n\n/**\n * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n * @returns {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).\n *\n * @example\n * // Convert 270 degrees to -90 degrees longitude\n * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));\n */\nCesiumMath.convertLongitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  const twoPi = CesiumMath.TWO_PI;\n\n  const simplified = angle - Math.floor(angle / twoPi) * twoPi;\n\n  if (simplified < -Math.PI) {\n    return simplified + twoPi;\n  }\n  if (simplified >= Math.PI) {\n    return simplified - twoPi;\n  }\n\n  return simplified;\n};\n\n/**\n * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * Useful for sanitizing data before use in objects requiring correct range.\n *\n * @param {Number} angle The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n * @returns {Number} The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).\n *\n * @example\n * // Clamp 108 degrees latitude to 90 degrees latitude\n * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));\n */\nCesiumMath.clampToLatitudeRange = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return CesiumMath.clamp(\n    angle,\n    -1 * CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO\n  );\n};\n\n/**\n * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.\n *\n * @param {Number} angle in radians\n * @returns {Number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].\n */\nCesiumMath.negativePiToPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= -CesiumMath.PI && angle <= CesiumMath.PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  return CesiumMath.zeroToTwoPi(angle + CesiumMath.PI) - CesiumMath.PI;\n};\n\n/**\n * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.\n *\n * @param {Number} angle in radians\n * @returns {Number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].\n */\nCesiumMath.zeroToTwoPi = function (angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  //>>includeEnd('debug');\n  if (angle >= 0 && angle <= CesiumMath.TWO_PI) {\n    // Early exit if the input is already inside the range. This avoids\n    // unnecessary math which could introduce floating point error.\n    return angle;\n  }\n  const mod = CesiumMath.mod(angle, CesiumMath.TWO_PI);\n  if (\n    Math.abs(mod) < CesiumMath.EPSILON14 &&\n    Math.abs(angle) > CesiumMath.EPSILON14\n  ) {\n    return CesiumMath.TWO_PI;\n  }\n  return mod;\n};\n\n/**\n * The modulo operation that also works for negative dividends.\n *\n * @param {Number} m The dividend.\n * @param {Number} n The divisor.\n * @returns {Number} The remainder.\n */\nCesiumMath.mod = function (m, n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(m)) {\n    throw new DeveloperError(\"m is required.\");\n  }\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  if (n === 0.0) {\n    throw new DeveloperError(\"divisor cannot be 0.\");\n  }\n  //>>includeEnd('debug');\n  if (CesiumMath.sign(m) === CesiumMath.sign(n) && Math.abs(m) < Math.abs(n)) {\n    // Early exit if the input does not need to be modded. This avoids\n    // unnecessary math which could introduce floating point error.\n    return m;\n  }\n\n  return ((m % n) + n) % n;\n};\n\n/**\n * Determines if two values are equal using an absolute or relative tolerance test. This is useful\n * to avoid problems due to roundoff error when comparing floating-point values directly. The values are\n * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.\n * Use this test if you are unsure of the magnitudes of left and right.\n *\n * @param {Number} left The first value to compare.\n * @param {Number} right The other value to compare.\n * @param {Number} [relativeEpsilon=0] The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.\n * @returns {Boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.\n *\n * @example\n * const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true\n * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false\n * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true\n * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false\n */\nCesiumMath.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"left is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"right is required.\");\n  }\n  //>>includeEnd('debug');\n\n  relativeEpsilon = defaultValue(relativeEpsilon, 0.0);\n  absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);\n  const absDiff = Math.abs(left - right);\n  return (\n    absDiff <= absoluteEpsilon ||\n    absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right))\n  );\n};\n\n/**\n * Determines if the left value is less than the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is less than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two\n *          values are nearly equal.\n */\nCesiumMath.lessThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < -absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is less than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is less than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.lessThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right < absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> by more than\n *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two\n *          values are nearly equal.\n */\nCesiumMath.greaterThan = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > absoluteEpsilon;\n};\n\n/**\n * Determines if the left value is greater than or equal to the right value. If the two values are within\n * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.\n *\n * @param {Number} left The first number to compare.\n * @param {Number} right The second number to compare.\n * @param {Number} absoluteEpsilon The absolute epsilon to use in comparison.\n * @returns {Boolean} <code>true</code> if <code>left</code> is greater than <code>right</code> or if the\n *          the values are nearly equal.\n */\nCesiumMath.greaterThanOrEquals = function (left, right, absoluteEpsilon) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(left)) {\n    throw new DeveloperError(\"first is required.\");\n  }\n  if (!defined(right)) {\n    throw new DeveloperError(\"second is required.\");\n  }\n  if (!defined(absoluteEpsilon)) {\n    throw new DeveloperError(\"absoluteEpsilon is required.\");\n  }\n  //>>includeEnd('debug');\n  return left - right > -absoluteEpsilon;\n};\n\nconst factorials = [1];\n\n/**\n * Computes the factorial of the provided number.\n *\n * @param {Number} n The number whose factorial is to be computed.\n * @returns {Number} The factorial of the provided number or undefined if the number is less than 0.\n *\n * @exception {DeveloperError} A number greater than or equal to 0 is required.\n *\n *\n * @example\n * //Compute 7!, which is equal to 5040\n * const computedFactorial = Cesium.Math.factorial(7);\n *\n * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}\n */\nCesiumMath.factorial = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0) {\n    throw new DeveloperError(\n      \"A number greater than or equal to 0 is required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const length = factorials.length;\n  if (n >= length) {\n    let sum = factorials[length - 1];\n    for (let i = length; i <= n; i++) {\n      const next = sum * i;\n      factorials.push(next);\n      sum = next;\n    }\n  }\n  return factorials[n];\n};\n\n/**\n * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.\n *\n * @param {Number} [n] The number to be incremented.\n * @param {Number} [maximumValue] The maximum incremented value before rolling over to the minimum value.\n * @param {Number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.\n * @returns {Number} The incremented number.\n *\n * @exception {DeveloperError} Maximum value must be greater than minimum value.\n *\n * @example\n * const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6\n * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0\n */\nCesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {\n  minimumValue = defaultValue(minimumValue, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(n)) {\n    throw new DeveloperError(\"n is required.\");\n  }\n  if (maximumValue <= minimumValue) {\n    throw new DeveloperError(\"maximumValue must be greater than minimumValue.\");\n  }\n  //>>includeEnd('debug');\n\n  ++n;\n  if (n > maximumValue) {\n    n = minimumValue;\n  }\n  return n;\n};\n\n/**\n * Determines if a non-negative integer is a power of two.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {Number} n The integer to test in the range [0, (2^32)-1].\n * @returns {Boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const t = Cesium.Math.isPowerOfTwo(16); // true\n * const f = Cesium.Math.isPowerOfTwo(20); // false\n */\nCesiumMath.isPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return n !== 0 && (n & (n - 1)) === 0;\n};\n\n/**\n * Computes the next power-of-two integer greater than or equal to the provided non-negative integer.\n * The maximum allowed input is 2^31 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {Number} n The integer to test in the range [0, 2^31].\n * @returns {Number} The next power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and 2^31 is required.\n *\n * @example\n * const n = Cesium.Math.nextPowerOfTwo(29); // 32\n * const m = Cesium.Math.nextPowerOfTwo(32); // 32\n */\nCesiumMath.nextPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 2147483648) {\n    throw new DeveloperError(\"A number between 0 and 2^31 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // From http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n  --n;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  ++n;\n\n  return n;\n};\n\n/**\n * Computes the previous power-of-two integer less than or equal to the provided non-negative integer.\n * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.\n *\n * @param {Number} n The integer to test in the range [0, (2^32)-1].\n * @returns {Number} The previous power-of-two integer.\n *\n * @exception {DeveloperError} A number between 0 and (2^32)-1 is required.\n *\n * @example\n * const n = Cesium.Math.previousPowerOfTwo(29); // 16\n * const m = Cesium.Math.previousPowerOfTwo(32); // 32\n */\nCesiumMath.previousPowerOfTwo = function (n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof n !== \"number\" || n < 0 || n > 4294967295) {\n    throw new DeveloperError(\"A number between 0 and (2^32)-1 is required.\");\n  }\n  //>>includeEnd('debug');\n\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n\n  // The previous bitwise operations implicitly convert to signed 32-bit. Use `>>>` to convert to unsigned\n  n = (n >>> 0) - (n >>> 1);\n\n  return n;\n};\n\n/**\n * Constraint a value to lie between two values.\n *\n * @param {Number} value The value to clamp.\n * @param {Number} min The minimum value.\n * @param {Number} max The maximum value.\n * @returns {Number} The clamped value such that min <= result <= max.\n */\nCesiumMath.clamp = function (value, min, max) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  Check.typeOf.number(\"min\", min);\n  Check.typeOf.number(\"max\", max);\n  //>>includeEnd('debug');\n\n  return value < min ? min : value > max ? max : value;\n};\n\nlet randomNumberGenerator = new MersenneTwister();\n\n/**\n * Sets the seed used by the random number generator\n * in {@link CesiumMath#nextRandomNumber}.\n *\n * @param {Number} seed An integer used as the seed.\n */\nCesiumMath.setRandomNumberSeed = function (seed) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(seed)) {\n    throw new DeveloperError(\"seed is required.\");\n  }\n  //>>includeEnd('debug');\n\n  randomNumberGenerator = new MersenneTwister(seed);\n};\n\n/**\n * Generates a random floating point number in the range of [0.0, 1.0)\n * using a Mersenne twister.\n *\n * @returns {Number} A random number in the range of [0.0, 1.0).\n *\n * @see CesiumMath.setRandomNumberSeed\n * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}\n */\nCesiumMath.nextRandomNumber = function () {\n  return randomNumberGenerator.random();\n};\n\n/**\n * Generates a random number between two numbers.\n *\n * @param {Number} min The minimum value.\n * @param {Number} max The maximum value.\n * @returns {Number} A random number between the min and max.\n */\nCesiumMath.randomBetween = function (min, max) {\n  return CesiumMath.nextRandomNumber() * (max - min) + min;\n};\n\n/**\n * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {Number} value The value for which to compute acos.\n * @returns {Number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.acosClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.acos(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]\n * so that the function will never return NaN.\n *\n * @param {Number} value The value for which to compute asin.\n * @returns {Number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,\n *          whichever is closer, if the value is outside the range.\n */\nCesiumMath.asinClamped = function (value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.asin(CesiumMath.clamp(value, -1.0, 1.0));\n};\n\n/**\n * Finds the chord length between two points given the circle's radius and the angle between the points.\n *\n * @param {Number} angle The angle between the two points.\n * @param {Number} radius The radius of the circle.\n * @returns {Number} The chord length.\n */\nCesiumMath.chordLength = function (angle, radius) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(angle)) {\n    throw new DeveloperError(\"angle is required.\");\n  }\n  if (!defined(radius)) {\n    throw new DeveloperError(\"radius is required.\");\n  }\n  //>>includeEnd('debug');\n  return 2.0 * radius * Math.sin(angle * 0.5);\n};\n\n/**\n * Finds the logarithm of a number to a base.\n *\n * @param {Number} number The number.\n * @param {Number} base The base.\n * @returns {Number} The result.\n */\nCesiumMath.logBase = function (number, base) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(number)) {\n    throw new DeveloperError(\"number is required.\");\n  }\n  if (!defined(base)) {\n    throw new DeveloperError(\"base is required.\");\n  }\n  //>>includeEnd('debug');\n  return Math.log(number) / Math.log(base);\n};\n\n/**\n * Finds the cube root of a number.\n * Returns NaN if <code>number</code> is not provided.\n *\n * @function\n * @param {Number} [number] The number.\n * @returns {Number} The result.\n */\n// eslint-disable-next-line es/no-math-cbrt\nCesiumMath.cbrt = defaultValue(Math.cbrt, function cbrt(number) {\n  const result = Math.pow(Math.abs(number), 1.0 / 3.0);\n  return number < 0.0 ? -result : result;\n});\n\n/**\n * Finds the base 2 logarithm of a number.\n *\n * @function\n * @param {Number} number The number.\n * @returns {Number} The result.\n */\n// eslint-disable-next-line es/no-math-log2\nCesiumMath.log2 = defaultValue(Math.log2, function log2(number) {\n  return Math.log(number) * Math.LOG2E;\n});\n\n/**\n * @private\n */\nCesiumMath.fog = function (distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n};\n\n/**\n * Computes a fast approximation of Atan for input in the range [-1, 1].\n *\n * Based on Michal Drobot's approximation from ShaderFastLibs,\n * which in turn is based on \"Efficient approximations for the arctangent function,\"\n * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\n * Adapted from ShaderFastLibs under MIT License.\n *\n * @param {Number} x An input number in the range [-1, 1]\n * @returns {Number} An approximation of atan(x)\n */\nCesiumMath.fastApproximateAtan = function (x) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  //>>includeEnd('debug');\n\n  return x * (-0.1784 * Math.abs(x) - 0.0663 * x * x + 1.0301);\n};\n\n/**\n * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.\n *\n * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html\n *\n * @param {Number} x An input number that isn't zero if y is zero.\n * @param {Number} y An input number that isn't zero if x is zero.\n * @returns {Number} An approximation of atan2(x, y)\n */\nCesiumMath.fastApproximateAtan2 = function (x, y) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  //>>includeEnd('debug');\n\n  // atan approximations are usually only reliable over [-1, 1]\n  // So reduce the range by flipping whether x or y is on top based on which is bigger.\n  let opposite;\n  let t = Math.abs(x); // t used as swap and atan result.\n  opposite = Math.abs(y);\n  const adjacent = Math.max(t, opposite);\n  opposite = Math.min(t, opposite);\n\n  const oppositeOverAdjacent = opposite / adjacent;\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(oppositeOverAdjacent)) {\n    throw new DeveloperError(\"either x or y must be nonzero\");\n  }\n  //>>includeEnd('debug');\n  t = CesiumMath.fastApproximateAtan(oppositeOverAdjacent);\n\n  // Undo range reduction\n  t = Math.abs(y) > Math.abs(x) ? CesiumMath.PI_OVER_TWO - t : t;\n  t = x < 0.0 ? CesiumMath.PI - t : t;\n  t = y < 0.0 ? -t : t;\n  return t;\n};\nexport default CesiumMath;\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * A 2x2 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix2\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n *\n * @see Matrix2.fromArray\n * @see Matrix2.fromColumnMajorArray\n * @see Matrix2.fromRowMajorArray\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.fromRotation\n * @see Matrix3\n * @see Matrix4\n */\nfunction Matrix2(column0Row0, column1Row0, column0Row1, column1Row1) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column1Row0, 0.0);\n  this[3] = defaultValue(column1Row1, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix2.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix2} [result] The object into which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix2();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix2s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix2[]} array The array of matrices to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n * @returns {Number[]} The packed array.\n */\nMatrix2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 4 elements\"\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Matrix2.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix2s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Matrix2[]} [result] The array onto which to store the result.\n * @returns {Matrix2[]} The unpacked array.\n */\nMatrix2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (let i = 0; i < length; i += 4) {\n    const index = i / 4;\n    result[index] = Matrix2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix2 instance.\n *\n * @param {Matrix2} matrix The matrix to duplicate.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix2.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix2(matrix[0], matrix[2], matrix[1], matrix[3]);\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Creates a Matrix2 from 4 consecutive elements in an array.\n *\n * @function\n * @param {Number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Create the Matrix2:\n * // [1.0, 2.0]\n * // [1.0, 2.0]\n *\n * const v = [1.0, 1.0, 2.0, 2.0];\n * const m = Cesium.Matrix2.fromArray(v);\n *\n * // Create same Matrix2 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];\n * const m2 = Cesium.Matrix2.fromArray(v2, 2);\n */\nMatrix2.fromArray = Matrix2.unpack;\n/**\n * Creates a Matrix2 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix2.clone(values, result);\n};\n\n/**\n * Creates a Matrix2 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n */\nMatrix2.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(values[0], values[1], values[2], values[3]);\n  }\n  result[0] = values[0];\n  result[1] = values[2];\n  result[2] = values[1];\n  result[3] = values[3];\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a non-uniform scale.\n *\n * @param {Cartesian2} scale The x and y scale factors.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0]\n * //   [0.0, 8.0]\n * const m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));\n */\nMatrix2.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale.x, 0.0, 0.0, scale.y);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale.y;\n  return result;\n};\n\n/**\n * Computes a Matrix2 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0]\n * //   [0.0, 2.0]\n * const m = Cesium.Matrix2.fromUniformScale(2.0);\n */\nMatrix2.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix2(scale, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = scale;\n  return result;\n};\n\n/**\n * Creates a rotation matrix.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise.\n * const p = new Cesium.Cartesian2(5, 6);\n * const m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());\n */\nMatrix2.fromRotation = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);\n  }\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = -sinAngle;\n  result[3] = cosAngle;\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix2 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix2} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix2.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [matrix[0], matrix[1], matrix[2], matrix[3]];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0 or 1.\n * @exception {DeveloperError} column must be 0 or 1.\n *\n * @example\n * const myMatrix = new Cesium.Matrix2();\n * const column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix2.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 1);\n\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 1);\n  //>>includeEnd('debug');\n\n  return column * 2 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 2;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  const startIndex = index * 2;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 2];\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0 or 1.\n */\nMatrix2.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 1);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix2.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 2] = cartesian.y;\n  return result;\n};\n\nconst scaleScratch1 = new Cartesian2();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Cartesian2} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix2.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioY;\n  result[3] = matrix[3] * scaleRatioY;\n\n  return result;\n};\n\nconst scaleScratch2 = new Cartesian2();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix to use.\n * @param {Number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix2.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioY;\n  result[3] = matrix[3] * scaleRatioY;\n\n  return result;\n};\n\nconst scratchColumn = new Cartesian2();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n *\n * @see Matrix2.multiplyByScale\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n */\nMatrix2.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn)\n  );\n  result.y = Cartesian2.magnitude(\n    Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn)\n  );\n  return result;\n};\n\nconst scaleScratch3 = new Cartesian2();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix2} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix2.getMaximumScale = function (matrix) {\n  Matrix2.getScale(matrix, scaleScratch3);\n  return Cartesian2.maximumComponent(scaleScratch3);\n};\n\nconst scaleScratch4 = new Cartesian2();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Matrix2} rotation The rotation matrix.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.fromRotation\n * @see Matrix2.getRotation\n */\nMatrix2.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix2.getScale(matrix, scaleScratch4);\n\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.y;\n  result[3] = rotation[3] * scale.y;\n\n  return result;\n};\n\nconst scaleScratch5 = new Cartesian2();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @see Matrix2.setRotation\n * @see Matrix2.fromRotation\n */\nMatrix2.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix2.getScale(matrix, scaleScratch5);\n\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.y;\n  result[3] = matrix[3] / scale.y;\n\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = left[0] * right[0] + left[2] * right[1];\n  const column1Row0 = left[0] * right[2] + left[2] * right[3];\n  const column0Row1 = left[1] * right[0] + left[3] * right[1];\n  const column1Row1 = left[1] * right[2] + left[3] * right[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix2} left The first matrix.\n * @param {Matrix2} right The second matrix.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Cartesian2} cartesian The column.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nMatrix2.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;\n  const y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix2} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {Number} scale The non-uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);\n * Cesium.Matrix2.multiplyByScale(m, scale, m);\n *\n * @see Matrix2.multiplyByUniformScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.y;\n  result[3] = matrix[3] * scale.y;\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix2} matrix The matrix on the left-hand side.\n * @param {Number} scale The uniform scale on the right-hand side.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromUniformScale(scale), m);\n * Cesium.Matrix2.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix2.multiplyByScale\n * @see Matrix2.fromScale\n * @see Matrix2.fromUniformScale\n * @see Matrix2.setScale\n * @see Matrix2.setUniformScale\n * @see Matrix2.getScale\n */\nMatrix2.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3] * scale;\n\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to negate.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix2} matrix The matrix to transpose.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = matrix[0];\n  const column0Row1 = matrix[2];\n  const column1Row0 = matrix[1];\n  const column1Row1 = matrix[3];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column1Row0;\n  result[3] = column1Row1;\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix2} matrix The matrix with signed elements.\n * @param {Matrix2} result The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter.\n */\nMatrix2.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3])\n  );\n};\n\n/**\n * @private\n */\nMatrix2.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [left] The first matrix.\n * @param {Matrix2} [right] The second matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix2 instance initialized to the identity matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));\n\n/**\n * An immutable Matrix2 instance initialized to the zero matrix.\n *\n * @type {Matrix2}\n * @constant\n */\nMatrix2.ZERO = Object.freeze(new Matrix2(0.0, 0.0, 0.0, 0.0));\n\n/**\n * The index into Matrix2 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0\n */\nMatrix2.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix2 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0\n */\nMatrix2.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix2 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0\n */\nMatrix2.COLUMN1ROW0 = 2;\n\n/**\n * The index into Matrix2 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n *\n * @example\n * const matrix = new Cesium.Matrix2();\n * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0\n */\nMatrix2.COLUMN1ROW1 = 3;\n\nObject.defineProperties(Matrix2.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix2.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix2.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix2 instance.\n *\n * @param {Matrix2} [result] The object onto which to store the result.\n * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.\n */\nMatrix2.prototype.clone = function (result) {\n  return Matrix2.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix2.prototype.equals = function (right) {\n  return Matrix2.equals(this, right);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix2} [right] The right hand side matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix2.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix2.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.\n */\nMatrix2.prototype.toString = function () {\n  return `(${this[0]}, ${this[2]})\\n` + `(${this[1]}, ${this[3]})`;\n};\nexport default Matrix2;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 3x3 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix3\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n *\n * @see Matrix3.fromArray\n * @see Matrix3.fromColumnMajorArray\n * @see Matrix3.fromRowMajorArray\n * @see Matrix3.fromQuaternion\n * @see Matrix3.fromHeadingPitchRoll\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.fromCrossProduct\n * @see Matrix3.fromRotationX\n * @see Matrix3.fromRotationY\n * @see Matrix3.fromRotationZ\n * @see Matrix2\n * @see Matrix4\n */\nfunction Matrix3(\n  column0Row0,\n  column1Row0,\n  column2Row0,\n  column0Row1,\n  column1Row1,\n  column2Row1,\n  column0Row2,\n  column1Row2,\n  column2Row2\n) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column0Row2, 0.0);\n  this[3] = defaultValue(column1Row0, 0.0);\n  this[4] = defaultValue(column1Row1, 0.0);\n  this[5] = defaultValue(column1Row2, 0.0);\n  this[6] = defaultValue(column2Row0, 0.0);\n  this[7] = defaultValue(column2Row1, 0.0);\n  this[8] = defaultValue(column2Row2, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix3.packedLength = 9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix3.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix3} [result] The object into which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix3();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix3s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix3[]} array The array of matrices to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 9 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 9) elements.\n * @returns {Number[]} The packed array.\n */\nMatrix3.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 9;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 9 elements\"\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Matrix3.pack(array[i], result, i * 9);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix3s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Matrix3[]} [result] The array onto which to store the result.\n * @returns {Matrix3[]} The unpacked array.\n */\nMatrix3.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 9);\n  if (array.length % 9 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 9.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 9);\n  } else {\n    result.length = length / 9;\n  }\n\n  for (let i = 0; i < length; i += 9) {\n    const index = i / 9;\n    result[index] = Matrix3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix3 instance.\n *\n * @param {Matrix3} matrix The matrix to duplicate.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix3.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix3(\n      matrix[0],\n      matrix[3],\n      matrix[6],\n      matrix[1],\n      matrix[4],\n      matrix[7],\n      matrix[2],\n      matrix[5],\n      matrix[8]\n    );\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Creates a Matrix3 from 9 consecutive elements in an array.\n *\n * @function\n * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Create the Matrix3:\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n * // [1.0, 2.0, 3.0]\n *\n * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m = Cesium.Matrix3.fromArray(v);\n *\n * // Create same Matrix3 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];\n * const m2 = Cesium.Matrix3.fromArray(v2, 2);\n */\nMatrix3.fromArray = Matrix3.unpack;\n\n/**\n * Creates a Matrix3 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix3.clone(values, result);\n};\n\n/**\n * Creates a Matrix3 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n */\nMatrix3.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      values[0],\n      values[1],\n      values[2],\n      values[3],\n      values[4],\n      values[5],\n      values[6],\n      values[7],\n      values[8]\n    );\n  }\n  result[0] = values[0];\n  result[1] = values[3];\n  result[2] = values[6];\n  result[3] = values[1];\n  result[4] = values[4];\n  result[5] = values[7];\n  result[6] = values[2];\n  result[7] = values[5];\n  result[8] = values[8];\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided quaternion.\n *\n * @param {Quaternion} quaternion the quaternion to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.\n */\nMatrix3.fromQuaternion = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  const x2 = quaternion.x * quaternion.x;\n  const xy = quaternion.x * quaternion.y;\n  const xz = quaternion.x * quaternion.z;\n  const xw = quaternion.x * quaternion.w;\n  const y2 = quaternion.y * quaternion.y;\n  const yz = quaternion.y * quaternion.z;\n  const yw = quaternion.y * quaternion.w;\n  const z2 = quaternion.z * quaternion.z;\n  const zw = quaternion.z * quaternion.w;\n  const w2 = quaternion.w * quaternion.w;\n\n  const m00 = x2 - y2 - z2 + w2;\n  const m01 = 2.0 * (xy - zw);\n  const m02 = 2.0 * (xz + yw);\n\n  const m10 = 2.0 * (xy + zw);\n  const m11 = -x2 + y2 - z2 + w2;\n  const m12 = 2.0 * (yz - xw);\n\n  const m20 = 2.0 * (xz - yw);\n  const m21 = 2.0 * (yz + xw);\n  const m22 = -x2 - y2 + z2 + w2;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )\n *\n * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.\n */\nMatrix3.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  const cosTheta = Math.cos(-headingPitchRoll.pitch);\n  const cosPsi = Math.cos(-headingPitchRoll.heading);\n  const cosPhi = Math.cos(headingPitchRoll.roll);\n  const sinTheta = Math.sin(-headingPitchRoll.pitch);\n  const sinPsi = Math.sin(-headingPitchRoll.heading);\n  const sinPhi = Math.sin(headingPitchRoll.roll);\n\n  const m00 = cosTheta * cosPsi;\n  const m01 = -cosPhi * sinPsi + sinPhi * sinTheta * cosPsi;\n  const m02 = sinPhi * sinPsi + cosPhi * sinTheta * cosPsi;\n\n  const m10 = cosTheta * sinPsi;\n  const m11 = cosPhi * cosPsi + sinPhi * sinTheta * sinPsi;\n  const m12 = -sinPhi * cosPsi + cosPhi * sinTheta * sinPsi;\n\n  const m20 = -sinTheta;\n  const m21 = sinPhi * cosTheta;\n  const m22 = cosPhi * cosTheta;\n\n  if (!defined(result)) {\n    return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n  }\n  result[0] = m00;\n  result[1] = m10;\n  result[2] = m20;\n  result[3] = m01;\n  result[4] = m11;\n  result[5] = m21;\n  result[6] = m02;\n  result[7] = m12;\n  result[8] = m22;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0]\n * //   [0.0, 0.0, 9.0]\n * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale.x, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, scale.z);\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale.y;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale.z;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 2.0]\n * const m = Cesium.Matrix3.fromUniformScale(2.0);\n */\nMatrix3.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(scale, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, scale);\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = scale;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = scale;\n  return result;\n};\n\n/**\n * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.\n *\n * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [0.0, -9.0,  8.0]\n * //   [9.0,  0.0, -7.0]\n * //   [-8.0, 7.0,  0.0]\n * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix3.fromCrossProduct = function (vector, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"vector\", vector);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix3(\n      0.0,\n      -vector.z,\n      vector.y,\n      vector.z,\n      0.0,\n      -vector.x,\n      -vector.y,\n      vector.x,\n      0.0\n    );\n  }\n\n  result[0] = 0.0;\n  result[1] = vector.z;\n  result[2] = -vector.y;\n  result[3] = -vector.z;\n  result[4] = 0.0;\n  result[5] = vector.x;\n  result[6] = vector.y;\n  result[7] = -vector.x;\n  result[8] = 0.0;\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the x-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the x-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationX = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      1.0,\n      0.0,\n      0.0,\n      0.0,\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle\n    );\n  }\n\n  result[0] = 1.0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = cosAngle;\n  result[5] = sinAngle;\n  result[6] = 0.0;\n  result[7] = -sinAngle;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the y-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the y-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationY = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      0.0,\n      sinAngle,\n      0.0,\n      1.0,\n      0.0,\n      -sinAngle,\n      0.0,\n      cosAngle\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = 0.0;\n  result[2] = -sinAngle;\n  result[3] = 0.0;\n  result[4] = 1.0;\n  result[5] = 0.0;\n  result[6] = sinAngle;\n  result[7] = 0.0;\n  result[8] = cosAngle;\n\n  return result;\n};\n\n/**\n * Creates a rotation matrix around the z-axis.\n *\n * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.\n * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.\n *\n * @example\n * // Rotate a point 45 degrees counterclockwise around the z-axis.\n * const p = new Cesium.Cartesian3(5, 6, 7);\n * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));\n * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());\n */\nMatrix3.fromRotationZ = function (angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n\n  if (!defined(result)) {\n    return new Matrix3(\n      cosAngle,\n      -sinAngle,\n      0.0,\n      sinAngle,\n      cosAngle,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = cosAngle;\n  result[1] = sinAngle;\n  result[2] = 0.0;\n  result[3] = -sinAngle;\n  result[4] = cosAngle;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n\n  return result;\n};\n\n/**\n * Creates an Array from the provided Matrix3 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix3} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n */\nMatrix3.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [\n      matrix[0],\n      matrix[1],\n      matrix[2],\n      matrix[3],\n      matrix[4],\n      matrix[5],\n      matrix[6],\n      matrix[7],\n      matrix[8],\n    ];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} column The zero-based index of the column.\n * @param {Number} row The zero-based index of the row.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, or 2.\n * @exception {DeveloperError} column must be 0, 1, or 2.\n *\n * @example\n * const myMatrix = new Cesium.Matrix3();\n * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index]\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix3.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 2);\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 2);\n  //>>includeEnd('debug');\n\n  return column * 3 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 3;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n  const z = matrix[startIndex + 2];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  const startIndex = index * 3;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 3];\n  const z = matrix[index + 6];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, or 2.\n */\nMatrix3.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 2);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix3.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 3] = cartesian.y;\n  result[index + 6] = cartesian.z;\n  return result;\n};\n\nconst scaleScratch1 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n  const scaleRatioZ = scale.z / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n\n  return result;\n};\n\nconst scaleScratch2 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @param {Number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix3.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n  const scaleRatioZ = scale / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3] * scaleRatioY;\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioZ;\n  result[7] = matrix[7] * scaleRatioZ;\n  result[8] = matrix[8] * scaleRatioZ;\n\n  return result;\n};\n\nconst scratchColumn = new Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n */\nMatrix3.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn)\n  );\n  result.y = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn)\n  );\n  result.z = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn)\n  );\n  return result;\n};\n\nconst scaleScratch3 = new Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors.\n *\n * @param {Matrix3} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix3.getMaximumScale = function (matrix) {\n  Matrix3.getScale(matrix, scaleScratch3);\n  return Cartesian3.maximumComponent(scaleScratch3);\n};\n\nconst scaleScratch4 = new Cartesian3();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} rotation The rotation matrix.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.getRotation\n */\nMatrix3.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch4);\n\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.x;\n  result[3] = rotation[3] * scale.y;\n  result[4] = rotation[4] * scale.y;\n  result[5] = rotation[5] * scale.y;\n  result[6] = rotation[6] * scale.z;\n  result[7] = rotation[7] * scale.z;\n  result[8] = rotation[8] * scale.z;\n\n  return result;\n};\n\nconst scaleScratch5 = new Cartesian3();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @see Matrix3.setRotation\n */\nMatrix3.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix3.getScale(matrix, scaleScratch5);\n\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.x;\n  result[3] = matrix[3] / scale.y;\n  result[4] = matrix[4] / scale.y;\n  result[5] = matrix[5] / scale.y;\n  result[6] = matrix[6] / scale.z;\n  result[7] = matrix[7] / scale.z;\n  result[8] = matrix[8] / scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 =\n    left[0] * right[0] + left[3] * right[1] + left[6] * right[2];\n  const column0Row1 =\n    left[1] * right[0] + left[4] * right[1] + left[7] * right[2];\n  const column0Row2 =\n    left[2] * right[0] + left[5] * right[1] + left[8] * right[2];\n\n  const column1Row0 =\n    left[0] * right[3] + left[3] * right[4] + left[6] * right[5];\n  const column1Row1 =\n    left[1] * right[3] + left[4] * right[4] + left[7] * right[5];\n  const column1Row2 =\n    left[2] * right[3] + left[5] * right[4] + left[8] * right[5];\n\n  const column2Row0 =\n    left[0] * right[6] + left[3] * right[7] + left[6] * right[8];\n  const column2Row1 =\n    left[1] * right[6] + left[4] * right[7] + left[7] * right[8];\n  const column2Row2 =\n    left[2] * right[6] + left[5] * right[7] + left[8] * right[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix3} left The first matrix.\n * @param {Matrix3} right The second matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Cartesian3} cartesian The column.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix3.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n\n  const x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;\n  const y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;\n  const z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix3} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Number} scale The non-uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);\n * Cesium.Matrix3.multiplyByScale(m, scale, m);\n *\n * @see Matrix3.multiplyByUniformScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale.x;\n  result[1] = matrix[1] * scale.x;\n  result[2] = matrix[2] * scale.x;\n  result[3] = matrix[3] * scale.y;\n  result[4] = matrix[4] * scale.y;\n  result[5] = matrix[5] * scale.y;\n  result[6] = matrix[6] * scale.z;\n  result[7] = matrix[7] * scale.z;\n  result[8] = matrix[8] * scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix3} matrix The matrix on the left-hand side.\n * @param {Number} scale The uniform scale on the right-hand side.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);\n * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix3.multiplyByScale\n * @see Matrix3.fromScale\n * @see Matrix3.fromUniformScale\n * @see Matrix3.setScale\n * @see Matrix3.setUniformScale\n * @see Matrix3.getScale\n */\nMatrix3.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3] * scale;\n  result[4] = matrix[4] * scale;\n  result[5] = matrix[5] * scale;\n  result[6] = matrix[6] * scale;\n  result[7] = matrix[7] * scale;\n  result[8] = matrix[8] * scale;\n\n  return result;\n};\n\n/**\n * Creates a negated copy of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to negate.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = matrix[0];\n  const column0Row1 = matrix[3];\n  const column0Row2 = matrix[6];\n  const column1Row0 = matrix[1];\n  const column1Row1 = matrix[4];\n  const column1Row2 = matrix[7];\n  const column2Row0 = matrix[2];\n  const column2Row1 = matrix[5];\n  const column2Row2 = matrix[8];\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column1Row0;\n  result[4] = column1Row1;\n  result[5] = column1Row2;\n  result[6] = column2Row0;\n  result[7] = column2Row1;\n  result[8] = column2Row2;\n  return result;\n};\n\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  // Computes the \"off-diagonal\" Frobenius norm.\n  // Assumes matrix is symmetric.\n\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n  //\n  // The routine takes a matrix, which is assumed to be symmetric, and\n  // finds the largest off-diagonal term, and then creates\n  // a matrix (result) which can be used to help reduce it\n\n  const tolerance = CesiumMath.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(\n      matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]\n    );\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  let c = 1.0;\n  let s = 0.0;\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[Matrix3.getElementIndex(q, q)];\n    const pp = matrix[Matrix3.getElementIndex(p, p)];\n    const qp = matrix[Matrix3.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  result = Matrix3.clone(Matrix3.IDENTITY, result);\n\n  result[Matrix3.getElementIndex(p, p)] = result[\n    Matrix3.getElementIndex(q, q)\n  ] = c;\n  result[Matrix3.getElementIndex(q, p)] = s;\n  result[Matrix3.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n * <p>\n * Returns a diagonal matrix and unitary matrix such that:\n * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>\n * </p>\n * <p>\n * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * </p>\n *\n * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symetric matrix\n * const result = {\n *     unitary : new Cesium.Matrix3(),\n *     diagonal : new Cesium.Matrix3()\n * };\n * Cesium.Matrix3.computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());\n * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());\n * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue\n * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector\n * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)\n */\nMatrix3.computeEigenDecomposition = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  // This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n  // section 8.4.3 The Classical Jacobi Algorithm\n\n  const tolerance = CesiumMath.EPSILON20;\n  const maxSweeps = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const unitaryMatrix = (result.unitary = Matrix3.clone(\n    Matrix3.IDENTITY,\n    result.unitary\n  ));\n  const diagMatrix = (result.diagonal = Matrix3.clone(matrix, result.diagonal));\n\n  const epsilon = tolerance * computeFrobeniusNorm(diagMatrix);\n\n  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {\n    shurDecomposition(diagMatrix, jMatrix);\n    Matrix3.transpose(jMatrix, jMatrixTranspose);\n    Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);\n    Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);\n    Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix3} matrix The matrix with signed elements.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n\n  return result;\n};\n\n/**\n * Computes the determinant of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to use.\n * @returns {Number} The value of the determinant of the matrix.\n */\nMatrix3.determinant = function (matrix) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[3];\n  const m31 = matrix[6];\n  const m12 = matrix[1];\n  const m22 = matrix[4];\n  const m32 = matrix[7];\n  const m13 = matrix[2];\n  const m23 = matrix[5];\n  const m33 = matrix[8];\n\n  return (\n    m11 * (m22 * m33 - m23 * m32) +\n    m12 * (m23 * m31 - m21 * m33) +\n    m13 * (m21 * m32 - m22 * m31)\n  );\n};\n\n/**\n * Computes the inverse of the provided matrix.\n *\n * @param {Matrix3} matrix The matrix to invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @exception {DeveloperError} matrix is not invertible.\n */\nMatrix3.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const m11 = matrix[0];\n  const m21 = matrix[1];\n  const m31 = matrix[2];\n  const m12 = matrix[3];\n  const m22 = matrix[4];\n  const m32 = matrix[5];\n  const m13 = matrix[6];\n  const m23 = matrix[7];\n  const m33 = matrix[8];\n\n  const determinant = Matrix3.determinant(matrix);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Math.abs(determinant) <= CesiumMath.EPSILON15) {\n    throw new DeveloperError(\"matrix is not invertible\");\n  }\n  //>>includeEnd('debug');\n\n  result[0] = m22 * m33 - m23 * m32;\n  result[1] = m23 * m31 - m21 * m33;\n  result[2] = m21 * m32 - m22 * m31;\n  result[3] = m13 * m32 - m12 * m33;\n  result[4] = m11 * m33 - m13 * m31;\n  result[5] = m12 * m31 - m11 * m32;\n  result[6] = m12 * m23 - m13 * m22;\n  result[7] = m13 * m21 - m11 * m23;\n  result[8] = m11 * m22 - m12 * m21;\n\n  const scale = 1.0 / determinant;\n  return Matrix3.multiplyByScalar(result, scale, result);\n};\n\nconst scratchTransposeMatrix = new Matrix3();\n\n/**\n * Computes the inverse transpose of a matrix.\n *\n * @param {Matrix3} matrix The matrix to transpose and invert.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n */\nMatrix3.inverseTranspose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  return Matrix3.inverse(\n    Matrix3.transpose(matrix, scratchTransposeMatrix),\n    result\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nMatrix3.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[3] === right[3] &&\n      left[4] === right[4] &&\n      left[5] === right[5] &&\n      left[6] === right[6] &&\n      left[7] === right[7] &&\n      left[8] === right[8])\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [left] The first matrix.\n * @param {Matrix3} [right] The second matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon &&\n      Math.abs(left[4] - right[4]) <= epsilon &&\n      Math.abs(left[5] - right[5]) <= epsilon &&\n      Math.abs(left[6] - right[6]) <= epsilon &&\n      Math.abs(left[7] - right[7]) <= epsilon &&\n      Math.abs(left[8] - right[8]) <= epsilon)\n  );\n};\n\n/**\n * An immutable Matrix3 instance initialized to the identity matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.IDENTITY = Object.freeze(\n  new Matrix3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n);\n\n/**\n * An immutable Matrix3 instance initialized to the zero matrix.\n *\n * @type {Matrix3}\n * @constant\n */\nMatrix3.ZERO = Object.freeze(\n  new Matrix3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n);\n\n/**\n * The index into Matrix3 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix3 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix3 for column 0, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix3 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW0 = 3;\n\n/**\n * The index into Matrix3 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW1 = 4;\n\n/**\n * The index into Matrix3 for column 1, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN1ROW2 = 5;\n\n/**\n * The index into Matrix3 for column 2, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW0 = 6;\n\n/**\n * The index into Matrix3 for column 2, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW1 = 7;\n\n/**\n * The index into Matrix3 for column 2, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix3.COLUMN2ROW2 = 8;\n\nObject.defineProperties(Matrix3.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix3.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix3.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix3 instance.\n *\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.\n */\nMatrix3.prototype.clone = function (result) {\n  return Matrix3.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix3.prototype.equals = function (right) {\n  return Matrix3.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix3.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3] &&\n    matrix[4] === array[offset + 4] &&\n    matrix[5] === array[offset + 5] &&\n    matrix[6] === array[offset + 6] &&\n    matrix[7] === array[offset + 7] &&\n    matrix[8] === array[offset + 8]\n  );\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix3} [right] The right hand side matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix3.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix3.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.\n */\nMatrix3.prototype.toString = function () {\n  return (\n    `(${this[0]}, ${this[3]}, ${this[6]})\\n` +\n    `(${this[1]}, ${this[4]}, ${this[7]})\\n` +\n    `(${this[2]}, ${this[5]}, ${this[8]})`\n  );\n};\nexport default Matrix3;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\n/**\n * A 4x4 matrix, indexable as a column-major order array.\n * Constructor parameters are in row-major order for code readability.\n * @alias Matrix4\n * @constructor\n * @implements {ArrayLike<number>}\n *\n * @param {Number} [column0Row0=0.0] The value for column 0, row 0.\n * @param {Number} [column1Row0=0.0] The value for column 1, row 0.\n * @param {Number} [column2Row0=0.0] The value for column 2, row 0.\n * @param {Number} [column3Row0=0.0] The value for column 3, row 0.\n * @param {Number} [column0Row1=0.0] The value for column 0, row 1.\n * @param {Number} [column1Row1=0.0] The value for column 1, row 1.\n * @param {Number} [column2Row1=0.0] The value for column 2, row 1.\n * @param {Number} [column3Row1=0.0] The value for column 3, row 1.\n * @param {Number} [column0Row2=0.0] The value for column 0, row 2.\n * @param {Number} [column1Row2=0.0] The value for column 1, row 2.\n * @param {Number} [column2Row2=0.0] The value for column 2, row 2.\n * @param {Number} [column3Row2=0.0] The value for column 3, row 2.\n * @param {Number} [column0Row3=0.0] The value for column 0, row 3.\n * @param {Number} [column1Row3=0.0] The value for column 1, row 3.\n * @param {Number} [column2Row3=0.0] The value for column 2, row 3.\n * @param {Number} [column3Row3=0.0] The value for column 3, row 3.\n *\n * @see Matrix4.fromArray\n * @see Matrix4.fromColumnMajorArray\n * @see Matrix4.fromRowMajorArray\n * @see Matrix4.fromRotationTranslation\n * @see Matrix4.fromTranslationQuaternionRotationScale\n * @see Matrix4.fromTranslationRotationScale\n * @see Matrix4.fromTranslation\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.fromRotation\n * @see Matrix4.fromCamera\n * @see Matrix4.computePerspectiveFieldOfView\n * @see Matrix4.computeOrthographicOffCenter\n * @see Matrix4.computePerspectiveOffCenter\n * @see Matrix4.computeInfinitePerspectiveOffCenter\n * @see Matrix4.computeViewportTransformation\n * @see Matrix4.computeView\n * @see Matrix2\n * @see Matrix3\n * @see Packable\n */\nfunction Matrix4(\n  column0Row0,\n  column1Row0,\n  column2Row0,\n  column3Row0,\n  column0Row1,\n  column1Row1,\n  column2Row1,\n  column3Row1,\n  column0Row2,\n  column1Row2,\n  column2Row2,\n  column3Row2,\n  column0Row3,\n  column1Row3,\n  column2Row3,\n  column3Row3\n) {\n  this[0] = defaultValue(column0Row0, 0.0);\n  this[1] = defaultValue(column0Row1, 0.0);\n  this[2] = defaultValue(column0Row2, 0.0);\n  this[3] = defaultValue(column0Row3, 0.0);\n  this[4] = defaultValue(column1Row0, 0.0);\n  this[5] = defaultValue(column1Row1, 0.0);\n  this[6] = defaultValue(column1Row2, 0.0);\n  this[7] = defaultValue(column1Row3, 0.0);\n  this[8] = defaultValue(column2Row0, 0.0);\n  this[9] = defaultValue(column2Row1, 0.0);\n  this[10] = defaultValue(column2Row2, 0.0);\n  this[11] = defaultValue(column2Row3, 0.0);\n  this[12] = defaultValue(column3Row0, 0.0);\n  this[13] = defaultValue(column3Row1, 0.0);\n  this[14] = defaultValue(column3Row2, 0.0);\n  this[15] = defaultValue(column3Row3, 0.0);\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nMatrix4.packedLength = 16;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Matrix4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nMatrix4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value[0];\n  array[startingIndex++] = value[1];\n  array[startingIndex++] = value[2];\n  array[startingIndex++] = value[3];\n  array[startingIndex++] = value[4];\n  array[startingIndex++] = value[5];\n  array[startingIndex++] = value[6];\n  array[startingIndex++] = value[7];\n  array[startingIndex++] = value[8];\n  array[startingIndex++] = value[9];\n  array[startingIndex++] = value[10];\n  array[startingIndex++] = value[11];\n  array[startingIndex++] = value[12];\n  array[startingIndex++] = value[13];\n  array[startingIndex++] = value[14];\n  array[startingIndex] = value[15];\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Matrix4} [result] The object into which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n */\nMatrix4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  result[0] = array[startingIndex++];\n  result[1] = array[startingIndex++];\n  result[2] = array[startingIndex++];\n  result[3] = array[startingIndex++];\n  result[4] = array[startingIndex++];\n  result[5] = array[startingIndex++];\n  result[6] = array[startingIndex++];\n  result[7] = array[startingIndex++];\n  result[8] = array[startingIndex++];\n  result[9] = array[startingIndex++];\n  result[10] = array[startingIndex++];\n  result[11] = array[startingIndex++];\n  result[12] = array[startingIndex++];\n  result[13] = array[startingIndex++];\n  result[14] = array[startingIndex++];\n  result[15] = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Matrix4s into an array of components. The components\n * are stored in column-major order.\n *\n * @param {Matrix4[]} array The array of matrices to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 16 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 16) elements.\n * @returns {Number[]} The packed array.\n */\nMatrix4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  const resultLength = length * 16;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    //>>includeStart('debug', pragmas.debug);\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 16 elements\"\n    );\n    //>>includeEnd('debug');\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    Matrix4.pack(array[i], result, i * 16);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of column-major matrix components into an array of Matrix4s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Matrix4[]} [result] The array onto which to store the result.\n * @returns {Matrix4[]} The unpacked array.\n */\nMatrix4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 16);\n  if (array.length % 16 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 16.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 16);\n  } else {\n    result.length = length / 16;\n  }\n\n  for (let i = 0; i < length; i += 16) {\n    const index = i / 16;\n    result[index] = Matrix4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Duplicates a Matrix4 instance.\n *\n * @param {Matrix4} matrix The matrix to duplicate.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)\n */\nMatrix4.clone = function (matrix, result) {\n  if (!defined(matrix)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Matrix4(\n      matrix[0],\n      matrix[4],\n      matrix[8],\n      matrix[12],\n      matrix[1],\n      matrix[5],\n      matrix[9],\n      matrix[13],\n      matrix[2],\n      matrix[6],\n      matrix[10],\n      matrix[14],\n      matrix[3],\n      matrix[7],\n      matrix[11],\n      matrix[15]\n    );\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Creates a Matrix4 from 16 consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n *\n * @example\n * // Create the Matrix4:\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n * // [1.0, 2.0, 3.0, 4.0]\n *\n * const v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * const m = Cesium.Matrix4.fromArray(v);\n *\n * // Create same Matrix4 with using an offset into an array\n * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];\n * const m2 = Cesium.Matrix4.fromArray(v2, 2);\n */\nMatrix4.fromArray = Matrix4.unpack;\n\n/**\n * Computes a Matrix4 instance from a column-major order array.\n *\n * @param {Number[]} values The column-major order array.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromColumnMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  return Matrix4.clone(values, result);\n};\n\n/**\n * Computes a Matrix4 instance from a row-major order array.\n * The resulting matrix will be in column-major order.\n *\n * @param {Number[]} values The row-major order array.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromRowMajorArray = function (values, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"values\", values);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix4(\n      values[0],\n      values[1],\n      values[2],\n      values[3],\n      values[4],\n      values[5],\n      values[6],\n      values[7],\n      values[8],\n      values[9],\n      values[10],\n      values[11],\n      values[12],\n      values[13],\n      values[14],\n      values[15]\n    );\n  }\n  result[0] = values[0];\n  result[1] = values[4];\n  result[2] = values[8];\n  result[3] = values[12];\n  result[4] = values[1];\n  result[5] = values[5];\n  result[6] = values[9];\n  result[7] = values[13];\n  result[8] = values[2];\n  result[9] = values[6];\n  result[10] = values[10];\n  result[11] = values[14];\n  result[12] = values[3];\n  result[13] = values[7];\n  result[14] = values[11];\n  result[15] = values[15];\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance from a Matrix3 representing the rotation\n * and a Cartesian3 representing the translation.\n *\n * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.\n * @param {Cartesian3} [translation=Cartesian3.ZERO] The upper right portion of the matrix representing the translation.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromRotationTranslation = function (rotation, translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rotation\", rotation);\n  //>>includeEnd('debug');\n\n  translation = defaultValue(translation, Cartesian3.ZERO);\n\n  if (!defined(result)) {\n    return new Matrix4(\n      rotation[0],\n      rotation[3],\n      rotation[6],\n      translation.x,\n      rotation[1],\n      rotation[4],\n      rotation[7],\n      translation.y,\n      rotation[2],\n      rotation[5],\n      rotation[8],\n      translation.z,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = rotation[0];\n  result[1] = rotation[1];\n  result[2] = rotation[2];\n  result[3] = 0.0;\n  result[4] = rotation[3];\n  result[5] = rotation[4];\n  result[6] = rotation[5];\n  result[7] = 0.0;\n  result[8] = rotation[6];\n  result[9] = rotation[7];\n  result[10] = rotation[8];\n  result[11] = 0.0;\n  result[12] = translation.x;\n  result[13] = translation.y;\n  result[14] = translation.z;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)\n * representation with the rotation represented as a quaternion.\n *\n * @param {Cartesian3} translation The translation transformation.\n * @param {Quaternion} rotation The rotation transformation.\n * @param {Cartesian3} scale The non-uniform scale transformation.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @example\n * const result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(\n *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation\n *   Cesium.Quaternion.IDENTITY,           // rotation\n *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale\n *   result);\n */\nMatrix4.fromTranslationQuaternionRotationScale = function (\n  translation,\n  rotation,\n  scale,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"translation\", translation);\n  Check.typeOf.object(\"rotation\", rotation);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  const scaleX = scale.x;\n  const scaleY = scale.y;\n  const scaleZ = scale.z;\n\n  const x2 = rotation.x * rotation.x;\n  const xy = rotation.x * rotation.y;\n  const xz = rotation.x * rotation.z;\n  const xw = rotation.x * rotation.w;\n  const y2 = rotation.y * rotation.y;\n  const yz = rotation.y * rotation.z;\n  const yw = rotation.y * rotation.w;\n  const z2 = rotation.z * rotation.z;\n  const zw = rotation.z * rotation.w;\n  const w2 = rotation.w * rotation.w;\n\n  const m00 = x2 - y2 - z2 + w2;\n  const m01 = 2.0 * (xy - zw);\n  const m02 = 2.0 * (xz + yw);\n\n  const m10 = 2.0 * (xy + zw);\n  const m11 = -x2 + y2 - z2 + w2;\n  const m12 = 2.0 * (yz - xw);\n\n  const m20 = 2.0 * (xz - yw);\n  const m21 = 2.0 * (yz + xw);\n  const m22 = -x2 - y2 + z2 + w2;\n\n  result[0] = m00 * scaleX;\n  result[1] = m10 * scaleX;\n  result[2] = m20 * scaleX;\n  result[3] = 0.0;\n  result[4] = m01 * scaleY;\n  result[5] = m11 * scaleY;\n  result[6] = m21 * scaleY;\n  result[7] = 0.0;\n  result[8] = m02 * scaleZ;\n  result[9] = m12 * scaleZ;\n  result[10] = m22 * scaleZ;\n  result[11] = 0.0;\n  result[12] = translation.x;\n  result[13] = translation.y;\n  result[14] = translation.z;\n  result[15] = 1.0;\n\n  return result;\n};\n\n/**\n * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.\n *\n * @param {TranslationRotationScale} translationRotationScale The instance.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromTranslationRotationScale = function (\n  translationRotationScale,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"translationRotationScale\", translationRotationScale);\n  //>>includeEnd('debug');\n\n  return Matrix4.fromTranslationQuaternionRotationScale(\n    translationRotationScale.translation,\n    translationRotationScale.rotation,\n    translationRotationScale.scale,\n    result\n  );\n};\n\n/**\n * Creates a Matrix4 instance from a Cartesian3 representing the translation.\n *\n * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @see Matrix4.multiplyByTranslation\n */\nMatrix4.fromTranslation = function (translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"translation\", translation);\n  //>>includeEnd('debug');\n\n  return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);\n};\n\n/**\n * Computes a Matrix4 instance representing a non-uniform scale.\n *\n * @param {Cartesian3} scale The x, y, and z scale factors.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [7.0, 0.0, 0.0, 0.0]\n * //   [0.0, 8.0, 0.0, 0.0]\n * //   [0.0, 0.0, 9.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * const m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));\n */\nMatrix4.fromScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix4(\n      scale.x,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale.y,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale.z,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = scale.x;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = scale.y;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = scale.z;\n  result[11] = 0.0;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = 0.0;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing a uniform scale.\n *\n * @param {Number} scale The uniform scale factor.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n *\n * @example\n * // Creates\n * //   [2.0, 0.0, 0.0, 0.0]\n * //   [0.0, 2.0, 0.0, 0.0]\n * //   [0.0, 0.0, 2.0, 0.0]\n * //   [0.0, 0.0, 0.0, 1.0]\n * const m = Cesium.Matrix4.fromUniformScale(2.0);\n */\nMatrix4.fromUniformScale = function (scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"scale\", scale);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Matrix4(\n      scale,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      scale,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n\n  result[0] = scale;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = scale;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = scale;\n  result[11] = 0.0;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = 0.0;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Creates a rotation matrix.\n *\n * @param {Matrix3} rotation The rotation matrix.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromRotation = function (rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rotation\", rotation);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n  result[0] = rotation[0];\n  result[1] = rotation[1];\n  result[2] = rotation[2];\n  result[3] = 0.0;\n\n  result[4] = rotation[3];\n  result[5] = rotation[4];\n  result[6] = rotation[5];\n  result[7] = 0.0;\n\n  result[8] = rotation[6];\n  result[9] = rotation[7];\n  result[10] = rotation[8];\n  result[11] = 0.0;\n\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = 0.0;\n  result[15] = 1.0;\n\n  return result;\n};\n\nconst fromCameraF = new Cartesian3();\nconst fromCameraR = new Cartesian3();\nconst fromCameraU = new Cartesian3();\n\n/**\n * Computes a Matrix4 instance from a Camera.\n *\n * @param {Camera} camera The camera to use.\n * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.\n */\nMatrix4.fromCamera = function (camera, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"camera\", camera);\n  //>>includeEnd('debug');\n\n  const position = camera.position;\n  const direction = camera.direction;\n  const up = camera.up;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"camera.position\", position);\n  Check.typeOf.object(\"camera.direction\", direction);\n  Check.typeOf.object(\"camera.up\", up);\n  //>>includeEnd('debug');\n\n  Cartesian3.normalize(direction, fromCameraF);\n  Cartesian3.normalize(\n    Cartesian3.cross(fromCameraF, up, fromCameraR),\n    fromCameraR\n  );\n  Cartesian3.normalize(\n    Cartesian3.cross(fromCameraR, fromCameraF, fromCameraU),\n    fromCameraU\n  );\n\n  const sX = fromCameraR.x;\n  const sY = fromCameraR.y;\n  const sZ = fromCameraR.z;\n  const fX = fromCameraF.x;\n  const fY = fromCameraF.y;\n  const fZ = fromCameraF.z;\n  const uX = fromCameraU.x;\n  const uY = fromCameraU.y;\n  const uZ = fromCameraU.z;\n  const positionX = position.x;\n  const positionY = position.y;\n  const positionZ = position.z;\n  const t0 = sX * -positionX + sY * -positionY + sZ * -positionZ;\n  const t1 = uX * -positionX + uY * -positionY + uZ * -positionZ;\n  const t2 = fX * positionX + fY * positionY + fZ * positionZ;\n\n  // The code below this comment is an optimized\n  // version of the commented lines.\n  // Rather that create two matrices and then multiply,\n  // we just bake in the multiplcation as part of creation.\n  // const rotation = new Matrix4(\n  //                 sX,  sY,  sZ, 0.0,\n  //                 uX,  uY,  uZ, 0.0,\n  //                -fX, -fY, -fZ, 0.0,\n  //                 0.0,  0.0,  0.0, 1.0);\n  // const translation = new Matrix4(\n  //                 1.0, 0.0, 0.0, -position.x,\n  //                 0.0, 1.0, 0.0, -position.y,\n  //                 0.0, 0.0, 1.0, -position.z,\n  //                 0.0, 0.0, 0.0, 1.0);\n  // return rotation.multiply(translation);\n  if (!defined(result)) {\n    return new Matrix4(\n      sX,\n      sY,\n      sZ,\n      t0,\n      uX,\n      uY,\n      uZ,\n      t1,\n      -fX,\n      -fY,\n      -fZ,\n      t2,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n  result[0] = sX;\n  result[1] = uX;\n  result[2] = -fX;\n  result[3] = 0.0;\n  result[4] = sY;\n  result[5] = uY;\n  result[6] = -fY;\n  result[7] = 0.0;\n  result[8] = sZ;\n  result[9] = uZ;\n  result[10] = -fZ;\n  result[11] = 0.0;\n  result[12] = t0;\n  result[13] = t1;\n  result[14] = t2;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing a perspective transformation matrix.\n *\n * @param {Number} fovY The field of view along the Y axis in radians.\n * @param {Number} aspectRatio The aspect ratio.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Number} far The distance to the far plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {DeveloperError} fovY must be in (0, PI].\n * @exception {DeveloperError} aspectRatio must be greater than zero.\n * @exception {DeveloperError} near must be greater than zero.\n * @exception {DeveloperError} far must be greater than zero.\n */\nMatrix4.computePerspectiveFieldOfView = function (\n  fovY,\n  aspectRatio,\n  near,\n  far,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"fovY\", fovY, 0.0);\n  Check.typeOf.number.lessThan(\"fovY\", fovY, Math.PI);\n  Check.typeOf.number.greaterThan(\"near\", near, 0.0);\n  Check.typeOf.number.greaterThan(\"far\", far, 0.0);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const bottom = Math.tan(fovY * 0.5);\n\n  const column1Row1 = 1.0 / bottom;\n  const column0Row0 = column1Row1 / aspectRatio;\n  const column2Row2 = (far + near) / (near - far);\n  const column3Row2 = (2.0 * far * near) / (near - far);\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = column2Row2;\n  result[11] = -1.0;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = column3Row2;\n  result[15] = 0.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing an orthographic transformation matrix.\n *\n * @param {Number} left The number of meters to the left of the camera that will be in view.\n * @param {Number} right The number of meters to the right of the camera that will be in view.\n * @param {Number} bottom The number of meters below of the camera that will be in view.\n * @param {Number} top The number of meters above of the camera that will be in view.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Number} far The distance to the far plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computeOrthographicOffCenter = function (\n  left,\n  right,\n  bottom,\n  top,\n  near,\n  far,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"left\", left);\n  Check.typeOf.number(\"right\", right);\n  Check.typeOf.number(\"bottom\", bottom);\n  Check.typeOf.number(\"top\", top);\n  Check.typeOf.number(\"near\", near);\n  Check.typeOf.number(\"far\", far);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let a = 1.0 / (right - left);\n  let b = 1.0 / (top - bottom);\n  let c = 1.0 / (far - near);\n\n  const tx = -(right + left) * a;\n  const ty = -(top + bottom) * b;\n  const tz = -(far + near) * c;\n  a *= 2.0;\n  b *= 2.0;\n  c *= -2.0;\n\n  result[0] = a;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = b;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = c;\n  result[11] = 0.0;\n  result[12] = tx;\n  result[13] = ty;\n  result[14] = tz;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing an off center perspective transformation.\n *\n * @param {Number} left The number of meters to the left of the camera that will be in view.\n * @param {Number} right The number of meters to the right of the camera that will be in view.\n * @param {Number} bottom The number of meters below of the camera that will be in view.\n * @param {Number} top The number of meters above of the camera that will be in view.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Number} far The distance to the far plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computePerspectiveOffCenter = function (\n  left,\n  right,\n  bottom,\n  top,\n  near,\n  far,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"left\", left);\n  Check.typeOf.number(\"right\", right);\n  Check.typeOf.number(\"bottom\", bottom);\n  Check.typeOf.number(\"top\", top);\n  Check.typeOf.number(\"near\", near);\n  Check.typeOf.number(\"far\", far);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = (2.0 * near) / (right - left);\n  const column1Row1 = (2.0 * near) / (top - bottom);\n  const column2Row0 = (right + left) / (right - left);\n  const column2Row1 = (top + bottom) / (top - bottom);\n  const column2Row2 = -(far + near) / (far - near);\n  const column2Row3 = -1.0;\n  const column3Row2 = (-2.0 * far * near) / (far - near);\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = column3Row2;\n  result[15] = 0.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance representing an infinite off center perspective transformation.\n *\n * @param {Number} left The number of meters to the left of the camera that will be in view.\n * @param {Number} right The number of meters to the right of the camera that will be in view.\n * @param {Number} bottom The number of meters below of the camera that will be in view.\n * @param {Number} top The number of meters above of the camera that will be in view.\n * @param {Number} near The distance to the near plane in meters.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computeInfinitePerspectiveOffCenter = function (\n  left,\n  right,\n  bottom,\n  top,\n  near,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"left\", left);\n  Check.typeOf.number(\"right\", right);\n  Check.typeOf.number(\"bottom\", bottom);\n  Check.typeOf.number(\"top\", top);\n  Check.typeOf.number(\"near\", near);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const column0Row0 = (2.0 * near) / (right - left);\n  const column1Row1 = (2.0 * near) / (top - bottom);\n  const column2Row0 = (right + left) / (right - left);\n  const column2Row1 = (top + bottom) / (top - bottom);\n  const column2Row2 = -1.0;\n  const column2Row3 = -1.0;\n  const column3Row2 = -2.0 * near;\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = 0.0;\n  result[13] = 0.0;\n  result[14] = column3Row2;\n  result[15] = 0.0;\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.\n *\n * @param {Object} [viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.\n * @param {Number} [nearDepthRange=0.0] The near plane distance in window coordinates.\n * @param {Number} [farDepthRange=1.0] The far plane distance in window coordinates.\n * @param {Matrix4} [result] The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Create viewport transformation using an explicit viewport and depth range.\n * const m = Cesium.Matrix4.computeViewportTransformation({\n *     x : 0.0,\n *     y : 0.0,\n *     width : 1024.0,\n *     height : 768.0\n * }, 0.0, 1.0, new Cesium.Matrix4());\n */\nMatrix4.computeViewportTransformation = function (\n  viewport,\n  nearDepthRange,\n  farDepthRange,\n  result\n) {\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);\n  const x = defaultValue(viewport.x, 0.0);\n  const y = defaultValue(viewport.y, 0.0);\n  const width = defaultValue(viewport.width, 0.0);\n  const height = defaultValue(viewport.height, 0.0);\n  nearDepthRange = defaultValue(nearDepthRange, 0.0);\n  farDepthRange = defaultValue(farDepthRange, 1.0);\n\n  const halfWidth = width * 0.5;\n  const halfHeight = height * 0.5;\n  const halfDepth = (farDepthRange - nearDepthRange) * 0.5;\n\n  const column0Row0 = halfWidth;\n  const column1Row1 = halfHeight;\n  const column2Row2 = halfDepth;\n  const column3Row0 = x + halfWidth;\n  const column3Row1 = y + halfHeight;\n  const column3Row2 = nearDepthRange + halfDepth;\n  const column3Row3 = 1.0;\n\n  result[0] = column0Row0;\n  result[1] = 0.0;\n  result[2] = 0.0;\n  result[3] = 0.0;\n  result[4] = 0.0;\n  result[5] = column1Row1;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 0.0;\n  result[9] = 0.0;\n  result[10] = column2Row2;\n  result[11] = 0.0;\n  result[12] = column3Row0;\n  result[13] = column3Row1;\n  result[14] = column3Row2;\n  result[15] = column3Row3;\n\n  return result;\n};\n\n/**\n * Computes a Matrix4 instance that transforms from world space to view space.\n *\n * @param {Cartesian3} position The position of the camera.\n * @param {Cartesian3} direction The forward direction.\n * @param {Cartesian3} up The up direction.\n * @param {Cartesian3} right The right direction.\n * @param {Matrix4} result The object in which the result will be stored.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.computeView = function (position, direction, up, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n  Check.typeOf.object(\"direction\", direction);\n  Check.typeOf.object(\"up\", up);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = right.x;\n  result[1] = up.x;\n  result[2] = -direction.x;\n  result[3] = 0.0;\n  result[4] = right.y;\n  result[5] = up.y;\n  result[6] = -direction.y;\n  result[7] = 0.0;\n  result[8] = right.z;\n  result[9] = up.z;\n  result[10] = -direction.z;\n  result[11] = 0.0;\n  result[12] = -Cartesian3.dot(right, position);\n  result[13] = -Cartesian3.dot(up, position);\n  result[14] = Cartesian3.dot(direction, position);\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Computes an Array from the provided Matrix4 instance.\n * The array will be in column-major order.\n *\n * @param {Matrix4} matrix The matrix to use..\n * @param {Number[]} [result] The Array onto which to store the result.\n * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.\n *\n * @example\n * //create an array from an instance of Matrix4\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n * const a = Cesium.Matrix4.toArray(m);\n *\n * // m remains the same\n * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]\n */\nMatrix4.toArray = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return [\n      matrix[0],\n      matrix[1],\n      matrix[2],\n      matrix[3],\n      matrix[4],\n      matrix[5],\n      matrix[6],\n      matrix[7],\n      matrix[8],\n      matrix[9],\n      matrix[10],\n      matrix[11],\n      matrix[12],\n      matrix[13],\n      matrix[14],\n      matrix[15],\n    ];\n  }\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Computes the array index of the element at the provided row and column.\n *\n * @param {Number} row The zero-based index of the row.\n * @param {Number} column The zero-based index of the column.\n * @returns {Number} The index of the element at the provided row and column.\n *\n * @exception {DeveloperError} row must be 0, 1, 2, or 3.\n * @exception {DeveloperError} column must be 0, 1, 2, or 3.\n *\n * @example\n * const myMatrix = new Cesium.Matrix4();\n * const column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);\n * const column1Row0 = myMatrix[column1Row0Index];\n * myMatrix[column1Row0Index] = 10.0;\n */\nMatrix4.getElementIndex = function (column, row) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"row\", row, 0);\n  Check.typeOf.number.lessThanOrEquals(\"row\", row, 3);\n\n  Check.typeOf.number.greaterThanOrEquals(\"column\", column, 0);\n  Check.typeOf.number.lessThanOrEquals(\"column\", column, 3);\n  //>>includeEnd('debug');\n\n  return column * 4 + row;\n};\n\n/**\n * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to retrieve.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Creates an instance of Cartesian\n * const a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());\n *\n * @example\n * //Example 2: Sets values for Cartesian instance\n * const a = new Cesium.Cartesian4();\n * Cesium.Matrix4.getColumn(m, 2, a);\n *\n * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;\n */\nMatrix4.getColumn = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const startIndex = index * 4;\n  const x = matrix[startIndex];\n  const y = matrix[startIndex + 1];\n  const z = matrix[startIndex + 2];\n  const w = matrix[startIndex + 3];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the column to set.\n * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //creates a new Matrix4 instance with new column values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 99.0, 13.0]\n * //     [14.0, 15.0, 98.0, 17.0]\n * //     [18.0, 19.0, 97.0, 21.0]\n * //     [22.0, 23.0, 96.0, 25.0]\n */\nMatrix4.setColumn = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix4.clone(matrix, result);\n  const startIndex = index * 4;\n  result[startIndex] = cartesian.x;\n  result[startIndex + 1] = cartesian.y;\n  result[startIndex + 2] = cartesian.z;\n  result[startIndex + 3] = cartesian.w;\n  return result;\n};\n\n/**\n * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to retrieve.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //returns a Cartesian4 instance with values from the specified column\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * //Example 1: Returns an instance of Cartesian\n * const a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());\n *\n * @example\n * //Example 2: Sets values for a Cartesian instance\n * const a = new Cesium.Cartesian4();\n * Cesium.Matrix4.getRow(m, 2, a);\n *\n * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;\n */\nMatrix4.getRow = function (matrix, index, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = matrix[index];\n  const y = matrix[index + 4];\n  const z = matrix[index + 8];\n  const w = matrix[index + 12];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} index The zero-based index of the row to set.\n * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {DeveloperError} index must be 0, 1, 2, or 3.\n *\n * @example\n * //create a new Matrix4 instance with new row values from the Cartesian4 instance\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [99.0, 98.0, 97.0, 96.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n */\nMatrix4.setRow = function (matrix, index, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  Check.typeOf.number.lessThanOrEquals(\"index\", index, 3);\n\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result = Matrix4.clone(matrix, result);\n  result[index] = cartesian.x;\n  result[index + 4] = cartesian.y;\n  result[index + 8] = cartesian.z;\n  result[index + 12] = cartesian.w;\n  return result;\n};\n\n/**\n * Computes a new matrix that replaces the translation in the rightmost column of the provided\n * matrix with the provided translation. This assumes the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Cartesian3} translation The translation that replaces the translation of the provided matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.setTranslation = function (matrix, translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"translation\", translation);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n\n  result[12] = translation.x;\n  result[13] = translation.y;\n  result[14] = translation.z;\n  result[15] = matrix[15];\n\n  return result;\n};\n\nconst scaleScratch1 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @see Matrix4.setUniformScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.multiplyByScale\n * @see Matrix4.multiplyByUniformScale\n * @see Matrix4.getScale\n */\nMatrix4.setScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix4.getScale(matrix, scaleScratch1);\n  const scaleRatioX = scale.x / existingScale.x;\n  const scaleRatioY = scale.y / existingScale.y;\n  const scaleRatioZ = scale.z / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3];\n\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioY;\n  result[7] = matrix[7];\n\n  result[8] = matrix[8] * scaleRatioZ;\n  result[9] = matrix[9] * scaleRatioZ;\n  result[10] = matrix[10] * scaleRatioZ;\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\nconst scaleScratch2 = new Cartesian3();\n\n/**\n * Computes a new matrix that replaces the scale with the provided uniform scale.\n * This assumes the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Number} scale The uniform scale that replaces the scale of the provided matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @see Matrix4.setScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.multiplyByScale\n * @see Matrix4.multiplyByUniformScale\n * @see Matrix4.getScale\n */\nMatrix4.setUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const existingScale = Matrix4.getScale(matrix, scaleScratch2);\n  const scaleRatioX = scale / existingScale.x;\n  const scaleRatioY = scale / existingScale.y;\n  const scaleRatioZ = scale / existingScale.z;\n\n  result[0] = matrix[0] * scaleRatioX;\n  result[1] = matrix[1] * scaleRatioX;\n  result[2] = matrix[2] * scaleRatioX;\n  result[3] = matrix[3];\n\n  result[4] = matrix[4] * scaleRatioY;\n  result[5] = matrix[5] * scaleRatioY;\n  result[6] = matrix[6] * scaleRatioY;\n  result[7] = matrix[7];\n\n  result[8] = matrix[8] * scaleRatioZ;\n  result[9] = matrix[9] * scaleRatioZ;\n  result[10] = matrix[10] * scaleRatioZ;\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\nconst scratchColumn = new Cartesian3();\n\n/**\n * Extracts the non-uniform scale assuming the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter\n *\n * @see Matrix4.multiplyByScale\n * @see Matrix4.multiplyByUniformScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.setScale\n * @see Matrix4.setUniformScale\n */\nMatrix4.getScale = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn)\n  );\n  result.y = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn)\n  );\n  result.z = Cartesian3.magnitude(\n    Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn)\n  );\n  return result;\n};\n\nconst scaleScratch3 = new Cartesian3();\n\n/**\n * Computes the maximum scale assuming the matrix is an affine transformation.\n * The maximum scale is the maximum length of the column vectors in the upper-left\n * 3x3 matrix.\n *\n * @param {Matrix4} matrix The matrix.\n * @returns {Number} The maximum scale.\n */\nMatrix4.getMaximumScale = function (matrix) {\n  Matrix4.getScale(matrix, scaleScratch3);\n  return Cartesian3.maximumComponent(scaleScratch3);\n};\n\nconst scaleScratch4 = new Cartesian3();\n\n/**\n * Sets the rotation assuming the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Matrix4} rotation The rotation matrix.\n * @returns {Matrix4} The modified result parameter.\n *\n * @see Matrix4.fromRotation\n * @see Matrix4.getRotation\n */\nMatrix4.setRotation = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix4.getScale(matrix, scaleScratch4);\n\n  result[0] = rotation[0] * scale.x;\n  result[1] = rotation[1] * scale.x;\n  result[2] = rotation[2] * scale.x;\n  result[3] = matrix[3];\n\n  result[4] = rotation[3] * scale.y;\n  result[5] = rotation[4] * scale.y;\n  result[6] = rotation[5] * scale.y;\n  result[7] = matrix[7];\n\n  result[8] = rotation[6] * scale.z;\n  result[9] = rotation[7] * scale.z;\n  result[10] = rotation[8] * scale.z;\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\nconst scaleScratch5 = new Cartesian3();\n\n/**\n * Extracts the rotation matrix assuming the matrix is an affine transformation.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @see Matrix4.setRotation\n * @see Matrix4.fromRotation\n */\nMatrix4.getRotation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scale = Matrix4.getScale(matrix, scaleScratch5);\n\n  result[0] = matrix[0] / scale.x;\n  result[1] = matrix[1] / scale.x;\n  result[2] = matrix[2] / scale.x;\n\n  result[3] = matrix[4] / scale.y;\n  result[4] = matrix[5] / scale.y;\n  result[5] = matrix[6] / scale.y;\n\n  result[6] = matrix[8] / scale.z;\n  result[7] = matrix[9] / scale.z;\n  result[8] = matrix[10] / scale.z;\n\n  return result;\n};\n\n/**\n * Computes the product of two matrices.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const left0 = left[0];\n  const left1 = left[1];\n  const left2 = left[2];\n  const left3 = left[3];\n  const left4 = left[4];\n  const left5 = left[5];\n  const left6 = left[6];\n  const left7 = left[7];\n  const left8 = left[8];\n  const left9 = left[9];\n  const left10 = left[10];\n  const left11 = left[11];\n  const left12 = left[12];\n  const left13 = left[13];\n  const left14 = left[14];\n  const left15 = left[15];\n\n  const right0 = right[0];\n  const right1 = right[1];\n  const right2 = right[2];\n  const right3 = right[3];\n  const right4 = right[4];\n  const right5 = right[5];\n  const right6 = right[6];\n  const right7 = right[7];\n  const right8 = right[8];\n  const right9 = right[9];\n  const right10 = right[10];\n  const right11 = right[11];\n  const right12 = right[12];\n  const right13 = right[13];\n  const right14 = right[14];\n  const right15 = right[15];\n\n  const column0Row0 =\n    left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;\n  const column0Row1 =\n    left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;\n  const column0Row2 =\n    left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;\n  const column0Row3 =\n    left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;\n\n  const column1Row0 =\n    left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;\n  const column1Row1 =\n    left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;\n  const column1Row2 =\n    left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;\n  const column1Row3 =\n    left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;\n\n  const column2Row0 =\n    left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;\n  const column2Row1 =\n    left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;\n  const column2Row2 =\n    left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;\n  const column2Row3 =\n    left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;\n\n  const column3Row0 =\n    left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;\n  const column3Row1 =\n    left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;\n  const column3Row2 =\n    left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;\n  const column3Row3 =\n    left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = column0Row3;\n  result[4] = column1Row0;\n  result[5] = column1Row1;\n  result[6] = column1Row2;\n  result[7] = column1Row3;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = column3Row0;\n  result[13] = column3Row1;\n  result[14] = column3Row2;\n  result[15] = column3Row3;\n  return result;\n};\n\n/**\n * Computes the sum of two matrices.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] + right[0];\n  result[1] = left[1] + right[1];\n  result[2] = left[2] + right[2];\n  result[3] = left[3] + right[3];\n  result[4] = left[4] + right[4];\n  result[5] = left[5] + right[5];\n  result[6] = left[6] + right[6];\n  result[7] = left[7] + right[7];\n  result[8] = left[8] + right[8];\n  result[9] = left[9] + right[9];\n  result[10] = left[10] + right[10];\n  result[11] = left[11] + right[11];\n  result[12] = left[12] + right[12];\n  result[13] = left[13] + right[13];\n  result[14] = left[14] + right[14];\n  result[15] = left[15] + right[15];\n  return result;\n};\n\n/**\n * Computes the difference of two matrices.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = left[0] - right[0];\n  result[1] = left[1] - right[1];\n  result[2] = left[2] - right[2];\n  result[3] = left[3] - right[3];\n  result[4] = left[4] - right[4];\n  result[5] = left[5] - right[5];\n  result[6] = left[6] - right[6];\n  result[7] = left[7] - right[7];\n  result[8] = left[8] - right[8];\n  result[9] = left[9] - right[9];\n  result[10] = left[10] - right[10];\n  result[11] = left[11] - right[11];\n  result[12] = left[12] - right[12];\n  result[13] = left[13] - right[13];\n  result[14] = left[14] - right[14];\n  result[15] = left[15] - right[15];\n  return result;\n};\n\n/**\n * Computes the product of two matrices assuming the matrices are affine transformation matrices,\n * where the upper left 3x3 elements are any matrix, and\n * the upper three elements in the fourth column are the translation.\n * The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * This method is faster than computing the product for general 4x4\n * matrices using {@link Matrix4.multiply}.\n *\n * @param {Matrix4} left The first matrix.\n * @param {Matrix4} right The second matrix.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * const m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n * const m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));\n * const m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());\n */\nMatrix4.multiplyTransformation = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const left0 = left[0];\n  const left1 = left[1];\n  const left2 = left[2];\n  const left4 = left[4];\n  const left5 = left[5];\n  const left6 = left[6];\n  const left8 = left[8];\n  const left9 = left[9];\n  const left10 = left[10];\n  const left12 = left[12];\n  const left13 = left[13];\n  const left14 = left[14];\n\n  const right0 = right[0];\n  const right1 = right[1];\n  const right2 = right[2];\n  const right4 = right[4];\n  const right5 = right[5];\n  const right6 = right[6];\n  const right8 = right[8];\n  const right9 = right[9];\n  const right10 = right[10];\n  const right12 = right[12];\n  const right13 = right[13];\n  const right14 = right[14];\n\n  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\n  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\n  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\n\n  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\n  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\n  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\n\n  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\n  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\n  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\n\n  const column3Row0 =\n    left0 * right12 + left4 * right13 + left8 * right14 + left12;\n  const column3Row1 =\n    left1 * right12 + left5 * right13 + left9 * right14 + left13;\n  const column3Row2 =\n    left2 * right12 + left6 * right13 + left10 * right14 + left14;\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = 0.0;\n  result[4] = column1Row0;\n  result[5] = column1Row1;\n  result[6] = column1Row2;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = 0.0;\n  result[12] = column3Row0;\n  result[13] = column3Row1;\n  result[14] = column3Row2;\n  result[15] = 1.0;\n  return result;\n};\n\n/**\n * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by a 3x3 rotation matrix.  This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The matrix on the left-hand side.\n * @param {Matrix3} rotation The 3x3 rotation matrix on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);\n * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);\n */\nMatrix4.multiplyByMatrix3 = function (matrix, rotation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"rotation\", rotation);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const left0 = matrix[0];\n  const left1 = matrix[1];\n  const left2 = matrix[2];\n  const left4 = matrix[4];\n  const left5 = matrix[5];\n  const left6 = matrix[6];\n  const left8 = matrix[8];\n  const left9 = matrix[9];\n  const left10 = matrix[10];\n\n  const right0 = rotation[0];\n  const right1 = rotation[1];\n  const right2 = rotation[2];\n  const right4 = rotation[3];\n  const right5 = rotation[4];\n  const right6 = rotation[5];\n  const right8 = rotation[6];\n  const right9 = rotation[7];\n  const right10 = rotation[8];\n\n  const column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;\n  const column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;\n  const column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;\n\n  const column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;\n  const column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;\n  const column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;\n\n  const column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;\n  const column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;\n  const column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;\n\n  result[0] = column0Row0;\n  result[1] = column0Row1;\n  result[2] = column0Row2;\n  result[3] = 0.0;\n  result[4] = column1Row0;\n  result[5] = column1Row1;\n  result[6] = column1Row2;\n  result[7] = 0.0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = 0.0;\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The matrix on the left-hand side.\n * @param {Cartesian3} translation The translation on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);\n * Cesium.Matrix4.multiplyByTranslation(m, position, m);\n */\nMatrix4.multiplyByTranslation = function (matrix, translation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"translation\", translation);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const x = translation.x;\n  const y = translation.y;\n  const z = translation.z;\n\n  const tx = x * matrix[0] + y * matrix[4] + z * matrix[8] + matrix[12];\n  const ty = x * matrix[1] + y * matrix[5] + z * matrix[9] + matrix[13];\n  const tz = x * matrix[2] + y * matrix[6] + z * matrix[10] + matrix[14];\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[3];\n  result[4] = matrix[4];\n  result[5] = matrix[5];\n  result[6] = matrix[6];\n  result[7] = matrix[7];\n  result[8] = matrix[8];\n  result[9] = matrix[9];\n  result[10] = matrix[10];\n  result[11] = matrix[11];\n  result[12] = tx;\n  result[13] = ty;\n  result[14] = tz;\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)\n * by an implicit non-uniform scale matrix. This is an optimization\n * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where\n * <code>m</code> must be an affine matrix.\n * This function performs fewer allocations and arithmetic operations.\n *\n * @param {Matrix4} matrix The affine matrix on the left-hand side.\n * @param {Cartesian3} scale The non-uniform scale on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);\n * Cesium.Matrix4.multiplyByScale(m, scale, m);\n *\n * @see Matrix4.multiplyByUniformScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.setScale\n * @see Matrix4.setUniformScale\n * @see Matrix4.getScale\n */\nMatrix4.multiplyByScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const scaleX = scale.x;\n  const scaleY = scale.y;\n  const scaleZ = scale.z;\n\n  // Faster than Cartesian3.equals\n  if (scaleX === 1.0 && scaleY === 1.0 && scaleZ === 1.0) {\n    return Matrix4.clone(matrix, result);\n  }\n\n  result[0] = scaleX * matrix[0];\n  result[1] = scaleX * matrix[1];\n  result[2] = scaleX * matrix[2];\n  result[3] = matrix[3];\n\n  result[4] = scaleY * matrix[4];\n  result[5] = scaleY * matrix[5];\n  result[6] = scaleY * matrix[6];\n  result[7] = matrix[7];\n\n  result[8] = scaleZ * matrix[8];\n  result[9] = scaleZ * matrix[9];\n  result[10] = scaleZ * matrix[10];\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.\n *\n * @param {Matrix4} matrix The matrix on the left-hand side.\n * @param {Number} scale The uniform scale on the right-hand side.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);\n * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);\n *\n * @see Matrix4.multiplyByScale\n * @see Matrix4.fromScale\n * @see Matrix4.fromUniformScale\n * @see Matrix4.setScale\n * @see Matrix4.setUniformScale\n * @see Matrix4.getScale\n */\nMatrix4.multiplyByUniformScale = function (matrix, scale, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scale\", scale);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scale;\n  result[1] = matrix[1] * scale;\n  result[2] = matrix[2] * scale;\n  result[3] = matrix[3];\n\n  result[4] = matrix[4] * scale;\n  result[5] = matrix[5] * scale;\n  result[6] = matrix[6] * scale;\n  result[7] = matrix[7];\n\n  result[8] = matrix[8] * scale;\n  result[9] = matrix[9] * scale;\n  result[10] = matrix[10] * scale;\n  result[11] = matrix[11];\n\n  result[12] = matrix[12];\n  result[13] = matrix[13];\n  result[14] = matrix[14];\n  result[15] = matrix[15];\n\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a column vector.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian4} cartesian The vector.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nMatrix4.multiplyByVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n  const vW = cartesian.w;\n\n  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;\n  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;\n  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;\n  const w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}\n * with a {@link Cartesian4} with a <code>w</code> component of zero.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian3} cartesian The point.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @example\n * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());\n * // A shortcut for\n * //   Cartesian3 p = ...\n * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);\n */\nMatrix4.multiplyByPointAsVector = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n\n  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;\n  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;\n  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}\n * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Cartesian3} cartesian The point.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n *\n * @example\n * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * const result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());\n */\nMatrix4.multiplyByPoint = function (matrix, cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const vX = cartesian.x;\n  const vY = cartesian.y;\n  const vZ = cartesian.z;\n\n  const x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];\n  const y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];\n  const z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the product of a matrix and a scalar.\n *\n * @param {Matrix4} matrix The matrix.\n * @param {Number} scalar The number to multiply by.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * //create a Matrix4 instance which is a scaled version of the supplied Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-20.0, -22.0, -24.0, -26.0]\n * //     [-28.0, -30.0, -32.0, -34.0]\n * //     [-36.0, -38.0, -40.0, -42.0]\n * //     [-44.0, -46.0, -48.0, -50.0]\n */\nMatrix4.multiplyByScalar = function (matrix, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0] * scalar;\n  result[1] = matrix[1] * scalar;\n  result[2] = matrix[2] * scalar;\n  result[3] = matrix[3] * scalar;\n  result[4] = matrix[4] * scalar;\n  result[5] = matrix[5] * scalar;\n  result[6] = matrix[6] * scalar;\n  result[7] = matrix[7] * scalar;\n  result[8] = matrix[8] * scalar;\n  result[9] = matrix[9] * scalar;\n  result[10] = matrix[10] * scalar;\n  result[11] = matrix[11] * scalar;\n  result[12] = matrix[12] * scalar;\n  result[13] = matrix[13] * scalar;\n  result[14] = matrix[14] * scalar;\n  result[15] = matrix[15] * scalar;\n  return result;\n};\n\n/**\n * Computes a negated copy of the provided matrix.\n *\n * @param {Matrix4} matrix The matrix to negate.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * //create a new Matrix4 instance which is a negation of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [-10.0, -11.0, -12.0, -13.0]\n * //     [-14.0, -15.0, -16.0, -17.0]\n * //     [-18.0, -19.0, -20.0, -21.0]\n * //     [-22.0, -23.0, -24.0, -25.0]\n */\nMatrix4.negate = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = -matrix[0];\n  result[1] = -matrix[1];\n  result[2] = -matrix[2];\n  result[3] = -matrix[3];\n  result[4] = -matrix[4];\n  result[5] = -matrix[5];\n  result[6] = -matrix[6];\n  result[7] = -matrix[7];\n  result[8] = -matrix[8];\n  result[9] = -matrix[9];\n  result[10] = -matrix[10];\n  result[11] = -matrix[11];\n  result[12] = -matrix[12];\n  result[13] = -matrix[13];\n  result[14] = -matrix[14];\n  result[15] = -matrix[15];\n  return result;\n};\n\n/**\n * Computes the transpose of the provided matrix.\n *\n * @param {Matrix4} matrix The matrix to transpose.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @example\n * //returns transpose of a Matrix4\n * // m = [10.0, 11.0, 12.0, 13.0]\n * //     [14.0, 15.0, 16.0, 17.0]\n * //     [18.0, 19.0, 20.0, 21.0]\n * //     [22.0, 23.0, 24.0, 25.0]\n *\n * const a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());\n *\n * // m remains the same\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n */\nMatrix4.transpose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const matrix1 = matrix[1];\n  const matrix2 = matrix[2];\n  const matrix3 = matrix[3];\n  const matrix6 = matrix[6];\n  const matrix7 = matrix[7];\n  const matrix11 = matrix[11];\n\n  result[0] = matrix[0];\n  result[1] = matrix[4];\n  result[2] = matrix[8];\n  result[3] = matrix[12];\n  result[4] = matrix1;\n  result[5] = matrix[5];\n  result[6] = matrix[9];\n  result[7] = matrix[13];\n  result[8] = matrix2;\n  result[9] = matrix6;\n  result[10] = matrix[10];\n  result[11] = matrix[14];\n  result[12] = matrix3;\n  result[13] = matrix7;\n  result[14] = matrix11;\n  result[15] = matrix[15];\n  return result;\n};\n\n/**\n * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.\n *\n * @param {Matrix4} matrix The matrix with signed elements.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.abs = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = Math.abs(matrix[0]);\n  result[1] = Math.abs(matrix[1]);\n  result[2] = Math.abs(matrix[2]);\n  result[3] = Math.abs(matrix[3]);\n  result[4] = Math.abs(matrix[4]);\n  result[5] = Math.abs(matrix[5]);\n  result[6] = Math.abs(matrix[6]);\n  result[7] = Math.abs(matrix[7]);\n  result[8] = Math.abs(matrix[8]);\n  result[9] = Math.abs(matrix[9]);\n  result[10] = Math.abs(matrix[10]);\n  result[11] = Math.abs(matrix[11]);\n  result[12] = Math.abs(matrix[12]);\n  result[13] = Math.abs(matrix[13]);\n  result[14] = Math.abs(matrix[14]);\n  result[15] = Math.abs(matrix[15]);\n\n  return result;\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix4} [left] The first matrix.\n * @param {Matrix4} [right] The second matrix.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n *\n * @example\n * //compares two Matrix4 instances\n *\n * // a = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equals(a,b)) {\n *      console.log(\"Both matrices are equal\");\n * } else {\n *      console.log(\"They are not equal\");\n * }\n *\n * //Prints \"Both matrices are equal\" on the console\n */\nMatrix4.equals = function (left, right) {\n  // Given that most matrices will be transformation matrices, the elements\n  // are tested in order such that the test is likely to fail as early\n  // as possible.  I _think_ this is just as friendly to the L1 cache\n  // as testing in index order.  It is certainty faster in practice.\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      // Translation\n      left[12] === right[12] &&\n      left[13] === right[13] &&\n      left[14] === right[14] &&\n      // Rotation/scale\n      left[0] === right[0] &&\n      left[1] === right[1] &&\n      left[2] === right[2] &&\n      left[4] === right[4] &&\n      left[5] === right[5] &&\n      left[6] === right[6] &&\n      left[8] === right[8] &&\n      left[9] === right[9] &&\n      left[10] === right[10] &&\n      // Bottom row\n      left[3] === right[3] &&\n      left[7] === right[7] &&\n      left[11] === right[11] &&\n      left[15] === right[15])\n  );\n};\n\n/**\n * Compares the provided matrices componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix4} [left] The first matrix.\n * @param {Matrix4} [right] The second matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n *\n * @example\n * //compares two Matrix4 instances\n *\n * // a = [10.5, 14.5, 18.5, 22.5]\n * //     [11.5, 15.5, 19.5, 23.5]\n * //     [12.5, 16.5, 20.5, 24.5]\n * //     [13.5, 17.5, 21.5, 25.5]\n *\n * // b = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){\n *      console.log(\"Difference between both the matrices is less than 0.1\");\n * } else {\n *      console.log(\"Difference between both the matrices is not less than 0.1\");\n * }\n *\n * //Prints \"Difference between both the matrices is not less than 0.1\" on the console\n */\nMatrix4.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left[0] - right[0]) <= epsilon &&\n      Math.abs(left[1] - right[1]) <= epsilon &&\n      Math.abs(left[2] - right[2]) <= epsilon &&\n      Math.abs(left[3] - right[3]) <= epsilon &&\n      Math.abs(left[4] - right[4]) <= epsilon &&\n      Math.abs(left[5] - right[5]) <= epsilon &&\n      Math.abs(left[6] - right[6]) <= epsilon &&\n      Math.abs(left[7] - right[7]) <= epsilon &&\n      Math.abs(left[8] - right[8]) <= epsilon &&\n      Math.abs(left[9] - right[9]) <= epsilon &&\n      Math.abs(left[10] - right[10]) <= epsilon &&\n      Math.abs(left[11] - right[11]) <= epsilon &&\n      Math.abs(left[12] - right[12]) <= epsilon &&\n      Math.abs(left[13] - right[13]) <= epsilon &&\n      Math.abs(left[14] - right[14]) <= epsilon &&\n      Math.abs(left[15] - right[15]) <= epsilon)\n  );\n};\n\n/**\n * Gets the translation portion of the provided matrix, assuming the matrix is an affine transformation matrix.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nMatrix4.getTranslation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = matrix[12];\n  result.y = matrix[13];\n  result.z = matrix[14];\n  return result;\n};\n\n/**\n * Gets the upper left 3x3 matrix of the provided matrix.\n *\n * @param {Matrix4} matrix The matrix to use.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter.\n *\n * @example\n * // returns a Matrix3 instance from a Matrix4 instance\n *\n * // m = [10.0, 14.0, 18.0, 22.0]\n * //     [11.0, 15.0, 19.0, 23.0]\n * //     [12.0, 16.0, 20.0, 24.0]\n * //     [13.0, 17.0, 21.0, 25.0]\n *\n * const b = new Cesium.Matrix3();\n * Cesium.Matrix4.getMatrix3(m,b);\n *\n * // b = [10.0, 14.0, 18.0]\n * //     [11.0, 15.0, 19.0]\n * //     [12.0, 16.0, 20.0]\n */\nMatrix4.getMatrix3 = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result[0] = matrix[0];\n  result[1] = matrix[1];\n  result[2] = matrix[2];\n  result[3] = matrix[4];\n  result[4] = matrix[5];\n  result[5] = matrix[6];\n  result[6] = matrix[8];\n  result[7] = matrix[9];\n  result[8] = matrix[10];\n  return result;\n};\n\nconst scratchInverseRotation = new Matrix3();\nconst scratchMatrix3Zero = new Matrix3();\nconst scratchBottomRow = new Cartesian4();\nconst scratchExpectedBottomRow = new Cartesian4(0.0, 0.0, 0.0, 1.0);\n\n/**\n * Computes the inverse of the provided matrix using Cramers Rule.\n * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.\n * If the matrix is a proper rigid transformation, it is more efficient\n * to invert it with {@link Matrix4.inverseTransformation}.\n *\n * @param {Matrix4} matrix The matrix to invert.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n *\n * @exception {RuntimeError} matrix is not invertible because its determinate is zero.\n */\nMatrix4.inverse = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n  //\n  // Ported from:\n  //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf\n  //\n  const src0 = matrix[0];\n  const src1 = matrix[4];\n  const src2 = matrix[8];\n  const src3 = matrix[12];\n  const src4 = matrix[1];\n  const src5 = matrix[5];\n  const src6 = matrix[9];\n  const src7 = matrix[13];\n  const src8 = matrix[2];\n  const src9 = matrix[6];\n  const src10 = matrix[10];\n  const src11 = matrix[14];\n  const src12 = matrix[3];\n  const src13 = matrix[7];\n  const src14 = matrix[11];\n  const src15 = matrix[15];\n\n  // calculate pairs for first 8 elements (cofactors)\n  let tmp0 = src10 * src15;\n  let tmp1 = src11 * src14;\n  let tmp2 = src9 * src15;\n  let tmp3 = src11 * src13;\n  let tmp4 = src9 * src14;\n  let tmp5 = src10 * src13;\n  let tmp6 = src8 * src15;\n  let tmp7 = src11 * src12;\n  let tmp8 = src8 * src14;\n  let tmp9 = src10 * src12;\n  let tmp10 = src8 * src13;\n  let tmp11 = src9 * src12;\n\n  // calculate first 8 elements (cofactors)\n  const dst0 =\n    tmp0 * src5 +\n    tmp3 * src6 +\n    tmp4 * src7 -\n    (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);\n  const dst1 =\n    tmp1 * src4 +\n    tmp6 * src6 +\n    tmp9 * src7 -\n    (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);\n  const dst2 =\n    tmp2 * src4 +\n    tmp7 * src5 +\n    tmp10 * src7 -\n    (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);\n  const dst3 =\n    tmp5 * src4 +\n    tmp8 * src5 +\n    tmp11 * src6 -\n    (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);\n  const dst4 =\n    tmp1 * src1 +\n    tmp2 * src2 +\n    tmp5 * src3 -\n    (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);\n  const dst5 =\n    tmp0 * src0 +\n    tmp7 * src2 +\n    tmp8 * src3 -\n    (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);\n  const dst6 =\n    tmp3 * src0 +\n    tmp6 * src1 +\n    tmp11 * src3 -\n    (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);\n  const dst7 =\n    tmp4 * src0 +\n    tmp9 * src1 +\n    tmp10 * src2 -\n    (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);\n\n  // calculate pairs for second 8 elements (cofactors)\n  tmp0 = src2 * src7;\n  tmp1 = src3 * src6;\n  tmp2 = src1 * src7;\n  tmp3 = src3 * src5;\n  tmp4 = src1 * src6;\n  tmp5 = src2 * src5;\n  tmp6 = src0 * src7;\n  tmp7 = src3 * src4;\n  tmp8 = src0 * src6;\n  tmp9 = src2 * src4;\n  tmp10 = src0 * src5;\n  tmp11 = src1 * src4;\n\n  // calculate second 8 elements (cofactors)\n  const dst8 =\n    tmp0 * src13 +\n    tmp3 * src14 +\n    tmp4 * src15 -\n    (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);\n  const dst9 =\n    tmp1 * src12 +\n    tmp6 * src14 +\n    tmp9 * src15 -\n    (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);\n  const dst10 =\n    tmp2 * src12 +\n    tmp7 * src13 +\n    tmp10 * src15 -\n    (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);\n  const dst11 =\n    tmp5 * src12 +\n    tmp8 * src13 +\n    tmp11 * src14 -\n    (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);\n  const dst12 =\n    tmp2 * src10 +\n    tmp5 * src11 +\n    tmp1 * src9 -\n    (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);\n  const dst13 =\n    tmp8 * src11 +\n    tmp0 * src8 +\n    tmp7 * src10 -\n    (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);\n  const dst14 =\n    tmp6 * src9 +\n    tmp11 * src11 +\n    tmp3 * src8 -\n    (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);\n  const dst15 =\n    tmp10 * src10 +\n    tmp4 * src8 +\n    tmp9 * src9 -\n    (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);\n\n  // calculate determinant\n  let det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;\n\n  if (Math.abs(det) < CesiumMath.EPSILON21) {\n    // Special case for a zero scale matrix that can occur, for example,\n    // when a model's node has a [0, 0, 0] scale.\n    if (\n      Matrix3.equalsEpsilon(\n        Matrix4.getMatrix3(matrix, scratchInverseRotation),\n        scratchMatrix3Zero,\n        CesiumMath.EPSILON7\n      ) &&\n      Cartesian4.equals(\n        Matrix4.getRow(matrix, 3, scratchBottomRow),\n        scratchExpectedBottomRow\n      )\n    ) {\n      result[0] = 0.0;\n      result[1] = 0.0;\n      result[2] = 0.0;\n      result[3] = 0.0;\n      result[4] = 0.0;\n      result[5] = 0.0;\n      result[6] = 0.0;\n      result[7] = 0.0;\n      result[8] = 0.0;\n      result[9] = 0.0;\n      result[10] = 0.0;\n      result[11] = 0.0;\n      result[12] = -matrix[12];\n      result[13] = -matrix[13];\n      result[14] = -matrix[14];\n      result[15] = 1.0;\n      return result;\n    }\n\n    throw new RuntimeError(\n      \"matrix is not invertible because its determinate is zero.\"\n    );\n  }\n\n  // calculate matrix inverse\n  det = 1.0 / det;\n\n  result[0] = dst0 * det;\n  result[1] = dst1 * det;\n  result[2] = dst2 * det;\n  result[3] = dst3 * det;\n  result[4] = dst4 * det;\n  result[5] = dst5 * det;\n  result[6] = dst6 * det;\n  result[7] = dst7 * det;\n  result[8] = dst8 * det;\n  result[9] = dst9 * det;\n  result[10] = dst10 * det;\n  result[11] = dst11 * det;\n  result[12] = dst12 * det;\n  result[13] = dst13 * det;\n  result[14] = dst14 * det;\n  result[15] = dst15 * det;\n  return result;\n};\n\n/**\n * Computes the inverse of the provided matrix assuming it is a proper rigid matrix,\n * where the upper left 3x3 elements are a rotation matrix,\n * and the upper three elements in the fourth column are the translation.\n * The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * This method is faster than computing the inverse for a general 4x4\n * matrix using {@link Matrix4.inverse}.\n *\n * @param {Matrix4} matrix The matrix to invert.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.inverseTransformation = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  //This function is an optimized version of the below 4 lines.\n  //const rT = Matrix3.transpose(Matrix4.getMatrix3(matrix));\n  //const rTN = Matrix3.negate(rT);\n  //const rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));\n  //return Matrix4.fromRotationTranslation(rT, rTT, result);\n\n  const matrix0 = matrix[0];\n  const matrix1 = matrix[1];\n  const matrix2 = matrix[2];\n  const matrix4 = matrix[4];\n  const matrix5 = matrix[5];\n  const matrix6 = matrix[6];\n  const matrix8 = matrix[8];\n  const matrix9 = matrix[9];\n  const matrix10 = matrix[10];\n\n  const vX = matrix[12];\n  const vY = matrix[13];\n  const vZ = matrix[14];\n\n  const x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;\n  const y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;\n  const z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;\n\n  result[0] = matrix0;\n  result[1] = matrix4;\n  result[2] = matrix8;\n  result[3] = 0.0;\n  result[4] = matrix1;\n  result[5] = matrix5;\n  result[6] = matrix9;\n  result[7] = 0.0;\n  result[8] = matrix2;\n  result[9] = matrix6;\n  result[10] = matrix10;\n  result[11] = 0.0;\n  result[12] = x;\n  result[13] = y;\n  result[14] = z;\n  result[15] = 1.0;\n  return result;\n};\n\nconst scratchTransposeMatrix = new Matrix4();\n\n/**\n * Computes the inverse transpose of a matrix.\n *\n * @param {Matrix4} matrix The matrix to transpose and invert.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter.\n */\nMatrix4.inverseTranspose = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  return Matrix4.inverse(\n    Matrix4.transpose(matrix, scratchTransposeMatrix),\n    result\n  );\n};\n\n/**\n * An immutable Matrix4 instance initialized to the identity matrix.\n *\n * @type {Matrix4}\n * @constant\n */\nMatrix4.IDENTITY = Object.freeze(\n  new Matrix4(\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0\n  )\n);\n\n/**\n * An immutable Matrix4 instance initialized to the zero matrix.\n *\n * @type {Matrix4}\n * @constant\n */\nMatrix4.ZERO = Object.freeze(\n  new Matrix4(\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0\n  )\n);\n\n/**\n * The index into Matrix4 for column 0, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW0 = 0;\n\n/**\n * The index into Matrix4 for column 0, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW1 = 1;\n\n/**\n * The index into Matrix4 for column 0, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW2 = 2;\n\n/**\n * The index into Matrix4 for column 0, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN0ROW3 = 3;\n\n/**\n * The index into Matrix4 for column 1, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW0 = 4;\n\n/**\n * The index into Matrix4 for column 1, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW1 = 5;\n\n/**\n * The index into Matrix4 for column 1, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW2 = 6;\n\n/**\n * The index into Matrix4 for column 1, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN1ROW3 = 7;\n\n/**\n * The index into Matrix4 for column 2, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW0 = 8;\n\n/**\n * The index into Matrix4 for column 2, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW1 = 9;\n\n/**\n * The index into Matrix4 for column 2, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW2 = 10;\n\n/**\n * The index into Matrix4 for column 2, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN2ROW3 = 11;\n\n/**\n * The index into Matrix4 for column 3, row 0.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW0 = 12;\n\n/**\n * The index into Matrix4 for column 3, row 1.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW1 = 13;\n\n/**\n * The index into Matrix4 for column 3, row 2.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW2 = 14;\n\n/**\n * The index into Matrix4 for column 3, row 3.\n *\n * @type {Number}\n * @constant\n */\nMatrix4.COLUMN3ROW3 = 15;\n\nObject.defineProperties(Matrix4.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof Matrix4.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return Matrix4.packedLength;\n    },\n  },\n});\n\n/**\n * Duplicates the provided Matrix4 instance.\n *\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.\n */\nMatrix4.prototype.clone = function (result) {\n  return Matrix4.clone(this, result);\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Matrix4} [right] The right hand side matrix.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nMatrix4.prototype.equals = function (right) {\n  return Matrix4.equals(this, right);\n};\n\n/**\n * @private\n */\nMatrix4.equalsArray = function (matrix, array, offset) {\n  return (\n    matrix[0] === array[offset] &&\n    matrix[1] === array[offset + 1] &&\n    matrix[2] === array[offset + 2] &&\n    matrix[3] === array[offset + 3] &&\n    matrix[4] === array[offset + 4] &&\n    matrix[5] === array[offset + 5] &&\n    matrix[6] === array[offset + 6] &&\n    matrix[7] === array[offset + 7] &&\n    matrix[8] === array[offset + 8] &&\n    matrix[9] === array[offset + 9] &&\n    matrix[10] === array[offset + 10] &&\n    matrix[11] === array[offset + 11] &&\n    matrix[12] === array[offset + 12] &&\n    matrix[13] === array[offset + 13] &&\n    matrix[14] === array[offset + 14] &&\n    matrix[15] === array[offset + 15]\n  );\n};\n\n/**\n * Compares this matrix to the provided matrix componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Matrix4} [right] The right hand side matrix.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nMatrix4.prototype.equalsEpsilon = function (right, epsilon) {\n  return Matrix4.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Computes a string representing this Matrix with each row being\n * on a separate line and in the format '(column0, column1, column2, column3)'.\n *\n * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.\n */\nMatrix4.prototype.toString = function () {\n  return (\n    `(${this[0]}, ${this[4]}, ${this[8]}, ${this[12]})\\n` +\n    `(${this[1]}, ${this[5]}, ${this[9]}, ${this[13]})\\n` +\n    `(${this[2]}, ${this[6]}, ${this[10]}, ${this[14]})\\n` +\n    `(${this[3]}, ${this[7]}, ${this[11]}, ${this[15]})`\n  );\n};\nexport default Matrix4;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Spline from \"./Spline.js\";\n\n/**\n * A spline that linearly interpolates over an array of weight values used by morph targets.\n *\n * @alias MorphWeightSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Number[]} options.weights The array of floating-point control weights given. The weights are ordered such\n *                that all weights for the targets are given in chronological order and order in which they appear in\n *                the glTF from which the morph targets come. This means for 2 targets, weights = [w(0,0), w(0,1), w(1,0), w(1,1) ...]\n *                where i and j in w(i,j) are the time indices and target indices, respectively.\n *\n * @exception {DeveloperError} weights.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be a factor of weights.length.\n *\n *\n * @example\n * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * const weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets\n * const spline = new Cesium.WeightSpline({\n *     times : times,\n *     weights : weights\n * });\n *\n * const p0 = spline.evaluate(times[0]);\n *\n * @see ConstantSpline\n * @see SteppedSpline\n * @see LinearSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see QuaternionSpline\n */\nfunction MorphWeightSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const weights = options.weights;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"weights\", weights);\n  Check.defined(\"times\", times);\n  Check.typeOf.number.greaterThanOrEquals(\"weights.length\", weights.length, 3);\n  if (weights.length % times.length !== 0) {\n    throw new DeveloperError(\n      \"times.length must be a factor of weights.length.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._weights = weights;\n  this._count = weights.length / times.length;\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(MorphWeightSpline.prototype, {\n  /**\n   * An array of times for the control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of floating-point array control weights.\n   *\n   * @memberof WeightSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  weights: {\n    get: function () {\n      return this._weights;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nMorphWeightSpline.prototype.findTimeInterval =\n  Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nMorphWeightSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nMorphWeightSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Number[]} [result] The object onto which to store the result.\n * @returns {Number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nMorphWeightSpline.prototype.evaluate = function (time, result) {\n  const weights = this.weights;\n  const times = this.times;\n\n  const i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex\n  ));\n  const u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  if (!defined(result)) {\n    result = new Array(this._count);\n  }\n\n  for (let j = 0; j < this._count; j++) {\n    const index = i * this._count + j;\n    result[j] = weights[index] * (1.0 - u) + weights[index + this._count] * u;\n  }\n\n  return result;\n};\nexport default MorphWeightSpline;\n","import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Morton Order (aka Z-Order Curve) helper functions.\n * @see {@link https://en.wikipedia.org/wiki/Z-order_curve}\n *\n * @namespace MortonOrder\n * @private\n */\nconst MortonOrder = {};\n\n/**\n * Inserts one 0 bit of spacing between a number's bits. This is the opposite of removeOneSpacing.\n *\n * Example:\n *  input: 6\n *  input (binary):  110\n *  output (binary): 10100\n *                    ^ ^ (added)\n *  output: 20\n *\n * @private\n * @param {Number} v A 16-bit unsigned integer.\n * @returns {Number} A 32-bit unsigned integer.\n * @see {@link https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/}\n * @private\n */\nfunction insertOneSpacing(v) {\n  v = (v ^ (v << 8)) & 0x00ff00ff;\n  v = (v ^ (v << 4)) & 0x0f0f0f0f;\n  v = (v ^ (v << 2)) & 0x33333333;\n  v = (v ^ (v << 1)) & 0x55555555;\n  return v;\n}\n\n/**\n * Inserts two 0 bits of spacing between a number's bits. This is the opposite of removeTwoSpacing.\n *\n * Example:\n *  input: 6\n *  input (binary):  110\n *  output (binary): 1001000\n *                    ^^ ^^ (added)\n *  output: 72\n *\n * @private\n * @param {Number} v A 10-bit unsigned integer.\n * @returns {Number} A 30-bit unsigned integer.\n * @see {@link https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/}\n */\nfunction insertTwoSpacing(v) {\n  v = (v ^ (v << 16)) & 0x030000ff;\n  v = (v ^ (v << 8)) & 0x0300f00f;\n  v = (v ^ (v << 4)) & 0x030c30c3;\n  v = (v ^ (v << 2)) & 0x09249249;\n  return v;\n}\n\n/**\n * Removes one bit of spacing between bits. This is the opposite of insertOneSpacing.\n *\n * Example:\n *  input: 20\n *  input (binary):  10100\n *                    ^ ^ (removed)\n *  output (binary): 110\n *  output: 6\n *\n * @private\n * @param {Number} v A 32-bit unsigned integer.\n * @returns {Number} A 16-bit unsigned integer.\n * @see {@link https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/}\n */\nfunction removeOneSpacing(v) {\n  v &= 0x55555555;\n  v = (v ^ (v >> 1)) & 0x33333333;\n  v = (v ^ (v >> 2)) & 0x0f0f0f0f;\n  v = (v ^ (v >> 4)) & 0x00ff00ff;\n  v = (v ^ (v >> 8)) & 0x0000ffff;\n  return v;\n}\n\n/**\n * Removes two bits of spacing between bits. This is the opposite of insertTwoSpacing.\n *\n * Example:\n *  input: 72\n *  input (binary):  1001000\n *                    ^^ ^^ (removed)\n *  output (binary): 110\n *  output: 6\n *\n * @private\n * @param {Number} v A 30-bit unsigned integer.\n * @returns {Number} A 10-bit unsigned integer.\n * @see {@link https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/}\n */\nfunction removeTwoSpacing(v) {\n  v &= 0x09249249;\n  v = (v ^ (v >> 2)) & 0x030c30c3;\n  v = (v ^ (v >> 4)) & 0x0300f00f;\n  v = (v ^ (v >> 8)) & 0xff0000ff;\n  v = (v ^ (v >> 16)) & 0x000003ff;\n  return v;\n}\n\n/**\n * Computes the Morton index from 2D coordinates. This is equivalent to interleaving their bits.\n * The inputs must be 16-bit unsigned integers (resulting in 32-bit Morton index) due to 32-bit bitwise operator limitation in JavaScript.\n *\n * @param {Number} x The X coordinate in the range [0, (2^16)-1].\n * @param {Number} y The Y coordinate in the range [0, (2^16)-1].\n * @returns {Number} The Morton index.\n * @private\n */\nMortonOrder.encode2D = function (x, y) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (x < 0 || x > 65535 || y < 0 || y > 65535) {\n    throw new DeveloperError(\"inputs must be 16-bit unsigned integers\");\n  }\n  //>>includeEnd('debug');\n\n  // Note: JavaScript bitwise operations return signed 32-bit integers, so the\n  // final result needs to be reintepreted as an unsigned integer using >>> 0.\n  // This is not needed for encode3D because the result is guaranteed to be at most\n  // 30 bits and thus will always be interpreted as an unsigned value.\n  return (insertOneSpacing(x) | (insertOneSpacing(y) << 1)) >>> 0;\n};\n\n/**\n * Computes the 2D coordinates from a Morton index. This is equivalent to deinterleaving their bits.\n * The input must be a 32-bit unsigned integer (resulting in 16 bits per coordinate) due to 32-bit bitwise operator limitation in JavaScript.\n *\n * @param {Number} mortonIndex The Morton index in the range [0, (2^32)-1].\n * @param {Number[]} [result] The array onto which to store the result.\n * @returns {Number[]} An array containing the 2D coordinates correspoding to the Morton index.\n * @private\n */\nMortonOrder.decode2D = function (mortonIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"mortonIndex\", mortonIndex);\n  if (mortonIndex < 0 || mortonIndex > 4294967295) {\n    throw new DeveloperError(\"input must be a 32-bit unsigned integer\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Array(2);\n  }\n\n  result[0] = removeOneSpacing(mortonIndex);\n  result[1] = removeOneSpacing(mortonIndex >> 1);\n  return result;\n};\n\n/**\n * Computes the Morton index from 3D coordinates. This is equivalent to interleaving their bits.\n * The inputs must be 10-bit unsigned integers (resulting in 30-bit Morton index) due to 32-bit bitwise operator limitation in JavaScript.\n *\n * @param {Number} x The X coordinate in the range [0, (2^10)-1].\n * @param {Number} y The Y coordinate in the range [0, (2^10)-1].\n * @param {Number} z The Z coordinate in the range [0, (2^10)-1].\n * @returns {Number} The Morton index.\n * @private\n */\nMortonOrder.encode3D = function (x, y, z) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  Check.typeOf.number(\"z\", z);\n  if (x < 0 || x > 1023 || y < 0 || y > 1023 || z < 0 || z > 1023) {\n    throw new DeveloperError(\"inputs must be 10-bit unsigned integers\");\n  }\n  //>>includeEnd('debug');\n\n  return (\n    insertTwoSpacing(x) |\n    (insertTwoSpacing(y) << 1) |\n    (insertTwoSpacing(z) << 2)\n  );\n};\n\n/**\n * Computes the 3D coordinates from a Morton index. This is equivalent to deinterleaving their bits.\n * The input must be a 30-bit unsigned integer (resulting in 10 bits per coordinate) due to 32-bit bitwise operator limitation in JavaScript.\n *\n * @param {Number} mortonIndex The Morton index in the range [0, (2^30)-1].\n * @param {Number[]} [result] The array onto which to store the result.\n * @returns {Number[]} An array containing the 3D coordinates corresponding to the Morton index.\n * @private\n */\nMortonOrder.decode3D = function (mortonIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"mortonIndex\", mortonIndex);\n  if (mortonIndex < 0 || mortonIndex > 1073741823) {\n    throw new DeveloperError(\"input must be a 30-bit unsigned integer\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Array(3);\n  }\n\n  result[0] = removeTwoSpacing(mortonIndex);\n  result[1] = removeTwoSpacing(mortonIndex >> 1);\n  result[2] = removeTwoSpacing(mortonIndex >> 2);\n  return result;\n};\n\nexport default MortonOrder;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Represents a scalar value's lower and upper bound at a near distance and far distance in eye space.\n * @alias NearFarScalar\n * @constructor\n *\n * @param {Number} [near=0.0] The lower bound of the camera range.\n * @param {Number} [nearValue=0.0] The value at the lower bound of the camera range.\n * @param {Number} [far=1.0] The upper bound of the camera range.\n * @param {Number} [farValue=0.0] The value at the upper bound of the camera range.\n *\n * @see Packable\n */\nfunction NearFarScalar(near, nearValue, far, farValue) {\n  /**\n   * The lower bound of the camera range.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.near = defaultValue(near, 0.0);\n  /**\n   * The value at the lower bound of the camera range.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.nearValue = defaultValue(nearValue, 0.0);\n  /**\n   * The upper bound of the camera range.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.far = defaultValue(far, 1.0);\n  /**\n   * The value at the upper bound of the camera range.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.farValue = defaultValue(farValue, 0.0);\n}\n\n/**\n * Duplicates a NearFarScalar instance.\n *\n * @param {NearFarScalar} nearFarScalar The NearFarScalar to duplicate.\n * @param {NearFarScalar} [result] The object onto which to store the result.\n * @returns {NearFarScalar} The modified result parameter or a new NearFarScalar instance if one was not provided. (Returns undefined if nearFarScalar is undefined)\n */\nNearFarScalar.clone = function (nearFarScalar, result) {\n  if (!defined(nearFarScalar)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new NearFarScalar(\n      nearFarScalar.near,\n      nearFarScalar.nearValue,\n      nearFarScalar.far,\n      nearFarScalar.farValue\n    );\n  }\n\n  result.near = nearFarScalar.near;\n  result.nearValue = nearFarScalar.nearValue;\n  result.far = nearFarScalar.far;\n  result.farValue = nearFarScalar.farValue;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nNearFarScalar.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {NearFarScalar} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nNearFarScalar.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.near;\n  array[startingIndex++] = value.nearValue;\n  array[startingIndex++] = value.far;\n  array[startingIndex] = value.farValue;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {NearFarScalar} [result] The object into which to store the result.\n * @returns {NearFarScalar} The modified result parameter or a new NearFarScalar instance if one was not provided.\n */\nNearFarScalar.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new NearFarScalar();\n  }\n  result.near = array[startingIndex++];\n  result.nearValue = array[startingIndex++];\n  result.far = array[startingIndex++];\n  result.farValue = array[startingIndex];\n  return result;\n};\n\n/**\n * Compares the provided NearFarScalar and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {NearFarScalar} [left] The first NearFarScalar.\n * @param {NearFarScalar} [right] The second NearFarScalar.\n * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nNearFarScalar.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.near === right.near &&\n      left.nearValue === right.nearValue &&\n      left.far === right.far &&\n      left.farValue === right.farValue)\n  );\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {NearFarScalar} [result] The object onto which to store the result.\n * @returns {NearFarScalar} The modified result parameter or a new NearFarScalar instance if one was not provided.\n */\nNearFarScalar.prototype.clone = function (result) {\n  return NearFarScalar.clone(this, result);\n};\n\n/**\n * Compares this instance to the provided NearFarScalar and returns <code>true</code> if they are equal,\n * <code>false</code> otherwise.\n *\n * @param {NearFarScalar} [right] The right hand side NearFarScalar.\n * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.\n */\nNearFarScalar.prototype.equals = function (right) {\n  return NearFarScalar.equals(this, right);\n};\nexport default NearFarScalar;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Visibility from \"./Visibility.js\";\n\n/**\n * Creates an Occluder derived from an object's position and radius, as well as the camera position.\n * The occluder can be used to determine whether or not other objects are visible or hidden behind the\n * visible horizon defined by the occluder and camera position.\n *\n * @alias Occluder\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n *\n * @constructor\n *\n * @example\n * // Construct an occluder one unit away from the origin with a radius of one.\n * const cameraPosition = Cesium.Cartesian3.ZERO;\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n */\nfunction Occluder(occluderBoundingSphere, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  this._occluderRadius = occluderBoundingSphere.radius;\n\n  this._horizonDistance = 0.0;\n  this._horizonPlaneNormal = undefined;\n  this._horizonPlanePosition = undefined;\n  this._cameraPosition = undefined;\n\n  // cameraPosition fills in the above values\n  this.cameraPosition = cameraPosition;\n}\n\nconst scratchCartesian3 = new Cartesian3();\n\nObject.defineProperties(Occluder.prototype, {\n  /**\n   * The position of the occluder.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._occluderPosition;\n    },\n  },\n\n  /**\n   * The radius of the occluder.\n   * @memberof Occluder.prototype\n   * @type {Number}\n   */\n  radius: {\n    get: function () {\n      return this._occluderRadius;\n    },\n  },\n\n  /**\n   * The position of the camera.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    set: function (cameraPosition) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(cameraPosition)) {\n        throw new DeveloperError(\"cameraPosition is required.\");\n      }\n      //>>includeEnd('debug');\n\n      cameraPosition = Cartesian3.clone(cameraPosition, this._cameraPosition);\n\n      const cameraToOccluderVec = Cartesian3.subtract(\n        this._occluderPosition,\n        cameraPosition,\n        scratchCartesian3\n      );\n      let invCameraToOccluderDistance = Cartesian3.magnitudeSquared(\n        cameraToOccluderVec\n      );\n      const occluderRadiusSqrd = this._occluderRadius * this._occluderRadius;\n\n      let horizonDistance;\n      let horizonPlaneNormal;\n      let horizonPlanePosition;\n      if (invCameraToOccluderDistance > occluderRadiusSqrd) {\n        horizonDistance = Math.sqrt(\n          invCameraToOccluderDistance - occluderRadiusSqrd\n        );\n        invCameraToOccluderDistance =\n          1.0 / Math.sqrt(invCameraToOccluderDistance);\n        horizonPlaneNormal = Cartesian3.multiplyByScalar(\n          cameraToOccluderVec,\n          invCameraToOccluderDistance,\n          scratchCartesian3\n        );\n        const nearPlaneDistance =\n          horizonDistance * horizonDistance * invCameraToOccluderDistance;\n        horizonPlanePosition = Cartesian3.add(\n          cameraPosition,\n          Cartesian3.multiplyByScalar(\n            horizonPlaneNormal,\n            nearPlaneDistance,\n            scratchCartesian3\n          ),\n          scratchCartesian3\n        );\n      } else {\n        horizonDistance = Number.MAX_VALUE;\n      }\n\n      this._horizonDistance = horizonDistance;\n      this._horizonPlaneNormal = horizonPlaneNormal;\n      this._horizonPlanePosition = horizonPlanePosition;\n      this._cameraPosition = cameraPosition;\n    },\n  },\n});\n\n/**\n * Creates an occluder from a bounding sphere and the camera position.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n * @param {Occluder} [result] The object onto which to store the result.\n * @returns {Occluder} The occluder derived from an object's position and radius, as well as the camera position.\n */\nOccluder.fromBoundingSphere = function (\n  occluderBoundingSphere,\n  cameraPosition,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Occluder(occluderBoundingSphere, cameraPosition);\n  }\n\n  Cartesian3.clone(occluderBoundingSphere.center, result._occluderPosition);\n  result._occluderRadius = occluderBoundingSphere.radius;\n  result.cameraPosition = cameraPosition;\n\n  return result;\n};\n\nconst tempVecScratch = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point surrounding the occludee object.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const point = new Cesium.Cartesian3(0, 0, -3);\n * occluder.isPointVisible(point); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isPointVisible = function (occludee) {\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    let tempVec = Cartesian3.subtract(\n      occludee,\n      this._occluderPosition,\n      tempVecScratch\n    );\n    let temp = this._occluderRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (temp > 0.0) {\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(occludee, this._cameraPosition, tempVec);\n      return temp * temp > Cartesian3.magnitudeSquared(tempVec);\n    }\n  }\n  return false;\n};\n\nconst occludeePositionScratch = new Cartesian3();\n\n/**\n * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {BoundingSphere} occludee The bounding sphere surrounding the occludee object.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * const bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);\n * occluder.isBoundingSphereVisible(bigSphere); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isBoundingSphereVisible = function (occludee) {\n  const occludeePosition = Cartesian3.clone(\n    occludee.center,\n    occludeePositionScratch\n  );\n  const occludeeRadius = occludee.radius;\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    let tempVec = Cartesian3.subtract(\n      occludeePosition,\n      this._occluderPosition,\n      tempVecScratch\n    );\n    let temp = this._occluderRadius - occludeeRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (occludeeRadius < this._occluderRadius) {\n      if (temp > 0.0) {\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        tempVec = Cartesian3.subtract(\n          occludeePosition,\n          this._cameraPosition,\n          tempVec\n        );\n        return (\n          temp * temp + occludeeRadius * occludeeRadius >\n          Cartesian3.magnitudeSquared(tempVec)\n        );\n      }\n      return false;\n    }\n\n    // Prevent against the case where the occludee radius is larger than the occluder's; since this is\n    // an uncommon case, the following code should rarely execute.\n    if (temp > 0.0) {\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._cameraPosition,\n        tempVec\n      );\n      const tempVecMagnitudeSquared = Cartesian3.magnitudeSquared(tempVec);\n      const occluderRadiusSquared = this._occluderRadius * this._occluderRadius;\n      const occludeeRadiusSquared = occludeeRadius * occludeeRadius;\n      if (\n        (this._horizonDistance * this._horizonDistance +\n          occluderRadiusSquared) *\n          occludeeRadiusSquared >\n        tempVecMagnitudeSquared * occluderRadiusSquared\n      ) {\n        // The occludee is close enough that the occluder cannot possible occlude the occludee\n        return true;\n      }\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      return temp * temp + occludeeRadiusSquared > tempVecMagnitudeSquared;\n    }\n\n    // The occludee completely encompasses the occluder\n    return true;\n  }\n\n  return false;\n};\n\nconst tempScratch = new Cartesian3();\n/**\n * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).\n *\n * @param {BoundingSphere} occludeeBS The bounding sphere of the occludee.\n * @returns {Visibility} Visibility.NONE if the occludee is not visible,\n *                       Visibility.PARTIAL if the occludee is partially visible, or\n *                       Visibility.FULL if the occludee is fully visible.\n *\n *\n * @example\n * const sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);\n * const sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluder = new Cesium.Occluder(sphere1, cameraPosition);\n * occluder.computeVisibility(sphere2); //returns Visibility.NONE\n *\n * @see Occluder#isVisible\n */\nOccluder.prototype.computeVisibility = function (occludeeBS) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occludeeBS)) {\n    throw new DeveloperError(\"occludeeBS is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // If the occludee radius is larger than the occluders, this will return that\n  // the entire ocludee is visible, even though that may not be the case, though this should\n  // not occur too often.\n  const occludeePosition = Cartesian3.clone(occludeeBS.center);\n  const occludeeRadius = occludeeBS.radius;\n\n  if (occludeeRadius > this._occluderRadius) {\n    return Visibility.FULL;\n  }\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    // The camera is outside the occluder\n    let tempVec = Cartesian3.subtract(\n      occludeePosition,\n      this._occluderPosition,\n      tempScratch\n    );\n    let temp = this._occluderRadius - occludeeRadius;\n    const occluderToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n    temp = occluderToOccludeeDistSqrd - temp * temp;\n    if (temp > 0.0) {\n      // The occludee is not completely inside the occluder\n      // Check to see if the occluder completely hides the occludee\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._cameraPosition,\n        tempVec\n      );\n      const cameraToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n      if (\n        temp * temp + occludeeRadius * occludeeRadius <\n        cameraToOccludeeDistSqrd\n      ) {\n        return Visibility.NONE;\n      }\n\n      // Check to see whether the occluder is fully or partially visible\n      // when the occludee does not intersect the occluder\n      temp = this._occluderRadius + occludeeRadius;\n      temp = occluderToOccludeeDistSqrd - temp * temp;\n      if (temp > 0.0) {\n        // The occludee does not intersect the occluder.\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        return cameraToOccludeeDistSqrd <\n          temp * temp + occludeeRadius * occludeeRadius\n          ? Visibility.FULL\n          : Visibility.PARTIAL;\n      }\n\n      //Check to see if the occluder is fully or partially visible when the occludee DOES\n      //intersect the occluder\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._horizonPlanePosition,\n        tempVec\n      );\n      return Cartesian3.dot(tempVec, this._horizonPlaneNormal) > -occludeeRadius\n        ? Visibility.PARTIAL\n        : Visibility.FULL;\n    }\n  }\n  return Visibility.NONE;\n};\n\nconst occludeePointScratch = new Cartesian3();\n/**\n * Computes a point that can be used as the occludee position to the visibility functions.\n * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around\n * an object that is used for visibility; however it is also possible to compute a point that if\n * seen/not seen would also indicate if an object is visible/not visible.  This function is better\n * called for objects that do not move relative to the occluder and is large, such as a chunk of\n * terrain.  You are better off not calling this and using the object's bounding sphere for objects\n * such as a satellite or ground vehicle.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.\n * @param {Cartesian3[]} positions List of altitude points on the horizon near the surface of the occluder.\n * @returns {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n *\n * @exception {DeveloperError} <code>positions</code> must contain at least one element.\n * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBoundingSphere.center</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);\n * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n * const positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];\n * const tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);\n * const occludeePosition = tileOccluderSphere.center;\n * const occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);\n */\nOccluder.computeOccludeePoint = function (\n  occluderBoundingSphere,\n  occludeePosition,\n  positions\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n  if (positions.length === 0) {\n    throw new DeveloperError(\"positions must contain at least one element\");\n  }\n  //>>includeEnd('debug');\n\n  const occludeePos = Cartesian3.clone(occludeePosition);\n  const occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  const occluderRadius = occluderBoundingSphere.radius;\n  const numPositions = positions.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Cartesian3.equals(occluderPosition, occludeePosition)) {\n    throw new DeveloperError(\n      \"occludeePosition must be different than occluderBoundingSphere.center\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Compute a plane with a normal from the occluder to the occludee position.\n  const occluderPlaneNormal = Cartesian3.normalize(\n    Cartesian3.subtract(occludeePos, occluderPosition, occludeePointScratch),\n    occludeePointScratch\n  );\n  const occluderPlaneD = -Cartesian3.dot(occluderPlaneNormal, occluderPosition);\n\n  //For each position, determine the horizon intersection. Choose the position and intersection\n  //that results in the greatest angle with the occcluder plane.\n  const aRotationVector = Occluder._anyRotationVector(\n    occluderPosition,\n    occluderPlaneNormal,\n    occluderPlaneD\n  );\n  let dot = Occluder._horizonToPlaneNormalDotProduct(\n    occluderBoundingSphere,\n    occluderPlaneNormal,\n    occluderPlaneD,\n    aRotationVector,\n    positions[0]\n  );\n  if (!dot) {\n    //The position is inside the mimimum radius, which is invalid\n    return undefined;\n  }\n  let tempDot;\n  for (let i = 1; i < numPositions; ++i) {\n    tempDot = Occluder._horizonToPlaneNormalDotProduct(\n      occluderBoundingSphere,\n      occluderPlaneNormal,\n      occluderPlaneD,\n      aRotationVector,\n      positions[i]\n    );\n    if (!tempDot) {\n      //The position is inside the minimum radius, which is invalid\n      return undefined;\n    }\n    if (tempDot < dot) {\n      dot = tempDot;\n    }\n  }\n  //Verify that the dot is not near 90 degress\n  if (dot < 0.00174532836589830883577820272085) {\n    return undefined;\n  }\n\n  const distance = occluderRadius / dot;\n  return Cartesian3.add(\n    occluderPosition,\n    Cartesian3.multiplyByScalar(\n      occluderPlaneNormal,\n      distance,\n      occludeePointScratch\n    ),\n    occludeePointScratch\n  );\n};\n\nconst computeOccludeePointFromRectangleScratch = [];\n/**\n * Computes a point that can be used as the occludee position to the visibility functions from a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n * @returns {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n */\nOccluder.computeOccludeePointFromRectangle = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  const positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    0.0,\n    computeOccludeePointFromRectangleScratch\n  );\n  const bs = BoundingSphere.fromPoints(positions);\n\n  // TODO: get correct ellipsoid center\n  const ellipsoidCenter = Cartesian3.ZERO;\n  if (!Cartesian3.equals(ellipsoidCenter, bs.center)) {\n    return Occluder.computeOccludeePoint(\n      new BoundingSphere(ellipsoidCenter, ellipsoid.minimumRadius),\n      bs.center,\n      positions\n    );\n  }\n\n  return undefined;\n};\n\nconst tempVec0Scratch = new Cartesian3();\nOccluder._anyRotationVector = function (\n  occluderPosition,\n  occluderPlaneNormal,\n  occluderPlaneD\n) {\n  const tempVec0 = Cartesian3.abs(occluderPlaneNormal, tempVec0Scratch);\n  let majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;\n  if (\n    (majorAxis === 0 && tempVec0.z > tempVec0.x) ||\n    (majorAxis === 1 && tempVec0.z > tempVec0.y)\n  ) {\n    majorAxis = 2;\n  }\n  const tempVec = new Cartesian3();\n  let tempVec1;\n  if (majorAxis === 0) {\n    tempVec0.x = occluderPosition.x;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_X;\n  } else if (majorAxis === 1) {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_Y;\n  } else {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z;\n    tempVec1 = Cartesian3.UNIT_Z;\n  }\n  const u =\n    (Cartesian3.dot(occluderPlaneNormal, tempVec0) + occluderPlaneD) /\n    -Cartesian3.dot(occluderPlaneNormal, tempVec1);\n  return Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.add(\n        tempVec0,\n        Cartesian3.multiplyByScalar(tempVec1, u, tempVec),\n        tempVec0\n      ),\n      occluderPosition,\n      tempVec0\n    ),\n    tempVec0\n  );\n};\n\nconst posDirectionScratch = new Cartesian3();\nOccluder._rotationVector = function (\n  occluderPosition,\n  occluderPlaneNormal,\n  occluderPlaneD,\n  position,\n  anyRotationVector\n) {\n  //Determine the angle between the occluder plane normal and the position direction\n  let positionDirection = Cartesian3.subtract(\n    position,\n    occluderPosition,\n    posDirectionScratch\n  );\n  positionDirection = Cartesian3.normalize(\n    positionDirection,\n    positionDirection\n  );\n  if (\n    Cartesian3.dot(occluderPlaneNormal, positionDirection) <\n    0.99999998476912904932780850903444\n  ) {\n    const crossProduct = Cartesian3.cross(\n      occluderPlaneNormal,\n      positionDirection,\n      positionDirection\n    );\n    const length = Cartesian3.magnitude(crossProduct);\n    if (length > CesiumMath.EPSILON13) {\n      return Cartesian3.normalize(crossProduct, new Cartesian3());\n    }\n  }\n  //The occluder plane normal and the position direction are colinear. Use any\n  //vector in the occluder plane as the rotation vector\n  return anyRotationVector;\n};\n\nconst posScratch1 = new Cartesian3();\nconst occluerPosScratch = new Cartesian3();\nconst posScratch2 = new Cartesian3();\nconst horizonPlanePosScratch = new Cartesian3();\nOccluder._horizonToPlaneNormalDotProduct = function (\n  occluderBS,\n  occluderPlaneNormal,\n  occluderPlaneD,\n  anyRotationVector,\n  position\n) {\n  const pos = Cartesian3.clone(position, posScratch1);\n  const occluderPosition = Cartesian3.clone(\n    occluderBS.center,\n    occluerPosScratch\n  );\n  const occluderRadius = occluderBS.radius;\n\n  //Verify that the position is outside the occluder\n  let positionToOccluder = Cartesian3.subtract(\n    occluderPosition,\n    pos,\n    posScratch2\n  );\n  const occluderToPositionDistanceSquared = Cartesian3.magnitudeSquared(\n    positionToOccluder\n  );\n  const occluderRadiusSquared = occluderRadius * occluderRadius;\n  if (occluderToPositionDistanceSquared < occluderRadiusSquared) {\n    return false;\n  }\n\n  //Horizon parameters\n  const horizonDistanceSquared =\n    occluderToPositionDistanceSquared - occluderRadiusSquared;\n  const horizonDistance = Math.sqrt(horizonDistanceSquared);\n  const occluderToPositionDistance = Math.sqrt(\n    occluderToPositionDistanceSquared\n  );\n  const invOccluderToPositionDistance = 1.0 / occluderToPositionDistance;\n  const cosTheta = horizonDistance * invOccluderToPositionDistance;\n  const horizonPlaneDistance = cosTheta * horizonDistance;\n  positionToOccluder = Cartesian3.normalize(\n    positionToOccluder,\n    positionToOccluder\n  );\n  const horizonPlanePosition = Cartesian3.add(\n    pos,\n    Cartesian3.multiplyByScalar(\n      positionToOccluder,\n      horizonPlaneDistance,\n      horizonPlanePosScratch\n    ),\n    horizonPlanePosScratch\n  );\n  const horizonCrossDistance = Math.sqrt(\n    horizonDistanceSquared - horizonPlaneDistance * horizonPlaneDistance\n  );\n\n  //Rotate the position to occluder vector 90 degrees\n  let tempVec = this._rotationVector(\n    occluderPosition,\n    occluderPlaneNormal,\n    occluderPlaneD,\n    pos,\n    anyRotationVector\n  );\n  let horizonCrossDirection = Cartesian3.fromElements(\n    tempVec.x * tempVec.x * positionToOccluder.x +\n      (tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y +\n      (tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z,\n    (tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x +\n      tempVec.y * tempVec.y * positionToOccluder.y +\n      (tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z,\n    (tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x +\n      (tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y +\n      tempVec.z * tempVec.z * positionToOccluder.z,\n    posScratch1\n  );\n  horizonCrossDirection = Cartesian3.normalize(\n    horizonCrossDirection,\n    horizonCrossDirection\n  );\n\n  //Horizon positions\n  const offset = Cartesian3.multiplyByScalar(\n    horizonCrossDirection,\n    horizonCrossDistance,\n    posScratch1\n  );\n  tempVec = Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.add(horizonPlanePosition, offset, posScratch2),\n      occluderPosition,\n      posScratch2\n    ),\n    posScratch2\n  );\n  const dot0 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  tempVec = Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.subtract(horizonPlanePosition, offset, tempVec),\n      occluderPosition,\n      tempVec\n    ),\n    tempVec\n  );\n  const dot1 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  return dot0 < dot1 ? dot0 : dot1;\n};\nexport default Occluder;\n","import Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Value and type information for per-instance geometry attribute that determines the geometry instance offset\n *\n * @alias OffsetGeometryInstanceAttribute\n * @constructor\n *\n * @param {Number} [x=0] The x translation\n * @param {Number} [y=0] The y translation\n * @param {Number} [z=0] The z translation\n *\n * @private\n *\n * @see GeometryInstance\n * @see GeometryInstanceAttribute\n */\nfunction OffsetGeometryInstanceAttribute(x, y, z) {\n  x = defaultValue(x, 0);\n  y = defaultValue(y, 0);\n  z = defaultValue(z, 0);\n\n  /**\n   * The values for the attributes stored in a typed array.\n   *\n   * @type Float32Array\n   */\n  this.value = new Float32Array([x, y, z]);\n}\n\nObject.defineProperties(OffsetGeometryInstanceAttribute.prototype, {\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link OffsetGeometryInstanceAttribute#value}.\n   *\n   * @memberof OffsetGeometryInstanceAttribute.prototype\n   *\n   * @type {ComponentDatatype}\n   * @readonly\n   *\n   * @default {@link ComponentDatatype.FLOAT}\n   */\n  componentDatatype: {\n    get: function () {\n      return ComponentDatatype.FLOAT;\n    },\n  },\n\n  /**\n   * The number of components in the attributes, i.e., {@link OffsetGeometryInstanceAttribute#value}.\n   *\n   * @memberof OffsetGeometryInstanceAttribute.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @default 3\n   */\n  componentsPerAttribute: {\n    get: function () {\n      return 3;\n    },\n  },\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   *\n   * @memberof OffsetGeometryInstanceAttribute.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  normalize: {\n    get: function () {\n      return false;\n    },\n  },\n});\n\n/**\n * Creates a new {@link OffsetGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\n *\n * @param {Cartesian3} offset The cartesian offset\n * @returns {OffsetGeometryInstanceAttribute} The new {@link OffsetGeometryInstanceAttribute} instance.\n */\nOffsetGeometryInstanceAttribute.fromCartesian3 = function (offset) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"offset\", offset);\n  //>>includeEnd('debug');\n\n  return new OffsetGeometryInstanceAttribute(offset.x, offset.y, offset.z);\n};\n\n/**\n * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\n *\n * @param {Cartesian3} offset The cartesian offset\n * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\n * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.modelMatrix = Cesium.OffsetGeometryInstanceAttribute.toValue(modelMatrix, attributes.modelMatrix);\n */\nOffsetGeometryInstanceAttribute.toValue = function (offset, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"offset\", offset);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Float32Array([offset.x, offset.y, offset.z]);\n  }\n\n  result[0] = offset.x;\n  result[1] = offset.y;\n  result[2] = offset.z;\n  return result;\n};\nexport default OffsetGeometryInstanceAttribute;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport combine from \"./combine.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n\n/**\n * Provides geocoding via a {@link https://opencagedata.com/|OpenCage} server.\n * @alias OpenCageGeocoderService\n * @constructor\n *\n * @param {Resource|String} url The endpoint to the OpenCage server.\n * @param {String} apiKey The OpenCage API Key.\n * @param {Object} [params] An object with the following properties (See https://opencagedata.com/api#forward-opt):\n * @param {Number} [params.abbrv] When set to 1 we attempt to abbreviate and shorten the formatted string we return.\n * @param {Number} [options.add_request] When set to 1 the various request parameters are added to the response for ease of debugging.\n * @param {String} [options.bounds] Provides the geocoder with a hint to the region that the query resides in.\n * @param {String} [options.countrycode] Restricts the results to the specified country or countries (as defined by the ISO 3166-1 Alpha 2 standard).\n * @param {String} [options.jsonp] Wraps the returned JSON with a function name.\n * @param {String} [options.language] An IETF format language code.\n * @param {Number} [options.limit] The maximum number of results we should return.\n * @param {Number} [options.min_confidence] An integer from 1-10. Only results with at least this confidence will be returned.\n * @param {Number} [options.no_annotations] When set to 1 results will not contain annotations.\n * @param {Number} [options.no_dedupe] When set to 1 results will not be deduplicated.\n * @param {Number} [options.no_record] When set to 1 the query contents are not logged.\n * @param {Number} [options.pretty] When set to 1 results are 'pretty' printed for easier reading. Useful for debugging.\n * @param {String} [options.proximity] Provides the geocoder with a hint to bias results in favour of those closer to the specified location (For example: 41.40139,2.12870).\n *\n * @example\n * // Configure a Viewer to use the OpenCage Geocoder\n * const viewer = new Cesium.Viewer('cesiumContainer', {\n *   geocoder: new Cesium.OpenCageGeocoderService('https://api.opencagedata.com/geocode/v1/', '<API key>')\n * });\n */\nfunction OpenCageGeocoderService(url, apiKey, params) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  Check.defined(\"apiKey\", apiKey);\n  if (defined(params)) {\n    Check.typeOf.object(\"params\", params);\n  }\n  //>>includeEnd('debug');\n\n  url = Resource.createIfNeeded(url);\n  url.appendForwardSlash();\n  url.setQueryParameters({ key: apiKey });\n  this._url = url;\n  this._params = defaultValue(params, {});\n}\n\nObject.defineProperties(OpenCageGeocoderService.prototype, {\n  /**\n   * The Resource used to access the OpenCage endpoint.\n   * @type {Resource}\n   * @memberof OpenCageGeocoderService.prototype\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._url;\n    },\n  },\n  /**\n   * Optional params passed to OpenCage in order to customize geocoding\n   * @type {Object}\n   * @memberof OpenCageGeocoderService.prototype\n   * @readonly\n   */\n  params: {\n    get: function () {\n      return this._params;\n    },\n  },\n});\n\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @returns {Promise<GeocoderService.Result[]>}\n */\nOpenCageGeocoderService.prototype.geocode = function (query) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"query\", query);\n  //>>includeEnd('debug');\n\n  const resource = this._url.getDerivedResource({\n    url: \"json\",\n    queryParameters: combine(this._params, { q: query }),\n  });\n  return resource.fetchJson().then(function (response) {\n    return response.results.map(function (resultObject) {\n      let destination;\n      const bounds = resultObject.bounds;\n\n      if (defined(bounds)) {\n        destination = Rectangle.fromDegrees(\n          bounds.southwest.lng,\n          bounds.southwest.lat,\n          bounds.northeast.lng,\n          bounds.northeast.lat\n        );\n      } else {\n        const lon = resultObject.geometry.lat;\n        const lat = resultObject.geometry.lng;\n        destination = Cartesian3.fromDegrees(lon, lat);\n      }\n\n      return {\n        displayName: resultObject.formatted,\n        destination: destination,\n      };\n    });\n  });\n};\nexport default OpenCageGeocoderService;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Creates an instance of an OrientedBoundingBox.\n * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n * @alias OrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\n *                                          cube centered at the origin.\n *\n *\n * @example\n * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\n * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\n *\n * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction OrientedBoundingBox(center, halfAxes) {\n  /**\n   * The center of the box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n  /**\n   * The transformation matrix, to rotate the box to the right position.\n   * @type {Matrix3}\n   * @default {@link Matrix3.ZERO}\n   */\n  this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nOrientedBoundingBox.packedLength =\n  Cartesian3.packedLength + Matrix3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrientedBoundingBox} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nOrientedBoundingBox.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value.center, array, startingIndex);\n  Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrientedBoundingBox} [result] The object into which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  Cartesian3.unpack(array, startingIndex, result.center);\n  Matrix3.unpack(\n    array,\n    startingIndex + Cartesian3.packedLength,\n    result.halfAxes\n  );\n  return result;\n};\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nconst scratchCartesian6 = new Cartesian3();\nconst scratchCovarianceResult = new Matrix3();\nconst scratchEigenResult = {\n  unitary: new Matrix3(),\n  diagonal: new Matrix3(),\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n *\n * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an object oriented bounding box enclosing two points.\n * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nOrientedBoundingBox.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.halfAxes = Matrix3.ZERO;\n    result.center = Cartesian3.ZERO;\n    return result;\n  }\n\n  let i;\n  const length = positions.length;\n\n  const meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\n  for (i = 1; i < length; i++) {\n    Cartesian3.add(meanPoint, positions[i], meanPoint);\n  }\n  const invLength = 1.0 / length;\n  Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n  let p;\n\n  for (i = 0; i < length; i++) {\n    p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const eigenDecomposition = Matrix3.computeEigenDecomposition(\n    covarianceMatrix,\n    scratchEigenResult\n  );\n  const rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\n\n  let v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\n  let v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\n  let v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (i = 0; i < length; i++) {\n    p = positions[i];\n    u1 = Math.max(Cartesian3.dot(v1, p), u1);\n    u2 = Math.max(Cartesian3.dot(v2, p), u2);\n    u3 = Math.max(Cartesian3.dot(v3, p), u3);\n\n    l1 = Math.min(Cartesian3.dot(v1, p), l1);\n    l2 = Math.min(Cartesian3.dot(v2, p), l2);\n    l3 = Math.min(Cartesian3.dot(v3, p), l3);\n  }\n\n  v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\n  v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\n  v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\n\n  const center = Cartesian3.add(v1, v2, result.center);\n  Cartesian3.add(center, v3, center);\n\n  const scale = scratchCartesian3;\n  scale.x = u1 - l1;\n  scale.y = u2 - l2;\n  scale.z = u3 - l3;\n  Cartesian3.multiplyByScalar(scale, 0.5, scale);\n  Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\n\n  return result;\n};\n\nconst scratchOffset = new Cartesian3();\nconst scratchScale = new Cartesian3();\nfunction fromPlaneExtents(\n  planeOrigin,\n  planeXAxis,\n  planeYAxis,\n  planeZAxis,\n  minimumX,\n  maximumX,\n  minimumY,\n  maximumY,\n  minimumZ,\n  maximumZ,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(minimumX) ||\n    !defined(maximumX) ||\n    !defined(minimumY) ||\n    !defined(maximumY) ||\n    !defined(minimumZ) ||\n    !defined(maximumZ)\n  ) {\n    throw new DeveloperError(\n      \"all extents (minimum/maximum X/Y/Z) are required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  const halfAxes = result.halfAxes;\n  Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\n\n  let centerOffset = scratchOffset;\n  centerOffset.x = (minimumX + maximumX) / 2.0;\n  centerOffset.y = (minimumY + maximumY) / 2.0;\n  centerOffset.z = (minimumZ + maximumZ) / 2.0;\n\n  const scale = scratchScale;\n  scale.x = (maximumX - minimumX) / 2.0;\n  scale.y = (maximumY - minimumY) / 2.0;\n  scale.z = (maximumZ - minimumZ) / 2.0;\n\n  const center = result.center;\n  centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\n  Cartesian3.add(planeOrigin, centerOffset, center);\n  Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\n\n  return result;\n}\n\nconst scratchRectangleCenterCartographic = new Cartographic();\nconst scratchRectangleCenter = new Cartesian3();\nconst scratchPerimeterCartographicNC = new Cartographic();\nconst scratchPerimeterCartographicNW = new Cartographic();\nconst scratchPerimeterCartographicCW = new Cartographic();\nconst scratchPerimeterCartographicSW = new Cartographic();\nconst scratchPerimeterCartographicSC = new Cartographic();\nconst scratchPerimeterCartesianNC = new Cartesian3();\nconst scratchPerimeterCartesianNW = new Cartesian3();\nconst scratchPerimeterCartesianCW = new Cartesian3();\nconst scratchPerimeterCartesianSW = new Cartesian3();\nconst scratchPerimeterCartesianSC = new Cartesian3();\nconst scratchPerimeterProjectedNC = new Cartesian2();\nconst scratchPerimeterProjectedNW = new Cartesian2();\nconst scratchPerimeterProjectedCW = new Cartesian2();\nconst scratchPerimeterProjectedSW = new Cartesian2();\nconst scratchPerimeterProjectedSC = new Cartesian2();\n\nconst scratchPlaneOrigin = new Cartesian3();\nconst scratchPlaneNormal = new Cartesian3();\nconst scratchPlaneXAxis = new Cartesian3();\nconst scratchHorizonCartesian = new Cartesian3();\nconst scratchHorizonProjected = new Cartesian2();\nconst scratchMaxY = new Cartesian3();\nconst scratchMinY = new Cartesian3();\nconst scratchZ = new Cartesian3();\nconst scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\n\n/**\n * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\n * There are no guarantees about the orientation of the bounding box.\n *\n * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\n * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\n * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n *\n * @exception {DeveloperError} rectangle.width must be between 0 and pi.\n * @exception {DeveloperError} rectangle.height must be between 0 and pi.\n * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\n */\nOrientedBoundingBox.fromRectangle = function (\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\n    throw new DeveloperError(\"Rectangle width must be between 0 and 2*pi\");\n  }\n  if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\n    throw new DeveloperError(\"Rectangle height must be between 0 and pi\");\n  }\n  if (\n    defined(ellipsoid) &&\n    !CesiumMath.equalsEpsilon(\n      ellipsoid.radii.x,\n      ellipsoid.radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  minimumHeight = defaultValue(minimumHeight, 0.0);\n  maximumHeight = defaultValue(maximumHeight, 0.0);\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  let minX, maxX, minY, maxY, minZ, maxZ, plane;\n\n  if (rectangle.width <= CesiumMath.PI) {\n    // The bounding box will be aligned with the tangent plane at the center of the rectangle.\n    const tangentPointCartographic = Rectangle.center(\n      rectangle,\n      scratchRectangleCenterCartographic\n    );\n    const tangentPoint = ellipsoid.cartographicToCartesian(\n      tangentPointCartographic,\n      scratchRectangleCenter\n    );\n    const tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\n    plane = tangentPlane.plane;\n\n    // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\n    const lonCenter = tangentPointCartographic.longitude;\n    const latCenter =\n      rectangle.south < 0.0 && rectangle.north > 0.0\n        ? 0.0\n        : tangentPointCartographic.latitude;\n\n    // Compute XY extents using the rectangle at maximum height\n    const perimeterCartographicNC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNC\n    );\n    const perimeterCartographicNW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.north,\n      maximumHeight,\n      scratchPerimeterCartographicNW\n    );\n    const perimeterCartographicCW = Cartographic.fromRadians(\n      rectangle.west,\n      latCenter,\n      maximumHeight,\n      scratchPerimeterCartographicCW\n    );\n    const perimeterCartographicSW = Cartographic.fromRadians(\n      rectangle.west,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSW\n    );\n    const perimeterCartographicSC = Cartographic.fromRadians(\n      lonCenter,\n      rectangle.south,\n      maximumHeight,\n      scratchPerimeterCartographicSC\n    );\n\n    const perimeterCartesianNC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNC,\n      scratchPerimeterCartesianNC\n    );\n    let perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    const perimeterCartesianCW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicCW,\n      scratchPerimeterCartesianCW\n    );\n    let perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n    const perimeterCartesianSC = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSC,\n      scratchPerimeterCartesianSC\n    );\n\n    const perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNC,\n      scratchPerimeterProjectedNC\n    );\n    const perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianNW,\n      scratchPerimeterProjectedNW\n    );\n    const perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianCW,\n      scratchPerimeterProjectedCW\n    );\n    const perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSW,\n      scratchPerimeterProjectedSW\n    );\n    const perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(\n      perimeterCartesianSC,\n      scratchPerimeterProjectedSC\n    );\n\n    minX = Math.min(\n      perimeterProjectedNW.x,\n      perimeterProjectedCW.x,\n      perimeterProjectedSW.x\n    );\n    maxX = -minX; // symmetrical\n\n    maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\n    minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\n\n    // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\n    perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\n    perimeterCartesianNW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicNW,\n      scratchPerimeterCartesianNW\n    );\n    perimeterCartesianSW = ellipsoid.cartographicToCartesian(\n      perimeterCartographicSW,\n      scratchPerimeterCartesianSW\n    );\n\n    minZ = Math.min(\n      Plane.getPointDistance(plane, perimeterCartesianNW),\n      Plane.getPointDistance(plane, perimeterCartesianSW)\n    );\n    maxZ = maximumHeight; // Since the tangent plane touches the surface at height = 0, this is okay\n\n    return fromPlaneExtents(\n      tangentPlane.origin,\n      tangentPlane.xAxis,\n      tangentPlane.yAxis,\n      tangentPlane.zAxis,\n      minX,\n      maxX,\n      minY,\n      maxY,\n      minZ,\n      maxZ,\n      result\n    );\n  }\n\n  // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\n  const fullyAboveEquator = rectangle.south > 0.0;\n  const fullyBelowEquator = rectangle.north < 0.0;\n  const latitudeNearestToEquator = fullyAboveEquator\n    ? rectangle.south\n    : fullyBelowEquator\n    ? rectangle.north\n    : 0.0;\n  const centerLongitude = Rectangle.center(\n    rectangle,\n    scratchRectangleCenterCartographic\n  ).longitude;\n\n  // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\n  // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\n  const planeOrigin = Cartesian3.fromRadians(\n    centerLongitude,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchPlaneOrigin\n  );\n  planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\n  const isPole =\n    Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 &&\n    Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\n  const planeNormal = !isPole\n    ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal)\n    : Cartesian3.UNIT_X;\n  const planeYAxis = Cartesian3.UNIT_Z;\n  const planeXAxis = Cartesian3.cross(\n    planeNormal,\n    planeYAxis,\n    scratchPlaneXAxis\n  );\n  plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\n\n  // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\n  const horizonCartesian = Cartesian3.fromRadians(\n    centerLongitude + CesiumMath.PI_OVER_TWO,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchHorizonCartesian\n  );\n  maxX = Cartesian3.dot(\n    Plane.projectPointOntoPlane(\n      plane,\n      horizonCartesian,\n      scratchHorizonProjected\n    ),\n    planeXAxis\n  );\n  minX = -maxX; // symmetrical\n\n  // Get the min and max Y, using the height that will give the largest extent\n  maxY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.north,\n    fullyBelowEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMaxY\n  ).z;\n  minY = Cartesian3.fromRadians(\n    0.0,\n    rectangle.south,\n    fullyAboveEquator ? minimumHeight : maximumHeight,\n    ellipsoid,\n    scratchMinY\n  ).z;\n\n  const farZ = Cartesian3.fromRadians(\n    rectangle.east,\n    latitudeNearestToEquator,\n    maximumHeight,\n    ellipsoid,\n    scratchZ\n  );\n  minZ = Plane.getPointDistance(plane, farZ);\n  maxZ = 0.0; // plane origin starts at maxZ already\n\n  // min and max are local to the plane axes\n  return fromPlaneExtents(\n    planeOrigin,\n    planeXAxis,\n    planeYAxis,\n    planeNormal,\n    minX,\n    maxX,\n    minY,\n    maxY,\n    minZ,\n    maxZ,\n    result\n  );\n};\n\n/**\n * Computes an OrientedBoundingBox that bounds an affine transformation.\n *\n * @param {Matrix4} transformation The affine transformation.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\n */\nOrientedBoundingBox.fromTransformation = function (transformation, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"transformation\", transformation);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new OrientedBoundingBox();\n  }\n\n  result.center = Matrix4.getTranslation(transformation, result.center);\n  result.halfAxes = Matrix4.getMatrix3(transformation, result.halfAxes);\n  result.halfAxes = Matrix3.multiplyByScalar(\n    result.halfAxes,\n    0.5,\n    result.halfAxes\n  );\n  return result;\n};\n\n/**\n * Duplicates a OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} box The bounding box to duplicate.\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nOrientedBoundingBox.clone = function (box, result) {\n  if (!defined(box)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new OrientedBoundingBox(box.center, box.halfAxes);\n  }\n\n  Cartesian3.clone(box.center, result.center);\n  Matrix3.clone(box.halfAxes, result.halfAxes);\n\n  return result;\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(plane)) {\n    throw new DeveloperError(\"plane is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const center = box.center;\n  const normal = plane.normal;\n  const halfAxes = box.halfAxes;\n  const normalX = normal.x,\n    normalY = normal.y,\n    normalZ = normal.z;\n  // plane is used as if it is its normal; the first three components are assumed to be normalized\n  const radEffective =\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN0ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN0ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN0ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN1ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN1ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN1ROW2]\n    ) +\n    Math.abs(\n      normalX * halfAxes[Matrix3.COLUMN2ROW0] +\n        normalY * halfAxes[Matrix3.COLUMN2ROW1] +\n        normalZ * halfAxes[Matrix3.COLUMN2ROW2]\n    );\n  const distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane <= -radEffective) {\n    // The entire box is on the negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane >= radEffective) {\n    // The entire box is on the positive side of the plane normal\n    return Intersect.INSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\nconst scratchCartesianU = new Cartesian3();\nconst scratchCartesianV = new Cartesian3();\nconst scratchCartesianW = new Cartesian3();\nconst scratchValidAxis2 = new Cartesian3();\nconst scratchValidAxis3 = new Cartesian3();\nconst scratchPPrime = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {OrientedBoundingBox} box The box.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nOrientedBoundingBox.distanceSquaredTo = function (box, cartesian) {\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\n\n  const halfAxes = box.halfAxes;\n  let u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  let v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  let w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  const uHalf = Cartesian3.magnitude(u);\n  const vHalf = Cartesian3.magnitude(v);\n  const wHalf = Cartesian3.magnitude(w);\n\n  let uValid = true;\n  let vValid = true;\n  let wValid = true;\n\n  if (uHalf > 0) {\n    Cartesian3.divideByScalar(u, uHalf, u);\n  } else {\n    uValid = false;\n  }\n\n  if (vHalf > 0) {\n    Cartesian3.divideByScalar(v, vHalf, v);\n  } else {\n    vValid = false;\n  }\n\n  if (wHalf > 0) {\n    Cartesian3.divideByScalar(w, wHalf, w);\n  } else {\n    wValid = false;\n  }\n\n  const numberOfDegenerateAxes = !uValid + !vValid + !wValid;\n  let validAxis1;\n  let validAxis2;\n  let validAxis3;\n\n  if (numberOfDegenerateAxes === 1) {\n    let degenerateAxis = u;\n    validAxis1 = v;\n    validAxis2 = w;\n    if (!vValid) {\n      degenerateAxis = v;\n      validAxis1 = u;\n    } else if (!wValid) {\n      degenerateAxis = w;\n      validAxis2 = u;\n    }\n\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n\n    if (degenerateAxis === u) {\n      u = validAxis3;\n    } else if (degenerateAxis === v) {\n      v = validAxis3;\n    } else if (degenerateAxis === w) {\n      w = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 2) {\n    validAxis1 = u;\n    if (vValid) {\n      validAxis1 = v;\n    } else if (wValid) {\n      validAxis1 = w;\n    }\n\n    let crossVector = Cartesian3.UNIT_Y;\n    if (crossVector.equalsEpsilon(validAxis1, CesiumMath.EPSILON3)) {\n      crossVector = Cartesian3.UNIT_X;\n    }\n\n    validAxis2 = Cartesian3.cross(validAxis1, crossVector, scratchValidAxis2);\n    Cartesian3.normalize(validAxis2, validAxis2);\n    validAxis3 = Cartesian3.cross(validAxis1, validAxis2, scratchValidAxis3);\n    Cartesian3.normalize(validAxis3, validAxis3);\n\n    if (validAxis1 === u) {\n      v = validAxis2;\n      w = validAxis3;\n    } else if (validAxis1 === v) {\n      w = validAxis2;\n      u = validAxis3;\n    } else if (validAxis1 === w) {\n      u = validAxis2;\n      v = validAxis3;\n    }\n  } else if (numberOfDegenerateAxes === 3) {\n    u = Cartesian3.UNIT_X;\n    v = Cartesian3.UNIT_Y;\n    w = Cartesian3.UNIT_Z;\n  }\n\n  const pPrime = scratchPPrime;\n  pPrime.x = Cartesian3.dot(offset, u);\n  pPrime.y = Cartesian3.dot(offset, v);\n  pPrime.z = Cartesian3.dot(offset, w);\n\n  let distanceSquared = 0.0;\n  let d;\n\n  if (pPrime.x < -uHalf) {\n    d = pPrime.x + uHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.x > uHalf) {\n    d = pPrime.x - uHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.y < -vHalf) {\n    d = pPrime.y + vHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.y > vHalf) {\n    d = pPrime.y - vHalf;\n    distanceSquared += d * d;\n  }\n\n  if (pPrime.z < -wHalf) {\n    d = pPrime.z + wHalf;\n    distanceSquared += d * d;\n  } else if (pPrime.z > wHalf) {\n    d = pPrime.z - wHalf;\n    distanceSquared += d * d;\n  }\n\n  return distanceSquared;\n};\n\nconst scratchCorner = new Cartesian3();\nconst scratchToCenter = new Cartesian3();\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.computePlaneDistances = function (\n  box,\n  position,\n  direction,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  let minDist = Number.POSITIVE_INFINITY;\n  let maxDist = Number.NEGATIVE_INFINITY;\n\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n\n  const u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\n  const v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\n  const w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\n\n  // project first corner\n  const corner = Cartesian3.add(u, v, scratchCorner);\n  Cartesian3.add(corner, w, corner);\n  Cartesian3.add(corner, center, corner);\n\n  const toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\n  let mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project second corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project third corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fourth corner\n  Cartesian3.add(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project fifth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project sixth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.add(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project seventh corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.add(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  // project eighth corner\n  Cartesian3.subtract(center, u, corner);\n  Cartesian3.subtract(corner, v, corner);\n  Cartesian3.subtract(corner, w, corner);\n\n  Cartesian3.subtract(corner, position, toCenter);\n  mag = Cartesian3.dot(direction, toCenter);\n\n  minDist = Math.min(mag, minDist);\n  maxDist = Math.max(mag, maxDist);\n\n  result.start = minDist;\n  result.stop = maxDist;\n  return result;\n};\n\nconst scratchXAxis = new Cartesian3();\nconst scratchYAxis = new Cartesian3();\nconst scratchZAxis = new Cartesian3();\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.computeCorners = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n      new Cartesian3(),\n    ];\n  }\n\n  const center = box.center;\n  const halfAxes = box.halfAxes;\n  const xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n  const yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n  const zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n  Cartesian3.clone(center, result[0]);\n  Cartesian3.subtract(result[0], xAxis, result[0]);\n  Cartesian3.subtract(result[0], yAxis, result[0]);\n  Cartesian3.subtract(result[0], zAxis, result[0]);\n\n  Cartesian3.clone(center, result[1]);\n  Cartesian3.subtract(result[1], xAxis, result[1]);\n  Cartesian3.subtract(result[1], yAxis, result[1]);\n  Cartesian3.add(result[1], zAxis, result[1]);\n\n  Cartesian3.clone(center, result[2]);\n  Cartesian3.subtract(result[2], xAxis, result[2]);\n  Cartesian3.add(result[2], yAxis, result[2]);\n  Cartesian3.subtract(result[2], zAxis, result[2]);\n\n  Cartesian3.clone(center, result[3]);\n  Cartesian3.subtract(result[3], xAxis, result[3]);\n  Cartesian3.add(result[3], yAxis, result[3]);\n  Cartesian3.add(result[3], zAxis, result[3]);\n\n  Cartesian3.clone(center, result[4]);\n  Cartesian3.add(result[4], xAxis, result[4]);\n  Cartesian3.subtract(result[4], yAxis, result[4]);\n  Cartesian3.subtract(result[4], zAxis, result[4]);\n\n  Cartesian3.clone(center, result[5]);\n  Cartesian3.add(result[5], xAxis, result[5]);\n  Cartesian3.subtract(result[5], yAxis, result[5]);\n  Cartesian3.add(result[5], zAxis, result[5]);\n\n  Cartesian3.clone(center, result[6]);\n  Cartesian3.add(result[6], xAxis, result[6]);\n  Cartesian3.add(result[6], yAxis, result[6]);\n  Cartesian3.subtract(result[6], zAxis, result[6]);\n\n  Cartesian3.clone(center, result[7]);\n  Cartesian3.add(result[7], xAxis, result[7]);\n  Cartesian3.add(result[7], yAxis, result[7]);\n  Cartesian3.add(result[7], zAxis, result[7]);\n\n  return result;\n};\n\nconst scratchRotationScale = new Matrix3();\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {OrientedBoundingBox} box The oriented bounding box.\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.computeTransformation = function (box, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"box\", box);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  const translation = box.center;\n  const rotationScale = Matrix3.multiplyByUniformScale(\n    box.halfAxes,\n    2.0,\n    scratchRotationScale\n  );\n  return Matrix4.fromRotationTranslation(rotationScale, translation, result);\n};\n\nconst scratchBoundingSphere = new BoundingSphere();\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.isOccluded = function (box, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(box)) {\n    throw new DeveloperError(\"box is required.\");\n  }\n  if (!defined(occluder)) {\n    throw new DeveloperError(\"occluder is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const sphere = BoundingSphere.fromOrientedBoundingBox(\n    box,\n    scratchBoundingSphere\n  );\n\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Determines which side of a plane the oriented bounding box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  return OrientedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding box to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding boxes from back to front\n * boxes.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nOrientedBoundingBox.prototype.distanceSquaredTo = function (cartesian) {\n  return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding box.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\n */\nOrientedBoundingBox.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result\n) {\n  return OrientedBoundingBox.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result\n  );\n};\n\n/**\n * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).\n *\n * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.\n * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.\n */\nOrientedBoundingBox.prototype.computeCorners = function (result) {\n  return OrientedBoundingBox.computeCorners(this, result);\n};\n\n/**\n * Computes a transformation matrix from an oriented bounding box.\n *\n * @param {Matrix4} result The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new {@link Matrix4} instance if none was provided.\n */\nOrientedBoundingBox.prototype.computeTransformation = function (result) {\n  return OrientedBoundingBox.computeTransformation(this, result);\n};\n\n/**\n * Determines whether or not a bounding box is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nOrientedBoundingBox.prototype.isOccluded = function (occluder) {\n  return OrientedBoundingBox.isOccluded(this, occluder);\n};\n\n/**\n * Compares the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\n * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      Matrix3.equals(left.halfAxes, right.halfAxes))\n  );\n};\n\n/**\n * Duplicates this OrientedBoundingBox instance.\n *\n * @param {OrientedBoundingBox} [result] The object onto which to store the result.\n * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\n */\nOrientedBoundingBox.prototype.clone = function (result) {\n  return OrientedBoundingBox.clone(this, result);\n};\n\n/**\n * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrientedBoundingBox.prototype.equals = function (right) {\n  return OrientedBoundingBox.equals(this, right);\n};\nexport default OrientedBoundingBox;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrthographicOffCenterFrustum from \"./OrthographicOffCenterFrustum.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.width] The width of the frustum in meters.\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {Number} [options.near=1.0] The distance of the near plane.\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\n *\n * @example\n * const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicFrustum();\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._offCenterFrustum = new OrthographicOffCenterFrustum();\n\n  /**\n   * The horizontal width of the frustum in meters.\n   * @type {Number}\n   * @default undefined\n   */\n  this.width = options.width;\n  this._width = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {Number}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0;\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nOrthographicFrustum.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {OrthographicFrustum} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nOrthographicFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.width;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex] = value.far;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {OrthographicFrustum} [result] The object into which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.width = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex];\n\n  return result;\n};\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.width) ||\n    !defined(frustum.aspectRatio) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"width, aspectRatio, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const f = frustum._offCenterFrustum;\n\n  if (\n    frustum.width !== frustum._width ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.aspectRatio < 0) {\n      throw new DeveloperError(\"aspectRatio must be positive.\");\n    }\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._width = frustum.width;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n\n    const ratio = 1.0 / frustum.aspectRatio;\n    f.right = frustum.width * 0.5;\n    f.left = -f.right;\n    f.top = ratio * f.right;\n    f.bottom = -f.top;\n    f.near = frustum.near;\n    f.far = frustum.far;\n  }\n}\n\nObject.defineProperties(OrthographicFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result\n  );\n};\n\n/**\n * Returns a duplicate of a OrthographicFrustum instance.\n *\n * @param {OrthographicFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.\n */\nOrthographicFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new OrthographicFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.width = this.width;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._width = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    this.width === other.width &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided OrthographicFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  if (!defined(other) || !(other instanceof OrthographicFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    CesiumMath.equalsEpsilon(\n      this.width,\n      other.width,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    CesiumMath.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon\n    )\n  );\n};\nexport default OrthographicFrustum;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias OrthographicOffCenterFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.left] The left clipping plane distance.\n * @param {Number} [options.right] The right clipping plane distance.\n * @param {Number} [options.top] The top clipping plane distance.\n * @param {Number} [options.bottom] The bottom clipping plane distance.\n * @param {Number} [options.near=1.0] The near clipping plane distance.\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * const maxRadii = ellipsoid.maximumRadius;\n *\n * const frustum = new Cesium.OrthographicOffCenterFrustum();\n * frustum.right = maxRadii * Cesium.Math.PI;\n * frustum.left = -c.frustum.right;\n * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);\n * frustum.bottom = -c.frustum.top;\n * frustum.near = 0.01 * maxRadii;\n * frustum.far = 50.0 * maxRadii;\n */\nfunction OrthographicOffCenterFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * The right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * The top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * The bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0;\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  this._cullingVolume = new CullingVolume();\n  this._orthographicMatrix = new Matrix4();\n}\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.right) ||\n    !defined(frustum.left) ||\n    !defined(frustum.top) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (\n    frustum.top !== frustum._top ||\n    frustum.bottom !== frustum._bottom ||\n    frustum.left !== frustum._left ||\n    frustum.right !== frustum._right ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.left > frustum.right) {\n      throw new DeveloperError(\"right must be greater than left.\");\n    }\n    if (frustum.bottom > frustum.top) {\n      throw new DeveloperError(\"top must be greater than bottom.\");\n    }\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._left = frustum.left;\n    frustum._right = frustum.right;\n    frustum._top = frustum.top;\n    frustum._bottom = frustum.bottom;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._orthographicMatrix = Matrix4.computeOrthographicOffCenter(\n      frustum.left,\n      frustum.right,\n      frustum.bottom,\n      frustum.top,\n      frustum.near,\n      frustum.far,\n      frustum._orthographicMatrix\n    );\n  }\n}\n\nObject.defineProperties(OrthographicOffCenterFrustum.prototype, {\n  /**\n   * Gets the orthographic projection matrix computed from the view frustum.\n   * @memberof OrthographicOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._orthographicMatrix;\n    },\n  },\n});\n\nconst getPlanesRight = new Cartesian3();\nconst getPlanesNearCenter = new Cartesian3();\nconst getPlanesPoint = new Cartesian3();\nconst negateScratch = new Cartesian3();\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nOrthographicOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this._cullingVolume.planes;\n  const t = this.top;\n  const b = this.bottom;\n  const r = this.right;\n  const l = this.left;\n  const n = this.near;\n  const f = this.far;\n\n  const right = Cartesian3.cross(direction, up, getPlanesRight);\n  Cartesian3.normalize(right, right);\n  const nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n\n  const point = getPlanesPoint;\n\n  // Left plane\n  Cartesian3.multiplyByScalar(right, l, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  let plane = planes[0];\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n  plane.x = right.x;\n  plane.y = right.y;\n  plane.z = right.z;\n  plane.w = -Cartesian3.dot(right, point);\n\n  // Right plane\n  Cartesian3.multiplyByScalar(right, r, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[1];\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n  plane.x = -right.x;\n  plane.y = -right.y;\n  plane.z = -right.z;\n  plane.w = -Cartesian3.dot(Cartesian3.negate(right, negateScratch), point);\n\n  // Bottom plane\n  Cartesian3.multiplyByScalar(up, b, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[2];\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n  plane.x = up.x;\n  plane.y = up.y;\n  plane.z = up.z;\n  plane.w = -Cartesian3.dot(up, point);\n\n  // Top plane\n  Cartesian3.multiplyByScalar(up, t, point);\n  Cartesian3.add(nearCenter, point, point);\n\n  plane = planes[3];\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n  plane.x = -up.x;\n  plane.y = -up.y;\n  plane.z = -up.z;\n  plane.w = -Cartesian3.dot(Cartesian3.negate(up, negateScratch), point);\n\n  // Near plane\n  plane = planes[4];\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter);\n\n  // Far plane\n  Cartesian3.multiplyByScalar(direction, f, point);\n  Cartesian3.add(position, point, point);\n\n  plane = planes[5];\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n  plane.x = -direction.x;\n  plane.y = -direction.y;\n  plane.z = -direction.z;\n  plane.w = -Cartesian3.dot(Cartesian3.negate(direction, negateScratch), point);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());\n */\nOrthographicOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required.\");\n  }\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const frustumWidth = this.right - this.left;\n  const frustumHeight = this.top - this.bottom;\n  const pixelWidth = (pixelRatio * frustumWidth) / drawingBufferWidth;\n  const pixelHeight = (pixelRatio * frustumHeight) / drawingBufferHeight;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a OrthographicOffCenterFrustum instance.\n *\n * @param {OrthographicOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {OrthographicOffCenterFrustum} The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.\n */\nOrthographicOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new OrthographicOffCenterFrustum();\n  }\n\n  result.left = this.left;\n  result.right = this.right;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {OrthographicOffCenterFrustum} [other] The right hand side OrthographicOffCenterFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nOrthographicOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    defined(other) &&\n    other instanceof OrthographicOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided OrthographicOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {OrthographicOffCenterFrustum} other The right hand side OrthographicOffCenterFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nOrthographicOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    other === this ||\n    (defined(other) &&\n      other instanceof OrthographicOffCenterFrustum &&\n      CesiumMath.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\nexport default OrthographicOffCenterFrustum;\n","import DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Static interface for types which can store their values as packed\n * elements in an array.  These methods and properties are expected to be\n * defined on a constructor function.\n *\n * @interface Packable\n *\n * @see PackableForInterpolation\n */\nconst Packable = {\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  packedLength: undefined,\n\n  /**\n   * Stores the provided instance into the provided array.\n   * @function\n   *\n   * @param {*} value The value to pack.\n   * @param {Number[]} array The array to pack into.\n   * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n   */\n  pack: DeveloperError.throwInstantiationError,\n\n  /**\n   * Retrieves an instance from a packed array.\n   * @function\n   *\n   * @param {Number[]} array The packed array.\n   * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n   * @param {Object} [result] The object into which to store the result.\n   * @returns {Object} The modified result parameter or a new Object instance if one was not provided.\n   */\n  unpack: DeveloperError.throwInstantiationError,\n};\nexport default Packable;\n","import DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Static interface for {@link Packable} types which are interpolated in a\n * different representation than their packed value.  These methods and\n * properties are expected to be defined on a constructor function.\n *\n * @namespace PackableForInterpolation\n *\n * @see Packable\n */\nconst PackableForInterpolation = {\n  /**\n   * The number of elements used to store the object into an array in its interpolatable form.\n   * @type {Number}\n   */\n  packedInterpolationLength: undefined,\n\n  /**\n   * Converts a packed array into a form suitable for interpolation.\n   * @function\n   *\n   * @param {Number[]} packedArray The packed array.\n   * @param {Number} [startingIndex=0] The index of the first element to be converted.\n   * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.\n   * @param {Number[]} [result] The object into which to store the result.\n   */\n  convertPackedArrayForInterpolation: DeveloperError.throwInstantiationError,\n\n  /**\n   * Retrieves an instance from a packed array converted with {@link PackableForInterpolation.convertPackedArrayForInterpolation}.\n   * @function\n   *\n   * @param {Number[]} array The array previously packed for interpolation.\n   * @param {Number[]} sourceArray The original packed array.\n   * @param {Number} [startingIndex=0] The startingIndex used to convert the array.\n   * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n   * @param {Object} [result] The object into which to store the result.\n   * @returns {Object} The modified result parameter or a new Object instance if one was not provided.\n   */\n  unpackInterpolationResult: DeveloperError.throwInstantiationError,\n};\nexport default PackableForInterpolation;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport GeocodeType from \"./GeocodeType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n\n/**\n * Provides geocoding via a {@link https://pelias.io/|Pelias} server.\n * @alias PeliasGeocoderService\n * @constructor\n *\n * @param {Resource|String} url The endpoint to the Pelias server.\n *\n * @example\n * // Configure a Viewer to use the Pelias server hosted by https://geocode.earth/\n * const viewer = new Cesium.Viewer('cesiumContainer', {\n *   geocoder: new Cesium.PeliasGeocoderService(new Cesium.Resource({\n *     url: 'https://api.geocode.earth/v1/',\n *       queryParameters: {\n *         api_key: '<Your geocode.earth API key>'\n *     }\n *   }))\n * });\n */\nfunction PeliasGeocoderService(url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  this._url = Resource.createIfNeeded(url);\n  this._url.appendForwardSlash();\n}\n\nObject.defineProperties(PeliasGeocoderService.prototype, {\n  /**\n   * The Resource used to access the Pelias endpoint.\n   * @type {Resource}\n   * @memberof PeliasGeocoderService.prototype\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._url;\n    },\n  },\n});\n\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.\n * @returns {Promise<GeocoderService.Result[]>}\n */\nPeliasGeocoderService.prototype.geocode = function (query, type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"query\", query);\n  //>>includeEnd('debug');\n\n  const resource = this._url.getDerivedResource({\n    url: type === GeocodeType.AUTOCOMPLETE ? \"autocomplete\" : \"search\",\n    queryParameters: {\n      text: query,\n    },\n  });\n\n  return resource.fetchJson().then(function (results) {\n    return results.features.map(function (resultObject) {\n      let destination;\n      const bboxDegrees = resultObject.bbox;\n\n      if (defined(bboxDegrees)) {\n        destination = Rectangle.fromDegrees(\n          bboxDegrees[0],\n          bboxDegrees[1],\n          bboxDegrees[2],\n          bboxDegrees[3]\n        );\n      } else {\n        const lon = resultObject.geometry.coordinates[0];\n        const lat = resultObject.geometry.coordinates[1];\n        destination = Cartesian3.fromDegrees(lon, lat);\n      }\n\n      return {\n        displayName: resultObject.properties.label,\n        destination: destination,\n      };\n    });\n  });\n};\nexport default PeliasGeocoderService;\n","import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport PerspectiveOffCenterFrustum from \"./PerspectiveOffCenterFrustum.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.fov] The angle of the field of view (FOV), in radians.\n * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.\n * @param {Number} [options.near=1.0] The distance of the near plane.\n * @param {Number} [options.far=500000000.0] The distance of the far plane.\n * @param {Number} [options.xOffset=0.0] The offset in the x direction.\n * @param {Number} [options.yOffset=0.0] The offset in the y direction.\n *\n * @example\n * const frustum = new Cesium.PerspectiveFrustum({\n *     fov : Cesium.Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n * @see PerspectiveOffCenterFrustum\n */\nfunction PerspectiveFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._offCenterFrustum = new PerspectiveOffCenterFrustum();\n\n  /**\n   * The angle of the field of view (FOV), in radians.  This angle will be used\n   * as the horizontal FOV if the width is greater than the height, otherwise\n   * it will be the vertical FOV.\n   * @type {Number}\n   * @default undefined\n   */\n  this.fov = options.fov;\n  this._fov = undefined;\n  this._fovy = undefined;\n\n  this._sseDenominator = undefined;\n\n  /**\n   * The aspect ratio of the frustum's width to it's height.\n   * @type {Number}\n   * @default undefined\n   */\n  this.aspectRatio = options.aspectRatio;\n  this._aspectRatio = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  /**\n   * Offsets the frustum in the x direction.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.xOffset = defaultValue(options.xOffset, 0.0);\n  this._xOffset = this.xOffset;\n\n  /**\n   * Offsets the frustum in the y direction.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.yOffset = defaultValue(options.yOffset, 0.0);\n  this._yOffset = this.yOffset;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nPerspectiveFrustum.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PerspectiveFrustum} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPerspectiveFrustum.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.fov;\n  array[startingIndex++] = value.aspectRatio;\n  array[startingIndex++] = value.near;\n  array[startingIndex++] = value.far;\n  array[startingIndex++] = value.xOffset;\n  array[startingIndex] = value.yOffset;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PerspectiveFrustum} [result] The object into which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.fov = array[startingIndex++];\n  result.aspectRatio = array[startingIndex++];\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex++];\n  result.xOffset = array[startingIndex++];\n  result.yOffset = array[startingIndex];\n\n  return result;\n};\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.fov) ||\n    !defined(frustum.aspectRatio) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"fov, aspectRatio, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const f = frustum._offCenterFrustum;\n\n  if (\n    frustum.fov !== frustum._fov ||\n    frustum.aspectRatio !== frustum._aspectRatio ||\n    frustum.near !== frustum._near ||\n    frustum.far !== frustum._far ||\n    frustum.xOffset !== frustum._xOffset ||\n    frustum.yOffset !== frustum._yOffset\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.fov < 0 || frustum.fov >= Math.PI) {\n      throw new DeveloperError(\"fov must be in the range [0, PI).\");\n    }\n\n    if (frustum.aspectRatio < 0) {\n      throw new DeveloperError(\"aspectRatio must be positive.\");\n    }\n\n    if (frustum.near < 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._aspectRatio = frustum.aspectRatio;\n    frustum._fov = frustum.fov;\n    frustum._fovy =\n      frustum.aspectRatio <= 1\n        ? frustum.fov\n        : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;\n    frustum._near = frustum.near;\n    frustum._far = frustum.far;\n    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);\n    frustum._xOffset = frustum.xOffset;\n    frustum._yOffset = frustum.yOffset;\n\n    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);\n    f.bottom = -f.top;\n    f.right = frustum.aspectRatio * f.top;\n    f.left = -f.right;\n    f.near = frustum.near;\n    f.far = frustum.far;\n\n    f.right += frustum.xOffset;\n    f.left += frustum.xOffset;\n    f.top += frustum.yOffset;\n    f.bottom += frustum.yOffset;\n  }\n}\n\nObject.defineProperties(PerspectiveFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.projectionMatrix;\n    },\n  },\n\n  /**\n   * The perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._offCenterFrustum.infiniteProjectionMatrix;\n    },\n  },\n\n  /**\n   * Gets the angle of the vertical field of view, in radians.\n   * @memberof PerspectiveFrustum.prototype\n   * @type {Number}\n   * @readonly\n   * @default undefined\n   */\n  fovy: {\n    get: function () {\n      update(this);\n      return this._fovy;\n    },\n  },\n\n  /**\n   * @readonly\n   * @private\n   */\n  sseDenominator: {\n    get: function () {\n      update(this);\n      return this._sseDenominator;\n    },\n  },\n});\n\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  update(this);\n  return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * const position = camera.position;\n * const direction = camera.direction;\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n  return this._offCenterFrustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    pixelRatio,\n    result\n  );\n};\n\n/**\n * Returns a duplicate of a PerspectiveFrustum instance.\n *\n * @param {PerspectiveFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveFrustum();\n  }\n\n  result.aspectRatio = this.aspectRatio;\n  result.fov = this.fov;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._aspectRatio = undefined;\n  result._fov = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  this._offCenterFrustum.clone(result._offCenterFrustum);\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equals = function (other) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    this.fov === other.fov &&\n    this.aspectRatio === other.aspectRatio &&\n    this._offCenterFrustum.equals(other._offCenterFrustum)\n  );\n};\n\n/**\n * Compares the provided PerspectiveFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n    return false;\n  }\n\n  update(this);\n  update(other);\n\n  return (\n    CesiumMath.equalsEpsilon(\n      this.fov,\n      other.fov,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    CesiumMath.equalsEpsilon(\n      this.aspectRatio,\n      other.aspectRatio,\n      relativeEpsilon,\n      absoluteEpsilon\n    ) &&\n    this._offCenterFrustum.equalsEpsilon(\n      other._offCenterFrustum,\n      relativeEpsilon,\n      absoluteEpsilon\n    )\n  );\n};\nexport default PerspectiveFrustum;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport CullingVolume from \"./CullingVolume.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveOffCenterFrustum\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.left] The left clipping plane distance.\n * @param {Number} [options.right] The right clipping plane distance.\n * @param {Number} [options.top] The top clipping plane distance.\n * @param {Number} [options.bottom] The bottom clipping plane distance.\n * @param {Number} [options.near=1.0] The near clipping plane distance.\n * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n *\n * @example\n * const frustum = new Cesium.PerspectiveOffCenterFrustum({\n *     left : -1.0,\n *     right : 1.0,\n *     top : 1.0,\n *     bottom : -1.0,\n *     near : 1.0,\n *     far : 100.0\n * });\n *\n * @see PerspectiveFrustum\n */\nfunction PerspectiveOffCenterFrustum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * Defines the left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.left = options.left;\n  this._left = undefined;\n\n  /**\n   * Defines the right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.right = options.right;\n  this._right = undefined;\n\n  /**\n   * Defines the top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.top = options.top;\n  this._top = undefined;\n\n  /**\n   * Defines the bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  this.bottom = options.bottom;\n  this._bottom = undefined;\n\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.near = defaultValue(options.near, 1.0);\n  this._near = this.near;\n\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  this.far = defaultValue(options.far, 500000000.0);\n  this._far = this.far;\n\n  this._cullingVolume = new CullingVolume();\n  this._perspectiveMatrix = new Matrix4();\n  this._infinitePerspective = new Matrix4();\n}\n\nfunction update(frustum) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !defined(frustum.right) ||\n    !defined(frustum.left) ||\n    !defined(frustum.top) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.near) ||\n    !defined(frustum.far)\n  ) {\n    throw new DeveloperError(\n      \"right, left, top, bottom, near, or far parameters are not set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const t = frustum.top;\n  const b = frustum.bottom;\n  const r = frustum.right;\n  const l = frustum.left;\n  const n = frustum.near;\n  const f = frustum.far;\n\n  if (\n    t !== frustum._top ||\n    b !== frustum._bottom ||\n    l !== frustum._left ||\n    r !== frustum._right ||\n    n !== frustum._near ||\n    f !== frustum._far\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frustum.near <= 0 || frustum.near > frustum.far) {\n      throw new DeveloperError(\n        \"near must be greater than zero and less than far.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    frustum._left = l;\n    frustum._right = r;\n    frustum._top = t;\n    frustum._bottom = b;\n    frustum._near = n;\n    frustum._far = f;\n    frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(\n      l,\n      r,\n      b,\n      t,\n      n,\n      f,\n      frustum._perspectiveMatrix\n    );\n    frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(\n      l,\n      r,\n      b,\n      t,\n      n,\n      frustum._infinitePerspective\n    );\n  }\n}\n\nObject.defineProperties(PerspectiveOffCenterFrustum.prototype, {\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  projectionMatrix: {\n    get: function () {\n      update(this);\n      return this._perspectiveMatrix;\n    },\n  },\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  infiniteProjectionMatrix: {\n    get: function () {\n      update(this);\n      return this._infinitePerspective;\n    },\n  },\n});\n\nconst getPlanesRight = new Cartesian3();\nconst getPlanesNearCenter = new Cartesian3();\nconst getPlanesFarCenter = new Cartesian3();\nconst getPlanesNormal = new Cartesian3();\n/**\n * Creates a culling volume for this frustum.\n *\n * @param {Cartesian3} position The eye position.\n * @param {Cartesian3} direction The view direction.\n * @param {Cartesian3} up The up direction.\n * @returns {CullingVolume} A culling volume at the given position and orientation.\n *\n * @example\n * // Check if a bounding volume intersects the frustum.\n * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n * const intersect = cullingVolume.computeVisibility(boundingVolume);\n */\nPerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (\n  position,\n  direction,\n  up\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n\n  if (!defined(up)) {\n    throw new DeveloperError(\"up is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this._cullingVolume.planes;\n\n  const t = this.top;\n  const b = this.bottom;\n  const r = this.right;\n  const l = this.left;\n  const n = this.near;\n  const f = this.far;\n\n  const right = Cartesian3.cross(direction, up, getPlanesRight);\n\n  const nearCenter = getPlanesNearCenter;\n  Cartesian3.multiplyByScalar(direction, n, nearCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n\n  const farCenter = getPlanesFarCenter;\n  Cartesian3.multiplyByScalar(direction, f, farCenter);\n  Cartesian3.add(position, farCenter, farCenter);\n\n  const normal = getPlanesNormal;\n\n  //Left plane computation\n  Cartesian3.multiplyByScalar(right, l, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.normalize(normal, normal);\n  Cartesian3.cross(normal, up, normal);\n  Cartesian3.normalize(normal, normal);\n\n  let plane = planes[0];\n  if (!defined(plane)) {\n    plane = planes[0] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Right plane computation\n  Cartesian3.multiplyByScalar(right, r, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(up, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[1];\n  if (!defined(plane)) {\n    plane = planes[1] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Bottom plane computation\n  Cartesian3.multiplyByScalar(up, b, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(right, normal, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[2];\n  if (!defined(plane)) {\n    plane = planes[2] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Top plane computation\n  Cartesian3.multiplyByScalar(up, t, normal);\n  Cartesian3.add(nearCenter, normal, normal);\n  Cartesian3.subtract(normal, position, normal);\n  Cartesian3.cross(normal, right, normal);\n  Cartesian3.normalize(normal, normal);\n\n  plane = planes[3];\n  if (!defined(plane)) {\n    plane = planes[3] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, position);\n\n  //Near plane computation\n  plane = planes[4];\n  if (!defined(plane)) {\n    plane = planes[4] = new Cartesian4();\n  }\n  plane.x = direction.x;\n  plane.y = direction.y;\n  plane.z = direction.z;\n  plane.w = -Cartesian3.dot(direction, nearCenter);\n\n  //Far plane computation\n  Cartesian3.negate(direction, normal);\n\n  plane = planes[5];\n  if (!defined(plane)) {\n    plane = planes[5] = new Cartesian4();\n  }\n  plane.x = normal.x;\n  plane.y = normal.y;\n  plane.z = normal.z;\n  plane.w = -Cartesian3.dot(normal, farCenter);\n\n  return this._cullingVolume;\n};\n\n/**\n * Returns the pixel's width and height in meters.\n *\n * @param {Number} drawingBufferWidth The width of the drawing buffer.\n * @param {Number} drawingBufferHeight The height of the drawing buffer.\n * @param {Number} distance The distance to the near plane in meters.\n * @param {Number} pixelRatio The scaling factor from pixel space to coordinate space.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.\n *\n * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n * @exception {DeveloperError} pixelRatio must be greater than zero.\n *\n * @example\n * // Example 1\n * // Get the width and height of a pixel.\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());\n *\n * @example\n * // Example 2\n * // Get the width and height of a pixel if the near plane was set to 'distance'.\n * // For example, get the size of a pixel of an image on a billboard.\n * const position = camera.position;\n * const direction = camera.direction;\n * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive\n * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector\n * const distance = Cesium.Cartesian3.magnitude(toCenterProj);\n * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n */\nPerspectiveOffCenterFrustum.prototype.getPixelDimensions = function (\n  drawingBufferWidth,\n  drawingBufferHeight,\n  distance,\n  pixelRatio,\n  result\n) {\n  update(this);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(drawingBufferWidth) || !defined(drawingBufferHeight)) {\n    throw new DeveloperError(\n      \"Both drawingBufferWidth and drawingBufferHeight are required.\"\n    );\n  }\n  if (drawingBufferWidth <= 0) {\n    throw new DeveloperError(\"drawingBufferWidth must be greater than zero.\");\n  }\n  if (drawingBufferHeight <= 0) {\n    throw new DeveloperError(\"drawingBufferHeight must be greater than zero.\");\n  }\n  if (!defined(distance)) {\n    throw new DeveloperError(\"distance is required.\");\n  }\n  if (!defined(pixelRatio)) {\n    throw new DeveloperError(\"pixelRatio is required\");\n  }\n  if (pixelRatio <= 0) {\n    throw new DeveloperError(\"pixelRatio must be greater than zero.\");\n  }\n  if (!defined(result)) {\n    throw new DeveloperError(\"A result object is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const inverseNear = 1.0 / this.near;\n  let tanTheta = this.top * inverseNear;\n  const pixelHeight =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferHeight;\n  tanTheta = this.right * inverseNear;\n  const pixelWidth =\n    (2.0 * pixelRatio * distance * tanTheta) / drawingBufferWidth;\n\n  result.x = pixelWidth;\n  result.y = pixelHeight;\n  return result;\n};\n\n/**\n * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n *\n * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.\n * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.\n */\nPerspectiveOffCenterFrustum.prototype.clone = function (result) {\n  if (!defined(result)) {\n    result = new PerspectiveOffCenterFrustum();\n  }\n\n  result.right = this.right;\n  result.left = this.left;\n  result.top = this.top;\n  result.bottom = this.bottom;\n  result.near = this.near;\n  result.far = this.far;\n\n  // force update of clone to compute matrices\n  result._left = undefined;\n  result._right = undefined;\n  result._top = undefined;\n  result._bottom = undefined;\n  result._near = undefined;\n  result._far = undefined;\n\n  return result;\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equals = function (other) {\n  return (\n    defined(other) &&\n    other instanceof PerspectiveOffCenterFrustum &&\n    this.right === other.right &&\n    this.left === other.left &&\n    this.top === other.top &&\n    this.bottom === other.bottom &&\n    this.near === other.near &&\n    this.far === other.far\n  );\n};\n\n/**\n * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.\n * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.\n */\nPerspectiveOffCenterFrustum.prototype.equalsEpsilon = function (\n  other,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    other === this ||\n    (defined(other) &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      CesiumMath.equalsEpsilon(\n        this.right,\n        other.right,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.left,\n        other.left,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.top,\n        other.top,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.bottom,\n        other.bottom,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.near,\n        other.near,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        this.far,\n        other.far,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\nexport default PerspectiveOffCenterFrustum;\n","import buildModuleUrl from \"./buildModuleUrl.js\";\nimport Color from \"./Color.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Resource from \"./Resource.js\";\nimport writeTextToCanvas from \"./writeTextToCanvas.js\";\n\n/**\n * A utility class for generating custom map pins as canvas elements.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/PinBuilder.png' width='500'/><br />\n * Example pins generated using both the maki icon set, which ships with Cesium, and single character text.\n * </div>\n *\n * @alias PinBuilder\n * @constructor\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Map%20Pins.html|Cesium Sandcastle PinBuilder Demo}\n */\nfunction PinBuilder() {\n  this._cache = {};\n}\n\n/**\n * Creates an empty pin of the specified color and size.\n *\n * @param {Color} color The color of the pin.\n * @param {Number} size The size of the pin, in pixels.\n * @returns {HTMLCanvasElement} The canvas element that represents the generated pin.\n */\nPinBuilder.prototype.fromColor = function (color, size) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required\");\n  }\n  if (!defined(size)) {\n    throw new DeveloperError(\"size is required\");\n  }\n  //>>includeEnd('debug');\n  return createPin(undefined, undefined, color, size, this._cache);\n};\n\n/**\n * Creates a pin with the specified icon, color, and size.\n *\n * @param {Resource|String} url The url of the image to be stamped onto the pin.\n * @param {Color} color The color of the pin.\n * @param {Number} size The size of the pin, in pixels.\n * @returns {HTMLCanvasElement|Promise.<HTMLCanvasElement>} The canvas element or a Promise to the canvas element that represents the generated pin.\n */\nPinBuilder.prototype.fromUrl = function (url, color, size) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(url)) {\n    throw new DeveloperError(\"url is required\");\n  }\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required\");\n  }\n  if (!defined(size)) {\n    throw new DeveloperError(\"size is required\");\n  }\n  //>>includeEnd('debug');\n  return createPin(url, undefined, color, size, this._cache);\n};\n\n/**\n * Creates a pin with the specified {@link https://www.mapbox.com/maki/|maki} icon identifier, color, and size.\n *\n * @param {String} id The id of the maki icon to be stamped onto the pin.\n * @param {Color} color The color of the pin.\n * @param {Number} size The size of the pin, in pixels.\n * @returns {HTMLCanvasElement|Promise.<HTMLCanvasElement>} The canvas element or a Promise to the canvas element that represents the generated pin.\n */\nPinBuilder.prototype.fromMakiIconId = function (id, color, size) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required\");\n  }\n  if (!defined(size)) {\n    throw new DeveloperError(\"size is required\");\n  }\n  //>>includeEnd('debug');\n  return createPin(\n    buildModuleUrl(`Assets/Textures/maki/${encodeURIComponent(id)}.png`),\n    undefined,\n    color,\n    size,\n    this._cache\n  );\n};\n\n/**\n * Creates a pin with the specified text, color, and size.  The text will be sized to be as large as possible\n * while still being contained completely within the pin.\n *\n * @param {String} text The text to be stamped onto the pin.\n * @param {Color} color The color of the pin.\n * @param {Number} size The size of the pin, in pixels.\n * @returns {HTMLCanvasElement} The canvas element that represents the generated pin.\n */\nPinBuilder.prototype.fromText = function (text, color, size) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(text)) {\n    throw new DeveloperError(\"text is required\");\n  }\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required\");\n  }\n  if (!defined(size)) {\n    throw new DeveloperError(\"size is required\");\n  }\n  //>>includeEnd('debug');\n\n  return createPin(undefined, text, color, size, this._cache);\n};\n\nconst colorScratch = new Color();\n\n//This function (except for the 3 commented lines) was auto-generated from an online tool,\n//http://www.professorcloud.com/svg-to-canvas/, using Assets/Textures/pin.svg as input.\n//The reason we simply can't load and draw the SVG directly to the canvas is because\n//it taints the canvas in Internet Explorer (and possibly some other browsers); making\n//it impossible to create a WebGL texture from the result.\nfunction drawPin(context2D, color, size) {\n  context2D.save();\n  context2D.scale(size / 24, size / 24); //Added to auto-generated code to scale up to desired size.\n  context2D.fillStyle = color.toCssColorString(); //Modified from auto-generated code.\n  context2D.strokeStyle = color.brighten(0.6, colorScratch).toCssColorString(); //Modified from auto-generated code.\n  context2D.lineWidth = 0.846;\n  context2D.beginPath();\n  context2D.moveTo(6.72, 0.422);\n  context2D.lineTo(17.28, 0.422);\n  context2D.bezierCurveTo(18.553, 0.422, 19.577, 1.758, 19.577, 3.415);\n  context2D.lineTo(19.577, 10.973);\n  context2D.bezierCurveTo(19.577, 12.63, 18.553, 13.966, 17.282, 13.966);\n  context2D.lineTo(14.386, 14.008);\n  context2D.lineTo(11.826, 23.578);\n  context2D.lineTo(9.614, 14.008);\n  context2D.lineTo(6.719, 13.965);\n  context2D.bezierCurveTo(5.446, 13.983, 4.422, 12.629, 4.422, 10.972);\n  context2D.lineTo(4.422, 3.416);\n  context2D.bezierCurveTo(4.423, 1.76, 5.447, 0.423, 6.718, 0.423);\n  context2D.closePath();\n  context2D.fill();\n  context2D.stroke();\n  context2D.restore();\n}\n\n//This function takes an image or canvas and uses it as a template\n//to \"stamp\" the pin with a white image outlined in black.  The color\n//values of the input image are ignored completely and only the alpha\n//values are used.\nfunction drawIcon(context2D, image, size) {\n  //Size is the largest image that looks good inside of pin box.\n  const imageSize = size / 2.5;\n  let sizeX = imageSize;\n  let sizeY = imageSize;\n\n  if (image.width > image.height) {\n    sizeY = imageSize * (image.height / image.width);\n  } else if (image.width < image.height) {\n    sizeX = imageSize * (image.width / image.height);\n  }\n\n  //x and y are the center of the pin box\n  const x = Math.round((size - sizeX) / 2);\n  const y = Math.round((7 / 24) * size - sizeY / 2);\n\n  context2D.globalCompositeOperation = \"destination-out\";\n  context2D.drawImage(image, x - 1, y, sizeX, sizeY);\n  context2D.drawImage(image, x, y - 1, sizeX, sizeY);\n  context2D.drawImage(image, x + 1, y, sizeX, sizeY);\n  context2D.drawImage(image, x, y + 1, sizeX, sizeY);\n\n  context2D.globalCompositeOperation = \"destination-over\";\n  context2D.fillStyle = Color.BLACK.toCssColorString();\n  context2D.fillRect(x - 1, y - 1, sizeX + 2, sizeY + 2);\n\n  context2D.globalCompositeOperation = \"destination-out\";\n  context2D.drawImage(image, x, y, sizeX, sizeY);\n\n  context2D.globalCompositeOperation = \"destination-over\";\n  context2D.fillStyle = Color.WHITE.toCssColorString();\n  context2D.fillRect(x - 1, y - 2, sizeX + 2, sizeY + 2);\n}\n\nconst stringifyScratch = new Array(4);\nfunction createPin(url, label, color, size, cache) {\n  //Use the parameters as a unique ID for caching.\n  stringifyScratch[0] = url;\n  stringifyScratch[1] = label;\n  stringifyScratch[2] = color;\n  stringifyScratch[3] = size;\n  const id = JSON.stringify(stringifyScratch);\n\n  const item = cache[id];\n  if (defined(item)) {\n    return item;\n  }\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = size;\n  canvas.height = size;\n\n  const context2D = canvas.getContext(\"2d\");\n  drawPin(context2D, color, size);\n\n  if (defined(url)) {\n    const resource = Resource.createIfNeeded(url);\n\n    //If we have an image url, load it and then stamp the pin.\n    const promise = resource.fetchImage().then(function (image) {\n      drawIcon(context2D, image, size);\n      cache[id] = canvas;\n      return canvas;\n    });\n    cache[id] = promise;\n    return promise;\n  } else if (defined(label)) {\n    //If we have a label, write it to a canvas and then stamp the pin.\n    const image = writeTextToCanvas(label, {\n      font: `bold ${size}px sans-serif`,\n    });\n    drawIcon(context2D, image, size);\n  }\n\n  cache[id] = canvas;\n  return canvas;\n}\nexport default PinBuilder;\n","import PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * The format of a pixel, i.e., the number of components it has and what they represent.\n *\n * @enum {Number}\n */\nconst PixelFormat = {\n  /**\n   * A pixel format containing a depth value.\n   *\n   * @type {Number}\n   * @constant\n   */\n  DEPTH_COMPONENT: WebGLConstants.DEPTH_COMPONENT,\n\n  /**\n   * A pixel format containing a depth and stencil value, most often used with {@link PixelDatatype.UNSIGNED_INT_24_8}.\n   *\n   * @type {Number}\n   * @constant\n   */\n  DEPTH_STENCIL: WebGLConstants.DEPTH_STENCIL,\n\n  /**\n   * A pixel format containing an alpha channel.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ALPHA: WebGLConstants.ALPHA,\n\n  /**\n   * A pixel format containing red, green, and blue channels.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGB: WebGLConstants.RGB,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGBA: WebGLConstants.RGBA,\n\n  /**\n   * A pixel format containing a luminance (intensity) channel.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LUMINANCE: WebGLConstants.LUMINANCE,\n\n  /**\n   * A pixel format containing luminance (intensity) and alpha channels.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LUMINANCE_ALPHA: WebGLConstants.LUMINANCE_ALPHA,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is DXT1 compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGB_DXT1: WebGLConstants.COMPRESSED_RGB_S3TC_DXT1_EXT,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is DXT1 compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGBA_DXT1: WebGLConstants.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is DXT3 compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGBA_DXT3: WebGLConstants.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is DXT5 compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGBA_DXT5: WebGLConstants.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is PVR 4bpp compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGB_PVRTC_4BPPV1: WebGLConstants.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is PVR 2bpp compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGB_PVRTC_2BPPV1: WebGLConstants.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is PVR 4bpp compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGBA_PVRTC_4BPPV1: WebGLConstants.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is PVR 2bpp compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGBA_PVRTC_2BPPV1: WebGLConstants.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is ASTC compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGBA_ASTC: WebGLConstants.COMPRESSED_RGBA_ASTC_4x4_WEBGL,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is ETC1 compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGB_ETC1: WebGLConstants.COMPRESSED_RGB_ETC1_WEBGL,\n\n  /**\n   * A pixel format containing red, green, and blue channels that is ETC2 compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGB8_ETC2: WebGLConstants.COMPRESSED_RGB8_ETC2,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is ETC2 compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGBA8_ETC2_EAC: WebGLConstants.COMPRESSED_RGBA8_ETC2_EAC,\n\n  /**\n   * A pixel format containing red, green, blue, and alpha channels that is BC7 compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RGBA_BC7: WebGLConstants.COMPRESSED_RGBA_BPTC_UNORM,\n};\n\n/**\n * @private\n */\nPixelFormat.componentsLength = function (pixelFormat) {\n  switch (pixelFormat) {\n    case PixelFormat.RGB:\n      return 3;\n    case PixelFormat.RGBA:\n      return 4;\n    case PixelFormat.LUMINANCE_ALPHA:\n      return 2;\n    case PixelFormat.ALPHA:\n    case PixelFormat.LUMINANCE:\n      return 1;\n    default:\n      return 1;\n  }\n};\n\n/**\n * @private\n */\nPixelFormat.validate = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.DEPTH_COMPONENT ||\n    pixelFormat === PixelFormat.DEPTH_STENCIL ||\n    pixelFormat === PixelFormat.ALPHA ||\n    pixelFormat === PixelFormat.RGB ||\n    pixelFormat === PixelFormat.RGBA ||\n    pixelFormat === PixelFormat.LUMINANCE ||\n    pixelFormat === PixelFormat.LUMINANCE_ALPHA ||\n    pixelFormat === PixelFormat.RGB_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT3 ||\n    pixelFormat === PixelFormat.RGBA_DXT5 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_ASTC ||\n    pixelFormat === PixelFormat.RGB_ETC1 ||\n    pixelFormat === PixelFormat.RGB8_ETC2 ||\n    pixelFormat === PixelFormat.RGBA8_ETC2_EAC ||\n    pixelFormat === PixelFormat.RGBA_BC7\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isColorFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.ALPHA ||\n    pixelFormat === PixelFormat.RGB ||\n    pixelFormat === PixelFormat.RGBA ||\n    pixelFormat === PixelFormat.LUMINANCE ||\n    pixelFormat === PixelFormat.LUMINANCE_ALPHA\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isDepthFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.DEPTH_COMPONENT ||\n    pixelFormat === PixelFormat.DEPTH_STENCIL\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isCompressedFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.RGB_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT3 ||\n    pixelFormat === PixelFormat.RGBA_DXT5 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_ASTC ||\n    pixelFormat === PixelFormat.RGB_ETC1 ||\n    pixelFormat === PixelFormat.RGB8_ETC2 ||\n    pixelFormat === PixelFormat.RGBA8_ETC2_EAC ||\n    pixelFormat === PixelFormat.RGBA_BC7\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isDXTFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.RGB_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT1 ||\n    pixelFormat === PixelFormat.RGBA_DXT3 ||\n    pixelFormat === PixelFormat.RGBA_DXT5\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isPVRTCFormat = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.RGB_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGB_PVRTC_2BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_4BPPV1 ||\n    pixelFormat === PixelFormat.RGBA_PVRTC_2BPPV1\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isASTCFormat = function (pixelFormat) {\n  return pixelFormat === PixelFormat.RGBA_ASTC;\n};\n\n/**\n * @private\n */\nPixelFormat.isETC1Format = function (pixelFormat) {\n  return pixelFormat === PixelFormat.RGB_ETC1;\n};\n\n/**\n * @private\n */\nPixelFormat.isETC2Format = function (pixelFormat) {\n  return (\n    pixelFormat === PixelFormat.RGB8_ETC2 ||\n    pixelFormat === PixelFormat.RGBA8_ETC2_EAC\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.isBC7Format = function (pixelFormat) {\n  return pixelFormat === PixelFormat.RGBA_BC7;\n};\n\n/**\n * @private\n */\nPixelFormat.compressedTextureSizeInBytes = function (\n  pixelFormat,\n  width,\n  height\n) {\n  switch (pixelFormat) {\n    case PixelFormat.RGB_DXT1:\n    case PixelFormat.RGBA_DXT1:\n    case PixelFormat.RGB_ETC1:\n    case PixelFormat.RGB8_ETC2:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n\n    case PixelFormat.RGBA_DXT3:\n    case PixelFormat.RGBA_DXT5:\n    case PixelFormat.RGBA_ASTC:\n    case PixelFormat.RGBA8_ETC2_EAC:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n\n    case PixelFormat.RGB_PVRTC_4BPPV1:\n    case PixelFormat.RGBA_PVRTC_4BPPV1:\n      return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);\n\n    case PixelFormat.RGB_PVRTC_2BPPV1:\n    case PixelFormat.RGBA_PVRTC_2BPPV1:\n      return Math.floor(\n        (Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8\n      );\n\n    case PixelFormat.RGBA_BC7:\n      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;\n\n    default:\n      return 0;\n  }\n};\n\n/**\n * @private\n */\nPixelFormat.textureSizeInBytes = function (\n  pixelFormat,\n  pixelDatatype,\n  width,\n  height\n) {\n  let componentsLength = PixelFormat.componentsLength(pixelFormat);\n  if (PixelDatatype.isPacked(pixelDatatype)) {\n    componentsLength = 1;\n  }\n  return (\n    componentsLength * PixelDatatype.sizeInBytes(pixelDatatype) * width * height\n  );\n};\n\n/**\n * @private\n */\nPixelFormat.alignmentInBytes = function (pixelFormat, pixelDatatype, width) {\n  const mod =\n    PixelFormat.textureSizeInBytes(pixelFormat, pixelDatatype, width, 1) % 4;\n  return mod === 0 ? 4 : mod === 2 ? 2 : 1;\n};\n\n/**\n * @private\n */\nPixelFormat.createTypedArray = function (\n  pixelFormat,\n  pixelDatatype,\n  width,\n  height\n) {\n  let constructor;\n  const sizeInBytes = PixelDatatype.sizeInBytes(pixelDatatype);\n  if (sizeInBytes === Uint8Array.BYTES_PER_ELEMENT) {\n    constructor = Uint8Array;\n  } else if (sizeInBytes === Uint16Array.BYTES_PER_ELEMENT) {\n    constructor = Uint16Array;\n  } else if (\n    sizeInBytes === Float32Array.BYTES_PER_ELEMENT &&\n    pixelDatatype === PixelDatatype.FLOAT\n  ) {\n    constructor = Float32Array;\n  } else {\n    constructor = Uint32Array;\n  }\n\n  const size = PixelFormat.componentsLength(pixelFormat) * width * height;\n  return new constructor(size);\n};\n\n/**\n * @private\n */\nPixelFormat.flipY = function (\n  bufferView,\n  pixelFormat,\n  pixelDatatype,\n  width,\n  height\n) {\n  if (height === 1) {\n    return bufferView;\n  }\n  const flipped = PixelFormat.createTypedArray(\n    pixelFormat,\n    pixelDatatype,\n    width,\n    height\n  );\n  const numberOfComponents = PixelFormat.componentsLength(pixelFormat);\n  const textureWidth = width * numberOfComponents;\n  for (let i = 0; i < height; ++i) {\n    const row = i * width * numberOfComponents;\n    const flippedRow = (height - i - 1) * width * numberOfComponents;\n    for (let j = 0; j < textureWidth; ++j) {\n      flipped[flippedRow + j] = bufferView[row + j];\n    }\n  }\n  return flipped;\n};\n\n/**\n * @private\n */\nPixelFormat.toInternalFormat = function (pixelFormat, pixelDatatype, context) {\n  // WebGL 1 require internalFormat to be the same as PixelFormat\n  if (!context.webgl2) {\n    return pixelFormat;\n  }\n\n  // Convert pixelFormat to correct internalFormat for WebGL 2\n  if (pixelFormat === PixelFormat.DEPTH_STENCIL) {\n    return WebGLConstants.DEPTH24_STENCIL8;\n  }\n\n  if (pixelFormat === PixelFormat.DEPTH_COMPONENT) {\n    if (pixelDatatype === PixelDatatype.UNSIGNED_SHORT) {\n      return WebGLConstants.DEPTH_COMPONENT16;\n    } else if (pixelDatatype === PixelDatatype.UNSIGNED_INT) {\n      return WebGLConstants.DEPTH_COMPONENT24;\n    }\n  }\n\n  if (pixelDatatype === PixelDatatype.FLOAT) {\n    switch (pixelFormat) {\n      case PixelFormat.RGBA:\n        return WebGLConstants.RGBA32F;\n      case PixelFormat.RGB:\n        return WebGLConstants.RGB32F;\n      case PixelFormat.RG:\n        return WebGLConstants.RG32F;\n      case PixelFormat.R:\n        return WebGLConstants.R32F;\n    }\n  }\n\n  if (pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    switch (pixelFormat) {\n      case PixelFormat.RGBA:\n        return WebGLConstants.RGBA16F;\n      case PixelFormat.RGB:\n        return WebGLConstants.RGB16F;\n      case PixelFormat.RG:\n        return WebGLConstants.RG16F;\n      case PixelFormat.R:\n        return WebGLConstants.R16F;\n    }\n  }\n\n  return pixelFormat;\n};\n\nexport default Object.freeze(PixelFormat);\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * A plane in Hessian Normal Form defined by\n * <pre>\n * ax + by + cz + d = 0\n * </pre>\n * where (a, b, c) is the plane's <code>normal</code>, d is the signed\n * <code>distance</code> to the plane, and (x, y, z) is any point on\n * the plane.\n *\n * @alias Plane\n * @constructor\n *\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Number} distance The shortest distance from the origin to the plane.  The sign of\n * <code>distance</code> determines which side of the plane the origin\n * is on.  If <code>distance</code> is positive, the origin is in the half-space\n * in the direction of the normal; if negative, the origin is in the half-space\n * opposite to the normal; if zero, the plane passes through the origin.\n *\n * @example\n * // The plane x=0\n * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nfunction Plane(normal, distance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  Check.typeOf.number(\"distance\", distance);\n  //>>includeEnd('debug');\n\n  /**\n   * The plane's normal.\n   *\n   * @type {Cartesian3}\n   */\n  this.normal = Cartesian3.clone(normal);\n\n  /**\n   * The shortest distance from the origin to the plane.  The sign of\n   * <code>distance</code> determines which side of the plane the origin\n   * is on.  If <code>distance</code> is positive, the origin is in the half-space\n   * in the direction of the normal; if negative, the origin is in the half-space\n   * opposite to the normal; if zero, the plane passes through the origin.\n   *\n   * @type {Number}\n   */\n  this.distance = distance;\n}\n\n/**\n * Creates a plane from a normal and a point on the plane.\n *\n * @param {Cartesian3} point The point on the plane.\n * @param {Cartesian3} normal The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @example\n * const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * const normal = ellipsoid.geodeticSurfaceNormal(point);\n * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromPointNormal = function (point, normal, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"point\", point);\n  Check.typeOf.object(\"normal\", normal);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  const distance = -Cartesian3.dot(normal, point);\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\nconst scratchNormal = new Cartesian3();\n/**\n * Creates a plane from the general equation\n *\n * @param {Cartesian4} coefficients The plane's normal (normalized).\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} A new plane instance or the modified result parameter.\n *\n * @exception {DeveloperError} Normal must be normalized\n */\nPlane.fromCartesian4 = function (coefficients, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"coefficients\", coefficients);\n  //>>includeEnd('debug');\n\n  const normal = Cartesian3.fromCartesian4(coefficients, scratchNormal);\n  const distance = coefficients.w;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !CesiumMath.equalsEpsilon(\n      Cartesian3.magnitude(normal),\n      1.0,\n      CesiumMath.EPSILON6\n    )\n  ) {\n    throw new DeveloperError(\"normal must be normalized.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(normal, distance);\n  }\n  Cartesian3.clone(normal, result.normal);\n  result.distance = distance;\n  return result;\n};\n\n/**\n * Computes the signed shortest distance of a point to a plane.\n * The sign of the distance determines which side of the plane the point\n * is on.  If the distance is positive, the point is in the half-space\n * in the direction of the normal; if negative, the point is in the half-space\n * opposite to the normal; if zero, the plane passes through the point.\n *\n * @param {Plane} plane The plane.\n * @param {Cartesian3} point The point.\n * @returns {Number} The signed shortest distance of the point to the plane.\n */\nPlane.getPointDistance = function (plane, point) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  return Cartesian3.dot(plane.normal, point) + plane.distance;\n};\n\nconst scratchCartesian = new Cartesian3();\n/**\n * Projects a point onto the plane.\n * @param {Plane} plane The plane to project the point onto\n * @param {Cartesian3} point The point to project onto the plane\n * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nPlane.projectPointOntoPlane = function (plane, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  // projectedPoint = point - (normal.point + scale) * normal\n  const pointDistance = Plane.getPointDistance(plane, point);\n  const scaledNormal = Cartesian3.multiplyByScalar(\n    plane.normal,\n    pointDistance,\n    scratchCartesian\n  );\n\n  return Cartesian3.subtract(point, scaledNormal, result);\n};\n\nconst scratchInverseTranspose = new Matrix4();\nconst scratchPlaneCartesian4 = new Cartesian4();\nconst scratchTransformNormal = new Cartesian3();\n/**\n * Transforms the plane by the given transformation matrix.\n *\n * @param {Plane} plane The plane.\n * @param {Matrix4} transform The transformation matrix.\n * @param {Plane} [result] The object into which to store the result.\n * @returns {Plane} The plane transformed by the given transformation matrix.\n */\nPlane.transform = function (plane, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  const normal = plane.normal;\n  const distance = plane.distance;\n  const inverseTranspose = Matrix4.inverseTranspose(\n    transform,\n    scratchInverseTranspose\n  );\n  let planeAsCartesian4 = Cartesian4.fromElements(\n    normal.x,\n    normal.y,\n    normal.z,\n    distance,\n    scratchPlaneCartesian4\n  );\n  planeAsCartesian4 = Matrix4.multiplyByVector(\n    inverseTranspose,\n    planeAsCartesian4,\n    planeAsCartesian4\n  );\n\n  // Convert the transformed plane to Hessian Normal Form\n  const transformedNormal = Cartesian3.fromCartesian4(\n    planeAsCartesian4,\n    scratchTransformNormal\n  );\n\n  planeAsCartesian4 = Cartesian4.divideByScalar(\n    planeAsCartesian4,\n    Cartesian3.magnitude(transformedNormal),\n    planeAsCartesian4\n  );\n\n  return Plane.fromCartesian4(planeAsCartesian4, result);\n};\n\n/**\n * Duplicates a Plane instance.\n *\n * @param {Plane} plane The plane to duplicate.\n * @param {Plane} [result] The object onto which to store the result.\n * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.\n */\nPlane.clone = function (plane, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Plane(plane.normal, plane.distance);\n  }\n\n  Cartesian3.clone(plane.normal, result.normal);\n  result.distance = plane.distance;\n\n  return result;\n};\n\n/**\n * Compares the provided Planes by normal and distance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Plane} left The first plane.\n * @param {Plane} right The second plane.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nPlane.equals = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.distance === right.distance &&\n    Cartesian3.equals(left.normal, right.normal)\n  );\n};\n\n/**\n * A constant initialized to the XY plane passing through the origin, with normal in positive Z.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_XY_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Z, 0.0));\n\n/**\n * A constant initialized to the YZ plane passing through the origin, with normal in positive X.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_YZ_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_X, 0.0));\n\n/**\n * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.\n *\n * @type {Plane}\n * @constant\n */\nPlane.ORIGIN_ZX_PLANE = Object.freeze(new Plane(Cartesian3.UNIT_Y, 0.0));\nexport default Plane;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\n/**\n * Describes geometry representing a plane centered at the origin, with a unit width and length.\n *\n * @alias PlaneGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @example\n * const planeGeometry = new Cesium.PlaneGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n * });\n */\nfunction PlaneGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  this._vertexFormat = vertexFormat;\n  this._workerName = \"createPlaneGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nPlaneGeometry.packedLength = VertexFormat.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PlaneGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPlaneGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n\n  return array;\n};\n\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PlaneGeometry} [result] The object into which to store the result.\n * @returns {PlaneGeometry} The modified result parameter or a new PlaneGeometry instance if one was not provided.\n */\nPlaneGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n\n  if (!defined(result)) {\n    return new PlaneGeometry(scratchOptions);\n  }\n\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n\n  return result;\n};\n\nconst min = new Cartesian3(-0.5, -0.5, 0.0);\nconst max = new Cartesian3(0.5, 0.5, 0.0);\n\n/**\n * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.\n *\n * @param {PlaneGeometry} planeGeometry A description of the plane.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPlaneGeometry.createGeometry = function (planeGeometry) {\n  const vertexFormat = planeGeometry._vertexFormat;\n\n  const attributes = new GeometryAttributes();\n  let indices;\n  let positions;\n\n  if (vertexFormat.position) {\n    // 4 corner points.  Duplicated 3 times each for each incident edge/face.\n    positions = new Float64Array(4 * 3);\n\n    // +z face\n    positions[0] = min.x;\n    positions[1] = min.y;\n    positions[2] = 0.0;\n    positions[3] = max.x;\n    positions[4] = min.y;\n    positions[5] = 0.0;\n    positions[6] = max.x;\n    positions[7] = max.y;\n    positions[8] = 0.0;\n    positions[9] = min.x;\n    positions[10] = max.y;\n    positions[11] = 0.0;\n\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n\n    if (vertexFormat.normal) {\n      const normals = new Float32Array(4 * 3);\n\n      // +z face\n      normals[0] = 0.0;\n      normals[1] = 0.0;\n      normals[2] = 1.0;\n      normals[3] = 0.0;\n      normals[4] = 0.0;\n      normals[5] = 1.0;\n      normals[6] = 0.0;\n      normals[7] = 0.0;\n      normals[8] = 1.0;\n      normals[9] = 0.0;\n      normals[10] = 0.0;\n      normals[11] = 1.0;\n\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.st) {\n      const texCoords = new Float32Array(4 * 2);\n\n      // +z face\n      texCoords[0] = 0.0;\n      texCoords[1] = 0.0;\n      texCoords[2] = 1.0;\n      texCoords[3] = 0.0;\n      texCoords[4] = 1.0;\n      texCoords[5] = 1.0;\n      texCoords[6] = 0.0;\n      texCoords[7] = 1.0;\n\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: texCoords,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      const tangents = new Float32Array(4 * 3);\n\n      // +z face\n      tangents[0] = 1.0;\n      tangents[1] = 0.0;\n      tangents[2] = 0.0;\n      tangents[3] = 1.0;\n      tangents[4] = 0.0;\n      tangents[5] = 0.0;\n      tangents[6] = 1.0;\n      tangents[7] = 0.0;\n      tangents[8] = 0.0;\n      tangents[9] = 1.0;\n      tangents[10] = 0.0;\n      tangents[11] = 0.0;\n\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      const bitangents = new Float32Array(4 * 3);\n\n      // +z face\n      bitangents[0] = 0.0;\n      bitangents[1] = 1.0;\n      bitangents[2] = 0.0;\n      bitangents[3] = 0.0;\n      bitangents[4] = 1.0;\n      bitangents[5] = 0.0;\n      bitangents[6] = 0.0;\n      bitangents[7] = 1.0;\n      bitangents[8] = 0.0;\n      bitangents[9] = 0.0;\n      bitangents[10] = 1.0;\n      bitangents[11] = 0.0;\n\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n\n    // 2 triangles\n    indices = new Uint16Array(2 * 3);\n\n    // +z face\n    indices[0] = 0;\n    indices[1] = 1;\n    indices[2] = 2;\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0)),\n  });\n};\nexport default PlaneGeometry;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\n/**\n * Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.\n *\n * @alias PlaneOutlineGeometry\n * @constructor\n *\n */\nfunction PlaneOutlineGeometry() {\n  this._workerName = \"createPlaneOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nPlaneOutlineGeometry.packedLength = 0;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PlaneOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n *\n * @returns {Number[]} The array that was packed into\n */\nPlaneOutlineGeometry.pack = function (value, array) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PlaneOutlineGeometry} [result] The object into which to store the result.\n * @returns {PlaneOutlineGeometry} The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.\n */\nPlaneOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new PlaneOutlineGeometry();\n  }\n\n  return result;\n};\n\nconst min = new Cartesian3(-0.5, -0.5, 0.0);\nconst max = new Cartesian3(0.5, 0.5, 0.0);\n\n/**\n * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.\n *\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPlaneOutlineGeometry.createGeometry = function () {\n  const attributes = new GeometryAttributes();\n  const indices = new Uint16Array(4 * 2);\n  const positions = new Float64Array(4 * 3);\n\n  positions[0] = min.x;\n  positions[1] = min.y;\n  positions[2] = min.z;\n  positions[3] = max.x;\n  positions[4] = min.y;\n  positions[5] = min.z;\n  positions[6] = max.x;\n  positions[7] = max.y;\n  positions[8] = min.z;\n  positions[9] = min.x;\n  positions[10] = max.y;\n  positions[11] = min.z;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  indices[0] = 0;\n  indices[1] = 1;\n  indices[2] = 1;\n  indices[3] = 2;\n  indices[4] = 2;\n  indices[5] = 3;\n  indices[6] = 3;\n  indices[7] = 0;\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0)),\n  });\n};\nexport default PlaneOutlineGeometry;\n","import ArcType from \"./ArcType.js\";\nimport arrayFill from \"./arrayFill.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nconst scratchCarto1 = new Cartographic();\nconst scratchCarto2 = new Cartographic();\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n  const carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n  const height = carto1.height;\n  const p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n  p1Carto.height = height;\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\n\n  const p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n  p2Carto.height = height - 100;\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\n}\n\nconst scratchBoundingRectangle = new BoundingRectangle();\nconst scratchPosition = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\nlet scratchPerPosNormal = new Cartesian3();\nlet scratchPerPosTangent = new Cartesian3();\nlet scratchPerPosBitangent = new Cartesian3();\n\nconst appendTextureCoordinatesOrigin = new Cartesian2();\nconst appendTextureCoordinatesCartesian2 = new Cartesian2();\nconst appendTextureCoordinatesCartesian3 = new Cartesian3();\nconst appendTextureCoordinatesQuaternion = new Quaternion();\nconst appendTextureCoordinatesMatrix3 = new Matrix3();\nconst tangentMatrixScratch = new Matrix3();\n\nfunction computeAttributes(options) {\n  const vertexFormat = options.vertexFormat;\n  const geometry = options.geometry;\n  const shadowVolume = options.shadowVolume;\n  const flatPositions = geometry.attributes.position.values;\n  const flatTexcoords = defined(geometry.attributes.st)\n    ? geometry.attributes.st.values\n    : undefined;\n\n  let length = flatPositions.length;\n  const wall = options.wall;\n  const top = options.top || wall;\n  const bottom = options.bottom || wall;\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent ||\n    shadowVolume\n  ) {\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n    const boundingRectangle = options.boundingRectangle;\n    const tangentPlane = options.tangentPlane;\n    const ellipsoid = options.ellipsoid;\n    const stRotation = options.stRotation;\n    const perPositionHeight = options.perPositionHeight;\n\n    const origin = appendTextureCoordinatesOrigin;\n    origin.x = boundingRectangle.x;\n    origin.y = boundingRectangle.y;\n\n    const textureCoordinates = vertexFormat.st\n      ? new Float32Array(2 * (length / 3))\n      : undefined;\n    let normals;\n    if (vertexFormat.normal) {\n      if (perPositionHeight && top && !wall) {\n        normals = geometry.attributes.normal.values;\n      } else {\n        normals = new Float32Array(length);\n      }\n    }\n    const tangents = vertexFormat.tangent\n      ? new Float32Array(length)\n      : undefined;\n    const bitangents = vertexFormat.bitangent\n      ? new Float32Array(length)\n      : undefined;\n    const extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n\n    let textureCoordIndex = 0;\n    let attrIndex = 0;\n\n    let normal = scratchNormal;\n    let tangent = scratchTangent;\n    let bitangent = scratchBitangent;\n    let recomputeNormal = true;\n\n    let textureMatrix = appendTextureCoordinatesMatrix3;\n    let tangentRotationMatrix = tangentMatrixScratch;\n    if (stRotation !== 0.0) {\n      let rotation = Quaternion.fromAxisAngle(\n        tangentPlane._plane.normal,\n        stRotation,\n        appendTextureCoordinatesQuaternion\n      );\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n      rotation = Quaternion.fromAxisAngle(\n        tangentPlane._plane.normal,\n        -stRotation,\n        appendTextureCoordinatesQuaternion\n      );\n      tangentRotationMatrix = Matrix3.fromQuaternion(\n        rotation,\n        tangentRotationMatrix\n      );\n    } else {\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n      tangentRotationMatrix = Matrix3.clone(\n        Matrix3.IDENTITY,\n        tangentRotationMatrix\n      );\n    }\n\n    let bottomOffset = 0;\n    let bottomOffset2 = 0;\n\n    if (top && bottom) {\n      bottomOffset = length / 2;\n      bottomOffset2 = length / 3;\n\n      length /= 2;\n    }\n\n    for (let i = 0; i < length; i += 3) {\n      const position = Cartesian3.fromArray(\n        flatPositions,\n        i,\n        appendTextureCoordinatesCartesian3\n      );\n\n      if (vertexFormat.st) {\n        if (!defined(flatTexcoords)) {\n          let p = Matrix3.multiplyByVector(\n            textureMatrix,\n            position,\n            scratchPosition\n          );\n          p = ellipsoid.scaleToGeodeticSurface(p, p);\n          const st = tangentPlane.projectPointOntoPlane(\n            p,\n            appendTextureCoordinatesCartesian2\n          );\n          Cartesian2.subtract(st, origin, st);\n\n          const stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n          const sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n          if (bottom) {\n            textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n            textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n          }\n          if (top) {\n            textureCoordinates[textureCoordIndex] = stx;\n            textureCoordinates[textureCoordIndex + 1] = sty;\n          }\n\n          textureCoordIndex += 2;\n        }\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent ||\n        shadowVolume\n      ) {\n        const attrIndex1 = attrIndex + 1;\n        const attrIndex2 = attrIndex + 2;\n\n        if (wall) {\n          if (i + 3 < length) {\n            const p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n            if (recomputeNormal) {\n              const p2 = Cartesian3.fromArray(\n                flatPositions,\n                i + length,\n                p2Scratch\n              );\n              if (perPositionHeight) {\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n              }\n              Cartesian3.subtract(p1, position, p1);\n              Cartesian3.subtract(p2, position, p2);\n              normal = Cartesian3.normalize(\n                Cartesian3.cross(p2, p1, normal),\n                normal\n              );\n              recomputeNormal = false;\n            }\n\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\n              // if we've reached a corner\n              recomputeNormal = true;\n            }\n          }\n\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n            if (vertexFormat.tangent) {\n              tangent = Cartesian3.normalize(\n                Cartesian3.cross(bitangent, normal, tangent),\n                tangent\n              );\n            }\n          }\n        } else {\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\n            if (perPositionHeight) {\n              scratchPerPosNormal = Cartesian3.fromArray(\n                normals,\n                attrIndex,\n                scratchPerPosNormal\n              );\n              scratchPerPosTangent = Cartesian3.cross(\n                Cartesian3.UNIT_Z,\n                scratchPerPosNormal,\n                scratchPerPosTangent\n              );\n              scratchPerPosTangent = Cartesian3.normalize(\n                Matrix3.multiplyByVector(\n                  tangentRotationMatrix,\n                  scratchPerPosTangent,\n                  scratchPerPosTangent\n                ),\n                scratchPerPosTangent\n              );\n              if (vertexFormat.bitangent) {\n                scratchPerPosBitangent = Cartesian3.normalize(\n                  Cartesian3.cross(\n                    scratchPerPosNormal,\n                    scratchPerPosTangent,\n                    scratchPerPosBitangent\n                  ),\n                  scratchPerPosBitangent\n                );\n              }\n            }\n\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n            tangent = Cartesian3.normalize(\n              Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent),\n              tangent\n            );\n            if (vertexFormat.bitangent) {\n              bitangent = Cartesian3.normalize(\n                Cartesian3.cross(normal, tangent, bitangent),\n                bitangent\n              );\n            }\n          }\n        }\n\n        if (vertexFormat.normal) {\n          if (options.wall) {\n            normals[attrIndex + bottomOffset] = normal.x;\n            normals[attrIndex1 + bottomOffset] = normal.y;\n            normals[attrIndex2 + bottomOffset] = normal.z;\n          } else if (bottom) {\n            normals[attrIndex + bottomOffset] = -normal.x;\n            normals[attrIndex1 + bottomOffset] = -normal.y;\n            normals[attrIndex2 + bottomOffset] = -normal.z;\n          }\n\n          if ((top && !perPositionHeight) || wall) {\n            normals[attrIndex] = normal.x;\n            normals[attrIndex1] = normal.y;\n            normals[attrIndex2] = normal.z;\n          }\n        }\n\n        if (shadowVolume) {\n          if (wall) {\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n          }\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          if (options.wall) {\n            tangents[attrIndex + bottomOffset] = tangent.x;\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\n          } else if (bottom) {\n            tangents[attrIndex + bottomOffset] = -tangent.x;\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n          }\n\n          if (top) {\n            if (perPositionHeight) {\n              tangents[attrIndex] = scratchPerPosTangent.x;\n              tangents[attrIndex1] = scratchPerPosTangent.y;\n              tangents[attrIndex2] = scratchPerPosTangent.z;\n            } else {\n              tangents[attrIndex] = tangent.x;\n              tangents[attrIndex1] = tangent.y;\n              tangents[attrIndex2] = tangent.z;\n            }\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          if (bottom) {\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n          }\n          if (top) {\n            if (perPositionHeight) {\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\n            } else {\n              bitangents[attrIndex] = bitangent.x;\n              bitangents[attrIndex1] = bitangent.y;\n              bitangents[attrIndex2] = bitangent.z;\n            }\n          }\n        }\n        attrIndex += 3;\n      }\n    }\n\n    if (vertexFormat.st && !defined(flatTexcoords)) {\n      geometry.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: textureCoordinates,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      geometry.attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      geometry.attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      geometry.attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n\n    if (shadowVolume) {\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: extrudeNormals,\n      });\n    }\n  }\n\n  if (options.extrude && defined(options.offsetAttribute)) {\n    const size = flatPositions.length / 3;\n    let offsetAttribute = new Uint8Array(size);\n\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      if ((top && bottom) || wall) {\n        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n      } else if (top) {\n        offsetAttribute = arrayFill(offsetAttribute, 1);\n      }\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    geometry.attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return geometry;\n}\n\nconst startCartographicScratch = new Cartographic();\nconst endCartographicScratch = new Cartographic();\nconst idlCross = {\n  westOverIDL: 0.0,\n  eastOverIDL: 0.0,\n};\nlet ellipsoidGeodesic = new EllipsoidGeodesic();\nfunction computeRectangle(positions, ellipsoid, arcType, granularity, result) {\n  result = defaultValue(result, new Rectangle());\n  if (!defined(positions) || positions.length < 3) {\n    result.west = 0.0;\n    result.north = 0.0;\n    result.south = 0.0;\n    result.east = 0.0;\n    return result;\n  }\n\n  if (arcType === ArcType.RHUMB) {\n    return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n  }\n\n  if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\n    ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n  }\n\n  result.west = Number.POSITIVE_INFINITY;\n  result.east = Number.NEGATIVE_INFINITY;\n  result.south = Number.POSITIVE_INFINITY;\n  result.north = Number.NEGATIVE_INFINITY;\n\n  idlCross.westOverIDL = Number.POSITIVE_INFINITY;\n  idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\n\n  const inverseChordLength =\n    1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  const positionsLength = positions.length;\n  let endCartographic = ellipsoid.cartesianToCartographic(\n    positions[0],\n    endCartographicScratch\n  );\n  let startCartographic = startCartographicScratch;\n  let swap;\n\n  for (let i = 1; i < positionsLength; i++) {\n    swap = startCartographic;\n    startCartographic = endCartographic;\n    endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\n    ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n    interpolateAndGrowRectangle(\n      ellipsoidGeodesic,\n      inverseChordLength,\n      result,\n      idlCross\n    );\n  }\n\n  swap = startCartographic;\n  startCartographic = endCartographic;\n  endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\n  ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n  interpolateAndGrowRectangle(\n    ellipsoidGeodesic,\n    inverseChordLength,\n    result,\n    idlCross\n  );\n\n  if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\n    result.west = idlCross.westOverIDL;\n    result.east = idlCross.eastOverIDL;\n\n    if (result.east > CesiumMath.PI) {\n      result.east = result.east - CesiumMath.TWO_PI;\n    }\n    if (result.west > CesiumMath.PI) {\n      result.west = result.west - CesiumMath.TWO_PI;\n    }\n  }\n\n  return result;\n}\n\nconst interpolatedCartographicScratch = new Cartographic();\nfunction interpolateAndGrowRectangle(\n  ellipsoidGeodesic,\n  inverseChordLength,\n  result,\n  idlCross\n) {\n  const segmentLength = ellipsoidGeodesic.surfaceDistance;\n\n  const numPoints = Math.ceil(segmentLength * inverseChordLength);\n  const subsegmentDistance =\n    numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\n  let interpolationDistance = 0.0;\n\n  for (let i = 0; i < numPoints; i++) {\n    const interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\n      interpolationDistance,\n      interpolatedCartographicScratch\n    );\n    interpolationDistance += subsegmentDistance;\n    const longitude = interpolatedCartographic.longitude;\n    const latitude = interpolatedCartographic.latitude;\n\n    result.west = Math.min(result.west, longitude);\n    result.east = Math.max(result.east, longitude);\n    result.south = Math.min(result.south, latitude);\n    result.north = Math.max(result.north, latitude);\n\n    const lonAdjusted =\n      longitude >= 0 ? longitude : longitude + CesiumMath.TWO_PI;\n    idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\n    idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\n  }\n}\n\nconst createGeometryFromPositionsExtrudedPositions = [];\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  polygon,\n  textureCoordinates,\n  granularity,\n  hierarchy,\n  perPositionHeight,\n  closeTop,\n  closeBottom,\n  vertexFormat,\n  arcType\n) {\n  const geos = {\n    walls: [],\n  };\n  let i;\n\n  if (closeTop || closeBottom) {\n    const topGeo = PolygonGeometryLibrary.createGeometryFromPositions(\n      ellipsoid,\n      polygon,\n      textureCoordinates,\n      granularity,\n      perPositionHeight,\n      vertexFormat,\n      arcType\n    );\n\n    const edgePoints = topGeo.attributes.position.values;\n    const indices = topGeo.indices;\n    let numPositions;\n    let newIndices;\n\n    if (closeTop && closeBottom) {\n      const topBottomPositions = edgePoints.concat(edgePoints);\n\n      numPositions = topBottomPositions.length / 3;\n\n      newIndices = IndexDatatype.createTypedArray(\n        numPositions,\n        indices.length * 2\n      );\n      newIndices.set(indices);\n      const ilength = indices.length;\n\n      const length = numPositions / 2;\n\n      for (i = 0; i < ilength; i += 3) {\n        const i0 = newIndices[i] + length;\n        const i1 = newIndices[i + 1] + length;\n        const i2 = newIndices[i + 2] + length;\n\n        newIndices[i + ilength] = i2;\n        newIndices[i + 1 + ilength] = i1;\n        newIndices[i + 2 + ilength] = i0;\n      }\n\n      topGeo.attributes.position.values = topBottomPositions;\n      if (perPositionHeight && vertexFormat.normal) {\n        const normals = topGeo.attributes.normal.values;\n        topGeo.attributes.normal.values = new Float32Array(\n          topBottomPositions.length\n        );\n        topGeo.attributes.normal.values.set(normals);\n      }\n\n      if (vertexFormat.st && defined(textureCoordinates)) {\n        const texcoords = topGeo.attributes.st.values;\n        topGeo.attributes.st.values = new Float32Array(numPositions * 2);\n        topGeo.attributes.st.values = texcoords.concat(texcoords);\n      }\n\n      topGeo.indices = newIndices;\n    } else if (closeBottom) {\n      numPositions = edgePoints.length / 3;\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n      for (i = 0; i < indices.length; i += 3) {\n        newIndices[i] = indices[i + 2];\n        newIndices[i + 1] = indices[i + 1];\n        newIndices[i + 2] = indices[i];\n      }\n\n      topGeo.indices = newIndices;\n    }\n\n    geos.topAndBottom = new GeometryInstance({\n      geometry: topGeo,\n    });\n  }\n\n  let outerRing = hierarchy.outerRing;\n  let tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n  let positions2D = tangentPlane.projectPointsOntoPlane(\n    outerRing,\n    createGeometryFromPositionsExtrudedPositions\n  );\n\n  let windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n  if (windingOrder === WindingOrder.CLOCKWISE) {\n    outerRing = outerRing.slice().reverse();\n  }\n\n  let wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n    outerRing,\n    textureCoordinates,\n    ellipsoid,\n    granularity,\n    perPositionHeight,\n    arcType\n  );\n  geos.walls.push(\n    new GeometryInstance({\n      geometry: wallGeo,\n    })\n  );\n\n  const holes = hierarchy.holes;\n  for (i = 0; i < holes.length; i++) {\n    let hole = holes[i];\n\n    tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\n    positions2D = tangentPlane.projectPointsOntoPlane(\n      hole,\n      createGeometryFromPositionsExtrudedPositions\n    );\n\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n      hole = hole.slice().reverse();\n    }\n\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(\n      hole,\n      textureCoordinates,\n      ellipsoid,\n      granularity,\n      perPositionHeight,\n      arcType\n    );\n    geos.walls.push(\n      new GeometryInstance({\n        geometry: wallGeo,\n      })\n    );\n  }\n\n  return geos;\n}\n\n/**\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias PolygonGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\n *\n * @see PolygonGeometry#createGeometry\n * @see PolygonGeometry#fromPositions\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n *\n * @example\n * // 1. create a polygon from points\n * const polygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes\n * const polygonWithHole = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon\n * const extrudedPolygon = new Cesium.PolygonGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  if (\n    defined(options.perPositionHeight) &&\n    options.perPositionHeight &&\n    defined(options.height)\n  ) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\"\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  const stRotation = defaultValue(options.stRotation, 0.0);\n  const textureCoordinates = options.textureCoordinates;\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\n  const perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  let height = defaultValue(options.height, 0.0);\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    const h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._stRotation = stRotation;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._closeTop = defaultValue(options.closeTop, true);\n  this._closeBottom = defaultValue(options.closeBottom, true);\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createPolygonGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n  this._textureCoordinates = textureCoordinates;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\n      polygonHierarchy,\n      Cartesian3\n    ) +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    (textureCoordinates\n      ? PolygonGeometryLibrary.computeHierarchyPackedLength(\n          textureCoordinates,\n          Cartesian2\n        )\n      : 1) +\n    12;\n}\n\n/**\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {Number} [options.height=0.0] The height of the polygon.\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\n * @returns {PolygonGeometry}\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.PolygonGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n *\n * @see PolygonGeometry#createGeometry\n */\nPolygonGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    vertexFormat: options.vertexFormat,\n    stRotation: options.stRotation,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    closeTop: options.closeTop,\n    closeBottom: options.closeBottom,\n    offsetAttribute: options.offsetAttribute,\n    arcType: options.arcType,\n    textureCoordinates: options.textureCoordinates,\n  };\n  return new PolygonGeometry(newOptions);\n};\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolygonGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex,\n    Cartesian3\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex++] = value._arcType;\n  if (defined(value._textureCoordinates)) {\n    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n      value._textureCoordinates,\n      array,\n      startingIndex,\n      Cartesian2\n    );\n  } else {\n    array[startingIndex++] = -1.0;\n  }\n  array[startingIndex++] = value.packedLength;\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\n\n//Only used to avoid inability to default construct.\nconst dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonGeometry} [result] The object into which to store the result.\n */\nPolygonGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex,\n    Cartesian3\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  const perPositionHeight = array[startingIndex++] === 1.0;\n  const closeTop = array[startingIndex++] === 1.0;\n  const closeBottom = array[startingIndex++] === 1.0;\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex++];\n  const arcType = array[startingIndex++];\n  const textureCoordinates =\n    array[startingIndex] === -1.0\n      ? undefined\n      : PolygonGeometryLibrary.unpackPolygonHierarchy(\n          array,\n          startingIndex,\n          Cartesian2\n        );\n  if (defined(textureCoordinates)) {\n    startingIndex = textureCoordinates.startingIndex;\n    delete textureCoordinates.startingIndex;\n  } else {\n    startingIndex++;\n  }\n  const packedLength = array[startingIndex++];\n\n  if (!defined(result)) {\n    result = new PolygonGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._stRotation = stRotation;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._perPositionHeight = perPositionHeight;\n  result._closeTop = closeTop;\n  result._closeBottom = closeBottom;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result._arcType = arcType;\n  result._textureCoordinates = textureCoordinates;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\n/**\n * Returns the bounding rectangle given the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle\n */\nPolygonGeometry.computeRectangle = function (options, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n  //>>includeEnd('debug');\n\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  const arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  //>>includeStart('debug', pragmas.debug);\n  if (arcType !== ArcType.GEODESIC && arcType !== ArcType.RHUMB) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  return computeRectangle(\n    polygonHierarchy.positions,\n    ellipsoid,\n    arcType,\n    granularity,\n    result\n  );\n};\n\n/**\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonGeometry.createGeometry = function (polygonGeometry) {\n  const vertexFormat = polygonGeometry._vertexFormat;\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const granularity = polygonGeometry._granularity;\n  const stRotation = polygonGeometry._stRotation;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const perPositionHeight = polygonGeometry._perPositionHeight;\n  const closeTop = polygonGeometry._closeTop;\n  const closeBottom = polygonGeometry._closeBottom;\n  const arcType = polygonGeometry._arcType;\n  const textureCoordinates = polygonGeometry._textureCoordinates;\n\n  const hasTextureCoordinates = defined(textureCoordinates);\n\n  let outerPositions = polygonHierarchy.positions;\n  if (outerPositions.length < 3) {\n    return;\n  }\n\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(\n    outerPositions,\n    ellipsoid\n  );\n\n  const results = PolygonGeometryLibrary.polygonsFromHierarchy(\n    polygonHierarchy,\n    hasTextureCoordinates,\n    tangentPlane.projectPointsOntoPlane.bind(tangentPlane),\n    !perPositionHeight,\n    ellipsoid\n  );\n\n  const hierarchy = results.hierarchy;\n  const polygons = results.polygons;\n\n  const dummyFunction = function (identity) {\n    return identity;\n  };\n\n  const textureCoordinatePolygons = hasTextureCoordinates\n    ? PolygonGeometryLibrary.polygonsFromHierarchy(\n        textureCoordinates,\n        true,\n        dummyFunction,\n        false\n      ).polygons\n    : undefined;\n\n  if (hierarchy.length === 0) {\n    return;\n  }\n\n  outerPositions = hierarchy[0].outerRing;\n  const boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(\n    tangentPlane.plane.normal,\n    tangentPlane.projectPointOntoPlane.bind(tangentPlane),\n    outerPositions,\n    stRotation,\n    scratchBoundingRectangle\n  );\n\n  const geometries = [];\n\n  const height = polygonGeometry._height;\n  const extrudedHeight = polygonGeometry._extrudedHeight;\n  const extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n  const options = {\n    perPositionHeight: perPositionHeight,\n    vertexFormat: vertexFormat,\n    geometry: undefined,\n    tangentPlane: tangentPlane,\n    boundingRectangle: boundingRectangle,\n    ellipsoid: ellipsoid,\n    stRotation: stRotation,\n    textureCoordinates: undefined,\n    bottom: false,\n    top: true,\n    wall: false,\n    extrude: false,\n    arcType: arcType,\n  };\n\n  let i;\n\n  if (extrude) {\n    options.extrude = true;\n    options.top = closeTop;\n    options.bottom = closeBottom;\n    options.shadowVolume = polygonGeometry._shadowVolume;\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\n    for (i = 0; i < polygons.length; i++) {\n      const splitGeometry = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\n        granularity,\n        hierarchy[i],\n        perPositionHeight,\n        closeTop,\n        closeBottom,\n        vertexFormat,\n        arcType\n      );\n\n      let topAndBottom;\n      if (closeTop && closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          topAndBottom.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight\n        );\n      } else if (closeTop) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n          topAndBottom.geometry.attributes.position.values,\n          height,\n          ellipsoid,\n          !perPositionHeight\n        );\n        options.geometry = topAndBottom.geometry;\n      } else if (closeBottom) {\n        topAndBottom = splitGeometry.topAndBottom;\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n          topAndBottom.geometry.attributes.position.values,\n          extrudedHeight,\n          ellipsoid,\n          true\n        );\n        options.geometry = topAndBottom.geometry;\n      }\n      if (closeTop || closeBottom) {\n        options.wall = false;\n        topAndBottom.geometry = computeAttributes(options);\n        geometries.push(topAndBottom);\n      }\n\n      const walls = splitGeometry.walls;\n      options.wall = true;\n      for (let k = 0; k < walls.length; k++) {\n        const wall = walls[k];\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n          wall.geometry,\n          height,\n          extrudedHeight,\n          ellipsoid,\n          perPositionHeight\n        );\n        wall.geometry = computeAttributes(options);\n        geometries.push(wall);\n      }\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      const geometryInstance = new GeometryInstance({\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(\n          ellipsoid,\n          polygons[i],\n          hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\n          granularity,\n          perPositionHeight,\n          vertexFormat,\n          arcType\n        ),\n      });\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n        geometryInstance.geometry.attributes.position.values,\n        height,\n        ellipsoid,\n        !perPositionHeight\n      );\n      options.geometry = geometryInstance.geometry;\n\n      geometryInstance.geometry = computeAttributes(options);\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const length =\n          geometryInstance.geometry.attributes.position.values.length;\n        const applyOffset = new Uint8Array(length / 3);\n        const offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        arrayFill(applyOffset, offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\n          {\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          }\n        );\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  geometry.attributes.position.values = new Float64Array(\n    geometry.attributes.position.values\n  );\n  geometry.indices = IndexDatatype.createTypedArray(\n    geometry.attributes.position.values.length / 3,\n    geometry.indices\n  );\n\n  const attributes = geometry.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values\n  );\n\n  if (!vertexFormat.position) {\n    delete attributes.position;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nPolygonGeometry.createShadowVolume = function (\n  polygonGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  const granularity = polygonGeometry._granularity;\n  const ellipsoid = polygonGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new PolygonGeometry({\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\n    ellipsoid: ellipsoid,\n    stRotation: polygonGeometry._stRotation,\n    granularity: granularity,\n    perPositionHeight: false,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n    arcType: polygonGeometry._arcType,\n  });\n};\n\nfunction textureCoordinateRotationPoints(polygonGeometry) {\n  const stRotation = -polygonGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const positions = polygonGeometry._polygonHierarchy.positions;\n  const boundingRectangle = polygonGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle\n  );\n}\n\nObject.defineProperties(PolygonGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        const positions = this._polygonHierarchy.positions;\n        this._rectangle = computeRectangle(\n          positions,\n          this._ellipsoid,\n          this._arcType,\n          this._granularity\n        );\n      }\n\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\n          this\n        );\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default PolygonGeometry;\n","import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Queue from \"./Queue.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\n/**\n * @private\n */\nconst PolygonGeometryLibrary = {};\n\nPolygonGeometryLibrary.computeHierarchyPackedLength = function (\n  polygonHierarchy,\n  CartesianX\n) {\n  let numComponents = 0;\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    numComponents += 2;\n\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n\n    if (defined(positions) && positions.length > 0) {\n      numComponents += positions.length * CartesianX.packedLength;\n    }\n\n    if (defined(holes)) {\n      const length = holes.length;\n      for (let i = 0; i < length; ++i) {\n        stack.push(holes[i]);\n      }\n    }\n  }\n\n  return numComponents;\n};\n\nPolygonGeometryLibrary.packPolygonHierarchy = function (\n  polygonHierarchy,\n  array,\n  startingIndex,\n  CartesianX\n) {\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n\n    array[startingIndex++] = defined(positions) ? positions.length : 0;\n    array[startingIndex++] = defined(holes) ? holes.length : 0;\n\n    if (defined(positions)) {\n      const positionsLength = positions.length;\n      for (\n        let i = 0;\n        i < positionsLength;\n        ++i, startingIndex += CartesianX.packedLength\n      ) {\n        CartesianX.pack(positions[i], array, startingIndex);\n      }\n    }\n\n    if (defined(holes)) {\n      const holesLength = holes.length;\n      for (let j = 0; j < holesLength; ++j) {\n        stack.push(holes[j]);\n      }\n    }\n  }\n\n  return startingIndex;\n};\n\nPolygonGeometryLibrary.unpackPolygonHierarchy = function (\n  array,\n  startingIndex,\n  CartesianX\n) {\n  const positionsLength = array[startingIndex++];\n  const holesLength = array[startingIndex++];\n\n  const positions = new Array(positionsLength);\n  const holes = holesLength > 0 ? new Array(holesLength) : undefined;\n\n  for (\n    let i = 0;\n    i < positionsLength;\n    ++i, startingIndex += CartesianX.packedLength\n  ) {\n    positions[i] = CartesianX.unpack(array, startingIndex);\n  }\n\n  for (let j = 0; j < holesLength; ++j) {\n    holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(\n      array,\n      startingIndex,\n      CartesianX\n    );\n    startingIndex = holes[j].startingIndex;\n    delete holes[j].startingIndex;\n  }\n\n  return {\n    positions: positions,\n    holes: holes,\n    startingIndex: startingIndex,\n  };\n};\n\nconst distance2DScratch = new Cartesian2();\nfunction getPointAtDistance2D(p0, p1, distance, length) {\n  Cartesian2.subtract(p1, p0, distance2DScratch);\n  Cartesian2.multiplyByScalar(\n    distance2DScratch,\n    distance / length,\n    distance2DScratch\n  );\n  Cartesian2.add(p0, distance2DScratch, distance2DScratch);\n  return [distance2DScratch.x, distance2DScratch.y];\n}\n\nconst distanceScratch = new Cartesian3();\nfunction getPointAtDistance(p0, p1, distance, length) {\n  Cartesian3.subtract(p1, p0, distanceScratch);\n  Cartesian3.multiplyByScalar(\n    distanceScratch,\n    distance / length,\n    distanceScratch\n  );\n  Cartesian3.add(p0, distanceScratch, distanceScratch);\n  return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\n}\n\nPolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  const n = distance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\nconst scratchCartographic2 = new Cartographic();\nconst scratchCartesian0 = new Cartesian3();\nconst scratchRhumbLine = new EllipsoidRhumbLine();\nPolygonGeometryLibrary.subdivideRhumbLineCount = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance\n) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {Number} minDistance Minimum distance for a segment.\n * @param {Array<Cartesian2>} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordLine = function (\n  t0,\n  t1,\n  p0,\n  p1,\n  minDistance,\n  result\n) {\n  // Compute the number of subdivisions.\n  const subdivisions = PolygonGeometryLibrary.subdivideLineCount(\n    p0,\n    p1,\n    minDistance\n  );\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n\n  return texcoords;\n};\n\nPolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {\n  const numVertices = PolygonGeometryLibrary.subdivideLineCount(\n    p0,\n    p1,\n    minDistance\n  );\n  const length = Cartesian3.distance(p0, p1);\n  const distanceBetweenVertices = length / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const positions = result;\n  positions.length = numVertices * 3;\n\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\n    positions[index++] = p[0];\n    positions[index++] = p[1];\n    positions[index++] = p[2];\n  }\n\n  return positions;\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions using a rhumb line.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {Number} minDistance Minimum distance for a segment.\n * @param {Array<Cartesian2>} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordRhumbLine = function (\n  t0,\n  t1,\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n  result\n) {\n  // Compute the surface distance.\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  scratchRhumbLine.setEndPoints(c0, c1);\n  const n = scratchRhumbLine.surfaceDistance / minDistance;\n\n  // Compute the number of subdivisions.\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const subdivisions = Math.pow(2, countDivide);\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n\n  return texcoords;\n};\n\nPolygonGeometryLibrary.subdivideRhumbLine = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n  result\n) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const numVertices = Math.pow(2, countDivide);\n  const distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const positions = result;\n  positions.length = numVertices * 3;\n\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const c = rhumb.interpolateUsingSurfaceDistance(\n      i * distanceBetweenVertices,\n      scratchCartographic2\n    );\n    const p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\n    positions[index++] = p.x;\n    positions[index++] = p.y;\n    positions[index++] = p.z;\n  }\n\n  return positions;\n};\n\nconst scaleToGeodeticHeightN1 = new Cartesian3();\nconst scaleToGeodeticHeightN2 = new Cartesian3();\nconst scaleToGeodeticHeightP1 = new Cartesian3();\nconst scaleToGeodeticHeightP2 = new Cartesian3();\n\nPolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (\n  geometry,\n  maxHeight,\n  minHeight,\n  ellipsoid,\n  perPositionHeight\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  const n1 = scaleToGeodeticHeightN1;\n  let n2 = scaleToGeodeticHeightN2;\n  const p = scaleToGeodeticHeightP1;\n  let p2 = scaleToGeodeticHeightP2;\n\n  if (\n    defined(geometry) &&\n    defined(geometry.attributes) &&\n    defined(geometry.attributes.position)\n  ) {\n    const positions = geometry.attributes.position.values;\n    const length = positions.length / 2;\n\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      ellipsoid.geodeticSurfaceNormal(p, n1);\n      p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\n      n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i + length] = n2.x;\n      positions[i + 1 + length] = n2.y;\n      positions[i + 2 + length] = n2.z;\n\n      if (perPositionHeight) {\n        p2 = Cartesian3.clone(p, p2);\n      }\n      n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i] = n2.x;\n      positions[i + 1] = n2.y;\n      positions[i + 2] = n2.z;\n    }\n  }\n  return geometry;\n};\n\nPolygonGeometryLibrary.polygonOutlinesFromHierarchy = function (\n  polygonHierarchy,\n  scaleToEllipsoidSurface,\n  ellipsoid\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const polygons = [];\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n  let i;\n  let j;\n  let length;\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n    outerRing = arrayRemoveDuplicates(\n      outerRing,\n      Cartesian3.equalsEpsilon,\n      true\n    );\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    const numChildren = outerNode.holes ? outerNode.holes.length : 0;\n    // The outer polygon contains inner polygons\n    for (i = 0; i < numChildren; i++) {\n      const hole = outerNode.holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n      holePositions = arrayRemoveDuplicates(\n        holePositions,\n        Cartesian3.equalsEpsilon,\n        true\n      );\n      if (holePositions.length < 3) {\n        continue;\n      }\n      polygons.push(holePositions);\n\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    polygons.push(outerRing);\n  }\n\n  return polygons;\n};\n\nPolygonGeometryLibrary.polygonsFromHierarchy = function (\n  polygonHierarchy,\n  keepDuplicates,\n  projectPointsTo2D,\n  scaleToEllipsoidSurface,\n  ellipsoid\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const hierarchy = [];\n  const polygons = [];\n\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    const holes = outerNode.holes;\n\n    let i;\n    let length;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n\n    if (!keepDuplicates) {\n      outerRing = arrayRemoveDuplicates(\n        outerRing,\n        Cartesian3.equalsEpsilon,\n        true\n      );\n    }\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    let positions2D = projectPointsTo2D(outerRing);\n    if (!defined(positions2D)) {\n      continue;\n    }\n    const holeIndices = [];\n\n    let originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n      positions2D\n    );\n    if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n      positions2D.reverse();\n      outerRing = outerRing.slice().reverse();\n    }\n\n    let positions = outerRing.slice();\n    const numChildren = defined(holes) ? holes.length : 0;\n    const polygonHoles = [];\n    let j;\n\n    for (i = 0; i < numChildren; i++) {\n      const hole = holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n\n      if (!keepDuplicates) {\n        holePositions = arrayRemoveDuplicates(\n          holePositions,\n          Cartesian3.equalsEpsilon,\n          true\n        );\n      }\n      if (holePositions.length < 3) {\n        continue;\n      }\n\n      const holePositions2D = projectPointsTo2D(holePositions);\n      if (!defined(holePositions2D)) {\n        continue;\n      }\n\n      originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n        holePositions2D\n      );\n      if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n        holePositions2D.reverse();\n        holePositions = holePositions.slice().reverse();\n      }\n\n      polygonHoles.push(holePositions);\n      holeIndices.push(positions.length);\n      positions = positions.concat(holePositions);\n      positions2D = positions2D.concat(holePositions2D);\n\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    hierarchy.push({\n      outerRing: outerRing,\n      holes: polygonHoles,\n    });\n    polygons.push({\n      positions: positions,\n      positions2D: positions2D,\n      holes: holeIndices,\n    });\n  }\n\n  return {\n    hierarchy: hierarchy,\n    polygons: polygons,\n  };\n};\n\nconst computeBoundingRectangleCartesian2 = new Cartesian2();\nconst computeBoundingRectangleCartesian3 = new Cartesian3();\nconst computeBoundingRectangleQuaternion = new Quaternion();\nconst computeBoundingRectangleMatrix3 = new Matrix3();\nPolygonGeometryLibrary.computeBoundingRectangle = function (\n  planeNormal,\n  projectPointTo2D,\n  positions,\n  angle,\n  result\n) {\n  const rotation = Quaternion.fromAxisAngle(\n    planeNormal,\n    angle,\n    computeBoundingRectangleQuaternion\n  );\n  const textureMatrix = Matrix3.fromQuaternion(\n    rotation,\n    computeBoundingRectangleMatrix3\n  );\n\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n\n  const length = positions.length;\n  for (let i = 0; i < length; ++i) {\n    const p = Cartesian3.clone(\n      positions[i],\n      computeBoundingRectangleCartesian3\n    );\n    Matrix3.multiplyByVector(textureMatrix, p, p);\n    const st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\n\n    if (defined(st)) {\n      minX = Math.min(minX, st.x);\n      maxX = Math.max(maxX, st.x);\n\n      minY = Math.min(minY, st.y);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  result.x = minX;\n  result.y = minY;\n  result.width = maxX - minX;\n  result.height = maxY - minY;\n  return result;\n};\n\nPolygonGeometryLibrary.createGeometryFromPositions = function (\n  ellipsoid,\n  polygon,\n  textureCoordinates,\n  granularity,\n  perPositionHeight,\n  vertexFormat,\n  arcType\n) {\n  let indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n  /* If polygon is completely unrenderable, just use the first three vertices */\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n\n  const positions = polygon.positions;\n\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n\n  if (perPositionHeight) {\n    const length = positions.length;\n    const flattenedPositions = new Array(length * 3);\n    let index = 0;\n    for (let i = 0; i < length; i++) {\n      const p = positions[i];\n      flattenedPositions[index++] = p.x;\n      flattenedPositions[index++] = p.y;\n      flattenedPositions[index++] = p.z;\n    }\n\n    const geometryOptions = {\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: flattenedPositions,\n        }),\n      },\n      indices: indices,\n      primitiveType: PrimitiveType.TRIANGLES,\n    };\n\n    if (hasTexcoords) {\n      geometryOptions.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: Cartesian2.packArray(texcoords),\n      });\n    }\n\n    const geometry = new Geometry(geometryOptions);\n\n    if (vertexFormat.normal) {\n      return GeometryPipeline.computeNormal(geometry);\n    }\n\n    return geometry;\n  }\n\n  if (arcType === ArcType.GEODESIC) {\n    return PolygonPipeline.computeSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      texcoords,\n      granularity\n    );\n  } else if (arcType === ArcType.RHUMB) {\n    return PolygonPipeline.computeRhumbLineSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      texcoords,\n      granularity\n    );\n  }\n};\n\nconst computeWallTexcoordsSubdivided = [];\nconst computeWallIndicesSubdivided = [];\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\n\nPolygonGeometryLibrary.computeWallGeometry = function (\n  positions,\n  textureCoordinates,\n  ellipsoid,\n  granularity,\n  perPositionHeight,\n  arcType\n) {\n  let edgePositions;\n  let topEdgeLength;\n  let i;\n  let p1;\n  let p2;\n  let t1;\n  let t2;\n  let edgeTexcoords;\n  let topEdgeTexcoordLength;\n\n  let length = positions.length;\n  let index = 0;\n  let textureIndex = 0;\n\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n\n  if (!perPositionHeight) {\n    const minDistance = CesiumMath.chordLength(\n      granularity,\n      ellipsoid.maximumRadius\n    );\n\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    }\n\n    topEdgeLength = (numVertices + length) * 3;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = (numVertices + length) * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n\n      let tempPositions;\n      let tempTexcoords;\n\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n      }\n\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided\n        );\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordLine(\n            t1,\n            t2,\n            p1,\n            p2,\n            minDistance,\n            computeWallTexcoordsSubdivided\n          );\n        }\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided\n        );\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordRhumbLine(\n            t1,\n            t2,\n            ellipsoid,\n            p1,\n            p2,\n            minDistance,\n            computeWallTexcoordsSubdivided\n          );\n        }\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j, ++index) {\n        edgePositions[index] = tempPositions[j];\n        edgePositions[index + topEdgeLength] = tempPositions[j];\n      }\n\n      edgePositions[index] = p2.x;\n      edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n\n      edgePositions[index] = p2.y;\n      edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n\n      edgePositions[index] = p2.z;\n      edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n\n      if (hasTexcoords) {\n        const tempTexcoordsLength = tempTexcoords.length;\n        for (let k = 0; k < tempTexcoordsLength; ++k, ++textureIndex) {\n          edgeTexcoords[textureIndex] = tempTexcoords[k];\n          edgeTexcoords[textureIndex + topEdgeTexcoordLength] =\n            tempTexcoords[k];\n        }\n\n        edgeTexcoords[textureIndex] = t2.x;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.x;\n        ++textureIndex;\n\n        edgeTexcoords[textureIndex] = t2.y;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.y;\n        ++textureIndex;\n      }\n    }\n  } else {\n    topEdgeLength = length * 3 * 2;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = length * 2 * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t1.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t1.y;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t2.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t2.y;\n        ++textureIndex;\n      }\n    }\n  }\n\n  length = edgePositions.length;\n  const indices = IndexDatatype.createTypedArray(\n    length / 3,\n    length - positions.length * 6\n  );\n  let edgeIndex = 0;\n  length /= 6;\n\n  for (i = 0; i < length; i++) {\n    const UL = i;\n    const UR = UL + 1;\n    const LL = UL + length;\n    const LR = LL + 1;\n\n    p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\n    p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\n    if (\n      Cartesian3.equalsEpsilon(\n        p1,\n        p2,\n        CesiumMath.EPSILON10,\n        CesiumMath.EPSILON10\n      )\n    ) {\n      //skip corner\n      continue;\n    }\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  const geometryOptions = {\n    attributes: new GeometryAttributes({\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: edgePositions,\n      }),\n    }),\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: edgeTexcoords,\n    });\n  }\n\n  const geometry = new Geometry(geometryOptions);\n\n  return geometry;\n};\nexport default PolygonGeometryLibrary;\n","import defined from \"./defined.js\";\n\n/**\n * An hierarchy of linear rings which define a polygon and its holes.\n * The holes themselves may also have holes which nest inner polygons.\n * @alias PolygonHierarchy\n * @constructor\n *\n * @param {Cartesian3[]} [positions] A linear ring defining the outer boundary of the polygon or hole.\n * @param {PolygonHierarchy[]} [holes] An array of polygon hierarchies defining holes in the polygon.\n */\nfunction PolygonHierarchy(positions, holes) {\n  /**\n   * A linear ring defining the outer boundary of the polygon or hole.\n   * @type {Cartesian3[]}\n   */\n  this.positions = defined(positions) ? positions : [];\n\n  /**\n   * An array of polygon hierarchies defining holes in the polygon.\n   * @type {PolygonHierarchy[]}\n   */\n  this.holes = defined(holes) ? holes : [];\n}\nexport default PolygonHierarchy;\n","import ArcType from \"./ArcType.js\";\nimport arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonGeometryLibrary from \"./PolygonGeometryLibrary.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\nconst createGeometryFromPositionsPositions = [];\nconst createGeometryFromPositionsSubdivided = [];\n\nfunction createGeometryFromPositions(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType\n) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions\n  );\n\n  const originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n    positions2D\n  );\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  let subdividedPositions;\n  let i;\n\n  let length = positions.length;\n  let index = 0;\n\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    }\n    subdividedPositions = new Float64Array(numVertices * 3);\n    for (i = 0; i < length; i++) {\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3);\n    for (i = 0; i < length; i++) {\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / 3;\n  const indicesSize = length * 2;\n  const indices = IndexDatatype.createTypedArray(length, indicesSize);\n  index = 0;\n  for (i = 0; i < length - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n  indices[index++] = length - 1;\n  indices[index++] = 0;\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\nfunction createGeometryFromPositionsExtruded(\n  ellipsoid,\n  positions,\n  minDistance,\n  perPositionHeight,\n  arcType\n) {\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n  const positions2D = tangentPlane.projectPointsOntoPlane(\n    positions,\n    createGeometryFromPositionsPositions\n  );\n\n  const originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n    positions2D\n  );\n  if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n    positions2D.reverse();\n    positions = positions.slice().reverse();\n  }\n\n  let subdividedPositions;\n  let i;\n\n  let length = positions.length;\n  const corners = new Array(length);\n  let index = 0;\n\n  if (!perPositionHeight) {\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    }\n\n    subdividedPositions = new Float64Array(numVertices * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      let tempPositions;\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance,\n          createGeometryFromPositionsSubdivided\n        );\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j) {\n        subdividedPositions[index++] = tempPositions[j];\n      }\n    }\n  } else {\n    subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n    for (i = 0; i < length; ++i) {\n      corners[i] = index / 3;\n      const p0 = positions[i];\n      const p1 = positions[(i + 1) % length];\n\n      subdividedPositions[index++] = p0.x;\n      subdividedPositions[index++] = p0.y;\n      subdividedPositions[index++] = p0.z;\n      subdividedPositions[index++] = p1.x;\n      subdividedPositions[index++] = p1.y;\n      subdividedPositions[index++] = p1.z;\n    }\n  }\n\n  length = subdividedPositions.length / (3 * 2);\n  const cornersLength = corners.length;\n\n  const indicesSize = (length * 2 + cornersLength) * 2;\n  const indices = IndexDatatype.createTypedArray(\n    length + cornersLength,\n    indicesSize\n  );\n\n  index = 0;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  for (i = 0; i < cornersLength; i++) {\n    const corner = corners[i];\n    indices[index++] = corner;\n    indices[index++] = corner + length;\n  }\n\n  return new GeometryInstance({\n    geometry: new Geometry({\n      attributes: new GeometryAttributes({\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: subdividedPositions,\n        }),\n      }),\n      indices: indices,\n      primitiveType: PrimitiveType.LINES,\n    }),\n  });\n}\n\n/**\n * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n *\n * @alias PolygonOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n *\n * @see PolygonOutlineGeometry#createGeometry\n * @see PolygonOutlineGeometry#fromPositions\n *\n * @example\n * // 1. create a polygon outline from points\n * const polygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * // 2. create a nested polygon with holes outline\n * const polygonWithHole = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -109.0, 30.0,\n *       -95.0, 30.0,\n *       -95.0, 40.0,\n *       -109.0, 40.0\n *     ]),\n *     [new Cesium.PolygonHierarchy(\n *       Cesium.Cartesian3.fromDegreesArray([\n *         -107.0, 31.0,\n *         -107.0, 39.0,\n *         -97.0, 39.0,\n *         -97.0, 31.0\n *       ]),\n *       [new Cesium.PolygonHierarchy(\n *         Cesium.Cartesian3.fromDegreesArray([\n *           -105.0, 33.0,\n *           -99.0, 33.0,\n *           -99.0, 37.0,\n *           -105.0, 37.0\n *         ]),\n *         [new Cesium.PolygonHierarchy(\n *           Cesium.Cartesian3.fromDegreesArray([\n *             -103.0, 34.0,\n *             -101.0, 34.0,\n *             -101.0, 36.0,\n *             -103.0, 36.0\n *           ])\n *         )]\n *       )]\n *     )]\n *   )\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n *\n * // 3. create extruded polygon outline\n * const extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\n *     Cesium.Cartesian3.fromDegreesArray([\n *       -72.0, 40.0,\n *       -70.0, 35.0,\n *       -75.0, 30.0,\n *       -70.0, 30.0,\n *       -68.0, 40.0\n *     ])\n *   ),\n *   extrudedHeight: 300000\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n */\nfunction PolygonOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\n\n  if (options.perPositionHeight && defined(options.height)) {\n    throw new DeveloperError(\n      \"Cannot use both options.perPositionHeight and options.height\"\n    );\n  }\n  if (\n    defined(options.arcType) &&\n    options.arcType !== ArcType.GEODESIC &&\n    options.arcType !== ArcType.RHUMB\n  ) {\n    throw new DeveloperError(\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const polygonHierarchy = options.polygonHierarchy;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\n  const perPositionHeightExtrude =\n    perPositionHeight && defined(options.extrudedHeight);\n  const arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n  let height = defaultValue(options.height, 0.0);\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  if (!perPositionHeightExtrude) {\n    const h = Math.max(height, extrudedHeight);\n    extrudedHeight = Math.min(height, extrudedHeight);\n    height = h;\n  }\n\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._granularity = granularity;\n  this._height = height;\n  this._extrudedHeight = extrudedHeight;\n  this._arcType = arcType;\n  this._polygonHierarchy = polygonHierarchy;\n  this._perPositionHeight = perPositionHeight;\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createPolygonOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\n      polygonHierarchy,\n      Cartesian3\n    ) +\n    Ellipsoid.packedLength +\n    8;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolygonOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolygonOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\n    value._polygonHierarchy,\n    array,\n    startingIndex,\n    Cartesian3\n  );\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n  array[startingIndex] = value.packedLength;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst dummyOptions = {\n  polygonHierarchy: {},\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n */\nPolygonOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\n    array,\n    startingIndex,\n    Cartesian3\n  );\n  startingIndex = polygonHierarchy.startingIndex;\n  delete polygonHierarchy.startingIndex;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\n  const perPositionHeight = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const offsetAttribute = array[startingIndex++];\n  const packedLength = array[startingIndex];\n\n  if (!defined(result)) {\n    result = new PolygonOutlineGeometry(dummyOptions);\n  }\n\n  result._polygonHierarchy = polygonHierarchy;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._granularity = granularity;\n  result._perPositionHeight = perPositionHeight;\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\n  result._arcType = arcType;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n  result.packedLength = packedLength;\n\n  return result;\n};\n\n/**\n * A description of a polygon outline from an array of positions.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n * @param {Number} [options.height=0.0] The height of the polygon.\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n * @returns {PolygonOutlineGeometry}\n *\n *\n * @example\n * // create a polygon from points\n * const polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0,\n *     -75.0, 30.0,\n *     -70.0, 30.0,\n *     -68.0, 40.0\n *   ])\n * });\n * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n *\n * @see PolygonOutlineGeometry#createGeometry\n */\nPolygonOutlineGeometry.fromPositions = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", options.positions);\n  //>>includeEnd('debug');\n\n  const newOptions = {\n    polygonHierarchy: {\n      positions: options.positions,\n    },\n    height: options.height,\n    extrudedHeight: options.extrudedHeight,\n    ellipsoid: options.ellipsoid,\n    granularity: options.granularity,\n    perPositionHeight: options.perPositionHeight,\n    arcType: options.arcType,\n    offsetAttribute: options.offsetAttribute,\n  };\n  return new PolygonOutlineGeometry(newOptions);\n};\n\n/**\n * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolygonOutlineGeometry.createGeometry = function (polygonGeometry) {\n  const ellipsoid = polygonGeometry._ellipsoid;\n  const granularity = polygonGeometry._granularity;\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\n  const perPositionHeight = polygonGeometry._perPositionHeight;\n  const arcType = polygonGeometry._arcType;\n\n  const polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(\n    polygonHierarchy,\n    !perPositionHeight,\n    ellipsoid\n  );\n\n  if (polygons.length === 0) {\n    return undefined;\n  }\n\n  let geometryInstance;\n  const geometries = [];\n  const minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius\n  );\n\n  const height = polygonGeometry._height;\n  const extrudedHeight = polygonGeometry._extrudedHeight;\n  const extrude =\n    polygonGeometry._perPositionHeightExtrude ||\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n  let offsetValue;\n  let i;\n  if (extrude) {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositionsExtruded(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType\n      );\n      geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\n        geometryInstance.geometry,\n        height,\n        extrudedHeight,\n        ellipsoid,\n        perPositionHeight\n      );\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const size =\n          geometryInstance.geometry.attributes.position.values.length / 3;\n        let offsetAttribute = new Uint8Array(size);\n        if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n          offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n        } else {\n          offsetValue =\n            polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n              ? 0\n              : 1;\n          offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n        }\n\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\n          {\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: offsetAttribute,\n          }\n        );\n      }\n      geometries.push(geometryInstance);\n    }\n  } else {\n    for (i = 0; i < polygons.length; i++) {\n      geometryInstance = createGeometryFromPositions(\n        ellipsoid,\n        polygons[i],\n        minDistance,\n        perPositionHeight,\n        arcType\n      );\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n        geometryInstance.geometry.attributes.position.values,\n        height,\n        ellipsoid,\n        !perPositionHeight\n      );\n\n      if (defined(polygonGeometry._offsetAttribute)) {\n        const length =\n          geometryInstance.geometry.attributes.position.values.length;\n        const applyOffset = new Uint8Array(length / 3);\n        offsetValue =\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n            ? 0\n            : 1;\n        arrayFill(applyOffset, offsetValue);\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\n          {\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n            componentsPerAttribute: 1,\n            values: applyOffset,\n          }\n        );\n      }\n\n      geometries.push(geometryInstance);\n    }\n  }\n\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\n  const boundingSphere = BoundingSphere.fromVertices(\n    geometry.attributes.position.values\n  );\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: boundingSphere,\n    offsetAttribute: polygonGeometry._offsetAttribute,\n  });\n};\nexport default PolygonOutlineGeometry;\n","import earcut from \"../ThirdParty/earcut.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nconst scaleToGeodeticHeightN = new Cartesian3();\nconst scaleToGeodeticHeightP = new Cartesian3();\n\n/**\n * @private\n */\nconst PolygonPipeline = {};\n\n/**\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeArea2D = function (positions) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"positions.length\",\n    positions.length,\n    3\n  );\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  let area = 0.0;\n\n  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    const v0 = positions[i0];\n    const v1 = positions[i1];\n\n    area += v0.x * v1.y - v1.x * v0.y;\n  }\n\n  return area * 0.5;\n};\n\n/**\n * @returns {WindingOrder} The winding order.\n *\n * @exception {DeveloperError} At least three positions are required.\n */\nPolygonPipeline.computeWindingOrder2D = function (positions) {\n  const area = PolygonPipeline.computeArea2D(positions);\n  return area > 0.0 ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;\n};\n\n/**\n * Triangulate a polygon.\n *\n * @param {Cartesian2[]} positions Cartesian2 array containing the vertices of the polygon\n * @param {Number[]} [holes] An array of the staring indices of the holes.\n * @returns {Number[]} Index array representing triangles that fill the polygon\n */\nPolygonPipeline.triangulate = function (positions, holes) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  const flattenedPositions = Cartesian2.packArray(positions);\n  return earcut(flattenedPositions, holes, 2);\n};\n\nconst subdivisionV0Scratch = new Cartesian3();\nconst subdivisionV1Scratch = new Cartesian3();\nconst subdivisionV2Scratch = new Cartesian3();\nconst subdivisionS0Scratch = new Cartesian3();\nconst subdivisionS1Scratch = new Cartesian3();\nconst subdivisionS2Scratch = new Cartesian3();\nconst subdivisionMidScratch = new Cartesian3();\nconst subdivisionT0Scratch = new Cartesian2();\nconst subdivisionT1Scratch = new Cartesian2();\nconst subdivisionT2Scratch = new Cartesian2();\nconst subdivisionTexcoordMidScratch = new Cartesian2();\n\n/**\n * Subdivides positions and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {Number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.\n * @param {Number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeSubdivision = function (\n  ellipsoid,\n  positions,\n  indices,\n  texcoords,\n  granularity\n) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n  const hasTexcoords = defined(texcoords);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  const triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  let i;\n  const length = positions.length;\n  const subdividedPositions = new Array(length * 3);\n  const subdividedTexcoords = new Array(length * 2);\n  let q = 0;\n  let p = 0;\n  for (i = 0; i < length; i++) {\n    const item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n\n    if (hasTexcoords) {\n      const texcoordItem = texcoords[i];\n      subdividedTexcoords[p++] = texcoordItem.x;\n      subdividedTexcoords[p++] = texcoordItem.y;\n    }\n  }\n\n  const subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  const edges = {};\n\n  const radius = ellipsoid.maximumRadius;\n  const minDistance = CesiumMath.chordLength(granularity, radius);\n  const minDistanceSqrd = minDistance * minDistance;\n\n  while (triangles.length > 0) {\n    const i2 = triangles.pop();\n    const i1 = triangles.pop();\n    const i0 = triangles.pop();\n\n    const v0 = Cartesian3.fromArray(\n      subdividedPositions,\n      i0 * 3,\n      subdivisionV0Scratch\n    );\n    const v1 = Cartesian3.fromArray(\n      subdividedPositions,\n      i1 * 3,\n      subdivisionV1Scratch\n    );\n    const v2 = Cartesian3.fromArray(\n      subdividedPositions,\n      i2 * 3,\n      subdivisionV2Scratch\n    );\n\n    let t0, t1, t2;\n    if (hasTexcoords) {\n      t0 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i0 * 2,\n        subdivisionT0Scratch\n      );\n      t1 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i1 * 2,\n        subdivisionT1Scratch\n      );\n      t2 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i2 * 2,\n        subdivisionT2Scratch\n      );\n    }\n\n    const s0 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v0, subdivisionS0Scratch),\n      radius,\n      subdivisionS0Scratch\n    );\n    const s1 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v1, subdivisionS1Scratch),\n      radius,\n      subdivisionS1Scratch\n    );\n    const s2 = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(v2, subdivisionS2Scratch),\n      radius,\n      subdivisionS2Scratch\n    );\n\n    const g0 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s0, s1, subdivisionMidScratch)\n    );\n    const g1 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s1, s2, subdivisionMidScratch)\n    );\n    const g2 = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(s2, s0, subdivisionMidScratch)\n    );\n\n    const max = Math.max(g0, g1, g2);\n    let edge;\n    let mid;\n    let midTexcoord;\n\n    // if the max length squared of a triangle edge is greater than the chord length of squared\n    // of the granularity, subdivide the triangle\n    if (max > minDistanceSqrd) {\n      if (g0 === max) {\n        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v0, v1, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v1, v2, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = Cartesian3.add(v2, v0, subdivisionMidScratch);\n          Cartesian3.multiplyByScalar(mid, 0.5, mid);\n          subdividedPositions.push(mid.x, mid.y, mid.z);\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  const geometryOptions = {\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions,\n      }),\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: subdividedTexcoords,\n    });\n  }\n\n  return new Geometry(geometryOptions);\n};\n\nconst subdivisionC0Scratch = new Cartographic();\nconst subdivisionC1Scratch = new Cartographic();\nconst subdivisionC2Scratch = new Cartographic();\nconst subdivisionCartographicScratch = new Cartographic();\n\n/**\n * Subdivides positions on rhumb lines and raises points to the surface of the ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid the polygon in on.\n * @param {Cartesian3[]} positions An array of {@link Cartesian3} positions of the polygon.\n * @param {Number[]} indices An array of indices that determines the triangles in the polygon.\n * @param {Cartesian2[]} texcoords An optional array of {@link Cartesian2} texture coordinates of the polygon.\n * @param {Number} [granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n *\n * @exception {DeveloperError} At least three indices are required.\n * @exception {DeveloperError} The number of indices must be divisable by three.\n * @exception {DeveloperError} Granularity must be greater than zero.\n */\nPolygonPipeline.computeRhumbLineSubdivision = function (\n  ellipsoid,\n  positions,\n  indices,\n  texcoords,\n  granularity\n) {\n  granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n  const hasTexcoords = defined(texcoords);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.defined(\"positions\", positions);\n  Check.defined(\"indices\", indices);\n  Check.typeOf.number.greaterThanOrEquals(\"indices.length\", indices.length, 3);\n  Check.typeOf.number.equals(\"indices.length % 3\", \"0\", indices.length % 3, 0);\n  Check.typeOf.number.greaterThan(\"granularity\", granularity, 0.0);\n  //>>includeEnd('debug');\n\n  // triangles that need (or might need) to be subdivided.\n  const triangles = indices.slice(0);\n\n  // New positions due to edge splits are appended to the positions list.\n  let i;\n  const length = positions.length;\n  const subdividedPositions = new Array(length * 3);\n  const subdividedTexcoords = new Array(length * 2);\n  let q = 0;\n  let p = 0;\n  for (i = 0; i < length; i++) {\n    const item = positions[i];\n    subdividedPositions[q++] = item.x;\n    subdividedPositions[q++] = item.y;\n    subdividedPositions[q++] = item.z;\n\n    if (hasTexcoords) {\n      const texcoordItem = texcoords[i];\n      subdividedTexcoords[p++] = texcoordItem.x;\n      subdividedTexcoords[p++] = texcoordItem.y;\n    }\n  }\n\n  const subdividedIndices = [];\n\n  // Used to make sure shared edges are not split more than once.\n  const edges = {};\n\n  const radius = ellipsoid.maximumRadius;\n  const minDistance = CesiumMath.chordLength(granularity, radius);\n\n  const rhumb0 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  const rhumb1 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  const rhumb2 = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n\n  while (triangles.length > 0) {\n    const i2 = triangles.pop();\n    const i1 = triangles.pop();\n    const i0 = triangles.pop();\n\n    const v0 = Cartesian3.fromArray(\n      subdividedPositions,\n      i0 * 3,\n      subdivisionV0Scratch\n    );\n    const v1 = Cartesian3.fromArray(\n      subdividedPositions,\n      i1 * 3,\n      subdivisionV1Scratch\n    );\n    const v2 = Cartesian3.fromArray(\n      subdividedPositions,\n      i2 * 3,\n      subdivisionV2Scratch\n    );\n\n    let t0, t1, t2;\n    if (hasTexcoords) {\n      t0 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i0 * 2,\n        subdivisionT0Scratch\n      );\n      t1 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i1 * 2,\n        subdivisionT1Scratch\n      );\n      t2 = Cartesian2.fromArray(\n        subdividedTexcoords,\n        i2 * 2,\n        subdivisionT2Scratch\n      );\n    }\n\n    const c0 = ellipsoid.cartesianToCartographic(v0, subdivisionC0Scratch);\n    const c1 = ellipsoid.cartesianToCartographic(v1, subdivisionC1Scratch);\n    const c2 = ellipsoid.cartesianToCartographic(v2, subdivisionC2Scratch);\n\n    rhumb0.setEndPoints(c0, c1);\n    const g0 = rhumb0.surfaceDistance;\n    rhumb1.setEndPoints(c1, c2);\n    const g1 = rhumb1.surfaceDistance;\n    rhumb2.setEndPoints(c2, c0);\n    const g2 = rhumb2.surfaceDistance;\n\n    const max = Math.max(g0, g1, g2);\n    let edge;\n    let mid;\n    let midHeight;\n    let midCartesian3;\n    let midTexcoord;\n\n    // if the max length squared of a triangle edge is greater than granularity, subdivide the triangle\n    if (max > minDistance) {\n      if (g0 === max) {\n        edge = `${Math.min(i0, i1)} ${Math.max(i0, i1)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb0.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch\n          );\n          midHeight = (c0.height + c1.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t0, t1, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i0, i, i2);\n        triangles.push(i, i1, i2);\n      } else if (g1 === max) {\n        edge = `${Math.min(i1, i2)} ${Math.max(i1, i2)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb1.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch\n          );\n          midHeight = (c1.height + c2.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t1, t2, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i1, i, i0);\n        triangles.push(i, i2, i0);\n      } else if (g2 === max) {\n        edge = `${Math.min(i2, i0)} ${Math.max(i2, i0)}`;\n\n        i = edges[edge];\n        if (!defined(i)) {\n          mid = rhumb2.interpolateUsingFraction(\n            0.5,\n            subdivisionCartographicScratch\n          );\n          midHeight = (c2.height + c0.height) * 0.5;\n          midCartesian3 = Cartesian3.fromRadians(\n            mid.longitude,\n            mid.latitude,\n            midHeight,\n            ellipsoid,\n            subdivisionMidScratch\n          );\n          subdividedPositions.push(\n            midCartesian3.x,\n            midCartesian3.y,\n            midCartesian3.z\n          );\n          i = subdividedPositions.length / 3 - 1;\n          edges[edge] = i;\n\n          if (hasTexcoords) {\n            midTexcoord = Cartesian2.add(t2, t0, subdivisionTexcoordMidScratch);\n            Cartesian2.multiplyByScalar(midTexcoord, 0.5, midTexcoord);\n            subdividedTexcoords.push(midTexcoord.x, midTexcoord.y);\n          }\n        }\n\n        triangles.push(i2, i, i1);\n        triangles.push(i, i0, i1);\n      }\n    } else {\n      subdividedIndices.push(i0);\n      subdividedIndices.push(i1);\n      subdividedIndices.push(i2);\n    }\n  }\n\n  const geometryOptions = {\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: subdividedPositions,\n      }),\n    },\n    indices: subdividedIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: subdividedTexcoords,\n    });\n  }\n\n  return new Geometry(geometryOptions);\n};\n\n/**\n * Scales each position of a geometry's position attribute to a height, in place.\n *\n * @param {Number[]} positions The array of numbers representing the positions to be scaled\n * @param {Number} [height=0.0] The desired height to add to the positions\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @param {Boolean} [scaleToSurface=true] <code>true</code> if the positions need to be scaled to the surface before the height is added.\n * @returns {Number[]} The input array of positions, scaled to height\n */\nPolygonPipeline.scaleToGeodeticHeight = function (\n  positions,\n  height,\n  ellipsoid,\n  scaleToSurface\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  let n = scaleToGeodeticHeightN;\n  let p = scaleToGeodeticHeightP;\n\n  height = defaultValue(height, 0.0);\n  scaleToSurface = defaultValue(scaleToSurface, true);\n\n  if (defined(positions)) {\n    const length = positions.length;\n\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      if (scaleToSurface) {\n        p = ellipsoid.scaleToGeodeticSurface(p, p);\n      }\n\n      if (height !== 0) {\n        n = ellipsoid.geodeticSurfaceNormal(p, n);\n\n        Cartesian3.multiplyByScalar(n, height, n);\n        Cartesian3.add(p, n, p);\n      }\n\n      positions[i] = p.x;\n      positions[i + 1] = p.y;\n      positions[i + 2] = p.z;\n    }\n  }\n\n  return positions;\n};\nexport default PolygonPipeline;\n","import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Color from \"./Color.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst scratchInterpolateColorsArray = [];\n\nfunction interpolateColors(p0, p1, color0, color1, numPoints) {\n  const colors = scratchInterpolateColorsArray;\n  colors.length = numPoints;\n  let i;\n\n  const r0 = color0.red;\n  const g0 = color0.green;\n  const b0 = color0.blue;\n  const a0 = color0.alpha;\n\n  const r1 = color1.red;\n  const g1 = color1.green;\n  const b1 = color1.blue;\n  const a1 = color1.alpha;\n\n  if (Color.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      colors[i] = Color.clone(color0);\n    }\n    return colors;\n  }\n\n  const redPerVertex = (r1 - r0) / numPoints;\n  const greenPerVertex = (g1 - g0) / numPoints;\n  const bluePerVertex = (b1 - b0) / numPoints;\n  const alphaPerVertex = (a1 - a0) / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    colors[i] = new Color(\n      r0 + i * redPerVertex,\n      g0 + i * greenPerVertex,\n      b0 + i * bluePerVertex,\n      a0 + i * alphaPerVertex\n    );\n  }\n\n  return colors;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position. The polyline is capable of\n * displaying with a material.\n *\n * @alias PolylineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Number} [options.width=1.0] The width in pixels.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} width must be greater than or equal to one.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see PolylineGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n *\n * @example\n * // A polyline with two connected line segments\n * const polyline = new Cesium.PolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ]),\n *   width : 10.0\n * });\n * const geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n */\nfunction PolylineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const colors = options.colors;\n  const width = defaultValue(options.width, 1.0);\n  const colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions) || positions.length < 2) {\n    throw new DeveloperError(\"At least two positions are required.\");\n  }\n  if (typeof width !== \"number\") {\n    throw new DeveloperError(\"width must be a number\");\n  }\n  if (\n    defined(colors) &&\n    ((colorsPerVertex && colors.length < positions.length) ||\n      (!colorsPerVertex && colors.length < positions.length - 1))\n  ) {\n    throw new DeveloperError(\"colors has an invalid length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._width = width;\n  this._colorsPerVertex = colorsPerVertex;\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\n  );\n\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._workerName = \"createPolylineGeometry\";\n\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const colors = value._colors;\n  length = defined(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    Color.pack(colors[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  colors: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  colorsPerVertex: undefined,\n  arcType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineGeometry} [result] The object into which to store the result.\n * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n */\nPolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  const colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n    colors[i] = Color.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const width = array[startingIndex++];\n  const colorsPerVertex = array[startingIndex++] === 1.0;\n  const arcType = array[startingIndex++];\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.colors = colors;\n    scratchOptions.width = width;\n    scratchOptions.colorsPerVertex = colorsPerVertex;\n    scratchOptions.arcType = arcType;\n    scratchOptions.granularity = granularity;\n    return new PolylineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nconst scratchCartesian3 = new Cartesian3();\nconst scratchPosition = new Cartesian3();\nconst scratchPrevPosition = new Cartesian3();\nconst scratchNextPosition = new Cartesian3();\n\n/**\n * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineGeometry.createGeometry = function (polylineGeometry) {\n  const width = polylineGeometry._width;\n  const vertexFormat = polylineGeometry._vertexFormat;\n  let colors = polylineGeometry._colors;\n  const colorsPerVertex = polylineGeometry._colorsPerVertex;\n  const arcType = polylineGeometry._arcType;\n  const granularity = polylineGeometry._granularity;\n  const ellipsoid = polylineGeometry._ellipsoid;\n\n  let i;\n  let j;\n  let k;\n\n  const removedIndices = [];\n  let positions = arrayRemoveDuplicates(\n    polylineGeometry._positions,\n    Cartesian3.equalsEpsilon,\n    false,\n    removedIndices\n  );\n\n  if (defined(colors) && removedIndices.length > 0) {\n    let removedArrayIndex = 0;\n    let nextRemovedIndex = removedIndices[0];\n    colors = colors.filter(function (color, index) {\n      let remove = false;\n      if (colorsPerVertex) {\n        remove =\n          index === nextRemovedIndex || (index === 0 && nextRemovedIndex === 1);\n      } else {\n        remove = index + 1 === nextRemovedIndex;\n      }\n\n      if (remove) {\n        removedArrayIndex++;\n        nextRemovedIndex = removedIndices[removedArrayIndex];\n        return false;\n      }\n      return true;\n    });\n  }\n\n  let positionsLength = positions.length;\n\n  // A width of a pixel or less is not a valid geometry, but in order to support external data\n  // that may have errors we treat this as an empty geometry.\n  if (positionsLength < 2 || width <= 0.0) {\n    return undefined;\n  }\n\n  if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n    let subdivisionSize;\n    let numberOfPointsFunction;\n    if (arcType === ArcType.GEODESIC) {\n      subdivisionSize = CesiumMath.chordLength(\n        granularity,\n        ellipsoid.maximumRadius\n      );\n      numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n    }\n\n    const heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n    if (defined(colors)) {\n      let colorLength = 1;\n      for (i = 0; i < positionsLength - 1; ++i) {\n        colorLength += numberOfPointsFunction(\n          positions[i],\n          positions[i + 1],\n          subdivisionSize\n        );\n      }\n\n      const newColors = new Array(colorLength);\n      let newColorIndex = 0;\n\n      for (i = 0; i < positionsLength - 1; ++i) {\n        const p0 = positions[i];\n        const p1 = positions[i + 1];\n        const c0 = colors[i];\n\n        const numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n        if (colorsPerVertex && i < colorLength) {\n          const c1 = colors[i + 1];\n          const interpolatedColors = interpolateColors(\n            p0,\n            p1,\n            c0,\n            c1,\n            numColors\n          );\n          const interpolatedColorsLength = interpolatedColors.length;\n          for (j = 0; j < interpolatedColorsLength; ++j) {\n            newColors[newColorIndex++] = interpolatedColors[j];\n          }\n        } else {\n          for (j = 0; j < numColors; ++j) {\n            newColors[newColorIndex++] = Color.clone(c0);\n          }\n        }\n      }\n\n      newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n      colors = newColors;\n\n      scratchInterpolateColorsArray.length = 0;\n    }\n\n    if (arcType === ArcType.GEODESIC) {\n      positions = PolylinePipeline.generateCartesianArc({\n        positions: positions,\n        minDistance: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    } else {\n      positions = PolylinePipeline.generateCartesianRhumbArc({\n        positions: positions,\n        granularity: subdivisionSize,\n        ellipsoid: ellipsoid,\n        height: heights,\n      });\n    }\n  }\n\n  positionsLength = positions.length;\n  const size = positionsLength * 4.0 - 4.0;\n\n  const finalPositions = new Float64Array(size * 3);\n  const prevPositions = new Float64Array(size * 3);\n  const nextPositions = new Float64Array(size * 3);\n  const expandAndWidth = new Float32Array(size * 2);\n  const st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n  const finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n\n  let positionIndex = 0;\n  let expandAndWidthIndex = 0;\n  let stIndex = 0;\n  let colorIndex = 0;\n  let position;\n\n  for (j = 0; j < positionsLength; ++j) {\n    if (j === 0) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(positions[0], positions[1], position);\n      Cartesian3.add(positions[0], position, position);\n    } else {\n      position = positions[j - 1];\n    }\n\n    Cartesian3.clone(position, scratchPrevPosition);\n    Cartesian3.clone(positions[j], scratchPosition);\n\n    if (j === positionsLength - 1) {\n      position = scratchCartesian3;\n      Cartesian3.subtract(\n        positions[positionsLength - 1],\n        positions[positionsLength - 2],\n        position\n      );\n      Cartesian3.add(positions[positionsLength - 1], position, position);\n    } else {\n      position = positions[j + 1];\n    }\n\n    Cartesian3.clone(position, scratchNextPosition);\n\n    let color0, color1;\n    if (defined(finalColors)) {\n      if (j !== 0 && !colorsPerVertex) {\n        color0 = colors[j - 1];\n      } else {\n        color0 = colors[j];\n      }\n\n      if (j !== positionsLength - 1) {\n        color1 = colors[j];\n      }\n    }\n\n    const startK = j === 0 ? 2 : 0;\n    const endK = j === positionsLength - 1 ? 2 : 4;\n\n    for (k = startK; k < endK; ++k) {\n      Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n      Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n      Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n      positionIndex += 3;\n\n      const direction = k - 2 < 0 ? -1.0 : 1.0;\n      expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1; // expand direction\n      expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n      if (vertexFormat.st) {\n        st[stIndex++] = j / (positionsLength - 1);\n        st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n      }\n\n      if (defined(finalColors)) {\n        const color = k < 2 ? color0 : color1;\n\n        finalColors[colorIndex++] = Color.floatToByte(color.red);\n        finalColors[colorIndex++] = Color.floatToByte(color.green);\n        finalColors[colorIndex++] = Color.floatToByte(color.blue);\n        finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  attributes.prevPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: prevPositions,\n  });\n\n  attributes.nextPosition = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: nextPositions,\n  });\n\n  attributes.expandAndWidth = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 2,\n    values: expandAndWidth,\n  });\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (defined(finalColors)) {\n    attributes.color = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: finalColors,\n      normalize: true,\n    });\n  }\n\n  const indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n  let index = 0;\n  let indicesIndex = 0;\n  const length = positionsLength - 1.0;\n  for (j = 0; j < length; ++j) {\n    indices[indicesIndex++] = index;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 1;\n\n    indices[indicesIndex++] = index + 1;\n    indices[indicesIndex++] = index + 2;\n    indices[indicesIndex++] = index + 3;\n\n    index += 4;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromPoints(positions),\n    geometryType: GeometryType.POLYLINES,\n  });\n};\nexport default PolylineGeometry;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * @private\n */\nconst PolylinePipeline = {};\n\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  return Math.ceil(distance / minDistance);\n};\n\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\n  const radiansDistanceSquared =\n    Math.pow(p0.longitude - p1.longitude, 2) +\n    Math.pow(p0.latitude - p1.latitude, 2);\n\n  return Math.max(\n    1,\n    Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity)))\n  );\n};\n\nconst cartoScratch = new Cartographic();\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\n  const length = positions.length;\n  const heights = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const p = positions[i];\n    heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n  }\n  return heights;\n};\n\nconst wrapLongitudeInversMatrix = new Matrix4();\nconst wrapLongitudeOrigin = new Cartesian3();\nconst wrapLongitudeXZNormal = new Cartesian3();\nconst wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeYZNormal = new Cartesian3();\nconst wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nconst wrapLongitudeIntersection = new Cartesian3();\nconst wrapLongitudeOffset = new Cartesian3();\n\nconst subdivideHeightsScratchArray = [];\n\nfunction subdivideHeights(numPoints, h0, h1) {\n  const heights = subdivideHeightsScratchArray;\n  heights.length = numPoints;\n\n  let i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    return heights;\n  }\n\n  const dHeight = h1 - h0;\n  const heightPerVertex = dHeight / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    const h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  return heights;\n}\n\nconst carto1 = new Cartographic();\nconst carto2 = new Cartographic();\nconst cartesian = new Cartesian3();\nconst scaleFirst = new Cartesian3();\nconst scaleLast = new Cartesian3();\nconst ellipsoidGeodesic = new EllipsoidGeodesic();\nlet ellipsoidRhumb = new EllipsoidRhumbLine();\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianArc(\n  p0,\n  p1,\n  minDistance,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset\n) {\n  const first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n  const last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n  const numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  const start = ellipsoid.cartesianToCartographic(first, carto1);\n  const end = ellipsoid.cartesianToCartographic(last, carto2);\n  const heights = subdivideHeights(numPoints, h0, h1);\n\n  ellipsoidGeodesic.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints =\n    ellipsoidGeodesic.surfaceDistance / numPoints;\n\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianRhumbArc(\n  p0,\n  p1,\n  granularity,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset\n) {\n  const start = ellipsoid.cartesianToCartographic(p0, carto1);\n  const end = ellipsoid.cartesianToCartographic(p1, carto2);\n  const numPoints = PolylinePipeline.numberOfPointsRhumbLine(\n    start,\n    end,\n    granularity\n  );\n  start.height = 0.0;\n  end.height = 0.0;\n  const heights = subdivideHeights(numPoints, h0, h1);\n\n  if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n    ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  }\n  ellipsoidRhumb.setEndPoints(start, end);\n  const surfaceDistanceBetweenPoints =\n    ellipsoidRhumb.surfaceDistance / numPoints;\n\n  let index = offset;\n  start.height = h0;\n  let cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (let i = 1; i < numPoints; i++) {\n    const carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n/**\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n *\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\n * <code>segments</code> property.\n *\n *\n * @example\n * const polylines = new Cesium.PolylineCollection();\n * const polyline = polylines.add(...);\n * const positions = polyline.positions;\n * const modelMatrix = polylines.modelMatrix;\n * const segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n * @see PolygonPipeline.wrapLongitude\n * @see Polyline\n * @see PolylineCollection\n */\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\n  const cartesians = [];\n  const segments = [];\n\n  if (defined(positions) && positions.length > 0) {\n    modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n    const inverseModelMatrix = Matrix4.inverseTransformation(\n      modelMatrix,\n      wrapLongitudeInversMatrix\n    );\n\n    const origin = Matrix4.multiplyByPoint(\n      inverseModelMatrix,\n      Cartesian3.ZERO,\n      wrapLongitudeOrigin\n    );\n    const xzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_Y,\n        wrapLongitudeXZNormal\n      ),\n      wrapLongitudeXZNormal\n    );\n    const xzPlane = Plane.fromPointNormal(\n      origin,\n      xzNormal,\n      wrapLongitudeXZPlane\n    );\n    const yzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_X,\n        wrapLongitudeYZNormal\n      ),\n      wrapLongitudeYZNormal\n    );\n    const yzPlane = Plane.fromPointNormal(\n      origin,\n      yzNormal,\n      wrapLongitudeYZPlane\n    );\n\n    let count = 1;\n    cartesians.push(Cartesian3.clone(positions[0]));\n    let prev = cartesians[0];\n\n    const length = positions.length;\n    for (let i = 1; i < length; ++i) {\n      const cur = positions[i];\n\n      // intersects the IDL if either endpoint is on the negative side of the yz-plane\n      if (\n        Plane.getPointDistance(yzPlane, prev) < 0.0 ||\n        Plane.getPointDistance(yzPlane, cur) < 0.0\n      ) {\n        // and intersects the xz-plane\n        const intersection = IntersectionTests.lineSegmentPlane(\n          prev,\n          cur,\n          xzPlane,\n          wrapLongitudeIntersection\n        );\n        if (defined(intersection)) {\n          // move point on the xz-plane slightly away from the plane\n          const offset = Cartesian3.multiplyByScalar(\n            xzNormal,\n            5.0e-9,\n            wrapLongitudeOffset\n          );\n          if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n            Cartesian3.negate(offset, offset);\n          }\n\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3())\n          );\n          segments.push(count + 1);\n\n          Cartesian3.negate(offset, offset);\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3())\n          );\n          count = 1;\n        }\n      }\n\n      cartesians.push(Cartesian3.clone(positions[i]));\n      count++;\n\n      prev = cur;\n    }\n\n    segments.push(count);\n  }\n\n  return {\n    positions: cartesians,\n    lengths: segments,\n  };\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  let height = defaultValue(options.height, 0);\n  const hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  let minDistance = options.minDistance;\n  if (!defined(minDistance)) {\n    const granularity = defaultValue(\n      options.granularity,\n      CesiumMath.RADIANS_PER_DEGREE\n    );\n    minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  }\n\n  let numPoints = 0;\n  let i;\n\n  for (i = 0; i < length - 1; i++) {\n    numPoints += PolylinePipeline.numberOfPoints(\n      positions[i],\n      positions[i + 1],\n      minDistance\n    );\n  }\n\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianArc(\n      p0,\n      p1,\n      minDistance,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateRhumbArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  const positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const length = positions.length;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  let height = defaultValue(options.height, 0);\n  const hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    const p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      const n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n\n  let numPoints = 0;\n  let i;\n\n  let c0 = ellipsoid.cartesianToCartographic(\n    positions[0],\n    scratchCartographic0\n  );\n  let c1;\n  for (i = 0; i < length - 1; i++) {\n    c1 = ellipsoid.cartesianToCartographic(\n      positions[i + 1],\n      scratchCartographic1\n    );\n    numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n    c0 = Cartographic.clone(c1, scratchCartographic0);\n  }\n\n  const arrayLength = (numPoints + 1) * 3;\n  const newPositions = new Array(arrayLength);\n  let offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    const p0 = positions[i];\n    const p1 = positions[i + 1];\n\n    const h0 = hasHeightArray ? height[i] : height;\n    const h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianRhumbArc(\n      p0,\n      p1,\n      granularity,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  const lastPoint = positions[length - 1];\n  const carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  const cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianArc = function (options) {\n  const numberArray = PolylinePipeline.generateArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * const positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * const surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\n  const numberArray = PolylinePipeline.generateRhumbArc(options);\n  const size = numberArray.length / 3;\n  const newPositions = new Array(size);\n  for (let i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\nexport default PolylinePipeline;\n","import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport oneTimeWarning from \"./oneTimeWarning.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nfunction computeAttributes(\n  combinedPositions,\n  shape,\n  boundingRectangle,\n  vertexFormat\n) {\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: combinedPositions,\n    });\n  }\n  const shapeLength = shape.length;\n  const vertexCount = combinedPositions.length / 3;\n  const length = (vertexCount - shapeLength * 2) / (shapeLength * 2);\n  const firstEndIndices = PolygonPipeline.triangulate(shape);\n\n  const indicesCount =\n    (length - 1) * shapeLength * 6 + firstEndIndices.length * 2;\n  const indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);\n  let i, j;\n  let ll, ul, ur, lr;\n  const offset = shapeLength * 2;\n  let index = 0;\n  for (i = 0; i < length - 1; i++) {\n    for (j = 0; j < shapeLength - 1; j++) {\n      ll = j * 2 + i * shapeLength * 2;\n      lr = ll + offset;\n      ul = ll + 1;\n      ur = ul + offset;\n\n      indices[index++] = ul;\n      indices[index++] = ll;\n      indices[index++] = ur;\n      indices[index++] = ur;\n      indices[index++] = ll;\n      indices[index++] = lr;\n    }\n    ll = shapeLength * 2 - 2 + i * shapeLength * 2;\n    ul = ll + 1;\n    ur = ul + offset;\n    lr = ll + offset;\n\n    indices[index++] = ul;\n    indices[index++] = ll;\n    indices[index++] = ur;\n    indices[index++] = ur;\n    indices[index++] = ll;\n    indices[index++] = lr;\n  }\n\n  if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) {\n    // st required for tangent/bitangent calculation\n    const st = new Float32Array(vertexCount * 2);\n    const lengthSt = 1 / (length - 1);\n    const heightSt = 1 / boundingRectangle.height;\n    const heightOffset = boundingRectangle.height / 2;\n    let s, t;\n    let stindex = 0;\n    for (i = 0; i < length; i++) {\n      s = i * lengthSt;\n      t = heightSt * (shape[0].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n      for (j = 1; j < shapeLength; j++) {\n        t = heightSt * (shape[j].y + heightOffset);\n        st[stindex++] = s;\n        st[stindex++] = t;\n        st[stindex++] = s;\n        st[stindex++] = t;\n      }\n      t = heightSt * (shape[0].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n    for (j = 0; j < shapeLength; j++) {\n      s = 0;\n      t = heightSt * (shape[j].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n    for (j = 0; j < shapeLength; j++) {\n      s = (length - 1) * lengthSt;\n      t = heightSt * (shape[j].y + heightOffset);\n      st[stindex++] = s;\n      st[stindex++] = t;\n    }\n\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: new Float32Array(st),\n    });\n  }\n\n  const endOffset = vertexCount - shapeLength * 2;\n  for (i = 0; i < firstEndIndices.length; i += 3) {\n    const v0 = firstEndIndices[i] + endOffset;\n    const v1 = firstEndIndices[i + 1] + endOffset;\n    const v2 = firstEndIndices[i + 2] + endOffset;\n\n    indices[index++] = v0;\n    indices[index++] = v1;\n    indices[index++] = v2;\n    indices[index++] = v2 + shapeLength;\n    indices[index++] = v1 + shapeLength;\n    indices[index++] = v0 + shapeLength;\n  }\n\n  let geometry = new Geometry({\n    attributes: attributes,\n    indices: indices,\n    boundingSphere: BoundingSphere.fromVertices(combinedPositions),\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  if (vertexFormat.normal) {\n    geometry = GeometryPipeline.computeNormal(geometry);\n  }\n\n  if (vertexFormat.tangent || vertexFormat.bitangent) {\n    try {\n      geometry = GeometryPipeline.computeTangentAndBitangent(geometry);\n    } catch (e) {\n      oneTimeWarning(\n        \"polyline-volume-tangent-bitangent\",\n        \"Unable to compute tangents and bitangents for polyline volume geometry\"\n      );\n      //TODO https://github.com/CesiumGS/cesium/issues/3609\n    }\n\n    if (!vertexFormat.tangent) {\n      geometry.attributes.tangent = undefined;\n    }\n    if (!vertexFormat.bitangent) {\n      geometry.attributes.bitangent = undefined;\n    }\n    if (!vertexFormat.st) {\n      geometry.attributes.st = undefined;\n    }\n  }\n\n  return geometry;\n}\n\n/**\n * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n *\n * @alias PolylineVolumeGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesian3} positions that define the center of the polyline volume.\n * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see PolylineVolumeGeometry#createGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}\n *\n * @example\n * function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volume = new Cesium.PolylineVolumeGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });\n */\nfunction PolylineVolumeGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.polylinePositions;\n  const shape = options.shapePositions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.polylinePositions is required.\");\n  }\n  if (!defined(shape)) {\n    throw new DeveloperError(\"options.shapePositions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._shape = shape;\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\n  );\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._workerName = \"createPolylineVolumeGeometry\";\n\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineVolumeGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolylineVolumeGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const shape = value._shape;\n  length = shape.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    Cartesian2.pack(shape[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  polylinePositions: undefined,\n  shapePositions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  cornerType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineVolumeGeometry} [result] The object into which to store the result.\n * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.\n */\nPolylineVolumeGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  const shape = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    shape[i] = Cartesian2.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.polylinePositions = positions;\n    scratchOptions.shapePositions = shape;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    return new PolylineVolumeGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._shape = shape;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nconst brScratch = new BoundingRectangle();\n\n/**\n * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineVolumeGeometry.createGeometry = function (polylineVolumeGeometry) {\n  const positions = polylineVolumeGeometry._positions;\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n  let shape2D = polylineVolumeGeometry._shape;\n  shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n  if (cleanPositions.length < 2 || shape2D.length < 3) {\n    return undefined;\n  }\n\n  if (\n    PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE\n  ) {\n    shape2D.reverse();\n  }\n  const boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n  const computedPositions = PolylineVolumeGeometryLibrary.computePositions(\n    cleanPositions,\n    shape2D,\n    boundingRectangle,\n    polylineVolumeGeometry,\n    true\n  );\n  return computeAttributes(\n    computedPositions,\n    shape2D,\n    boundingRectangle,\n    polylineVolumeGeometry._vertexFormat\n  );\n};\nexport default PolylineVolumeGeometry;\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport CornerType from \"./CornerType.js\";\nimport EllipsoidTangentPlane from \"./EllipsoidTangentPlane.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Transforms from \"./Transforms.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\n\nconst scratch2Array = [new Cartesian3(), new Cartesian3()];\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst scratchCartesian5 = new Cartesian3();\nconst scratchCartesian6 = new Cartesian3();\nconst scratchCartesian7 = new Cartesian3();\nconst scratchCartesian8 = new Cartesian3();\nconst scratchCartesian9 = new Cartesian3();\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\n\n/**\n * @private\n */\nconst PolylineVolumeGeometryLibrary = {};\n\nlet cartographic = new Cartographic();\nfunction scaleToSurface(positions, ellipsoid) {\n  const heights = new Array(positions.length);\n  for (let i = 0; i < positions.length; i++) {\n    const pos = positions[i];\n    cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n    heights[i] = cartographic.height;\n    positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n  }\n  return heights;\n}\n\nfunction subdivideHeights(points, h0, h1, granularity) {\n  const p0 = points[0];\n  const p1 = points[1];\n  const angleBetween = Cartesian3.angleBetween(p0, p1);\n  const numPoints = Math.ceil(angleBetween / granularity);\n  const heights = new Array(numPoints);\n  let i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    heights.push(h1);\n    return heights;\n  }\n\n  const dHeight = h1 - h0;\n  const heightPerVertex = dHeight / numPoints;\n\n  for (i = 1; i < numPoints; i++) {\n    const h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  heights[0] = h0;\n  heights.push(h1);\n  return heights;\n}\n\nconst nextScratch = new Cartesian3();\nconst prevScratch = new Cartesian3();\n\nfunction computeRotationAngle(start, end, position, ellipsoid) {\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  const next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, start, nextScratch),\n    nextScratch\n  );\n  const prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, end, prevScratch),\n    prevScratch\n  );\n  const angle = Cartesian2.angleBetween(next, prev);\n\n  return prev.x * next.y - prev.y * next.x >= 0.0 ? -angle : angle;\n}\n\nconst negativeX = new Cartesian3(-1, 0, 0);\nlet transform = new Matrix4();\nconst translation = new Matrix4();\nlet rotationZ = new Matrix3();\nconst scaleMatrix = Matrix3.IDENTITY.clone();\nconst westScratch = new Cartesian3();\nconst finalPosScratch = new Cartesian4();\nconst heightCartesian = new Cartesian3();\nfunction addPosition(\n  center,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  height,\n  xScalar,\n  repeat\n) {\n  let west = westScratch;\n  let finalPosition = finalPosScratch;\n  transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n\n  west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n  west = Cartesian3.normalize(west, west);\n  const angle = computeRotationAngle(west, left, center, ellipsoid);\n  rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n\n  heightCartesian.z = height;\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation),\n    transform\n  );\n  const scale = scaleMatrix;\n  scale[0] = xScalar;\n\n  for (let j = 0; j < repeat; j++) {\n    for (let i = 0; i < shape.length; i += 3) {\n      finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n      finalPosition = Matrix3.multiplyByVector(\n        scale,\n        finalPosition,\n        finalPosition\n      );\n      finalPosition = Matrix4.multiplyByPoint(\n        transform,\n        finalPosition,\n        finalPosition\n      );\n      finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n    }\n  }\n\n  return finalPositions;\n}\n\nconst centerScratch = new Cartesian3();\nfunction addPositions(\n  centers,\n  left,\n  shape,\n  finalPositions,\n  ellipsoid,\n  heights,\n  xScalar\n) {\n  for (let i = 0; i < centers.length; i += 3) {\n    const center = Cartesian3.fromArray(centers, i, centerScratch);\n    finalPositions = addPosition(\n      center,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      heights[i / 3],\n      xScalar,\n      1\n    );\n  }\n  return finalPositions;\n}\n\nfunction convertShapeTo3DDuplicate(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n  const length = shape2D.length;\n  const shape = new Array(length * 6);\n  let index = 0;\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  let point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n  for (let i = 1; i < length; i++) {\n    point = shape2D[i];\n    const x = point.x - xOffset;\n    const z = point.y - yOffset;\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n\n    shape[index++] = x;\n    shape[index++] = 0.0;\n    shape[index++] = z;\n  }\n  point = shape2D[0];\n  shape[index++] = point.x - xOffset;\n  shape[index++] = 0.0;\n  shape[index++] = point.y - yOffset;\n\n  return shape;\n}\n\nfunction convertShapeTo3D(shape2D, boundingRectangle) {\n  //orientate 2D shape to XZ plane center at (0, 0, 0)\n  const length = shape2D.length;\n  const shape = new Array(length * 3);\n  let index = 0;\n  const xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n  const yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n  for (let i = 0; i < length; i++) {\n    shape[index++] = shape2D[i].x - xOffset;\n    shape[index++] = 0;\n    shape[index++] = shape2D[i].y - yOffset;\n  }\n\n  return shape;\n}\n\nconst quaterion = new Quaternion();\nconst startPointScratch = new Cartesian3();\nconst rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  pivot,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside,\n  ellipsoid,\n  finalPositions,\n  shape,\n  height,\n  duplicatePoints\n) {\n  const angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, pivot, scratch1),\n    Cartesian3.subtract(endPoint, pivot, scratch2)\n  );\n  const granularity =\n    cornerType === CornerType.BEVELED\n      ? 0\n      : Math.ceil(angle / CesiumMath.toRadians(5));\n\n  let m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(pivot, scratch1),\n        angle / (granularity + 1),\n        quaterion\n      ),\n      rotMatrix\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion),\n      rotMatrix\n    );\n  }\n\n  let left;\n  let surfacePoint;\n  startPoint = Cartesian3.clone(startPoint, startPointScratch);\n  if (granularity > 0) {\n    const repeat = duplicatePoints ? 2 : 1;\n    for (let i = 0; i < granularity; i++) {\n      startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n      left = Cartesian3.subtract(startPoint, pivot, scratch1);\n      left = Cartesian3.normalize(left, left);\n      if (!leftIsOutside) {\n        left = Cartesian3.negate(left, left);\n      }\n      surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n      finalPositions = addPosition(\n        surfacePoint,\n        left,\n        shape,\n        finalPositions,\n        ellipsoid,\n        height,\n        1,\n        repeat\n      );\n    }\n  } else {\n    left = Cartesian3.subtract(startPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1\n    );\n\n    endPoint = Cartesian3.clone(endPoint, startPointScratch);\n    left = Cartesian3.subtract(endPoint, pivot, scratch1);\n    left = Cartesian3.normalize(left, left);\n    if (!leftIsOutside) {\n      left = Cartesian3.negate(left, left);\n    }\n    surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n    finalPositions = addPosition(\n      surfacePoint,\n      left,\n      shape,\n      finalPositions,\n      ellipsoid,\n      height,\n      1,\n      1\n    );\n  }\n\n  return finalPositions;\n}\n\nPolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function (\n  shapePositions\n) {\n  const length = shapePositions.length;\n  const cleanedPositions = [];\n  for (let i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n    const v0 = shapePositions[i0];\n    const v1 = shapePositions[i1];\n\n    if (!Cartesian2.equals(v0, v1)) {\n      cleanedPositions.push(v1); // Shallow copy!\n    }\n  }\n\n  return cleanedPositions;\n};\n\nPolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function (\n  forward,\n  backward,\n  position,\n  ellipsoid\n) {\n  const tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n  const next = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, forward, nextScratch),\n    nextScratch\n  );\n  const prev = tangentPlane.projectPointOntoPlane(\n    Cartesian3.add(position, backward, prevScratch),\n    prevScratch\n  );\n\n  return prev.x * next.y - prev.y * next.x >= 0.0;\n};\n\nconst scratchForwardProjection = new Cartesian3();\nconst scratchBackwardProjection = new Cartesian3();\n\nPolylineVolumeGeometryLibrary.computePositions = function (\n  positions,\n  shape2D,\n  boundingRectangle,\n  geometry,\n  duplicatePoints\n) {\n  const ellipsoid = geometry._ellipsoid;\n  const heights = scaleToSurface(positions, ellipsoid);\n  const granularity = geometry._granularity;\n  const cornerType = geometry._cornerType;\n  const shapeForSides = duplicatePoints\n    ? convertShapeTo3DDuplicate(shape2D, boundingRectangle)\n    : convertShapeTo3D(shape2D, boundingRectangle);\n  const shapeForEnds = duplicatePoints\n    ? convertShapeTo3D(shape2D, boundingRectangle)\n    : undefined;\n  const heightOffset = boundingRectangle.height / 2;\n  const width = boundingRectangle.width / 2;\n  let length = positions.length;\n  let finalPositions = [];\n  let ends = duplicatePoints ? [] : undefined;\n\n  let forward = scratchCartesian1;\n  let backward = scratchCartesian2;\n  let cornerDirection = scratchCartesian3;\n  let surfaceNormal = scratchCartesian4;\n  let pivot = scratchCartesian5;\n  let start = scratchCartesian6;\n  let end = scratchCartesian7;\n  let left = scratchCartesian8;\n  let previousPosition = scratchCartesian9;\n\n  let position = positions[0];\n  let nextPosition = positions[1];\n  surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n  forward = Cartesian3.subtract(nextPosition, position, forward);\n  forward = Cartesian3.normalize(forward, forward);\n  left = Cartesian3.cross(surfaceNormal, forward, left);\n  left = Cartesian3.normalize(left, left);\n  let h0 = heights[0];\n  let h1 = heights[1];\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h0 + heightOffset,\n      1,\n      1\n    );\n  }\n  previousPosition = Cartesian3.clone(position, previousPosition);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n  let subdividedHeights;\n  let subdividedPositions;\n  for (let i = 1; i < length - 1; i++) {\n    const repeat = duplicatePoints ? 2 : 1;\n    nextPosition = positions[i + 1];\n    if (position.equals(nextPosition)) {\n      oneTimeWarning(\n        \"Positions are too close and are considered equivalent with rounding error.\"\n      );\n      continue;\n    }\n    forward = Cartesian3.subtract(nextPosition, position, forward);\n    forward = Cartesian3.normalize(forward, forward);\n    cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n    cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n    surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n\n    const forwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(forward, surfaceNormal),\n      scratchForwardProjection\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    const backwardProjection = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Cartesian3.dot(backward, surfaceNormal),\n      scratchBackwardProjection\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    const doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        surfaceNormal,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.cross(\n        surfaceNormal,\n        cornerDirection,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      const scalar =\n        1 /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1)\n          )\n        );\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid\n      );\n      if (leftIsOutside) {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection\n          ),\n          pivot\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, start),\n          start\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, width, end),\n          end\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints\n          );\n        } else {\n          cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      } else {\n        pivot = Cartesian3.add(\n          position,\n          Cartesian3.multiplyByScalar(\n            cornerDirection,\n            scalar * width,\n            cornerDirection\n          ),\n          pivot\n        );\n        start = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, start),\n          start\n        );\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(\n          scratch2Array,\n          h0 + heightOffset,\n          h1 + heightOffset,\n          granularity\n        );\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scratch2Array,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        finalPositions = addPositions(\n          subdividedPositions,\n          left,\n          shapeForSides,\n          finalPositions,\n          ellipsoid,\n          subdividedHeights,\n          1\n        );\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        end = Cartesian3.add(\n          pivot,\n          Cartesian3.multiplyByScalar(left, -width, end),\n          end\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          computeRoundCorner(\n            pivot,\n            start,\n            end,\n            cornerType,\n            leftIsOutside,\n            ellipsoid,\n            finalPositions,\n            shapeForSides,\n            h1 + heightOffset,\n            duplicatePoints\n          );\n        } else {\n          finalPositions = addPosition(\n            position,\n            cornerDirection,\n            shapeForSides,\n            finalPositions,\n            ellipsoid,\n            h1 + heightOffset,\n            scalar,\n            repeat\n          );\n        }\n        previousPosition = Cartesian3.clone(end, previousPosition);\n      }\n      backward = Cartesian3.negate(forward, backward);\n    } else {\n      finalPositions = addPosition(\n        previousPosition,\n        left,\n        shapeForSides,\n        finalPositions,\n        ellipsoid,\n        h0 + heightOffset,\n        1,\n        1\n      );\n      previousPosition = position;\n    }\n    h0 = h1;\n    h1 = heights[i + 1];\n    position = nextPosition;\n  }\n\n  scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n  scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n  subdividedHeights = subdivideHeights(\n    scratch2Array,\n    h0 + heightOffset,\n    h1 + heightOffset,\n    granularity\n  );\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scratch2Array,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  finalPositions = addPositions(\n    subdividedPositions,\n    left,\n    shapeForSides,\n    finalPositions,\n    ellipsoid,\n    subdividedHeights,\n    1\n  );\n  if (duplicatePoints) {\n    ends = addPosition(\n      position,\n      left,\n      shapeForEnds,\n      ends,\n      ellipsoid,\n      h1 + heightOffset,\n      1,\n      1\n    );\n  }\n\n  length = finalPositions.length;\n  const posLength = duplicatePoints ? length + ends.length : length;\n  const combinedPositions = new Float64Array(posLength);\n  combinedPositions.set(finalPositions);\n  if (duplicatePoints) {\n    combinedPositions.set(ends, length);\n  }\n\n  return combinedPositions;\n};\nexport default PolylineVolumeGeometryLibrary;\n","import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingRectangle from \"./BoundingRectangle.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\nfunction computeAttributes(positions, shape) {\n  const attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  const shapeLength = shape.length;\n  const vertexCount = attributes.position.values.length / 3;\n  const positionLength = positions.length / 3;\n  const shapeCount = positionLength / shapeLength;\n  const indices = IndexDatatype.createTypedArray(\n    vertexCount,\n    2 * shapeLength * (shapeCount + 1)\n  );\n  let i, j;\n  let index = 0;\n  i = 0;\n  let offset = i * shapeLength;\n  for (j = 0; j < shapeLength - 1; j++) {\n    indices[index++] = j + offset;\n    indices[index++] = j + offset + 1;\n  }\n  indices[index++] = shapeLength - 1 + offset;\n  indices[index++] = offset;\n\n  i = shapeCount - 1;\n  offset = i * shapeLength;\n  for (j = 0; j < shapeLength - 1; j++) {\n    indices[index++] = j + offset;\n    indices[index++] = j + offset + 1;\n  }\n  indices[index++] = shapeLength - 1 + offset;\n  indices[index++] = offset;\n\n  for (i = 0; i < shapeCount - 1; i++) {\n    const firstOffset = shapeLength * i;\n    const secondOffset = firstOffset + shapeLength;\n    for (j = 0; j < shapeLength; j++) {\n      indices[index++] = j + firstOffset;\n      indices[index++] = j + secondOffset;\n    }\n  }\n\n  const geometry = new Geometry({\n    attributes: attributes,\n    indices: IndexDatatype.createTypedArray(vertexCount, indices),\n    boundingSphere: BoundingSphere.fromVertices(positions),\n    primitiveType: PrimitiveType.LINES,\n  });\n\n  return geometry;\n}\n\n/**\n * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n *\n * @alias PolylineVolumeOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.polylinePositions An array of positions that define the center of the polyline volume.\n * @param {Cartesian2[]} options.shapePositions An array of positions that define the shape to be extruded along the polyline\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see PolylineVolumeOutlineGeometry#createGeometry\n *\n * @example\n * function computeCircle(radius) {\n *   const positions = [];\n *   for (let i = 0; i < 360; i++) {\n *     const radians = Cesium.Math.toRadians(i);\n *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n *   }\n *   return positions;\n * }\n *\n * const volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({\n *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n *     -72.0, 40.0,\n *     -70.0, 35.0\n *   ]),\n *   shapePositions : computeCircle(100000.0)\n * });\n */\nfunction PolylineVolumeOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.polylinePositions;\n  const shape = options.shapePositions;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.polylinePositions is required.\");\n  }\n  if (!defined(shape)) {\n    throw new DeveloperError(\"options.shapePositions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._positions = positions;\n  this._shape = shape;\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._workerName = \"createPolylineVolumeOutlineGeometry\";\n\n  let numComponents = 1 + positions.length * Cartesian3.packedLength;\n  numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength = numComponents + Ellipsoid.packedLength + 2;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {PolylineVolumeOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nPolylineVolumeOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  const positions = value._positions;\n  let length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  const shape = value._shape;\n  length = shape.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    Cartesian2.pack(shape[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  polylinePositions: undefined,\n  shapePositions: undefined,\n  ellipsoid: scratchEllipsoid,\n  height: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {PolylineVolumeOutlineGeometry} [result] The object into which to store the result.\n * @returns {PolylineVolumeOutlineGeometry} The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.\n */\nPolylineVolumeOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  let i;\n\n  let length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  const shape = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n    shape[i] = Cartesian2.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.polylinePositions = positions;\n    scratchOptions.shapePositions = shape;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    return new PolylineVolumeOutlineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._shape = shape;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nconst brScratch = new BoundingRectangle();\n\n/**\n * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n *\n * @param {PolylineVolumeOutlineGeometry} polylineVolumeOutlineGeometry A description of the polyline volume outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nPolylineVolumeOutlineGeometry.createGeometry = function (\n  polylineVolumeOutlineGeometry\n) {\n  const positions = polylineVolumeOutlineGeometry._positions;\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n  let shape2D = polylineVolumeOutlineGeometry._shape;\n  shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n  if (cleanPositions.length < 2 || shape2D.length < 3) {\n    return undefined;\n  }\n\n  if (\n    PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE\n  ) {\n    shape2D.reverse();\n  }\n  const boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n  const computedPositions = PolylineVolumeGeometryLibrary.computePositions(\n    cleanPositions,\n    shape2D,\n    boundingRectangle,\n    polylineVolumeOutlineGeometry,\n    false\n  );\n  return computeAttributes(computedPositions, shape2D);\n};\nexport default PolylineVolumeOutlineGeometry;\n","import WebGLConstants from \"./WebGLConstants.js\";\n\n/**\n * The type of a geometric primitive, i.e., points, lines, and triangles.\n *\n * @enum {Number}\n */\nconst PrimitiveType = {\n  /**\n   * Points primitive where each vertex (or index) is a separate point.\n   *\n   * @type {Number}\n   * @constant\n   */\n  POINTS: WebGLConstants.POINTS,\n\n  /**\n   * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LINES: WebGLConstants.LINES,\n\n  /**\n   * Line loop primitive where each vertex (or index) after the first connects a line to\n   * the previous vertex, and the last vertex implicitly connects to the first.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LINE_LOOP: WebGLConstants.LINE_LOOP,\n\n  /**\n   * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LINE_STRIP: WebGLConstants.LINE_STRIP,\n\n  /**\n   * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.\n   *\n   * @type {Number}\n   * @constant\n   */\n  TRIANGLES: WebGLConstants.TRIANGLES,\n\n  /**\n   * Triangle strip primitive where each vertex (or index) after the first two connect to\n   * the previous two vertices forming a triangle.  For example, this can be used to model a wall.\n   *\n   * @type {Number}\n   * @constant\n   */\n  TRIANGLE_STRIP: WebGLConstants.TRIANGLE_STRIP,\n\n  /**\n   * Triangle fan primitive where each vertex (or index) after the first two connect to\n   * the previous vertex and the first vertex forming a triangle.  For example, this can be used\n   * to model a cone or circle.\n   *\n   * @type {Number}\n   * @constant\n   */\n  TRIANGLE_FAN: WebGLConstants.TRIANGLE_FAN,\n};\n\n/**\n * @private\n */\nPrimitiveType.isLines = function (primitiveType) {\n  return (\n    primitiveType === PrimitiveType.LINES ||\n    primitiveType === PrimitiveType.LINE_LOOP ||\n    primitiveType === PrimitiveType.LINE_STRIP\n  );\n};\n\n/**\n * @private\n */\nPrimitiveType.isTriangles = function (primitiveType) {\n  return (\n    primitiveType === PrimitiveType.TRIANGLES ||\n    primitiveType === PrimitiveType.TRIANGLE_STRIP ||\n    primitiveType === PrimitiveType.TRIANGLE_FAN\n  );\n};\n\n/**\n * @private\n */\nPrimitiveType.validate = function (primitiveType) {\n  return (\n    primitiveType === PrimitiveType.POINTS ||\n    primitiveType === PrimitiveType.LINES ||\n    primitiveType === PrimitiveType.LINE_LOOP ||\n    primitiveType === PrimitiveType.LINE_STRIP ||\n    primitiveType === PrimitiveType.TRIANGLES ||\n    primitiveType === PrimitiveType.TRIANGLE_STRIP ||\n    primitiveType === PrimitiveType.TRIANGLE_FAN\n  );\n};\n\nexport default Object.freeze(PrimitiveType);\n","import DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Base class for proxying requested made by {@link Resource}.\n *\n * @alias Proxy\n * @constructor\n *\n * @see DefaultProxy\n */\nfunction Proxy() {\n  DeveloperError.throwInstantiationError();\n}\n\n/**\n * Get the final URL to use to request a given resource.\n *\n * @param {String} resource The resource to request.\n * @returns {String} proxied resource\n * @function\n */\nProxy.prototype.getURL = DeveloperError.throwInstantiationError;\n\nexport default Proxy;\n","import DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.\n *\n * @namespace QuadraticRealPolynomial\n */\nconst QuadraticRealPolynomial = {};\n\n/**\n * Provides the discriminant of the quadratic equation from the supplied coefficients.\n *\n * @param {Number} a The coefficient of the 2nd order monomial.\n * @param {Number} b The coefficient of the 1st order monomial.\n * @param {Number} c The coefficient of the 0th order monomial.\n * @returns {Number} The value of the discriminant.\n */\nQuadraticRealPolynomial.computeDiscriminant = function (a, b, c) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  const discriminant = b * b - 4.0 * a * c;\n  return discriminant;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  const difference = left + right;\n  if (\n    CesiumMath.sign(left) !== CesiumMath.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\n/**\n * Provides the real valued roots of the quadratic polynomial with the provided coefficients.\n *\n * @param {Number} a The coefficient of the 2nd order monomial.\n * @param {Number} b The coefficient of the 1st order monomial.\n * @param {Number} c The coefficient of the 0th order monomial.\n * @returns {Number[]} The real valued roots.\n */\nQuadraticRealPolynomial.computeRealRoots = function (a, b, c) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  let ratio;\n  if (a === 0.0) {\n    if (b === 0.0) {\n      // Constant function: c = 0.\n      return [];\n    }\n\n    // Linear function: b * x + c = 0.\n    return [-c / b];\n  } else if (b === 0.0) {\n    if (c === 0.0) {\n      // 2nd order monomial: a * x^2 = 0.\n      return [0.0, 0.0];\n    }\n\n    const cMagnitude = Math.abs(c);\n    const aMagnitude = Math.abs(a);\n\n    if (\n      cMagnitude < aMagnitude &&\n      cMagnitude / aMagnitude < CesiumMath.EPSILON14\n    ) {\n      // c ~= 0.0.\n      // 2nd order monomial: a * x^2 = 0.\n      return [0.0, 0.0];\n    } else if (\n      cMagnitude > aMagnitude &&\n      aMagnitude / cMagnitude < CesiumMath.EPSILON14\n    ) {\n      // a ~= 0.0.\n      // Constant function: c = 0.\n      return [];\n    }\n\n    // a * x^2 + c = 0\n    ratio = -c / a;\n\n    if (ratio < 0.0) {\n      // Both roots are complex.\n      return [];\n    }\n\n    // Both roots are real.\n    const root = Math.sqrt(ratio);\n    return [-root, root];\n  } else if (c === 0.0) {\n    // a * x^2 + b * x = 0\n    ratio = -b / a;\n    if (ratio < 0.0) {\n      return [ratio, 0.0];\n    }\n\n    return [0.0, ratio];\n  }\n\n  // a * x^2 + b * x + c = 0\n  const b2 = b * b;\n  const four_ac = 4.0 * a * c;\n  const radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);\n\n  if (radicand < 0.0) {\n    // Both roots are complex.\n    return [];\n  }\n\n  const q =\n    -0.5 *\n    addWithCancellationCheck(\n      b,\n      CesiumMath.sign(b) * Math.sqrt(radicand),\n      CesiumMath.EPSILON14\n    );\n  if (b > 0.0) {\n    return [q / a, c / q];\n  }\n\n  return [c / q, q / a];\n};\nexport default QuadraticRealPolynomial;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized\n * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed\n * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner\n * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile\n * and 32767 at the maximum height in the tile.\n *\n * @alias QuantizedMeshTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Uint16Array} options.quantizedVertices The buffer containing the quantized mesh.\n * @param {Uint16Array|Uint32Array} options.indices The indices specifying how the quantized vertices are linked\n *                      together into triangles.  Each three indices specifies one triangle.\n * @param {Number} options.minimumHeight The minimum terrain height within the tile, in meters above the ellipsoid.\n * @param {Number} options.maximumHeight The maximum terrain height within the tile, in meters above the ellipsoid.\n * @param {BoundingSphere} options.boundingSphere A sphere bounding all of the vertices in the mesh.\n * @param {OrientedBoundingBox} [options.orientedBoundingBox] An OrientedBoundingBox bounding all of the vertices in the mesh.\n * @param {Cartesian3} options.horizonOcclusionPoint The horizon occlusion point of the mesh.  If this point\n *                      is below the horizon, the entire tile is assumed to be below the horizon as well.\n *                      The point is expressed in ellipsoid-scaled coordinates.\n * @param {Number[]} options.westIndices The indices of the vertices on the western edge of the tile.\n * @param {Number[]} options.southIndices The indices of the vertices on the southern edge of the tile.\n * @param {Number[]} options.eastIndices The indices of the vertices on the eastern edge of the tile.\n * @param {Number[]} options.northIndices The indices of the vertices on the northern edge of the tile.\n * @param {Number} options.westSkirtHeight The height of the skirt to add on the western edge of the tile.\n * @param {Number} options.southSkirtHeight The height of the skirt to add on the southern edge of the tile.\n * @param {Number} options.eastSkirtHeight The height of the skirt to add on the eastern edge of the tile.\n * @param {Number} options.northSkirtHeight The height of the skirt to add on the northern edge of the tile.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Uint8Array} [options.encodedNormals] The buffer containing per vertex normals, encoded using 'oct' encoding\n * @param {Uint8Array} [options.waterMask] The buffer containing the watermask.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * const data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction QuantizedMeshTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!defined(options) || !defined(options.quantizedVertices)) {\n    throw new DeveloperError(\"options.quantizedVertices is required.\");\n  }\n  if (!defined(options.indices)) {\n    throw new DeveloperError(\"options.indices is required.\");\n  }\n  if (!defined(options.minimumHeight)) {\n    throw new DeveloperError(\"options.minimumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.boundingSphere)) {\n    throw new DeveloperError(\"options.boundingSphere is required.\");\n  }\n  if (!defined(options.horizonOcclusionPoint)) {\n    throw new DeveloperError(\"options.horizonOcclusionPoint is required.\");\n  }\n  if (!defined(options.westIndices)) {\n    throw new DeveloperError(\"options.westIndices is required.\");\n  }\n  if (!defined(options.southIndices)) {\n    throw new DeveloperError(\"options.southIndices is required.\");\n  }\n  if (!defined(options.eastIndices)) {\n    throw new DeveloperError(\"options.eastIndices is required.\");\n  }\n  if (!defined(options.northIndices)) {\n    throw new DeveloperError(\"options.northIndices is required.\");\n  }\n  if (!defined(options.westSkirtHeight)) {\n    throw new DeveloperError(\"options.westSkirtHeight is required.\");\n  }\n  if (!defined(options.southSkirtHeight)) {\n    throw new DeveloperError(\"options.southSkirtHeight is required.\");\n  }\n  if (!defined(options.eastSkirtHeight)) {\n    throw new DeveloperError(\"options.eastSkirtHeight is required.\");\n  }\n  if (!defined(options.northSkirtHeight)) {\n    throw new DeveloperError(\"options.northSkirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._quantizedVertices = options.quantizedVertices;\n  this._encodedNormals = options.encodedNormals;\n  this._indices = options.indices;\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._boundingSphere = options.boundingSphere;\n  this._orientedBoundingBox = options.orientedBoundingBox;\n  this._horizonOcclusionPoint = options.horizonOcclusionPoint;\n  this._credits = options.credits;\n\n  const vertexCount = this._quantizedVertices.length / 3;\n  const uValues = (this._uValues = this._quantizedVertices.subarray(\n    0,\n    vertexCount\n  ));\n  const vValues = (this._vValues = this._quantizedVertices.subarray(\n    vertexCount,\n    2 * vertexCount\n  ));\n  this._heightValues = this._quantizedVertices.subarray(\n    2 * vertexCount,\n    3 * vertexCount\n  );\n\n  // We don't assume that we can count on the edge vertices being sorted by u or v.\n  function sortByV(a, b) {\n    return vValues[a] - vValues[b];\n  }\n\n  function sortByU(a, b) {\n    return uValues[a] - uValues[b];\n  }\n\n  this._westIndices = sortIndicesIfNecessary(\n    options.westIndices,\n    sortByV,\n    vertexCount\n  );\n  this._southIndices = sortIndicesIfNecessary(\n    options.southIndices,\n    sortByU,\n    vertexCount\n  );\n  this._eastIndices = sortIndicesIfNecessary(\n    options.eastIndices,\n    sortByV,\n    vertexCount\n  );\n  this._northIndices = sortIndicesIfNecessary(\n    options.northIndices,\n    sortByU,\n    vertexCount\n  );\n\n  this._westSkirtHeight = options.westSkirtHeight;\n  this._southSkirtHeight = options.southSkirtHeight;\n  this._eastSkirtHeight = options.eastSkirtHeight;\n  this._northSkirtHeight = options.northSkirtHeight;\n\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n\n  this._mesh = undefined;\n}\n\nObject.defineProperties(QuantizedMeshTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n\n  canUpsample: {\n    get: function () {\n      return defined(this._mesh);\n    },\n  },\n});\n\nconst arrayScratch = [];\n\nfunction sortIndicesIfNecessary(indices, sortFunction, vertexCount) {\n  arrayScratch.length = indices.length;\n\n  let needsSort = false;\n  for (let i = 0, len = indices.length; i < len; ++i) {\n    arrayScratch[i] = indices[i];\n    needsSort =\n      needsSort || (i > 0 && sortFunction(indices[i - 1], indices[i]) > 0);\n  }\n\n  if (needsSort) {\n    arrayScratch.sort(sortFunction);\n    return IndexDatatype.createTypedArray(vertexCount, arrayScratch);\n  }\n  return indices;\n}\n\nconst createMeshTaskName = \"createVerticesFromQuantizedTerrainMesh\";\nconst createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nconst createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nQuantizedMeshTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  const tilingScheme = options.tilingScheme;\n  const x = options.x;\n  const y = options.y;\n  const level = options.level;\n  const exaggeration = defaultValue(options.exaggeration, 1.0);\n  const exaggerationRelativeHeight = defaultValue(\n    options.exaggerationRelativeHeight,\n    0.0\n  );\n  const throttle = defaultValue(options.throttle, true);\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  const createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  const verticesPromise = createMeshTaskProcessor.scheduleTask({\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    quantizedVertices: this._quantizedVertices,\n    octEncodedNormals: this._encodedNormals,\n    includeWebMercatorT: true,\n    indices: this._indices,\n    westIndices: this._westIndices,\n    southIndices: this._southIndices,\n    eastIndices: this._eastIndices,\n    northIndices: this._northIndices,\n    westSkirtHeight: this._westSkirtHeight,\n    southSkirtHeight: this._southSkirtHeight,\n    eastSkirtHeight: this._eastSkirtHeight,\n    northSkirtHeight: this._northSkirtHeight,\n    rectangle: rectangle,\n    relativeToCenter: this._boundingSphere.center,\n    ellipsoid: ellipsoid,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  const that = this;\n  return Promise.resolve(verticesPromise).then(function (result) {\n    const vertexCountWithoutSkirts = that._quantizedVertices.length / 3;\n    const vertexCount =\n      vertexCountWithoutSkirts +\n      that._westIndices.length +\n      that._southIndices.length +\n      that._eastIndices.length +\n      that._northIndices.length;\n    const indicesTypedArray = IndexDatatype.createTypedArray(\n      vertexCount,\n      result.indices\n    );\n\n    const vertices = new Float32Array(result.vertices);\n    const rtc = result.center;\n    const minimumHeight = result.minimumHeight;\n    const maximumHeight = result.maximumHeight;\n    const boundingSphere = that._boundingSphere;\n    const obb = that._orientedBoundingBox;\n    const occludeePointInScaledSpace = defaultValue(\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      that._horizonOcclusionPoint\n    );\n    const stride = result.vertexStride;\n    const terrainEncoding = TerrainEncoding.clone(result.encoding);\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      rtc,\n      vertices,\n      indicesTypedArray,\n      result.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      minimumHeight,\n      maximumHeight,\n      boundingSphere,\n      occludeePointInScaledSpace,\n      stride,\n      obb,\n      terrainEncoding,\n      result.westIndicesSouthToNorth,\n      result.southIndicesEastToWest,\n      result.eastIndicesNorthToSouth,\n      result.northIndicesWestToEast\n    );\n\n    // Free memory received from server after mesh is created.\n    that._quantizedVertices = undefined;\n    that._encodedNormals = undefined;\n    that._indices = undefined;\n\n    that._uValues = undefined;\n    that._vValues = undefined;\n    that._heightValues = undefined;\n\n    that._westIndices = undefined;\n    that._southIndices = undefined;\n    that._eastIndices = undefined;\n    that._northIndices = undefined;\n\n    return that._mesh;\n  });\n};\n\nconst upsampleTaskProcessor = new TaskProcessor(\n  \"upsampleQuantizedTerrainMesh\",\n  TerrainData.maximumAsynchronousTasks\n);\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * vertices in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<QuantizedMeshTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nQuantizedMeshTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  const levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  const isEastChild = thisX * 2 !== descendantX;\n  const isNorthChild = thisY * 2 === descendantY;\n\n  const ellipsoid = tilingScheme.ellipsoid;\n  const childRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  const upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  let shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);\n\n  const westSkirtHeight = isEastChild\n    ? shortestSkirt * 0.5\n    : this._westSkirtHeight;\n  const southSkirtHeight = isNorthChild\n    ? shortestSkirt * 0.5\n    : this._southSkirtHeight;\n  const eastSkirtHeight = isEastChild\n    ? this._eastSkirtHeight\n    : shortestSkirt * 0.5;\n  const northSkirtHeight = isNorthChild\n    ? this._northSkirtHeight\n    : shortestSkirt * 0.5;\n  const credits = this._credits;\n\n  return Promise.resolve(upsamplePromise).then(function (result) {\n    const quantizedVertices = new Uint16Array(result.vertices);\n    const indicesTypedArray = IndexDatatype.createTypedArray(\n      quantizedVertices.length / 3,\n      result.indices\n    );\n    let encodedNormals;\n    if (defined(result.encodedNormals)) {\n      encodedNormals = new Uint8Array(result.encodedNormals);\n    }\n\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      encodedNormals: encodedNormals,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(\n        result.orientedBoundingBox\n      ),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: westSkirtHeight,\n      southSkirtHeight: southSkirtHeight,\n      eastSkirtHeight: eastSkirtHeight,\n      northSkirtHeight: northSkirtHeight,\n      childTileMask: 0,\n      credits: credits,\n      createdByUpsampling: true,\n    });\n  });\n};\n\nconst maxShort = 32767;\nconst barycentricCoordinateScratch = new Cartesian3();\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  The position is clamped to\n *          the rectangle, so expect incorrect results for positions far outside the rectangle.\n */\nQuantizedMeshTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  let u = CesiumMath.clamp(\n    (longitude - rectangle.west) / rectangle.width,\n    0.0,\n    1.0\n  );\n  u *= maxShort;\n  let v = CesiumMath.clamp(\n    (latitude - rectangle.south) / rectangle.height,\n    0.0,\n    1.0\n  );\n  v *= maxShort;\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nfunction pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2) {\n  const minU = Math.min(u0, u1, u2);\n  const maxU = Math.max(u0, u1, u2);\n  const minV = Math.min(v0, v1, v2);\n  const maxV = Math.max(v0, v1, v2);\n  return u >= minU && u <= maxU && v >= minV && v <= maxV;\n}\n\nconst texCoordScratch0 = new Cartesian2();\nconst texCoordScratch1 = new Cartesian2();\nconst texCoordScratch2 = new Cartesian2();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  const mesh = terrainData._mesh;\n  const vertices = mesh.vertices;\n  const encoding = mesh.encoding;\n  const indices = mesh.indices;\n\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const uv0 = encoding.decodeTextureCoordinates(\n      vertices,\n      i0,\n      texCoordScratch0\n    );\n    const uv1 = encoding.decodeTextureCoordinates(\n      vertices,\n      i1,\n      texCoordScratch1\n    );\n    const uv2 = encoding.decodeTextureCoordinates(\n      vertices,\n      i2,\n      texCoordScratch2\n    );\n\n    if (pointInBoundingBox(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y)) {\n      const barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        uv0.x,\n        uv0.y,\n        uv1.x,\n        uv1.y,\n        uv2.x,\n        uv2.y,\n        barycentricCoordinateScratch\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        const h0 = encoding.decodeHeight(vertices, i0);\n        const h1 = encoding.decodeHeight(vertices, i1);\n        const h2 = encoding.decodeHeight(vertices, i2);\n        return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\nfunction interpolateHeight(terrainData, u, v) {\n  const uBuffer = terrainData._uValues;\n  const vBuffer = terrainData._vValues;\n  const heightBuffer = terrainData._heightValues;\n\n  const indices = terrainData._indices;\n  for (let i = 0, len = indices.length; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const u0 = uBuffer[i0];\n    const u1 = uBuffer[i1];\n    const u2 = uBuffer[i2];\n\n    const v0 = vBuffer[i0];\n    const v1 = vBuffer[i1];\n    const v2 = vBuffer[i2];\n\n    if (pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2)) {\n      const barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        u0,\n        v0,\n        u1,\n        v1,\n        u2,\n        v2,\n        barycentricCoordinateScratch\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        const quantizedHeight =\n          barycentric.x * heightBuffer[i0] +\n          barycentric.y * heightBuffer[i1] +\n          barycentric.z * heightBuffer[i2];\n        return CesiumMath.lerp(\n          terrainData._minimumHeight,\n          terrainData._maximumHeight,\n          quantizedHeight / maxShort\n        );\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\nexport default QuantizedMeshTerrainData;\n","import CubicRealPolynomial from \"./CubicRealPolynomial.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\n\n/**\n * Defines functions for 4th order polynomial functions of one variable with only real coefficients.\n *\n * @namespace QuarticRealPolynomial\n */\nconst QuarticRealPolynomial = {};\n\n/**\n * Provides the discriminant of the quartic equation from the supplied coefficients.\n *\n * @param {Number} a The coefficient of the 4th order monomial.\n * @param {Number} b The coefficient of the 3rd order monomial.\n * @param {Number} c The coefficient of the 2nd order monomial.\n * @param {Number} d The coefficient of the 1st order monomial.\n * @param {Number} e The coefficient of the 0th order monomial.\n * @returns {Number} The value of the discriminant.\n */\nQuarticRealPolynomial.computeDiscriminant = function (a, b, c, d, e) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  if (typeof e !== \"number\") {\n    throw new DeveloperError(\"e is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  const a2 = a * a;\n  const a3 = a2 * a;\n  const b2 = b * b;\n  const b3 = b2 * b;\n  const c2 = c * c;\n  const c3 = c2 * c;\n  const d2 = d * d;\n  const d3 = d2 * d;\n  const e2 = e * e;\n  const e3 = e2 * e;\n\n  const discriminant =\n    b2 * c2 * d2 -\n    4.0 * b3 * d3 -\n    4.0 * a * c3 * d2 +\n    18 * a * b * c * d3 -\n    27.0 * a2 * d2 * d2 +\n    256.0 * a3 * e3 +\n    e *\n      (18.0 * b3 * c * d -\n        4.0 * b2 * c3 +\n        16.0 * a * c2 * c2 -\n        80.0 * a * b * c2 * d -\n        6.0 * a * b2 * d2 +\n        144.0 * a2 * c * d2) +\n    e2 *\n      (144.0 * a * b2 * c -\n        27.0 * b2 * b2 -\n        128.0 * a2 * c2 -\n        192.0 * a2 * b * d);\n  return discriminant;\n};\n\nfunction original(a3, a2, a1, a0) {\n  const a3Squared = a3 * a3;\n\n  const p = a2 - (3.0 * a3Squared) / 8.0;\n  const q = a1 - (a2 * a3) / 2.0 + (a3Squared * a3) / 8.0;\n  const r =\n    a0 -\n    (a1 * a3) / 4.0 +\n    (a2 * a3Squared) / 16.0 -\n    (3.0 * a3Squared * a3Squared) / 256.0;\n\n  // Find the roots of the cubic equations:  h^6 + 2 p h^4 + (p^2 - 4 r) h^2 - q^2 = 0.\n  const cubicRoots = CubicRealPolynomial.computeRealRoots(\n    1.0,\n    2.0 * p,\n    p * p - 4.0 * r,\n    -q * q\n  );\n\n  if (cubicRoots.length > 0) {\n    const temp = -a3 / 4.0;\n\n    // Use the largest positive root.\n    const hSquared = cubicRoots[cubicRoots.length - 1];\n\n    if (Math.abs(hSquared) < CesiumMath.EPSILON14) {\n      // y^4 + p y^2 + r = 0.\n      const roots = QuadraticRealPolynomial.computeRealRoots(1.0, p, r);\n\n      if (roots.length === 2) {\n        const root0 = roots[0];\n        const root1 = roots[1];\n\n        let y;\n        if (root0 >= 0.0 && root1 >= 0.0) {\n          const y0 = Math.sqrt(root0);\n          const y1 = Math.sqrt(root1);\n\n          return [temp - y1, temp - y0, temp + y0, temp + y1];\n        } else if (root0 >= 0.0 && root1 < 0.0) {\n          y = Math.sqrt(root0);\n          return [temp - y, temp + y];\n        } else if (root0 < 0.0 && root1 >= 0.0) {\n          y = Math.sqrt(root1);\n          return [temp - y, temp + y];\n        }\n      }\n      return [];\n    } else if (hSquared > 0.0) {\n      const h = Math.sqrt(hSquared);\n\n      const m = (p + hSquared - q / h) / 2.0;\n      const n = (p + hSquared + q / h) / 2.0;\n\n      // Now solve the two quadratic factors:  (y^2 + h y + m)(y^2 - h y + n);\n      const roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, h, m);\n      const roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, -h, n);\n\n      if (roots1.length !== 0) {\n        roots1[0] += temp;\n        roots1[1] += temp;\n\n        if (roots2.length !== 0) {\n          roots2[0] += temp;\n          roots2[1] += temp;\n\n          if (roots1[1] <= roots2[0]) {\n            return [roots1[0], roots1[1], roots2[0], roots2[1]];\n          } else if (roots2[1] <= roots1[0]) {\n            return [roots2[0], roots2[1], roots1[0], roots1[1]];\n          } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n            return [roots2[0], roots1[0], roots1[1], roots2[1]];\n          } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n            return [roots1[0], roots2[0], roots2[1], roots1[1]];\n          } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n            return [roots2[0], roots1[0], roots2[1], roots1[1]];\n          }\n          return [roots1[0], roots2[0], roots1[1], roots2[1]];\n        }\n        return roots1;\n      }\n\n      if (roots2.length !== 0) {\n        roots2[0] += temp;\n        roots2[1] += temp;\n\n        return roots2;\n      }\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction neumark(a3, a2, a1, a0) {\n  const a1Squared = a1 * a1;\n  const a2Squared = a2 * a2;\n  const a3Squared = a3 * a3;\n\n  const p = -2.0 * a2;\n  const q = a1 * a3 + a2Squared - 4.0 * a0;\n  const r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;\n\n  const cubicRoots = CubicRealPolynomial.computeRealRoots(1.0, p, q, r);\n\n  if (cubicRoots.length > 0) {\n    // Use the most positive root\n    const y = cubicRoots[0];\n\n    const temp = a2 - y;\n    const tempSquared = temp * temp;\n\n    const g1 = a3 / 2.0;\n    const h1 = temp / 2.0;\n\n    const m = tempSquared - 4.0 * a0;\n    const mError = tempSquared + 4.0 * Math.abs(a0);\n\n    const n = a3Squared - 4.0 * y;\n    const nError = a3Squared + 4.0 * Math.abs(y);\n\n    let g2;\n    let h2;\n\n    if (y < 0.0 || m * nError < n * mError) {\n      const squareRootOfN = Math.sqrt(n);\n      g2 = squareRootOfN / 2.0;\n      h2 = squareRootOfN === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfN;\n    } else {\n      const squareRootOfM = Math.sqrt(m);\n      g2 = squareRootOfM === 0.0 ? 0.0 : (a3 * h1 - a1) / squareRootOfM;\n      h2 = squareRootOfM / 2.0;\n    }\n\n    let G;\n    let g;\n    if (g1 === 0.0 && g2 === 0.0) {\n      G = 0.0;\n      g = 0.0;\n    } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {\n      G = g1 + g2;\n      g = y / G;\n    } else {\n      g = g1 - g2;\n      G = y / g;\n    }\n\n    let H;\n    let h;\n    if (h1 === 0.0 && h2 === 0.0) {\n      H = 0.0;\n      h = 0.0;\n    } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {\n      H = h1 + h2;\n      h = a0 / H;\n    } else {\n      h = h1 - h2;\n      H = a0 / h;\n    }\n\n    // Now solve the two quadratic factors:  (y^2 + G y + H)(y^2 + g y + h);\n    const roots1 = QuadraticRealPolynomial.computeRealRoots(1.0, G, H);\n    const roots2 = QuadraticRealPolynomial.computeRealRoots(1.0, g, h);\n\n    if (roots1.length !== 0) {\n      if (roots2.length !== 0) {\n        if (roots1[1] <= roots2[0]) {\n          return [roots1[0], roots1[1], roots2[0], roots2[1]];\n        } else if (roots2[1] <= roots1[0]) {\n          return [roots2[0], roots2[1], roots1[0], roots1[1]];\n        } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {\n          return [roots2[0], roots1[0], roots1[1], roots2[1]];\n        } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {\n          return [roots1[0], roots2[0], roots2[1], roots1[1]];\n        } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {\n          return [roots2[0], roots1[0], roots2[1], roots1[1]];\n        }\n        return [roots1[0], roots2[0], roots1[1], roots2[1]];\n      }\n      return roots1;\n    }\n    if (roots2.length !== 0) {\n      return roots2;\n    }\n  }\n  return [];\n}\n\n/**\n * Provides the real valued roots of the quartic polynomial with the provided coefficients.\n *\n * @param {Number} a The coefficient of the 4th order monomial.\n * @param {Number} b The coefficient of the 3rd order monomial.\n * @param {Number} c The coefficient of the 2nd order monomial.\n * @param {Number} d The coefficient of the 1st order monomial.\n * @param {Number} e The coefficient of the 0th order monomial.\n * @returns {Number[]} The real valued roots.\n */\nQuarticRealPolynomial.computeRealRoots = function (a, b, c, d, e) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  if (typeof e !== \"number\") {\n    throw new DeveloperError(\"e is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  if (Math.abs(a) < CesiumMath.EPSILON15) {\n    return CubicRealPolynomial.computeRealRoots(b, c, d, e);\n  }\n  const a3 = b / a;\n  const a2 = c / a;\n  const a1 = d / a;\n  const a0 = e / a;\n\n  let k = a3 < 0.0 ? 1 : 0;\n  k += a2 < 0.0 ? k + 1 : k;\n  k += a1 < 0.0 ? k + 1 : k;\n  k += a0 < 0.0 ? k + 1 : k;\n\n  switch (k) {\n    case 0:\n      return original(a3, a2, a1, a0);\n    case 1:\n      return neumark(a3, a2, a1, a0);\n    case 2:\n      return neumark(a3, a2, a1, a0);\n    case 3:\n      return original(a3, a2, a1, a0);\n    case 4:\n      return original(a3, a2, a1, a0);\n    case 5:\n      return neumark(a3, a2, a1, a0);\n    case 6:\n      return original(a3, a2, a1, a0);\n    case 7:\n      return original(a3, a2, a1, a0);\n    case 8:\n      return neumark(a3, a2, a1, a0);\n    case 9:\n      return original(a3, a2, a1, a0);\n    case 10:\n      return original(a3, a2, a1, a0);\n    case 11:\n      return neumark(a3, a2, a1, a0);\n    case 12:\n      return original(a3, a2, a1, a0);\n    case 13:\n      return original(a3, a2, a1, a0);\n    case 14:\n      return original(a3, a2, a1, a0);\n    case 15:\n      return original(a3, a2, a1, a0);\n    default:\n      return undefined;\n  }\n};\nexport default QuarticRealPolynomial;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FeatureDetection from \"./FeatureDetection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\n\n/**\n * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.\n * @alias Quaternion\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see PackableForInterpolation\n */\nfunction Quaternion(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.w = defaultValue(w, 0.0);\n}\n\nlet fromAxisAngleScratch = new Cartesian3();\n\n/**\n * Computes a quaternion representing a rotation around an axis.\n *\n * @param {Cartesian3} axis The axis of rotation.\n * @param {Number} angle The angle in radians to rotate around the axis.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.fromAxisAngle = function (axis, angle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"axis\", axis);\n  Check.typeOf.number(\"angle\", angle);\n  //>>includeEnd('debug');\n\n  const halfAngle = angle / 2.0;\n  const s = Math.sin(halfAngle);\n  fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);\n\n  const x = fromAxisAngleScratch.x * s;\n  const y = fromAxisAngleScratch.y * s;\n  const z = fromAxisAngleScratch.z * s;\n  const w = Math.cos(halfAngle);\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nconst fromRotationMatrixNext = [1, 2, 0];\nconst fromRotationMatrixQuat = new Array(3);\n/**\n * Computes a Quaternion from the provided Matrix3 instance.\n *\n * @param {Matrix3} matrix The rotation matrix.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n *\n * @see Matrix3.fromQuaternion\n */\nQuaternion.fromRotationMatrix = function (matrix, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"matrix\", matrix);\n  //>>includeEnd('debug');\n\n  let root;\n  let x;\n  let y;\n  let z;\n  let w;\n\n  const m00 = matrix[Matrix3.COLUMN0ROW0];\n  const m11 = matrix[Matrix3.COLUMN1ROW1];\n  const m22 = matrix[Matrix3.COLUMN2ROW2];\n  const trace = m00 + m11 + m22;\n\n  if (trace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    root = Math.sqrt(trace + 1.0); // 2w\n    w = 0.5 * root;\n    root = 0.5 / root; // 1/(4w)\n\n    x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;\n    y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;\n    z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;\n  } else {\n    // |w| <= 1/2\n    const next = fromRotationMatrixNext;\n\n    let i = 0;\n    if (m11 > m00) {\n      i = 1;\n    }\n    if (m22 > m00 && m22 > m11) {\n      i = 2;\n    }\n    const j = next[i];\n    const k = next[j];\n\n    root = Math.sqrt(\n      matrix[Matrix3.getElementIndex(i, i)] -\n        matrix[Matrix3.getElementIndex(j, j)] -\n        matrix[Matrix3.getElementIndex(k, k)] +\n        1.0\n    );\n\n    const quat = fromRotationMatrixQuat;\n    quat[i] = 0.5 * root;\n    root = 0.5 / root;\n    w =\n      (matrix[Matrix3.getElementIndex(k, j)] -\n        matrix[Matrix3.getElementIndex(j, k)]) *\n      root;\n    quat[j] =\n      (matrix[Matrix3.getElementIndex(j, i)] +\n        matrix[Matrix3.getElementIndex(i, j)]) *\n      root;\n    quat[k] =\n      (matrix[Matrix3.getElementIndex(k, i)] +\n        matrix[Matrix3.getElementIndex(i, k)]) *\n      root;\n\n    x = -quat[0];\n    y = -quat[1];\n    z = -quat[2];\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(x, y, z, w);\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\nconst scratchHPRQuaternion = new Quaternion();\nlet scratchHeadingQuaternion = new Quaternion();\nlet scratchPitchQuaternion = new Quaternion();\nlet scratchRollQuaternion = new Quaternion();\n\n/**\n * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the\n * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about\n * the positive x axis.\n *\n * @param {HeadingPitchRoll} headingPitchRoll The rotation expressed as a heading, pitch and roll.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n */\nQuaternion.fromHeadingPitchRoll = function (headingPitchRoll, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"headingPitchRoll\", headingPitchRoll);\n  //>>includeEnd('debug');\n\n  scratchRollQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_X,\n    headingPitchRoll.roll,\n    scratchHPRQuaternion\n  );\n  scratchPitchQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Y,\n    -headingPitchRoll.pitch,\n    result\n  );\n  result = Quaternion.multiply(\n    scratchPitchQuaternion,\n    scratchRollQuaternion,\n    scratchPitchQuaternion\n  );\n  scratchHeadingQuaternion = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -headingPitchRoll.heading,\n    scratchHPRQuaternion\n  );\n  return Quaternion.multiply(scratchHeadingQuaternion, result, result);\n};\n\nconst sampledQuaternionAxis = new Cartesian3();\nconst sampledQuaternionRotation = new Cartesian3();\nconst sampledQuaternionTempQuaternion = new Quaternion();\nconst sampledQuaternionQuaternion0 = new Quaternion();\nconst sampledQuaternionQuaternion0Conjugate = new Quaternion();\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nQuaternion.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Quaternion} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nQuaternion.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  result.x = array[startingIndex];\n  result.y = array[startingIndex + 1];\n  result.z = array[startingIndex + 2];\n  result.w = array[startingIndex + 3];\n  return result;\n};\n\n/**\n * The number of elements used to store the object into an array in its interpolatable form.\n * @type {Number}\n */\nQuaternion.packedInterpolationLength = 3;\n\n/**\n * Converts a packed array into a form suitable for interpolation.\n *\n * @param {Number[]} packedArray The packed array.\n * @param {Number} [startingIndex=0] The index of the first element to be converted.\n * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.\n * @param {Number[]} [result] The object into which to store the result.\n */\nQuaternion.convertPackedArrayForInterpolation = function (\n  packedArray,\n  startingIndex,\n  lastIndex,\n  result\n) {\n  Quaternion.unpack(\n    packedArray,\n    lastIndex * 4,\n    sampledQuaternionQuaternion0Conjugate\n  );\n  Quaternion.conjugate(\n    sampledQuaternionQuaternion0Conjugate,\n    sampledQuaternionQuaternion0Conjugate\n  );\n\n  for (let i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n    const offset = i * 3;\n    Quaternion.unpack(\n      packedArray,\n      (startingIndex + i) * 4,\n      sampledQuaternionTempQuaternion\n    );\n\n    Quaternion.multiply(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionQuaternion0Conjugate,\n      sampledQuaternionTempQuaternion\n    );\n\n    if (sampledQuaternionTempQuaternion.w < 0) {\n      Quaternion.negate(\n        sampledQuaternionTempQuaternion,\n        sampledQuaternionTempQuaternion\n      );\n    }\n\n    Quaternion.computeAxis(\n      sampledQuaternionTempQuaternion,\n      sampledQuaternionAxis\n    );\n    const angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);\n    if (!defined(result)) {\n      result = [];\n    }\n    result[offset] = sampledQuaternionAxis.x * angle;\n    result[offset + 1] = sampledQuaternionAxis.y * angle;\n    result[offset + 2] = sampledQuaternionAxis.z * angle;\n  }\n};\n\n/**\n * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.\n *\n * @param {Number[]} array The array previously packed for interpolation.\n * @param {Number[]} sourceArray The original packed array.\n * @param {Number} [firstIndex=0] The firstIndex used to convert the array.\n * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n * @param {Quaternion} [result] The object into which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.unpackInterpolationResult = function (\n  array,\n  sourceArray,\n  firstIndex,\n  lastIndex,\n  result\n) {\n  if (!defined(result)) {\n    result = new Quaternion();\n  }\n  Cartesian3.fromArray(array, 0, sampledQuaternionRotation);\n  const magnitude = Cartesian3.magnitude(sampledQuaternionRotation);\n\n  Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);\n\n  if (magnitude === 0) {\n    Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);\n  } else {\n    Quaternion.fromAxisAngle(\n      sampledQuaternionRotation,\n      magnitude,\n      sampledQuaternionTempQuaternion\n    );\n  }\n\n  return Quaternion.multiply(\n    sampledQuaternionTempQuaternion,\n    sampledQuaternionQuaternion0,\n    result\n  );\n};\n\n/**\n * Duplicates a Quaternion instance.\n *\n * @param {Quaternion} quaternion The quaternion to duplicate.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)\n */\nQuaternion.clone = function (quaternion, result) {\n  if (!defined(quaternion)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Quaternion(\n      quaternion.x,\n      quaternion.y,\n      quaternion.z,\n      quaternion.w\n    );\n  }\n\n  result.x = quaternion.x;\n  result.y = quaternion.y;\n  result.z = quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes the conjugate of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.conjugate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = quaternion.w;\n  return result;\n};\n\n/**\n * Computes magnitude squared for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {Number} The magnitude squared.\n */\nQuaternion.magnitudeSquared = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  return (\n    quaternion.x * quaternion.x +\n    quaternion.y * quaternion.y +\n    quaternion.z * quaternion.z +\n    quaternion.w * quaternion.w\n  );\n};\n\n/**\n * Computes magnitude for the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to conjugate.\n * @returns {Number} The magnitude.\n */\nQuaternion.magnitude = function (quaternion) {\n  return Math.sqrt(Quaternion.magnitudeSquared(quaternion));\n};\n\n/**\n * Computes the normalized form of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.normalize = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const inverseMagnitude = 1.0 / Quaternion.magnitude(quaternion);\n  const x = quaternion.x * inverseMagnitude;\n  const y = quaternion.y * inverseMagnitude;\n  const z = quaternion.z * inverseMagnitude;\n  const w = quaternion.w * inverseMagnitude;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Computes the inverse of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to normalize.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.inverse = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const magnitudeSquared = Quaternion.magnitudeSquared(quaternion);\n  result = Quaternion.conjugate(quaternion, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / magnitudeSquared, result);\n};\n\n/**\n * Computes the componentwise sum of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Negates the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to be negated.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.negate = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -quaternion.x;\n  result.y = -quaternion.y;\n  result.z = -quaternion.z;\n  result.w = -quaternion.w;\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @returns {Number} The dot product.\n */\nQuaternion.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the product of two quaternions.\n *\n * @param {Quaternion} left The first quaternion.\n * @param {Quaternion} right The second quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiply = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const leftX = left.x;\n  const leftY = left.y;\n  const leftZ = left.z;\n  const leftW = left.w;\n\n  const rightX = right.x;\n  const rightY = right.y;\n  const rightZ = right.z;\n  const rightW = right.w;\n\n  const x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;\n  const y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;\n  const z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;\n  const w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Multiplies the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.multiplyByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  result.w = quaternion.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided quaternion componentwise by the provided scalar.\n *\n * @param {Quaternion} quaternion The quaternion to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.divideByScalar = function (quaternion, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = quaternion.x / scalar;\n  result.y = quaternion.y / scalar;\n  result.z = quaternion.z / scalar;\n  result.w = quaternion.w / scalar;\n  return result;\n};\n\n/**\n * Computes the axis of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.computeAxis = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const w = quaternion.w;\n  if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {\n    result.x = result.y = result.z = 0;\n    return result;\n  }\n\n  const scalar = 1.0 / Math.sqrt(1.0 - w * w);\n\n  result.x = quaternion.x * scalar;\n  result.y = quaternion.y * scalar;\n  result.z = quaternion.z * scalar;\n  return result;\n};\n\n/**\n * Computes the angle of rotation of the provided quaternion.\n *\n * @param {Quaternion} quaternion The quaternion to use.\n * @returns {Number} The angle of rotation.\n */\nQuaternion.computeAngle = function (quaternion) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  //>>includeEnd('debug');\n\n  if (Math.abs(quaternion.w - 1.0) < CesiumMath.EPSILON6) {\n    return 0.0;\n  }\n  return 2.0 * Math.acos(quaternion.w);\n};\n\nlet lerpScratch = new Quaternion();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);\n  result = Quaternion.multiplyByScalar(start, 1.0 - t, result);\n  return Quaternion.add(lerpScratch, result, result);\n};\n\nlet slerpEndNegated = new Quaternion();\nlet slerpScaledP = new Quaternion();\nlet slerpScaledR = new Quaternion();\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#fastSlerp\n */\nQuaternion.slerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let dot = Quaternion.dot(start, end);\n\n  // The angle between start must be acute. Since q and -q represent\n  // the same rotation, negate q to get the acute angle.\n  let r = end;\n  if (dot < 0.0) {\n    dot = -dot;\n    r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);\n  }\n\n  // dot > 0, as the dot product approaches 1, the angle between the\n  // quaternions vanishes. use linear interpolation.\n  if (1.0 - dot < CesiumMath.EPSILON6) {\n    return Quaternion.lerp(start, r, t, result);\n  }\n\n  const theta = Math.acos(dot);\n  slerpScaledP = Quaternion.multiplyByScalar(\n    start,\n    Math.sin((1 - t) * theta),\n    slerpScaledP\n  );\n  slerpScaledR = Quaternion.multiplyByScalar(\n    r,\n    Math.sin(t * theta),\n    slerpScaledR\n  );\n  result = Quaternion.add(slerpScaledP, slerpScaledR, result);\n  return Quaternion.multiplyByScalar(result, 1.0 / Math.sin(theta), result);\n};\n\n/**\n * The logarithmic quaternion function.\n *\n * @param {Quaternion} quaternion The unit quaternion.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nQuaternion.log = function (quaternion, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"quaternion\", quaternion);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = CesiumMath.acosClamped(quaternion.w);\n  let thetaOverSinTheta = 0.0;\n\n  if (theta !== 0.0) {\n    thetaOverSinTheta = theta / Math.sin(theta);\n  }\n\n  return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);\n};\n\n/**\n * The exponential quaternion function.\n *\n * @param {Cartesian3} cartesian The cartesian.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n */\nQuaternion.exp = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const theta = Cartesian3.magnitude(cartesian);\n  let sinThetaOverTheta = 0.0;\n\n  if (theta !== 0.0) {\n    sinThetaOverTheta = Math.sin(theta) / theta;\n  }\n\n  result.x = cartesian.x * sinThetaOverTheta;\n  result.y = cartesian.y * sinThetaOverTheta;\n  result.z = cartesian.z * sinThetaOverTheta;\n  result.w = Math.cos(theta);\n\n  return result;\n};\n\nconst squadScratchCartesian0 = new Cartesian3();\nconst squadScratchCartesian1 = new Cartesian3();\nconst squadScratchQuaternion0 = new Quaternion();\nconst squadScratchQuaternion1 = new Quaternion();\n\n/**\n * Computes an inner quadrangle point.\n * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} q2 The third quaternion.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#squad\n */\nQuaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"q2\", q2);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);\n  Quaternion.multiply(qInv, q2, squadScratchQuaternion1);\n  const cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);\n\n  Quaternion.multiply(qInv, q0, squadScratchQuaternion1);\n  const cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);\n\n  Cartesian3.add(cart0, cart1, cart0);\n  Cartesian3.multiplyByScalar(cart0, 0.25, cart0);\n  Cartesian3.negate(cart0, cart0);\n  Quaternion.exp(cart0, squadScratchQuaternion0);\n\n  return Quaternion.multiply(q1, squadScratchQuaternion0, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {Number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n *\n * @example\n * // 1. compute the squad interpolation between two quaternions on a curve\n * const s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());\n *\n * // 2. compute the squad interpolation as above but where the first quaternion is a end point.\n * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());\n * const q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());\n *\n * @see Quaternion#computeInnerQuadrangle\n */\nQuaternion.squad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.slerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\nconst fastSlerpScratchQuaternion = new Quaternion();\nconst opmu = 1.90110745351730037;\nconst u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\nconst bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];\n\nfor (let i = 0; i < 7; ++i) {\n  const s = i + 1.0;\n  const t = 2.0 * s + 1.0;\n  u[i] = 1.0 / (s * t);\n  v[i] = s / t;\n}\n\nu[7] = opmu / (8.0 * 17.0);\nv[7] = (opmu * 8.0) / 17.0;\n\n/**\n * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.\n * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.\n *\n * @param {Quaternion} start The value corresponding to t at 0.0.\n * @param {Quaternion} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter.\n *\n * @see Quaternion#slerp\n */\nQuaternion.fastSlerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  let x = Quaternion.dot(start, end);\n\n  let sign;\n  if (x >= 0) {\n    sign = 1.0;\n  } else {\n    sign = -1.0;\n    x = -x;\n  }\n\n  const xm1 = x - 1.0;\n  const d = 1.0 - t;\n  const sqrT = t * t;\n  const sqrD = d * d;\n\n  for (let i = 7; i >= 0; --i) {\n    bT[i] = (u[i] * sqrT - v[i]) * xm1;\n    bD[i] = (u[i] * sqrD - v[i]) * xm1;\n  }\n\n  const cT =\n    sign *\n    t *\n    (1.0 +\n      bT[0] *\n        (1.0 +\n          bT[1] *\n            (1.0 +\n              bT[2] *\n                (1.0 +\n                  bT[3] *\n                    (1.0 +\n                      bT[4] *\n                        (1.0 + bT[5] * (1.0 + bT[6] * (1.0 + bT[7]))))))));\n  const cD =\n    d *\n    (1.0 +\n      bD[0] *\n        (1.0 +\n          bD[1] *\n            (1.0 +\n              bD[2] *\n                (1.0 +\n                  bD[3] *\n                    (1.0 +\n                      bD[4] *\n                        (1.0 + bD[5] * (1.0 + bD[6] * (1.0 + bD[7]))))))));\n\n  const temp = Quaternion.multiplyByScalar(\n    start,\n    cD,\n    fastSlerpScratchQuaternion\n  );\n  Quaternion.multiplyByScalar(end, cT, result);\n  return Quaternion.add(temp, result, result);\n};\n\n/**\n * Computes the spherical quadrangle interpolation between quaternions.\n * An implementation that is faster than {@link Quaternion#squad}, but less accurate.\n *\n * @param {Quaternion} q0 The first quaternion.\n * @param {Quaternion} q1 The second quaternion.\n * @param {Quaternion} s0 The first inner quadrangle.\n * @param {Quaternion} s1 The second inner quadrangle.\n * @param {Number} t The time in [0,1] used to interpolate.\n * @param {Quaternion} result The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance if none was provided.\n *\n * @see Quaternion#squad\n */\nQuaternion.fastSquad = function (q0, q1, s0, s1, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"q0\", q0);\n  Check.typeOf.object(\"q1\", q1);\n  Check.typeOf.object(\"s0\", s0);\n  Check.typeOf.object(\"s1\", s1);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);\n  const slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);\n  return Quaternion.fastSlerp(slerp0, slerp1, 2.0 * t * (1.0 - t), result);\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * Compares the provided quaternions componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [left] The first quaternion.\n * @param {Quaternion} [right] The second quaternion.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = defaultValue(epsilon, 0);\n\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Math.abs(left.x - right.x) <= epsilon &&\n      Math.abs(left.y - right.y) <= epsilon &&\n      Math.abs(left.z - right.z) <= epsilon &&\n      Math.abs(left.w - right.w) <= epsilon)\n  );\n};\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.ZERO = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Quaternion}\n * @constant\n */\nQuaternion.IDENTITY = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Quaternion instance.\n *\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.\n */\nQuaternion.prototype.clone = function (result) {\n  return Quaternion.clone(this, result);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nQuaternion.prototype.equals = function (right) {\n  return Quaternion.equals(this, right);\n};\n\n/**\n * Compares this and the provided quaternion componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Quaternion} [right] The right hand side quaternion.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nQuaternion.prototype.equalsEpsilon = function (right, epsilon) {\n  return Quaternion.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Returns a string representing this quaternion in the format (x, y, z, w).\n *\n * @returns {String} A string representing this Quaternion.\n */\nQuaternion.prototype.toString = function () {\n  return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n};\nexport default Quaternion;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Spline from \"./Spline.js\";\n\nfunction createEvaluateFunction(spline) {\n  const points = spline.points;\n  const times = spline.times;\n\n  // use slerp interpolation\n  return function (time, result) {\n    if (!defined(result)) {\n      result = new Quaternion();\n    }\n    const i = (spline._lastTimeIndex = spline.findTimeInterval(\n      time,\n      spline._lastTimeIndex\n    ));\n    const u = (time - times[i]) / (times[i + 1] - times[i]);\n\n    const q0 = points[i];\n    const q1 = points[i + 1];\n\n    return Quaternion.fastSlerp(q0, q1, u, result);\n  };\n}\n\n/**\n * A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.\n * The generated curve is in the class C<sup>1</sup>.\n *\n * @alias QuaternionSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Quaternion[]} options.points The array of {@link Quaternion} control points.\n *\n * @exception {DeveloperError} points and times are required\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n\n * @see ConstantSpline\n * @see SteppedSpline\n * @see HermiteSpline\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see MorphWeightSpline\n */\nfunction QuaternionSpline(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const points = options.points;\n  const times = options.times;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(points) || !defined(times)) {\n    throw new DeveloperError(\"points and times are required.\");\n  }\n  if (points.length < 2) {\n    throw new DeveloperError(\n      \"points.length must be greater than or equal to 2.\"\n    );\n  }\n  if (times.length !== points.length) {\n    throw new DeveloperError(\"times.length must be equal to points.length.\");\n  }\n  //>>includeEnd('debug');\n\n  this._times = times;\n  this._points = points;\n\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(QuaternionSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Quaternion} control points.\n   *\n   * @memberof QuaternionSpline.prototype\n   *\n   * @type {Quaternion[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n});\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nQuaternionSpline.prototype.wrapTime = Spline.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nQuaternionSpline.prototype.clampTime = Spline.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nQuaternionSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\nexport default QuaternionSpline;\n","/**\n * A queue that can enqueue items at the end, and dequeue items from the front.\n *\n * @alias Queue\n * @constructor\n */\nfunction Queue() {\n  this._array = [];\n  this._offset = 0;\n  this._length = 0;\n}\n\nObject.defineProperties(Queue.prototype, {\n  /**\n   * The length of the queue.\n   *\n   * @memberof Queue.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n});\n\n/**\n * Enqueues the specified item.\n *\n * @param {*} item The item to enqueue.\n */\nQueue.prototype.enqueue = function (item) {\n  this._array.push(item);\n  this._length++;\n};\n\n/**\n * Dequeues an item.  Returns undefined if the queue is empty.\n *\n * @returns {*} The the dequeued item.\n */\nQueue.prototype.dequeue = function () {\n  if (this._length === 0) {\n    return undefined;\n  }\n\n  const array = this._array;\n  let offset = this._offset;\n  const item = array[offset];\n  array[offset] = undefined;\n\n  offset++;\n  if (offset > 10 && offset * 2 > array.length) {\n    //compact array\n    this._array = array.slice(offset);\n    offset = 0;\n  }\n\n  this._offset = offset;\n  this._length--;\n\n  return item;\n};\n\n/**\n * Returns the item at the front of the queue.  Returns undefined if the queue is empty.\n *\n * @returns {*} The item at the front of the queue.\n */\nQueue.prototype.peek = function () {\n  if (this._length === 0) {\n    return undefined;\n  }\n\n  return this._array[this._offset];\n};\n\n/**\n * Check whether this queue contains the specified item.\n *\n * @param {*} item The item to search for.\n */\nQueue.prototype.contains = function (item) {\n  return this._array.indexOf(item) !== -1;\n};\n\n/**\n * Remove all items from the queue.\n */\nQueue.prototype.clear = function () {\n  this._array.length = this._offset = this._length = 0;\n};\n\n/**\n * Sort the items in the queue in-place.\n *\n * @param {Queue.Comparator} compareFunction A function that defines the sort order.\n */\nQueue.prototype.sort = function (compareFunction) {\n  if (this._offset > 0) {\n    //compact array\n    this._array = this._array.slice(this._offset);\n    this._offset = 0;\n  }\n\n  this._array.sort(compareFunction);\n};\n\n/**\n * A function used to compare two items while sorting a queue.\n * @callback Queue.Comparator\n *\n * @param {*} a An item in the array.\n * @param {*} b An item in the array.\n * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,\n *          a positive value if <code>a</code> is greater than <code>b</code>, or\n *          0 if <code>a</code> is equal to <code>b</code>.\n *\n * @example\n * function compareNumbers(a, b) {\n *     return a - b;\n * }\n */\nexport default Queue;\n"],"names":["defaultKey","str","len","length","buffer","ArrayBuffer","ui8","Uint8Array","i","charCodeAt","stringToBuffer","GoogleEarthEnterpriseMetadata","resourceOrUrl","url","resource","appendForwardSlash","this","_resource","imageryPresent","protoImagery","undefined","terrainPresent","negativeAltitudeExponentBias","negativeAltitudeThreshold","providers","key","_quadPacketVersion","_tileInfo","_subtreePromises","that","_readyPromise","getDerivedResource","queryParameters","output","dbrootParserPromise","oldValue","window","cesiumGoogleEarthDbRootParser","then","dbrootParser","fetchArrayBuffer","buf","encryptedDbRootProto","EncryptedDbRootProto","decode","byteArray","encryptionData","offset","byteOffset","end","byteLength","slice","dbrootData","dbRootCompressed","taskProcessor","scheduleTask","type","result","dbRoot","DbRootProto","endSnippet","model","compressedNegativeAltitudeThreshold","databaseVersion","quadtreeVersion","providerInfo","count","provider","copyrightString","providerId","value","catch","requestDbRoot","getQuadTreePacket","e","message","getMetadataResource","Promise","reject","Object","defineProperties","prototype","get","proxy","readyPromise","tileXYToQuadKey","x","y","level","quadkey","bitmask","digit","quadKeyToTileXY","isValid","quadKey","info","getTileInformationFromQuadKey","last","valid","q","substring","hasSubtree","hasChild","parseInt","populateSubtree","request","tileInfo","subtreeRequest","t","hasChildren","subtreePromises","promise","throttle","throttleByServer","priorityFunction","cnodeVersion","finally","version","toString","metadata","root","topLevelKeyLength","top","_bits","keys","sort","a","b","keysLength","keyLength","setParent","parent","getTileInformation","GoogleEarthEnterpriseTerrainData","options","negativeElevationThreshold","_buffer","_credits","credits","_negativeAltitudeExponentBias","_negativeElevationThreshold","googleChildTileMask","childTileMask","_childTileMask","_createdByUpsampling","createdByUpsampling","_skirtHeight","_bufferType","constructor","_mesh","_minimumHeight","_maximumHeight","waterMask","createMeshTaskName","createMeshTaskProcessorNoThrottle","createMeshTaskProcessorThrottle","nativeRectangleScratch","rectangleScratch","createMesh","tilingScheme","exaggeration","exaggerationRelativeHeight","ellipsoid","tileXYToNativeRectangle","tileXYToRectangle","center","cartographicToCartesian","thisLevelMaxError","Math","min","verticesPromise","nativeRectangle","rectangle","relativeToCenter","skirtHeight","includeWebMercatorT","Float32Array","vertices","Uint16Array","indices","indexCountWithoutSkirts","vertexCountWithoutSkirts","minimumHeight","maximumHeight","boundingSphere3D","occludeePointInScaledSpace","numberOfAttributes","orientedBoundingBox","encoding","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","interpolateHeight","longitude","latitude","u","west","width","v","south","height","terrainData","mesh","i0","i1","i2","uv0","decodeTextureCoordinates","texCoordScratch0","uv1","texCoordScratch1","uv2","texCoordScratch2","barycentric","barycentricCoordinateScratch","z","h0","decodeHeight","h1","h2","interpolateMeshHeight","quad","uStart","vStart","dv","DataView","getUint32","sizeOfUint32","sizeOfDouble","xSize","getFloat64","ySize","xScale","yScale","numPoints","getInt32","sizeOfInt32","numIndices","uBuffer","Array","vBuffer","heights","getUint8","getFloat32","sizeOfFloat","getUint16","sizeOfUint16","u0","u1","u2","v0","v1","v2","upsampleTaskProcessor","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","isEastChild","isNorthChild","childRectangle","upsamplePromise","quantizedVertices","indicesTypedArray","boundingSphere","horizonOcclusionPoint","westIndices","southIndices","eastIndices","northIndices","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling","BYTES_PER_ELEMENT","Uint32Array","Int32Array","Float64Array","TerrainState","julianDateScratch","TerrainCache","_terrainCache","_lastTidy","GoogleEarthEnterpriseTerrainProvider","_metadata","_tilingScheme","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","credit","_credit","_levelZeroMaximumGeometricError","_terrainPromises","_terrainRequests","_errorEvent","_ready","metadataError","add","timestamp","tidy","terrainCache","k","errorEvent","ready","hasWaterMask","hasVertexNormals","availability","computeChildMask","childMask","getChildBitmask","terrainState","child","hasTerrain","requestTileGeometry","terrainProvider","resolve","ancestorHasTerrain","parentInfo","terrainVersion","terrainPromises","terrainRequests","sharedPromise","sharedRequest","requestPromise","buildTerrainResource","terrain","terrainTiles","requestedInfo","j","childKey","error","state","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability","childrenBitmasks","GoogleEarthEnterpriseTileInformation","bits","imageryVersion","imageryProvider","clone","hasImagery","index","year","month","day","hour","minute","second","millisecond","isLeapSecond","PROJECTIONS","PROJECTION_COUNT","MITER_BREAK_SMALL","cos","MITER_BREAK_LARGE","GroundPolylineGeometry","positions","arcType","_positions","granularity","loop","_ellipsoid","_projectionIndex","_workerName","_scene3DOnly","packedLength","setProjectionAndEllipsoid","groundPolylineGeometry","mapProjection","projectionIndex","cart3Scratch1","cart3Scratch2","cart3Scratch3","computeRightNormal","start","maxHeight","startBottom","getPosition","startTop","endBottom","up","direction","forward","interpolatedCartographicScratch","interpolatedBottomScratch","interpolatedTopScratch","interpolatedNormalScratch","interpolateSegment","minHeight","normalsArray","bottomPositionsArray","topPositionsArray","cartographicsArray","ellipsoidLine","surfaceDistance","interpolatedNormal","segments","ceil","interpointDistance","distanceFromStart","pointsToAdd","packIndex","interpolatedCartographic","interpolateUsingSurfaceDistance","interpolatedBottom","interpolatedTop","push","heightlessCartographicScratch","cartographic","target","origin","tangentDirection","pack","array","startingIndex","positionsLength","cartesian","unpack","scene3DOnly","toPreviousScratch","toNextScratch","forwardScratch","vertexUpScratch","computeVertexMiterNormal","previousBottom","vertexBottom","vertexTop","nextBottom","toPrevious","toNext","XZ_PLANE","previousBottomScratch","vertexBottomScratch","vertexTopScratch","nextBottomScratch","vertexNormalScratch","intersectionScratch","cartographicScratch0","cartographicScratch1","cartographicIntersectionScratch","createGeometry","compute2dAttributes","projection","p0","p1","c0","c1","rhumbLine","intersection","intersectionCartographic","intersectionLongitude","splitPositions","cartesianToCartographic","setEndPoints","findIntersectionWithLongitude","cartographicsLength","cartographics","vertexNormal","startCartographic","nextCartographic","vertexCartographic","endCartographic","preEndCartographic","postEndCartographic","segmentCount","vertexCount","arraySizeVec4","indexCount","positionsArray","startHiAndForwardOffsetX","startLoAndForwardOffsetY","startNormalAndForwardOffsetZ","endNormalAndTextureCoordinateNormalizationX","rightNormalAndTextureCoordinateNormalizationY","startHiLo2D","offsetAndRight2D","startEndNormals2D","texcoordNormalization2D","length2D","startCartographicScratch","endCartographicScratch","segmentStartCartesian","segmentStartTopScratch","segmentEndCartesian","segmentEndTopScratch","project","length3D","cartographicsIndex","vec2sWriteIndex","vec3sWriteIndex","vec4sWriteIndex","miterBroken","segmentEndBottomScratch","endTop","endGeometryNormal","segmentEndNormalScratch","breakMiter","segmentStartBottomScratch","lengthSoFar3D","lengthSoFar2D","sumHeights","start2D","end2D","startGeometryNormal2D","endGeometryNormal2D","startGeometryNormal","segmentStartNormalScratch","nudgeResult","nudgeCartographic","segmentStart2DScratch","segmentEnd2DScratch","direction2D","forwardOffset2DScratch","abs","segmentStartNormal2DScratch","segmentEndNormal2DScratch","projectNormal","segmentLength3D","encodedStart","encodeScratch","forwardOffset","offsetScratch","rightScratch","startUp","startUpScratch","rightNormal","startPlaneNormal","startPlaneNormalScratch","endUp","endUpScratch","endPlaneNormal","endPlaneNormalScratch","texcoordNormalization3DX","texcoordNormalization3DY","encodedStart2D","forwardOffset2D","right2D","segmentLength2D","texcoordNormalization2DX","texcoordNormalization2DY","encodeScratch2D","right2DScratch","swap","vec4Index","vec2Index","wIndex","rightPlaneSide","topBottomSide","high","low","texcoordNormalization","adjustHeightStartBottom","adjustHeightStartBottomScratch","adjustHeightEndBottom","adjustHeightEndBottomScratch","adjustHeightStartTop","adjustHeightStartTopScratch","adjustHeightEndTop","adjustHeightEndTopScratch","getHeightsRectangle","getHeightCartographics","getHeightRectangleScratch","minMaxHeights","minimumTerrainHeight","maximumTerrainHeight","adjustHeights","normalNudge","normalNudgeScratch","nudgeXZ","indexOffset","REFERENCE_INDICES_LENGTH","REFERENCE_INDICES","boundingSpheres","scratchBoundingSpheres","radius","attributes","position","componentDatatype","componentsPerAttribute","normalize","values","getVec4GeometryAttribute","generateGeometryAttributes","lineDirectionScratch","matrix3Scratch","quaternionScratch","lineDirection","dot","vertexUp","angle","quaternion","rotationMatrix","endPosCartographicScratch","normalStartpointScratch","normalEndpointScratch","normal","projectedPosition","normalEndpoint","flipNormal","normalEndpointCartographic","normalEndpointProjected","adjustHeightNormalScratch","adjustHeightOffsetScratch","bottom","adjustHeightBottom","adjustHeightTop","adjustHeightNormal","distanceForBottom","adjustHeightOffset","distanceForTop","nudgeDirectionScratch","startToXZdistance","endToXZdistance","absStartLon","absEndLon","endSign","startSign","typedArray","_projectNormal","HeadingPitchRange","heading","pitch","range","hpr","HeadingPitchRoll","roll","fromQuaternion","test","w","denominatorRoll","numeratorRoll","denominatorHeading","numeratorHeading","atan2","fromDegrees","headingPitchRoll","equals","left","right","equalsEpsilon","relativeEpsilon","absoluteEpsilon","Heap","comparator","_comparator","_array","_length","_maximumLength","temp","internalArray","maximumLength","set","originalLength","reserve","heapify","candidate","inserting","resort","insert","element","removedElement","floor","pop","freeze","NONE","LERC","HeightmapTerrainData","_width","_height","_encoding","defaultStructure","structure","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","_structure","_waterMask","sourceRectangle","fromWest","east","fromSouth","north","westInteger","eastInteger","southInteger","northInteger","dy","triangleInterpolateHeight","dX","dY","southwestHeight","southeastHeight","northwestHeight","northeastHeight","getHeight","setHeight","divisor","getNumberOfXTilesAtLevel","heightmap","isGeographic","indicesAndEdges","gridWidth","gridHeight","_createMeshSync","isMeshCreated","isLERCEncoding","heightSample","sourceHeights","dx","meshData","destinationRectangle","pow","lowestEncodedHeight","highestEncodedHeight","HeightmapTessellator","DEFAULT_STRUCTURE","cartesian3Scratch","matrix4Scratch","minimumScratch","maximumScratch","computeVertices","sin","sqrt","atan","exp","piOverTwo","toRadians","hasSkirts","oneOverGlobeSemimajorAxis","maximumRadius","geographicWest","geographicSouth","geographicEast","geographicNorth","hasRelativeToCenter","includeGeodeticSurfaceNormals","rectangleWidth","rectangleHeight","granularityX","granularityY","radiiSquared","radiiSquaredX","radiiSquaredY","radiiSquaredZ","fromENU","toENU","southMercatorY","oneOverMercatorHeight","minimum","Number","POSITIVE_INFINITY","maximum","NEGATIVE_INFINITY","hMin","gridVertexCount","uvs","webMercatorTs","geodeticSurfaceNormals","startRow","endRow","startCol","endCol","skirtOffsetPercentage","rowIndex","row","isNorthEdge","isSouthEdge","cosLatitude","nZ","kZ","webMercatorT","colIndex","col","terrainOffset","elementOffset","max","isWestEdge","isEastEdge","isEdge","nX","nY","kX","kY","oneOverGamma","rSurfaceX","rSurfaceY","rSurfaceZ","geodeticSurfaceNormal","computeHorizonCullingPointPossiblyUnderEllipsoid","aaBox","bufferIndex","encode","factorial","calculateCoefficientTerm","zIndices","xTable","derivOrder","termOrder","reservedIndices","reserved","splice","HermitePolynomialApproximation","degree","inputOrder","yTable","yStride","d","s","coefficients","l","zIndicesLength","highestNonZeroCoef","nonZeroCoefficients","zj","zn","numerator","tempTerm","coeff","arrayScratch","interpolate","outputOrder","resultLength","r","zIndiceslength","highestNonZero","tmp","dimOne","coefIndex","dimTwo","coefficient","dimTwoMinusOne","fillCoefficientList","loopStop","coef","scratchLower","scratchDiagonal","scratchUpper","scratchRight","HermiteSpline","points","times","inTangents","outTangents","_times","_points","_pointType","_inTangents","_outTangents","_lastTimeIndex","createC1","tangents","createNaturalCubic","generateNatural","createClampedCubic","firstTangent","lastTangent","PointType","generateClamped","hermiteCoefficientMatrix","findTimeInterval","scratchTimeVec","scratchTemp","wrapTime","clampTime","evaluate","time","timesDelta","timeVec","coefs","multiplyByScalar","HilbertOrder","rotate","n","p","rx","ry","encode2D","BigInt","decode2D","Iau2000Orientation","c2","c3","c4","c5","c6","c7","c8","c9","c10","c11","c12","c13","dateTT","ComputeMoon","date","T","E1","E2","E3","E4","E5","E6","E7","E8","E9","E10","E11","E12","E13","sinE1","sinE2","sinE3","sinE4","sinE5","sinE6","sinE7","sinE8","sinE9","sinE10","sinE11","sinE12","sinE13","cosE1","cosE2","cosE3","cosE4","cosE5","cosE6","cosE7","cosE8","cosE9","cosE10","cosE11","cosE12","cosE13","rightAscension","declination","rotation","rotationRate","Iau2006XysData","_xysFileUrlTemplate","xysFileUrlTemplate","_interpolationOrder","interpolationOrder","_sampleZeroJulianEphemerisDate","sampleZeroJulianEphemerisDate","_sampleZeroDateTT","_stepSizeDays","stepSizeDays","_samplesPerXysFile","samplesPerXysFile","_totalSamples","totalSamples","_samples","_chunkDownloadsInProgress","order","denom","_denominators","_xTable","stepN","_work","_coef","getDaysSinceEpoch","xys","dayTT","secondTT","dayNumber","secondsOfDay","requestXysChunk","xysData","chunkIndex","deferred","chunkUrl","templateValues","fetchJson","chunk","samples","newSamples","startIndex","preload","startDayTT","startSecondTT","stopDayTT","stopSecondTT","startDaysSinceEpoch","stopDaysSinceEpoch","stopIndex","startChunk","stopChunk","promises","all","computeXysRadians","daysSinceEpoch","centerIndex","firstIndex","lastIndex","isDataMissing","work","sampleIndex","IauOrientationAxes","computeFunction","_computeFunction","xAxisScratch","yAxisScratch","zAxisScratch","rotMtxScratch","quatScratch","alphaDeltaW","precMtx","alpha","delta","xAxis","cosDec","zAxis","yAxis","computeRotationMatrix","rot","quat","rotMtx","IndexDatatype","UNSIGNED_BYTE","UNSIGNED_SHORT","UNSIGNED_INT","indexDatatype","sizeInBytes","numberOfVertices","indicesLengthOrArray","sourceArray","InterpolationAlgorithm","getRequiredDataPoints","interpolateOrderZero","STEP","LINEAR","CUBICSPLINE","OUTSIDE","INTERSECTING","INSIDE","IntersectionTests","ray","plane","denominator","distance","scratchEdge0","scratchEdge1","scratchPVec","scratchTVec","scratchQVec","rayTriangleParametric","p2","cullBackFaces","edge0","edge1","det","tvec","invDet","rayTriangle","scratchLineSegmentTriangleRay","lineSegmentTriangle","raySphereRoots","root0","root1","raySphere","sphere","radiusSquared","diff","roots","c","disc","solveQuadratic","stop","scratchLineSegmentRay","lineSegmentSphere","maxT","scratchQ","scratchW","addWithCancellationCheck","tolerance","difference","rayEllipsoid","inverseRadii","oneOverRadii","q2","qw","w2","product","discriminant","qw2","firstAxisScratch","secondAxisScratch","thirdAxisScratch","referenceScratch","bCart","bScratch","btScratch","diScratch","dScratch","cScratch","tempMatrix","aScratch","sScratch","closestScratch","surfPointScratch","grazingAltitudeLocation","intersects","f","transformPositionToScaledSpace","firstAxis","reference","secondAxis","thirdAxis","B","B_T","D_I","radii","D","C","A","solutions","xSquared","wSquared","l2","l1","l0","r1","r0","cosines","cosine0","sine0","cosine1","sine1","r0Squared","r1Squared","r0r1","cosine","cosineSquared","sineSquared","sine","quadraticVectorExpression","altitude","closest","maximumValue","dotProduct","surfacePoint","lineSegmentPlaneDifference","lineSegmentPlane","endPoint0","endPoint1","nDotDiff","nDotP0","trianglePlaneIntersection","planeNormal","planeD","p0Behind","p1Behind","p2Behind","numBehind","Intersections2D","threshold","keepAbove","u0Behind","u1Behind","u2Behind","u01Ratio","u02Ratio","u12Ratio","u10Ratio","u20Ratio","u21Ratio","x1","y1","x2","y2","x3","y3","x1mx3","x3mx2","y2my3","y1my3","inverseDeterminant","ymy3","xmx3","l3","x00","y00","x01","y01","x10","y10","x11","y11","denominator1","ua1","ub1","defaultTokenCredit","defaultAccessToken","Ion","defaultServer","getDefaultTokenCredit","providedKey","defaultTokenMessage","IonGeocoderService","scene","accessToken","server","frameState","creditDisplay","addDefaultCredit","searchEndpoint","appendQueryParameters","access_token","_accessToken","_server","_pelias","geocode","query","geocodeType","IonResource","endpoint","endpointResource","externalType","isExternal","retryAttempts","retryCallback","_ionEndpoint","_ionEndpointDomain","authority","_ionEndpointResource","_ionRoot","_pendingPromise","_isExternal","ionRoot","imageDefined","Image","statusCode","newEndpoint","create","fromAssetId","assetId","_createEndpointResource","getCreditsFromEndpoint","attributions","map","fetchImage","userOptions","preferBlob","flipY","preferImageBitmap","_makeRequest","headers","Authorization","resourceOptions","MINIMUM_VALUE","MAXIMUM_VALUE","MAXIMUM_INTERVAL","gregorianDateScratch","daysInMonth","compareLeapSecondDates","leapSecond","dateToFind","JulianDate","compare","julianDate","binarySearchScratchLeapSecond","convertUtcToTai","leapSeconds","secondsDifference","addSeconds","convertTaiToUtc","setComponents","wholeDays","extraDays","computeJulianDateComponents","matchCalendarYear","matchCalendarMonth","matchOrdinalDate","matchWeekDate","matchCalendarDate","utcOffset","matchHours","source","matchHoursMinutes","matchHoursMinutesSeconds","iso8601ErrorMessage","julianDayNumber","timeStandard","fromGregorianDate","components","fromDate","Date","isNaN","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","fromIso8601","iso8601String","tokens","replace","split","inLeapYear","dashCount","offsetIndex","match","dayOfYear","weekNumber","dayOfWeek","UTC","getUTCDay","setUTCDate","offsetHours","offsetMinutes","getTimezoneOffset","now","toGregorianDateScratch","toGregorianDate","thisUtc","L","N","I","J","remainingSeconds","toDate","gDate","toIso8601","precision","millisecondStr","toFixed","padStart","julianDayNumberDifference","epsilon","totalDays","daysDifference","computeTaiMinusUtc","seconds","addMinutes","minutes","newSecondsOfDay","addHours","hours","addDays","days","lessThan","lessThanOrEquals","greaterThan","greaterThanOrEquals","KTX2Transcoder","_transcodeTaskProcessor","transcode","ktx2Buffer","supportedTargetFormats","initWebAssemblyModule","modulePath","wasmBinaryFile","makeReadyPromise","parameters","view","levelsLength","faceKeys","faceKeysLength","faces","face","internalFormat","datatype","levelBuffer","SHIFT","CTRL","ALT","LagrangePolynomialApproximation","diffX","LinearApproximation","y0","x0","LinearSpline","ManagedArray","peek","resize","trim","MapProjection","unproject","CesiumMath","sign","signNotZero","toSNorm","rangeMaximum","round","clamp","fromSNorm","rangeMinimum","sinh","cosh","lerp","PI","ONE_OVER_PI","PI_OVER_TWO","PI_OVER_THREE","PI_OVER_FOUR","PI_OVER_SIX","THREE_PI_OVER_TWO","TWO_PI","ONE_OVER_TWO_PI","RADIANS_PER_DEGREE","DEGREES_PER_RADIAN","RADIANS_PER_ARCSECOND","degrees","toDegrees","radians","convertLongitudeRange","twoPi","simplified","clampToLatitudeRange","negativePiToPi","zeroToTwoPi","mod","EPSILON14","m","absDiff","factorials","sum","next","incrementWrap","minimumValue","isPowerOfTwo","nextPowerOfTwo","previousPowerOfTwo","randomNumberGenerator","setRandomNumberSeed","seed","nextRandomNumber","random","randomBetween","acosClamped","acos","asinClamped","asin","chordLength","logBase","number","base","log","cbrt","log2","LOG2E","fog","distanceToCamera","density","scalar","fastApproximateAtan","fastApproximateAtan2","opposite","adjacent","oppositeOverAdjacent","Matrix2","column0Row0","column1Row0","column0Row1","column1Row1","packArray","isArray","unpackArray","matrix","fromArray","fromColumnMajorArray","fromRowMajorArray","fromScale","scale","fromUniformScale","fromRotation","cosAngle","sinAngle","toArray","getElementIndex","column","getColumn","setColumn","getRow","setRow","scaleScratch1","setScale","existingScale","getScale","scaleRatioX","scaleRatioY","scaleScratch2","setUniformScale","scratchColumn","scaleScratch3","getMaximumScale","scaleScratch4","setRotation","scaleScratch5","getRotation","multiply","subtract","multiplyByVector","multiplyByScale","multiplyByUniformScale","negate","transpose","equalsArray","IDENTITY","ZERO","COLUMN0ROW0","COLUMN0ROW1","COLUMN1ROW0","COLUMN1ROW1","Matrix3","column2Row0","column2Row1","column0Row2","column1Row2","column2Row2","xy","xz","xw","yz","yw","z2","zw","m00","m01","m02","m10","m11","m12","m20","m21","m22","fromHeadingPitchRoll","cosTheta","cosPsi","cosPhi","sinTheta","sinPsi","sinPhi","fromCrossProduct","vector","fromRotationX","fromRotationY","fromRotationZ","scaleRatioZ","vX","vY","vZ","rowVal","colVal","offDiagonalFrobeniusNorm","norm","shurDecomposition","maxDiagonal","rotAxis","tau","jMatrix","jMatrixTranspose","computeEigenDecomposition","sweep","unitaryMatrix","unitary","diagMatrix","diagonal","computeFrobeniusNorm","determinant","m31","m32","m13","m23","m33","inverse","scratchTransposeMatrix","inverseTranspose","COLUMN0ROW2","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","Matrix4","column3Row0","column3Row1","column3Row2","column0Row3","column1Row3","column2Row3","column3Row3","fromRotationTranslation","translation","fromTranslationQuaternionRotationScale","scaleX","scaleY","scaleZ","fromTranslationRotationScale","translationRotationScale","fromTranslation","fromCameraF","fromCameraR","fromCameraU","fromCamera","camera","sX","sY","sZ","fX","fY","fZ","uX","uY","uZ","positionX","positionY","positionZ","t0","t1","t2","computePerspectiveFieldOfView","fovY","aspectRatio","near","far","tan","computeOrthographicOffCenter","tx","ty","tz","computePerspectiveOffCenter","computeInfinitePerspectiveOffCenter","computeViewportTransformation","viewport","nearDepthRange","farDepthRange","halfWidth","halfHeight","halfDepth","computeView","setTranslation","left0","left1","left2","left3","left4","left5","left6","left7","left8","left9","left10","left11","left12","left13","left14","left15","right0","right1","right2","right3","right4","right5","right6","right7","right8","right9","right10","right11","right12","right13","right14","right15","multiplyTransformation","multiplyByMatrix3","multiplyByTranslation","vW","multiplyByPointAsVector","multiplyByPoint","matrix1","matrix2","matrix3","matrix6","matrix7","matrix11","getTranslation","getMatrix3","scratchInverseRotation","scratchMatrix3Zero","scratchBottomRow","scratchExpectedBottomRow","src0","src1","src2","src3","src4","src5","src6","src7","src8","src9","src10","src11","src12","src13","src14","src15","tmp0","tmp1","tmp2","tmp3","tmp4","tmp5","tmp6","tmp7","tmp8","tmp9","tmp10","tmp11","dst0","dst1","dst2","dst3","dst4","dst5","dst6","dst7","dst8","dst9","dst10","dst11","dst12","dst13","dst14","dst15","inverseTransformation","matrix0","matrix4","matrix5","matrix8","matrix9","matrix10","COLUMN0ROW3","COLUMN1ROW3","COLUMN2ROW3","COLUMN3ROW0","COLUMN3ROW1","COLUMN3ROW2","COLUMN3ROW3","MorphWeightSpline","weights","_weights","_count","MortonOrder","insertOneSpacing","insertTwoSpacing","removeOneSpacing","removeTwoSpacing","mortonIndex","encode3D","decode3D","NearFarScalar","nearValue","farValue","nearFarScalar","Occluder","occluderBoundingSphere","cameraPosition","_occluderPosition","_occluderRadius","_horizonDistance","_horizonPlaneNormal","_horizonPlanePosition","_cameraPosition","scratchCartesian3","cameraToOccluderVec","invCameraToOccluderDistance","occluderRadiusSqrd","horizonDistance","horizonPlaneNormal","horizonPlanePosition","nearPlaneDistance","MAX_VALUE","fromBoundingSphere","tempVecScratch","isPointVisible","occludee","tempVec","occludeePositionScratch","isBoundingSphereVisible","occludeePosition","occludeeRadius","tempVecMagnitudeSquared","occluderRadiusSquared","occludeeRadiusSquared","tempScratch","computeVisibility","occludeeBS","occluderToOccludeeDistSqrd","cameraToOccludeeDistSqrd","occludeePointScratch","computeOccludeePoint","occludeePos","occluderPosition","occluderRadius","numPositions","occluderPlaneNormal","occluderPlaneD","aRotationVector","_anyRotationVector","tempDot","_horizonToPlaneNormalDotProduct","computeOccludeePointFromRectangleScratch","computeOccludeePointFromRectangle","bs","ellipsoidCenter","minimumRadius","tempVec0Scratch","tempVec0","majorAxis","tempVec1","posDirectionScratch","_rotationVector","anyRotationVector","positionDirection","crossProduct","posScratch1","occluerPosScratch","posScratch2","horizonPlanePosScratch","occluderBS","pos","positionToOccluder","occluderToPositionDistanceSquared","horizonDistanceSquared","horizonPlaneDistance","horizonCrossDistance","horizonCrossDirection","dot0","dot1","OffsetGeometryInstanceAttribute","fromCartesian3","toValue","OpenCageGeocoderService","apiKey","params","setQueryParameters","_url","_params","response","results","resultObject","destination","bounds","southwest","lng","lat","northeast","lon","geometry","displayName","formatted","OrientedBoundingBox","halfAxes","scratchCartesian1","scratchCartesian2","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCovarianceResult","scratchEigenResult","fromPoints","meanPoint","invLength","exx","exy","exz","eyy","eyz","ezz","covarianceMatrix","eigenDecomposition","v3","u3","scratchOffset","scratchScale","fromPlaneExtents","planeOrigin","planeXAxis","planeYAxis","planeZAxis","minimumX","maximumX","minimumY","maximumY","minimumZ","maximumZ","centerOffset","scratchRectangleCenterCartographic","scratchRectangleCenter","scratchPerimeterCartographicNC","scratchPerimeterCartographicNW","scratchPerimeterCartographicCW","scratchPerimeterCartographicSW","scratchPerimeterCartographicSC","scratchPerimeterCartesianNC","scratchPerimeterCartesianNW","scratchPerimeterCartesianCW","scratchPerimeterCartesianSW","scratchPerimeterCartesianSC","scratchPerimeterProjectedNC","scratchPerimeterProjectedNW","scratchPerimeterProjectedCW","scratchPerimeterProjectedSW","scratchPerimeterProjectedSC","scratchPlaneOrigin","scratchPlaneNormal","scratchPlaneXAxis","scratchHorizonCartesian","scratchHorizonProjected","scratchMaxY","scratchMinY","scratchZ","scratchPlane","fromRectangle","minX","maxX","minY","maxY","minZ","maxZ","tangentPointCartographic","tangentPoint","tangentPlane","lonCenter","latCenter","perimeterCartographicNC","perimeterCartographicNW","perimeterCartographicCW","perimeterCartographicSW","perimeterCartographicSC","perimeterCartesianNC","perimeterCartesianNW","perimeterCartesianCW","perimeterCartesianSW","perimeterCartesianSC","perimeterProjectedNC","projectPointToNearestOnPlane","perimeterProjectedNW","perimeterProjectedCW","perimeterProjectedSW","perimeterProjectedSC","fullyAboveEquator","fullyBelowEquator","latitudeNearestToEquator","centerLongitude","horizonCartesian","farZ","fromTransformation","transformation","box","intersectPlane","normalX","normalY","normalZ","radEffective","distanceToPlane","scratchCartesianU","scratchCartesianV","scratchCartesianW","scratchValidAxis2","scratchValidAxis3","scratchPPrime","distanceSquaredTo","uHalf","vHalf","wHalf","uValid","vValid","wValid","numberOfDegenerateAxes","validAxis1","validAxis2","validAxis3","degenerateAxis","crossVector","pPrime","distanceSquared","scratchCorner","scratchToCenter","computePlaneDistances","minDist","maxDist","corner","toCenter","mag","scratchXAxis","scratchYAxis","scratchZAxis","computeCorners","scratchRotationScale","computeTransformation","rotationScale","scratchBoundingSphere","isOccluded","occluder","OrthographicFrustum","_offCenterFrustum","_aspectRatio","_near","_far","update","frustum","ratio","projectionMatrix","computeCullingVolume","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","pixelRatio","other","OrthographicOffCenterFrustum","_left","_right","_top","_bottom","_cullingVolume","_orthographicMatrix","getPlanesRight","getPlanesNearCenter","getPlanesPoint","negateScratch","planes","nearCenter","point","pixelWidth","pixelHeight","packedInterpolationLength","convertPackedArrayForInterpolation","unpackInterpolationResult","PeliasGeocoderService","text","features","bboxDegrees","bbox","coordinates","properties","label","PerspectiveFrustum","fov","_fov","_fovy","_sseDenominator","xOffset","_xOffset","yOffset","_yOffset","infiniteProjectionMatrix","fovy","sseDenominator","PerspectiveOffCenterFrustum","_perspectiveMatrix","_infinitePerspective","getPlanesFarCenter","getPlanesNormal","farCenter","inverseNear","tanTheta","PinBuilder","_cache","fromColor","color","size","createPin","fromUrl","fromMakiIconId","id","encodeURIComponent","fromText","colorScratch","drawIcon","context2D","image","imageSize","sizeX","sizeY","globalCompositeOperation","drawImage","fillStyle","fillRect","stringifyScratch","cache","JSON","stringify","item","canvas","document","createElement","getContext","save","toCssColorString","strokeStyle","brighten","lineWidth","beginPath","moveTo","lineTo","bezierCurveTo","closePath","fill","stroke","restore","drawPin","font","PixelFormat","DEPTH_COMPONENT","DEPTH_STENCIL","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","RGB_DXT1","RGBA_DXT1","RGBA_DXT3","RGBA_DXT5","RGB_PVRTC_4BPPV1","RGB_PVRTC_2BPPV1","RGBA_PVRTC_4BPPV1","RGBA_PVRTC_2BPPV1","RGBA_ASTC","RGB_ETC1","RGB8_ETC2","RGBA8_ETC2_EAC","RGBA_BC7","pixelFormat","pixelDatatype","componentsLength","textureSizeInBytes","bufferView","flipped","createTypedArray","numberOfComponents","textureWidth","flippedRow","context","webgl2","RG","R","Plane","fromPointNormal","scratchNormal","fromCartesian4","getPointDistance","scratchCartesian","projectPointOntoPlane","pointDistance","scaledNormal","scratchInverseTranspose","scratchPlaneCartesian4","scratchTransformNormal","transform","planeAsCartesian4","transformedNormal","ORIGIN_XY_PLANE","ORIGIN_YZ_PLANE","ORIGIN_ZX_PLANE","PlaneGeometry","vertexFormat","_vertexFormat","scratchVertexFormat","scratchOptions","planeGeometry","normals","st","texCoords","tangent","bitangent","bitangents","primitiveType","PlaneOutlineGeometry","scratchCarto1","scratchCarto2","adjustPosHeightsForNormal","p1Carto","p2Carto","scratchBoundingRectangle","scratchPosition","scratchTangent","scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","appendTextureCoordinatesMatrix3","tangentMatrixScratch","computeAttributes","shadowVolume","flatPositions","flatTexcoords","wall","boundingRectangle","stRotation","perPositionHeight","textureCoordinates","extrudeNormals","textureCoordIndex","attrIndex","recomputeNormal","textureMatrix","tangentRotationMatrix","_plane","bottomOffset","bottomOffset2","scaleToGeodeticSurface","stx","sty","attrIndex1","attrIndex2","extrudeDirection","extrude","offsetAttribute","offsetValue","applyOffset","idlCross","westOverIDL","eastOverIDL","ellipsoidGeodesic","computeRectangle","inverseChordLength","interpolateAndGrowRectangle","segmentLength","subsegmentDistance","interpolationDistance","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","polygon","hierarchy","closeTop","closeBottom","geos","walls","topGeo","edgePoints","newIndices","topBottomPositions","concat","ilength","texcoords","topAndBottom","outerRing","positions2D","projectPointsOntoPlane","windingOrder","reverse","wallGeo","holes","hole","PolygonGeometry","polygonHierarchy","perPositionHeightExtrude","extrudedHeight","h","_granularity","_stRotation","_extrudedHeight","_closeTop","_closeBottom","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_shadowVolume","_offsetAttribute","_arcType","_rectangle","_textureCoordinateRotationPoints","_textureCoordinates","fromPositions","scratchEllipsoid","dummyOptions","polygonGeometry","hasTextureCoordinates","outerPositions","bind","polygons","textureCoordinatePolygons","identity","geometries","splitGeometry","geometryInstance","createShadowVolume","minHeightFunc","maxHeightFunc","textureCoordinateRotationPoints","PolygonGeometryLibrary","CartesianX","numComponents","stack","holesLength","unpackPolygonHierarchy","distance2DScratch","getPointAtDistance2D","distanceScratch","getPointAtDistance","subdivideLineCount","minDistance","countDivide","scratchCartographic0","scratchCartographic1","scratchCartographic2","scratchCartesian0","scratchRhumbLine","subdivideRhumbLineCount","subdivideTexcoordLine","subdivisions","distanceBetweenCoords","subdivideLine","numVertices","distanceBetweenVertices","subdivideTexcoordRhumbLine","subdivideRhumbLine","rhumb","scaleToGeodeticHeightN1","scaleToGeodeticHeightN2","scaleToGeodeticHeightP1","scaleToGeodeticHeightP2","scaleToGeodeticHeightExtruded","n1","n2","polygonOutlinesFromHierarchy","scaleToEllipsoidSurface","queue","enqueue","outerNode","dequeue","numChildren","holePositions","numGrandchildren","polygonsFromHierarchy","keepDuplicates","projectPointsTo2D","holeIndices","originalWindingOrder","polygonHoles","holePositions2D","computeBoundingRectangleCartesian2","computeBoundingRectangleCartesian3","computeBoundingRectangleQuaternion","computeBoundingRectangleMatrix3","computeBoundingRectangle","projectPointTo2D","createGeometryFromPositions","hasTexcoords","flattenedPositions","geometryOptions","computeWallTexcoordsSubdivided","computeWallIndicesSubdivided","computeWallGeometry","edgePositions","topEdgeLength","edgeTexcoords","topEdgeTexcoordLength","textureIndex","tempPositions","tempTexcoords","tempPositionsLength","tempTexcoordsLength","edgeIndex","UL","UR","LL","LR","createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","subdividedPositions","indicesSize","corners","cornersLength","PolygonOutlineGeometry","scaleToGeodeticHeightN","scaleToGeodeticHeightP","PolygonPipeline","area","computeArea2D","subdivisionV0Scratch","subdivisionV1Scratch","subdivisionV2Scratch","subdivisionS0Scratch","subdivisionS1Scratch","subdivisionS2Scratch","subdivisionMidScratch","subdivisionT0Scratch","subdivisionT1Scratch","subdivisionT2Scratch","subdivisionTexcoordMidScratch","computeSubdivision","triangles","subdividedTexcoords","texcoordItem","subdividedIndices","edges","minDistanceSqrd","s0","s1","s2","g0","g1","g2","edge","mid","midTexcoord","subdivisionC0Scratch","subdivisionC1Scratch","subdivisionC2Scratch","subdivisionCartographicScratch","computeRhumbLineSubdivision","rhumb0","rhumb1","rhumb2","midHeight","midCartesian3","interpolateUsingFraction","scaleToGeodeticHeight","scaleToSurface","scratchInterpolateColorsArray","interpolateColors","color0","color1","colors","red","green","b0","blue","a0","b1","a1","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","PolylineGeometry","colorsPerVertex","_colors","_colorsPerVertex","scratchPrevPosition","scratchNextPosition","polylineGeometry","removedIndices","removedArrayIndex","nextRemovedIndex","filter","remove","subdivisionSize","numberOfPointsFunction","colorLength","newColors","newColorIndex","numColors","interpolatedColors","interpolatedColorsLength","finalPositions","prevPositions","nextPositions","expandAndWidth","finalColors","positionIndex","expandAndWidthIndex","stIndex","colorIndex","endK","prevPosition","nextPosition","indicesIndex","geometryType","PolylinePipeline","radiansDistanceSquared","cartoScratch","extractHeights","wrapLongitudeInversMatrix","wrapLongitudeOrigin","wrapLongitudeXZNormal","wrapLongitudeXZPlane","wrapLongitudeYZNormal","wrapLongitudeYZPlane","wrapLongitudeIntersection","wrapLongitudeOffset","subdivideHeightsScratchArray","subdivideHeights","heightPerVertex","carto1","carto2","scaleFirst","scaleLast","ellipsoidRhumb","generateCartesianArc","first","numberOfPoints","surfaceDistanceBetweenPoints","cart","carto","generateCartesianRhumbArc","numberOfPointsRhumbLine","wrapLongitude","modelMatrix","cartesians","inverseModelMatrix","xzNormal","xzPlane","yzNormal","yzPlane","prev","cur","lengths","generateArc","hasHeightArray","arrayLength","newPositions","lastPoint","generateRhumbArc","numberArray","PolylineVolumeGeometry","polylinePositions","shape","shapePositions","_shape","_cornerType","cornerType","brScratch","polylineVolumeGeometry","cleanPositions","shape2D","combinedPositions","shapeLength","firstEndIndices","indicesCount","ll","ul","ur","lr","lengthSt","heightSt","stindex","endOffset","scratch2Array","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","angleBetween","nextScratch","prevScratch","negativeX","rotationZ","scaleMatrix","westScratch","finalPosScratch","heightCartesian","addPosition","xScalar","repeat","finalPosition","computeRotationAngle","centerScratch","addPositions","centers","convertShapeTo3D","quaterion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","leftIsOutside","duplicatePoints","removeDuplicatesFromShape","cleanedPositions","angleIsGreaterThanPi","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","shapeForSides","convertShapeTo3DDuplicate","shapeForEnds","ends","cornerDirection","surfaceNormal","previousPosition","subdividedHeights","forwardProjection","backwardProjection","posLength","PolylineVolumeOutlineGeometry","polylineVolumeOutlineGeometry","shapeCount","firstOffset","secondOffset","PrimitiveType","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","Proxy","getURL","QuadraticRealPolynomial","computeDiscriminant","computeRealRoots","cMagnitude","aMagnitude","radicand","QuantizedMeshTerrainData","_quantizedVertices","_encodedNormals","encodedNormals","_indices","_boundingSphere","_orientedBoundingBox","_horizonOcclusionPoint","uValues","_uValues","subarray","vValues","_vValues","sortByV","sortByU","_heightValues","_westIndices","sortIndicesIfNecessary","_southIndices","_eastIndices","_northIndices","_westSkirtHeight","_southSkirtHeight","_eastSkirtHeight","_northSkirtHeight","canUpsample","sortFunction","needsSort","octEncodedNormals","rtc","obb","vertexStride","terrainEncoding","shortestSkirt","maxShort","pointInBoundingBox","minU","maxU","minV","maxV","heightBuffer","quantizedHeight","QuarticRealPolynomial","original","a3","a2","a3Squared","cubicRoots","hSquared","roots1","roots2","neumark","tempSquared","mError","nError","G","g","H","squareRootOfN","squareRootOfM","b2","b3","d2","d3","e2","Quaternion","fromAxisAngleScratch","fromAxisAngle","axis","halfAngle","fromRotationMatrixNext","fromRotationMatrixQuat","fromRotationMatrix","trace","scratchHPRQuaternion","scratchHeadingQuaternion","scratchPitchQuaternion","scratchRollQuaternion","sampledQuaternionAxis","sampledQuaternionRotation","sampledQuaternionTempQuaternion","sampledQuaternionQuaternion0","sampledQuaternionQuaternion0Conjugate","packedArray","conjugate","computeAxis","computeAngle","magnitude","magnitudeSquared","inverseMagnitude","leftX","leftY","leftZ","leftW","rightX","rightY","rightZ","rightW","divideByScalar","lerpScratch","slerpEndNegated","slerpScaledP","slerpScaledR","slerp","theta","thetaOverSinTheta","sinThetaOverTheta","squadScratchCartesian0","squadScratchCartesian1","squadScratchQuaternion0","squadScratchQuaternion1","computeInnerQuadrangle","q0","q1","qInv","cart0","cart1","squad","slerp0","slerp1","fastSlerpScratchQuaternion","opmu","bT","bD","fastSlerp","xm1","sqrT","sqrD","cT","cD","fastSquad","QuaternionSpline","_evaluateFunction","spline","createEvaluateFunction","Queue","_offset","contains","indexOf","clear","compareFunction"],"sourceRoot":""}