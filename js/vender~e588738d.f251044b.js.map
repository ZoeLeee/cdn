{"version":3,"file":"js/vender~e588738d.f251044b.js","mappings":"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","sources":["webpack:///../../../node_modules/@babylonjs/core/Meshes/geodesicMesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/geometry.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/goldbergMesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/groundMesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/meshSimplification.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/csg.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/trailMesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/meshBuilder.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/meshSimplificationSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/instancedMesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/linesMesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/mesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/mesh.vertexData.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/meshLODLevel.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/polygonMesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/subMesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/subMesh.project.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js","webpack:///../../../node_modules/@babylonjs/core/Meshes/transformNode.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { PHI } from \"../Maths/math.constants.js\";\nimport { _IsoVector } from \"../Maths/math.isovector.js\";\n/**\n * Class representing data for one face OAB of an equilateral icosahedron\n * When O is the isovector (0, 0), A is isovector (m, n)\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar _PrimaryIsoTriangle = /** @class */ (function () {\n    function _PrimaryIsoTriangle() {\n        this.cartesian = [];\n        this.vertices = [];\n        this.max = [];\n        this.min = [];\n        this.closestTo = [];\n        this.innerFacets = [];\n        this.isoVecsABOB = [];\n        this.isoVecsOBOA = [];\n        this.isoVecsBAOA = [];\n        this.vertexTypes = [];\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        this.IDATA = new PolyhedronData(\"icosahedron\", \"Regular\", [\n            [0, PHI, -1],\n            [-PHI, 1, 0],\n            [-1, 0, -PHI],\n            [1, 0, -PHI],\n            [PHI, 1, 0],\n            [0, PHI, 1],\n            [-1, 0, PHI],\n            [-PHI, -1, 0],\n            [0, -PHI, -1],\n            [PHI, -1, 0],\n            [1, 0, PHI],\n            [0, -PHI, 1],\n        ], [\n            [0, 2, 1],\n            [0, 3, 2],\n            [0, 4, 3],\n            [0, 5, 4],\n            [0, 1, 5],\n            [7, 6, 1],\n            [8, 7, 2],\n            [9, 8, 3],\n            [10, 9, 4],\n            [6, 10, 5],\n            [2, 7, 1],\n            [3, 8, 2],\n            [4, 9, 3],\n            [5, 10, 4],\n            [1, 6, 5],\n            [11, 6, 7],\n            [11, 7, 8],\n            [11, 8, 9],\n            [11, 9, 10],\n            [11, 10, 6],\n        ]);\n    }\n    /**\n     * Creates the PrimaryIsoTriangle Triangle OAB\n     * @param m an integer\n     * @param n an integer\n     */\n    //operators\n    _PrimaryIsoTriangle.prototype.setIndices = function () {\n        var indexCount = 12; // 12 vertices already assigned\n        var vecToidx = {}; //maps iso-vectors to indexCount;\n        var m = this.m;\n        var n = this.n;\n        var g = m; // hcf of m, n when n != 0\n        var m1 = 1;\n        var n1 = 0;\n        if (n !== 0) {\n            g = Scalar.HCF(m, n);\n        }\n        m1 = m / g;\n        n1 = n / g;\n        var fr; //face to the right of current face\n        var rot; //rotation about which vertex for fr\n        var O;\n        var A;\n        var B;\n        var oVec = _IsoVector.Zero();\n        var aVec = new _IsoVector(m, n);\n        var bVec = new _IsoVector(-n, m + n);\n        var oaVec = _IsoVector.Zero();\n        var abVec = _IsoVector.Zero();\n        var obVec = _IsoVector.Zero();\n        var verts = [];\n        var idx;\n        var idxR;\n        var isoId;\n        var isoIdR;\n        var closestTo = [];\n        var vDist = this.vertByDist;\n        var matchIdx = function (f, fr, isoId, isoIdR) {\n            idx = f + \"|\" + isoId;\n            idxR = fr + \"|\" + isoIdR;\n            if (!(idx in vecToidx || idxR in vecToidx)) {\n                vecToidx[idx] = indexCount;\n                vecToidx[idxR] = indexCount;\n                indexCount++;\n            }\n            else if (idx in vecToidx && !(idxR in vecToidx)) {\n                vecToidx[idxR] = vecToidx[idx];\n            }\n            else if (idxR in vecToidx && !(idx in vecToidx)) {\n                vecToidx[idx] = vecToidx[idxR];\n            }\n            if (vDist[isoId][0] > 2) {\n                closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\n            }\n            else {\n                closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\n            }\n        };\n        this.IDATA.edgematch = [\n            [1, \"B\"],\n            [2, \"B\"],\n            [3, \"B\"],\n            [4, \"B\"],\n            [0, \"B\"],\n            [10, \"O\", 14, \"A\"],\n            [11, \"O\", 10, \"A\"],\n            [12, \"O\", 11, \"A\"],\n            [13, \"O\", 12, \"A\"],\n            [14, \"O\", 13, \"A\"],\n            [0, \"O\"],\n            [1, \"O\"],\n            [2, \"O\"],\n            [3, \"O\"],\n            [4, \"O\"],\n            [19, \"B\", 5, \"A\"],\n            [15, \"B\", 6, \"A\"],\n            [16, \"B\", 7, \"A\"],\n            [17, \"B\", 8, \"A\"],\n            [18, \"B\", 9, \"A\"],\n        ];\n        /***edges AB to OB***** rotation about B*/\n        for (var f = 0; f < 20; f++) {\n            //f current face\n            verts = this.IDATA.face[f];\n            O = verts[2];\n            A = verts[1];\n            B = verts[0];\n            isoId = oVec.x + \"|\" + oVec.y;\n            idx = f + \"|\" + isoId;\n            if (!(idx in vecToidx)) {\n                vecToidx[idx] = O;\n                closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];\n            }\n            isoId = aVec.x + \"|\" + aVec.y;\n            idx = f + \"|\" + isoId;\n            if (!(idx in vecToidx)) {\n                vecToidx[idx] = A;\n                closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];\n            }\n            isoId = bVec.x + \"|\" + bVec.y;\n            idx = f + \"|\" + isoId;\n            if (!(idx in vecToidx)) {\n                vecToidx[idx] = B;\n                closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];\n            }\n            //for edge vertices\n            fr = this.IDATA.edgematch[f][0];\n            rot = this.IDATA.edgematch[f][1];\n            if (rot === \"B\") {\n                for (var i = 1; i < g; i++) {\n                    abVec.x = m - i * (m1 + n1);\n                    abVec.y = n + i * m1;\n                    obVec.x = -i * n1;\n                    obVec.y = i * (m1 + n1);\n                    isoId = abVec.x + \"|\" + abVec.y;\n                    isoIdR = obVec.x + \"|\" + obVec.y;\n                    matchIdx(f, fr, isoId, isoIdR);\n                }\n            }\n            if (rot === \"O\") {\n                for (var i = 1; i < g; i++) {\n                    obVec.x = -i * n1;\n                    obVec.y = i * (m1 + n1);\n                    oaVec.x = i * m1;\n                    oaVec.y = i * n1;\n                    isoId = obVec.x + \"|\" + obVec.y;\n                    isoIdR = oaVec.x + \"|\" + oaVec.y;\n                    matchIdx(f, fr, isoId, isoIdR);\n                }\n            }\n            fr = this.IDATA.edgematch[f][2];\n            rot = this.IDATA.edgematch[f][3];\n            if (rot && rot === \"A\") {\n                for (var i = 1; i < g; i++) {\n                    oaVec.x = i * m1;\n                    oaVec.y = i * n1;\n                    abVec.x = m - (g - i) * (m1 + n1); //reversed for BA\n                    abVec.y = n + (g - i) * m1; //reversed for BA\n                    isoId = oaVec.x + \"|\" + oaVec.y;\n                    isoIdR = abVec.x + \"|\" + abVec.y;\n                    matchIdx(f, fr, isoId, isoIdR);\n                }\n            }\n            for (var i = 0; i < this.vertices.length; i++) {\n                isoId = this.vertices[i].x + \"|\" + this.vertices[i].y;\n                idx = f + \"|\" + isoId;\n                if (!(idx in vecToidx)) {\n                    vecToidx[idx] = indexCount++;\n                    if (vDist[isoId][0] > 2) {\n                        closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\n                    }\n                    else {\n                        closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\n                    }\n                }\n            }\n        }\n        this.closestTo = closestTo;\n        this.vecToidx = vecToidx;\n    };\n    _PrimaryIsoTriangle.prototype.calcCoeffs = function () {\n        var m = this.m;\n        var n = this.n;\n        var thirdR3 = Math.sqrt(3) / 3;\n        var LSQD = m * m + n * n + m * n;\n        this.coau = (m + n) / LSQD;\n        this.cobu = -n / LSQD;\n        this.coav = (-thirdR3 * (m - n)) / LSQD;\n        this.cobv = (thirdR3 * (2 * m + n)) / LSQD;\n    };\n    _PrimaryIsoTriangle.prototype.createInnerFacets = function () {\n        var m = this.m;\n        var n = this.n;\n        for (var y = 0; y < n + m + 1; y++) {\n            for (var x = this.min[y]; x < this.max[y] + 1; x++) {\n                if (x < this.max[y] && x < this.max[y + 1] + 1) {\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + x + \"|\" + (y + 1), \"|\" + (x + 1) + \"|\" + y]);\n                }\n                if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + (x + 1) + \"|\" + y, \"|\" + (x + 1) + \"|\" + (y - 1)]);\n                }\n            }\n        }\n    };\n    _PrimaryIsoTriangle.prototype.edgeVecsABOB = function () {\n        var m = this.m;\n        var n = this.n;\n        var B = new _IsoVector(-n, m + n);\n        for (var y = 1; y < m + n; y++) {\n            var point = new _IsoVector(this.min[y], y);\n            var prev = new _IsoVector(this.min[y - 1], y - 1);\n            var next = new _IsoVector(this.min[y + 1], y + 1);\n            var pointR = point.clone();\n            var prevR = prev.clone();\n            var nextR = next.clone();\n            pointR.rotate60About(B);\n            prevR.rotate60About(B);\n            nextR.rotate60About(B);\n            var maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);\n            var maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);\n            var maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);\n            if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {\n                if (pointR.x !== maxPrev.x) {\n                    // type2\n                    //up\n                    this.vertexTypes.push([1, 0, 0]);\n                    this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);\n                    //down\n                    this.vertexTypes.push([1, 0, 0]);\n                    this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);\n                }\n                else if (pointR.y === nextR.y) {\n                    // type1\n                    //up\n                    this.vertexTypes.push([1, 1, 0]);\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\n                    //down\n                    this.vertexTypes.push([1, 0, 1]);\n                    this.isoVecsABOB.push([point, maxPrev, next]);\n                }\n                else {\n                    // type 0\n                    //up\n                    this.vertexTypes.push([1, 1, 0]);\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\n                    //down\n                    this.vertexTypes.push([1, 0, 0]);\n                    this.isoVecsABOB.push([point, maxPrev, maxPoint]);\n                }\n            }\n        }\n    };\n    _PrimaryIsoTriangle.prototype.mapABOBtoOBOA = function () {\n        var point = new _IsoVector(0, 0);\n        for (var i = 0; i < this.isoVecsABOB.length; i++) {\n            var temp = [];\n            for (var j = 0; j < 3; j++) {\n                point.x = this.isoVecsABOB[i][j].x;\n                point.y = this.isoVecsABOB[i][j].y;\n                if (this.vertexTypes[i][j] === 0) {\n                    point.rotateNeg120(this.m, this.n);\n                }\n                temp.push(point.clone());\n            }\n            this.isoVecsOBOA.push(temp);\n        }\n    };\n    _PrimaryIsoTriangle.prototype.mapABOBtoBAOA = function () {\n        var point = new _IsoVector(0, 0);\n        for (var i = 0; i < this.isoVecsABOB.length; i++) {\n            var temp = [];\n            for (var j = 0; j < 3; j++) {\n                point.x = this.isoVecsABOB[i][j].x;\n                point.y = this.isoVecsABOB[i][j].y;\n                if (this.vertexTypes[i][j] === 1) {\n                    point.rotate120(this.m, this.n);\n                }\n                temp.push(point.clone());\n            }\n            this.isoVecsBAOA.push(temp);\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    _PrimaryIsoTriangle.prototype.MapToFace = function (faceNb, geodesicData) {\n        var F = this.IDATA.face[faceNb];\n        var oidx = F[2];\n        var aidx = F[1];\n        var bidx = F[0];\n        var O = Vector3.FromArray(this.IDATA.vertex[oidx]);\n        var A = Vector3.FromArray(this.IDATA.vertex[aidx]);\n        var B = Vector3.FromArray(this.IDATA.vertex[bidx]);\n        var OA = A.subtract(O);\n        var OB = B.subtract(O);\n        var x = OA.scale(this.coau).add(OB.scale(this.cobu));\n        var y = OA.scale(this.coav).add(OB.scale(this.cobv));\n        var mapped = [];\n        var idx;\n        var tempVec = TmpVectors.Vector3[0];\n        for (var i = 0; i < this.cartesian.length; i++) {\n            tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);\n            mapped[i] = [tempVec.x, tempVec.y, tempVec.z];\n            idx = faceNb + \"|\" + this.vertices[i].x + \"|\" + this.vertices[i].y;\n            geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];\n        }\n    };\n    //statics\n    /**Creates a primary triangle\n     * @param m\n     * @param n\n     * @hidden\n     */\n    _PrimaryIsoTriangle.prototype.build = function (m, n) {\n        var vertices = new Array();\n        var O = _IsoVector.Zero();\n        var A = new _IsoVector(m, n);\n        var B = new _IsoVector(-n, m + n);\n        vertices.push(O, A, B);\n        //max internal isoceles triangle vertices\n        for (var y_1 = n; y_1 < m + 1; y_1++) {\n            for (var x_1 = 0; x_1 < m + 1 - y_1; x_1++) {\n                vertices.push(new _IsoVector(x_1, y_1));\n            }\n        }\n        //shared vertices along edges when needed\n        if (n > 0) {\n            var g = Scalar.HCF(m, n);\n            var m1 = m / g;\n            var n1 = n / g;\n            for (var i = 1; i < g; i++) {\n                vertices.push(new _IsoVector(i * m1, i * n1)); //OA\n                vertices.push(new _IsoVector(-i * n1, i * (m1 + n1))); //OB\n                vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1)); // AB\n            }\n            //lower rows vertices and their rotations\n            var ratio = m / n;\n            for (var y_2 = 1; y_2 < n; y_2++) {\n                for (var x_2 = 0; x_2 < y_2 * ratio; x_2++) {\n                    vertices.push(new _IsoVector(x_2, y_2));\n                    vertices.push(new _IsoVector(x_2, y_2).rotate120(m, n));\n                    vertices.push(new _IsoVector(x_2, y_2).rotateNeg120(m, n));\n                }\n            }\n        }\n        //order vertices by x and then y\n        vertices.sort(function (a, b) {\n            return a.x - b.x;\n        });\n        vertices.sort(function (a, b) {\n            return a.y - b.y;\n        });\n        var min = new Array(m + n + 1);\n        var max = new Array(m + n + 1);\n        for (var i = 0; i < min.length; i++) {\n            min[i] = Infinity;\n            max[i] = -Infinity;\n        }\n        var y = 0;\n        var x = 0;\n        var len = vertices.length;\n        for (var i = 0; i < len; i++) {\n            x = vertices[i].x;\n            y = vertices[i].y;\n            min[y] = Math.min(x, min[y]);\n            max[y] = Math.max(x, max[y]);\n        }\n        //calculates the distance of a vertex from a given primary vertex\n        var distFrom = function (vert, primVert) {\n            var v = vert.clone();\n            if (primVert === \"A\") {\n                v.rotateNeg120(m, n);\n            }\n            if (primVert === \"B\") {\n                v.rotate120(m, n);\n            }\n            if (v.x < 0) {\n                return v.y;\n            }\n            return v.x + v.y;\n        };\n        var cartesian = [];\n        var distFromO = [];\n        var distFromA = [];\n        var distFromB = [];\n        var vertByDist = {};\n        var vertData = [];\n        var closest = -1;\n        var dist = -1;\n        for (var i = 0; i < len; i++) {\n            cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);\n            distFromO[i] = distFrom(vertices[i], \"O\");\n            distFromA[i] = distFrom(vertices[i], \"A\");\n            distFromB[i] = distFrom(vertices[i], \"B\");\n            if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {\n                closest = 3;\n                dist = distFromO[i];\n            }\n            else if (distFromO[i] === distFromA[i]) {\n                closest = 4;\n                dist = distFromO[i];\n            }\n            else if (distFromA[i] === distFromB[i]) {\n                closest = 5;\n                dist = distFromA[i];\n            }\n            else if (distFromB[i] === distFromO[i]) {\n                closest = 6;\n                dist = distFromO[i];\n            }\n            if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {\n                closest = 2;\n                dist = distFromO[i];\n            }\n            if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {\n                closest = 1;\n                dist = distFromA[i];\n            }\n            if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {\n                closest = 0;\n                dist = distFromB[i];\n            }\n            vertData.push([closest, dist, vertices[i].x, vertices[i].y]);\n        }\n        vertData.sort(function (a, b) {\n            return a[2] - b[2];\n        });\n        vertData.sort(function (a, b) {\n            return a[3] - b[3];\n        });\n        vertData.sort(function (a, b) {\n            return a[1] - b[1];\n        });\n        vertData.sort(function (a, b) {\n            return a[0] - b[0];\n        });\n        for (var v = 0; v < vertData.length; v++) {\n            vertByDist[vertData[v][2] + \"|\" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];\n        }\n        this.m = m;\n        this.n = n;\n        this.vertices = vertices;\n        this.vertByDist = vertByDist;\n        this.cartesian = cartesian;\n        this.min = min;\n        this.max = max;\n        return this;\n    };\n    return _PrimaryIsoTriangle;\n}());\nexport { _PrimaryIsoTriangle };\n/** Builds Polyhedron Data\n * @hidden\n */\nvar PolyhedronData = /** @class */ (function () {\n    function PolyhedronData(name, category, vertex, face) {\n        this.name = name;\n        this.category = category;\n        this.vertex = vertex;\n        this.face = face;\n    }\n    return PolyhedronData;\n}());\nexport { PolyhedronData };\n/**\n * This class Extends the PolyhedronData Class to provide measures for a Geodesic Polyhedron\n */\nvar GeodesicData = /** @class */ (function (_super) {\n    __extends(GeodesicData, _super);\n    function GeodesicData() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param face\n     * @param primTri\n     * @hidden\n     */\n    GeodesicData.prototype.innerToData = function (face, primTri) {\n        for (var i = 0; i < primTri.innerFacets.length; i++) {\n            this.face.push(primTri.innerFacets[i].map(function (el) { return primTri.vecToidx[face + el]; }));\n        }\n    };\n    /**\n     * @param faceNb\n     * @param primTri\n     * @hidden\n     */\n    GeodesicData.prototype.mapABOBtoDATA = function (faceNb, primTri) {\n        var fr = primTri.IDATA.edgematch[faceNb][0];\n        for (var i = 0; i < primTri.isoVecsABOB.length; i++) {\n            var temp = [];\n            for (var j = 0; j < 3; j++) {\n                if (primTri.vertexTypes[i][j] === 0) {\n                    temp.push(faceNb + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\n                }\n                else {\n                    temp.push(fr + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\n                }\n            }\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\n        }\n    };\n    /**\n     * @param faceNb\n     * @param primTri\n     * @hidden\n     */\n    GeodesicData.prototype.mapOBOAtoDATA = function (faceNb, primTri) {\n        var fr = primTri.IDATA.edgematch[faceNb][0];\n        for (var i = 0; i < primTri.isoVecsOBOA.length; i++) {\n            var temp = [];\n            for (var j = 0; j < 3; j++) {\n                if (primTri.vertexTypes[i][j] === 1) {\n                    temp.push(faceNb + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\n                }\n                else {\n                    temp.push(fr + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\n                }\n            }\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\n        }\n    };\n    /**\n     * @param faceNb\n     * @param primTri\n     * @hidden\n     */\n    GeodesicData.prototype.mapBAOAtoDATA = function (faceNb, primTri) {\n        var fr = primTri.IDATA.edgematch[faceNb][2];\n        for (var i = 0; i < primTri.isoVecsBAOA.length; i++) {\n            var temp = [];\n            for (var j = 0; j < 3; j++) {\n                if (primTri.vertexTypes[i][j] === 1) {\n                    temp.push(faceNb + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\n                }\n                else {\n                    temp.push(fr + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\n                }\n            }\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\n        }\n    };\n    /**\n     * @param primTri\n     * @hidden\n     */\n    GeodesicData.prototype.orderData = function (primTri) {\n        var nearTo = [];\n        for (var i = 0; i < 13; i++) {\n            nearTo[i] = [];\n        }\n        var close = primTri.closestTo;\n        for (var i = 0; i < close.length; i++) {\n            if (close[i][0] > -1) {\n                if (close[i][1] > 0) {\n                    nearTo[close[i][0]].push([i, close[i][1]]);\n                }\n            }\n            else {\n                nearTo[12].push([i, close[i][0]]);\n            }\n        }\n        var near = [];\n        for (var i = 0; i < 12; i++) {\n            near[i] = i;\n        }\n        var nearIndex = 12;\n        for (var i = 0; i < 12; i++) {\n            nearTo[i].sort(function (a, b) {\n                return a[1] - b[1];\n            });\n            for (var j = 0; j < nearTo[i].length; j++) {\n                near[nearTo[i][j][0]] = nearIndex++;\n            }\n        }\n        for (var j = 0; j < nearTo[12].length; j++) {\n            near[nearTo[12][j][0]] = nearIndex++;\n        }\n        for (var i = 0; i < this.vertex.length; i++) {\n            this.vertex[i].push(near[i]);\n        }\n        this.vertex.sort(function (a, b) {\n            return a[3] - b[3];\n        });\n        for (var i = 0; i < this.vertex.length; i++) {\n            this.vertex[i].pop();\n        }\n        for (var i = 0; i < this.face.length; i++) {\n            for (var j = 0; j < this.face[i].length; j++) {\n                this.face[i][j] = near[this.face[i][j]];\n            }\n        }\n        this.sharedNodes = nearTo[12].length;\n        this.poleNodes = this.vertex.length - this.sharedNodes;\n    };\n    /**\n     * @param m\n     * @param faces\n     * @hidden\n     */\n    GeodesicData.prototype.setOrder = function (m, faces) {\n        var adjVerts = [];\n        var dualFaces = [];\n        var face = faces.pop();\n        dualFaces.push(face);\n        var index = this.face[face].indexOf(m);\n        index = (index + 2) % 3;\n        var v = this.face[face][index];\n        adjVerts.push(v);\n        var f = 0;\n        while (faces.length > 0) {\n            face = faces[f];\n            if (this.face[face].indexOf(v) > -1) {\n                // v is a vertex of face f\n                index = (this.face[face].indexOf(v) + 1) % 3;\n                v = this.face[face][index];\n                adjVerts.push(v);\n                dualFaces.push(face);\n                faces.splice(f, 1);\n                f = 0;\n            }\n            else {\n                f++;\n            }\n        }\n        this.adjacentFaces.push(adjVerts);\n        return dualFaces;\n    };\n    /**\n     * @hidden\n     */\n    GeodesicData.prototype.toGoldbergPolyhedronData = function () {\n        var _this = this;\n        var goldbergPolyhedronData = new PolyhedronData(\"GeoDual\", \"Goldberg\", [], []);\n        goldbergPolyhedronData.name = \"GD dual\";\n        var verticesNb = this.vertex.length;\n        var map = new Array(verticesNb);\n        for (var v = 0; v < verticesNb; v++) {\n            map[v] = [];\n        }\n        for (var f = 0; f < this.face.length; f++) {\n            for (var i = 0; i < 3; i++) {\n                map[this.face[f][i]].push(f);\n            }\n        }\n        var cx = 0;\n        var cy = 0;\n        var cz = 0;\n        var face = [];\n        var vertex = [];\n        this.adjacentFaces = [];\n        for (var m = 0; m < map.length; m++) {\n            goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));\n            map[m].forEach(function (el) {\n                cx = 0;\n                cy = 0;\n                cz = 0;\n                face = _this.face[el];\n                for (var i = 0; i < 3; i++) {\n                    vertex = _this.vertex[face[i]];\n                    cx += vertex[0];\n                    cy += vertex[1];\n                    cz += vertex[2];\n                }\n                goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];\n            });\n        }\n        return goldbergPolyhedronData;\n    };\n    //statics\n    /**Builds the data for a Geodesic Polyhedron from a primary triangle\n     * @param primTri the primary triangle\n     * @hidden\n     */\n    GeodesicData.BuildGeodesicData = function (primTri) {\n        var geodesicData = new GeodesicData(\"Geodesic-m-n\", \"Geodesic\", [\n            [0, PHI, -1],\n            [-PHI, 1, 0],\n            [-1, 0, -PHI],\n            [1, 0, -PHI],\n            [PHI, 1, 0],\n            [0, PHI, 1],\n            [-1, 0, PHI],\n            [-PHI, -1, 0],\n            [0, -PHI, -1],\n            [PHI, -1, 0],\n            [1, 0, PHI],\n            [0, -PHI, 1],\n        ], []);\n        primTri.setIndices();\n        primTri.calcCoeffs();\n        primTri.createInnerFacets();\n        primTri.edgeVecsABOB();\n        primTri.mapABOBtoOBOA();\n        primTri.mapABOBtoBAOA();\n        for (var f = 0; f < primTri.IDATA.face.length; f++) {\n            primTri.MapToFace(f, geodesicData);\n            geodesicData.innerToData(f, primTri);\n            if (primTri.IDATA.edgematch[f][1] === \"B\") {\n                geodesicData.mapABOBtoDATA(f, primTri);\n            }\n            if (primTri.IDATA.edgematch[f][1] === \"O\") {\n                geodesicData.mapOBOAtoDATA(f, primTri);\n            }\n            if (primTri.IDATA.edgematch[f][3] === \"A\") {\n                geodesicData.mapBAOAtoDATA(f, primTri);\n            }\n        }\n        geodesicData.orderData(primTri);\n        var radius = 1;\n        geodesicData.vertex = geodesicData.vertex.map(function (el) {\n            var a = el[0];\n            var b = el[1];\n            var c = el[2];\n            var d = Math.sqrt(a * a + b * b + c * c);\n            el[0] *= radius / d;\n            el[1] *= radius / d;\n            el[2] *= radius / d;\n            return el;\n        });\n        return geodesicData;\n    };\n    return GeodesicData;\n}(PolyhedronData));\nexport { GeodesicData };\n//# sourceMappingURL=geodesicMesh.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\n\nimport { Tools } from \"../Misc/tools.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { extractMinAndMax } from \"../Maths/math.functions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions.js\";\n/**\n * Class used to store geometry data (vertex buffers + index buffer)\n */\nvar Geometry = /** @class */ (function () {\n    /**\n     * Creates a new geometry\n     * @param id defines the unique ID\n     * @param scene defines the hosting scene\n     * @param vertexData defines the VertexData used to get geometry data\n     * @param updatable defines if geometry must be updatable (false by default)\n     * @param mesh defines the mesh that will be associated with the geometry\n     */\n    function Geometry(id, scene, vertexData, updatable, mesh) {\n        if (updatable === void 0) { updatable = false; }\n        if (mesh === void 0) { mesh = null; }\n        /**\n         * Gets the delay loading state of the geometry (none by default which means not delayed)\n         */\n        this.delayLoadState = 0;\n        this._totalVertices = 0;\n        this._isDisposed = false;\n        this._indexBufferIsUpdatable = false;\n        this._positionsCache = [];\n        /** @hidden */\n        this._parentContainer = null;\n        /**\n         * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\n         * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\n         */\n        this.useBoundingInfoFromGeometry = false;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        if (!this._scene) {\n            return;\n        }\n        this.id = id;\n        this.uniqueId = this._scene.getUniqueId();\n        this._engine = this._scene.getEngine();\n        this._meshes = [];\n        //Init vertex buffer cache\n        this._vertexBuffers = {};\n        this._indices = [];\n        this._updatable = updatable;\n        // vertexData\n        if (vertexData) {\n            this.setAllVerticesData(vertexData, updatable);\n        }\n        else {\n            this._totalVertices = 0;\n            this._indices = [];\n        }\n        if (this._engine.getCaps().vertexArrayObject) {\n            this._vertexArrayObjects = {};\n        }\n        // applyToMesh\n        if (mesh) {\n            this.applyToMesh(mesh);\n            mesh.computeWorldMatrix(true);\n        }\n    }\n    Object.defineProperty(Geometry.prototype, \"boundingBias\", {\n        /**\n         *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n         */\n        get: function () {\n            return this._boundingBias;\n        },\n        /**\n         *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n         */\n        set: function (value) {\n            if (this._boundingBias) {\n                this._boundingBias.copyFrom(value);\n            }\n            else {\n                this._boundingBias = value.clone();\n            }\n            this._updateBoundingInfo(true, null);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Static function used to attach a new empty geometry to a mesh\n     * @param mesh defines the mesh to attach the geometry to\n     * @returns the new Geometry\n     */\n    Geometry.CreateGeometryForMesh = function (mesh) {\n        var geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\n        geometry.applyToMesh(mesh);\n        return geometry;\n    };\n    Object.defineProperty(Geometry.prototype, \"meshes\", {\n        /** Get the list of meshes using this geometry */\n        get: function () {\n            return this._meshes;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Geometry.prototype, \"extend\", {\n        /**\n         * Gets the current extend of the geometry\n         */\n        get: function () {\n            return this._extend;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Gets the hosting scene\n     * @returns the hosting Scene\n     */\n    Geometry.prototype.getScene = function () {\n        return this._scene;\n    };\n    /**\n     * Gets the hosting engine\n     * @returns the hosting Engine\n     */\n    Geometry.prototype.getEngine = function () {\n        return this._engine;\n    };\n    /**\n     * Defines if the geometry is ready to use\n     * @returns true if the geometry is ready to be used\n     */\n    Geometry.prototype.isReady = function () {\n        return this.delayLoadState === 1 || this.delayLoadState === 0;\n    };\n    Object.defineProperty(Geometry.prototype, \"doNotSerialize\", {\n        /**\n         * Gets a value indicating that the geometry should not be serialized\n         */\n        get: function () {\n            for (var index = 0; index < this._meshes.length; index++) {\n                if (!this._meshes[index].doNotSerialize) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** @hidden */\n    Geometry.prototype._rebuild = function () {\n        if (this._vertexArrayObjects) {\n            this._vertexArrayObjects = {};\n        }\n        // Index buffer\n        if (this._meshes.length !== 0 && this._indices) {\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\n        }\n        // Vertex buffers\n        for (var key in this._vertexBuffers) {\n            var vertexBuffer = this._vertexBuffers[key];\n            vertexBuffer._rebuild();\n        }\n    };\n    /**\n     * Affects all geometry data in one call\n     * @param vertexData defines the geometry data\n     * @param updatable defines if the geometry must be flagged as updatable (false as default)\n     */\n    Geometry.prototype.setAllVerticesData = function (vertexData, updatable) {\n        vertexData.applyToGeometry(this, updatable);\n        this._notifyUpdate();\n    };\n    /**\n     * Set specific vertex data\n     * @param kind defines the data kind (Position, normal, etc...)\n     * @param data defines the vertex data to use\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\n     */\n    Geometry.prototype.setVerticesData = function (kind, data, updatable, stride) {\n        if (updatable === void 0) { updatable = false; }\n        if (updatable && Array.isArray(data)) {\n            // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\n            data = new Float32Array(data);\n        }\n        var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\n        this.setVerticesBuffer(buffer);\n    };\n    /**\n     * Removes a specific vertex data\n     * @param kind defines the data kind (Position, normal, etc...)\n     */\n    Geometry.prototype.removeVerticesData = function (kind) {\n        if (this._vertexBuffers[kind]) {\n            this._vertexBuffers[kind].dispose();\n            delete this._vertexBuffers[kind];\n        }\n        if (this._vertexArrayObjects) {\n            this._disposeVertexArrayObjects();\n        }\n    };\n    /**\n     * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\n     * @param buffer defines the vertex buffer to use\n     * @param totalVertices defines the total number of vertices for position kind (could be null)\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n     */\n    Geometry.prototype.setVerticesBuffer = function (buffer, totalVertices, disposeExistingBuffer) {\n        if (totalVertices === void 0) { totalVertices = null; }\n        if (disposeExistingBuffer === void 0) { disposeExistingBuffer = true; }\n        var kind = buffer.getKind();\n        if (this._vertexBuffers[kind] && disposeExistingBuffer) {\n            this._vertexBuffers[kind].dispose();\n        }\n        if (buffer._buffer) {\n            buffer._buffer._increaseReferences();\n        }\n        this._vertexBuffers[kind] = buffer;\n        var meshes = this._meshes;\n        var numOfMeshes = meshes.length;\n        if (kind === VertexBuffer.PositionKind) {\n            var data = buffer.getData();\n            if (totalVertices != null) {\n                this._totalVertices = totalVertices;\n            }\n            else {\n                if (data != null) {\n                    this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);\n                }\n            }\n            this._updateExtend(data);\n            this._resetPointsArrayCache();\n            for (var index = 0; index < numOfMeshes; index++) {\n                var mesh = meshes[index];\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n                mesh._createGlobalSubMesh(mesh.isUnIndexed);\n                mesh.computeWorldMatrix(true);\n                mesh.synchronizeInstances();\n            }\n        }\n        this._notifyUpdate(kind);\n    };\n    /**\n     * Update a specific vertex buffer\n     * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\n     * It will do nothing if the buffer is not updatable\n     * @param kind defines the data kind (Position, normal, etc...)\n     * @param data defines the data to use\n     * @param offset defines the offset in the target buffer where to store the data\n     * @param useBytes set to true if the offset is in bytes\n     */\n    Geometry.prototype.updateVerticesDataDirectly = function (kind, data, offset, useBytes) {\n        if (useBytes === void 0) { useBytes = false; }\n        var vertexBuffer = this.getVertexBuffer(kind);\n        if (!vertexBuffer) {\n            return;\n        }\n        vertexBuffer.updateDirectly(data, offset, useBytes);\n        this._notifyUpdate(kind);\n    };\n    /**\n     * Update a specific vertex buffer\n     * This function will create a new buffer if the current one is not updatable\n     * @param kind defines the data kind (Position, normal, etc...)\n     * @param data defines the data to use\n     * @param updateExtends defines if the geometry extends must be recomputed (false by default)\n     */\n    Geometry.prototype.updateVerticesData = function (kind, data, updateExtends) {\n        if (updateExtends === void 0) { updateExtends = false; }\n        var vertexBuffer = this.getVertexBuffer(kind);\n        if (!vertexBuffer) {\n            return;\n        }\n        vertexBuffer.update(data);\n        if (kind === VertexBuffer.PositionKind) {\n            this._updateBoundingInfo(updateExtends, data);\n        }\n        this._notifyUpdate(kind);\n    };\n    Geometry.prototype._updateBoundingInfo = function (updateExtends, data) {\n        if (updateExtends) {\n            this._updateExtend(data);\n        }\n        this._resetPointsArrayCache();\n        if (updateExtends) {\n            var meshes = this._meshes;\n            for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\n                var mesh = meshes_1[_i];\n                if (mesh.hasBoundingInfo) {\n                    mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\n                }\n                else {\n                    mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n                }\n                var subMeshes = mesh.subMeshes;\n                for (var _a = 0, subMeshes_1 = subMeshes; _a < subMeshes_1.length; _a++) {\n                    var subMesh = subMeshes_1[_a];\n                    subMesh.refreshBoundingInfo();\n                }\n            }\n        }\n    };\n    /**\n     * @param effect\n     * @param indexToBind\n     * @hidden\n     */\n    Geometry.prototype._bind = function (effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {\n        if (!effect) {\n            return;\n        }\n        if (indexToBind === undefined) {\n            indexToBind = this._indexBuffer;\n        }\n        var vbs = this.getVertexBuffers();\n        if (!vbs) {\n            return;\n        }\n        if (indexToBind != this._indexBuffer || (!this._vertexArrayObjects && !overrideVertexArrayObjects)) {\n            this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\n            return;\n        }\n        var vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;\n        // Using VAO\n        if (!vaos[effect.key]) {\n            vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\n        }\n        this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\n    };\n    /**\n     * Gets total number of vertices\n     * @returns the total number of vertices\n     */\n    Geometry.prototype.getTotalVertices = function () {\n        if (!this.isReady()) {\n            return 0;\n        }\n        return this._totalVertices;\n    };\n    /**\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\n     * @param kind defines the data kind (Position, normal, etc...)\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n     * @returns a float array containing vertex data\n     */\n    Geometry.prototype.getVerticesData = function (kind, copyWhenShared, forceCopy) {\n        var vertexBuffer = this.getVertexBuffer(kind);\n        if (!vertexBuffer) {\n            return null;\n        }\n        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || (copyWhenShared && this._meshes.length !== 1));\n    };\n    /**\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable\n     * @param kind defines the data kind (Position, normal, etc...)\n     * @returns true if the vertex buffer with the specified kind is updatable\n     */\n    Geometry.prototype.isVertexBufferUpdatable = function (kind) {\n        var vb = this._vertexBuffers[kind];\n        if (!vb) {\n            return false;\n        }\n        return vb.isUpdatable();\n    };\n    /**\n     * Gets a specific vertex buffer\n     * @param kind defines the data kind (Position, normal, etc...)\n     * @returns a VertexBuffer\n     */\n    Geometry.prototype.getVertexBuffer = function (kind) {\n        if (!this.isReady()) {\n            return null;\n        }\n        return this._vertexBuffers[kind];\n    };\n    /**\n     * Returns all vertex buffers\n     * @return an object holding all vertex buffers indexed by kind\n     */\n    Geometry.prototype.getVertexBuffers = function () {\n        if (!this.isReady()) {\n            return null;\n        }\n        return this._vertexBuffers;\n    };\n    /**\n     * Gets a boolean indicating if specific vertex buffer is present\n     * @param kind defines the data kind (Position, normal, etc...)\n     * @returns true if data is present\n     */\n    Geometry.prototype.isVerticesDataPresent = function (kind) {\n        if (!this._vertexBuffers) {\n            if (this._delayInfo) {\n                return this._delayInfo.indexOf(kind) !== -1;\n            }\n            return false;\n        }\n        return this._vertexBuffers[kind] !== undefined;\n    };\n    /**\n     * Gets a list of all attached data kinds (Position, normal, etc...)\n     * @returns a list of string containing all kinds\n     */\n    Geometry.prototype.getVerticesDataKinds = function () {\n        var result = [];\n        var kind;\n        if (!this._vertexBuffers && this._delayInfo) {\n            for (kind in this._delayInfo) {\n                result.push(kind);\n            }\n        }\n        else {\n            for (kind in this._vertexBuffers) {\n                result.push(kind);\n            }\n        }\n        return result;\n    };\n    /**\n     * Update index buffer\n     * @param indices defines the indices to store in the index buffer\n     * @param offset defines the offset in the target buffer where to store the data\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n     */\n    Geometry.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\n        if (gpuMemoryOnly === void 0) { gpuMemoryOnly = false; }\n        if (!this._indexBuffer) {\n            return;\n        }\n        if (!this._indexBufferIsUpdatable) {\n            this.setIndices(indices, null, true);\n        }\n        else {\n            var needToUpdateSubMeshes = indices.length !== this._indices.length;\n            if (!gpuMemoryOnly) {\n                this._indices = indices.slice();\n            }\n            this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\n            if (needToUpdateSubMeshes) {\n                for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n                    var mesh = _a[_i];\n                    mesh._createGlobalSubMesh(true);\n                }\n            }\n        }\n    };\n    /**\n     * Creates a new index buffer\n     * @param indices defines the indices to store in the index buffer\n     * @param totalVertices defines the total number of vertices (could be null)\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\n     */\n    Geometry.prototype.setIndices = function (indices, totalVertices, updatable) {\n        if (totalVertices === void 0) { totalVertices = null; }\n        if (updatable === void 0) { updatable = false; }\n        if (this._indexBuffer) {\n            this._engine._releaseBuffer(this._indexBuffer);\n        }\n        this._indices = indices;\n        this._indexBufferIsUpdatable = updatable;\n        if (this._meshes.length !== 0 && this._indices) {\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\n        }\n        if (totalVertices != undefined) {\n            // including null and undefined\n            this._totalVertices = totalVertices;\n        }\n        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n            var mesh = _a[_i];\n            mesh._createGlobalSubMesh(true);\n            mesh.synchronizeInstances();\n        }\n        this._notifyUpdate();\n    };\n    /**\n     * Return the total number of indices\n     * @returns the total number of indices\n     */\n    Geometry.prototype.getTotalIndices = function () {\n        if (!this.isReady()) {\n            return 0;\n        }\n        return this._indices.length;\n    };\n    /**\n     * Gets the index buffer array\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n     * @returns the index buffer array\n     */\n    Geometry.prototype.getIndices = function (copyWhenShared, forceCopy) {\n        if (!this.isReady()) {\n            return null;\n        }\n        var orig = this._indices;\n        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\n            return orig;\n        }\n        else {\n            return orig.slice();\n        }\n    };\n    /**\n     * Gets the index buffer\n     * @return the index buffer\n     */\n    Geometry.prototype.getIndexBuffer = function () {\n        if (!this.isReady()) {\n            return null;\n        }\n        return this._indexBuffer;\n    };\n    /**\n     * @param effect\n     * @hidden\n     */\n    Geometry.prototype._releaseVertexArrayObject = function (effect) {\n        if (effect === void 0) { effect = null; }\n        if (!effect || !this._vertexArrayObjects) {\n            return;\n        }\n        if (this._vertexArrayObjects[effect.key]) {\n            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\n            delete this._vertexArrayObjects[effect.key];\n        }\n    };\n    /**\n     * Release the associated resources for a specific mesh\n     * @param mesh defines the source mesh\n     * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\n     */\n    Geometry.prototype.releaseForMesh = function (mesh, shouldDispose) {\n        var meshes = this._meshes;\n        var index = meshes.indexOf(mesh);\n        if (index === -1) {\n            return;\n        }\n        meshes.splice(index, 1);\n        if (this._vertexArrayObjects) {\n            mesh._invalidateInstanceVertexArrayObject();\n        }\n        mesh._geometry = null;\n        if (meshes.length === 0 && shouldDispose) {\n            this.dispose();\n        }\n    };\n    /**\n     * Apply current geometry to a given mesh\n     * @param mesh defines the mesh to apply geometry to\n     */\n    Geometry.prototype.applyToMesh = function (mesh) {\n        if (mesh._geometry === this) {\n            return;\n        }\n        var previousGeometry = mesh._geometry;\n        if (previousGeometry) {\n            previousGeometry.releaseForMesh(mesh);\n        }\n        if (this._vertexArrayObjects) {\n            mesh._invalidateInstanceVertexArrayObject();\n        }\n        var meshes = this._meshes;\n        // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\n        mesh._geometry = this;\n        mesh._internalAbstractMeshDataInfo._positions = null;\n        this._scene.pushGeometry(this);\n        meshes.push(mesh);\n        if (this.isReady()) {\n            this._applyToMesh(mesh);\n        }\n        else if (this._boundingInfo) {\n            mesh.setBoundingInfo(this._boundingInfo);\n        }\n    };\n    Geometry.prototype._updateExtend = function (data) {\n        if (data === void 0) { data = null; }\n        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\n            this._extend = {\n                minimum: this._boundingInfo.minimum.clone(),\n                maximum: this._boundingInfo.maximum.clone(),\n            };\n        }\n        else {\n            if (!data) {\n                data = this.getVerticesData(VertexBuffer.PositionKind);\n                // This can happen if the buffer comes from a Hardware Buffer where\n                // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\n                if (!data) {\n                    return;\n                }\n            }\n            this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\n        }\n    };\n    Geometry.prototype._applyToMesh = function (mesh) {\n        var numOfMeshes = this._meshes.length;\n        // vertexBuffers\n        for (var kind in this._vertexBuffers) {\n            if (numOfMeshes === 1) {\n                this._vertexBuffers[kind].create();\n            }\n            if (kind === VertexBuffer.PositionKind) {\n                if (!this._extend) {\n                    this._updateExtend();\n                }\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n                mesh._createGlobalSubMesh(mesh.isUnIndexed);\n                //bounding info was just created again, world matrix should be applied again.\n                mesh._updateBoundingInfo();\n            }\n        }\n        // indexBuffer\n        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\n        }\n        // morphTargets\n        mesh._syncGeometryWithMorphTargetManager();\n        // instances\n        mesh.synchronizeInstances();\n    };\n    Geometry.prototype._notifyUpdate = function (kind) {\n        if (this.onGeometryUpdated) {\n            this.onGeometryUpdated(this, kind);\n        }\n        if (this._vertexArrayObjects) {\n            this._disposeVertexArrayObjects();\n        }\n        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n            var mesh = _a[_i];\n            mesh._markSubMeshesAsAttributesDirty();\n        }\n    };\n    /**\n     * Load the geometry if it was flagged as delay loaded\n     * @param scene defines the hosting scene\n     * @param onLoaded defines a callback called when the geometry is loaded\n     */\n    Geometry.prototype.load = function (scene, onLoaded) {\n        if (this.delayLoadState === 2) {\n            return;\n        }\n        if (this.isReady()) {\n            if (onLoaded) {\n                onLoaded();\n            }\n            return;\n        }\n        this.delayLoadState = 2;\n        this._queueLoad(scene, onLoaded);\n    };\n    Geometry.prototype._queueLoad = function (scene, onLoaded) {\n        var _this = this;\n        if (!this.delayLoadingFile) {\n            return;\n        }\n        scene._addPendingData(this);\n        scene._loadFile(this.delayLoadingFile, function (data) {\n            if (!_this._delayLoadingFunction) {\n                return;\n            }\n            _this._delayLoadingFunction(JSON.parse(data), _this);\n            _this.delayLoadState = 1;\n            _this._delayInfo = [];\n            scene._removePendingData(_this);\n            var meshes = _this._meshes;\n            var numOfMeshes = meshes.length;\n            for (var index = 0; index < numOfMeshes; index++) {\n                _this._applyToMesh(meshes[index]);\n            }\n            if (onLoaded) {\n                onLoaded();\n            }\n        }, undefined, true);\n    };\n    /**\n     * Invert the geometry to move from a right handed system to a left handed one.\n     */\n    Geometry.prototype.toLeftHanded = function () {\n        // Flip faces\n        var tIndices = this.getIndices(false);\n        if (tIndices != null && tIndices.length > 0) {\n            for (var i = 0; i < tIndices.length; i += 3) {\n                var tTemp = tIndices[i + 0];\n                tIndices[i + 0] = tIndices[i + 2];\n                tIndices[i + 2] = tTemp;\n            }\n            this.setIndices(tIndices);\n        }\n        // Negate position.z\n        var tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\n        if (tPositions != null && tPositions.length > 0) {\n            for (var i = 0; i < tPositions.length; i += 3) {\n                tPositions[i + 2] = -tPositions[i + 2];\n            }\n            this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\n        }\n        // Negate normal.z\n        var tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\n        if (tNormals != null && tNormals.length > 0) {\n            for (var i = 0; i < tNormals.length; i += 3) {\n                tNormals[i + 2] = -tNormals[i + 2];\n            }\n            this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\n        }\n    };\n    // Cache\n    /** @hidden */\n    Geometry.prototype._resetPointsArrayCache = function () {\n        this._positions = null;\n    };\n    /** @hidden */\n    Geometry.prototype._generatePointsArray = function () {\n        if (this._positions) {\n            return true;\n        }\n        var data = this.getVerticesData(VertexBuffer.PositionKind);\n        if (!data || data.length === 0) {\n            return false;\n        }\n        for (var index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\n            this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\n        }\n        for (var index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\n            this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\n        }\n        // just in case the number of positions was reduced, splice the array\n        this._positionsCache.length = data.length / 3;\n        this._positions = this._positionsCache;\n        return true;\n    };\n    /**\n     * Gets a value indicating if the geometry is disposed\n     * @returns true if the geometry was disposed\n     */\n    Geometry.prototype.isDisposed = function () {\n        return this._isDisposed;\n    };\n    Geometry.prototype._disposeVertexArrayObjects = function () {\n        if (this._vertexArrayObjects) {\n            for (var kind in this._vertexArrayObjects) {\n                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\n            }\n            this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\n            var meshes = this._meshes;\n            var numOfMeshes = meshes.length;\n            for (var index = 0; index < numOfMeshes; index++) {\n                meshes[index]._invalidateInstanceVertexArrayObject();\n            }\n        }\n    };\n    /**\n     * Free all associated resources\n     */\n    Geometry.prototype.dispose = function () {\n        var meshes = this._meshes;\n        var numOfMeshes = meshes.length;\n        var index;\n        for (index = 0; index < numOfMeshes; index++) {\n            this.releaseForMesh(meshes[index]);\n        }\n        this._meshes = [];\n        this._disposeVertexArrayObjects();\n        for (var kind in this._vertexBuffers) {\n            this._vertexBuffers[kind].dispose();\n        }\n        this._vertexBuffers = {};\n        this._totalVertices = 0;\n        if (this._indexBuffer) {\n            this._engine._releaseBuffer(this._indexBuffer);\n        }\n        this._indexBuffer = null;\n        this._indices = [];\n        this.delayLoadState = 0;\n        this.delayLoadingFile = null;\n        this._delayLoadingFunction = null;\n        this._delayInfo = [];\n        this._boundingInfo = null;\n        this._scene.removeGeometry(this);\n        if (this._parentContainer) {\n            var index_1 = this._parentContainer.geometries.indexOf(this);\n            if (index_1 > -1) {\n                this._parentContainer.geometries.splice(index_1, 1);\n            }\n            this._parentContainer = null;\n        }\n        this._isDisposed = true;\n    };\n    /**\n     * Clone the current geometry into a new geometry\n     * @param id defines the unique ID of the new geometry\n     * @returns a new geometry object\n     */\n    Geometry.prototype.copy = function (id) {\n        var vertexData = new VertexData();\n        vertexData.indices = [];\n        var indices = this.getIndices();\n        if (indices) {\n            for (var index = 0; index < indices.length; index++) {\n                vertexData.indices.push(indices[index]);\n            }\n        }\n        var updatable = false;\n        var stopChecking = false;\n        var kind;\n        for (kind in this._vertexBuffers) {\n            // using slice() to make a copy of the array and not just reference it\n            var data = this.getVerticesData(kind);\n            if (data) {\n                if (data instanceof Float32Array) {\n                    vertexData.set(new Float32Array(data), kind);\n                }\n                else {\n                    vertexData.set(data.slice(0), kind);\n                }\n                if (!stopChecking) {\n                    var vb = this.getVertexBuffer(kind);\n                    if (vb) {\n                        updatable = vb.isUpdatable();\n                        stopChecking = !updatable;\n                    }\n                }\n            }\n        }\n        var geometry = new Geometry(id, this._scene, vertexData, updatable);\n        geometry.delayLoadState = this.delayLoadState;\n        geometry.delayLoadingFile = this.delayLoadingFile;\n        geometry._delayLoadingFunction = this._delayLoadingFunction;\n        for (kind in this._delayInfo) {\n            geometry._delayInfo = geometry._delayInfo || [];\n            geometry._delayInfo.push(kind);\n        }\n        // Bounding info\n        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n        return geometry;\n    };\n    /**\n     * Serialize the current geometry info (and not the vertices data) into a JSON object\n     * @return a JSON representation of the current geometry data (without the vertices data)\n     */\n    Geometry.prototype.serialize = function () {\n        var serializationObject = {};\n        serializationObject.id = this.id;\n        serializationObject.uniqueId = this.uniqueId;\n        serializationObject.updatable = this._updatable;\n        if (Tags && Tags.HasTags(this)) {\n            serializationObject.tags = Tags.GetTags(this);\n        }\n        return serializationObject;\n    };\n    Geometry.prototype._toNumberArray = function (origin) {\n        if (Array.isArray(origin)) {\n            return origin;\n        }\n        else {\n            return Array.prototype.slice.call(origin);\n        }\n    };\n    /**\n     * Release any memory retained by the cached data on the Geometry.\n     *\n     * Call this function to reduce memory footprint of the mesh.\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n     */\n    Geometry.prototype.clearCachedData = function () {\n        this._indices = [];\n        this._resetPointsArrayCache();\n        for (var vbName in this._vertexBuffers) {\n            if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\n                continue;\n            }\n            this._vertexBuffers[vbName]._buffer._data = null;\n        }\n    };\n    /**\n     * Serialize all vertices data into a JSON object\n     * @returns a JSON representation of the current geometry data\n     */\n    Geometry.prototype.serializeVerticeData = function () {\n        var serializationObject = this.serialize();\n        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n            serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n                serializationObject.positions._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n            serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n                serializationObject.normals._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n            serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\n                serializationObject.tangents._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n            serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\n                serializationObject.uvs._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n            serializationObject.uv2s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\n                serializationObject.uv2s._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n            serializationObject.uv3s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\n                serializationObject.uv3s._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n            serializationObject.uv4s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\n                serializationObject.uv4s._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n            serializationObject.uv5s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\n                serializationObject.uv5s._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n            serializationObject.uv6s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\n                serializationObject.uv6s._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n            serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\n                serializationObject.colors._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n            serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\n            serializationObject.matricesIndices._isExpanded = true;\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\n                serializationObject.matricesIndices._updatable = true;\n            }\n        }\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n            serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\n                serializationObject.matricesWeights._updatable = true;\n            }\n        }\n        serializationObject.indices = this._toNumberArray(this.getIndices());\n        return serializationObject;\n    };\n    // Statics\n    /**\n     * Extracts a clone of a mesh geometry\n     * @param mesh defines the source mesh\n     * @param id defines the unique ID of the new geometry object\n     * @returns the new geometry object\n     */\n    Geometry.ExtractFromMesh = function (mesh, id) {\n        var geometry = mesh._geometry;\n        if (!geometry) {\n            return null;\n        }\n        return geometry.copy(id);\n    };\n    /**\n     * You should now use Tools.RandomId(), this method is still here for legacy reasons.\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n     * Be aware Math.random() could cause collisions, but:\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n     * @returns a string containing a new GUID\n     */\n    Geometry.RandomId = function () {\n        return Tools.RandomId();\n    };\n    Geometry._GetGeometryByLoadedUniqueId = function (uniqueId, scene) {\n        for (var index = 0; index < scene.geometries.length; index++) {\n            if (scene.geometries[index]._loadedUniqueId === uniqueId) {\n                return scene.geometries[index];\n            }\n        }\n        return null;\n    };\n    /**\n     * @param parsedGeometry\n     * @param mesh\n     * @hidden\n     */\n    Geometry._ImportGeometry = function (parsedGeometry, mesh) {\n        var scene = mesh.getScene();\n        // Geometry\n        var geometryUniqueId = parsedGeometry.geometryUniqueId;\n        var geometryId = parsedGeometry.geometryId;\n        if (geometryUniqueId || geometryId) {\n            var geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\n            if (geometry) {\n                geometry.applyToMesh(mesh);\n            }\n        }\n        else if (parsedGeometry instanceof ArrayBuffer) {\n            var binaryInfo = mesh._binaryInfo;\n            if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\n                var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\n                mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\n            }\n            if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\n                var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\n                mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\n            }\n            if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\n                var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\n                mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\n            }\n            if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\n                var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                    for (var index = 1; index < uvsData.length; index += 2) {\n                        uvsData[index] = 1 - uvsData[index];\n                    }\n                }\n                mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\n            }\n            if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\n                var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                    for (var index = 1; index < uvs2Data.length; index += 2) {\n                        uvs2Data[index] = 1 - uvs2Data[index];\n                    }\n                }\n                mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\n            }\n            if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\n                var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                    for (var index = 1; index < uvs3Data.length; index += 2) {\n                        uvs3Data[index] = 1 - uvs3Data[index];\n                    }\n                }\n                mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\n            }\n            if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\n                var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                    for (var index = 1; index < uvs4Data.length; index += 2) {\n                        uvs4Data[index] = 1 - uvs4Data[index];\n                    }\n                }\n                mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\n            }\n            if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\n                var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                    for (var index = 1; index < uvs5Data.length; index += 2) {\n                        uvs5Data[index] = 1 - uvs5Data[index];\n                    }\n                }\n                mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\n            }\n            if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\n                var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n                    for (var index = 1; index < uvs6Data.length; index += 2) {\n                        uvs6Data[index] = 1 - uvs6Data[index];\n                    }\n                }\n                mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\n            }\n            if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\n                var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\n                mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\n            }\n            if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\n                var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\n                var floatIndices = [];\n                for (var i = 0; i < matricesIndicesData.length; i++) {\n                    var index = matricesIndicesData[i];\n                    floatIndices.push(index & 0x000000ff);\n                    floatIndices.push((index & 0x0000ff00) >> 8);\n                    floatIndices.push((index & 0x00ff0000) >> 16);\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\n                }\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\n            }\n            if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\n                var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\n                var floatIndices = [];\n                for (var i = 0; i < matricesIndicesData.length; i++) {\n                    var index = matricesIndicesData[i];\n                    floatIndices.push(index & 0x000000ff);\n                    floatIndices.push((index & 0x0000ff00) >> 8);\n                    floatIndices.push((index & 0x00ff0000) >> 16);\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\n                }\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\n            }\n            if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\n                var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\n            }\n            if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\n                var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\n                mesh.setIndices(indicesData, null);\n            }\n            if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\n                var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\n                mesh.subMeshes = [];\n                for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\n                    var materialIndex = subMeshesData[i * 5 + 0];\n                    var verticesStart = subMeshesData[i * 5 + 1];\n                    var verticesCount = subMeshesData[i * 5 + 2];\n                    var indexStart = subMeshesData[i * 5 + 3];\n                    var indexCount = subMeshesData[i * 5 + 4];\n                    SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);\n                }\n            }\n        }\n        else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\n            mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\n            mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\n            if (parsedGeometry.tangents) {\n                mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\n            }\n            if (parsedGeometry.uvs) {\n                mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\n            }\n            if (parsedGeometry.uvs2) {\n                mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\n            }\n            if (parsedGeometry.uvs3) {\n                mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\n            }\n            if (parsedGeometry.uvs4) {\n                mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\n            }\n            if (parsedGeometry.uvs5) {\n                mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\n            }\n            if (parsedGeometry.uvs6) {\n                mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\n            }\n            if (parsedGeometry.colors) {\n                mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\n            }\n            if (parsedGeometry.matricesIndices) {\n                if (!parsedGeometry.matricesIndices._isExpanded) {\n                    var floatIndices = [];\n                    for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {\n                        var matricesIndex = parsedGeometry.matricesIndices[i];\n                        floatIndices.push(matricesIndex & 0x000000ff);\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\n                    }\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\n                }\n                else {\n                    delete parsedGeometry.matricesIndices._isExpanded;\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\n                }\n            }\n            if (parsedGeometry.matricesIndicesExtra) {\n                if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\n                    var floatIndices = [];\n                    for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\n                        var matricesIndex = parsedGeometry.matricesIndicesExtra[i];\n                        floatIndices.push(matricesIndex & 0x000000ff);\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\n                    }\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\n                }\n                else {\n                    delete parsedGeometry.matricesIndices._isExpanded;\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\n                }\n            }\n            if (parsedGeometry.matricesWeights) {\n                Geometry._CleanMatricesWeights(parsedGeometry, mesh);\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\n            }\n            if (parsedGeometry.matricesWeightsExtra) {\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\n            }\n            mesh.setIndices(parsedGeometry.indices, null);\n        }\n        // SubMeshes\n        if (parsedGeometry.subMeshes) {\n            mesh.subMeshes = [];\n            for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\n                var parsedSubMesh = parsedGeometry.subMeshes[subIndex];\n                SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);\n            }\n        }\n        // Flat shading\n        if (mesh._shouldGenerateFlatShading) {\n            mesh.convertToFlatShadedMesh();\n            mesh._shouldGenerateFlatShading = false;\n        }\n        // Update\n        mesh.computeWorldMatrix(true);\n        scene.onMeshImportedObservable.notifyObservers(mesh);\n    };\n    Geometry._CleanMatricesWeights = function (parsedGeometry, mesh) {\n        var epsilon = 1e-3;\n        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\n            return;\n        }\n        var noInfluenceBoneIndex = 0.0;\n        if (parsedGeometry.skeletonId > -1) {\n            var skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\n            if (!skeleton) {\n                return;\n            }\n            noInfluenceBoneIndex = skeleton.bones.length;\n        }\n        else {\n            return;\n        }\n        var matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n        var matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n        var matricesWeights = parsedGeometry.matricesWeights;\n        var matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\n        var influencers = parsedGeometry.numBoneInfluencer;\n        var size = matricesWeights.length;\n        for (var i = 0; i < size; i += 4) {\n            var weight = 0.0;\n            var firstZeroWeight = -1;\n            for (var j = 0; j < 4; j++) {\n                var w = matricesWeights[i + j];\n                weight += w;\n                if (w < epsilon && firstZeroWeight < 0) {\n                    firstZeroWeight = j;\n                }\n            }\n            if (matricesWeightsExtra) {\n                for (var j = 0; j < 4; j++) {\n                    var w = matricesWeightsExtra[i + j];\n                    weight += w;\n                    if (w < epsilon && firstZeroWeight < 0) {\n                        firstZeroWeight = j + 4;\n                    }\n                }\n            }\n            if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\n                firstZeroWeight = influencers - 1;\n            }\n            if (weight > epsilon) {\n                var mweight = 1.0 / weight;\n                for (var j = 0; j < 4; j++) {\n                    matricesWeights[i + j] *= mweight;\n                }\n                if (matricesWeightsExtra) {\n                    for (var j = 0; j < 4; j++) {\n                        matricesWeightsExtra[i + j] *= mweight;\n                    }\n                }\n            }\n            else {\n                if (firstZeroWeight >= 4) {\n                    matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\n                    matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\n                }\n                else {\n                    matricesWeights[i + firstZeroWeight] = 1.0 - weight;\n                    matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\n                }\n            }\n        }\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\n        if (parsedGeometry.matricesWeightsExtra) {\n            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\n        }\n    };\n    /**\n     * Create a new geometry from persisted data (Using .babylon file format)\n     * @param parsedVertexData defines the persisted data\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root url to use to load assets (like delayed data)\n     * @returns the new geometry object\n     */\n    Geometry.Parse = function (parsedVertexData, scene, rootUrl) {\n        var geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\n        geometry._loadedUniqueId = parsedVertexData.uniqueId;\n        if (Tags) {\n            Tags.AddTagsTo(geometry, parsedVertexData.tags);\n        }\n        if (parsedVertexData.delayLoadingFile) {\n            geometry.delayLoadState = 4;\n            geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\n            geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\n            geometry._delayInfo = [];\n            if (parsedVertexData.hasUVs) {\n                geometry._delayInfo.push(VertexBuffer.UVKind);\n            }\n            if (parsedVertexData.hasUVs2) {\n                geometry._delayInfo.push(VertexBuffer.UV2Kind);\n            }\n            if (parsedVertexData.hasUVs3) {\n                geometry._delayInfo.push(VertexBuffer.UV3Kind);\n            }\n            if (parsedVertexData.hasUVs4) {\n                geometry._delayInfo.push(VertexBuffer.UV4Kind);\n            }\n            if (parsedVertexData.hasUVs5) {\n                geometry._delayInfo.push(VertexBuffer.UV5Kind);\n            }\n            if (parsedVertexData.hasUVs6) {\n                geometry._delayInfo.push(VertexBuffer.UV6Kind);\n            }\n            if (parsedVertexData.hasColors) {\n                geometry._delayInfo.push(VertexBuffer.ColorKind);\n            }\n            if (parsedVertexData.hasMatricesIndices) {\n                geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n            }\n            if (parsedVertexData.hasMatricesWeights) {\n                geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n            }\n            geometry._delayLoadingFunction = VertexData.ImportVertexData;\n        }\n        else {\n            VertexData.ImportVertexData(parsedVertexData, geometry);\n        }\n        scene.pushGeometry(geometry, true);\n        return geometry;\n    };\n    return Geometry;\n}());\nexport { Geometry };\n//# sourceMappingURL=geometry.js.map","import { __extends } from \"tslib\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Logger } from \"../Misc/logger.js\";\nMesh._GoldbergMeshParser = function (parsedMesh, scene) {\n    return GoldbergMesh.Parse(parsedMesh, scene);\n};\n/**\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\n */\nvar GoldbergMesh = /** @class */ (function (_super) {\n    __extends(GoldbergMesh, _super);\n    function GoldbergMesh() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * Defines the specific Goldberg data used in this mesh construction.\n         */\n        _this.goldbergData = {\n            faceColors: [],\n            faceCenters: [],\n            faceZaxis: [],\n            faceXaxis: [],\n            faceYaxis: [],\n            nbSharedFaces: 0,\n            nbUnsharedFaces: 0,\n            nbFaces: 0,\n            nbFacesAtPole: 0,\n            adjacentFaces: [],\n        };\n        return _this;\n    }\n    /**\n     * Gets the related Goldberg face from pole infos\n     * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\n     * @param fromPole Defines an optional pole index to find the related info from\n     * @returns the goldberg face number\n     */\n    GoldbergMesh.prototype.relatedGoldbergFace = function (poleOrShared, fromPole) {\n        if (fromPole === void 0) {\n            if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\n                Logger.Warn(\"Maximum number of unshared faces used\");\n                poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\n            }\n            return this.goldbergData.nbUnsharedFaces + poleOrShared;\n        }\n        if (poleOrShared > 11) {\n            Logger.Warn(\"Last pole used\");\n            poleOrShared = 11;\n        }\n        if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\n            Logger.Warn(\"Maximum number of faces at a pole used\");\n            fromPole = this.goldbergData.nbFacesAtPole - 1;\n        }\n        return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\n    };\n    GoldbergMesh.prototype._changeGoldbergFaceColors = function (colorRange) {\n        for (var i = 0; i < colorRange.length; i++) {\n            var min = colorRange[i][0];\n            var max = colorRange[i][1];\n            var col = colorRange[i][2];\n            for (var f = min; f < max + 1; f++) {\n                this.goldbergData.faceColors[f] = col;\n            }\n        }\n        var newCols = [];\n        for (var f = 0; f < 12; f++) {\n            for (var i = 0; i < 5; i++) {\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\n            }\n        }\n        for (var f = 12; f < this.goldbergData.faceColors.length; f++) {\n            for (var i = 0; i < 6; i++) {\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\n            }\n        }\n        return newCols;\n    };\n    /**\n     * Set new goldberg face colors\n     * @param colorRange the new color to apply to the mesh\n     */\n    GoldbergMesh.prototype.setGoldbergFaceColors = function (colorRange) {\n        var newCols = this._changeGoldbergFaceColors(colorRange);\n        this.setVerticesData(VertexBuffer.ColorKind, newCols);\n    };\n    /**\n     * Updates new goldberg face colors\n     * @param colorRange the new color to apply to the mesh\n     */\n    GoldbergMesh.prototype.updateGoldbergFaceColors = function (colorRange) {\n        var newCols = this._changeGoldbergFaceColors(colorRange);\n        this.updateVerticesData(VertexBuffer.ColorKind, newCols);\n    };\n    GoldbergMesh.prototype._changeGoldbergFaceUVs = function (uvRange) {\n        var uvs = this.getVerticesData(VertexBuffer.UVKind);\n        for (var i = 0; i < uvRange.length; i++) {\n            var min = uvRange[i][0];\n            var max = uvRange[i][1];\n            var center = uvRange[i][2];\n            var radius = uvRange[i][3];\n            var angle = uvRange[i][4];\n            var points5 = [];\n            var points6 = [];\n            var u = void 0;\n            var v = void 0;\n            for (var p = 0; p < 5; p++) {\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 2.5);\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 2.5);\n                if (u < 0) {\n                    u = 0;\n                }\n                if (u > 1) {\n                    u = 1;\n                }\n                points5.push(u, v);\n            }\n            for (var p = 0; p < 6; p++) {\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 3);\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 3);\n                if (u < 0) {\n                    u = 0;\n                }\n                if (u > 1) {\n                    u = 1;\n                }\n                points6.push(u, v);\n            }\n            for (var f = min; f < Math.min(12, max + 1); f++) {\n                for (var p = 0; p < 5; p++) {\n                    uvs[10 * f + 2 * p] = points5[2 * p];\n                    uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\n                }\n            }\n            for (var f = Math.max(12, min); f < max + 1; f++) {\n                for (var p = 0; p < 6; p++) {\n                    //120 + 12 * (f - 12) = 12 * f - 24\n                    uvs[12 * f - 24 + 2 * p] = points6[2 * p];\n                    uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\n                }\n            }\n        }\n        return uvs;\n    };\n    /**\n     * set new goldberg face UVs\n     * @param uvRange the new UVs to apply to the mesh\n     */\n    GoldbergMesh.prototype.setGoldbergFaceUVs = function (uvRange) {\n        var newUVs = this._changeGoldbergFaceUVs(uvRange);\n        this.setVerticesData(VertexBuffer.UVKind, newUVs);\n    };\n    /**\n     * Updates new goldberg face UVs\n     * @param uvRange the new UVs to apply to the mesh\n     */\n    GoldbergMesh.prototype.updateGoldbergFaceUVs = function (uvRange) {\n        var newUVs = this._changeGoldbergFaceUVs(uvRange);\n        this.updateVerticesData(VertexBuffer.UVKind, newUVs);\n    };\n    /**\n     * Places a mesh on a particular face of the goldberg polygon\n     * @param mesh Defines the mesh to position\n     * @param face Defines the face to position onto\n     * @param position Defines the position relative to the face we are positioning the mesh onto\n     */\n    GoldbergMesh.prototype.placeOnGoldbergFaceAt = function (mesh, face, position) {\n        var orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\n        mesh.rotation = orientation;\n        mesh.position = this.goldbergData.faceCenters[face]\n            .add(this.goldbergData.faceXaxis[face].scale(position.x))\n            .add(this.goldbergData.faceYaxis[face].scale(position.y))\n            .add(this.goldbergData.faceZaxis[face].scale(position.z));\n    };\n    /**\n     * Serialize current mesh\n     * @param serializationObject defines the object which will receive the serialization data\n     */\n    GoldbergMesh.prototype.serialize = function (serializationObject) {\n        _super.prototype.serialize.call(this, serializationObject);\n        serializationObject.type = \"GoldbergMesh\";\n        var goldbergData = {};\n        goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\n        goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\n        goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\n        goldbergData.nbFaces = this.goldbergData.nbFaces;\n        goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\n        if (this.goldbergData.faceColors) {\n            goldbergData.faceColors = [];\n            for (var _i = 0, _a = this.goldbergData.faceColors; _i < _a.length; _i++) {\n                var color = _a[_i];\n                goldbergData.faceColors.push(color.asArray());\n            }\n        }\n        if (this.goldbergData.faceCenters) {\n            goldbergData.faceCenters = [];\n            for (var _b = 0, _c = this.goldbergData.faceCenters; _b < _c.length; _b++) {\n                var vector = _c[_b];\n                goldbergData.faceCenters.push(vector.asArray());\n            }\n        }\n        if (this.goldbergData.faceZaxis) {\n            goldbergData.faceZaxis = [];\n            for (var _d = 0, _e = this.goldbergData.faceZaxis; _d < _e.length; _d++) {\n                var vector = _e[_d];\n                goldbergData.faceZaxis.push(vector.asArray());\n            }\n        }\n        if (this.goldbergData.faceYaxis) {\n            goldbergData.faceYaxis = [];\n            for (var _f = 0, _g = this.goldbergData.faceYaxis; _f < _g.length; _f++) {\n                var vector = _g[_f];\n                goldbergData.faceYaxis.push(vector.asArray());\n            }\n        }\n        if (this.goldbergData.faceXaxis) {\n            goldbergData.faceXaxis = [];\n            for (var _h = 0, _j = this.goldbergData.faceXaxis; _h < _j.length; _h++) {\n                var vector = _j[_h];\n                goldbergData.faceXaxis.push(vector.asArray());\n            }\n        }\n        serializationObject.goldbergData = goldbergData;\n    };\n    /**\n     * Parses a serialized goldberg mesh\n     * @param parsedMesh the serialized mesh\n     * @param scene the scene to create the goldberg mesh in\n     * @returns the created goldberg mesh\n     */\n    GoldbergMesh.Parse = function (parsedMesh, scene) {\n        var goldbergData = parsedMesh.goldbergData;\n        goldbergData.faceColors = goldbergData.faceColors.map(function (el) { return Color4.FromArray(el); });\n        goldbergData.faceCenters = goldbergData.faceCenters.map(function (el) { return Vector3.FromArray(el); });\n        goldbergData.faceZaxis = goldbergData.faceZaxis.map(function (el) { return Vector3.FromArray(el); });\n        goldbergData.faceXaxis = goldbergData.faceXaxis.map(function (el) { return Vector3.FromArray(el); });\n        goldbergData.faceYaxis = goldbergData.faceYaxis.map(function (el) { return Vector3.FromArray(el); });\n        var goldberg = new GoldbergMesh(parsedMesh.name, scene);\n        goldberg.goldbergData = goldbergData;\n        return goldberg;\n    };\n    return GoldbergMesh;\n}(Mesh));\nexport { GoldbergMesh };\n//# sourceMappingURL=goldbergMesh.js.map","import { __extends } from \"tslib\";\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nMesh._GroundMeshParser = function (parsedMesh, scene) {\n    return GroundMesh.Parse(parsedMesh, scene);\n};\n/**\n * Mesh representing the ground\n */\nvar GroundMesh = /** @class */ (function (_super) {\n    __extends(GroundMesh, _super);\n    function GroundMesh(name, scene) {\n        var _this = _super.call(this, name, scene) || this;\n        /** If octree should be generated */\n        _this.generateOctree = false;\n        return _this;\n    }\n    /**\n     * \"GroundMesh\"\n     * @returns \"GroundMesh\"\n     */\n    GroundMesh.prototype.getClassName = function () {\n        return \"GroundMesh\";\n    };\n    Object.defineProperty(GroundMesh.prototype, \"subdivisions\", {\n        /**\n         * The minimum of x and y subdivisions\n         */\n        get: function () {\n            return Math.min(this._subdivisionsX, this._subdivisionsY);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(GroundMesh.prototype, \"subdivisionsX\", {\n        /**\n         * X subdivisions\n         */\n        get: function () {\n            return this._subdivisionsX;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(GroundMesh.prototype, \"subdivisionsY\", {\n        /**\n         * Y subdivisions\n         */\n        get: function () {\n            return this._subdivisionsY;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\n     * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\n     * @param chunksCount the number of subdivisions for x and y\n     * @param octreeBlocksSize (Default: 32)\n     */\n    GroundMesh.prototype.optimize = function (chunksCount, octreeBlocksSize) {\n        if (octreeBlocksSize === void 0) { octreeBlocksSize = 32; }\n        this._subdivisionsX = chunksCount;\n        this._subdivisionsY = chunksCount;\n        this.subdivide(chunksCount);\n        // Call the octree system optimization if it is defined.\n        var thisAsAny = this;\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\n        }\n    };\n    /**\n     * Returns a height (y) value in the World system :\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\n     * @param x x coordinate\n     * @param z z coordinate\n     * @returns the ground y position if (x, z) are outside the ground surface.\n     */\n    GroundMesh.prototype.getHeightAtCoordinates = function (x, z) {\n        var world = this.getWorldMatrix();\n        var invMat = TmpVectors.Matrix[5];\n        world.invertToRef(invMat);\n        var tmpVect = TmpVectors.Vector3[8];\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\n        x = tmpVect.x;\n        z = tmpVect.z;\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n            return this.position.y;\n        }\n        if (!this._heightQuads || this._heightQuads.length == 0) {\n            this._initHeightQuads();\n            this._computeHeightQuads();\n        }\n        var facet = this._getFacetAt(x, z);\n        var y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\n        // return y in the World system\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\n        return tmpVect.y;\n    };\n    /**\n     * Returns a normalized vector (Vector3) orthogonal to the ground\n     * at the ground coordinates (x, z) expressed in the World system.\n     * @param x x coordinate\n     * @param z z coordinate\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\n     */\n    GroundMesh.prototype.getNormalAtCoordinates = function (x, z) {\n        var normal = new Vector3(0.0, 1.0, 0.0);\n        this.getNormalAtCoordinatesToRef(x, z, normal);\n        return normal;\n    };\n    /**\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\n     * at the ground coordinates (x, z) expressed in the World system.\n     * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\n     * @param x x coordinate\n     * @param z z coordinate\n     * @param ref vector to store the result\n     * @returns the GroundMesh.\n     */\n    GroundMesh.prototype.getNormalAtCoordinatesToRef = function (x, z, ref) {\n        var world = this.getWorldMatrix();\n        var tmpMat = TmpVectors.Matrix[5];\n        world.invertToRef(tmpMat);\n        var tmpVect = TmpVectors.Vector3[8];\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\n        x = tmpVect.x;\n        z = tmpVect.z;\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n            return this;\n        }\n        if (!this._heightQuads || this._heightQuads.length == 0) {\n            this._initHeightQuads();\n            this._computeHeightQuads();\n        }\n        var facet = this._getFacetAt(x, z);\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\n        return this;\n    };\n    /**\n     * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\n     * if the ground has been updated.\n     * This can be used in the render loop.\n     * @returns the GroundMesh.\n     */\n    GroundMesh.prototype.updateCoordinateHeights = function () {\n        if (!this._heightQuads || this._heightQuads.length == 0) {\n            this._initHeightQuads();\n        }\n        this._computeHeightQuads();\n        return this;\n    };\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\n    GroundMesh.prototype._getFacetAt = function (x, z) {\n        // retrieve col and row from x, z coordinates in the ground local system\n        var col = Math.floor(((x + this._maxX) * this._subdivisionsX) / this._width);\n        var row = Math.floor((-(z + this._maxZ) * this._subdivisionsY) / this._height + this._subdivisionsY);\n        var quad = this._heightQuads[row * this._subdivisionsX + col];\n        var facet;\n        if (z < quad.slope.x * x + quad.slope.y) {\n            facet = quad.facet1;\n        }\n        else {\n            facet = quad.facet2;\n        }\n        return facet;\n    };\n    //  Creates and populates the heightMap array with \"facet\" elements :\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n    // Returns the GroundMesh.\n    GroundMesh.prototype._initHeightQuads = function () {\n        var subdivisionsX = this._subdivisionsX;\n        var subdivisionsY = this._subdivisionsY;\n        this._heightQuads = new Array();\n        for (var row = 0; row < subdivisionsY; row++) {\n            for (var col = 0; col < subdivisionsX; col++) {\n                var quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\n                this._heightQuads[row * subdivisionsX + col] = quad;\n            }\n        }\n        return this;\n    };\n    // Compute each quad element values and update the the heightMap array :\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n    // Returns the GroundMesh.\n    GroundMesh.prototype._computeHeightQuads = function () {\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\n        if (!positions) {\n            return this;\n        }\n        var v1 = TmpVectors.Vector3[3];\n        var v2 = TmpVectors.Vector3[2];\n        var v3 = TmpVectors.Vector3[1];\n        var v4 = TmpVectors.Vector3[0];\n        var v1v2 = TmpVectors.Vector3[4];\n        var v1v3 = TmpVectors.Vector3[5];\n        var v1v4 = TmpVectors.Vector3[6];\n        var norm1 = TmpVectors.Vector3[7];\n        var norm2 = TmpVectors.Vector3[8];\n        var i = 0;\n        var j = 0;\n        var k = 0;\n        var cd = 0; // 2D slope coefficient : z = cd * x + h\n        var h = 0;\n        var d1 = 0; // facet plane equation : ax + by + cz + d = 0\n        var d2 = 0;\n        var subdivisionsX = this._subdivisionsX;\n        var subdivisionsY = this._subdivisionsY;\n        for (var row = 0; row < subdivisionsY; row++) {\n            for (var col = 0; col < subdivisionsX; col++) {\n                i = col * 3;\n                j = row * (subdivisionsX + 1) * 3;\n                k = (row + 1) * (subdivisionsX + 1) * 3;\n                v1.x = positions[j + i];\n                v1.y = positions[j + i + 1];\n                v1.z = positions[j + i + 2];\n                v2.x = positions[j + i + 3];\n                v2.y = positions[j + i + 4];\n                v2.z = positions[j + i + 5];\n                v3.x = positions[k + i];\n                v3.y = positions[k + i + 1];\n                v3.z = positions[k + i + 2];\n                v4.x = positions[k + i + 3];\n                v4.y = positions[k + i + 4];\n                v4.z = positions[k + i + 5];\n                // 2D slope V1V4\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\n                h = v1.z - cd * v1.x; // v1 belongs to the slope\n                // facet equations :\n                // we compute each facet normal vector\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\n                // we compute the value d by applying the equation to v1 which belongs to the plane\n                // then we store the facet equation in a Vector4\n                v2.subtractToRef(v1, v1v2);\n                v3.subtractToRef(v1, v1v3);\n                v4.subtractToRef(v1, v1v4);\n                Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\n                norm1.normalize();\n                norm2.normalize();\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\n                var quad = this._heightQuads[row * subdivisionsX + col];\n                quad.slope.copyFromFloats(cd, h);\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\n            }\n        }\n        return this;\n    };\n    /**\n     * Serializes this ground mesh\n     * @param serializationObject object to write serialization to\n     */\n    GroundMesh.prototype.serialize = function (serializationObject) {\n        _super.prototype.serialize.call(this, serializationObject);\n        serializationObject.subdivisionsX = this._subdivisionsX;\n        serializationObject.subdivisionsY = this._subdivisionsY;\n        serializationObject.minX = this._minX;\n        serializationObject.maxX = this._maxX;\n        serializationObject.minZ = this._minZ;\n        serializationObject.maxZ = this._maxZ;\n        serializationObject.width = this._width;\n        serializationObject.height = this._height;\n    };\n    /**\n     * Parses a serialized ground mesh\n     * @param parsedMesh the serialized mesh\n     * @param scene the scene to create the ground mesh in\n     * @returns the created ground mesh\n     */\n    GroundMesh.Parse = function (parsedMesh, scene) {\n        var result = new GroundMesh(parsedMesh.name, scene);\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\n        result._minX = parsedMesh.minX;\n        result._maxX = parsedMesh.maxX;\n        result._minZ = parsedMesh.minZ;\n        result._maxZ = parsedMesh.maxZ;\n        result._width = parsedMesh.width;\n        result._height = parsedMesh.height;\n        return result;\n    };\n    return GroundMesh;\n}(Mesh));\nexport { GroundMesh };\n//# sourceMappingURL=groundMesh.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { AsyncLoop } from \"../Misc/tools.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Class used to specify simplification options\n * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification\n */\nvar SimplificationSettings = /** @class */ (function () {\n    /**\n     * Creates a SimplificationSettings\n     * @param quality expected quality\n     * @param distance distance when this optimized version should be used\n     * @param optimizeMesh already optimized mesh\n     */\n    function SimplificationSettings(\n    /** expected quality */\n    quality, \n    /** distance when this optimized version should be used */\n    distance, \n    /** already optimized mesh  */\n    optimizeMesh) {\n        this.quality = quality;\n        this.distance = distance;\n        this.optimizeMesh = optimizeMesh;\n    }\n    return SimplificationSettings;\n}());\nexport { SimplificationSettings };\n/**\n * Queue used to order the simplification tasks\n * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification\n */\nvar SimplificationQueue = /** @class */ (function () {\n    /**\n     * Creates a new queue\n     */\n    function SimplificationQueue() {\n        this.running = false;\n        this._simplificationArray = [];\n    }\n    /**\n     * Adds a new simplification task\n     * @param task defines a task to add\n     */\n    SimplificationQueue.prototype.addTask = function (task) {\n        this._simplificationArray.push(task);\n    };\n    /**\n     * Execute next task\n     */\n    SimplificationQueue.prototype.executeNext = function () {\n        var task = this._simplificationArray.pop();\n        if (task) {\n            this.running = true;\n            this.runSimplification(task);\n        }\n        else {\n            this.running = false;\n        }\n    };\n    /**\n     * Execute a simplification task\n     * @param task defines the task to run\n     */\n    SimplificationQueue.prototype.runSimplification = function (task) {\n        var _this = this;\n        if (task.parallelProcessing) {\n            //parallel simplifier\n            task.settings.forEach(function (setting) {\n                var simplifier = _this._getSimplifier(task);\n                simplifier.simplify(setting, function (newMesh) {\n                    if (setting.distance !== undefined) {\n                        task.mesh.addLODLevel(setting.distance, newMesh);\n                    }\n                    newMesh.isVisible = true;\n                    //check if it is the last\n                    if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {\n                        //all done, run the success callback.\n                        task.successCallback();\n                    }\n                    _this.executeNext();\n                });\n            });\n        }\n        else {\n            //single simplifier.\n            var simplifier_1 = this._getSimplifier(task);\n            var runDecimation_1 = function (setting, callback) {\n                simplifier_1.simplify(setting, function (newMesh) {\n                    if (setting.distance !== undefined) {\n                        task.mesh.addLODLevel(setting.distance, newMesh);\n                    }\n                    newMesh.isVisible = true;\n                    //run the next quality level\n                    callback();\n                });\n            };\n            AsyncLoop.Run(task.settings.length, function (loop) {\n                runDecimation_1(task.settings[loop.index], function () {\n                    loop.executeNext();\n                });\n            }, function () {\n                //execution ended, run the success callback.\n                if (task.successCallback) {\n                    task.successCallback();\n                }\n                _this.executeNext();\n            });\n        }\n    };\n    SimplificationQueue.prototype._getSimplifier = function (task) {\n        switch (task.simplificationType) {\n            case SimplificationType.QUADRATIC:\n            default:\n                return new QuadraticErrorSimplification(task.mesh);\n        }\n    };\n    return SimplificationQueue;\n}());\nexport { SimplificationQueue };\n/**\n * The implemented types of simplification\n * At the moment only Quadratic Error Decimation is implemented\n * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification\n */\nexport var SimplificationType;\n(function (SimplificationType) {\n    /** Quadratic error decimation */\n    SimplificationType[SimplificationType[\"QUADRATIC\"] = 0] = \"QUADRATIC\";\n})(SimplificationType || (SimplificationType = {}));\nvar DecimationTriangle = /** @class */ (function () {\n    function DecimationTriangle(_vertices) {\n        this._vertices = _vertices;\n        this.error = new Array(4);\n        this.deleted = false;\n        this.isDirty = false;\n        this.deletePending = false;\n        this.borderFactor = 0;\n    }\n    return DecimationTriangle;\n}());\nvar DecimationVertex = /** @class */ (function () {\n    function DecimationVertex(position, id) {\n        this.position = position;\n        this.id = id;\n        this.isBorder = true;\n        this.q = new QuadraticMatrix();\n        this.triangleCount = 0;\n        this.triangleStart = 0;\n        this.originalOffsets = [];\n    }\n    DecimationVertex.prototype.updatePosition = function (newPosition) {\n        this.position.copyFrom(newPosition);\n    };\n    return DecimationVertex;\n}());\nvar QuadraticMatrix = /** @class */ (function () {\n    function QuadraticMatrix(data) {\n        this.data = new Array(10);\n        for (var i = 0; i < 10; ++i) {\n            if (data && data[i]) {\n                this.data[i] = data[i];\n            }\n            else {\n                this.data[i] = 0;\n            }\n        }\n    }\n    QuadraticMatrix.prototype.det = function (a11, a12, a13, a21, a22, a23, a31, a32, a33) {\n        var det = this.data[a11] * this.data[a22] * this.data[a33] +\n            this.data[a13] * this.data[a21] * this.data[a32] +\n            this.data[a12] * this.data[a23] * this.data[a31] -\n            this.data[a13] * this.data[a22] * this.data[a31] -\n            this.data[a11] * this.data[a23] * this.data[a32] -\n            this.data[a12] * this.data[a21] * this.data[a33];\n        return det;\n    };\n    QuadraticMatrix.prototype.addInPlace = function (matrix) {\n        for (var i = 0; i < 10; ++i) {\n            this.data[i] += matrix.data[i];\n        }\n    };\n    QuadraticMatrix.prototype.addArrayInPlace = function (data) {\n        for (var i = 0; i < 10; ++i) {\n            this.data[i] += data[i];\n        }\n    };\n    QuadraticMatrix.prototype.add = function (matrix) {\n        var m = new QuadraticMatrix();\n        for (var i = 0; i < 10; ++i) {\n            m.data[i] = this.data[i] + matrix.data[i];\n        }\n        return m;\n    };\n    QuadraticMatrix.FromData = function (a, b, c, d) {\n        return new QuadraticMatrix(QuadraticMatrix.DataFromNumbers(a, b, c, d));\n    };\n    //returning an array to avoid garbage collection\n    QuadraticMatrix.DataFromNumbers = function (a, b, c, d) {\n        return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];\n    };\n    return QuadraticMatrix;\n}());\nvar Reference = /** @class */ (function () {\n    function Reference(vertexId, triangleId) {\n        this.vertexId = vertexId;\n        this.triangleId = triangleId;\n    }\n    return Reference;\n}());\n/**\n * An implementation of the Quadratic Error simplification algorithm.\n * Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf\n * Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS\n * @author RaananW\n * @see https://doc.babylonjs.com/how_to/in-browser_mesh_simplification\n */\nvar QuadraticErrorSimplification = /** @class */ (function () {\n    /**\n     * Creates a new QuadraticErrorSimplification\n     * @param _mesh defines the target mesh\n     */\n    function QuadraticErrorSimplification(_mesh) {\n        this._mesh = _mesh;\n        /** Gets or sets the number pf sync iterations */\n        this.syncIterations = 5000;\n        this.aggressiveness = 7;\n        this.decimationIterations = 100;\n        this.boundingBoxEpsilon = Epsilon;\n    }\n    /**\n     * Simplification of a given mesh according to the given settings.\n     * Since this requires computation, it is assumed that the function runs async.\n     * @param settings The settings of the simplification, including quality and distance\n     * @param successCallback A callback that will be called after the mesh was simplified.\n     */\n    QuadraticErrorSimplification.prototype.simplify = function (settings, successCallback) {\n        var _this = this;\n        this._initDecimatedMesh();\n        //iterating through the submeshes array, one after the other.\n        AsyncLoop.Run(this._mesh.subMeshes.length, function (loop) {\n            _this._initWithMesh(loop.index, function () {\n                _this._runDecimation(settings, loop.index, function () {\n                    loop.executeNext();\n                });\n            }, settings.optimizeMesh);\n        }, function () {\n            setTimeout(function () {\n                successCallback(_this._reconstructedMesh);\n            }, 0);\n        });\n    };\n    QuadraticErrorSimplification.prototype._runDecimation = function (settings, submeshIndex, successCallback) {\n        var _this = this;\n        var targetCount = ~~(this._triangles.length * settings.quality);\n        var deletedTriangles = 0;\n        var triangleCount = this._triangles.length;\n        var iterationFunction = function (iteration, callback) {\n            setTimeout(function () {\n                if (iteration % 5 === 0) {\n                    _this._updateMesh(iteration === 0);\n                }\n                for (var i = 0; i < _this._triangles.length; ++i) {\n                    _this._triangles[i].isDirty = false;\n                }\n                var threshold = 0.000000001 * Math.pow(iteration + 3, _this.aggressiveness);\n                var trianglesIterator = function (i) {\n                    var tIdx = ~~((_this._triangles.length / 2 + i) % _this._triangles.length);\n                    var t = _this._triangles[tIdx];\n                    if (!t) {\n                        return;\n                    }\n                    if (t.error[3] > threshold || t.deleted || t.isDirty) {\n                        return;\n                    }\n                    var _loop_1 = function (j) {\n                        if (t.error[j] < threshold) {\n                            var deleted0 = [];\n                            var deleted1 = [];\n                            var v0 = t._vertices[j];\n                            var v1 = t._vertices[(j + 1) % 3];\n                            if (v0.isBorder || v1.isBorder) {\n                                return \"continue\";\n                            }\n                            var p = Vector3.Zero();\n                            // var n = Vector3.Zero();\n                            // var uv = Vector2.Zero();\n                            // var color = new Color4(0, 0, 0, 1);\n                            _this._calculateError(v0, v1, p);\n                            var delTr = new Array();\n                            if (_this._isFlipped(v0, v1, p, deleted0, delTr)) {\n                                return \"continue\";\n                            }\n                            if (_this._isFlipped(v1, v0, p, deleted1, delTr)) {\n                                return \"continue\";\n                            }\n                            if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {\n                                return \"continue\";\n                            }\n                            var uniqueArray_1 = new Array();\n                            delTr.forEach(function (deletedT) {\n                                if (uniqueArray_1.indexOf(deletedT) === -1) {\n                                    deletedT.deletePending = true;\n                                    uniqueArray_1.push(deletedT);\n                                }\n                            });\n                            if (uniqueArray_1.length % 2 !== 0) {\n                                return \"continue\";\n                            }\n                            v0.q = v1.q.add(v0.q);\n                            v0.updatePosition(p);\n                            var tStart = _this._references.length;\n                            deletedTriangles = _this._updateTriangles(v0, v0, deleted0, deletedTriangles);\n                            deletedTriangles = _this._updateTriangles(v0, v1, deleted1, deletedTriangles);\n                            var tCount = _this._references.length - tStart;\n                            if (tCount <= v0.triangleCount) {\n                                if (tCount) {\n                                    for (var c = 0; c < tCount; c++) {\n                                        _this._references[v0.triangleStart + c] = _this._references[tStart + c];\n                                    }\n                                }\n                            }\n                            else {\n                                v0.triangleStart = tStart;\n                            }\n                            v0.triangleCount = tCount;\n                            return \"break\";\n                        }\n                    };\n                    for (var j = 0; j < 3; ++j) {\n                        var state_1 = _loop_1(j);\n                        if (state_1 === \"break\")\n                            break;\n                    }\n                };\n                AsyncLoop.SyncAsyncForLoop(_this._triangles.length, _this.syncIterations, trianglesIterator, callback, function () {\n                    return triangleCount - deletedTriangles <= targetCount;\n                });\n            }, 0);\n        };\n        AsyncLoop.Run(this.decimationIterations, function (loop) {\n            if (triangleCount - deletedTriangles <= targetCount) {\n                loop.breakLoop();\n            }\n            else {\n                iterationFunction(loop.index, function () {\n                    loop.executeNext();\n                });\n            }\n        }, function () {\n            setTimeout(function () {\n                //reconstruct this part of the mesh\n                _this._reconstructMesh(submeshIndex);\n                successCallback();\n            }, 0);\n        });\n    };\n    QuadraticErrorSimplification.prototype._initWithMesh = function (submeshIndex, callback, optimizeMesh) {\n        var _this = this;\n        this._vertices = [];\n        this._triangles = [];\n        var positionData = this._mesh.getVerticesData(VertexBuffer.PositionKind);\n        var indices = this._mesh.getIndices();\n        var submesh = this._mesh.subMeshes[submeshIndex];\n        var findInVertices = function (positionToSearch) {\n            if (optimizeMesh) {\n                for (var ii = 0; ii < _this._vertices.length; ++ii) {\n                    if (_this._vertices[ii].position.equalsWithEpsilon(positionToSearch, 0.0001)) {\n                        return _this._vertices[ii];\n                    }\n                }\n            }\n            return null;\n        };\n        var vertexReferences = [];\n        var vertexInit = function (i) {\n            if (!positionData) {\n                return;\n            }\n            var offset = i + submesh.verticesStart;\n            var position = Vector3.FromArray(positionData, offset * 3);\n            var vertex = findInVertices(position) || new DecimationVertex(position, _this._vertices.length);\n            vertex.originalOffsets.push(offset);\n            if (vertex.id === _this._vertices.length) {\n                _this._vertices.push(vertex);\n            }\n            vertexReferences.push(vertex.id);\n        };\n        //var totalVertices = mesh.getTotalVertices();\n        var totalVertices = submesh.verticesCount;\n        AsyncLoop.SyncAsyncForLoop(totalVertices, (this.syncIterations / 4) >> 0, vertexInit, function () {\n            var indicesInit = function (i) {\n                if (!indices) {\n                    return;\n                }\n                var offset = submesh.indexStart / 3 + i;\n                var pos = offset * 3;\n                var i0 = indices[pos + 0];\n                var i1 = indices[pos + 1];\n                var i2 = indices[pos + 2];\n                var v0 = _this._vertices[vertexReferences[i0 - submesh.verticesStart]];\n                var v1 = _this._vertices[vertexReferences[i1 - submesh.verticesStart]];\n                var v2 = _this._vertices[vertexReferences[i2 - submesh.verticesStart]];\n                var triangle = new DecimationTriangle([v0, v1, v2]);\n                triangle.originalOffset = pos;\n                _this._triangles.push(triangle);\n            };\n            AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, _this.syncIterations, indicesInit, function () {\n                _this._init(callback);\n            });\n        });\n    };\n    QuadraticErrorSimplification.prototype._init = function (callback) {\n        var _this = this;\n        var triangleInit1 = function (i) {\n            var t = _this._triangles[i];\n            t.normal = Vector3.Cross(t._vertices[1].position.subtract(t._vertices[0].position), t._vertices[2].position.subtract(t._vertices[0].position)).normalize();\n            for (var j = 0; j < 3; j++) {\n                t._vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -Vector3.Dot(t.normal, t._vertices[0].position)));\n            }\n        };\n        AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit1, function () {\n            var triangleInit2 = function (i) {\n                var t = _this._triangles[i];\n                for (var j = 0; j < 3; ++j) {\n                    t.error[j] = _this._calculateError(t._vertices[j], t._vertices[(j + 1) % 3]);\n                }\n                t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\n            };\n            AsyncLoop.SyncAsyncForLoop(_this._triangles.length, _this.syncIterations, triangleInit2, function () {\n                callback();\n            });\n        });\n    };\n    QuadraticErrorSimplification.prototype._reconstructMesh = function (submeshIndex) {\n        var newTriangles = [];\n        var i;\n        for (i = 0; i < this._vertices.length; ++i) {\n            this._vertices[i].triangleCount = 0;\n        }\n        var t;\n        var j;\n        for (i = 0; i < this._triangles.length; ++i) {\n            if (!this._triangles[i].deleted) {\n                t = this._triangles[i];\n                for (j = 0; j < 3; ++j) {\n                    t._vertices[j].triangleCount = 1;\n                }\n                newTriangles.push(t);\n            }\n        }\n        var newPositionData = (this._reconstructedMesh.getVerticesData(VertexBuffer.PositionKind) || []);\n        var newNormalData = (this._reconstructedMesh.getVerticesData(VertexBuffer.NormalKind) || []);\n        var newUVsData = (this._reconstructedMesh.getVerticesData(VertexBuffer.UVKind) || []);\n        var newColorsData = (this._reconstructedMesh.getVerticesData(VertexBuffer.ColorKind) || []);\n        var normalData = this._mesh.getVerticesData(VertexBuffer.NormalKind);\n        var uvs = this._mesh.getVerticesData(VertexBuffer.UVKind);\n        var colorsData = this._mesh.getVerticesData(VertexBuffer.ColorKind);\n        var vertexCount = 0;\n        var _loop_2 = function () {\n            var vertex = this_1._vertices[i];\n            vertex.id = vertexCount;\n            if (vertex.triangleCount) {\n                vertex.originalOffsets.forEach(function (originalOffset) {\n                    newPositionData.push(vertex.position.x);\n                    newPositionData.push(vertex.position.y);\n                    newPositionData.push(vertex.position.z);\n                    if (normalData && normalData.length) {\n                        newNormalData.push(normalData[originalOffset * 3]);\n                        newNormalData.push(normalData[originalOffset * 3 + 1]);\n                        newNormalData.push(normalData[originalOffset * 3 + 2]);\n                    }\n                    if (uvs && uvs.length) {\n                        newUVsData.push(uvs[originalOffset * 2]);\n                        newUVsData.push(uvs[originalOffset * 2 + 1]);\n                    }\n                    if (colorsData && colorsData.length) {\n                        newColorsData.push(colorsData[originalOffset * 4]);\n                        newColorsData.push(colorsData[originalOffset * 4 + 1]);\n                        newColorsData.push(colorsData[originalOffset * 4 + 2]);\n                        newColorsData.push(colorsData[originalOffset * 4 + 3]);\n                    }\n                    ++vertexCount;\n                });\n            }\n        };\n        var this_1 = this;\n        for (i = 0; i < this._vertices.length; ++i) {\n            _loop_2();\n        }\n        var startingIndex = this._reconstructedMesh.getTotalIndices();\n        var startingVertex = this._reconstructedMesh.getTotalVertices();\n        var submeshesArray = this._reconstructedMesh.subMeshes;\n        this._reconstructedMesh.subMeshes = [];\n        var newIndicesArray = this._reconstructedMesh.getIndices(); //[];\n        var originalIndices = this._mesh.getIndices();\n        for (i = 0; i < newTriangles.length; ++i) {\n            t = newTriangles[i]; //now get the new referencing point for each vertex\n            [0, 1, 2].forEach(function (idx) {\n                var id = originalIndices[t.originalOffset + idx];\n                var offset = t._vertices[idx].originalOffsets.indexOf(id);\n                if (offset < 0) {\n                    offset = 0;\n                }\n                newIndicesArray.push(t._vertices[idx].id + offset + startingVertex);\n            });\n        }\n        //overwriting the old vertex buffers and indices.\n        this._reconstructedMesh.setIndices(newIndicesArray);\n        this._reconstructedMesh.setVerticesData(VertexBuffer.PositionKind, newPositionData);\n        if (newNormalData.length > 0) {\n            this._reconstructedMesh.setVerticesData(VertexBuffer.NormalKind, newNormalData);\n        }\n        if (newUVsData.length > 0) {\n            this._reconstructedMesh.setVerticesData(VertexBuffer.UVKind, newUVsData);\n        }\n        if (newColorsData.length > 0) {\n            this._reconstructedMesh.setVerticesData(VertexBuffer.ColorKind, newColorsData);\n        }\n        //create submesh\n        var originalSubmesh = this._mesh.subMeshes[submeshIndex];\n        if (submeshIndex > 0) {\n            this._reconstructedMesh.subMeshes = [];\n            submeshesArray.forEach(function (submesh) {\n                SubMesh.AddToMesh(submesh.materialIndex, submesh.verticesStart, submesh.verticesCount, \n                /* 0, newPositionData.length/3, */ submesh.indexStart, submesh.indexCount, submesh.getMesh());\n            });\n            SubMesh.AddToMesh(originalSubmesh.materialIndex, startingVertex, vertexCount, \n            /* 0, newPositionData.length / 3, */ startingIndex, newTriangles.length * 3, this._reconstructedMesh);\n        }\n    };\n    QuadraticErrorSimplification.prototype._initDecimatedMesh = function () {\n        this._reconstructedMesh = new Mesh(this._mesh.name + \"Decimated\", this._mesh.getScene());\n        this._reconstructedMesh.material = this._mesh.material;\n        this._reconstructedMesh.parent = this._mesh.parent;\n        this._reconstructedMesh.isVisible = false;\n        this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;\n    };\n    QuadraticErrorSimplification.prototype._isFlipped = function (vertex1, vertex2, point, deletedArray, delTr) {\n        for (var i = 0; i < vertex1.triangleCount; ++i) {\n            var t = this._triangles[this._references[vertex1.triangleStart + i].triangleId];\n            if (t.deleted) {\n                continue;\n            }\n            var s = this._references[vertex1.triangleStart + i].vertexId;\n            var v1 = t._vertices[(s + 1) % 3];\n            var v2 = t._vertices[(s + 2) % 3];\n            if (v1 === vertex2 || v2 === vertex2) {\n                deletedArray[i] = true;\n                delTr.push(t);\n                continue;\n            }\n            var d1 = v1.position.subtract(point);\n            d1 = d1.normalize();\n            var d2 = v2.position.subtract(point);\n            d2 = d2.normalize();\n            if (Math.abs(Vector3.Dot(d1, d2)) > 0.999) {\n                return true;\n            }\n            var normal = Vector3.Cross(d1, d2).normalize();\n            deletedArray[i] = false;\n            if (Vector3.Dot(normal, t.normal) < 0.2) {\n                return true;\n            }\n        }\n        return false;\n    };\n    QuadraticErrorSimplification.prototype._updateTriangles = function (origVertex, vertex, deletedArray, deletedTriangles) {\n        var newDeleted = deletedTriangles;\n        for (var i = 0; i < vertex.triangleCount; ++i) {\n            var ref = this._references[vertex.triangleStart + i];\n            var t = this._triangles[ref.triangleId];\n            if (t.deleted) {\n                continue;\n            }\n            if (deletedArray[i] && t.deletePending) {\n                t.deleted = true;\n                newDeleted++;\n                continue;\n            }\n            t._vertices[ref.vertexId] = origVertex;\n            t.isDirty = true;\n            t.error[0] = this._calculateError(t._vertices[0], t._vertices[1]) + t.borderFactor / 2;\n            t.error[1] = this._calculateError(t._vertices[1], t._vertices[2]) + t.borderFactor / 2;\n            t.error[2] = this._calculateError(t._vertices[2], t._vertices[0]) + t.borderFactor / 2;\n            t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\n            this._references.push(ref);\n        }\n        return newDeleted;\n    };\n    QuadraticErrorSimplification.prototype._identifyBorder = function () {\n        for (var i = 0; i < this._vertices.length; ++i) {\n            var vCount = [];\n            var vId = [];\n            var v = this._vertices[i];\n            var j = void 0;\n            for (j = 0; j < v.triangleCount; ++j) {\n                var triangle = this._triangles[this._references[v.triangleStart + j].triangleId];\n                for (var ii = 0; ii < 3; ii++) {\n                    var ofs = 0;\n                    var vv = triangle._vertices[ii];\n                    while (ofs < vCount.length) {\n                        if (vId[ofs] === vv.id) {\n                            break;\n                        }\n                        ++ofs;\n                    }\n                    if (ofs === vCount.length) {\n                        vCount.push(1);\n                        vId.push(vv.id);\n                    }\n                    else {\n                        vCount[ofs]++;\n                    }\n                }\n            }\n            for (j = 0; j < vCount.length; ++j) {\n                if (vCount[j] === 1) {\n                    this._vertices[vId[j]].isBorder = true;\n                }\n                else {\n                    this._vertices[vId[j]].isBorder = false;\n                }\n            }\n        }\n    };\n    QuadraticErrorSimplification.prototype._updateMesh = function (identifyBorders) {\n        if (identifyBorders === void 0) { identifyBorders = false; }\n        var i;\n        if (!identifyBorders) {\n            var newTrianglesVector = [];\n            for (i = 0; i < this._triangles.length; ++i) {\n                if (!this._triangles[i].deleted) {\n                    newTrianglesVector.push(this._triangles[i]);\n                }\n            }\n            this._triangles = newTrianglesVector;\n        }\n        for (i = 0; i < this._vertices.length; ++i) {\n            this._vertices[i].triangleCount = 0;\n            this._vertices[i].triangleStart = 0;\n        }\n        var t;\n        var j;\n        var v;\n        for (i = 0; i < this._triangles.length; ++i) {\n            t = this._triangles[i];\n            for (j = 0; j < 3; ++j) {\n                v = t._vertices[j];\n                v.triangleCount++;\n            }\n        }\n        var tStart = 0;\n        for (i = 0; i < this._vertices.length; ++i) {\n            this._vertices[i].triangleStart = tStart;\n            tStart += this._vertices[i].triangleCount;\n            this._vertices[i].triangleCount = 0;\n        }\n        var newReferences = new Array(this._triangles.length * 3);\n        for (i = 0; i < this._triangles.length; ++i) {\n            t = this._triangles[i];\n            for (j = 0; j < 3; ++j) {\n                v = t._vertices[j];\n                newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);\n                v.triangleCount++;\n            }\n        }\n        this._references = newReferences;\n        if (identifyBorders) {\n            this._identifyBorder();\n        }\n    };\n    QuadraticErrorSimplification.prototype._vertexError = function (q, point) {\n        var x = point.x;\n        var y = point.y;\n        var z = point.z;\n        return (q.data[0] * x * x +\n            2 * q.data[1] * x * y +\n            2 * q.data[2] * x * z +\n            2 * q.data[3] * x +\n            q.data[4] * y * y +\n            2 * q.data[5] * y * z +\n            2 * q.data[6] * y +\n            q.data[7] * z * z +\n            2 * q.data[8] * z +\n            q.data[9]);\n    };\n    QuadraticErrorSimplification.prototype._calculateError = function (vertex1, vertex2, pointResult) {\n        var q = vertex1.q.add(vertex2.q);\n        var border = vertex1.isBorder && vertex2.isBorder;\n        var error = 0;\n        var qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);\n        if (qDet !== 0 && !border) {\n            if (!pointResult) {\n                pointResult = Vector3.Zero();\n            }\n            pointResult.x = (-1 / qDet) * q.det(1, 2, 3, 4, 5, 6, 5, 7, 8);\n            pointResult.y = (1 / qDet) * q.det(0, 2, 3, 1, 5, 6, 2, 7, 8);\n            pointResult.z = (-1 / qDet) * q.det(0, 1, 3, 1, 4, 6, 2, 5, 8);\n            error = this._vertexError(q, pointResult);\n        }\n        else {\n            var p3 = vertex1.position.add(vertex2.position).divide(new Vector3(2, 2, 2));\n            //var norm3 = (vertex1.normal.add(vertex2.normal)).divide(new Vector3(2, 2, 2)).normalize();\n            var error1 = this._vertexError(q, vertex1.position);\n            var error2 = this._vertexError(q, vertex2.position);\n            var error3 = this._vertexError(q, p3);\n            error = Math.min(error1, error2, error3);\n            if (error === error1) {\n                if (pointResult) {\n                    pointResult.copyFrom(vertex1.position);\n                }\n            }\n            else if (error === error2) {\n                if (pointResult) {\n                    pointResult.copyFrom(vertex2.position);\n                }\n            }\n            else {\n                if (pointResult) {\n                    pointResult.copyFrom(p3);\n                }\n            }\n        }\n        return error;\n    };\n    return QuadraticErrorSimplification;\n}());\nexport { QuadraticErrorSimplification };\n//# sourceMappingURL=meshSimplification.js.map","import { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\n\n/**\n * Unique ID when we import meshes from Babylon to CSG\n */\nvar currentCSGMeshId = 0;\n/**\n * Represents a vertex of a polygon. Use your own vertex class instead of this\n * one to provide additional features like texture coordinates and vertex\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\n * is not used anywhere else.\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\n */\nvar Vertex = /** @class */ (function () {\n    /**\n     * Initializes the vertex\n     * @param pos The position of the vertex\n     * @param normal The normal of the vertex\n     * @param uv The texture coordinate of the vertex\n     * @param vertColor The RGBA color of the vertex\n     */\n    function Vertex(\n    /**\n     * The position of the vertex\n     */\n    pos, \n    /**\n     * The normal of the vertex\n     */\n    normal, \n    /**\n     * The texture coordinate of the vertex\n     */\n    uv, \n    /**\n     * The texture coordinate of the vertex\n     */\n    vertColor) {\n        this.pos = pos;\n        this.normal = normal;\n        this.uv = uv;\n        this.vertColor = vertColor;\n    }\n    /**\n     * Make a clone, or deep copy, of the vertex\n     * @returns A new Vertex\n     */\n    Vertex.prototype.clone = function () {\n        var _a, _b;\n        return new Vertex(this.pos.clone(), this.normal.clone(), (_a = this.uv) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.vertColor) === null || _b === void 0 ? void 0 : _b.clone());\n    };\n    /**\n     * Invert all orientation-specific data (e.g. vertex normal). Called when the\n     * orientation of a polygon is flipped.\n     */\n    Vertex.prototype.flip = function () {\n        this.normal = this.normal.scale(-1);\n    };\n    /**\n     * Create a new vertex between this vertex and `other` by linearly\n     * interpolating all properties using a parameter of `t`. Subclasses should\n     * override this to interpolate additional properties.\n     * @param other the vertex to interpolate against\n     * @param t The factor used to linearly interpolate between the vertices\n     */\n    Vertex.prototype.interpolate = function (other, t) {\n        return new Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined);\n    };\n    return Vertex;\n}());\n/**\n * Represents a plane in 3D space.\n */\nvar Plane = /** @class */ (function () {\n    /**\n     * Initializes the plane\n     * @param normal The normal for the plane\n     * @param w\n     */\n    function Plane(normal, w) {\n        this.normal = normal;\n        this.w = w;\n    }\n    /**\n     * Construct a plane from three points\n     * @param a Point a\n     * @param b Point b\n     * @param c Point c\n     */\n    Plane.FromPoints = function (a, b, c) {\n        var v0 = c.subtract(a);\n        var v1 = b.subtract(a);\n        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\n            return null;\n        }\n        var n = Vector3.Normalize(Vector3.Cross(v0, v1));\n        return new Plane(n, Vector3.Dot(n, a));\n    };\n    /**\n     * Clone, or make a deep copy of the plane\n     * @returns a new Plane\n     */\n    Plane.prototype.clone = function () {\n        return new Plane(this.normal.clone(), this.w);\n    };\n    /**\n     * Flip the face of the plane\n     */\n    Plane.prototype.flip = function () {\n        this.normal.scaleInPlace(-1);\n        this.w = -this.w;\n    };\n    /**\n     * Split `polygon` by this plane if needed, then put the polygon or polygon\n     * fragments in the appropriate lists. Coplanar polygons go into either\n    `* coplanarFront` or `coplanarBack` depending on their orientation with\n     * respect to this plane. Polygons in front or in back of this plane go into\n     * either `front` or `back`\n     * @param polygon The polygon to be split\n     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\n     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\n     * @param front Will contain the polygons in front of the plane\n     * @param back Will contain the polygons begind the plane\n     */\n    Plane.prototype.splitPolygon = function (polygon, coplanarFront, coplanarBack, front, back) {\n        var COPLANAR = 0;\n        var FRONT = 1;\n        var BACK = 2;\n        var SPANNING = 3;\n        // Classify each point as well as the entire polygon into one of the above\n        // four classes.\n        var polygonType = 0;\n        var types = [];\n        var i;\n        var t;\n        for (i = 0; i < polygon.vertices.length; i++) {\n            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\n            var type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n            polygonType |= type;\n            types.push(type);\n        }\n        // Put the polygon in the correct list, splitting it when necessary\n        switch (polygonType) {\n            case COPLANAR:\n                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n                break;\n            case FRONT:\n                front.push(polygon);\n                break;\n            case BACK:\n                back.push(polygon);\n                break;\n            case SPANNING: {\n                var f = [], b = [];\n                for (i = 0; i < polygon.vertices.length; i++) {\n                    var j = (i + 1) % polygon.vertices.length;\n                    var ti = types[i], tj = types[j];\n                    var vi = polygon.vertices[i], vj = polygon.vertices[j];\n                    if (ti !== BACK) {\n                        f.push(vi);\n                    }\n                    if (ti !== FRONT) {\n                        b.push(ti !== BACK ? vi.clone() : vi);\n                    }\n                    if ((ti | tj) === SPANNING) {\n                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\n                        var v = vi.interpolate(vj, t);\n                        f.push(v);\n                        b.push(v.clone());\n                    }\n                }\n                var poly = void 0;\n                if (f.length >= 3) {\n                    poly = new Polygon(f, polygon.shared);\n                    if (poly.plane) {\n                        front.push(poly);\n                    }\n                }\n                if (b.length >= 3) {\n                    poly = new Polygon(b, polygon.shared);\n                    if (poly.plane) {\n                        back.push(poly);\n                    }\n                }\n                break;\n            }\n        }\n    };\n    /**\n     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\n     * point is on the plane\n     */\n    Plane.EPSILON = 1e-5;\n    return Plane;\n}());\n/**\n * Represents a convex polygon. The vertices used to initialize a polygon must\n * be coplanar and form a convex loop.\n *\n * Each convex polygon has a `shared` property, which is shared between all\n * polygons that are clones of each other or were split from the same polygon.\n * This can be used to define per-polygon properties (such as surface color)\n */\nvar Polygon = /** @class */ (function () {\n    /**\n     * Initializes the polygon\n     * @param vertices The vertices of the polygon\n     * @param shared The properties shared across all polygons\n     */\n    function Polygon(vertices, shared) {\n        this.vertices = vertices;\n        this.shared = shared;\n        this.plane = Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n    }\n    /**\n     * Clones, or makes a deep copy, or the polygon\n     */\n    Polygon.prototype.clone = function () {\n        var vertices = this.vertices.map(function (v) { return v.clone(); });\n        return new Polygon(vertices, this.shared);\n    };\n    /**\n     * Flips the faces of the polygon\n     */\n    Polygon.prototype.flip = function () {\n        this.vertices.reverse().map(function (v) {\n            v.flip();\n        });\n        this.plane.flip();\n    };\n    return Polygon;\n}());\n/**\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n * by picking a polygon to split along. That polygon (and all other coplanar\n * polygons) are added directly to that node and the other polygons are added to\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\n * no distinction between internal and leaf nodes\n */\nvar Node = /** @class */ (function () {\n    /**\n     * Initializes the node\n     * @param polygons A collection of polygons held in the node\n     */\n    function Node(polygons) {\n        this._plane = null;\n        this._front = null;\n        this._back = null;\n        this._polygons = new Array();\n        if (polygons) {\n            this.build(polygons);\n        }\n    }\n    /**\n     * Clones, or makes a deep copy, of the node\n     * @returns The cloned node\n     */\n    Node.prototype.clone = function () {\n        var node = new Node();\n        node._plane = this._plane && this._plane.clone();\n        node._front = this._front && this._front.clone();\n        node._back = this._back && this._back.clone();\n        node._polygons = this._polygons.map(function (p) { return p.clone(); });\n        return node;\n    };\n    /**\n     * Convert solid space to empty space and empty space to solid space\n     */\n    Node.prototype.invert = function () {\n        for (var i = 0; i < this._polygons.length; i++) {\n            this._polygons[i].flip();\n        }\n        if (this._plane) {\n            this._plane.flip();\n        }\n        if (this._front) {\n            this._front.invert();\n        }\n        if (this._back) {\n            this._back.invert();\n        }\n        var temp = this._front;\n        this._front = this._back;\n        this._back = temp;\n    };\n    /**\n     * Recursively remove all polygons in `polygons` that are inside this BSP\n     * tree.\n     * @param polygons Polygons to remove from the BSP\n     * @returns Polygons clipped from the BSP\n     */\n    Node.prototype.clipPolygons = function (polygons) {\n        if (!this._plane) {\n            return polygons.slice();\n        }\n        var front = new Array(), back = new Array();\n        for (var i = 0; i < polygons.length; i++) {\n            this._plane.splitPolygon(polygons[i], front, back, front, back);\n        }\n        if (this._front) {\n            front = this._front.clipPolygons(front);\n        }\n        if (this._back) {\n            back = this._back.clipPolygons(back);\n        }\n        else {\n            back = [];\n        }\n        return front.concat(back);\n    };\n    /**\n     * Remove all polygons in this BSP tree that are inside the other BSP tree\n     * `bsp`.\n     * @param bsp BSP containing polygons to remove from this BSP\n     */\n    Node.prototype.clipTo = function (bsp) {\n        this._polygons = bsp.clipPolygons(this._polygons);\n        if (this._front) {\n            this._front.clipTo(bsp);\n        }\n        if (this._back) {\n            this._back.clipTo(bsp);\n        }\n    };\n    /**\n     * Return a list of all polygons in this BSP tree\n     * @returns List of all polygons in this BSP tree\n     */\n    Node.prototype.allPolygons = function () {\n        var polygons = this._polygons.slice();\n        if (this._front) {\n            polygons = polygons.concat(this._front.allPolygons());\n        }\n        if (this._back) {\n            polygons = polygons.concat(this._back.allPolygons());\n        }\n        return polygons;\n    };\n    /**\n     * Build a BSP tree out of `polygons`. When called on an existing tree, the\n     * new polygons are filtered down to the bottom of the tree and become new\n     * nodes there. Each set of polygons is partitioned using the first polygon\n     * (no heuristic is used to pick a good split)\n     * @param polygons Polygons used to construct the BSP tree\n     */\n    Node.prototype.build = function (polygons) {\n        if (!polygons.length) {\n            return;\n        }\n        if (!this._plane) {\n            this._plane = polygons[0].plane.clone();\n        }\n        var front = new Array(), back = new Array();\n        for (var i = 0; i < polygons.length; i++) {\n            this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\n        }\n        if (front.length) {\n            if (!this._front) {\n                this._front = new Node();\n            }\n            this._front.build(front);\n        }\n        if (back.length) {\n            if (!this._back) {\n                this._back = new Node();\n            }\n            this._back.build(back);\n        }\n    };\n    return Node;\n}());\n/**\n * Class for building Constructive Solid Geometry\n */\nvar CSG = /** @class */ (function () {\n    function CSG() {\n        this._polygons = new Array();\n    }\n    /**\n     * Convert the Mesh to CSG\n     * @param mesh The Mesh to convert to CSG\n     * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\n     * @returns A new CSG from the Mesh\n     */\n    CSG.FromMesh = function (mesh, absolute) {\n        if (absolute === void 0) { absolute = false; }\n        var vertex, normal, uv = undefined, position, vertColor = undefined, polygon, vertices;\n        var polygons = new Array();\n        var matrix, meshPosition, meshRotation, meshRotationQuaternion = null, meshScaling;\n        var invertWinding = false;\n        if (mesh instanceof Mesh) {\n            mesh.computeWorldMatrix(true);\n            matrix = mesh.getWorldMatrix();\n            meshPosition = mesh.position.clone();\n            meshRotation = mesh.rotation.clone();\n            if (mesh.rotationQuaternion) {\n                meshRotationQuaternion = mesh.rotationQuaternion.clone();\n            }\n            meshScaling = mesh.scaling.clone();\n            if (mesh.material && absolute) {\n                invertWinding = mesh.material.sideOrientation === 0;\n            }\n        }\n        else {\n            throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\n        }\n        var indices = mesh.getIndices(), positions = mesh.getVerticesData(VertexBuffer.PositionKind), normals = mesh.getVerticesData(VertexBuffer.NormalKind), uvs = mesh.getVerticesData(VertexBuffer.UVKind), vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);\n        var subMeshes = mesh.subMeshes;\n        for (var sm = 0, sml = subMeshes.length; sm < sml; sm++) {\n            for (var i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\n                vertices = [];\n                for (var j = 0; j < 3; j++) {\n                    var indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\n                    var sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\n                    if (uvs) {\n                        uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\n                    }\n                    if (vertColors) {\n                        vertColor = new Color4(vertColors[indices[indexIndices] * 4], vertColors[indices[indexIndices] * 4 + 1], vertColors[indices[indexIndices] * 4 + 2], vertColors[indices[indexIndices] * 4 + 3]);\n                    }\n                    var sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\n                    position = Vector3.TransformCoordinates(sourcePosition, matrix);\n                    normal = Vector3.TransformNormal(sourceNormal, matrix);\n                    vertex = new Vertex(position, normal, uv, vertColor);\n                    vertices.push(vertex);\n                }\n                polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\n                // To handle the case of degenerated triangle\n                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n                if (polygon.plane) {\n                    polygons.push(polygon);\n                }\n            }\n        }\n        var csg = CSG._FromPolygons(polygons);\n        csg.matrix = absolute ? Matrix.Identity() : matrix;\n        csg.position = absolute ? Vector3.Zero() : meshPosition;\n        csg.rotation = absolute ? Vector3.Zero() : meshRotation;\n        csg.scaling = absolute ? Vector3.One() : meshScaling;\n        csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\n        currentCSGMeshId++;\n        return csg;\n    };\n    /**\n     * Construct a CSG solid from a list of `CSG.Polygon` instances.\n     * @param polygons Polygons used to construct a CSG solid\n     */\n    CSG._FromPolygons = function (polygons) {\n        var csg = new CSG();\n        csg._polygons = polygons;\n        return csg;\n    };\n    /**\n     * Clones, or makes a deep copy, of the CSG\n     * @returns A new CSG\n     */\n    CSG.prototype.clone = function () {\n        var csg = new CSG();\n        csg._polygons = this._polygons.map(function (p) { return p.clone(); });\n        csg.copyTransformAttributes(this);\n        return csg;\n    };\n    /**\n     * Unions this CSG with another CSG\n     * @param csg The CSG to union against this CSG\n     * @returns The unioned CSG\n     */\n    CSG.prototype.union = function (csg) {\n        var a = new Node(this.clone()._polygons);\n        var b = new Node(csg.clone()._polygons);\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n    };\n    /**\n     * Unions this CSG with another CSG in place\n     * @param csg The CSG to union against this CSG\n     */\n    CSG.prototype.unionInPlace = function (csg) {\n        var a = new Node(this._polygons);\n        var b = new Node(csg._polygons);\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        this._polygons = a.allPolygons();\n    };\n    /**\n     * Subtracts this CSG with another CSG\n     * @param csg The CSG to subtract against this CSG\n     * @returns A new CSG\n     */\n    CSG.prototype.subtract = function (csg) {\n        var a = new Node(this.clone()._polygons);\n        var b = new Node(csg.clone()._polygons);\n        a.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n    };\n    /**\n     * Subtracts this CSG with another CSG in place\n     * @param csg The CSG to subtract against this CSG\n     */\n    CSG.prototype.subtractInPlace = function (csg) {\n        var a = new Node(this._polygons);\n        var b = new Node(csg._polygons);\n        a.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        b.invert();\n        b.clipTo(a);\n        b.invert();\n        a.build(b.allPolygons());\n        a.invert();\n        this._polygons = a.allPolygons();\n    };\n    /**\n     * Intersect this CSG with another CSG\n     * @param csg The CSG to intersect against this CSG\n     * @returns A new CSG\n     */\n    CSG.prototype.intersect = function (csg) {\n        var a = new Node(this.clone()._polygons);\n        var b = new Node(csg.clone()._polygons);\n        a.invert();\n        b.clipTo(a);\n        b.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        a.build(b.allPolygons());\n        a.invert();\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n    };\n    /**\n     * Intersects this CSG with another CSG in place\n     * @param csg The CSG to intersect against this CSG\n     */\n    CSG.prototype.intersectInPlace = function (csg) {\n        var a = new Node(this._polygons);\n        var b = new Node(csg._polygons);\n        a.invert();\n        b.clipTo(a);\n        b.invert();\n        a.clipTo(b);\n        b.clipTo(a);\n        a.build(b.allPolygons());\n        a.invert();\n        this._polygons = a.allPolygons();\n    };\n    /**\n     * Return a new CSG solid with solid and empty space switched. This solid is\n     * not modified.\n     * @returns A new CSG solid with solid and empty space switched\n     */\n    CSG.prototype.inverse = function () {\n        var csg = this.clone();\n        csg.inverseInPlace();\n        return csg;\n    };\n    /**\n     * Inverses the CSG in place\n     */\n    CSG.prototype.inverseInPlace = function () {\n        this._polygons.map(function (p) {\n            p.flip();\n        });\n    };\n    /**\n     * This is used to keep meshes transformations so they can be restored\n     * when we build back a Babylon Mesh\n     * NB : All CSG operations are performed in world coordinates\n     * @param csg The CSG to copy the transform attributes from\n     * @returns This CSG\n     */\n    CSG.prototype.copyTransformAttributes = function (csg) {\n        this.matrix = csg.matrix;\n        this.position = csg.position;\n        this.rotation = csg.rotation;\n        this.scaling = csg.scaling;\n        this.rotationQuaternion = csg.rotationQuaternion;\n        return this;\n    };\n    /**\n     * Build Raw mesh from CSG\n     * Coordinates here are in world space\n     * @param name The name of the mesh geometry\n     * @param scene The Scene\n     * @param keepSubMeshes Specifies if the submeshes should be kept\n     * @returns A new Mesh\n     */\n    CSG.prototype.buildMeshGeometry = function (name, scene, keepSubMeshes) {\n        var matrix = this.matrix.clone();\n        matrix.invert();\n        var mesh = new Mesh(name, scene);\n        var vertices = [];\n        var indices = [];\n        var normals = [];\n        var uvs = null;\n        var vertColors = null;\n        var vertex = Vector3.Zero();\n        var normal = Vector3.Zero();\n        var uv = Vector2.Zero();\n        var vertColor = new Color4(0, 0, 0, 0);\n        var polygons = this._polygons;\n        var polygonIndices = [0, 0, 0];\n        var polygon;\n        var vertice_dict = {};\n        var vertex_idx;\n        var currentIndex = 0;\n        var subMeshDict = {};\n        var subMeshObj;\n        if (keepSubMeshes) {\n            // Sort Polygons, since subMeshes are indices range\n            polygons.sort(function (a, b) {\n                if (a.shared.meshId === b.shared.meshId) {\n                    return a.shared.subMeshId - b.shared.subMeshId;\n                }\n                else {\n                    return a.shared.meshId - b.shared.meshId;\n                }\n            });\n        }\n        for (var i = 0, il = polygons.length; i < il; i++) {\n            polygon = polygons[i];\n            // Building SubMeshes\n            if (!subMeshDict[polygon.shared.meshId]) {\n                subMeshDict[polygon.shared.meshId] = {};\n            }\n            if (!subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId]) {\n                subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId] = {\n                    indexStart: +Infinity,\n                    indexEnd: -Infinity,\n                    materialIndex: polygon.shared.materialIndex,\n                };\n            }\n            subMeshObj = subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId];\n            for (var j = 2, jl = polygon.vertices.length; j < jl; j++) {\n                polygonIndices[0] = 0;\n                polygonIndices[1] = j - 1;\n                polygonIndices[2] = j;\n                for (var k = 0; k < 3; k++) {\n                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\n                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\n                    if (polygon.vertices[polygonIndices[k]].uv) {\n                        if (!uvs) {\n                            uvs = [];\n                        }\n                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);\n                    }\n                    if (polygon.vertices[polygonIndices[k]].vertColor) {\n                        if (!vertColors) {\n                            vertColors = [];\n                        }\n                        vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);\n                    }\n                    var localVertex = Vector3.TransformCoordinates(vertex, matrix);\n                    var localNormal = Vector3.TransformNormal(normal, matrix);\n                    vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\n                    var areUvsDifferent = false;\n                    if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\n                        areUvsDifferent = true;\n                    }\n                    var areColorsDifferent = false;\n                    if (vertColors &&\n                        !(vertColors[vertex_idx * 4] === vertColor.r ||\n                            vertColors[vertex_idx * 4 + 1] === vertColor.g ||\n                            vertColors[vertex_idx * 4 + 2] === vertColor.b ||\n                            vertColors[vertex_idx * 4 + 3] === vertColor.a)) {\n                        areColorsDifferent = true;\n                    }\n                    // Check if 2 points can be merged\n                    if (!(typeof vertex_idx !== \"undefined\" &&\n                        normals[vertex_idx * 3] === localNormal.x &&\n                        normals[vertex_idx * 3 + 1] === localNormal.y &&\n                        normals[vertex_idx * 3 + 2] === localNormal.z) ||\n                        areUvsDifferent ||\n                        areColorsDifferent) {\n                        vertices.push(localVertex.x, localVertex.y, localVertex.z);\n                        if (uvs) {\n                            uvs.push(uv.x, uv.y);\n                        }\n                        normals.push(normal.x, normal.y, normal.z);\n                        if (vertColors) {\n                            vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\n                        }\n                        vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\n                    }\n                    indices.push(vertex_idx);\n                    subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\n                    subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\n                    currentIndex++;\n                }\n            }\n        }\n        mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n        if (uvs) {\n            mesh.setVerticesData(VertexBuffer.UVKind, uvs);\n        }\n        if (vertColors) {\n            mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);\n        }\n        mesh.setIndices(indices, null);\n        if (keepSubMeshes) {\n            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\n            var materialIndexOffset = 0, materialMaxIndex = void 0;\n            mesh.subMeshes = new Array();\n            for (var m in subMeshDict) {\n                materialMaxIndex = -1;\n                for (var sm in subMeshDict[m]) {\n                    subMeshObj = subMeshDict[m][sm];\n                    SubMesh.CreateFromIndices(subMeshObj.materialIndex + materialIndexOffset, subMeshObj.indexStart, subMeshObj.indexEnd - subMeshObj.indexStart + 1, mesh);\n                    materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\n                }\n                materialIndexOffset += ++materialMaxIndex;\n            }\n        }\n        return mesh;\n    };\n    /**\n     * Build Mesh from CSG taking material and transforms into account\n     * @param name The name of the Mesh\n     * @param material The material of the Mesh\n     * @param scene The Scene\n     * @param keepSubMeshes Specifies if submeshes should be kept\n     * @returns The new Mesh\n     */\n    CSG.prototype.toMesh = function (name, material, scene, keepSubMeshes) {\n        if (material === void 0) { material = null; }\n        var mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\n        mesh.material = material;\n        mesh.position.copyFrom(this.position);\n        mesh.rotation.copyFrom(this.rotation);\n        if (this.rotationQuaternion) {\n            mesh.rotationQuaternion = this.rotationQuaternion.clone();\n        }\n        mesh.scaling.copyFrom(this.scaling);\n        mesh.computeWorldMatrix(true);\n        return mesh;\n    };\n    return CSG;\n}());\nexport { CSG };\n//# sourceMappingURL=csg.js.map","import { __extends } from \"tslib\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\n/**\n * Class used to create a trail following a mesh\n */\nvar TrailMesh = /** @class */ (function (_super) {\n    __extends(TrailMesh, _super);\n    /**\n     * @constructor\n     * @param name The value used by scene.getMeshByName() to do a lookup.\n     * @param generator The mesh or transform node to generate a trail.\n     * @param scene The scene to add this mesh to.\n     * @param diameter Diameter of trailing mesh. Default is 1.\n     * @param length Length of trailing mesh. Default is 60.\n     * @param autoStart Automatically start trailing mesh. Default true.\n     */\n    function TrailMesh(name, generator, scene, diameter, length, autoStart) {\n        if (diameter === void 0) { diameter = 1; }\n        if (length === void 0) { length = 60; }\n        if (autoStart === void 0) { autoStart = true; }\n        var _this = _super.call(this, name, scene) || this;\n        _this._sectionPolygonPointsCount = 4;\n        _this._running = false;\n        _this._autoStart = autoStart;\n        _this._generator = generator;\n        _this._diameter = diameter;\n        _this._length = length;\n        _this._sectionVectors = [];\n        _this._sectionNormalVectors = [];\n        for (var i = 0; i < _this._sectionPolygonPointsCount; i++) {\n            _this._sectionVectors[i] = Vector3.Zero();\n            _this._sectionNormalVectors[i] = Vector3.Zero();\n        }\n        _this._createMesh();\n        return _this;\n    }\n    /**\n     * \"TrailMesh\"\n     * @returns \"TrailMesh\"\n     */\n    TrailMesh.prototype.getClassName = function () {\n        return \"TrailMesh\";\n    };\n    TrailMesh.prototype._createMesh = function () {\n        var data = new VertexData();\n        var positions = [];\n        var normals = [];\n        var indices = [];\n        var meshCenter = Vector3.Zero();\n        if (this._generator instanceof AbstractMesh && this._generator.hasBoundingInfo) {\n            meshCenter = this._generator.getBoundingInfo().boundingBox.centerWorld;\n        }\n        else {\n            meshCenter = this._generator.position;\n        }\n        var alpha = (2 * Math.PI) / this._sectionPolygonPointsCount;\n        for (var i = 0; i < this._sectionPolygonPointsCount; i++) {\n            positions.push(meshCenter.x + Math.cos(i * alpha) * this._diameter, meshCenter.y + Math.sin(i * alpha) * this._diameter, meshCenter.z);\n        }\n        for (var i = 1; i <= this._length; i++) {\n            for (var j = 0; j < this._sectionPolygonPointsCount; j++) {\n                positions.push(meshCenter.x + Math.cos(j * alpha) * this._diameter, meshCenter.y + Math.sin(j * alpha) * this._diameter, meshCenter.z);\n            }\n            var l = positions.length / 3 - 2 * this._sectionPolygonPointsCount;\n            for (var j = 0; j < this._sectionPolygonPointsCount - 1; j++) {\n                indices.push(l + j, l + j + this._sectionPolygonPointsCount, l + j + this._sectionPolygonPointsCount + 1);\n                indices.push(l + j, l + j + this._sectionPolygonPointsCount + 1, l + j + 1);\n            }\n            indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount - 1 + this._sectionPolygonPointsCount, l + this._sectionPolygonPointsCount);\n            indices.push(l + this._sectionPolygonPointsCount - 1, l + this._sectionPolygonPointsCount, l);\n        }\n        VertexData.ComputeNormals(positions, indices, normals);\n        data.positions = positions;\n        data.normals = normals;\n        data.indices = indices;\n        data.applyToMesh(this, true);\n        if (this._autoStart) {\n            this.start();\n        }\n    };\n    /**\n     * Start trailing mesh.\n     */\n    TrailMesh.prototype.start = function () {\n        var _this = this;\n        if (!this._running) {\n            this._running = true;\n            this._beforeRenderObserver = this.getScene().onBeforeRenderObservable.add(function () {\n                _this.update();\n            });\n        }\n    };\n    /**\n     * Stop trailing mesh.\n     */\n    TrailMesh.prototype.stop = function () {\n        if (this._beforeRenderObserver && this._running) {\n            this._running = false;\n            this.getScene().onBeforeRenderObservable.remove(this._beforeRenderObserver);\n        }\n    };\n    /**\n     * Update trailing mesh geometry.\n     */\n    TrailMesh.prototype.update = function () {\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\n        var normals = this.getVerticesData(VertexBuffer.NormalKind);\n        var wm = this._generator.getWorldMatrix();\n        if (positions && normals) {\n            for (var i = 3 * this._sectionPolygonPointsCount; i < positions.length; i++) {\n                positions[i - 3 * this._sectionPolygonPointsCount] = positions[i] - (normals[i] / this._length) * this._diameter;\n            }\n            for (var i = 3 * this._sectionPolygonPointsCount; i < normals.length; i++) {\n                normals[i - 3 * this._sectionPolygonPointsCount] = normals[i];\n            }\n            var l = positions.length - 3 * this._sectionPolygonPointsCount;\n            var alpha = (2 * Math.PI) / this._sectionPolygonPointsCount;\n            for (var i = 0; i < this._sectionPolygonPointsCount; i++) {\n                this._sectionVectors[i].copyFromFloats(Math.cos(i * alpha) * this._diameter, Math.sin(i * alpha) * this._diameter, 0);\n                this._sectionNormalVectors[i].copyFromFloats(Math.cos(i * alpha), Math.sin(i * alpha), 0);\n                Vector3.TransformCoordinatesToRef(this._sectionVectors[i], wm, this._sectionVectors[i]);\n                Vector3.TransformNormalToRef(this._sectionNormalVectors[i], wm, this._sectionNormalVectors[i]);\n            }\n            for (var i = 0; i < this._sectionPolygonPointsCount; i++) {\n                positions[l + 3 * i] = this._sectionVectors[i].x;\n                positions[l + 3 * i + 1] = this._sectionVectors[i].y;\n                positions[l + 3 * i + 2] = this._sectionVectors[i].z;\n                normals[l + 3 * i] = this._sectionNormalVectors[i].x;\n                normals[l + 3 * i + 1] = this._sectionNormalVectors[i].y;\n                normals[l + 3 * i + 2] = this._sectionNormalVectors[i].z;\n            }\n            this.updateVerticesData(VertexBuffer.PositionKind, positions, true, false);\n            this.updateVerticesData(VertexBuffer.NormalKind, normals, true, false);\n        }\n    };\n    /**\n     * Returns a new TrailMesh object.\n     * @param name is a string, the name given to the new mesh\n     * @param newGenerator use new generator object for cloned trail mesh\n     * @returns a new mesh\n     */\n    TrailMesh.prototype.clone = function (name, newGenerator) {\n        if (name === void 0) { name = \"\"; }\n        return new TrailMesh(name, newGenerator === undefined ? this._generator : newGenerator, this.getScene(), this._diameter, this._length, this._autoStart);\n    };\n    /**\n     * Serializes this trail mesh\n     * @param serializationObject object to write serialization to\n     */\n    TrailMesh.prototype.serialize = function (serializationObject) {\n        _super.prototype.serialize.call(this, serializationObject);\n    };\n    /**\n     * Parses a serialized trail mesh\n     * @param parsedMesh the serialized mesh\n     * @param scene the scene to create the trail mesh in\n     * @returns the created trail mesh\n     */\n    TrailMesh.Parse = function (parsedMesh, scene) {\n        return new TrailMesh(parsedMesh.name, parsedMesh._generator, scene, parsedMesh._diameter, parsedMesh._length, parsedMesh._autoStart);\n    };\n    return TrailMesh;\n}(Mesh));\nexport { TrailMesh };\n//# sourceMappingURL=trailMesh.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { CreateRibbon } from \"./Builders/ribbonBuilder.js\";\nimport { CreateDisc } from \"./Builders/discBuilder.js\";\nimport { CreateBox } from \"./Builders/boxBuilder.js\";\nimport { CreateTiledBox } from \"./Builders/tiledBoxBuilder.js\";\nimport { CreateSphere } from \"./Builders/sphereBuilder.js\";\nimport { CreateCylinder } from \"./Builders/cylinderBuilder.js\";\nimport { CreateTorus } from \"./Builders/torusBuilder.js\";\nimport { CreateTorusKnot } from \"./Builders/torusKnotBuilder.js\";\nimport { CreateDashedLines, CreateLineSystem, CreateLines } from \"./Builders/linesBuilder.js\";\nimport { CreatePolygon, ExtrudePolygon } from \"./Builders/polygonBuilder.js\";\nimport { ExtrudeShape, ExtrudeShapeCustom } from \"./Builders/shapeBuilder.js\";\nimport { CreateLathe } from \"./Builders/latheBuilder.js\";\nimport { CreatePlane } from \"./Builders/planeBuilder.js\";\nimport { CreateTiledPlane } from \"./Builders/tiledPlaneBuilder.js\";\nimport { CreateGround, CreateGroundFromHeightMap, CreateTiledGround } from \"./Builders/groundBuilder.js\";\nimport { CreateTube } from \"./Builders/tubeBuilder.js\";\nimport { CreatePolyhedron } from \"./Builders/polyhedronBuilder.js\";\nimport { CreateIcoSphere } from \"./Builders/icoSphereBuilder.js\";\nimport { CreateDecal } from \"./Builders/decalBuilder.js\";\nimport { CreateCapsule } from \"./Builders/capsuleBuilder.js\";\nimport { CreateGeodesic } from \"./Builders/geodesicBuilder.js\";\nimport { CreateGoldberg } from \"./Builders/goldbergBuilder.js\";\n/**\n * Class containing static functions to help procedurally build meshes\n */\nexport var MeshBuilder = {\n    CreateBox: CreateBox,\n    CreateTiledBox: CreateTiledBox,\n    CreateSphere: CreateSphere,\n    CreateDisc: CreateDisc,\n    CreateIcoSphere: CreateIcoSphere,\n    CreateRibbon: CreateRibbon,\n    CreateCylinder: CreateCylinder,\n    CreateTorus: CreateTorus,\n    CreateTorusKnot: CreateTorusKnot,\n    CreateLineSystem: CreateLineSystem,\n    CreateLines: CreateLines,\n    CreateDashedLines: CreateDashedLines,\n    ExtrudeShape: ExtrudeShape,\n    ExtrudeShapeCustom: ExtrudeShapeCustom,\n    CreateLathe: CreateLathe,\n    CreateTiledPlane: CreateTiledPlane,\n    CreatePlane: CreatePlane,\n    CreateGround: CreateGround,\n    CreateTiledGround: CreateTiledGround,\n    CreateGroundFromHeightMap: CreateGroundFromHeightMap,\n    CreatePolygon: CreatePolygon,\n    ExtrudePolygon: ExtrudePolygon,\n    CreateTube: CreateTube,\n    CreatePolyhedron: CreatePolyhedron,\n    CreateGeodesic: CreateGeodesic,\n    CreateGoldberg: CreateGoldberg,\n    CreateDecal: CreateDecal,\n    CreateCapsule: CreateCapsule,\n};\n//# sourceMappingURL=meshBuilder.js.map","import { Scene } from \"../scene.js\";\nimport { Mesh } from \"./mesh.js\";\nimport { SimplificationQueue, SimplificationType } from \"./meshSimplification.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nObject.defineProperty(Scene.prototype, \"simplificationQueue\", {\n    get: function () {\n        if (!this._simplificationQueue) {\n            this._simplificationQueue = new SimplificationQueue();\n            var component = this._getComponent(SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE);\n            if (!component) {\n                component = new SimplicationQueueSceneComponent(this);\n                this._addComponent(component);\n            }\n        }\n        return this._simplificationQueue;\n    },\n    set: function (value) {\n        this._simplificationQueue = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\nMesh.prototype.simplify = function (settings, parallelProcessing, simplificationType, successCallback) {\n    if (parallelProcessing === void 0) { parallelProcessing = true; }\n    if (simplificationType === void 0) { simplificationType = SimplificationType.QUADRATIC; }\n    this.getScene().simplificationQueue.addTask({\n        settings: settings,\n        parallelProcessing: parallelProcessing,\n        mesh: this,\n        simplificationType: simplificationType,\n        successCallback: successCallback,\n    });\n    return this;\n};\n/**\n * Defines the simplification queue scene component responsible to help scheduling the various simplification task\n * created in a scene\n */\nvar SimplicationQueueSceneComponent = /** @class */ (function () {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    function SimplicationQueueSceneComponent(scene) {\n        /**\n         * The component name helpfull to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    SimplicationQueueSceneComponent.prototype.register = function () {\n        this.scene._beforeCameraUpdateStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE, this, this._beforeCameraUpdate);\n    };\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    SimplicationQueueSceneComponent.prototype.rebuild = function () {\n        // Nothing to do for this component\n    };\n    /**\n     * Disposes the component and the associated resources\n     */\n    SimplicationQueueSceneComponent.prototype.dispose = function () {\n        // Nothing to do for this component\n    };\n    SimplicationQueueSceneComponent.prototype._beforeCameraUpdate = function () {\n        if (this.scene._simplificationQueue && !this.scene._simplificationQueue.running) {\n            this.scene._simplificationQueue.executeNext();\n        }\n    };\n    return SimplicationQueueSceneComponent;\n}());\nexport { SimplicationQueueSceneComponent };\n//# sourceMappingURL=meshSimplificationSceneComponent.js.map","import { __extends } from \"tslib\";\nimport { Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { TransformNode } from \"./transformNode.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nMesh._instancedMeshFactory = function (name, mesh) {\n    var instance = new InstancedMesh(name, mesh);\n    if (mesh.instancedBuffers) {\n        instance.instancedBuffers = {};\n        for (var key in mesh.instancedBuffers) {\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\n        }\n    }\n    return instance;\n};\n/**\n * Creates an instance based on a source mesh.\n */\nvar InstancedMesh = /** @class */ (function (_super) {\n    __extends(InstancedMesh, _super);\n    function InstancedMesh(name, source) {\n        var _this = _super.call(this, name, source.getScene()) || this;\n        /** @hidden */\n        _this._indexInSourceMeshInstanceArray = -1;\n        /** @hidden */\n        _this._distanceToCamera = 0;\n        source.addInstance(_this);\n        _this._sourceMesh = source;\n        _this._unIndexed = source._unIndexed;\n        _this.position.copyFrom(source.position);\n        _this.rotation.copyFrom(source.rotation);\n        _this.scaling.copyFrom(source.scaling);\n        if (source.rotationQuaternion) {\n            _this.rotationQuaternion = source.rotationQuaternion.clone();\n        }\n        _this.animations = source.animations.slice();\n        for (var _i = 0, _a = source.getAnimationRanges(); _i < _a.length; _i++) {\n            var range = _a[_i];\n            if (range != null) {\n                _this.createAnimationRange(range.name, range.from, range.to);\n            }\n        }\n        _this.infiniteDistance = source.infiniteDistance;\n        _this.setPivotMatrix(source.getPivotMatrix());\n        _this.refreshBoundingInfo(true, true);\n        _this._syncSubMeshes();\n        return _this;\n    }\n    /**\n     * Returns the string \"InstancedMesh\".\n     */\n    InstancedMesh.prototype.getClassName = function () {\n        return \"InstancedMesh\";\n    };\n    Object.defineProperty(InstancedMesh.prototype, \"lightSources\", {\n        /** Gets the list of lights affecting that mesh */\n        get: function () {\n            return this._sourceMesh._lightSources;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    InstancedMesh.prototype._resyncLightSources = function () {\n        // Do nothing as all the work will be done by source mesh\n    };\n    InstancedMesh.prototype._resyncLightSource = function () {\n        // Do nothing as all the work will be done by source mesh\n    };\n    InstancedMesh.prototype._removeLightSource = function () {\n        // Do nothing as all the work will be done by source mesh\n    };\n    Object.defineProperty(InstancedMesh.prototype, \"receiveShadows\", {\n        // Methods\n        /**\n         * If the source mesh receives shadows\n         */\n        get: function () {\n            return this._sourceMesh.receiveShadows;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(InstancedMesh.prototype, \"material\", {\n        /**\n         * The material of the source mesh\n         */\n        get: function () {\n            return this._sourceMesh.material;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(InstancedMesh.prototype, \"visibility\", {\n        /**\n         * Visibility of the source mesh\n         */\n        get: function () {\n            return this._sourceMesh.visibility;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(InstancedMesh.prototype, \"skeleton\", {\n        /**\n         * Skeleton of the source mesh\n         */\n        get: function () {\n            return this._sourceMesh.skeleton;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(InstancedMesh.prototype, \"renderingGroupId\", {\n        /**\n         * Rendering ground id of the source mesh\n         */\n        get: function () {\n            return this._sourceMesh.renderingGroupId;\n        },\n        set: function (value) {\n            if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\n                return;\n            }\n            //no-op with warning\n            Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the total number of vertices (integer).\n     */\n    InstancedMesh.prototype.getTotalVertices = function () {\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\n    };\n    /**\n     * Returns a positive integer : the total number of indices in this mesh geometry.\n     * @returns the number of indices or zero if the mesh has no geometry.\n     */\n    InstancedMesh.prototype.getTotalIndices = function () {\n        return this._sourceMesh.getTotalIndices();\n    };\n    Object.defineProperty(InstancedMesh.prototype, \"sourceMesh\", {\n        /**\n         * The source mesh of the instance\n         */\n        get: function () {\n            return this._sourceMesh;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Creates a new InstancedMesh object from the mesh model.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\n     * @param name defines the name of the new instance\n     * @returns a new InstancedMesh\n     */\n    InstancedMesh.prototype.createInstance = function (name) {\n        return this._sourceMesh.createInstance(name);\n    };\n    /**\n     * Is this node ready to be used/rendered\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n     * @return {boolean} is it ready\n     */\n    InstancedMesh.prototype.isReady = function (completeCheck) {\n        if (completeCheck === void 0) { completeCheck = false; }\n        return this._sourceMesh.isReady(completeCheck, true);\n    };\n    /**\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\n     */\n    InstancedMesh.prototype.getVerticesData = function (kind, copyWhenShared) {\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\n    };\n    /**\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n     * The `data` are either a numeric array either a Float32Array.\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\n     * Note that a new underlying VertexBuffer object is created each call.\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n     *\n     * Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     *\n     * Returns the Mesh.\n     * @param kind\n     * @param data\n     * @param updatable\n     * @param stride\n     */\n    InstancedMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n        if (this.sourceMesh) {\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\n        }\n        return this.sourceMesh;\n    };\n    /**\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n     * If the mesh has no geometry, it is simply returned as it is.\n     * The `data` are either a numeric array either a Float32Array.\n     * No new underlying VertexBuffer object is created.\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\n     *\n     * Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     *\n     * Returns the Mesh.\n     * @param kind\n     * @param data\n     * @param updateExtends\n     * @param makeItUnique\n     */\n    InstancedMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n        if (this.sourceMesh) {\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\n        }\n        return this.sourceMesh;\n    };\n    /**\n     * Sets the mesh indices.\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n     * This method creates a new index buffer each call.\n     * Returns the Mesh.\n     * @param indices\n     * @param totalVertices\n     */\n    InstancedMesh.prototype.setIndices = function (indices, totalVertices) {\n        if (totalVertices === void 0) { totalVertices = null; }\n        if (this.sourceMesh) {\n            this.sourceMesh.setIndices(indices, totalVertices);\n        }\n        return this.sourceMesh;\n    };\n    /**\n     * Boolean : True if the mesh owns the requested kind of data.\n     * @param kind\n     */\n    InstancedMesh.prototype.isVerticesDataPresent = function (kind) {\n        return this._sourceMesh.isVerticesDataPresent(kind);\n    };\n    /**\n     * Returns an array of indices (IndicesArray).\n     */\n    InstancedMesh.prototype.getIndices = function () {\n        return this._sourceMesh.getIndices();\n    };\n    Object.defineProperty(InstancedMesh.prototype, \"_positions\", {\n        get: function () {\n            return this._sourceMesh._positions;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n     * This means the mesh underlying bounding box and sphere are recomputed.\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n     * @returns the current mesh\n     */\n    InstancedMesh.prototype.refreshBoundingInfo = function (applySkeleton, applyMorph) {\n        if (applySkeleton === void 0) { applySkeleton = false; }\n        if (applyMorph === void 0) { applyMorph = false; }\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n            return this;\n        }\n        var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\n        return this;\n    };\n    /** @hidden */\n    InstancedMesh.prototype._preActivate = function () {\n        if (this._currentLOD) {\n            this._currentLOD._preActivate();\n        }\n        return this;\n    };\n    /**\n     * @param renderId\n     * @param intermediateRendering\n     * @hidden\n     */\n    InstancedMesh.prototype._activate = function (renderId, intermediateRendering) {\n        _super.prototype._activate.call(this, renderId, intermediateRendering);\n        if (!this._sourceMesh.subMeshes) {\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\n        }\n        if (this._currentLOD) {\n            var differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\n            if (differentSign) {\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\n                return true;\n            }\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\n            if (intermediateRendering) {\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\n                    return true;\n                }\n            }\n            else {\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /** @hidden */\n    InstancedMesh.prototype._postActivate = function () {\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n            // we are using the edge renderer of the source mesh\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\n        }\n        else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n            // we are using the edge renderer defined for this instance\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\n        }\n    };\n    InstancedMesh.prototype.getWorldMatrix = function () {\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\n            if (!this._billboardWorldMatrix) {\n                this._billboardWorldMatrix = new Matrix();\n            }\n            var tempMaster = this._currentLOD._masterMesh;\n            this._currentLOD._masterMesh = this;\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\n            this._currentLOD.position.set(0, 0, 0);\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\n            this._currentLOD._masterMesh = tempMaster;\n            return this._billboardWorldMatrix;\n        }\n        return _super.prototype.getWorldMatrix.call(this);\n    };\n    Object.defineProperty(InstancedMesh.prototype, \"isAnInstance\", {\n        get: function () {\n            return true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the current associated LOD AbstractMesh.\n     * @param camera\n     */\n    InstancedMesh.prototype.getLOD = function (camera) {\n        if (!camera) {\n            return this;\n        }\n        var sourceMeshLODLevels = this.sourceMesh.getLODLevels();\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\n            this._currentLOD = this.sourceMesh;\n        }\n        else {\n            var boundingInfo = this.getBoundingInfo();\n            this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\n        }\n        return this._currentLOD;\n    };\n    /**\n     * @param renderId\n     * @hidden\n     */\n    InstancedMesh.prototype._preActivateForIntermediateRendering = function (renderId) {\n        return this.sourceMesh._preActivateForIntermediateRendering(renderId);\n    };\n    /** @hidden */\n    InstancedMesh.prototype._syncSubMeshes = function () {\n        this.releaseSubMeshes();\n        if (this._sourceMesh.subMeshes) {\n            for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\n            }\n        }\n        return this;\n    };\n    /** @hidden */\n    InstancedMesh.prototype._generatePointsArray = function () {\n        return this._sourceMesh._generatePointsArray();\n    };\n    /** @hidden */\n    InstancedMesh.prototype._updateBoundingInfo = function () {\n        if (this.hasBoundingInfo) {\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\n        }\n        else {\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\n        }\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n        return this;\n    };\n    /**\n     * Creates a new InstancedMesh from the current mesh.\n     * - name (string) : the cloned mesh name\n     * - newParent (optional Node) : the optional Node to parent the clone to.\n     * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\n     *\n     * Returns the clone.\n     * @param name\n     * @param newParent\n     * @param doNotCloneChildren\n     */\n    InstancedMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n        if (newParent === void 0) { newParent = null; }\n        var result = this._sourceMesh.createInstance(name);\n        // Deep copy\n        DeepCopier.DeepCopy(this, result, [\n            \"name\",\n            \"subMeshes\",\n            \"uniqueId\",\n            \"parent\",\n            \"lightSources\",\n            \"receiveShadows\",\n            \"material\",\n            \"visibility\",\n            \"skeleton\",\n            \"sourceMesh\",\n            \"isAnInstance\",\n            \"facetNb\",\n            \"isFacetDataEnabled\",\n            \"isBlocked\",\n            \"useBones\",\n            \"hasInstances\",\n            \"collider\",\n            \"edgesRenderer\",\n            \"forward\",\n            \"up\",\n            \"right\",\n            \"absolutePosition\",\n            \"absoluteScaling\",\n            \"absoluteRotationQuaternion\",\n            \"isWorldMatrixFrozen\",\n            \"nonUniformScaling\",\n            \"behaviors\",\n            \"worldMatrixFromCache\",\n            \"hasThinInstances\",\n            \"hasBoundingInfo\",\n        ], []);\n        // Bounding info\n        this.refreshBoundingInfo();\n        // Parent\n        if (newParent) {\n            result.parent = newParent;\n        }\n        if (!doNotCloneChildren) {\n            // Children\n            for (var index = 0; index < this.getScene().meshes.length; index++) {\n                var mesh = this.getScene().meshes[index];\n                if (mesh.parent === this) {\n                    mesh.clone(mesh.name, result);\n                }\n            }\n        }\n        result.computeWorldMatrix(true);\n        this.onClonedObservable.notifyObservers(result);\n        return result;\n    };\n    /**\n     * Disposes the InstancedMesh.\n     * Returns nothing.\n     * @param doNotRecurse\n     * @param disposeMaterialAndTextures\n     */\n    InstancedMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }\n        // Remove from mesh\n        this._sourceMesh.removeInstance(this);\n        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n    };\n    return InstancedMesh;\n}(AbstractMesh));\nexport { InstancedMesh };\nMesh.prototype.registerInstancedBuffer = function (kind, stride) {\n    var _a, _b;\n    // Remove existing one\n    (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose();\n    // Creates the instancedBuffer field if not present\n    if (!this.instancedBuffers) {\n        this.instancedBuffers = {};\n        for (var _i = 0, _c = this.instances; _i < _c.length; _i++) {\n            var instance = _c[_i];\n            instance.instancedBuffers = {};\n        }\n        if (!this._userInstancedBuffersStorage) {\n            this._userInstancedBuffersStorage = {\n                data: {},\n                vertexBuffers: {},\n                strides: {},\n                sizes: {},\n                vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\n            };\n        }\n    }\n    // Creates an empty property for this kind\n    this.instancedBuffers[kind] = null;\n    this._userInstancedBuffersStorage.strides[kind] = stride;\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n    for (var _d = 0, _e = this.instances; _d < _e.length; _d++) {\n        var instance = _e[_d];\n        instance.instancedBuffers[kind] = null;\n    }\n    this._invalidateInstanceVertexArrayObject();\n    this._markSubMeshesAsAttributesDirty();\n};\nMesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\n    var instanceCount = visibleInstances.length;\n    for (var kind in this.instancedBuffers) {\n        var size = this._userInstancedBuffersStorage.sizes[kind];\n        var stride = this._userInstancedBuffersStorage.strides[kind];\n        // Resize if required\n        var expectedSize = (instanceCount + 1) * stride;\n        while (size < expectedSize) {\n            size *= 2;\n        }\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\n            this._userInstancedBuffersStorage.sizes[kind] = size;\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n                this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n            }\n        }\n        var data = this._userInstancedBuffersStorage.data[kind];\n        // Update data buffer\n        var offset = 0;\n        if (renderSelf) {\n            var value = this.instancedBuffers[kind];\n            if (value.toArray) {\n                value.toArray(data, offset);\n            }\n            else if (value.copyToArray) {\n                value.copyToArray(data, offset);\n            }\n            else {\n                data[offset] = value;\n            }\n            offset += stride;\n        }\n        for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\n            var instance = visibleInstances[instanceIndex];\n            var value = instance.instancedBuffers[kind];\n            if (value.toArray) {\n                value.toArray(data, offset);\n            }\n            else if (value.copyToArray) {\n                value.copyToArray(data, offset);\n            }\n            else {\n                data[offset] = value;\n            }\n            offset += stride;\n        }\n        // Update vertex buffer\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n            this._invalidateInstanceVertexArrayObject();\n        }\n        else {\n            this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);\n        }\n    }\n};\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\n        return;\n    }\n    for (var kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\n    }\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\n};\nMesh.prototype._disposeInstanceSpecificData = function () {\n    if (this._instanceDataStorage.instancesBuffer) {\n        this._instanceDataStorage.instancesBuffer.dispose();\n        this._instanceDataStorage.instancesBuffer = null;\n    }\n    while (this.instances.length) {\n        this.instances[0].dispose();\n    }\n    for (var kind in this.instancedBuffers) {\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n            this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n        }\n    }\n    this._invalidateInstanceVertexArrayObject();\n    this.instancedBuffers = {};\n};\n//# sourceMappingURL=instancedMesh.js.map","import { __extends } from \"tslib\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { InstancedMesh } from \"../Meshes/instancedMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport \"../Shaders/color.fragment.js\";\nimport \"../Shaders/color.vertex.js\";\nMesh._LinesMeshParser = function (parsedMesh, scene) {\n    return LinesMesh.Parse(parsedMesh, scene);\n};\n/**\n * Line mesh\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\n */\nvar LinesMesh = /** @class */ (function (_super) {\n    __extends(LinesMesh, _super);\n    /**\n     * Creates a new LinesMesh\n     * @param name defines the name\n     * @param scene defines the hosting scene\n     * @param parent defines the parent mesh if any\n     * @param source defines the optional source LinesMesh used to clone data from\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n     * When false, achieved by calling a clone(), also passing False.\n     * This will make creation of children, recursive.\n     * @param useVertexColor defines if this LinesMesh supports vertex color\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\n     * @param material material to use to draw the line. If not provided, will create a new one\n     */\n    function LinesMesh(name, scene, parent, source, doNotCloneChildren, \n    /**\n     * If vertex color should be applied to the mesh\n     */\n    useVertexColor, \n    /**\n     * If vertex alpha should be applied to the mesh\n     */\n    useVertexAlpha, material) {\n        if (scene === void 0) { scene = null; }\n        if (parent === void 0) { parent = null; }\n        if (source === void 0) { source = null; }\n        var _this = _super.call(this, name, scene, parent, source, doNotCloneChildren) || this;\n        _this.useVertexColor = useVertexColor;\n        _this.useVertexAlpha = useVertexAlpha;\n        /**\n         * Color of the line (Default: White)\n         */\n        _this.color = new Color3(1, 1, 1);\n        /**\n         * Alpha of the line (Default: 1)\n         */\n        _this.alpha = 1;\n        if (source) {\n            _this.color = source.color.clone();\n            _this.alpha = source.alpha;\n            _this.useVertexColor = source.useVertexColor;\n            _this.useVertexAlpha = source.useVertexAlpha;\n        }\n        _this.intersectionThreshold = 0.1;\n        var defines = [];\n        var options = {\n            attributes: [VertexBuffer.PositionKind],\n            uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"vClipPlane5\", \"vClipPlane6\", \"world\", \"viewProjection\"],\n            needAlphaBlending: true,\n            defines: defines,\n            useClipPlane: null,\n        };\n        if (useVertexAlpha === false) {\n            options.needAlphaBlending = false;\n        }\n        else {\n            options.defines.push(\"#define VERTEXALPHA\");\n        }\n        if (!useVertexColor) {\n            options.uniforms.push(\"color\");\n            _this._color4 = new Color4();\n        }\n        else {\n            options.defines.push(\"#define VERTEXCOLOR\");\n            options.attributes.push(VertexBuffer.ColorKind);\n        }\n        if (material) {\n            _this.material = material;\n        }\n        else {\n            _this.material = new ShaderMaterial(\"colorShader\", _this.getScene(), \"color\", options, false);\n        }\n        return _this;\n    }\n    LinesMesh.prototype._isShaderMaterial = function (shader) {\n        return shader.getClassName() === \"ShaderMaterial\";\n    };\n    LinesMesh.prototype.isReady = function () {\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage)) {\n            return false;\n        }\n        return _super.prototype.isReady.call(this);\n    };\n    /**\n     * Returns the string \"LineMesh\"\n     */\n    LinesMesh.prototype.getClassName = function () {\n        return \"LinesMesh\";\n    };\n    Object.defineProperty(LinesMesh.prototype, \"material\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return this._lineMaterial;\n        },\n        /**\n         * @hidden\n         */\n        set: function (value) {\n            this._lineMaterial = value;\n            this._lineMaterial.fillMode = Material.LineListDrawMode;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(LinesMesh.prototype, \"checkCollisions\", {\n        /**\n         * @hidden\n         */\n        get: function () {\n            return false;\n        },\n        set: function (value) {\n            // Just ignore it\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * @hidden\n     */\n    LinesMesh.prototype._bind = function () {\n        if (!this._geometry) {\n            return this;\n        }\n        var colorEffect = this._lineMaterial.getEffect();\n        // VBOs\n        var indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\n        if (!this._userInstancedBuffersStorage) {\n            this._geometry._bind(colorEffect, indexToBind);\n        }\n        else {\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\n        }\n        // Color\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\n            var _a = this.color, r = _a.r, g = _a.g, b = _a.b;\n            this._color4.set(r, g, b, this.alpha);\n            this._lineMaterial.setColor4(\"color\", this._color4);\n        }\n        return this;\n    };\n    /**\n     * @param subMesh\n     * @param fillMode\n     * @param instancesCount\n     * @hidden\n     */\n    LinesMesh.prototype._draw = function (subMesh, fillMode, instancesCount) {\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\n            return this;\n        }\n        var engine = this.getScene().getEngine();\n        // Draw order\n        if (this._unIndexed) {\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\n        }\n        else {\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\n        }\n        return this;\n    };\n    /**\n     * Disposes of the line mesh\n     * @param doNotRecurse If children should be disposed\n     */\n    LinesMesh.prototype.dispose = function (doNotRecurse) {\n        this._lineMaterial.dispose(false, false, true);\n        _super.prototype.dispose.call(this, doNotRecurse);\n    };\n    /**\n     * Returns a new LineMesh object cloned from the current one.\n     * @param name\n     * @param newParent\n     * @param doNotCloneChildren\n     */\n    LinesMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n        if (newParent === void 0) { newParent = null; }\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\n    };\n    /**\n     * Creates a new InstancedLinesMesh object from the mesh model.\n     * @see https://doc.babylonjs.com/divingDeeper/mesh/copies/instances\n     * @param name defines the name of the new instance\n     * @returns a new InstancedLinesMesh\n     */\n    LinesMesh.prototype.createInstance = function (name) {\n        var instance = new InstancedLinesMesh(name, this);\n        if (this.instancedBuffers) {\n            instance.instancedBuffers = {};\n            for (var key in this.instancedBuffers) {\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\n            }\n        }\n        return instance;\n    };\n    /**\n     * Serializes this ground mesh\n     * @param serializationObject object to write serialization to\n     */\n    LinesMesh.prototype.serialize = function (serializationObject) {\n        _super.prototype.serialize.call(this, serializationObject);\n        serializationObject.color = this.color.asArray();\n        serializationObject.alpha = this.alpha;\n    };\n    /**\n     * Parses a serialized ground mesh\n     * @param parsedMesh the serialized mesh\n     * @param scene the scene to create the ground mesh in\n     * @returns the created ground mesh\n     */\n    LinesMesh.Parse = function (parsedMesh, scene) {\n        var result = new LinesMesh(parsedMesh.name, scene);\n        result.color = Color3.FromArray(parsedMesh.color);\n        result.alpha = parsedMesh.alpha;\n        return result;\n    };\n    return LinesMesh;\n}(Mesh));\nexport { LinesMesh };\n/**\n * Creates an instance based on a source LinesMesh\n */\nvar InstancedLinesMesh = /** @class */ (function (_super) {\n    __extends(InstancedLinesMesh, _super);\n    function InstancedLinesMesh(name, source) {\n        var _this = _super.call(this, name, source) || this;\n        _this.intersectionThreshold = source.intersectionThreshold;\n        return _this;\n    }\n    /**\n     * Returns the string \"InstancedLinesMesh\".\n     */\n    InstancedLinesMesh.prototype.getClassName = function () {\n        return \"InstancedLinesMesh\";\n    };\n    return InstancedLinesMesh;\n}(InstancedMesh));\nexport { InstancedLinesMesh };\n//# sourceMappingURL=linesMesh.js.map","import { __extends, __generator } from \"tslib\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Tools, AsyncLoop } from \"../Misc/tools.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"../Misc/coroutine.js\";\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"./mesh.vertexData.js\";\nimport { Geometry } from \"./geometry.js\";\nimport { AbstractMesh } from \"./abstractMesh.js\";\nimport { SubMesh } from \"./subMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\n\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { GetClass, RegisterClass } from \"../Misc/typeStore.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { MeshLODLevel } from \"./meshLODLevel.js\";\n/**\n * @hidden\n **/\nvar _CreationDataStorage = /** @class */ (function () {\n    function _CreationDataStorage() {\n    }\n    return _CreationDataStorage;\n}());\nexport { _CreationDataStorage };\n/**\n * @hidden\n **/\nvar _InstanceDataStorage = /** @class */ (function () {\n    function _InstanceDataStorage() {\n        this.visibleInstances = {};\n        this.batchCache = new _InstancesBatch();\n        this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();\n        this.instancesBufferSize = 32 * 16 * 4; // let's start with a maximum of 32 instances\n    }\n    return _InstanceDataStorage;\n}());\n/**\n * @hidden\n **/\nvar _InstancesBatch = /** @class */ (function () {\n    function _InstancesBatch() {\n        this.mustReturn = false;\n        this.visibleInstances = new Array();\n        this.renderSelf = new Array();\n        this.hardwareInstancedRendering = new Array();\n    }\n    return _InstancesBatch;\n}());\nexport { _InstancesBatch };\n/**\n * @hidden\n **/\nvar _ThinInstanceDataStorage = /** @class */ (function () {\n    function _ThinInstanceDataStorage() {\n        this.instancesCount = 0;\n        this.matrixBuffer = null;\n        this.previousMatrixBuffer = null;\n        this.matrixBufferSize = 32 * 16; // let's start with a maximum of 32 thin instances\n        this.matrixData = null;\n        this.boundingVectors = [];\n        this.worldMatrices = null;\n    }\n    return _ThinInstanceDataStorage;\n}());\n/**\n * @hidden\n **/\nvar _InternalMeshDataInfo = /** @class */ (function () {\n    function _InternalMeshDataInfo() {\n        this._areNormalsFrozen = false; // Will be used by ribbons mainly\n        // Will be used to save a source mesh reference, If any\n        this._source = null;\n        // Will be used to for fast cloned mesh lookup\n        this.meshMap = null;\n        this._preActivateId = -1;\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        this._LODLevels = new Array();\n        /** Alternative definition of LOD level, using screen coverage instead of distance */\n        this._useLODScreenCoverage = false;\n        this._effectiveMaterial = null;\n        this._forcedInstanceCount = 0;\n    }\n    return _InternalMeshDataInfo;\n}());\n/**\n * Class used to represent renderable models\n */\nvar Mesh = /** @class */ (function (_super) {\n    __extends(Mesh, _super);\n    /**\n     * @constructor\n     * @param name The value used by scene.getMeshByName() to do a lookup.\n     * @param scene The scene to add this mesh to.\n     * @param parent The parent of this mesh, if it has one\n     * @param source An optional Mesh from which geometry is shared, cloned.\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n     *                  When false, achieved by calling a clone(), also passing False.\n     *                  This will make creation of children, recursive.\n     * @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.\n     */\n    function Mesh(name, scene, parent, source, doNotCloneChildren, clonePhysicsImpostor) {\n        if (scene === void 0) { scene = null; }\n        if (parent === void 0) { parent = null; }\n        if (source === void 0) { source = null; }\n        if (clonePhysicsImpostor === void 0) { clonePhysicsImpostor = true; }\n        var _this = _super.call(this, name, scene) || this;\n        // Internal data\n        _this._internalMeshDataInfo = new _InternalMeshDataInfo();\n        // Members\n        /**\n         * Gets the delay loading state of the mesh (when delay loading is turned on)\n         * @see https://doc.babylonjs.com/how_to/using_the_incremental_loading_system\n         */\n        _this.delayLoadState = 0;\n        /**\n         * Gets the list of instances created from this mesh\n         * it is not supposed to be modified manually.\n         * Note also that the order of the InstancedMesh wihin the array is not significant and might change.\n         * @see https://doc.babylonjs.com/how_to/how_to_use_instances\n         */\n        _this.instances = new Array();\n        // Private\n        /** @hidden */\n        _this._creationDataStorage = null;\n        /** @hidden */\n        _this._geometry = null;\n        /** @hidden */\n        _this._instanceDataStorage = new _InstanceDataStorage();\n        /** @hidden */\n        _this._thinInstanceDataStorage = new _ThinInstanceDataStorage();\n        /** @hidden */\n        _this._shouldGenerateFlatShading = false;\n        // Use by builder only to know what orientation were the mesh build in.\n        /** @hidden */\n        _this._originalBuilderSideOrientation = Mesh.DEFAULTSIDE;\n        /**\n         * Use this property to change the original side orientation defined at construction time\n         */\n        _this.overrideMaterialSideOrientation = null;\n        /**\n         * Gets or sets a boolean indicating whether to render ignoring the active camera's max z setting. (false by default)\n         * Note this will reduce performance when set to true.\n         */\n        _this.ignoreCameraMaxZ = false;\n        scene = _this.getScene();\n        _this._onBeforeDraw = function (isInstance, world, effectiveMaterial) {\n            if (isInstance && effectiveMaterial) {\n                if (_this._uniformBuffer) {\n                    _this.transferToEffect(world);\n                }\n                else {\n                    effectiveMaterial.bindOnlyWorldMatrix(world);\n                }\n            }\n        };\n        if (source) {\n            // Geometry\n            if (source._geometry) {\n                source._geometry.applyToMesh(_this);\n            }\n            // Deep copy\n            DeepCopier.DeepCopy(source, _this, [\n                \"name\",\n                \"material\",\n                \"skeleton\",\n                \"instances\",\n                \"parent\",\n                \"uniqueId\",\n                \"source\",\n                \"metadata\",\n                \"morphTargetManager\",\n                \"hasInstances\",\n                \"worldMatrixInstancedBuffer\",\n                \"previousWorldMatrixInstancedBuffer\",\n                \"hasLODLevels\",\n                \"geometry\",\n                \"isBlocked\",\n                \"areNormalsFrozen\",\n                \"facetNb\",\n                \"isFacetDataEnabled\",\n                \"lightSources\",\n                \"useBones\",\n                \"isAnInstance\",\n                \"collider\",\n                \"edgesRenderer\",\n                \"forward\",\n                \"up\",\n                \"right\",\n                \"absolutePosition\",\n                \"absoluteScaling\",\n                \"absoluteRotationQuaternion\",\n                \"isWorldMatrixFrozen\",\n                \"nonUniformScaling\",\n                \"behaviors\",\n                \"worldMatrixFromCache\",\n                \"hasThinInstances\",\n                \"cloneMeshMap\",\n                \"hasBoundingInfo\",\n            ], [\"_poseMatrix\"]);\n            // Source mesh\n            _this._internalMeshDataInfo._source = source;\n            if (scene.useClonedMeshMap) {\n                if (!source._internalMeshDataInfo.meshMap) {\n                    source._internalMeshDataInfo.meshMap = {};\n                }\n                source._internalMeshDataInfo.meshMap[_this.uniqueId] = _this;\n            }\n            // Construction Params\n            // Clone parameters allowing mesh to be updated in case of parametric shapes.\n            _this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;\n            _this._creationDataStorage = source._creationDataStorage;\n            // Animation ranges\n            if (source._ranges) {\n                var ranges = source._ranges;\n                for (var name_1 in ranges) {\n                    if (!Object.prototype.hasOwnProperty.call(ranges, name_1)) {\n                        continue;\n                    }\n                    if (!ranges[name_1]) {\n                        continue;\n                    }\n                    _this.createAnimationRange(name_1, ranges[name_1].from, ranges[name_1].to);\n                }\n            }\n            // Metadata\n            if (source.metadata && source.metadata.clone) {\n                _this.metadata = source.metadata.clone();\n            }\n            else {\n                _this.metadata = source.metadata;\n            }\n            // Tags\n            if (Tags && Tags.HasTags(source)) {\n                Tags.AddTagsTo(_this, Tags.GetTags(source, true));\n            }\n            // Enabled\n            _this.setEnabled(source.isEnabled());\n            // Parent\n            _this.parent = source.parent;\n            // Pivot\n            _this.setPivotMatrix(source.getPivotMatrix());\n            _this.id = name + \".\" + source.id;\n            // Material\n            _this.material = source.material;\n            if (!doNotCloneChildren) {\n                // Children\n                var directDescendants = source.getDescendants(true);\n                for (var index = 0; index < directDescendants.length; index++) {\n                    var child = directDescendants[index];\n                    if (child.clone) {\n                        child.clone(name + \".\" + child.name, _this);\n                    }\n                }\n            }\n            // Morphs\n            if (source.morphTargetManager) {\n                _this.morphTargetManager = source.morphTargetManager;\n            }\n            // Physics clone\n            if (scene.getPhysicsEngine) {\n                var physicsEngine = scene.getPhysicsEngine();\n                if (clonePhysicsImpostor && physicsEngine) {\n                    var impostor = physicsEngine.getImpostorForPhysicsObject(source);\n                    if (impostor) {\n                        _this.physicsImpostor = impostor.clone(_this);\n                    }\n                }\n            }\n            // Particles\n            for (var index = 0; index < scene.particleSystems.length; index++) {\n                var system = scene.particleSystems[index];\n                if (system.emitter === source) {\n                    system.clone(system.name, _this);\n                }\n            }\n            // Skeleton\n            _this.skeleton = source.skeleton;\n            _this.refreshBoundingInfo(true, true);\n            _this.computeWorldMatrix(true);\n        }\n        // Parent\n        if (parent !== null) {\n            _this.parent = parent;\n        }\n        _this._instanceDataStorage.hardwareInstancedRendering = _this.getEngine().getCaps().instancedArrays;\n        _this._internalMeshDataInfo._onMeshReadyObserverAdded = function (observer) {\n            // only notify once! then unregister the observer\n            observer.unregisterOnNextCall = true;\n            if (_this.isReady(true)) {\n                _this.onMeshReadyObservable.notifyObservers(_this);\n            }\n            else {\n                if (!_this._internalMeshDataInfo._checkReadinessObserver) {\n                    _this._internalMeshDataInfo._checkReadinessObserver = _this._scene.onBeforeRenderObservable.add(function () {\n                        // check for complete readiness\n                        if (_this.isReady(true)) {\n                            _this._scene.onBeforeRenderObservable.remove(_this._internalMeshDataInfo._checkReadinessObserver);\n                            _this._internalMeshDataInfo._checkReadinessObserver = null;\n                            _this.onMeshReadyObservable.notifyObservers(_this);\n                        }\n                    });\n                }\n            }\n        };\n        _this.onMeshReadyObservable = new Observable(_this._internalMeshDataInfo._onMeshReadyObserverAdded);\n        if (source) {\n            source.onClonedObservable.notifyObservers(_this);\n        }\n        return _this;\n    }\n    /**\n     * Gets the default side orientation.\n     * @param orientation the orientation to value to attempt to get\n     * @returns the default orientation\n     * @hidden\n     */\n    Mesh._GetDefaultSideOrientation = function (orientation) {\n        return orientation || Mesh.FRONTSIDE; // works as Mesh.FRONTSIDE is 0\n    };\n    Object.defineProperty(Mesh.prototype, \"useLODScreenCoverage\", {\n        /**\n         * Determines if the LOD levels are intended to be calculated using screen coverage (surface area ratio) instead of distance\n         */\n        get: function () {\n            return this._internalMeshDataInfo._useLODScreenCoverage;\n        },\n        set: function (value) {\n            this._internalMeshDataInfo._useLODScreenCoverage = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"computeBonesUsingShaders\", {\n        get: function () {\n            return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n        },\n        set: function (value) {\n            if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n                return;\n            }\n            if (value && this._internalMeshDataInfo._sourcePositions) {\n                // switch from software to GPU computation: we need to reset the vertex and normal buffers that have been updated by the software process\n                this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);\n                if (this._internalMeshDataInfo._sourceNormals) {\n                    this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);\n                }\n                this._internalMeshDataInfo._sourcePositions = null;\n                this._internalMeshDataInfo._sourceNormals = null;\n            }\n            this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n            this._markSubMeshesAsAttributesDirty();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"onBeforeRenderObservable\", {\n        /**\n         * An event triggered before rendering the mesh\n         */\n        get: function () {\n            if (!this._internalMeshDataInfo._onBeforeRenderObservable) {\n                this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();\n            }\n            return this._internalMeshDataInfo._onBeforeRenderObservable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"onBeforeBindObservable\", {\n        /**\n         * An event triggered before binding the mesh\n         */\n        get: function () {\n            if (!this._internalMeshDataInfo._onBeforeBindObservable) {\n                this._internalMeshDataInfo._onBeforeBindObservable = new Observable();\n            }\n            return this._internalMeshDataInfo._onBeforeBindObservable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"onAfterRenderObservable\", {\n        /**\n         * An event triggered after rendering the mesh\n         */\n        get: function () {\n            if (!this._internalMeshDataInfo._onAfterRenderObservable) {\n                this._internalMeshDataInfo._onAfterRenderObservable = new Observable();\n            }\n            return this._internalMeshDataInfo._onAfterRenderObservable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"onBetweenPassObservable\", {\n        /**\n         * An event triggeredbetween rendering pass when using separateCullingPass = true\n         */\n        get: function () {\n            if (!this._internalMeshDataInfo._onBetweenPassObservable) {\n                this._internalMeshDataInfo._onBetweenPassObservable = new Observable();\n            }\n            return this._internalMeshDataInfo._onBetweenPassObservable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"onBeforeDrawObservable\", {\n        /**\n         * An event triggered before drawing the mesh\n         */\n        get: function () {\n            if (!this._internalMeshDataInfo._onBeforeDrawObservable) {\n                this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();\n            }\n            return this._internalMeshDataInfo._onBeforeDrawObservable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"onBeforeDraw\", {\n        /**\n         * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead\n         */\n        set: function (callback) {\n            if (this._onBeforeDrawObserver) {\n                this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);\n            }\n            this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"hasInstances\", {\n        get: function () {\n            return this.instances.length > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"hasThinInstances\", {\n        get: function () {\n            var _a;\n            return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"forcedInstanceCount\", {\n        /**\n         * Gets or sets the forced number of instances to display.\n         * If 0 (default value), the number of instances is not forced and depends on the draw type\n         * (regular / instance / thin instances mesh)\n         */\n        get: function () {\n            return this._internalMeshDataInfo._forcedInstanceCount;\n        },\n        set: function (count) {\n            this._internalMeshDataInfo._forcedInstanceCount = count;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"source\", {\n        /**\n         * Gets the source mesh (the one used to clone this one from)\n         */\n        get: function () {\n            return this._internalMeshDataInfo._source;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"cloneMeshMap\", {\n        /**\n         * Gets the list of clones of this mesh\n         * The scene must have been constructed with useClonedMeshMap=true for this to work!\n         * Note that useClonedMeshMap=true is the default setting\n         */\n        get: function () {\n            return this._internalMeshDataInfo.meshMap;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"isUnIndexed\", {\n        /**\n         * Gets or sets a boolean indicating that this mesh does not use index buffer\n         */\n        get: function () {\n            return this._unIndexed;\n        },\n        set: function (value) {\n            if (this._unIndexed !== value) {\n                this._unIndexed = value;\n                this._markSubMeshesAsAttributesDirty();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"worldMatrixInstancedBuffer\", {\n        /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */\n        get: function () {\n            return this._instanceDataStorage.instancesData;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"previousWorldMatrixInstancedBuffer\", {\n        /** Gets the array buffer used to store the instanced buffer used for instances' previous world matrices */\n        get: function () {\n            return this._instanceDataStorage.instancesPreviousData;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"manualUpdateOfWorldMatrixInstancedBuffer\", {\n        /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n        get: function () {\n            return this._instanceDataStorage.manualUpdate;\n        },\n        set: function (value) {\n            this._instanceDataStorage.manualUpdate = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Mesh.prototype, \"manualUpdateOfPreviousWorldMatrixInstancedBuffer\", {\n        /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n        get: function () {\n            return this._instanceDataStorage.previousManualUpdate;\n        },\n        set: function (value) {\n            this._instanceDataStorage.previousManualUpdate = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Mesh.prototype.instantiateHierarchy = function (newParent, options, onNewNodeCreated) {\n        if (newParent === void 0) { newParent = null; }\n        var instance = this.getTotalVertices() > 0 && (!options || !options.doNotInstantiate)\n            ? this.createInstance(\"instance of \" + (this.name || this.id))\n            : this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true);\n        instance.parent = newParent || this.parent;\n        instance.position = this.position.clone();\n        instance.scaling = this.scaling.clone();\n        if (this.rotationQuaternion) {\n            instance.rotationQuaternion = this.rotationQuaternion.clone();\n        }\n        else {\n            instance.rotation = this.rotation.clone();\n        }\n        if (onNewNodeCreated) {\n            onNewNodeCreated(this, instance);\n        }\n        for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {\n            var child = _a[_i];\n            child.instantiateHierarchy(instance, options, onNewNodeCreated);\n        }\n        return instance;\n    };\n    /**\n     * Gets the class name\n     * @returns the string \"Mesh\".\n     */\n    Mesh.prototype.getClassName = function () {\n        return \"Mesh\";\n    };\n    Object.defineProperty(Mesh.prototype, \"_isMesh\", {\n        /** @hidden */\n        get: function () {\n            return true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns a description of this mesh\n     * @param fullDetails define if full details about this mesh must be used\n     * @returns a descriptive string representing this mesh\n     */\n    Mesh.prototype.toString = function (fullDetails) {\n        var ret = _super.prototype.toString.call(this, fullDetails);\n        ret += \", n vertices: \" + this.getTotalVertices();\n        ret += \", parent: \" + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : \"NONE\");\n        if (this.animations) {\n            for (var i = 0; i < this.animations.length; i++) {\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n            }\n        }\n        if (fullDetails) {\n            if (this._geometry) {\n                var ib = this.getIndices();\n                var vb = this.getVerticesData(VertexBuffer.PositionKind);\n                if (vb && ib) {\n                    ret += \", flat shading: \" + (vb.length / 3 === ib.length ? \"YES\" : \"NO\");\n                }\n            }\n            else {\n                ret += \", flat shading: UNKNOWN\";\n            }\n        }\n        return ret;\n    };\n    /** @hidden */\n    Mesh.prototype._unBindEffect = function () {\n        _super.prototype._unBindEffect.call(this);\n        for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {\n            var instance = _a[_i];\n            instance._unBindEffect();\n        }\n    };\n    Object.defineProperty(Mesh.prototype, \"hasLODLevels\", {\n        /**\n         * Gets a boolean indicating if this mesh has LOD\n         */\n        get: function () {\n            return this._internalMeshDataInfo._LODLevels.length > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Gets the list of MeshLODLevel associated with the current mesh\n     * @returns an array of MeshLODLevel\n     */\n    Mesh.prototype.getLODLevels = function () {\n        return this._internalMeshDataInfo._LODLevels;\n    };\n    Mesh.prototype._sortLODLevels = function () {\n        var sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;\n        this._internalMeshDataInfo._LODLevels.sort(function (a, b) {\n            if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {\n                return sortingOrderFactor;\n            }\n            if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {\n                return -sortingOrderFactor;\n            }\n            return 0;\n        });\n    };\n    /**\n     * Add a mesh as LOD level triggered at the given distance.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\n     * @param distanceOrScreenCoverage Either distance from the center of the object to show this level or the screen coverage if `useScreenCoverage` is set to `true`.\n     * If screen coverage, value is a fraction of the screen's total surface, between 0 and 1.\n     * @param mesh The mesh to be added as LOD level (can be null)\n     * @return This mesh (for chaining)\n     */\n    Mesh.prototype.addLODLevel = function (distanceOrScreenCoverage, mesh) {\n        if (mesh && mesh._masterMesh) {\n            Logger.Warn(\"You cannot use a mesh as LOD level twice\");\n            return this;\n        }\n        var level = new MeshLODLevel(distanceOrScreenCoverage, mesh);\n        this._internalMeshDataInfo._LODLevels.push(level);\n        if (mesh) {\n            mesh._masterMesh = this;\n        }\n        this._sortLODLevels();\n        return this;\n    };\n    /**\n     * Returns the LOD level mesh at the passed distance or null if not found.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\n     * @param distance The distance from the center of the object to show this level\n     * @returns a Mesh or `null`\n     */\n    Mesh.prototype.getLODLevelAtDistance = function (distance) {\n        var internalDataInfo = this._internalMeshDataInfo;\n        for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\n            var level = internalDataInfo._LODLevels[index];\n            if (level.distanceOrScreenCoverage === distance) {\n                return level.mesh;\n            }\n        }\n        return null;\n    };\n    /**\n     * Remove a mesh from the LOD array\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\n     * @param mesh defines the mesh to be removed\n     * @return This mesh (for chaining)\n     */\n    Mesh.prototype.removeLODLevel = function (mesh) {\n        var internalDataInfo = this._internalMeshDataInfo;\n        for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\n            if (internalDataInfo._LODLevels[index].mesh === mesh) {\n                internalDataInfo._LODLevels.splice(index, 1);\n                if (mesh) {\n                    mesh._masterMesh = null;\n                }\n            }\n        }\n        this._sortLODLevels();\n        return this;\n    };\n    /**\n     * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\n     * @param camera defines the camera to use to compute distance\n     * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh\n     * @return This mesh (for chaining)\n     */\n    Mesh.prototype.getLOD = function (camera, boundingSphere) {\n        var internalDataInfo = this._internalMeshDataInfo;\n        if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {\n            return this;\n        }\n        var bSphere;\n        if (boundingSphere) {\n            bSphere = boundingSphere;\n        }\n        else {\n            var boundingInfo = this.getBoundingInfo();\n            bSphere = boundingInfo.boundingSphere;\n        }\n        var distanceToCamera = bSphere.centerWorld.subtract(camera.globalPosition).length();\n        var useScreenCoverage = internalDataInfo._useLODScreenCoverage;\n        var compareValue = distanceToCamera;\n        var compareSign = 1;\n        if (useScreenCoverage) {\n            var screenArea = camera.screenArea;\n            var meshArea = (bSphere.radiusWorld * camera.minZ) / distanceToCamera;\n            meshArea = meshArea * meshArea * Math.PI;\n            compareValue = meshArea / screenArea;\n            compareSign = -1;\n        }\n        if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {\n            if (this.onLODLevelSelection) {\n                this.onLODLevelSelection(compareValue, this, this);\n            }\n            return this;\n        }\n        for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\n            var level = internalDataInfo._LODLevels[index];\n            if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {\n                if (level.mesh) {\n                    if (level.mesh.delayLoadState === 4) {\n                        level.mesh._checkDelayState();\n                        return this;\n                    }\n                    if (level.mesh.delayLoadState === 2) {\n                        return this;\n                    }\n                    level.mesh._preActivate();\n                    level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n                }\n                if (this.onLODLevelSelection) {\n                    this.onLODLevelSelection(compareValue, this, level.mesh);\n                }\n                return level.mesh;\n            }\n        }\n        if (this.onLODLevelSelection) {\n            this.onLODLevelSelection(compareValue, this, this);\n        }\n        return this;\n    };\n    Object.defineProperty(Mesh.prototype, \"geometry\", {\n        /**\n         * Gets the mesh internal Geometry object\n         */\n        get: function () {\n            return this._geometry;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.\n     * @returns the total number of vertices\n     */\n    Mesh.prototype.getTotalVertices = function () {\n        if (this._geometry === null || this._geometry === undefined) {\n            return 0;\n        }\n        return this._geometry.getTotalVertices();\n    };\n    /**\n     * Returns the content of an associated vertex buffer\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\n     * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.\n     */\n    Mesh.prototype.getVerticesData = function (kind, copyWhenShared, forceCopy) {\n        var _a, _b;\n        if (!this._geometry) {\n            return null;\n        }\n        var data = (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.getFloatData(this._geometry.getTotalVertices(), forceCopy || (copyWhenShared && this._geometry.meshes.length !== 1));\n        if (!data) {\n            data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);\n        }\n        return data;\n    };\n    /**\n     * Returns the mesh VertexBuffer object from the requested `kind`\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.NormalKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.\n     */\n    Mesh.prototype.getVertexBuffer = function (kind) {\n        var _a, _b;\n        if (!this._geometry) {\n            return null;\n        }\n        return (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== null && _b !== void 0 ? _b : this._geometry.getVertexBuffer(kind);\n    };\n    /**\n     * Tests if a specific vertex buffer is associated with this mesh\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.NormalKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @returns a boolean\n     */\n    Mesh.prototype.isVerticesDataPresent = function (kind) {\n        var _a;\n        if (!this._geometry) {\n            if (this._delayInfo) {\n                return this._delayInfo.indexOf(kind) !== -1;\n            }\n            return false;\n        }\n        return ((_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== undefined || this._geometry.isVerticesDataPresent(kind);\n    };\n    /**\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable.\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @returns a boolean\n     */\n    Mesh.prototype.isVertexBufferUpdatable = function (kind) {\n        var _a, _b;\n        if (!this._geometry) {\n            if (this._delayInfo) {\n                return this._delayInfo.indexOf(kind) !== -1;\n            }\n            return false;\n        }\n        return ((_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.isUpdatable()) || this._geometry.isVertexBufferUpdatable(kind);\n    };\n    /**\n     * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.\n     * @returns an array of strings\n     */\n    Mesh.prototype.getVerticesDataKinds = function () {\n        if (!this._geometry) {\n            var result_1 = new Array();\n            if (this._delayInfo) {\n                this._delayInfo.forEach(function (kind) {\n                    result_1.push(kind);\n                });\n            }\n            return result_1;\n        }\n        var kinds = this._geometry.getVerticesDataKinds();\n        if (this._userInstancedBuffersStorage) {\n            for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {\n                kinds.push(kind);\n            }\n        }\n        return kinds;\n    };\n    /**\n     * Returns a positive integer : the total number of indices in this mesh geometry.\n     * @returns the numner of indices or zero if the mesh has no geometry.\n     */\n    Mesh.prototype.getTotalIndices = function () {\n        if (!this._geometry) {\n            return 0;\n        }\n        return this._geometry.getTotalIndices();\n    };\n    /**\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n     * @returns the indices array or an empty array if the mesh has no geometry\n     */\n    Mesh.prototype.getIndices = function (copyWhenShared, forceCopy) {\n        if (!this._geometry) {\n            return [];\n        }\n        return this._geometry.getIndices(copyWhenShared, forceCopy);\n    };\n    Object.defineProperty(Mesh.prototype, \"isBlocked\", {\n        get: function () {\n            return this._masterMesh !== null && this._masterMesh !== undefined;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Determine if the current mesh is ready to be rendered\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n     * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)\n     * @returns true if all associated assets are ready (material, textures, shaders)\n     */\n    Mesh.prototype.isReady = function (completeCheck, forceInstanceSupport) {\n        var _a, _b, _c, _d, _e, _f;\n        if (completeCheck === void 0) { completeCheck = false; }\n        if (forceInstanceSupport === void 0) { forceInstanceSupport = false; }\n        if (this.delayLoadState === 2) {\n            return false;\n        }\n        if (!_super.prototype.isReady.call(this, completeCheck)) {\n            return false;\n        }\n        if (!this.subMeshes || this.subMeshes.length === 0) {\n            return true;\n        }\n        if (!completeCheck) {\n            return true;\n        }\n        var engine = this.getEngine();\n        var scene = this.getScene();\n        var hardwareInstancedRendering = forceInstanceSupport || (engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances));\n        this.computeWorldMatrix();\n        var mat = this.material || scene.defaultMaterial;\n        if (mat) {\n            if (mat._storeEffectOnSubMeshes) {\n                for (var _i = 0, _g = this.subMeshes; _i < _g.length; _i++) {\n                    var subMesh = _g[_i];\n                    var effectiveMaterial = subMesh.getMaterial();\n                    if (effectiveMaterial) {\n                        if (effectiveMaterial._storeEffectOnSubMeshes) {\n                            if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n                                return false;\n                            }\n                        }\n                        else {\n                            if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                if (!mat.isReady(this, hardwareInstancedRendering)) {\n                    return false;\n                }\n            }\n        }\n        // Shadows\n        var currentRenderPassId = engine.currentRenderPassId;\n        for (var _h = 0, _j = this.lightSources; _h < _j.length; _h++) {\n            var light = _j[_h];\n            var generator = light.getShadowGenerator();\n            if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || (((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1))) {\n                if (generator.getShadowMap()) {\n                    engine.currentRenderPassId = generator.getShadowMap().renderPassId;\n                }\n                for (var _k = 0, _l = this.subMeshes; _k < _l.length; _k++) {\n                    var subMesh = _l[_k];\n                    if (!generator.isReady(subMesh, hardwareInstancedRendering, (_f = (_e = subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {\n                        engine.currentRenderPassId = currentRenderPassId;\n                        return false;\n                    }\n                }\n                engine.currentRenderPassId = currentRenderPassId;\n            }\n        }\n        // LOD\n        for (var _m = 0, _o = this._internalMeshDataInfo._LODLevels; _m < _o.length; _m++) {\n            var lod = _o[_m];\n            if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Object.defineProperty(Mesh.prototype, \"areNormalsFrozen\", {\n        /**\n         * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.\n         */\n        get: function () {\n            return this._internalMeshDataInfo._areNormalsFrozen;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.\n     * @returns the current mesh\n     */\n    Mesh.prototype.freezeNormals = function () {\n        this._internalMeshDataInfo._areNormalsFrozen = true;\n        return this;\n    };\n    /**\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen\n     * @returns the current mesh\n     */\n    Mesh.prototype.unfreezeNormals = function () {\n        this._internalMeshDataInfo._areNormalsFrozen = false;\n        return this;\n    };\n    Object.defineProperty(Mesh.prototype, \"overridenInstanceCount\", {\n        /**\n         * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs\n         */\n        set: function (count) {\n            this._instanceDataStorage.overridenInstanceCount = count;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // Methods\n    /** @hidden */\n    Mesh.prototype._preActivate = function () {\n        var internalDataInfo = this._internalMeshDataInfo;\n        var sceneRenderId = this.getScene().getRenderId();\n        if (internalDataInfo._preActivateId === sceneRenderId) {\n            return this;\n        }\n        internalDataInfo._preActivateId = sceneRenderId;\n        this._instanceDataStorage.visibleInstances = null;\n        return this;\n    };\n    /**\n     * @param renderId\n     * @hidden\n     */\n    Mesh.prototype._preActivateForIntermediateRendering = function (renderId) {\n        if (this._instanceDataStorage.visibleInstances) {\n            this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;\n        }\n        return this;\n    };\n    /**\n     * @param instance\n     * @param renderId\n     * @hidden\n     */\n    Mesh.prototype._registerInstanceForRenderId = function (instance, renderId) {\n        if (!this._instanceDataStorage.visibleInstances) {\n            this._instanceDataStorage.visibleInstances = {\n                defaultRenderId: renderId,\n                selfDefaultRenderId: this._renderId\n            };\n        }\n        if (!this._instanceDataStorage.visibleInstances[renderId]) {\n            if (this._instanceDataStorage.previousRenderId !== undefined && this._instanceDataStorage.isFrozen) {\n                this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;\n            }\n            this._instanceDataStorage.previousRenderId = renderId;\n            this._instanceDataStorage.visibleInstances[renderId] = new Array();\n        }\n        this._instanceDataStorage.visibleInstances[renderId].push(instance);\n        return this;\n    };\n    Mesh.prototype._afterComputeWorldMatrix = function () {\n        _super.prototype._afterComputeWorldMatrix.call(this);\n        if (!this.hasThinInstances) {\n            return;\n        }\n        if (!this.doNotSyncBoundingInfo) {\n            this.thinInstanceRefreshBoundingInfo(false);\n        }\n    };\n    /** @hidden */\n    Mesh.prototype._postActivate = function () {\n        if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {\n            this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);\n            this.edgesRenderer.customInstances.push(this.getWorldMatrix());\n        }\n    };\n    /**\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n     * This means the mesh underlying bounding box and sphere are recomputed.\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n     * @returns the current mesh\n     */\n    Mesh.prototype.refreshBoundingInfo = function (applySkeleton, applyMorph) {\n        if (applySkeleton === void 0) { applySkeleton = false; }\n        if (applyMorph === void 0) { applyMorph = false; }\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n            return this;\n        }\n        var bias = this.geometry ? this.geometry.boundingBias : null;\n        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);\n        return this;\n    };\n    /**\n     * @param force\n     * @hidden\n     */\n    Mesh.prototype._createGlobalSubMesh = function (force) {\n        var totalVertices = this.getTotalVertices();\n        if (!totalVertices || !this.getIndices()) {\n            return null;\n        }\n        // Check if we need to recreate the submeshes\n        if (this.subMeshes && this.subMeshes.length > 0) {\n            var ib = this.getIndices();\n            if (!ib) {\n                return null;\n            }\n            var totalIndices = ib.length;\n            var needToRecreate = false;\n            if (force) {\n                needToRecreate = true;\n            }\n            else {\n                for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n                    var submesh = _a[_i];\n                    if (submesh.indexStart + submesh.indexCount > totalIndices) {\n                        needToRecreate = true;\n                        break;\n                    }\n                    if (submesh.verticesStart + submesh.verticesCount > totalVertices) {\n                        needToRecreate = true;\n                        break;\n                    }\n                }\n            }\n            if (!needToRecreate) {\n                return this.subMeshes[0];\n            }\n        }\n        this.releaseSubMeshes();\n        return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);\n    };\n    /**\n     * This function will subdivide the mesh into multiple submeshes\n     * @param count defines the expected number of submeshes\n     */\n    Mesh.prototype.subdivide = function (count) {\n        if (count < 1) {\n            return;\n        }\n        var totalIndices = this.getTotalIndices();\n        var subdivisionSize = (totalIndices / count) | 0;\n        var offset = 0;\n        // Ensure that subdivisionSize is a multiple of 3\n        while (subdivisionSize % 3 !== 0) {\n            subdivisionSize++;\n        }\n        this.releaseSubMeshes();\n        for (var index = 0; index < count; index++) {\n            if (offset >= totalIndices) {\n                break;\n            }\n            SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);\n            offset += subdivisionSize;\n        }\n        this.synchronizeInstances();\n    };\n    /**\n     * Copy a FloatArray into a specific associated vertex buffer\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\n     * @param stride defines the data stride size (can be null)\n     * @returns the current mesh\n     */\n    Mesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n        if (updatable === void 0) { updatable = false; }\n        if (!this._geometry) {\n            var vertexData = new VertexData();\n            vertexData.set(data, kind);\n            var scene = this.getScene();\n            new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n        }\n        else {\n            this._geometry.setVerticesData(kind, data, updatable, stride);\n        }\n        return this;\n    };\n    /**\n     * Delete a vertex buffer associated with this mesh\n     * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     */\n    Mesh.prototype.removeVerticesData = function (kind) {\n        if (!this._geometry) {\n            return;\n        }\n        this._geometry.removeVerticesData(kind);\n    };\n    /**\n     * Flags an associated vertex buffer as updatable\n     * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\n     */\n    Mesh.prototype.markVerticesDataAsUpdatable = function (kind, updatable) {\n        if (updatable === void 0) { updatable = true; }\n        var vb = this.getVertexBuffer(kind);\n        if (!vb || vb.isUpdatable() === updatable) {\n            return;\n        }\n        this.setVerticesData(kind, this.getVerticesData(kind), updatable);\n    };\n    /**\n     * Sets the mesh global Vertex Buffer\n     * @param buffer defines the buffer to use\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n     * @returns the current mesh\n     */\n    Mesh.prototype.setVerticesBuffer = function (buffer, disposeExistingBuffer) {\n        if (disposeExistingBuffer === void 0) { disposeExistingBuffer = true; }\n        if (!this._geometry) {\n            this._geometry = Geometry.CreateGeometryForMesh(this);\n        }\n        this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);\n        return this;\n    };\n    /**\n     * Update a specific associated vertex buffer\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\n     * @returns the current mesh\n     */\n    Mesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n        if (!this._geometry) {\n            return this;\n        }\n        if (!makeItUnique) {\n            this._geometry.updateVerticesData(kind, data, updateExtends);\n        }\n        else {\n            this.makeGeometryUnique();\n            this.updateVerticesData(kind, data, updateExtends, false);\n        }\n        return this;\n    };\n    /**\n     * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.\n     * @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions\n     * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything\n     * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update\n     * @returns the current mesh\n     */\n    Mesh.prototype.updateMeshPositions = function (positionFunction, computeNormals) {\n        if (computeNormals === void 0) { computeNormals = true; }\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\n        if (!positions) {\n            return this;\n        }\n        positionFunction(positions);\n        this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n        if (computeNormals) {\n            var indices = this.getIndices();\n            var normals = this.getVerticesData(VertexBuffer.NormalKind);\n            if (!normals) {\n                return this;\n            }\n            VertexData.ComputeNormals(positions, indices, normals);\n            this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n        }\n        return this;\n    };\n    /**\n     * Creates a un-shared specific occurence of the geometry for the mesh.\n     * @returns the current mesh\n     */\n    Mesh.prototype.makeGeometryUnique = function () {\n        if (!this._geometry) {\n            return this;\n        }\n        if (this._geometry.meshes.length === 1) {\n            return this;\n        }\n        var oldGeometry = this._geometry;\n        var geometry = this._geometry.copy(Geometry.RandomId());\n        oldGeometry.releaseForMesh(this, true);\n        geometry.applyToMesh(this);\n        return this;\n    };\n    /**\n     * Set the index buffer of this mesh\n     * @param indices defines the source data\n     * @param totalVertices defines the total number of vertices referenced by this index data (can be null)\n     * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)\n     * @returns the current mesh\n     */\n    Mesh.prototype.setIndices = function (indices, totalVertices, updatable) {\n        if (totalVertices === void 0) { totalVertices = null; }\n        if (updatable === void 0) { updatable = false; }\n        if (!this._geometry) {\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            var scene = this.getScene();\n            new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n        }\n        else {\n            this._geometry.setIndices(indices, totalVertices, updatable);\n        }\n        return this;\n    };\n    /**\n     * Update the current index buffer\n     * @param indices defines the source data\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n     * @returns the current mesh\n     */\n    Mesh.prototype.updateIndices = function (indices, offset, gpuMemoryOnly) {\n        if (gpuMemoryOnly === void 0) { gpuMemoryOnly = false; }\n        if (!this._geometry) {\n            return this;\n        }\n        this._geometry.updateIndices(indices, offset, gpuMemoryOnly);\n        return this;\n    };\n    /**\n     * Invert the geometry to move from a right handed system to a left handed one.\n     * @returns the current mesh\n     */\n    Mesh.prototype.toLeftHanded = function () {\n        if (!this._geometry) {\n            return this;\n        }\n        this._geometry.toLeftHanded();\n        return this;\n    };\n    /**\n     * @param subMesh\n     * @param effect\n     * @param fillMode\n     * @hidden\n     */\n    Mesh.prototype._bind = function (subMesh, effect, fillMode) {\n        if (!this._geometry) {\n            return this;\n        }\n        var engine = this.getScene().getEngine();\n        // Morph targets\n        if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {\n            this.morphTargetManager._bind(effect);\n        }\n        // Wireframe\n        var indexToBind;\n        if (this._unIndexed) {\n            indexToBind = null;\n        }\n        else {\n            switch (fillMode) {\n                case Material.PointFillMode:\n                    indexToBind = null;\n                    break;\n                case Material.WireFrameFillMode:\n                    indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);\n                    break;\n                default:\n                case Material.TriangleFillMode:\n                    indexToBind = this._geometry.getIndexBuffer();\n                    break;\n            }\n        }\n        // VBOs\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\n            this._geometry._bind(effect, indexToBind);\n        }\n        else {\n            this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\n        }\n        return this;\n    };\n    /**\n     * @param subMesh\n     * @param fillMode\n     * @param instancesCount\n     * @hidden\n     */\n    Mesh.prototype._draw = function (subMesh, fillMode, instancesCount) {\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\n            return this;\n        }\n        if (this._internalMeshDataInfo._onBeforeDrawObservable) {\n            this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);\n        }\n        var scene = this.getScene();\n        var engine = scene.getEngine();\n        if (this._unIndexed || fillMode == Material.PointFillMode) {\n            // or triangles as points\n            engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);\n        }\n        else if (fillMode == Material.WireFrameFillMode) {\n            // Triangles as wireframe\n            engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);\n        }\n        else {\n            engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);\n        }\n        return this;\n    };\n    /**\n     * Registers for this mesh a javascript function called just before the rendering process\n     * @param func defines the function to call before rendering this mesh\n     * @returns the current mesh\n     */\n    Mesh.prototype.registerBeforeRender = function (func) {\n        this.onBeforeRenderObservable.add(func);\n        return this;\n    };\n    /**\n     * Disposes a previously registered javascript function called before the rendering\n     * @param func defines the function to remove\n     * @returns the current mesh\n     */\n    Mesh.prototype.unregisterBeforeRender = function (func) {\n        this.onBeforeRenderObservable.removeCallback(func);\n        return this;\n    };\n    /**\n     * Registers for this mesh a javascript function called just after the rendering is complete\n     * @param func defines the function to call after rendering this mesh\n     * @returns the current mesh\n     */\n    Mesh.prototype.registerAfterRender = function (func) {\n        this.onAfterRenderObservable.add(func);\n        return this;\n    };\n    /**\n     * Disposes a previously registered javascript function called after the rendering.\n     * @param func defines the function to remove\n     * @returns the current mesh\n     */\n    Mesh.prototype.unregisterAfterRender = function (func) {\n        this.onAfterRenderObservable.removeCallback(func);\n        return this;\n    };\n    /**\n     * @param subMeshId\n     * @param isReplacementMode\n     * @hidden\n     */\n    Mesh.prototype._getInstancesRenderList = function (subMeshId, isReplacementMode) {\n        if (isReplacementMode === void 0) { isReplacementMode = false; }\n        if (this._instanceDataStorage.isFrozen) {\n            if (isReplacementMode) {\n                this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;\n                this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;\n                return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;\n            }\n            if (this._instanceDataStorage.previousBatch) {\n                return this._instanceDataStorage.previousBatch;\n            }\n        }\n        var scene = this.getScene();\n        var isInIntermediateRendering = scene._isInIntermediateRendering();\n        var onlyForInstances = isInIntermediateRendering\n            ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate\n            : this._internalAbstractMeshDataInfo._onlyForInstances;\n        var batchCache = this._instanceDataStorage.batchCache;\n        batchCache.mustReturn = false;\n        batchCache.renderSelf[subMeshId] = isReplacementMode || (!onlyForInstances && this.isEnabled() && this.isVisible);\n        batchCache.visibleInstances[subMeshId] = null;\n        if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {\n            var visibleInstances = this._instanceDataStorage.visibleInstances;\n            var currentRenderId = scene.getRenderId();\n            var defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;\n            batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];\n            if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {\n                batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];\n            }\n        }\n        batchCache.hardwareInstancedRendering[subMeshId] =\n            !isReplacementMode &&\n                this._instanceDataStorage.hardwareInstancedRendering &&\n                batchCache.visibleInstances[subMeshId] !== null &&\n                batchCache.visibleInstances[subMeshId] !== undefined;\n        this._instanceDataStorage.previousBatch = batchCache;\n        return batchCache;\n    };\n    /**\n     * @param subMesh\n     * @param fillMode\n     * @param batch\n     * @param effect\n     * @param engine\n     * @hidden\n     */\n    Mesh.prototype._renderWithInstances = function (subMesh, fillMode, batch, effect, engine) {\n        var _a;\n        var visibleInstances = batch.visibleInstances[subMesh._id];\n        if (!visibleInstances) {\n            return this;\n        }\n        var instanceStorage = this._instanceDataStorage;\n        var currentInstancesBufferSize = instanceStorage.instancesBufferSize;\n        var instancesBuffer = instanceStorage.instancesBuffer;\n        var instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;\n        var matricesCount = visibleInstances.length + 1;\n        var bufferSize = matricesCount * 16 * 4;\n        while (instanceStorage.instancesBufferSize < bufferSize) {\n            instanceStorage.instancesBufferSize *= 2;\n        }\n        if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n            instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n        }\n        if ((this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData) || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n            instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n        }\n        var offset = 0;\n        var instancesCount = 0;\n        var renderSelf = batch.renderSelf[subMesh._id];\n        var needUpdateBuffer = !instancesBuffer ||\n            currentInstancesBufferSize !== instanceStorage.instancesBufferSize ||\n            (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer);\n        if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {\n            var world = this.getWorldMatrix();\n            if (renderSelf) {\n                if (this._scene.needsPreviousWorldMatrices) {\n                    if (!instanceStorage.masterMeshPreviousWorldMatrix) {\n                        instanceStorage.masterMeshPreviousWorldMatrix = world.clone();\n                        instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n                    }\n                    else {\n                        instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n                        instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);\n                    }\n                }\n                world.copyToArray(instanceStorage.instancesData, offset);\n                offset += 16;\n                instancesCount++;\n            }\n            if (visibleInstances) {\n                if (Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {\n                    var cameraPosition = this._scene.activeCamera.globalPosition;\n                    for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n                        var instanceMesh = visibleInstances[instanceIndex];\n                        instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n                    }\n                    visibleInstances.sort(function (m1, m2) {\n                        return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;\n                    });\n                }\n                for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n                    var instance = visibleInstances[instanceIndex];\n                    var matrix = instance.getWorldMatrix();\n                    matrix.copyToArray(instanceStorage.instancesData, offset);\n                    if (this._scene.needsPreviousWorldMatrices) {\n                        if (!instance._previousWorldMatrix) {\n                            instance._previousWorldMatrix = matrix.clone();\n                            instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n                        }\n                        else {\n                            instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n                            instance._previousWorldMatrix.copyFrom(matrix);\n                        }\n                    }\n                    offset += 16;\n                    instancesCount++;\n                }\n            }\n        }\n        else {\n            instancesCount = (renderSelf ? 1 : 0) + visibleInstances.length;\n        }\n        if (needUpdateBuffer) {\n            if (instancesBuffer) {\n                instancesBuffer.dispose();\n            }\n            if (instancesPreviousBuffer) {\n                instancesPreviousBuffer.dispose();\n            }\n            instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);\n            instanceStorage.instancesBuffer = instancesBuffer;\n            if (!this._userInstancedBuffersStorage) {\n                this._userInstancedBuffersStorage = {\n                    data: {},\n                    vertexBuffers: {},\n                    strides: {},\n                    sizes: {},\n                    vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined\n                };\n            }\n            this._userInstancedBuffersStorage.vertexBuffers[\"world0\"] = instancesBuffer.createVertexBuffer(\"world0\", 0, 4);\n            this._userInstancedBuffersStorage.vertexBuffers[\"world1\"] = instancesBuffer.createVertexBuffer(\"world1\", 4, 4);\n            this._userInstancedBuffersStorage.vertexBuffers[\"world2\"] = instancesBuffer.createVertexBuffer(\"world2\", 8, 4);\n            this._userInstancedBuffersStorage.vertexBuffers[\"world3\"] = instancesBuffer.createVertexBuffer(\"world3\", 12, 4);\n            if (this._scene.needsPreviousWorldMatrices) {\n                instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);\n                instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld0\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld0\", 0, 4);\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld1\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld1\", 4, 4);\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld2\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld2\", 8, 4);\n                this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld3\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld3\", 12, 4);\n            }\n            this._invalidateInstanceVertexArrayObject();\n        }\n        else {\n            if (!this._instanceDataStorage.isFrozen) {\n                instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n                if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {\n                    instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);\n                }\n            }\n        }\n        this._processInstancedBuffers(visibleInstances, renderSelf);\n        // Stats\n        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n        // Draw\n        if (engine._currentDrawContext) {\n            engine._currentDrawContext.useInstancing = true;\n        }\n        this._bind(subMesh, effect, fillMode);\n        this._draw(subMesh, fillMode, instancesCount);\n        // Write current matrices as previous matrices in case of manual update\n        // Default behaviour when previous matrices are not specified explicitly\n        // Will break if instances number/order changes\n        if (this._scene.needsPreviousWorldMatrices &&\n            !needUpdateBuffer &&\n            this._instanceDataStorage.manualUpdate &&\n            !this._instanceDataStorage.isFrozen &&\n            !this._instanceDataStorage.previousManualUpdate) {\n            instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n        }\n        engine.unbindInstanceAttributes();\n        return this;\n    };\n    /**\n     * @param subMesh\n     * @param fillMode\n     * @param effect\n     * @param engine\n     * @hidden\n     */\n    Mesh.prototype._renderWithThinInstances = function (subMesh, fillMode, effect, engine) {\n        var _a, _b;\n        // Stats\n        var instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;\n        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n        // Draw\n        if (engine._currentDrawContext) {\n            engine._currentDrawContext.useInstancing = true;\n        }\n        this._bind(subMesh, effect, fillMode);\n        this._draw(subMesh, fillMode, instancesCount);\n        // Write current matrices as previous matrices\n        // Default behaviour when previous matrices are not specified explicitly\n        // Will break if instances number/order changes\n        if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {\n            if (!this._thinInstanceDataStorage.previousMatrixBuffer) {\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", this._thinInstanceDataStorage.matrixData, false);\n            }\n            else {\n                this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);\n            }\n        }\n        engine.unbindInstanceAttributes();\n    };\n    /**\n     * @param visibleInstances\n     * @param renderSelf\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Mesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\n        // Do nothing\n    };\n    /**\n     * @param renderingMesh\n     * @param subMesh\n     * @param effect\n     * @param fillMode\n     * @param batch\n     * @param hardwareInstancedRendering\n     * @param onBeforeDraw\n     * @param effectiveMaterial\n     * @hidden\n     */\n    Mesh.prototype._processRendering = function (renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {\n        var scene = this.getScene();\n        var engine = scene.getEngine();\n        if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {\n            this._renderWithThinInstances(subMesh, fillMode, effect, engine);\n            return this;\n        }\n        if (hardwareInstancedRendering) {\n            this._renderWithInstances(subMesh, fillMode, batch, effect, engine);\n        }\n        else {\n            if (engine._currentDrawContext) {\n                engine._currentDrawContext.useInstancing = false;\n            }\n            var instanceCount = 0;\n            if (batch.renderSelf[subMesh._id]) {\n                // Draw\n                if (onBeforeDraw) {\n                    onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);\n                }\n                instanceCount++;\n                this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);\n            }\n            var visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];\n            if (visibleInstancesForSubMesh) {\n                var visibleInstanceCount = visibleInstancesForSubMesh.length;\n                instanceCount += visibleInstanceCount;\n                // Stats\n                for (var instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {\n                    var instance = visibleInstancesForSubMesh[instanceIndex];\n                    // World\n                    var world = instance.getWorldMatrix();\n                    if (onBeforeDraw) {\n                        onBeforeDraw(true, world, effectiveMaterial);\n                    }\n                    // Draw\n                    this._draw(subMesh, fillMode);\n                }\n            }\n            // Stats\n            scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);\n        }\n        return this;\n    };\n    /**\n     * @param dispose\n     * @hidden\n     */\n    Mesh.prototype._rebuild = function (dispose) {\n        if (dispose === void 0) { dispose = false; }\n        if (this._instanceDataStorage.instancesBuffer) {\n            // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n            if (dispose) {\n                this._instanceDataStorage.instancesBuffer.dispose();\n            }\n            this._instanceDataStorage.instancesBuffer = null;\n        }\n        if (this._userInstancedBuffersStorage) {\n            for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {\n                var buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];\n                if (buffer) {\n                    // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n                    if (dispose) {\n                        buffer.dispose();\n                    }\n                    this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n                }\n            }\n            if (this._userInstancedBuffersStorage.vertexArrayObjects) {\n                this._userInstancedBuffersStorage.vertexArrayObjects = {};\n            }\n        }\n        this._internalMeshDataInfo._effectiveMaterial = null;\n        _super.prototype._rebuild.call(this, dispose);\n    };\n    /** @hidden */\n    Mesh.prototype._freeze = function () {\n        if (!this.subMeshes) {\n            return;\n        }\n        // Prepare batches\n        for (var index = 0; index < this.subMeshes.length; index++) {\n            this._getInstancesRenderList(index);\n        }\n        this._internalMeshDataInfo._effectiveMaterial = null;\n        this._instanceDataStorage.isFrozen = true;\n    };\n    /** @hidden */\n    Mesh.prototype._unFreeze = function () {\n        this._instanceDataStorage.isFrozen = false;\n        this._instanceDataStorage.previousBatch = null;\n    };\n    /**\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n     * @param subMesh defines the subMesh to render\n     * @param enableAlphaMode defines if alpha mode can be changed\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n     * @returns the current mesh\n     */\n    Mesh.prototype.render = function (subMesh, enableAlphaMode, effectiveMeshReplacement) {\n        var _a, _b, _c;\n        var scene = this.getScene();\n        if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {\n            this._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n        }\n        else {\n            this._internalAbstractMeshDataInfo._isActive = false;\n        }\n        if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {\n            return this;\n        }\n        // Managing instances\n        var batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);\n        if (batch.mustReturn) {\n            return this;\n        }\n        // Checking geometry state\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\n            return this;\n        }\n        var engine = scene.getEngine();\n        var oldCameraMaxZ = 0;\n        var oldCamera = null;\n        if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {\n            oldCameraMaxZ = scene.activeCamera.maxZ;\n            oldCamera = scene.activeCamera;\n            scene.activeCamera.maxZ = 0;\n            scene.updateTransformMatrix(true);\n        }\n        if (this._internalMeshDataInfo._onBeforeRenderObservable) {\n            this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);\n        }\n        var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || subMesh.getRenderingMesh().hasThinInstances;\n        var instanceDataStorage = this._instanceDataStorage;\n        var material = subMesh.getMaterial();\n        if (!material) {\n            if (oldCamera) {\n                oldCamera.maxZ = oldCameraMaxZ;\n                scene.updateTransformMatrix(true);\n            }\n            return this;\n        }\n        // Material\n        if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {\n            if (material._storeEffectOnSubMeshes) {\n                if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n                    if (oldCamera) {\n                        oldCamera.maxZ = oldCameraMaxZ;\n                        scene.updateTransformMatrix(true);\n                    }\n                    return this;\n                }\n            }\n            else if (!material.isReady(this, hardwareInstancedRendering)) {\n                if (oldCamera) {\n                    oldCamera.maxZ = oldCameraMaxZ;\n                    scene.updateTransformMatrix(true);\n                }\n                return this;\n            }\n            this._internalMeshDataInfo._effectiveMaterial = material;\n        }\n        else if ((material._storeEffectOnSubMeshes && !((_a = subMesh.effect) === null || _a === void 0 ? void 0 : _a._wasPreviouslyReady)) ||\n            (!material._storeEffectOnSubMeshes && !((_b = material.getEffect()) === null || _b === void 0 ? void 0 : _b._wasPreviouslyReady))) {\n            if (oldCamera) {\n                oldCamera.maxZ = oldCameraMaxZ;\n                scene.updateTransformMatrix(true);\n            }\n            return this;\n        }\n        // Alpha mode\n        if (enableAlphaMode) {\n            engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);\n        }\n        var drawWrapper;\n        if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {\n            drawWrapper = subMesh._drawWrapper;\n        }\n        else {\n            drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();\n        }\n        var effect = (_c = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _c !== void 0 ? _c : null;\n        for (var _i = 0, _d = scene._beforeRenderingMeshStage; _i < _d.length; _i++) {\n            var step = _d[_i];\n            step.action(this, subMesh, batch, effect);\n        }\n        if (!drawWrapper || !effect) {\n            if (oldCamera) {\n                oldCamera.maxZ = oldCameraMaxZ;\n                scene.updateTransformMatrix(true);\n            }\n            return this;\n        }\n        var effectiveMesh = effectiveMeshReplacement || this;\n        var sideOrientation;\n        if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {\n            var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n            sideOrientation = this.overrideMaterialSideOrientation;\n            if (sideOrientation == null) {\n                sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;\n            }\n            if (mainDeterminant < 0) {\n                sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n            }\n            instanceDataStorage.sideOrientation = sideOrientation;\n        }\n        else {\n            sideOrientation = instanceDataStorage.sideOrientation;\n        }\n        var reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);\n        if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {\n            engine.setDepthWrite(true);\n        }\n        // Bind\n        var fillMode = scene.forcePointsCloud\n            ? Material.PointFillMode\n            : scene.forceWireframe\n                ? Material.WireFrameFillMode\n                : this._internalMeshDataInfo._effectiveMaterial.fillMode;\n        if (this._internalMeshDataInfo._onBeforeBindObservable) {\n            this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);\n        }\n        if (!hardwareInstancedRendering) {\n            // Binding will be done later because we need to add more info to the VB\n            this._bind(subMesh, effect, fillMode);\n        }\n        var effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;\n        var world = effectiveMesh.getWorldMatrix();\n        if (effectiveMaterial._storeEffectOnSubMeshes) {\n            effectiveMaterial.bindForSubMesh(world, this, subMesh);\n        }\n        else {\n            effectiveMaterial.bind(world, this);\n        }\n        if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {\n            engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n            this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n            engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n            if (this._internalMeshDataInfo._onBetweenPassObservable) {\n                this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);\n            }\n        }\n        // Draw\n        this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n        // Unbind\n        this._internalMeshDataInfo._effectiveMaterial.unbind();\n        for (var _e = 0, _f = scene._afterRenderingMeshStage; _e < _f.length; _e++) {\n            var step = _f[_e];\n            step.action(this, subMesh, batch, effect);\n        }\n        if (this._internalMeshDataInfo._onAfterRenderObservable) {\n            this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);\n        }\n        if (oldCamera) {\n            oldCamera.maxZ = oldCameraMaxZ;\n            scene.updateTransformMatrix(true);\n        }\n        return this;\n    };\n    /**\n     *   Renormalize the mesh and patch it up if there are no weights\n     *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.\n     *   However in the case of zero weights then we set just a single influence to 1.\n     *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.\n     */\n    Mesh.prototype.cleanMatrixWeights = function () {\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n            if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n                this._normalizeSkinWeightsAndExtra();\n            }\n            else {\n                this._normalizeSkinFourWeights();\n            }\n        }\n    };\n    // faster 4 weight version.\n    Mesh.prototype._normalizeSkinFourWeights = function () {\n        var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n        var numWeights = matricesWeights.length;\n        for (var a = 0; a < numWeights; a += 4) {\n            // accumulate weights\n            var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n            // check for invalid weight and just set it to 1.\n            if (t === 0) {\n                matricesWeights[a] = 1;\n            }\n            else {\n                // renormalize so everything adds to 1 use reciprocal\n                var recip = 1 / t;\n                matricesWeights[a] *= recip;\n                matricesWeights[a + 1] *= recip;\n                matricesWeights[a + 2] *= recip;\n                matricesWeights[a + 3] *= recip;\n            }\n        }\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n    };\n    // handle special case of extra verts.  (in theory gltf can handle 12 influences)\n    Mesh.prototype._normalizeSkinWeightsAndExtra = function () {\n        var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n        var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n        var numWeights = matricesWeights.length;\n        for (var a = 0; a < numWeights; a += 4) {\n            // accumulate weights\n            var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n            t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];\n            // check for invalid weight and just set it to 1.\n            if (t === 0) {\n                matricesWeights[a] = 1;\n            }\n            else {\n                // renormalize so everything adds to 1 use reciprocal\n                var recip = 1 / t;\n                matricesWeights[a] *= recip;\n                matricesWeights[a + 1] *= recip;\n                matricesWeights[a + 2] *= recip;\n                matricesWeights[a + 3] *= recip;\n                // same goes for extras\n                matricesWeightsExtra[a] *= recip;\n                matricesWeightsExtra[a + 1] *= recip;\n                matricesWeightsExtra[a + 2] *= recip;\n                matricesWeightsExtra[a + 3] *= recip;\n            }\n        }\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);\n    };\n    /**\n     * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,\n     * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let\n     * the user know there was an issue with importing the mesh\n     * @returns a validation object with skinned, valid and report string\n     */\n    Mesh.prototype.validateSkinning = function () {\n        var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n        var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n        if (matricesWeights === null || this.skeleton == null) {\n            return { skinned: false, valid: true, report: \"not skinned\" };\n        }\n        var numWeights = matricesWeights.length;\n        var numberNotSorted = 0;\n        var missingWeights = 0;\n        var maxUsedWeights = 0;\n        var numberNotNormalized = 0;\n        var numInfluences = matricesWeightsExtra === null ? 4 : 8;\n        var usedWeightCounts = new Array();\n        for (var a = 0; a <= numInfluences; a++) {\n            usedWeightCounts[a] = 0;\n        }\n        var toleranceEpsilon = 0.001;\n        for (var a = 0; a < numWeights; a += 4) {\n            var lastWeight = matricesWeights[a];\n            var t = lastWeight;\n            var usedWeights = t === 0 ? 0 : 1;\n            for (var b = 1; b < numInfluences; b++) {\n                var d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];\n                if (d > lastWeight) {\n                    numberNotSorted++;\n                }\n                if (d !== 0) {\n                    usedWeights++;\n                }\n                t += d;\n                lastWeight = d;\n            }\n            // count the buffer weights usage\n            usedWeightCounts[usedWeights]++;\n            // max influences\n            if (usedWeights > maxUsedWeights) {\n                maxUsedWeights = usedWeights;\n            }\n            // check for invalid weight and just set it to 1.\n            if (t === 0) {\n                missingWeights++;\n            }\n            else {\n                // renormalize so everything adds to 1 use reciprocal\n                var recip = 1 / t;\n                var tolerance = 0;\n                for (var b = 0; b < numInfluences; b++) {\n                    if (b < 4) {\n                        tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);\n                    }\n                    else {\n                        tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);\n                    }\n                }\n                // arbitrary epsilon value for dictating not normalized\n                if (tolerance > toleranceEpsilon) {\n                    numberNotNormalized++;\n                }\n            }\n        }\n        // validate bone indices are in range of the skeleton\n        var numBones = this.skeleton.bones.length;\n        var matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n        var matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n        var numBadBoneIndices = 0;\n        for (var a = 0; a < numWeights; a += 4) {\n            for (var b = 0; b < numInfluences; b++) {\n                var index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];\n                if (index >= numBones || index < 0) {\n                    numBadBoneIndices++;\n                }\n            }\n        }\n        // log mesh stats\n        var output = \"Number of Weights = \" +\n            numWeights / 4 +\n            \"\\nMaximum influences = \" +\n            maxUsedWeights +\n            \"\\nMissing Weights = \" +\n            missingWeights +\n            \"\\nNot Sorted = \" +\n            numberNotSorted +\n            \"\\nNot Normalized = \" +\n            numberNotNormalized +\n            \"\\nWeightCounts = [\" +\n            usedWeightCounts +\n            \"]\" +\n            \"\\nNumber of bones = \" +\n            numBones +\n            \"\\nBad Bone Indices = \" +\n            numBadBoneIndices;\n        return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };\n    };\n    /** @hidden */\n    Mesh.prototype._checkDelayState = function () {\n        var scene = this.getScene();\n        if (this._geometry) {\n            this._geometry.load(scene);\n        }\n        else if (this.delayLoadState === 4) {\n            this.delayLoadState = 2;\n            this._queueLoad(scene);\n        }\n        return this;\n    };\n    Mesh.prototype._queueLoad = function (scene) {\n        var _this = this;\n        scene._addPendingData(this);\n        var getBinaryData = this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\") !== -1;\n        Tools.LoadFile(this.delayLoadingFile, function (data) {\n            if (data instanceof ArrayBuffer) {\n                _this._delayLoadingFunction(data, _this);\n            }\n            else {\n                _this._delayLoadingFunction(JSON.parse(data), _this);\n            }\n            _this.instances.forEach(function (instance) {\n                instance.refreshBoundingInfo();\n                instance._syncSubMeshes();\n            });\n            _this.delayLoadState = 1;\n            scene._removePendingData(_this);\n        }, function () { }, scene.offlineProvider, getBinaryData);\n        return this;\n    };\n    /**\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n     * A mesh is in the frustum if its bounding box intersects the frustum\n     * @param frustumPlanes defines the frustum to test\n     * @returns true if the mesh is in the frustum planes\n     */\n    Mesh.prototype.isInFrustum = function (frustumPlanes) {\n        if (this.delayLoadState === 2) {\n            return false;\n        }\n        if (!_super.prototype.isInFrustum.call(this, frustumPlanes)) {\n            return false;\n        }\n        this._checkDelayState();\n        return true;\n    };\n    /**\n     * Sets the mesh material by the material or multiMaterial `id` property\n     * @param id is a string identifying the material or the multiMaterial\n     * @returns the current mesh\n     */\n    Mesh.prototype.setMaterialById = function (id) {\n        var materials = this.getScene().materials;\n        var index;\n        for (index = materials.length - 1; index > -1; index--) {\n            if (materials[index].id === id) {\n                this.material = materials[index];\n                return this;\n            }\n        }\n        // Multi\n        var multiMaterials = this.getScene().multiMaterials;\n        for (index = multiMaterials.length - 1; index > -1; index--) {\n            if (multiMaterials[index].id === id) {\n                this.material = multiMaterials[index];\n                return this;\n            }\n        }\n        return this;\n    };\n    /**\n     * Returns as a new array populated with the mesh material and/or skeleton, if any.\n     * @returns an array of IAnimatable\n     */\n    Mesh.prototype.getAnimatables = function () {\n        var results = new Array();\n        if (this.material) {\n            results.push(this.material);\n        }\n        if (this.skeleton) {\n            results.push(this.skeleton);\n        }\n        return results;\n    };\n    /**\n     * Modifies the mesh geometry according to the passed transformation matrix.\n     * This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.\n     * The mesh normals are modified using the same transformation.\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\n     * @param transform defines the transform matrix to use\n     * @see https://doc.babylonjs.com/resources/baking_transformations\n     * @returns the current mesh\n     */\n    Mesh.prototype.bakeTransformIntoVertices = function (transform) {\n        // Position\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n            return this;\n        }\n        var submeshes = this.subMeshes.splice(0);\n        this._resetPointsArrayCache();\n        var data = this.getVerticesData(VertexBuffer.PositionKind);\n        var temp = new Array();\n        var index;\n        for (index = 0; index < data.length; index += 3) {\n            Vector3.TransformCoordinates(Vector3.FromArray(data, index), transform).toArray(temp, index);\n        }\n        this.setVerticesData(VertexBuffer.PositionKind, temp, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());\n        // Normals\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n            data = this.getVerticesData(VertexBuffer.NormalKind);\n            temp = [];\n            for (index = 0; index < data.length; index += 3) {\n                Vector3.TransformNormal(Vector3.FromArray(data, index), transform).normalize().toArray(temp, index);\n            }\n            this.setVerticesData(VertexBuffer.NormalKind, temp, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());\n        }\n        // flip faces?\n        if (transform.determinant() < 0) {\n            this.flipFaces();\n        }\n        // Restore submeshes\n        this.releaseSubMeshes();\n        this.subMeshes = submeshes;\n        return this;\n    };\n    /**\n     * Modifies the mesh geometry according to its own current World Matrix.\n     * The mesh World Matrix is then reset.\n     * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\n     * @see https://doc.babylonjs.com/resources/baking_transformations\n     * @param bakeIndependenlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking\n     * @returns the current mesh\n     */\n    Mesh.prototype.bakeCurrentTransformIntoVertices = function (bakeIndependenlyOfChildren) {\n        if (bakeIndependenlyOfChildren === void 0) { bakeIndependenlyOfChildren = true; }\n        this.bakeTransformIntoVertices(this.computeWorldMatrix(true));\n        this.resetLocalMatrix(bakeIndependenlyOfChildren);\n        return this;\n    };\n    Object.defineProperty(Mesh.prototype, \"_positions\", {\n        // Cache\n        /** @hidden */\n        get: function () {\n            if (this._internalAbstractMeshDataInfo._positions) {\n                return this._internalAbstractMeshDataInfo._positions;\n            }\n            if (this._geometry) {\n                return this._geometry._positions;\n            }\n            return null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** @hidden */\n    Mesh.prototype._resetPointsArrayCache = function () {\n        if (this._geometry) {\n            this._geometry._resetPointsArrayCache();\n        }\n        return this;\n    };\n    /** @hidden */\n    Mesh.prototype._generatePointsArray = function () {\n        if (this._geometry) {\n            return this._geometry._generatePointsArray();\n        }\n        return false;\n    };\n    /**\n     * Returns a new Mesh object generated from the current mesh properties.\n     * This method must not get confused with createInstance()\n     * @param name is a string, the name given to the new mesh\n     * @param newParent can be any Node object (default `null`)\n     * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)\n     * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)\n     * @returns a new mesh\n     */\n    Mesh.prototype.clone = function (name, newParent, doNotCloneChildren, clonePhysicsImpostor) {\n        if (name === void 0) { name = \"\"; }\n        if (newParent === void 0) { newParent = null; }\n        if (clonePhysicsImpostor === void 0) { clonePhysicsImpostor = true; }\n        return new Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);\n    };\n    /**\n     * Releases resources associated with this mesh.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    Mesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }\n        this.morphTargetManager = null;\n        if (this._geometry) {\n            this._geometry.releaseForMesh(this, true);\n        }\n        var internalDataInfo = this._internalMeshDataInfo;\n        if (internalDataInfo._onBeforeDrawObservable) {\n            internalDataInfo._onBeforeDrawObservable.clear();\n        }\n        if (internalDataInfo._onBeforeBindObservable) {\n            internalDataInfo._onBeforeBindObservable.clear();\n        }\n        if (internalDataInfo._onBeforeRenderObservable) {\n            internalDataInfo._onBeforeRenderObservable.clear();\n        }\n        if (internalDataInfo._onAfterRenderObservable) {\n            internalDataInfo._onAfterRenderObservable.clear();\n        }\n        if (internalDataInfo._onBetweenPassObservable) {\n            internalDataInfo._onBetweenPassObservable.clear();\n        }\n        // Sources\n        if (this._scene.useClonedMeshMap) {\n            if (internalDataInfo.meshMap) {\n                for (var uniqueId in internalDataInfo.meshMap) {\n                    var mesh = internalDataInfo.meshMap[uniqueId];\n                    if (mesh) {\n                        mesh._internalMeshDataInfo._source = null;\n                        internalDataInfo.meshMap[uniqueId] = undefined;\n                    }\n                }\n            }\n            if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {\n                internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = undefined;\n            }\n        }\n        else {\n            var meshes = this.getScene().meshes;\n            for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {\n                var abstractMesh = meshes_1[_i];\n                var mesh = abstractMesh;\n                if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {\n                    mesh._internalMeshDataInfo._source = null;\n                }\n            }\n        }\n        internalDataInfo._source = null;\n        // Instances\n        this._disposeInstanceSpecificData();\n        // Thin instances\n        this._disposeThinInstanceSpecificData();\n        if (this._internalMeshDataInfo._checkReadinessObserver) {\n            this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\n        }\n        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n    };\n    /** @hidden */\n    Mesh.prototype._disposeInstanceSpecificData = function () {\n        // Do nothing\n    };\n    /** @hidden */\n    Mesh.prototype._disposeThinInstanceSpecificData = function () {\n        // Do nothing\n    };\n    /** @hidden */\n    Mesh.prototype._invalidateInstanceVertexArrayObject = function () {\n        // Do nothing\n    };\n    /**\n     * Modifies the mesh geometry according to a displacement map.\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n     * @param url is a string, the URL from the image file is to be downloaded.\n     * @param minHeight is the lower limit of the displacement.\n     * @param maxHeight is the upper limit of the displacement.\n     * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\n     * @param uvOffset is an optional vector2 used to offset UV.\n     * @param uvScale is an optional vector2 used to scale UV.\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n     * @returns the Mesh.\n     */\n    Mesh.prototype.applyDisplacementMap = function (url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate) {\n        var _this = this;\n        if (forceUpdate === void 0) { forceUpdate = false; }\n        var scene = this.getScene();\n        var onload = function (img) {\n            // Getting height map data\n            var heightMapWidth = img.width;\n            var heightMapHeight = img.height;\n            var canvas = _this.getEngine().createCanvas(heightMapWidth, heightMapHeight);\n            var context = canvas.getContext(\"2d\");\n            context.drawImage(img, 0, 0);\n            // Create VertexData from map data\n            //Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n            var buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;\n            _this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);\n            //execute success callback, if set\n            if (onSuccess) {\n                onSuccess(_this);\n            }\n        };\n        Tools.LoadImage(url, onload, function () { }, scene.offlineProvider);\n        return this;\n    };\n    /**\n     * Modifies the mesh geometry according to a displacementMap buffer.\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n     * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.\n     * @param heightMapWidth is the width of the buffer image.\n     * @param heightMapHeight is the height of the buffer image.\n     * @param minHeight is the lower limit of the displacement.\n     * @param maxHeight is the upper limit of the displacement.\n     * @param uvOffset is an optional vector2 used to offset UV.\n     * @param uvScale is an optional vector2 used to scale UV.\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n     * @returns the Mesh.\n     */\n    Mesh.prototype.applyDisplacementMapFromBuffer = function (buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate) {\n        if (forceUpdate === void 0) { forceUpdate = false; }\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n            Logger.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\");\n            return this;\n        }\n        var positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);\n        var normals = this.getVerticesData(VertexBuffer.NormalKind);\n        var uvs = this.getVerticesData(VertexBuffer.UVKind);\n        var position = Vector3.Zero();\n        var normal = Vector3.Zero();\n        var uv = Vector2.Zero();\n        uvOffset = uvOffset || Vector2.Zero();\n        uvScale = uvScale || new Vector2(1, 1);\n        for (var index = 0; index < positions.length; index += 3) {\n            Vector3.FromArrayToRef(positions, index, position);\n            Vector3.FromArrayToRef(normals, index, normal);\n            Vector2.FromArrayToRef(uvs, (index / 3) * 2, uv);\n            // Compute height\n            var u = (Math.abs(uv.x * uvScale.x + (uvOffset.x % 1)) * (heightMapWidth - 1)) % heightMapWidth | 0;\n            var v = (Math.abs(uv.y * uvScale.y + (uvOffset.y % 1)) * (heightMapHeight - 1)) % heightMapHeight | 0;\n            var pos = (u + v * heightMapWidth) * 4;\n            var r = buffer[pos] / 255.0;\n            var g = buffer[pos + 1] / 255.0;\n            var b = buffer[pos + 2] / 255.0;\n            var gradient = r * 0.3 + g * 0.59 + b * 0.11;\n            normal.normalize();\n            normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);\n            position = position.add(normal);\n            position.toArray(positions, index);\n        }\n        VertexData.ComputeNormals(positions, this.getIndices(), normals);\n        if (forceUpdate) {\n            this.setVerticesData(VertexBuffer.PositionKind, positions);\n            this.setVerticesData(VertexBuffer.NormalKind, normals);\n            this.setVerticesData(VertexBuffer.UVKind, uvs);\n        }\n        else {\n            this.updateVerticesData(VertexBuffer.PositionKind, positions);\n            this.updateVerticesData(VertexBuffer.NormalKind, normals);\n        }\n        return this;\n    };\n    /**\n     * Modify the mesh to get a flat shading rendering.\n     * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.\n     * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.\n     * @returns current mesh\n     */\n    Mesh.prototype.convertToFlatShadedMesh = function () {\n        var kinds = this.getVerticesDataKinds();\n        var vbs = {};\n        var data = {};\n        var newdata = {};\n        var updatableNormals = false;\n        var kindIndex;\n        var kind;\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n            kind = kinds[kindIndex];\n            var vertexBuffer = this.getVertexBuffer(kind);\n            // Check data consistency\n            var vertexData = vertexBuffer.getData();\n            if (vertexData instanceof Array || vertexData instanceof Float32Array) {\n                if (vertexData.length === 0) {\n                    continue;\n                }\n            }\n            if (kind === VertexBuffer.NormalKind) {\n                updatableNormals = vertexBuffer.isUpdatable();\n                kinds.splice(kindIndex, 1);\n                kindIndex--;\n                continue;\n            }\n            vbs[kind] = vertexBuffer;\n            data[kind] = this.getVerticesData(kind);\n            newdata[kind] = [];\n        }\n        // Save previous submeshes\n        var previousSubmeshes = this.subMeshes.slice(0);\n        var indices = this.getIndices();\n        var totalIndices = this.getTotalIndices();\n        // Generating unique vertices per face\n        var index;\n        for (index = 0; index < totalIndices; index++) {\n            var vertexIndex = indices[index];\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                kind = kinds[kindIndex];\n                if (!vbs[kind]) {\n                    continue;\n                }\n                var stride = vbs[kind].getStrideSize();\n                for (var offset = 0; offset < stride; offset++) {\n                    newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n                }\n            }\n        }\n        // Updating faces & normal\n        var normals = [];\n        var positions = newdata[VertexBuffer.PositionKind];\n        var useRightHandedSystem = this.getScene().useRightHandedSystem;\n        var flipNormalGeneration;\n        if (useRightHandedSystem) {\n            flipNormalGeneration = this.overrideMaterialSideOrientation === 1;\n        }\n        else {\n            flipNormalGeneration = this.overrideMaterialSideOrientation === 0;\n        }\n        for (index = 0; index < totalIndices; index += 3) {\n            indices[index] = index;\n            indices[index + 1] = index + 1;\n            indices[index + 2] = index + 2;\n            var p1 = Vector3.FromArray(positions, index * 3);\n            var p2 = Vector3.FromArray(positions, (index + 1) * 3);\n            var p3 = Vector3.FromArray(positions, (index + 2) * 3);\n            var p1p2 = p1.subtract(p2);\n            var p3p2 = p3.subtract(p2);\n            var normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));\n            if (flipNormalGeneration) {\n                normal.scaleInPlace(-1);\n            }\n            // Store same normals for every vertex\n            for (var localIndex = 0; localIndex < 3; localIndex++) {\n                normals.push(normal.x);\n                normals.push(normal.y);\n                normals.push(normal.z);\n            }\n        }\n        this.setIndices(indices);\n        this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);\n        // Updating vertex buffers\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n            kind = kinds[kindIndex];\n            if (!newdata[kind]) {\n                continue;\n            }\n            this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\n        }\n        // Updating submeshes\n        this.releaseSubMeshes();\n        for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n            var previousOne = previousSubmeshes[submeshIndex];\n            SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n        }\n        this.synchronizeInstances();\n        return this;\n    };\n    /**\n     * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.\n     * In other words, more vertices, no more indices and a single bigger VBO.\n     * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.\n     * @returns current mesh\n     */\n    Mesh.prototype.convertToUnIndexedMesh = function () {\n        var kinds = this.getVerticesDataKinds();\n        var vbs = {};\n        var data = {};\n        var newdata = {};\n        var kindIndex;\n        var kind;\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n            kind = kinds[kindIndex];\n            var vertexBuffer = this.getVertexBuffer(kind);\n            vbs[kind] = vertexBuffer;\n            data[kind] = vbs[kind].getData();\n            newdata[kind] = [];\n        }\n        // Save previous submeshes\n        var previousSubmeshes = this.subMeshes.slice(0);\n        var indices = this.getIndices();\n        var totalIndices = this.getTotalIndices();\n        // Generating unique vertices per face\n        var index;\n        for (index = 0; index < totalIndices; index++) {\n            var vertexIndex = indices[index];\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                kind = kinds[kindIndex];\n                var stride = vbs[kind].getStrideSize();\n                for (var offset = 0; offset < stride; offset++) {\n                    newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n                }\n            }\n        }\n        // Updating indices\n        for (index = 0; index < totalIndices; index += 3) {\n            indices[index] = index;\n            indices[index + 1] = index + 1;\n            indices[index + 2] = index + 2;\n        }\n        this.setIndices(indices);\n        // Updating vertex buffers\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n            kind = kinds[kindIndex];\n            this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\n        }\n        // Updating submeshes\n        this.releaseSubMeshes();\n        for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n            var previousOne = previousSubmeshes[submeshIndex];\n            SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n        }\n        this._unIndexed = true;\n        this.synchronizeInstances();\n        return this;\n    };\n    /**\n     * Inverses facet orientations.\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     * @param flipNormals will also inverts the normals\n     * @returns current mesh\n     */\n    Mesh.prototype.flipFaces = function (flipNormals) {\n        if (flipNormals === void 0) { flipNormals = false; }\n        var vertex_data = VertexData.ExtractFromMesh(this);\n        var i;\n        if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {\n            for (i = 0; i < vertex_data.normals.length; i++) {\n                vertex_data.normals[i] *= -1;\n            }\n        }\n        if (vertex_data.indices) {\n            var temp = void 0;\n            for (i = 0; i < vertex_data.indices.length; i += 3) {\n                // reassign indices\n                temp = vertex_data.indices[i + 1];\n                vertex_data.indices[i + 1] = vertex_data.indices[i + 2];\n                vertex_data.indices[i + 2] = temp;\n            }\n        }\n        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n        return this;\n    };\n    /**\n     * Increase the number of facets and hence vertices in a mesh\n     * Vertex normals are interpolated from existing vertex normals\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1\n     */\n    Mesh.prototype.increaseVertices = function (numberPerEdge) {\n        if (numberPerEdge === void 0) { numberPerEdge = 1; }\n        var vertex_data = VertexData.ExtractFromMesh(this);\n        var currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;\n        var positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;\n        var uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;\n        var normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;\n        if (!currentIndices || !positions) {\n            Logger.Warn(\"Couldn't increase number of vertices : VertexData must contain at least indices and positions\");\n        }\n        else {\n            vertex_data.indices = currentIndices;\n            vertex_data.positions = positions;\n            if (uvs) {\n                vertex_data.uvs = uvs;\n            }\n            if (normals) {\n                vertex_data.normals = normals;\n            }\n            var segments = numberPerEdge + 1; //segments per current facet edge, become sides of new facets\n            var tempIndices = new Array();\n            for (var i = 0; i < segments + 1; i++) {\n                tempIndices[i] = new Array();\n            }\n            var a = void 0; //vertex index of one end of a side\n            var b = void 0; //vertex index of other end of the side\n            var deltaPosition = new Vector3(0, 0, 0);\n            var deltaNormal = new Vector3(0, 0, 0);\n            var deltaUV = new Vector2(0, 0);\n            var indices = new Array();\n            var vertexIndex = new Array();\n            var side = new Array();\n            var len = void 0;\n            var positionPtr = positions.length;\n            var uvPtr = void 0;\n            if (uvs) {\n                uvPtr = uvs.length;\n            }\n            var normalsPtr = void 0;\n            if (normals) {\n                normalsPtr = normals.length;\n            }\n            for (var i = 0; i < currentIndices.length; i += 3) {\n                vertexIndex[0] = currentIndices[i];\n                vertexIndex[1] = currentIndices[i + 1];\n                vertexIndex[2] = currentIndices[i + 2];\n                for (var j = 0; j < 3; j++) {\n                    a = vertexIndex[j];\n                    b = vertexIndex[(j + 1) % 3];\n                    if (side[a] === undefined && side[b] === undefined) {\n                        side[a] = new Array();\n                        side[b] = new Array();\n                    }\n                    else {\n                        if (side[a] === undefined) {\n                            side[a] = new Array();\n                        }\n                        if (side[b] === undefined) {\n                            side[b] = new Array();\n                        }\n                    }\n                    if (side[a][b] === undefined && side[b][a] === undefined) {\n                        side[a][b] = [];\n                        deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;\n                        deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;\n                        deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;\n                        if (normals) {\n                            deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;\n                            deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;\n                            deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;\n                        }\n                        if (uvs) {\n                            deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;\n                            deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;\n                        }\n                        side[a][b].push(a);\n                        for (var k = 1; k < segments; k++) {\n                            side[a][b].push(positions.length / 3);\n                            positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;\n                            positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;\n                            positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;\n                            if (normals) {\n                                normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;\n                                normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;\n                                normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;\n                            }\n                            if (uvs) {\n                                uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;\n                                uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;\n                            }\n                        }\n                        side[a][b].push(b);\n                        side[b][a] = new Array();\n                        len = side[a][b].length;\n                        for (var idx = 0; idx < len; idx++) {\n                            side[b][a][idx] = side[a][b][len - 1 - idx];\n                        }\n                    }\n                }\n                //Calculate positions, normals and uvs of new internal vertices\n                tempIndices[0][0] = currentIndices[i];\n                tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];\n                tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];\n                for (var k = 2; k < segments; k++) {\n                    tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];\n                    tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];\n                    deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;\n                    deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;\n                    deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;\n                    if (normals) {\n                        deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;\n                        deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;\n                        deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;\n                    }\n                    if (uvs) {\n                        deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;\n                        deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;\n                    }\n                    for (var j = 1; j < k; j++) {\n                        tempIndices[k][j] = positions.length / 3;\n                        positions[positionPtr++] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;\n                        positions[positionPtr++] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;\n                        positions[positionPtr++] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;\n                        if (normals) {\n                            normals[normalsPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;\n                            normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;\n                            normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;\n                        }\n                        if (uvs) {\n                            uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;\n                            uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;\n                        }\n                    }\n                }\n                tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];\n                // reform indices\n                indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);\n                for (var k = 1; k < segments; k++) {\n                    var j = void 0;\n                    for (j = 0; j < k; j++) {\n                        indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\n                        indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);\n                    }\n                    indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\n                }\n            }\n            vertex_data.indices = indices;\n            vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n        }\n    };\n    /**\n     * Force adjacent facets to share vertices and remove any facets that have all vertices in a line\n     * This will undo any application of covertToFlatShadedMesh\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     */\n    Mesh.prototype.forceSharedVertices = function () {\n        var vertex_data = VertexData.ExtractFromMesh(this);\n        var currentUVs = vertex_data.uvs;\n        var currentIndices = vertex_data.indices;\n        var currentPositions = vertex_data.positions;\n        var currentColors = vertex_data.colors;\n        if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {\n            Logger.Warn(\"VertexData contains empty entries\");\n        }\n        else {\n            var positions = new Array();\n            var indices = new Array();\n            var uvs = new Array();\n            var colors = new Array();\n            var pstring = new Array(); //lists facet vertex positions (a,b,c) as string \"a|b|c\"\n            var indexPtr = 0; // pointer to next available index value\n            var uniquePositions = {}; // unique vertex positions\n            var ptr = void 0; // pointer to element in uniquePositions\n            var facet = void 0;\n            for (var i = 0; i < currentIndices.length; i += 3) {\n                facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]]; //facet vertex indices\n                pstring = new Array();\n                for (var j = 0; j < 3; j++) {\n                    pstring[j] = \"\";\n                    for (var k = 0; k < 3; k++) {\n                        //small values make 0\n                        if (Math.abs(currentPositions[3 * facet[j] + k]) < 0.00000001) {\n                            currentPositions[3 * facet[j] + k] = 0;\n                        }\n                        pstring[j] += currentPositions[3 * facet[j] + k] + \"|\";\n                    }\n                }\n                //check facet vertices to see that none are repeated\n                // do not process any facet that has a repeated vertex, ie is a line\n                if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {\n                    //for each facet position check if already listed in uniquePositions\n                    // if not listed add to uniquePositions and set index pointer\n                    // if listed use its index in uniquePositions and new index pointer\n                    for (var j = 0; j < 3; j++) {\n                        ptr = uniquePositions[pstring[j]];\n                        if (ptr === undefined) {\n                            uniquePositions[pstring[j]] = indexPtr;\n                            ptr = indexPtr++;\n                            //not listed so add individual x, y, z coordinates to positions\n                            for (var k = 0; k < 3; k++) {\n                                positions.push(currentPositions[3 * facet[j] + k]);\n                            }\n                            if (currentColors !== null && currentColors !== void 0) {\n                                for (var k = 0; k < 4; k++) {\n                                    colors.push(currentColors[4 * facet[j] + k]);\n                                }\n                            }\n                            if (currentUVs !== null && currentUVs !== void 0) {\n                                for (var k = 0; k < 2; k++) {\n                                    uvs.push(currentUVs[2 * facet[j] + k]);\n                                }\n                            }\n                        }\n                        // add new index pointer to indices array\n                        indices.push(ptr);\n                    }\n                }\n            }\n            var normals = new Array();\n            VertexData.ComputeNormals(positions, indices, normals);\n            //create new vertex data object and update\n            vertex_data.positions = positions;\n            vertex_data.indices = indices;\n            vertex_data.normals = normals;\n            if (currentUVs !== null && currentUVs !== void 0) {\n                vertex_data.uvs = uvs;\n            }\n            if (currentColors !== null && currentColors !== void 0) {\n                vertex_data.colors = colors;\n            }\n            vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n        }\n    };\n    // Instances\n    /**\n     * @param name\n     * @param mesh\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/naming-convention\n    Mesh._instancedMeshFactory = function (name, mesh) {\n        throw _WarnImport(\"InstancedMesh\");\n    };\n    /**\n     * @param scene\n     * @param physicObject\n     * @param jsonObject\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Mesh._PhysicsImpostorParser = function (scene, physicObject, jsonObject) {\n        throw _WarnImport(\"PhysicsImpostor\");\n    };\n    /**\n     * Creates a new InstancedMesh object from the mesh model.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\n     * @param name defines the name of the new instance\n     * @returns a new InstancedMesh\n     */\n    Mesh.prototype.createInstance = function (name) {\n        return Mesh._instancedMeshFactory(name, this);\n    };\n    /**\n     * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.\n     * After this call, all the mesh instances have the same submeshes than the current mesh.\n     * @returns the current mesh\n     */\n    Mesh.prototype.synchronizeInstances = function () {\n        for (var instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {\n            var instance = this.instances[instanceIndex];\n            instance._syncSubMeshes();\n        }\n        return this;\n    };\n    /**\n     * Optimization of the mesh's indices, in case a mesh has duplicated vertices.\n     * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.\n     * This should be used together with the simplification to avoid disappearing triangles.\n     * @param successCallback an optional success callback to be called after the optimization finished.\n     * @returns the current mesh\n     */\n    Mesh.prototype.optimizeIndices = function (successCallback) {\n        var _this = this;\n        var indices = this.getIndices();\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\n        if (!positions || !indices) {\n            return this;\n        }\n        var vectorPositions = new Array();\n        for (var pos = 0; pos < positions.length; pos = pos + 3) {\n            vectorPositions.push(Vector3.FromArray(positions, pos));\n        }\n        var dupes = new Array();\n        AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, function (iteration) {\n            var realPos = vectorPositions.length - 1 - iteration;\n            var testedPosition = vectorPositions[realPos];\n            for (var j = 0; j < realPos; ++j) {\n                var againstPosition = vectorPositions[j];\n                if (testedPosition.equals(againstPosition)) {\n                    dupes[realPos] = j;\n                    break;\n                }\n            }\n        }, function () {\n            for (var i = 0; i < indices.length; ++i) {\n                indices[i] = dupes[indices[i]] || indices[i];\n            }\n            //indices are now reordered\n            var originalSubMeshes = _this.subMeshes.slice(0);\n            _this.setIndices(indices);\n            _this.subMeshes = originalSubMeshes;\n            if (successCallback) {\n                successCallback(_this);\n            }\n        });\n        return this;\n    };\n    /**\n     * Serialize current mesh\n     * @param serializationObject defines the object which will receive the serialization data\n     */\n    Mesh.prototype.serialize = function (serializationObject) {\n        serializationObject.name = this.name;\n        serializationObject.id = this.id;\n        serializationObject.uniqueId = this.uniqueId;\n        serializationObject.type = this.getClassName();\n        if (Tags && Tags.HasTags(this)) {\n            serializationObject.tags = Tags.GetTags(this);\n        }\n        serializationObject.position = this.position.asArray();\n        if (this.rotationQuaternion) {\n            serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();\n        }\n        else if (this.rotation) {\n            serializationObject.rotation = this.rotation.asArray();\n        }\n        serializationObject.scaling = this.scaling.asArray();\n        if (this._postMultiplyPivotMatrix) {\n            serializationObject.pivotMatrix = this.getPivotMatrix().asArray();\n        }\n        else {\n            serializationObject.localMatrix = this.getPivotMatrix().asArray();\n        }\n        serializationObject.isEnabled = this.isEnabled(false);\n        serializationObject.isVisible = this.isVisible;\n        serializationObject.infiniteDistance = this.infiniteDistance;\n        serializationObject.pickable = this.isPickable;\n        serializationObject.receiveShadows = this.receiveShadows;\n        serializationObject.billboardMode = this.billboardMode;\n        serializationObject.visibility = this.visibility;\n        serializationObject.checkCollisions = this.checkCollisions;\n        serializationObject.isBlocker = this.isBlocker;\n        serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;\n        // Parent\n        if (this.parent) {\n            serializationObject.parentId = this.parent.uniqueId;\n        }\n        // Geometry\n        serializationObject.isUnIndexed = this.isUnIndexed;\n        var geometry = this._geometry;\n        if (geometry && this.subMeshes) {\n            serializationObject.geometryUniqueId = geometry.uniqueId;\n            serializationObject.geometryId = geometry.id;\n            // SubMeshes\n            serializationObject.subMeshes = [];\n            for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\n                var subMesh = this.subMeshes[subIndex];\n                serializationObject.subMeshes.push({\n                    materialIndex: subMesh.materialIndex,\n                    verticesStart: subMesh.verticesStart,\n                    verticesCount: subMesh.verticesCount,\n                    indexStart: subMesh.indexStart,\n                    indexCount: subMesh.indexCount\n                });\n            }\n        }\n        // Material\n        if (this.material) {\n            if (!this.material.doNotSerialize) {\n                serializationObject.materialUniqueId = this.material.uniqueId;\n                serializationObject.materialId = this.material.id; // back compat\n            }\n        }\n        else {\n            this.material = null;\n            serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;\n            serializationObject.materialId = this._scene.defaultMaterial.id; // back compat\n        }\n        // Morph targets\n        if (this.morphTargetManager) {\n            serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;\n        }\n        // Skeleton\n        if (this.skeleton) {\n            serializationObject.skeletonId = this.skeleton.id;\n            serializationObject.numBoneInfluencers = this.numBoneInfluencers;\n        }\n        // Physics\n        //TODO implement correct serialization for physics impostors.\n        if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n            var impostor = this.getPhysicsImpostor();\n            if (impostor) {\n                serializationObject.physicsMass = impostor.getParam(\"mass\");\n                serializationObject.physicsFriction = impostor.getParam(\"friction\");\n                serializationObject.physicsRestitution = impostor.getParam(\"mass\");\n                serializationObject.physicsImpostor = impostor.type;\n            }\n        }\n        // Metadata\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        // Instances\n        serializationObject.instances = [];\n        for (var index = 0; index < this.instances.length; index++) {\n            var instance = this.instances[index];\n            if (instance.doNotSerialize) {\n                continue;\n            }\n            var serializationInstance = {\n                name: instance.name,\n                id: instance.id,\n                isEnabled: instance.isEnabled(false),\n                isVisible: instance.isVisible,\n                isPickable: instance.isPickable,\n                checkCollisions: instance.checkCollisions,\n                position: instance.position.asArray(),\n                scaling: instance.scaling.asArray()\n            };\n            if (instance.parent) {\n                serializationInstance.parentId = instance.parent.uniqueId;\n            }\n            if (instance.rotationQuaternion) {\n                serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();\n            }\n            else if (instance.rotation) {\n                serializationInstance.rotation = instance.rotation.asArray();\n            }\n            // Physics\n            //TODO implement correct serialization for physics impostors.\n            if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n                var impostor = instance.getPhysicsImpostor();\n                if (impostor) {\n                    serializationInstance.physicsMass = impostor.getParam(\"mass\");\n                    serializationInstance.physicsFriction = impostor.getParam(\"friction\");\n                    serializationInstance.physicsRestitution = impostor.getParam(\"mass\");\n                    serializationInstance.physicsImpostor = impostor.type;\n                }\n            }\n            // Metadata\n            if (instance.metadata) {\n                serializationInstance.metadata = instance.metadata;\n            }\n            serializationObject.instances.push(serializationInstance);\n            // Animations\n            SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);\n            serializationInstance.ranges = instance.serializeAnimationRanges();\n        }\n        // Thin instances\n        if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {\n            serializationObject.thinInstances = {\n                instancesCount: this._thinInstanceDataStorage.instancesCount,\n                matrixData: Array.from(this._thinInstanceDataStorage.matrixData),\n                matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,\n                enablePicking: this.thinInstanceEnablePicking\n            };\n            if (this._userThinInstanceBuffersStorage) {\n                var userThinInstance = {\n                    data: {},\n                    sizes: {},\n                    strides: {}\n                };\n                for (var kind in this._userThinInstanceBuffersStorage.data) {\n                    userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);\n                    userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];\n                    userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];\n                }\n                serializationObject.thinInstances.userThinInstance = userThinInstance;\n            }\n        }\n        // Animations\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n        serializationObject.ranges = this.serializeAnimationRanges();\n        // Layer mask\n        serializationObject.layerMask = this.layerMask;\n        // Alpha\n        serializationObject.alphaIndex = this.alphaIndex;\n        serializationObject.hasVertexAlpha = this.hasVertexAlpha;\n        // Overlay\n        serializationObject.overlayAlpha = this.overlayAlpha;\n        serializationObject.overlayColor = this.overlayColor.asArray();\n        serializationObject.renderOverlay = this.renderOverlay;\n        // Fog\n        serializationObject.applyFog = this.applyFog;\n        // Action Manager\n        if (this.actionManager) {\n            serializationObject.actions = this.actionManager.serialize(this.name);\n        }\n    };\n    /** @hidden */\n    Mesh.prototype._syncGeometryWithMorphTargetManager = function () {\n        if (!this.geometry) {\n            return;\n        }\n        this._markSubMeshesAsAttributesDirty();\n        var morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;\n        if (morphTargetManager && morphTargetManager.vertexCount) {\n            if (morphTargetManager.vertexCount !== this.getTotalVertices()) {\n                Logger.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\");\n                this.morphTargetManager = null;\n                return;\n            }\n            if (morphTargetManager.isUsingTextureForTargets) {\n                return;\n            }\n            for (var index = 0; index < morphTargetManager.numInfluencers; index++) {\n                var morphTarget = morphTargetManager.getActiveTarget(index);\n                var positions = morphTarget.getPositions();\n                if (!positions) {\n                    Logger.Error(\"Invalid morph target. Target must have positions.\");\n                    return;\n                }\n                this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);\n                var normals = morphTarget.getNormals();\n                if (normals) {\n                    this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);\n                }\n                var tangents = morphTarget.getTangents();\n                if (tangents) {\n                    this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);\n                }\n                var uvs = morphTarget.getUVs();\n                if (uvs) {\n                    this.geometry.setVerticesData(VertexBuffer.UVKind + \"_\" + index, uvs, false, 2);\n                }\n            }\n        }\n        else {\n            var index = 0;\n            // Positions\n            while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {\n                this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {\n                    this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);\n                }\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {\n                    this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);\n                }\n                if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {\n                    this.geometry.removeVerticesData(VertexBuffer.UVKind + \"_\" + index);\n                }\n                index++;\n            }\n        }\n    };\n    /**\n     * Returns a new Mesh object parsed from the source provided.\n     * @param parsedMesh is the source\n     * @param scene defines the hosting scene\n     * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with\n     * @returns a new Mesh\n     */\n    Mesh.Parse = function (parsedMesh, scene, rootUrl) {\n        var mesh;\n        if (parsedMesh.type && parsedMesh.type === \"LinesMesh\") {\n            mesh = Mesh._LinesMeshParser(parsedMesh, scene);\n        }\n        else if (parsedMesh.type && parsedMesh.type === \"GroundMesh\") {\n            mesh = Mesh._GroundMeshParser(parsedMesh, scene);\n        }\n        else if (parsedMesh.type && parsedMesh.type === \"GoldbergMesh\") {\n            mesh = Mesh._GoldbergMeshParser(parsedMesh, scene);\n        }\n        else {\n            mesh = new Mesh(parsedMesh.name, scene);\n        }\n        mesh.id = parsedMesh.id;\n        if (Tags) {\n            Tags.AddTagsTo(mesh, parsedMesh.tags);\n        }\n        mesh.position = Vector3.FromArray(parsedMesh.position);\n        if (parsedMesh.metadata !== undefined) {\n            mesh.metadata = parsedMesh.metadata;\n        }\n        if (parsedMesh.rotationQuaternion) {\n            mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);\n        }\n        else if (parsedMesh.rotation) {\n            mesh.rotation = Vector3.FromArray(parsedMesh.rotation);\n        }\n        mesh.scaling = Vector3.FromArray(parsedMesh.scaling);\n        if (parsedMesh.localMatrix) {\n            mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));\n        }\n        else if (parsedMesh.pivotMatrix) {\n            mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));\n        }\n        mesh.setEnabled(parsedMesh.isEnabled);\n        mesh.isVisible = parsedMesh.isVisible;\n        mesh.infiniteDistance = parsedMesh.infiniteDistance;\n        mesh.showBoundingBox = parsedMesh.showBoundingBox;\n        mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;\n        if (parsedMesh.applyFog !== undefined) {\n            mesh.applyFog = parsedMesh.applyFog;\n        }\n        if (parsedMesh.pickable !== undefined) {\n            mesh.isPickable = parsedMesh.pickable;\n        }\n        if (parsedMesh.alphaIndex !== undefined) {\n            mesh.alphaIndex = parsedMesh.alphaIndex;\n        }\n        mesh.receiveShadows = parsedMesh.receiveShadows;\n        mesh.billboardMode = parsedMesh.billboardMode;\n        if (parsedMesh.visibility !== undefined) {\n            mesh.visibility = parsedMesh.visibility;\n        }\n        mesh.checkCollisions = parsedMesh.checkCollisions;\n        mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;\n        if (parsedMesh.isBlocker !== undefined) {\n            mesh.isBlocker = parsedMesh.isBlocker;\n        }\n        mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;\n        // freezeWorldMatrix\n        if (parsedMesh.freezeWorldMatrix) {\n            mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;\n        }\n        // Parent\n        if (parsedMesh.parentId !== undefined) {\n            mesh._waitingParentId = parsedMesh.parentId;\n        }\n        // Actions\n        if (parsedMesh.actions !== undefined) {\n            mesh._waitingData.actions = parsedMesh.actions;\n        }\n        // Overlay\n        if (parsedMesh.overlayAlpha !== undefined) {\n            mesh.overlayAlpha = parsedMesh.overlayAlpha;\n        }\n        if (parsedMesh.overlayColor !== undefined) {\n            mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);\n        }\n        if (parsedMesh.renderOverlay !== undefined) {\n            mesh.renderOverlay = parsedMesh.renderOverlay;\n        }\n        // Geometry\n        mesh.isUnIndexed = !!parsedMesh.isUnIndexed;\n        mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;\n        if (parsedMesh.delayLoadingFile) {\n            mesh.delayLoadState = 4;\n            mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;\n            mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));\n            if (parsedMesh._binaryInfo) {\n                mesh._binaryInfo = parsedMesh._binaryInfo;\n            }\n            mesh._delayInfo = [];\n            if (parsedMesh.hasUVs) {\n                mesh._delayInfo.push(VertexBuffer.UVKind);\n            }\n            if (parsedMesh.hasUVs2) {\n                mesh._delayInfo.push(VertexBuffer.UV2Kind);\n            }\n            if (parsedMesh.hasUVs3) {\n                mesh._delayInfo.push(VertexBuffer.UV3Kind);\n            }\n            if (parsedMesh.hasUVs4) {\n                mesh._delayInfo.push(VertexBuffer.UV4Kind);\n            }\n            if (parsedMesh.hasUVs5) {\n                mesh._delayInfo.push(VertexBuffer.UV5Kind);\n            }\n            if (parsedMesh.hasUVs6) {\n                mesh._delayInfo.push(VertexBuffer.UV6Kind);\n            }\n            if (parsedMesh.hasColors) {\n                mesh._delayInfo.push(VertexBuffer.ColorKind);\n            }\n            if (parsedMesh.hasMatricesIndices) {\n                mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n            }\n            if (parsedMesh.hasMatricesWeights) {\n                mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n            }\n            mesh._delayLoadingFunction = Geometry._ImportGeometry;\n            if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {\n                mesh._checkDelayState();\n            }\n        }\n        else {\n            Geometry._ImportGeometry(parsedMesh, mesh);\n        }\n        // Material\n        if (parsedMesh.materialUniqueId) {\n            mesh._waitingMaterialId = parsedMesh.materialUniqueId;\n        }\n        else if (parsedMesh.materialId) {\n            mesh._waitingMaterialId = parsedMesh.materialId;\n        }\n        // Morph targets\n        if (parsedMesh.morphTargetManagerId > -1) {\n            mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);\n        }\n        // Skeleton\n        if (parsedMesh.skeletonId !== undefined && parsedMesh.skeletonId !== null) {\n            mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);\n            if (parsedMesh.numBoneInfluencers) {\n                mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;\n            }\n        }\n        // Animations\n        if (parsedMesh.animations) {\n            for (var animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\n                var parsedAnimation = parsedMesh.animations[animationIndex];\n                var internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    mesh.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n            Node.ParseAnimationRanges(mesh, parsedMesh, scene);\n        }\n        if (parsedMesh.autoAnimate) {\n            scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1.0);\n        }\n        // Layer Mask\n        if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {\n            mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));\n        }\n        else {\n            mesh.layerMask = 0x0fffffff;\n        }\n        // Physics\n        if (parsedMesh.physicsImpostor) {\n            Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);\n        }\n        // Levels\n        if (parsedMesh.lodMeshIds) {\n            mesh._waitingData.lods = {\n                ids: parsedMesh.lodMeshIds,\n                distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,\n                coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null\n            };\n        }\n        // Instances\n        if (parsedMesh.instances) {\n            for (var index = 0; index < parsedMesh.instances.length; index++) {\n                var parsedInstance = parsedMesh.instances[index];\n                var instance = mesh.createInstance(parsedInstance.name);\n                if (parsedInstance.id) {\n                    instance.id = parsedInstance.id;\n                }\n                if (Tags) {\n                    if (parsedInstance.tags) {\n                        Tags.AddTagsTo(instance, parsedInstance.tags);\n                    }\n                    else {\n                        Tags.AddTagsTo(instance, parsedMesh.tags);\n                    }\n                }\n                instance.position = Vector3.FromArray(parsedInstance.position);\n                if (parsedInstance.metadata !== undefined) {\n                    instance.metadata = parsedInstance.metadata;\n                }\n                if (parsedInstance.parentId !== undefined) {\n                    instance._waitingParentId = parsedInstance.parentId;\n                }\n                if (parsedInstance.isEnabled !== undefined && parsedInstance.isEnabled !== null) {\n                    instance.setEnabled(parsedInstance.isEnabled);\n                }\n                if (parsedInstance.isVisible !== undefined && parsedInstance.isVisible !== null) {\n                    instance.isVisible = parsedInstance.isVisible;\n                }\n                if (parsedInstance.isPickable !== undefined && parsedInstance.isPickable !== null) {\n                    instance.isPickable = parsedInstance.isPickable;\n                }\n                if (parsedInstance.rotationQuaternion) {\n                    instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);\n                }\n                else if (parsedInstance.rotation) {\n                    instance.rotation = Vector3.FromArray(parsedInstance.rotation);\n                }\n                instance.scaling = Vector3.FromArray(parsedInstance.scaling);\n                if (parsedInstance.checkCollisions != undefined && parsedInstance.checkCollisions != null) {\n                    instance.checkCollisions = parsedInstance.checkCollisions;\n                }\n                if (parsedInstance.pickable != undefined && parsedInstance.pickable != null) {\n                    instance.isPickable = parsedInstance.pickable;\n                }\n                if (parsedInstance.showBoundingBox != undefined && parsedInstance.showBoundingBox != null) {\n                    instance.showBoundingBox = parsedInstance.showBoundingBox;\n                }\n                if (parsedInstance.showSubMeshesBoundingBox != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n                    instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;\n                }\n                if (parsedInstance.alphaIndex != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n                    instance.alphaIndex = parsedInstance.alphaIndex;\n                }\n                // Physics\n                if (parsedInstance.physicsImpostor) {\n                    Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);\n                }\n                // Animation\n                if (parsedInstance.animations) {\n                    for (var animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {\n                        var parsedAnimation = parsedInstance.animations[animationIndex];\n                        var internalClass = GetClass(\"BABYLON.Animation\");\n                        if (internalClass) {\n                            instance.animations.push(internalClass.Parse(parsedAnimation));\n                        }\n                    }\n                    Node.ParseAnimationRanges(instance, parsedInstance, scene);\n                    if (parsedInstance.autoAnimate) {\n                        scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1.0);\n                    }\n                }\n            }\n        }\n        // Thin instances\n        if (parsedMesh.thinInstances) {\n            var thinInstances = parsedMesh.thinInstances;\n            mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;\n            if (thinInstances.matrixData) {\n                mesh.thinInstanceSetBuffer(\"matrix\", new Float32Array(thinInstances.matrixData), 16, false);\n                mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n                mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;\n            }\n            else {\n                mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n            }\n            if (parsedMesh.thinInstances.userThinInstance) {\n                var userThinInstance = parsedMesh.thinInstances.userThinInstance;\n                for (var kind in userThinInstance.data) {\n                    mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);\n                    mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];\n                }\n            }\n        }\n        return mesh;\n    };\n    // Skeletons\n    /**\n     * Prepare internal position array for software CPU skinning\n     * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh\n     */\n    Mesh.prototype.setPositionsForCPUSkinning = function () {\n        var internalDataInfo = this._internalMeshDataInfo;\n        if (!internalDataInfo._sourcePositions) {\n            var source = this.getVerticesData(VertexBuffer.PositionKind);\n            if (!source) {\n                return internalDataInfo._sourcePositions;\n            }\n            internalDataInfo._sourcePositions = new Float32Array(source);\n            if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n                this.setVerticesData(VertexBuffer.PositionKind, source, true);\n            }\n        }\n        return internalDataInfo._sourcePositions;\n    };\n    /**\n     * Prepare internal normal array for software CPU skinning\n     * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.\n     */\n    Mesh.prototype.setNormalsForCPUSkinning = function () {\n        var internalDataInfo = this._internalMeshDataInfo;\n        if (!internalDataInfo._sourceNormals) {\n            var source = this.getVerticesData(VertexBuffer.NormalKind);\n            if (!source) {\n                return internalDataInfo._sourceNormals;\n            }\n            internalDataInfo._sourceNormals = new Float32Array(source);\n            if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n                this.setVerticesData(VertexBuffer.NormalKind, source, true);\n            }\n        }\n        return internalDataInfo._sourceNormals;\n    };\n    /**\n     * Updates the vertex buffer by applying transformation from the bones\n     * @param skeleton defines the skeleton to apply to current mesh\n     * @returns the current mesh\n     */\n    Mesh.prototype.applySkeleton = function (skeleton) {\n        if (!this.geometry) {\n            return this;\n        }\n        if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {\n            return this;\n        }\n        this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();\n        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n            return this;\n        }\n        if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n            return this;\n        }\n        if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n            return this;\n        }\n        var hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);\n        var internalDataInfo = this._internalMeshDataInfo;\n        if (!internalDataInfo._sourcePositions) {\n            var submeshes = this.subMeshes.slice();\n            this.setPositionsForCPUSkinning();\n            this.subMeshes = submeshes;\n        }\n        if (hasNormals && !internalDataInfo._sourceNormals) {\n            this.setNormalsForCPUSkinning();\n        }\n        // positionsData checks for not being Float32Array will only pass at most once\n        var positionsData = this.getVerticesData(VertexBuffer.PositionKind);\n        if (!positionsData) {\n            return this;\n        }\n        if (!(positionsData instanceof Float32Array)) {\n            positionsData = new Float32Array(positionsData);\n        }\n        // normalsData checks for not being Float32Array will only pass at most once\n        var normalsData = this.getVerticesData(VertexBuffer.NormalKind);\n        if (hasNormals) {\n            if (!normalsData) {\n                return this;\n            }\n            if (!(normalsData instanceof Float32Array)) {\n                normalsData = new Float32Array(normalsData);\n            }\n        }\n        var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n        var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n        if (!matricesWeightsData || !matricesIndicesData) {\n            return this;\n        }\n        var needExtras = this.numBoneInfluencers > 4;\n        var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n        var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n        var skeletonMatrices = skeleton.getTransformMatrices(this);\n        var tempVector3 = Vector3.Zero();\n        var finalMatrix = new Matrix();\n        var tempMatrix = new Matrix();\n        var matWeightIdx = 0;\n        var inf;\n        for (var index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {\n            var weight = void 0;\n            for (inf = 0; inf < 4; inf++) {\n                weight = matricesWeightsData[matWeightIdx + inf];\n                if (weight > 0) {\n                    Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                    finalMatrix.addToSelf(tempMatrix);\n                }\n            }\n            if (needExtras) {\n                for (inf = 0; inf < 4; inf++) {\n                    weight = matricesWeightsExtraData[matWeightIdx + inf];\n                    if (weight > 0) {\n                        Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                        finalMatrix.addToSelf(tempMatrix);\n                    }\n                }\n            }\n            Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);\n            tempVector3.toArray(positionsData, index);\n            if (hasNormals) {\n                Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);\n                tempVector3.toArray(normalsData, index);\n            }\n            finalMatrix.reset();\n        }\n        this.updateVerticesData(VertexBuffer.PositionKind, positionsData);\n        if (hasNormals) {\n            this.updateVerticesData(VertexBuffer.NormalKind, normalsData);\n        }\n        return this;\n    };\n    // Tools\n    /**\n     * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates\n     * @param meshes defines the list of meshes to scan\n     * @returns an object `{min:` Vector3`, max:` Vector3`}`\n     */\n    Mesh.MinMax = function (meshes) {\n        var minVector = null;\n        var maxVector = null;\n        meshes.forEach(function (mesh) {\n            var boundingInfo = mesh.getBoundingInfo();\n            var boundingBox = boundingInfo.boundingBox;\n            if (!minVector || !maxVector) {\n                minVector = boundingBox.minimumWorld;\n                maxVector = boundingBox.maximumWorld;\n            }\n            else {\n                minVector.minimizeInPlace(boundingBox.minimumWorld);\n                maxVector.maximizeInPlace(boundingBox.maximumWorld);\n            }\n        });\n        if (!minVector || !maxVector) {\n            return {\n                min: Vector3.Zero(),\n                max: Vector3.Zero()\n            };\n        }\n        return {\n            min: minVector,\n            max: maxVector\n        };\n    };\n    /**\n     * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array\n     * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object\n     * @returns a vector3\n     */\n    Mesh.Center = function (meshesOrMinMaxVector) {\n        var minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;\n        return Vector3.Center(minMaxVector.min, minMaxVector.max);\n    };\n    /**\n     * Merge the array of meshes into a single mesh for performance reasons.\n     * @param meshes defines he vertices source.  They should all be of the same material.  Entries can empty\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true\n     * @param meshSubclass when set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh to his subMesh array with meshes source.\n     * @param multiMultiMaterials when true (false default), subdivide mesh and accept multiple multi materials, ignores subdivideWithSubMeshes.\n     * @returns a new mesh\n     */\n    Mesh.MergeMeshes = function (meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {\n        if (disposeSource === void 0) { disposeSource = true; }\n        return runCoroutineSync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));\n    };\n    /**\n     * Merge the array of meshes into a single mesh for performance reasons.\n     * @param meshes defines he vertices source.  They should all be of the same material.  Entries can empty\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true\n     * @param meshSubclass when set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh to his subMesh array with meshes source.\n     * @param multiMultiMaterials when true (false default), subdivide mesh and accept multiple multi materials, ignores subdivideWithSubMeshes.\n     * @returns a new mesh\n     */\n    Mesh.MergeMeshesAsync = function (meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {\n        if (disposeSource === void 0) { disposeSource = true; }\n        return runCoroutineAsync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());\n    };\n    Mesh._MergeMeshesCoroutine = function (meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, isAsync) {\n        var index, totalVertices, materialArray, materialIndexArray, indiceArray, currentOverrideMaterialSideOrientation, mesh, material, matIndex, subIndex, subIndex, subIndex, source, getVertexDataFromMesh, _a, sourceVertexData, sourceTransform, meshVertexDatas, i, mergeCoroutine, mergeCoroutineStep, vertexData, applyToCoroutine, applyToCoroutineStep, offset, _i, _b, subMesh, newMultiMaterial, subIndex;\n        if (disposeSource === void 0) { disposeSource = true; }\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    // Remove any null/undefined entries from the mesh array\n                    meshes = meshes.filter(Boolean);\n                    if (meshes.length === 0) {\n                        return [2 /*return*/, null];\n                    }\n                    if (!allow32BitsIndices) {\n                        totalVertices = 0;\n                        // Counting vertices\n                        for (index = 0; index < meshes.length; index++) {\n                            totalVertices += meshes[index].getTotalVertices();\n                            if (totalVertices >= 65536) {\n                                Logger.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\");\n                                return [2 /*return*/, null];\n                            }\n                        }\n                    }\n                    if (multiMultiMaterials) {\n                        subdivideWithSubMeshes = false;\n                    }\n                    materialArray = new Array();\n                    materialIndexArray = new Array();\n                    indiceArray = new Array();\n                    currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;\n                    for (index = 0; index < meshes.length; index++) {\n                        mesh = meshes[index];\n                        if (mesh.isAnInstance) {\n                            Logger.Warn(\"Cannot merge instance meshes.\");\n                            return [2 /*return*/, null];\n                        }\n                        if (currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation) {\n                            Logger.Warn(\"Cannot merge meshes with different overrideMaterialSideOrientation values.\");\n                            return [2 /*return*/, null];\n                        }\n                        if (subdivideWithSubMeshes) {\n                            indiceArray.push(mesh.getTotalIndices());\n                        }\n                        if (multiMultiMaterials) {\n                            if (mesh.material) {\n                                material = mesh.material;\n                                if (material instanceof MultiMaterial) {\n                                    for (matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {\n                                        if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {\n                                            materialArray.push(material.subMaterials[matIndex]);\n                                        }\n                                    }\n                                    for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                                        materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));\n                                        indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n                                    }\n                                }\n                                else {\n                                    if (materialArray.indexOf(material) < 0) {\n                                        materialArray.push(material);\n                                    }\n                                    for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                                        materialIndexArray.push(materialArray.indexOf(material));\n                                        indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n                                    }\n                                }\n                            }\n                            else {\n                                for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                                    materialIndexArray.push(0);\n                                    indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n                                }\n                            }\n                        }\n                    }\n                    source = meshes[0];\n                    getVertexDataFromMesh = function (mesh) {\n                        var wm = mesh.computeWorldMatrix(true);\n                        var vertexData = VertexData.ExtractFromMesh(mesh, false, false);\n                        return [vertexData, wm];\n                    };\n                    _a = getVertexDataFromMesh(source), sourceVertexData = _a[0], sourceTransform = _a[1];\n                    if (!isAsync) return [3 /*break*/, 2];\n                    return [4 /*yield*/];\n                case 1:\n                    _c.sent();\n                    _c.label = 2;\n                case 2:\n                    meshVertexDatas = new Array(meshes.length - 1);\n                    i = 1;\n                    _c.label = 3;\n                case 3:\n                    if (!(i < meshes.length)) return [3 /*break*/, 6];\n                    meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);\n                    if (!isAsync) return [3 /*break*/, 5];\n                    return [4 /*yield*/];\n                case 4:\n                    _c.sent();\n                    _c.label = 5;\n                case 5:\n                    i++;\n                    return [3 /*break*/, 3];\n                case 6:\n                    mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);\n                    mergeCoroutineStep = mergeCoroutine.next();\n                    _c.label = 7;\n                case 7:\n                    if (!!mergeCoroutineStep.done) return [3 /*break*/, 10];\n                    if (!isAsync) return [3 /*break*/, 9];\n                    return [4 /*yield*/];\n                case 8:\n                    _c.sent();\n                    _c.label = 9;\n                case 9:\n                    mergeCoroutineStep = mergeCoroutine.next();\n                    return [3 /*break*/, 7];\n                case 10:\n                    vertexData = mergeCoroutineStep.value;\n                    if (!meshSubclass) {\n                        meshSubclass = new Mesh(source.name + \"_merged\", source.getScene());\n                    }\n                    applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, undefined, isAsync);\n                    applyToCoroutineStep = applyToCoroutine.next();\n                    _c.label = 11;\n                case 11:\n                    if (!!applyToCoroutineStep.done) return [3 /*break*/, 14];\n                    if (!isAsync) return [3 /*break*/, 13];\n                    return [4 /*yield*/];\n                case 12:\n                    _c.sent();\n                    _c.label = 13;\n                case 13:\n                    applyToCoroutineStep = applyToCoroutine.next();\n                    return [3 /*break*/, 11];\n                case 14:\n                    // Setting properties\n                    meshSubclass.checkCollisions = source.checkCollisions;\n                    meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;\n                    // Cleaning\n                    if (disposeSource) {\n                        for (index = 0; index < meshes.length; index++) {\n                            meshes[index].dispose();\n                        }\n                    }\n                    // Subdivide\n                    if (subdivideWithSubMeshes || multiMultiMaterials) {\n                        //-- removal of global submesh\n                        meshSubclass.releaseSubMeshes();\n                        index = 0;\n                        offset = 0;\n                        //-- apply subdivision according to index table\n                        while (index < indiceArray.length) {\n                            SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, undefined, false);\n                            offset += indiceArray[index];\n                            index++;\n                        }\n                        for (_i = 0, _b = meshSubclass.subMeshes; _i < _b.length; _i++) {\n                            subMesh = _b[_i];\n                            subMesh.refreshBoundingInfo();\n                        }\n                        meshSubclass.computeWorldMatrix(true);\n                    }\n                    if (multiMultiMaterials) {\n                        newMultiMaterial = new MultiMaterial(source.name + \"_merged\", source.getScene());\n                        newMultiMaterial.subMaterials = materialArray;\n                        for (subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {\n                            meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];\n                        }\n                        meshSubclass.material = newMultiMaterial;\n                    }\n                    else {\n                        meshSubclass.material = source.material;\n                    }\n                    return [2 /*return*/, meshSubclass];\n            }\n        });\n    };\n    /**\n     * @param instance\n     * @hidden\n     */\n    Mesh.prototype.addInstance = function (instance) {\n        instance._indexInSourceMeshInstanceArray = this.instances.length;\n        this.instances.push(instance);\n    };\n    /**\n     * @param instance\n     * @hidden\n     */\n    Mesh.prototype.removeInstance = function (instance) {\n        // Remove from mesh\n        var index = instance._indexInSourceMeshInstanceArray;\n        if (index != -1) {\n            if (index !== this.instances.length - 1) {\n                var last = this.instances[this.instances.length - 1];\n                this.instances[index] = last;\n                last._indexInSourceMeshInstanceArray = index;\n            }\n            instance._indexInSourceMeshInstanceArray = -1;\n            this.instances.pop();\n        }\n    };\n    /** @hidden */\n    Mesh.prototype._shouldConvertRHS = function () {\n        return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;\n    };\n    // Consts\n    /**\n     * Mesh side orientation : usually the external or front surface\n     */\n    Mesh.FRONTSIDE = VertexData.FRONTSIDE;\n    /**\n     * Mesh side orientation : usually the internal or back surface\n     */\n    Mesh.BACKSIDE = VertexData.BACKSIDE;\n    /**\n     * Mesh side orientation : both internal and external or front and back surfaces\n     */\n    Mesh.DOUBLESIDE = VertexData.DOUBLESIDE;\n    /**\n     * Mesh side orientation : by default, `FRONTSIDE`\n     */\n    Mesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;\n    /**\n     * Mesh cap setting : no cap\n     */\n    Mesh.NO_CAP = 0;\n    /**\n     * Mesh cap setting : one cap at the beginning of the mesh\n     */\n    Mesh.CAP_START = 1;\n    /**\n     * Mesh cap setting : one cap at the end of the mesh\n     */\n    Mesh.CAP_END = 2;\n    /**\n     * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh\n     */\n    Mesh.CAP_ALL = 3;\n    /**\n     * Mesh pattern setting : no flip or rotate\n     */\n    Mesh.NO_FLIP = 0;\n    /**\n     * Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column\n     */\n    Mesh.FLIP_TILE = 1;\n    /**\n     * Mesh pattern setting : rotate (180degs) alternate tiles on each row or column\n     */\n    Mesh.ROTATE_TILE = 2;\n    /**\n     * Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows\n     */\n    Mesh.FLIP_ROW = 3;\n    /**\n     * Mesh pattern setting : rotate (180degs) all tiles on alternate rows\n     */\n    Mesh.ROTATE_ROW = 4;\n    /**\n     * Mesh pattern setting : flip and rotate alternate tiles on each row or column\n     */\n    Mesh.FLIP_N_ROTATE_TILE = 5;\n    /**\n     * Mesh pattern setting : rotate pattern and rotate\n     */\n    Mesh.FLIP_N_ROTATE_ROW = 6;\n    /**\n     * Mesh tile positioning : part tiles same on left/right or top/bottom\n     */\n    Mesh.CENTER = 0;\n    /**\n     * Mesh tile positioning : part tiles on left\n     */\n    Mesh.LEFT = 1;\n    /**\n     * Mesh tile positioning : part tiles on right\n     */\n    Mesh.RIGHT = 2;\n    /**\n     * Mesh tile positioning : part tiles on top\n     */\n    Mesh.TOP = 3;\n    /**\n     * Mesh tile positioning : part tiles on bottom\n     */\n    Mesh.BOTTOM = 4;\n    /**\n     * Indicates that the instanced meshes should be sorted from back to front before rendering if their material is transparent\n     */\n    Mesh.INSTANCEDMESH_SORT_TRANSPARENT = false;\n    // Statics\n    /**\n     * @param parsedMesh\n     * @param scene\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Mesh._GroundMeshParser = function (parsedMesh, scene) {\n        throw _WarnImport(\"GroundMesh\");\n    };\n    /**\n     * @param parsedMesh\n     * @param scene\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Mesh._GoldbergMeshParser = function (parsedMesh, scene) {\n        throw _WarnImport(\"GoldbergMesh\");\n    };\n    /**\n     * @param parsedMesh\n     * @param scene\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    Mesh._LinesMeshParser = function (parsedMesh, scene) {\n        throw _WarnImport(\"LinesMesh\");\n    };\n    return Mesh;\n}(AbstractMesh));\nexport { Mesh };\nRegisterClass(\"BABYLON.Mesh\", Mesh);\n/**\n * @param id\n * @hidden\n */\nMesh.prototype.setMaterialByID = function (id) {\n    return this.setMaterialById(id);\n};\nMesh.CreateDisc =\n    Mesh.CreateDisc ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateBox =\n    Mesh.CreateBox ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateSphere =\n    Mesh.CreateSphere ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateCylinder =\n    Mesh.CreateCylinder ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateTorusKnot =\n    Mesh.CreateTorusKnot ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateTorus =\n    Mesh.CreateTorus ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreatePlane =\n    Mesh.CreatePlane ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateGround =\n    Mesh.CreateGround ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateTiledGround =\n    Mesh.CreateTiledGround ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateGroundFromHeightMap =\n    Mesh.CreateGroundFromHeightMap ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateTube =\n    Mesh.CreateTube ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreatePolyhedron =\n    Mesh.CreatePolyhedron ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateIcoSphere =\n    Mesh.CreateIcoSphere ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateDecal =\n    Mesh.CreateDecal ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.CreateCapsule =\n    Mesh.CreateCapsule ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\nMesh.ExtendToGoldberg =\n    Mesh.ExtendToGoldberg ||\n        (function () {\n            throw new Error(\"Import MeshBuilder to populate this function\");\n        });\n//# sourceMappingURL=mesh.js.map","import { __decorate, __generator } from \"tslib\";\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\n/**\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\n */\nvar VertexData = /** @class */ (function () {\n    function VertexData() {\n        this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\n    }\n    /**\n     * Uses the passed data array to set the set the values for the specified kind of data\n     * @param data a linear array of floating numbers\n     * @param kind the type of data that is being set, eg positions, colors etc\n     */\n    VertexData.prototype.set = function (data, kind) {\n        if (!data.length) {\n            Logger.Warn(\"Setting vertex data kind '\".concat(kind, \"' with an empty array\"));\n        }\n        switch (kind) {\n            case VertexBuffer.PositionKind:\n                this.positions = data;\n                break;\n            case VertexBuffer.NormalKind:\n                this.normals = data;\n                break;\n            case VertexBuffer.TangentKind:\n                this.tangents = data;\n                break;\n            case VertexBuffer.UVKind:\n                this.uvs = data;\n                break;\n            case VertexBuffer.UV2Kind:\n                this.uvs2 = data;\n                break;\n            case VertexBuffer.UV3Kind:\n                this.uvs3 = data;\n                break;\n            case VertexBuffer.UV4Kind:\n                this.uvs4 = data;\n                break;\n            case VertexBuffer.UV5Kind:\n                this.uvs5 = data;\n                break;\n            case VertexBuffer.UV6Kind:\n                this.uvs6 = data;\n                break;\n            case VertexBuffer.ColorKind:\n                this.colors = data;\n                break;\n            case VertexBuffer.MatricesIndicesKind:\n                this.matricesIndices = data;\n                break;\n            case VertexBuffer.MatricesWeightsKind:\n                this.matricesWeights = data;\n                break;\n            case VertexBuffer.MatricesIndicesExtraKind:\n                this.matricesIndicesExtra = data;\n                break;\n            case VertexBuffer.MatricesWeightsExtraKind:\n                this.matricesWeightsExtra = data;\n                break;\n        }\n    };\n    /**\n     * Associates the vertexData to the passed Mesh.\n     * Sets it as updatable or not (default `false`)\n     * @param mesh the mesh the vertexData is applied to\n     * @param updatable when used and having the value true allows new data to update the vertexData\n     * @returns the VertexData\n     */\n    VertexData.prototype.applyToMesh = function (mesh, updatable) {\n        this._applyTo(mesh, updatable, false);\n        return this;\n    };\n    /**\n     * Associates the vertexData to the passed Geometry.\n     * Sets it as updatable or not (default `false`)\n     * @param geometry the geometry the vertexData is applied to\n     * @param updatable when used and having the value true allows new data to update the vertexData\n     * @returns VertexData\n     */\n    VertexData.prototype.applyToGeometry = function (geometry, updatable) {\n        this._applyTo(geometry, updatable, false);\n        return this;\n    };\n    /**\n     * Updates the associated mesh\n     * @param mesh the mesh to be updated\n     * @returns VertexData\n     */\n    VertexData.prototype.updateMesh = function (mesh) {\n        this._update(mesh);\n        return this;\n    };\n    /**\n     * Updates the associated geometry\n     * @param geometry the geometry to be updated\n     * @returns VertexData.\n     */\n    VertexData.prototype.updateGeometry = function (geometry) {\n        this._update(geometry);\n        return this;\n    };\n    /**\n     * @param meshOrGeometry\n     * @param updatable\n     * @param isAsync\n     * @hidden\n     */\n    VertexData.prototype._applyToCoroutine = function (meshOrGeometry, updatable, isAsync) {\n        if (updatable === void 0) { updatable = false; }\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!this.positions) return [3 /*break*/, 2];\n                    meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\n                    if (!isAsync) return [3 /*break*/, 2];\n                    return [4 /*yield*/];\n                case 1:\n                    _a.sent();\n                    _a.label = 2;\n                case 2:\n                    if (!this.normals) return [3 /*break*/, 4];\n                    meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\n                    if (!isAsync) return [3 /*break*/, 4];\n                    return [4 /*yield*/];\n                case 3:\n                    _a.sent();\n                    _a.label = 4;\n                case 4:\n                    if (!this.tangents) return [3 /*break*/, 6];\n                    meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\n                    if (!isAsync) return [3 /*break*/, 6];\n                    return [4 /*yield*/];\n                case 5:\n                    _a.sent();\n                    _a.label = 6;\n                case 6:\n                    if (!this.uvs) return [3 /*break*/, 8];\n                    meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\n                    if (!isAsync) return [3 /*break*/, 8];\n                    return [4 /*yield*/];\n                case 7:\n                    _a.sent();\n                    _a.label = 8;\n                case 8:\n                    if (!this.uvs2) return [3 /*break*/, 10];\n                    meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\n                    if (!isAsync) return [3 /*break*/, 10];\n                    return [4 /*yield*/];\n                case 9:\n                    _a.sent();\n                    _a.label = 10;\n                case 10:\n                    if (!this.uvs3) return [3 /*break*/, 12];\n                    meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\n                    if (!isAsync) return [3 /*break*/, 12];\n                    return [4 /*yield*/];\n                case 11:\n                    _a.sent();\n                    _a.label = 12;\n                case 12:\n                    if (!this.uvs4) return [3 /*break*/, 14];\n                    meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\n                    if (!isAsync) return [3 /*break*/, 14];\n                    return [4 /*yield*/];\n                case 13:\n                    _a.sent();\n                    _a.label = 14;\n                case 14:\n                    if (!this.uvs5) return [3 /*break*/, 16];\n                    meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\n                    if (!isAsync) return [3 /*break*/, 16];\n                    return [4 /*yield*/];\n                case 15:\n                    _a.sent();\n                    _a.label = 16;\n                case 16:\n                    if (!this.uvs6) return [3 /*break*/, 18];\n                    meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\n                    if (!isAsync) return [3 /*break*/, 18];\n                    return [4 /*yield*/];\n                case 17:\n                    _a.sent();\n                    _a.label = 18;\n                case 18:\n                    if (!this.colors) return [3 /*break*/, 20];\n                    meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\n                    if (!isAsync) return [3 /*break*/, 20];\n                    return [4 /*yield*/];\n                case 19:\n                    _a.sent();\n                    _a.label = 20;\n                case 20:\n                    if (!this.matricesIndices) return [3 /*break*/, 22];\n                    meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\n                    if (!isAsync) return [3 /*break*/, 22];\n                    return [4 /*yield*/];\n                case 21:\n                    _a.sent();\n                    _a.label = 22;\n                case 22:\n                    if (!this.matricesWeights) return [3 /*break*/, 24];\n                    meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\n                    if (!isAsync) return [3 /*break*/, 24];\n                    return [4 /*yield*/];\n                case 23:\n                    _a.sent();\n                    _a.label = 24;\n                case 24:\n                    if (!this.matricesIndicesExtra) return [3 /*break*/, 26];\n                    meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\n                    if (!isAsync) return [3 /*break*/, 26];\n                    return [4 /*yield*/];\n                case 25:\n                    _a.sent();\n                    _a.label = 26;\n                case 26:\n                    if (!this.matricesWeightsExtra) return [3 /*break*/, 28];\n                    meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\n                    if (!isAsync) return [3 /*break*/, 28];\n                    return [4 /*yield*/];\n                case 27:\n                    _a.sent();\n                    _a.label = 28;\n                case 28:\n                    if (!this.indices) return [3 /*break*/, 31];\n                    meshOrGeometry.setIndices(this.indices, null, updatable);\n                    if (!isAsync) return [3 /*break*/, 30];\n                    return [4 /*yield*/];\n                case 29:\n                    _a.sent();\n                    _a.label = 30;\n                case 30: return [3 /*break*/, 32];\n                case 31:\n                    meshOrGeometry.setIndices([], null);\n                    _a.label = 32;\n                case 32: return [2 /*return*/, this];\n            }\n        });\n    };\n    VertexData.prototype._update = function (meshOrGeometry, updateExtends, makeItUnique) {\n        if (this.positions) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\n        }\n        if (this.normals) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\n        }\n        if (this.tangents) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\n        }\n        if (this.uvs) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\n        }\n        if (this.uvs2) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\n        }\n        if (this.uvs3) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\n        }\n        if (this.uvs4) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\n        }\n        if (this.uvs5) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\n        }\n        if (this.uvs6) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\n        }\n        if (this.colors) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\n        }\n        if (this.matricesIndices) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\n        }\n        if (this.matricesWeights) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\n        }\n        if (this.matricesIndicesExtra) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\n        }\n        if (this.matricesWeightsExtra) {\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\n        }\n        if (this.indices) {\n            meshOrGeometry.setIndices(this.indices, null);\n        }\n        return this;\n    };\n    VertexData._TransformVector3Coordinates = function (coordinates, transformation, offset, length) {\n        if (offset === void 0) { offset = 0; }\n        if (length === void 0) { length = coordinates.length; }\n        var coordinate = TmpVectors.Vector3[0];\n        var transformedCoordinate = TmpVectors.Vector3[1];\n        for (var index = offset; index < offset + length; index += 3) {\n            Vector3.FromArrayToRef(coordinates, index, coordinate);\n            Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\n            coordinates[index] = transformedCoordinate.x;\n            coordinates[index + 1] = transformedCoordinate.y;\n            coordinates[index + 2] = transformedCoordinate.z;\n        }\n    };\n    VertexData._TransformVector3Normals = function (normals, transformation, offset, length) {\n        if (offset === void 0) { offset = 0; }\n        if (length === void 0) { length = normals.length; }\n        var normal = TmpVectors.Vector3[0];\n        var transformedNormal = TmpVectors.Vector3[1];\n        for (var index = offset; index < offset + length; index += 3) {\n            Vector3.FromArrayToRef(normals, index, normal);\n            Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\n            normals[index] = transformedNormal.x;\n            normals[index + 1] = transformedNormal.y;\n            normals[index + 2] = transformedNormal.z;\n        }\n    };\n    VertexData._TransformVector4Normals = function (normals, transformation, offset, length) {\n        if (offset === void 0) { offset = 0; }\n        if (length === void 0) { length = normals.length; }\n        var normal = TmpVectors.Vector4[0];\n        var transformedNormal = TmpVectors.Vector4[1];\n        for (var index = offset; index < offset + length; index += 4) {\n            Vector4.FromArrayToRef(normals, index, normal);\n            Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\n            normals[index] = transformedNormal.x;\n            normals[index + 1] = transformedNormal.y;\n            normals[index + 2] = transformedNormal.z;\n            normals[index + 3] = transformedNormal.w;\n        }\n    };\n    VertexData._FlipFaces = function (indices, offset, length) {\n        if (offset === void 0) { offset = 0; }\n        if (length === void 0) { length = indices.length; }\n        for (var index = offset; index < offset + length; index += 3) {\n            var tmp = indices[index + 1];\n            indices[index + 1] = indices[index + 2];\n            indices[index + 2] = tmp;\n        }\n    };\n    /**\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\n     * @param matrix the transforming matrix\n     * @returns the VertexData\n     */\n    VertexData.prototype.transform = function (matrix) {\n        var flip = matrix.determinant() < 0;\n        if (this.positions) {\n            VertexData._TransformVector3Coordinates(this.positions, matrix);\n        }\n        if (this.normals) {\n            VertexData._TransformVector3Normals(this.normals, matrix);\n        }\n        if (this.tangents) {\n            VertexData._TransformVector4Normals(this.tangents, matrix);\n        }\n        if (flip && this.indices) {\n            VertexData._FlipFaces(this.indices);\n        }\n        return this;\n    };\n    /**\n     * Merges the passed VertexData into the current one\n     * @param others the VertexData to be merged into the current one\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\n     * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\n     * @returns the modified VertexData\n     */\n    VertexData.prototype.merge = function (others, use32BitsIndices, forceCloneIndices) {\n        if (use32BitsIndices === void 0) { use32BitsIndices = false; }\n        if (forceCloneIndices === void 0) { forceCloneIndices = false; }\n        var vertexDatas = Array.isArray(others) ? others.map(function (other) { return [other, undefined]; }) : [[others, undefined]];\n        return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices));\n    };\n    /**\n     * @param transform\n     * @param vertexDatas\n     * @param use32BitsIndices\n     * @param isAsync\n     * @param forceCloneIndices\n     * @hidden\n     */\n    VertexData.prototype._mergeCoroutine = function (transform, vertexDatas, use32BitsIndices, isAsync, forceCloneIndices) {\n        var others, _i, others_1, other, totalIndices, sliceIndices, indices, indicesOffset, temp, positionsOffset, _a, vertexDatas_1, _b, other, transform_1, index;\n        var _this = this;\n        var _c, _d, _e, _f;\n        if (use32BitsIndices === void 0) { use32BitsIndices = false; }\n        return __generator(this, function (_g) {\n            switch (_g.label) {\n                case 0:\n                    this._validate();\n                    others = vertexDatas.map(function (vertexData) { return vertexData[0]; });\n                    for (_i = 0, others_1 = others; _i < others_1.length; _i++) {\n                        other = others_1[_i];\n                        other._validate();\n                        if (!this.normals !== !other.normals ||\n                            !this.tangents !== !other.tangents ||\n                            !this.uvs !== !other.uvs ||\n                            !this.uvs2 !== !other.uvs2 ||\n                            !this.uvs3 !== !other.uvs3 ||\n                            !this.uvs4 !== !other.uvs4 ||\n                            !this.uvs5 !== !other.uvs5 ||\n                            !this.uvs6 !== !other.uvs6 ||\n                            !this.colors !== !other.colors ||\n                            !this.matricesIndices !== !other.matricesIndices ||\n                            !this.matricesWeights !== !other.matricesWeights ||\n                            !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\n                            !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\n                            throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\n                        }\n                    }\n                    totalIndices = others.reduce(function (indexSum, vertexData) { var _a, _b; return indexSum + ((_b = (_a = vertexData.indices) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); }, (_d = (_c = this.indices) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0);\n                    sliceIndices = forceCloneIndices || others.some(function (vertexData) { return vertexData.indices === _this.indices; });\n                    indices = sliceIndices ? (_e = this.indices) === null || _e === void 0 ? void 0 : _e.slice() : this.indices;\n                    if (!(totalIndices > 0)) return [3 /*break*/, 4];\n                    indicesOffset = (_f = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _f !== void 0 ? _f : 0;\n                    if (!indices) {\n                        indices = new Array(totalIndices);\n                    }\n                    if (indices.length !== totalIndices) {\n                        if (Array.isArray(indices)) {\n                            indices.length = totalIndices;\n                        }\n                        else {\n                            temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\n                            temp.set(indices);\n                            indices = temp;\n                        }\n                        if (transform && transform.determinant() < 0) {\n                            VertexData._FlipFaces(indices, 0, indicesOffset);\n                        }\n                    }\n                    positionsOffset = this.positions ? this.positions.length / 3 : 0;\n                    _a = 0, vertexDatas_1 = vertexDatas;\n                    _g.label = 1;\n                case 1:\n                    if (!(_a < vertexDatas_1.length)) return [3 /*break*/, 4];\n                    _b = vertexDatas_1[_a], other = _b[0], transform_1 = _b[1];\n                    if (!other.indices) return [3 /*break*/, 3];\n                    for (index = 0; index < other.indices.length; index++) {\n                        indices[indicesOffset + index] = other.indices[index] + positionsOffset;\n                    }\n                    if (transform_1 && transform_1.determinant() < 0) {\n                        VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\n                    }\n                    // The call to _validate already checked for positions\n                    positionsOffset += other.positions.length / 3;\n                    indicesOffset += other.indices.length;\n                    if (!isAsync) return [3 /*break*/, 3];\n                    return [4 /*yield*/];\n                case 2:\n                    _g.sent();\n                    _g.label = 3;\n                case 3:\n                    _a++;\n                    return [3 /*break*/, 1];\n                case 4:\n                    this.indices = indices;\n                    this.positions = VertexData._MergeElement(VertexBuffer.PositionKind, this.positions, transform, vertexDatas.map(function (other) { return [other[0].positions, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 6];\n                    return [4 /*yield*/];\n                case 5:\n                    _g.sent();\n                    _g.label = 6;\n                case 6:\n                    this.normals = VertexData._MergeElement(VertexBuffer.NormalKind, this.normals, transform, vertexDatas.map(function (other) { return [other[0].normals, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 8];\n                    return [4 /*yield*/];\n                case 7:\n                    _g.sent();\n                    _g.label = 8;\n                case 8:\n                    this.tangents = VertexData._MergeElement(VertexBuffer.TangentKind, this.tangents, transform, vertexDatas.map(function (other) { return [other[0].tangents, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 10];\n                    return [4 /*yield*/];\n                case 9:\n                    _g.sent();\n                    _g.label = 10;\n                case 10:\n                    this.uvs = VertexData._MergeElement(VertexBuffer.UVKind, this.uvs, transform, vertexDatas.map(function (other) { return [other[0].uvs, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 12];\n                    return [4 /*yield*/];\n                case 11:\n                    _g.sent();\n                    _g.label = 12;\n                case 12:\n                    this.uvs2 = VertexData._MergeElement(VertexBuffer.UV2Kind, this.uvs2, transform, vertexDatas.map(function (other) { return [other[0].uvs2, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 14];\n                    return [4 /*yield*/];\n                case 13:\n                    _g.sent();\n                    _g.label = 14;\n                case 14:\n                    this.uvs3 = VertexData._MergeElement(VertexBuffer.UV3Kind, this.uvs3, transform, vertexDatas.map(function (other) { return [other[0].uvs3, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 16];\n                    return [4 /*yield*/];\n                case 15:\n                    _g.sent();\n                    _g.label = 16;\n                case 16:\n                    this.uvs4 = VertexData._MergeElement(VertexBuffer.UV4Kind, this.uvs4, transform, vertexDatas.map(function (other) { return [other[0].uvs4, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 18];\n                    return [4 /*yield*/];\n                case 17:\n                    _g.sent();\n                    _g.label = 18;\n                case 18:\n                    this.uvs5 = VertexData._MergeElement(VertexBuffer.UV5Kind, this.uvs5, transform, vertexDatas.map(function (other) { return [other[0].uvs5, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 20];\n                    return [4 /*yield*/];\n                case 19:\n                    _g.sent();\n                    _g.label = 20;\n                case 20:\n                    this.uvs6 = VertexData._MergeElement(VertexBuffer.UV6Kind, this.uvs6, transform, vertexDatas.map(function (other) { return [other[0].uvs6, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 22];\n                    return [4 /*yield*/];\n                case 21:\n                    _g.sent();\n                    _g.label = 22;\n                case 22:\n                    this.colors = VertexData._MergeElement(VertexBuffer.ColorKind, this.colors, transform, vertexDatas.map(function (other) { return [other[0].colors, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 24];\n                    return [4 /*yield*/];\n                case 23:\n                    _g.sent();\n                    _g.label = 24;\n                case 24:\n                    this.matricesIndices = VertexData._MergeElement(VertexBuffer.MatricesIndicesKind, this.matricesIndices, transform, vertexDatas.map(function (other) { return [other[0].matricesIndices, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 26];\n                    return [4 /*yield*/];\n                case 25:\n                    _g.sent();\n                    _g.label = 26;\n                case 26:\n                    this.matricesWeights = VertexData._MergeElement(VertexBuffer.MatricesWeightsKind, this.matricesWeights, transform, vertexDatas.map(function (other) { return [other[0].matricesWeights, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 28];\n                    return [4 /*yield*/];\n                case 27:\n                    _g.sent();\n                    _g.label = 28;\n                case 28:\n                    this.matricesIndicesExtra = VertexData._MergeElement(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, transform, vertexDatas.map(function (other) { return [other[0].matricesIndicesExtra, other[1]]; }));\n                    if (!isAsync) return [3 /*break*/, 30];\n                    return [4 /*yield*/];\n                case 29:\n                    _g.sent();\n                    _g.label = 30;\n                case 30:\n                    this.matricesWeightsExtra = VertexData._MergeElement(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, transform, vertexDatas.map(function (other) { return [other[0].matricesWeightsExtra, other[1]]; }));\n                    return [2 /*return*/, this];\n            }\n        });\n    };\n    VertexData._MergeElement = function (kind, source, transform, others) {\n        var nonNullOthers = others.filter(function (other) { return other[0] !== null && other[0] !== undefined; });\n        // If there is no source to copy and no other non-null sources then skip this element.\n        if (!source && nonNullOthers.length == 0) {\n            return source;\n        }\n        if (!source) {\n            return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\n        }\n        var len = nonNullOthers.reduce(function (sumLen, elements) { return sumLen + elements[0].length; }, source.length);\n        var transformRange = kind === VertexBuffer.PositionKind\n            ? VertexData._TransformVector3Coordinates\n            : kind === VertexBuffer.NormalKind\n                ? VertexData._TransformVector3Normals\n                : kind === VertexBuffer.TangentKind\n                    ? VertexData._TransformVector4Normals\n                    : function () { };\n        if (source instanceof Float32Array) {\n            // use non-loop method when the source is Float32Array\n            var ret32 = new Float32Array(len);\n            ret32.set(source);\n            transform && transformRange(ret32, transform, 0, source.length);\n            var offset = source.length;\n            for (var _i = 0, nonNullOthers_1 = nonNullOthers; _i < nonNullOthers_1.length; _i++) {\n                var _a = nonNullOthers_1[_i], vertexData = _a[0], transform_2 = _a[1];\n                ret32.set(vertexData, offset);\n                transform_2 && transformRange(ret32, transform_2, offset, vertexData.length);\n                offset += vertexData.length;\n            }\n            return ret32;\n        }\n        else {\n            // don't use concat as it is super slow, just loop for other cases\n            var ret = new Array(len);\n            for (var i = 0; i < source.length; i++) {\n                ret[i] = source[i];\n            }\n            transform && transformRange(ret, transform, 0, source.length);\n            var offset = source.length;\n            for (var _b = 0, nonNullOthers_2 = nonNullOthers; _b < nonNullOthers_2.length; _b++) {\n                var _c = nonNullOthers_2[_b], vertexData = _c[0], transform_3 = _c[1];\n                for (var i = 0; i < vertexData.length; i++) {\n                    ret[offset + i] = vertexData[i];\n                }\n                transform_3 && transformRange(ret, transform_3, offset, vertexData.length);\n                offset += vertexData.length;\n            }\n            return ret;\n        }\n    };\n    VertexData.prototype._validate = function () {\n        if (!this.positions) {\n            throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\n        }\n        var getElementCount = function (kind, values) {\n            var stride = VertexBuffer.DeduceStride(kind);\n            if (values.length % stride !== 0) {\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\n            }\n            return values.length / stride;\n        };\n        var positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\n        var validateElementCount = function (kind, values) {\n            var elementCount = getElementCount(kind, values);\n            if (elementCount !== positionsElementCount) {\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\n            }\n        };\n        if (this.normals) {\n            validateElementCount(VertexBuffer.NormalKind, this.normals);\n        }\n        if (this.tangents) {\n            validateElementCount(VertexBuffer.TangentKind, this.tangents);\n        }\n        if (this.uvs) {\n            validateElementCount(VertexBuffer.UVKind, this.uvs);\n        }\n        if (this.uvs2) {\n            validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\n        }\n        if (this.uvs3) {\n            validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\n        }\n        if (this.uvs4) {\n            validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\n        }\n        if (this.uvs5) {\n            validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\n        }\n        if (this.uvs6) {\n            validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\n        }\n        if (this.colors) {\n            validateElementCount(VertexBuffer.ColorKind, this.colors);\n        }\n        if (this.matricesIndices) {\n            validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\n        }\n        if (this.matricesWeights) {\n            validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\n        }\n        if (this.matricesIndicesExtra) {\n            validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\n        }\n        if (this.matricesWeightsExtra) {\n            validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\n        }\n    };\n    /**\n     * Serializes the VertexData\n     * @returns a serialized object\n     */\n    VertexData.prototype.serialize = function () {\n        var serializationObject = {};\n        if (this.positions) {\n            serializationObject.positions = this.positions;\n        }\n        if (this.normals) {\n            serializationObject.normals = this.normals;\n        }\n        if (this.tangents) {\n            serializationObject.tangents = this.tangents;\n        }\n        if (this.uvs) {\n            serializationObject.uvs = this.uvs;\n        }\n        if (this.uvs2) {\n            serializationObject.uvs2 = this.uvs2;\n        }\n        if (this.uvs3) {\n            serializationObject.uvs3 = this.uvs3;\n        }\n        if (this.uvs4) {\n            serializationObject.uvs4 = this.uvs4;\n        }\n        if (this.uvs5) {\n            serializationObject.uvs5 = this.uvs5;\n        }\n        if (this.uvs6) {\n            serializationObject.uvs6 = this.uvs6;\n        }\n        if (this.colors) {\n            serializationObject.colors = this.colors;\n        }\n        if (this.matricesIndices) {\n            serializationObject.matricesIndices = this.matricesIndices;\n            serializationObject.matricesIndices._isExpanded = true;\n        }\n        if (this.matricesWeights) {\n            serializationObject.matricesWeights = this.matricesWeights;\n        }\n        if (this.matricesIndicesExtra) {\n            serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\n            serializationObject.matricesIndicesExtra._isExpanded = true;\n        }\n        if (this.matricesWeightsExtra) {\n            serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\n        }\n        serializationObject.indices = this.indices;\n        return serializationObject;\n    };\n    // Statics\n    /**\n     * Extracts the vertexData from a mesh\n     * @param mesh the mesh from which to extract the VertexData\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n     * @returns the object VertexData associated to the passed mesh\n     */\n    VertexData.ExtractFromMesh = function (mesh, copyWhenShared, forceCopy) {\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\n    };\n    /**\n     * Extracts the vertexData from the geometry\n     * @param geometry the geometry from which to extract the VertexData\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n     * @returns the object VertexData associated to the passed mesh\n     */\n    VertexData.ExtractFromGeometry = function (geometry, copyWhenShared, forceCopy) {\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\n    };\n    VertexData._ExtractFrom = function (meshOrGeometry, copyWhenShared, forceCopy) {\n        var result = new VertexData();\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n            result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\n        }\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\n        }\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\n        return result;\n    };\n    /**\n     * Creates the VertexData for a Ribbon\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\n     * * pathArray array of paths, each of which an array of successive Vector3\n     * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\n     * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\n     * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\n     * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\n     * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\n     * @param options.pathArray\n     * @param options.closeArray\n     * @param options.closePath\n     * @param options.offset\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @param options.invertUV\n     * @param options.uvs\n     * @param options.colors\n     * @returns the VertexData of the ribbon\n     * @deprecated use CreateRibbonVertexData instead\n     */\n    VertexData.CreateRibbon = function (options) {\n        throw _WarnImport(\"ribbonBuilder\");\n    };\n    /**\n     * Creates the VertexData for a box\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\n     * * size sets the width, height and depth of the box to the value of size, optional default 1\n     * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n     * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n     * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.size\n     * @param options.width\n     * @param options.height\n     * @param options.depth\n     * @param options.faceUV\n     * @param options.faceColors\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the box\n     * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\n     */\n    VertexData.CreateBox = function (options) {\n        throw _WarnImport(\"boxBuilder\");\n    };\n    /**\n     * Creates the VertexData for a tiled box\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\n     * * faceTiles sets the pattern, tile size and number of tiles for a face\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * @param options.pattern\n     * @param options.width\n     * @param options.height\n     * @param options.depth\n     * @param options.tileSize\n     * @param options.tileWidth\n     * @param options.tileHeight\n     * @param options.alignHorizontal\n     * @param options.alignVertical\n     * @param options.faceUV\n     * @param options.faceColors\n     * @param options.sideOrientation\n     * @returns the VertexData of the box\n     * @deprecated Please use CreateTiledBoxVertexData instead\n     */\n    VertexData.CreateTiledBox = function (options) {\n        throw _WarnImport(\"tiledBoxBuilder\");\n    };\n    /**\n     * Creates the VertexData for a tiled plane\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\n     * * pattern a limited pattern arrangement depending on the number\n     * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n     * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n     * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.pattern\n     * @param options.tileSize\n     * @param options.tileWidth\n     * @param options.tileHeight\n     * @param options.size\n     * @param options.width\n     * @param options.height\n     * @param options.alignHorizontal\n     * @param options.alignVertical\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the tiled plane\n     * @deprecated use CreateTiledPlaneVertexData instead\n     */\n    VertexData.CreateTiledPlane = function (options) {\n        throw _WarnImport(\"tiledPlaneBuilder\");\n    };\n    /**\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\n     * * segments sets the number of horizontal strips optional, default 32\n     * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n     * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n     * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n     * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n     * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n     * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.segments\n     * @param options.diameter\n     * @param options.diameterX\n     * @param options.diameterY\n     * @param options.diameterZ\n     * @param options.arc\n     * @param options.slice\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the ellipsoid\n     * @deprecated use CreateSphereVertexData instead\n     */\n    VertexData.CreateSphere = function (options) {\n        throw _WarnImport(\"sphereBuilder\");\n    };\n    /**\n     * Creates the VertexData for a cylinder, cone or prism\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\n     * * height sets the height (y direction) of the cylinder, optional, default 2\n     * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n     * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n     * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n     * * subdivisions` the number of rings along the cylinder height, optional, default 1\n     * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n     * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n     * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.height\n     * @param options.diameterTop\n     * @param options.diameterBottom\n     * @param options.diameter\n     * @param options.tessellation\n     * @param options.subdivisions\n     * @param options.arc\n     * @param options.faceColors\n     * @param options.faceUV\n     * @param options.hasRings\n     * @param options.enclose\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the cylinder, cone or prism\n     * @deprecated please use CreateCylinderVertexData instead\n     */\n    VertexData.CreateCylinder = function (options) {\n        throw _WarnImport(\"cylinderBuilder\");\n    };\n    /**\n     * Creates the VertexData for a torus\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\n     * * diameter the diameter of the torus, optional default 1\n     * * thickness the diameter of the tube forming the torus, optional default 0.5\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.diameter\n     * @param options.thickness\n     * @param options.tessellation\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the torus\n     * @deprecated use CreateTorusVertexData instead\n     */\n    VertexData.CreateTorus = function (options) {\n        throw _WarnImport(\"torusBuilder\");\n    };\n    /**\n     * Creates the VertexData of the LineSystem\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n     *  - lines an array of lines, each line being an array of successive Vector3\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n     * @param options.lines\n     * @param options.colors\n     * @returns the VertexData of the LineSystem\n     * @deprecated use CreateLineSystemVertexData instead\n     */\n    VertexData.CreateLineSystem = function (options) {\n        throw _WarnImport(\"linesBuilder\");\n    };\n    /**\n     * Create the VertexData for a DashedLines\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n     *  - points an array successive Vector3\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n     *  - dashNb the intended total number of dashes, optional, default 200\n     * @param options.points\n     * @param options.dashSize\n     * @param options.gapSize\n     * @param options.dashNb\n     * @returns the VertexData for the DashedLines\n     * @deprecated use CreateDashedLinesVertexData instead\n     */\n    VertexData.CreateDashedLines = function (options) {\n        throw _WarnImport(\"linesBuilder\");\n    };\n    /**\n     * Creates the VertexData for a Ground\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n     *  - width the width (x direction) of the ground, optional, default 1\n     *  - height the height (z direction) of the ground, optional, default 1\n     *  - subdivisions the number of subdivisions per side, optional, default 1\n     * @param options.width\n     * @param options.height\n     * @param options.subdivisions\n     * @param options.subdivisionsX\n     * @param options.subdivisionsY\n     * @returns the VertexData of the Ground\n     * @deprecated Please use CreateGroundVertexData instead\n     */\n    VertexData.CreateGround = function (options) {\n        throw _WarnImport(\"groundBuilder\");\n    };\n    /**\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n     * * xmin the ground minimum X coordinate, optional, default -1\n     * * zmin the ground minimum Z coordinate, optional, default -1\n     * * xmax the ground maximum X coordinate, optional, default 1\n     * * zmax the ground maximum Z coordinate, optional, default 1\n     * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n     * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n     * @param options.xmin\n     * @param options.zmin\n     * @param options.xmax\n     * @param options.zmax\n     * @param options.subdivisions\n     * @param options.subdivisions.w\n     * @param options.subdivisions.h\n     * @param options.precision\n     * @param options.precision.w\n     * @param options.precision.h\n     * @returns the VertexData of the TiledGround\n     * @deprecated use CreateTiledGroundVertexData instead\n     */\n    VertexData.CreateTiledGround = function (options) {\n        throw _WarnImport(\"groundBuilder\");\n    };\n    /**\n     * Creates the VertexData of the Ground designed from a heightmap\n     * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n     * * width the width (x direction) of the ground\n     * * height the height (z direction) of the ground\n     * * subdivisions the number of subdivisions per side\n     * * minHeight the minimum altitude on the ground, optional, default 0\n     * * maxHeight the maximum altitude on the ground, optional default 1\n     * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n     * * buffer the array holding the image color data\n     * * bufferWidth the width of image\n     * * bufferHeight the height of image\n     * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n     * @param options.width\n     * @param options.height\n     * @param options.subdivisions\n     * @param options.minHeight\n     * @param options.maxHeight\n     * @param options.colorFilter\n     * @param options.buffer\n     * @param options.bufferWidth\n     * @param options.bufferHeight\n     * @param options.alphaFilter\n     * @returns the VertexData of the Ground designed from a heightmap\n     * @deprecated use CreateGroundFromHeightMapVertexData instead\n     */\n    VertexData.CreateGroundFromHeightMap = function (options) {\n        throw _WarnImport(\"groundBuilder\");\n    };\n    /**\n     * Creates the VertexData for a Plane\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\n     * * size sets the width and height of the plane to the value of size, optional default 1\n     * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\n     * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.size\n     * @param options.width\n     * @param options.height\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the box\n     * @deprecated use CreatePlaneVertexData instead\n     */\n    VertexData.CreatePlane = function (options) {\n        throw _WarnImport(\"planeBuilder\");\n    };\n    /**\n     * Creates the VertexData of the Disc or regular Polygon\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\n     * * radius the radius of the disc, optional default 0.5\n     * * tessellation the number of polygon sides, optional, default 64\n     * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.radius\n     * @param options.tessellation\n     * @param options.arc\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the box\n     * @deprecated use CreateDiscVertexData instead\n     */\n    VertexData.CreateDisc = function (options) {\n        throw _WarnImport(\"discBuilder\");\n    };\n    /**\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\n     * All parameters are provided by CreatePolygon as needed\n     * @param polygon a mesh built from polygonTriangulation.build()\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\n     * @returns the VertexData of the Polygon\n     * @deprecated use CreatePolygonVertexData instead\n     */\n    VertexData.CreatePolygon = function (polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {\n        throw _WarnImport(\"polygonBuilder\");\n    };\n    /**\n     * Creates the VertexData of the IcoSphere\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\n     * * radius the radius of the IcoSphere, optional default 1\n     * * radiusX allows stretching in the x direction, optional, default radius\n     * * radiusY allows stretching in the y direction, optional, default radius\n     * * radiusZ allows stretching in the z direction, optional, default radius\n     * * flat when true creates a flat shaded mesh, optional, default true\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.radius\n     * @param options.radiusX\n     * @param options.radiusY\n     * @param options.radiusZ\n     * @param options.flat\n     * @param options.subdivisions\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the IcoSphere\n     * @deprecated use CreateIcoSphereVertexData instead\n     */\n    VertexData.CreateIcoSphere = function (options) {\n        throw _WarnImport(\"icoSphereBuilder\");\n    };\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n    /**\n     * Creates the VertexData for a Polyhedron\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n     * * type provided types are:\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n     * * size the size of the IcoSphere, optional default 1\n     * * sizeX allows stretching in the x direction, optional, default size\n     * * sizeY allows stretching in the y direction, optional, default size\n     * * sizeZ allows stretching in the z direction, optional, default size\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n     * * flat when true creates a flat shaded mesh, optional, default true\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.type\n     * @param options.size\n     * @param options.sizeX\n     * @param options.sizeY\n     * @param options.sizeZ\n     * @param options.custom\n     * @param options.faceUV\n     * @param options.faceColors\n     * @param options.flat\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the Polyhedron\n     * @deprecated use CreatePolyhedronVertexData instead\n     */\n    VertexData.CreatePolyhedron = function (options) {\n        throw _WarnImport(\"polyhedronBuilder\");\n    };\n    /**\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\n     * @returns the VertexData of the Capsule\n     * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\n     */\n    VertexData.CreateCapsule = function (options) {\n        if (options === void 0) { options = {\n            orientation: Vector3.Up(),\n            subdivisions: 2,\n            tessellation: 16,\n            height: 1,\n            radius: 0.25,\n            capSubdivisions: 6,\n        }; }\n        throw _WarnImport(\"capsuleBuilder\");\n    };\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n    /**\n     * Creates the VertexData for a TorusKnot\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n     * * radius the radius of the torus knot, optional, default 2\n     * * tube the thickness of the tube, optional, default 0.5\n     * * radialSegments the number of sides on each tube segments, optional, default 32\n     * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n     * * p the number of windings around the z axis, optional,  default 2\n     * * q the number of windings around the x axis, optional,  default 3\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n     * @param options.radius\n     * @param options.tube\n     * @param options.radialSegments\n     * @param options.tubularSegments\n     * @param options.p\n     * @param options.q\n     * @param options.sideOrientation\n     * @param options.frontUVs\n     * @param options.backUVs\n     * @returns the VertexData of the Torus Knot\n     * @deprecated use CreateTorusKnotVertexData instead\n     */\n    VertexData.CreateTorusKnot = function (options) {\n        throw _WarnImport(\"torusKnotBuilder\");\n    };\n    // Tools\n    /**\n     * Compute normals for given positions and indices\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\n     * * facetNormals : optional array of facet normals (vector3)\n     * * facetPositions : optional array of facet positions (vector3)\n     * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\n     * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\n     * * bInfo : optional bounding info, required for facetPartitioning computation\n     * * bbSize : optional bounding box size data, required for facetPartitioning computation\n     * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\n     * * useRightHandedSystem: optional boolean to for right handed system computation\n     * * depthSort : optional boolean to enable the facet depth sort computation\n     * * distanceTo : optional Vector3 to compute the facet depth from this location\n     * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\n     * @param options.facetNormals\n     * @param options.facetPositions\n     * @param options.facetPartitioning\n     * @param options.ratio\n     * @param options.bInfo\n     * @param options.bbSize\n     * @param options.subDiv\n     * @param options.useRightHandedSystem\n     * @param options.depthSort\n     * @param options.distanceTo\n     * @param options.depthSortedFacets\n     */\n    VertexData.ComputeNormals = function (positions, indices, normals, options) {\n        // temporary scalar variables\n        var index = 0; // facet index\n        var p1p2x = 0.0; // p1p2 vector x coordinate\n        var p1p2y = 0.0; // p1p2 vector y coordinate\n        var p1p2z = 0.0; // p1p2 vector z coordinate\n        var p3p2x = 0.0; // p3p2 vector x coordinate\n        var p3p2y = 0.0; // p3p2 vector y coordinate\n        var p3p2z = 0.0; // p3p2 vector z coordinate\n        var faceNormalx = 0.0; // facet normal x coordinate\n        var faceNormaly = 0.0; // facet normal y coordinate\n        var faceNormalz = 0.0; // facet normal z coordinate\n        var length = 0.0; // facet normal length before normalization\n        var v1x = 0; // vector1 x index in the positions array\n        var v1y = 0; // vector1 y index in the positions array\n        var v1z = 0; // vector1 z index in the positions array\n        var v2x = 0; // vector2 x index in the positions array\n        var v2y = 0; // vector2 y index in the positions array\n        var v2z = 0; // vector2 z index in the positions array\n        var v3x = 0; // vector3 x index in the positions array\n        var v3y = 0; // vector3 y index in the positions array\n        var v3z = 0; // vector3 z index in the positions array\n        var computeFacetNormals = false;\n        var computeFacetPositions = false;\n        var computeFacetPartitioning = false;\n        var computeDepthSort = false;\n        var faceNormalSign = 1;\n        var ratio = 0;\n        var distanceTo = null;\n        if (options) {\n            computeFacetNormals = options.facetNormals ? true : false;\n            computeFacetPositions = options.facetPositions ? true : false;\n            computeFacetPartitioning = options.facetPartitioning ? true : false;\n            faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\n            ratio = options.ratio || 0;\n            computeDepthSort = options.depthSort ? true : false;\n            distanceTo = options.distanceTo;\n            if (computeDepthSort) {\n                if (distanceTo === undefined) {\n                    distanceTo = Vector3.Zero();\n                }\n            }\n        }\n        // facetPartitioning reinit if needed\n        var xSubRatio = 0;\n        var ySubRatio = 0;\n        var zSubRatio = 0;\n        var subSq = 0;\n        if (computeFacetPartitioning && options && options.bbSize) {\n            //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\n            //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\n            xSubRatio = (options.subDiv.X * ratio) / options.bbSize.x;\n            ySubRatio = (options.subDiv.Y * ratio) / options.bbSize.y;\n            zSubRatio = (options.subDiv.Z * ratio) / options.bbSize.z;\n            subSq = options.subDiv.max * options.subDiv.max;\n            options.facetPartitioning.length = 0;\n        }\n        // reset the normals\n        for (index = 0; index < positions.length; index++) {\n            normals[index] = 0.0;\n        }\n        // Loop : 1 indice triplet = 1 facet\n        var nbFaces = (indices.length / 3) | 0;\n        for (index = 0; index < nbFaces; index++) {\n            // get the indexes of the coordinates of each vertex of the facet\n            v1x = indices[index * 3] * 3;\n            v1y = v1x + 1;\n            v1z = v1x + 2;\n            v2x = indices[index * 3 + 1] * 3;\n            v2y = v2x + 1;\n            v2z = v2x + 2;\n            v3x = indices[index * 3 + 2] * 3;\n            v3y = v3x + 1;\n            v3z = v3x + 2;\n            p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\n            p1p2y = positions[v1y] - positions[v2y];\n            p1p2z = positions[v1z] - positions[v2z];\n            p3p2x = positions[v3x] - positions[v2x];\n            p3p2y = positions[v3y] - positions[v2y];\n            p3p2z = positions[v3z] - positions[v2z];\n            // compute the face normal with the cross product\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\n            // normalize this normal and store it in the array facetData\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n            length = length === 0 ? 1.0 : length;\n            faceNormalx /= length;\n            faceNormaly /= length;\n            faceNormalz /= length;\n            if (computeFacetNormals && options) {\n                options.facetNormals[index].x = faceNormalx;\n                options.facetNormals[index].y = faceNormaly;\n                options.facetNormals[index].z = faceNormalz;\n            }\n            if (computeFacetPositions && options) {\n                // compute and the facet barycenter coordinates in the array facetPositions\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\n            }\n            if (computeFacetPartitioning && options) {\n                // store the facet indexes in arrays in the main facetPartitioning array :\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\n                var ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\n                var oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\n                var oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\n                var b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n                var b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n                var b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n                var b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n                var b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n                var b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n                var b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n                var b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n                var b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n                var block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\n                var block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\n                var block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\n                var block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\n                options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\n                options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\n                options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\n                options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\n                // push each facet index in each block containing the vertex\n                options.facetPartitioning[block_idx_v1].push(index);\n                if (block_idx_v2 != block_idx_v1) {\n                    options.facetPartitioning[block_idx_v2].push(index);\n                }\n                if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\n                    options.facetPartitioning[block_idx_v3].push(index);\n                }\n                if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\n                    options.facetPartitioning[block_idx_o].push(index);\n                }\n            }\n            if (computeDepthSort && options && options.facetPositions) {\n                var dsf = options.depthSortedFacets[index];\n                dsf.ind = index * 3;\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);\n            }\n            // compute the normals anyway\n            normals[v1x] += faceNormalx; // accumulate all the normals per face\n            normals[v1y] += faceNormaly;\n            normals[v1z] += faceNormalz;\n            normals[v2x] += faceNormalx;\n            normals[v2y] += faceNormaly;\n            normals[v2z] += faceNormalz;\n            normals[v3x] += faceNormalx;\n            normals[v3y] += faceNormaly;\n            normals[v3z] += faceNormalz;\n        }\n        // last normalization of each normal\n        for (index = 0; index < normals.length / 3; index++) {\n            faceNormalx = normals[index * 3];\n            faceNormaly = normals[index * 3 + 1];\n            faceNormalz = normals[index * 3 + 2];\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n            length = length === 0 ? 1.0 : length;\n            faceNormalx /= length;\n            faceNormaly /= length;\n            faceNormalz /= length;\n            normals[index * 3] = faceNormalx;\n            normals[index * 3 + 1] = faceNormaly;\n            normals[index * 3 + 2] = faceNormalz;\n        }\n    };\n    /**\n     * @param sideOrientation\n     * @param positions\n     * @param indices\n     * @param normals\n     * @param uvs\n     * @param frontUVs\n     * @param backUVs\n     * @hidden\n     */\n    VertexData._ComputeSides = function (sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {\n        var li = indices.length;\n        var ln = normals.length;\n        var i;\n        var n;\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\n        switch (sideOrientation) {\n            case VertexData.FRONTSIDE:\n                // nothing changed\n                break;\n            case VertexData.BACKSIDE:\n                // indices\n                for (i = 0; i < li; i += 3) {\n                    var tmp = indices[i];\n                    indices[i] = indices[i + 2];\n                    indices[i + 2] = tmp;\n                }\n                // normals\n                for (n = 0; n < ln; n++) {\n                    normals[n] = -normals[n];\n                }\n                break;\n            case VertexData.DOUBLESIDE: {\n                // positions\n                var lp = positions.length;\n                var l = lp / 3;\n                for (var p = 0; p < lp; p++) {\n                    positions[lp + p] = positions[p];\n                }\n                // indices\n                for (i = 0; i < li; i += 3) {\n                    indices[i + li] = indices[i + 2] + l;\n                    indices[i + 1 + li] = indices[i + 1] + l;\n                    indices[i + 2 + li] = indices[i] + l;\n                }\n                // normals\n                for (n = 0; n < ln; n++) {\n                    normals[ln + n] = -normals[n];\n                }\n                // uvs\n                var lu = uvs.length;\n                var u = 0;\n                for (u = 0; u < lu; u++) {\n                    uvs[u + lu] = uvs[u];\n                }\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n                u = 0;\n                for (i = 0; i < lu / 2; i++) {\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\n                    u += 2;\n                }\n                break;\n            }\n        }\n    };\n    /**\n     * Applies VertexData created from the imported parameters to the geometry\n     * @param parsedVertexData the parsed data from an imported file\n     * @param geometry the geometry to apply the VertexData to\n     */\n    VertexData.ImportVertexData = function (parsedVertexData, geometry) {\n        var vertexData = new VertexData();\n        // positions\n        var positions = parsedVertexData.positions;\n        if (positions) {\n            vertexData.set(positions, VertexBuffer.PositionKind);\n        }\n        // normals\n        var normals = parsedVertexData.normals;\n        if (normals) {\n            vertexData.set(normals, VertexBuffer.NormalKind);\n        }\n        // tangents\n        var tangents = parsedVertexData.tangents;\n        if (tangents) {\n            vertexData.set(tangents, VertexBuffer.TangentKind);\n        }\n        // uvs\n        var uvs = parsedVertexData.uvs;\n        if (uvs) {\n            vertexData.set(uvs, VertexBuffer.UVKind);\n        }\n        // uv2s\n        var uv2s = parsedVertexData.uv2s;\n        if (uv2s) {\n            vertexData.set(uv2s, VertexBuffer.UV2Kind);\n        }\n        // uv3s\n        var uv3s = parsedVertexData.uv3s;\n        if (uv3s) {\n            vertexData.set(uv3s, VertexBuffer.UV3Kind);\n        }\n        // uv4s\n        var uv4s = parsedVertexData.uv4s;\n        if (uv4s) {\n            vertexData.set(uv4s, VertexBuffer.UV4Kind);\n        }\n        // uv5s\n        var uv5s = parsedVertexData.uv5s;\n        if (uv5s) {\n            vertexData.set(uv5s, VertexBuffer.UV5Kind);\n        }\n        // uv6s\n        var uv6s = parsedVertexData.uv6s;\n        if (uv6s) {\n            vertexData.set(uv6s, VertexBuffer.UV6Kind);\n        }\n        // colors\n        var colors = parsedVertexData.colors;\n        if (colors) {\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\n        }\n        // matricesIndices\n        var matricesIndices = parsedVertexData.matricesIndices;\n        if (matricesIndices) {\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\n        }\n        // matricesWeights\n        var matricesWeights = parsedVertexData.matricesWeights;\n        if (matricesWeights) {\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\n        }\n        // indices\n        var indices = parsedVertexData.indices;\n        if (indices) {\n            vertexData.indices = indices;\n        }\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\n    };\n    /**\n     * Mesh side orientation : usually the external or front surface\n     */\n    VertexData.FRONTSIDE = 0;\n    /**\n     * Mesh side orientation : usually the internal or back surface\n     */\n    VertexData.BACKSIDE = 1;\n    /**\n     * Mesh side orientation : both internal and external or front and back surfaces\n     */\n    VertexData.DOUBLESIDE = 2;\n    /**\n     * Mesh side orientation : by default, `FRONTSIDE`\n     */\n    VertexData.DEFAULTSIDE = 0;\n    __decorate([\n        nativeOverride.filter(function () {\n            var _a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                _a[_i] = arguments[_i];\n            }\n            var coordinates = _a[0];\n            return !Array.isArray(coordinates);\n        })\n    ], VertexData, \"_TransformVector3Coordinates\", null);\n    __decorate([\n        nativeOverride.filter(function () {\n            var _a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                _a[_i] = arguments[_i];\n            }\n            var normals = _a[0];\n            return !Array.isArray(normals);\n        })\n    ], VertexData, \"_TransformVector3Normals\", null);\n    __decorate([\n        nativeOverride.filter(function () {\n            var _a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                _a[_i] = arguments[_i];\n            }\n            var normals = _a[0];\n            return !Array.isArray(normals);\n        })\n    ], VertexData, \"_TransformVector4Normals\", null);\n    __decorate([\n        nativeOverride.filter(function () {\n            var _a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                _a[_i] = arguments[_i];\n            }\n            var indices = _a[0];\n            return !Array.isArray(indices);\n        })\n    ], VertexData, \"_FlipFaces\", null);\n    return VertexData;\n}());\nexport { VertexData };\n//# sourceMappingURL=mesh.vertexData.js.map","/**\n * Class used to represent a specific level of detail of a mesh\n * @see https://doc.babylonjs.com/how_to/how_to_use_lod\n */\nvar MeshLODLevel = /** @class */ (function () {\n    /**\n     * Creates a new LOD level\n     * @param distanceOrScreenCoverage defines either the distance or the screen coverage where this level should start being displayed\n     * @param mesh defines the mesh to use to render this level\n     */\n    function MeshLODLevel(\n    /** Either distance from the center of the object to show this level or the screen coverage if `useLODScreenCoverage` is set to `true` on the mesh*/\n    distanceOrScreenCoverage, \n    /** Defines the mesh to use to render this level */\n    mesh) {\n        this.distanceOrScreenCoverage = distanceOrScreenCoverage;\n        this.mesh = mesh;\n    }\n    return MeshLODLevel;\n}());\nexport { MeshLODLevel };\n//# sourceMappingURL=meshLODLevel.js.map","import { __extends } from \"tslib\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Path2 } from \"../Maths/math.path.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Vector2 wth index property\n */\nvar IndexedVector2 = /** @class */ (function (_super) {\n    __extends(IndexedVector2, _super);\n    function IndexedVector2(original, \n    /** Index of the vector2 */\n    index) {\n        var _this = _super.call(this, original.x, original.y) || this;\n        _this.index = index;\n        return _this;\n    }\n    return IndexedVector2;\n}(Vector2));\n/**\n * Defines points to create a polygon\n */\nvar PolygonPoints = /** @class */ (function () {\n    function PolygonPoints() {\n        this.elements = new Array();\n    }\n    PolygonPoints.prototype.add = function (originalPoints) {\n        var _this = this;\n        var result = new Array();\n        originalPoints.forEach(function (point) {\n            var newPoint = new IndexedVector2(point, _this.elements.length);\n            result.push(newPoint);\n            _this.elements.push(newPoint);\n        });\n        return result;\n    };\n    PolygonPoints.prototype.computeBounds = function () {\n        var lmin = new Vector2(this.elements[0].x, this.elements[0].y);\n        var lmax = new Vector2(this.elements[0].x, this.elements[0].y);\n        this.elements.forEach(function (point) {\n            // x\n            if (point.x < lmin.x) {\n                lmin.x = point.x;\n            }\n            else if (point.x > lmax.x) {\n                lmax.x = point.x;\n            }\n            // y\n            if (point.y < lmin.y) {\n                lmin.y = point.y;\n            }\n            else if (point.y > lmax.y) {\n                lmax.y = point.y;\n            }\n        });\n        return {\n            min: lmin,\n            max: lmax,\n            width: lmax.x - lmin.x,\n            height: lmax.y - lmin.y,\n        };\n    };\n    return PolygonPoints;\n}());\n/**\n * Polygon\n * @see https://doc.babylonjs.com/how_to/parametric_shapes#non-regular-polygon\n */\nvar Polygon = /** @class */ (function () {\n    function Polygon() {\n    }\n    /**\n     * Creates a rectangle\n     * @param xmin bottom X coord\n     * @param ymin bottom Y coord\n     * @param xmax top X coord\n     * @param ymax top Y coord\n     * @returns points that make the resulting rectangle\n     */\n    Polygon.Rectangle = function (xmin, ymin, xmax, ymax) {\n        return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\n    };\n    /**\n     * Creates a circle\n     * @param radius radius of circle\n     * @param cx scale in x\n     * @param cy scale in y\n     * @param numberOfSides number of sides that make up the circle\n     * @returns points that make the resulting circle\n     */\n    Polygon.Circle = function (radius, cx, cy, numberOfSides) {\n        if (cx === void 0) { cx = 0; }\n        if (cy === void 0) { cy = 0; }\n        if (numberOfSides === void 0) { numberOfSides = 32; }\n        var result = new Array();\n        var angle = 0;\n        var increment = (Math.PI * 2) / numberOfSides;\n        for (var i = 0; i < numberOfSides; i++) {\n            result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\n            angle -= increment;\n        }\n        return result;\n    };\n    /**\n     * Creates a polygon from input string\n     * @param input Input polygon data\n     * @returns the parsed points\n     */\n    Polygon.Parse = function (input) {\n        var floats = input\n            .split(/[^-+eE.\\d]+/)\n            .map(parseFloat)\n            .filter(function (val) { return !isNaN(val); });\n        var i;\n        var result = [];\n        for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\n            result.push(new Vector2(floats[i], floats[i + 1]));\n        }\n        return result;\n    };\n    /**\n     * Starts building a polygon from x and y coordinates\n     * @param x x coordinate\n     * @param y y coordinate\n     * @returns the started path2\n     */\n    Polygon.StartingAt = function (x, y) {\n        return Path2.StartingAt(x, y);\n    };\n    return Polygon;\n}());\nexport { Polygon };\n/**\n * Builds a polygon\n * @see https://doc.babylonjs.com/how_to/polygonmeshbuilder\n */\nvar PolygonMeshBuilder = /** @class */ (function () {\n    /**\n     * Creates a PolygonMeshBuilder\n     * @param name name of the builder\n     * @param contours Path of the polygon\n     * @param scene scene to add to when creating the mesh\n     * @param earcutInjection can be used to inject your own earcut reference\n     */\n    function PolygonMeshBuilder(name, contours, scene, earcutInjection) {\n        if (earcutInjection === void 0) { earcutInjection = earcut; }\n        this._points = new PolygonPoints();\n        this._outlinepoints = new PolygonPoints();\n        this._holes = new Array();\n        this._epoints = new Array();\n        this._eholes = new Array();\n        this.bjsEarcut = earcutInjection;\n        this._name = name;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        var points;\n        if (contours instanceof Path2) {\n            points = contours.getPoints();\n        }\n        else {\n            points = contours;\n        }\n        this._addToepoint(points);\n        this._points.add(points);\n        this._outlinepoints.add(points);\n        if (typeof this.bjsEarcut === \"undefined\") {\n            Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\n        }\n    }\n    PolygonMeshBuilder.prototype._addToepoint = function (points) {\n        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n            var p = points_1[_i];\n            this._epoints.push(p.x, p.y);\n        }\n    };\n    /**\n     * Adds a hole within the polygon\n     * @param hole Array of points defining the hole\n     * @returns this\n     */\n    PolygonMeshBuilder.prototype.addHole = function (hole) {\n        this._points.add(hole);\n        var holepoints = new PolygonPoints();\n        holepoints.add(hole);\n        this._holes.push(holepoints);\n        this._eholes.push(this._epoints.length / 2);\n        this._addToepoint(hole);\n        return this;\n    };\n    /**\n     * Creates the polygon\n     * @param updatable If the mesh should be updatable\n     * @param depth The depth of the mesh created\n     * @param smoothingThreshold Dot product threshold for smoothed normals\n     * @returns the created mesh\n     */\n    PolygonMeshBuilder.prototype.build = function (updatable, depth, smoothingThreshold) {\n        if (updatable === void 0) { updatable = false; }\n        if (depth === void 0) { depth = 0; }\n        if (smoothingThreshold === void 0) { smoothingThreshold = 2; }\n        var result = new Mesh(this._name, this._scene);\n        var vertexData = this.buildVertexData(depth, smoothingThreshold);\n        result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);\n        result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);\n        result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);\n        result.setIndices(vertexData.indices);\n        return result;\n    };\n    /**\n     * Creates the polygon\n     * @param depth The depth of the mesh created\n     * @param smoothingThreshold Dot product threshold for smoothed normals\n     * @returns the created VertexData\n     */\n    PolygonMeshBuilder.prototype.buildVertexData = function (depth, smoothingThreshold) {\n        var _this = this;\n        if (depth === void 0) { depth = 0; }\n        if (smoothingThreshold === void 0) { smoothingThreshold = 2; }\n        var result = new VertexData();\n        var normals = new Array();\n        var positions = new Array();\n        var uvs = new Array();\n        var bounds = this._points.computeBounds();\n        this._points.elements.forEach(function (p) {\n            normals.push(0, 1.0, 0);\n            positions.push(p.x, 0, p.y);\n            uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\n        });\n        var indices = new Array();\n        var res = this.bjsEarcut(this._epoints, this._eholes, 2);\n        for (var i = 0; i < res.length; i++) {\n            indices.push(res[i]);\n        }\n        if (depth > 0) {\n            var positionscount = positions.length / 3; //get the current pointcount\n            this._points.elements.forEach(function (p) {\n                //add the elements at the depth\n                normals.push(0, -1.0, 0);\n                positions.push(p.x, -depth, p.y);\n                uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\n            });\n            var totalCount = indices.length;\n            for (var i = 0; i < totalCount; i += 3) {\n                var i0 = indices[i + 0];\n                var i1 = indices[i + 1];\n                var i2 = indices[i + 2];\n                indices.push(i2 + positionscount);\n                indices.push(i1 + positionscount);\n                indices.push(i0 + positionscount);\n            }\n            //Add the sides\n            this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\n            this._holes.forEach(function (hole) {\n                _this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\n            });\n        }\n        result.indices = indices;\n        result.positions = positions;\n        result.normals = normals;\n        result.uvs = uvs;\n        return result;\n    };\n    /**\n     * Adds a side to the polygon\n     * @param positions points that make the polygon\n     * @param normals normals of the polygon\n     * @param uvs uvs of the polygon\n     * @param indices indices of the polygon\n     * @param bounds bounds of the polygon\n     * @param points points of the polygon\n     * @param depth depth of the polygon\n     * @param flip flip of the polygon\n     * @param smoothingThreshold\n     */\n    PolygonMeshBuilder.prototype._addSide = function (positions, normals, uvs, indices, bounds, points, depth, flip, smoothingThreshold) {\n        var startIndex = positions.length / 3;\n        var ulength = 0;\n        for (var i = 0; i < points.elements.length; i++) {\n            var p = points.elements[i];\n            var p1 = points.elements[(i + 1) % points.elements.length];\n            positions.push(p.x, 0, p.y);\n            positions.push(p.x, -depth, p.y);\n            positions.push(p1.x, 0, p1.y);\n            positions.push(p1.x, -depth, p1.y);\n            var p0 = points.elements[(i + points.elements.length - 1) % points.elements.length];\n            var p2 = points.elements[(i + 2) % points.elements.length];\n            var vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\n            var vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\n            var vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\n            if (!flip) {\n                vc = vc.scale(-1);\n                vp = vp.scale(-1);\n                vn = vn.scale(-1);\n            }\n            var vc_norm = vc.normalizeToNew();\n            var vp_norm = vp.normalizeToNew();\n            var vn_norm = vn.normalizeToNew();\n            var dotp = Vector3.Dot(vp_norm, vc_norm);\n            if (dotp > smoothingThreshold) {\n                if (dotp < Epsilon - 1) {\n                    vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\n                }\n                else {\n                    // cheap average weighed by side length\n                    vp_norm = vp.add(vc).normalize();\n                }\n            }\n            else {\n                vp_norm = vc_norm;\n            }\n            var dotn = Vector3.Dot(vn, vc);\n            if (dotn > smoothingThreshold) {\n                if (dotn < Epsilon - 1) {\n                    // back to back\n                    vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\n                }\n                else {\n                    // cheap average weighed by side length\n                    vn_norm = vn.add(vc).normalize();\n                }\n            }\n            else {\n                vn_norm = vc_norm;\n            }\n            uvs.push(ulength / bounds.width, 0);\n            uvs.push(ulength / bounds.width, 1);\n            ulength += vc.length();\n            uvs.push(ulength / bounds.width, 0);\n            uvs.push(ulength / bounds.width, 1);\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\n            if (!flip) {\n                indices.push(startIndex);\n                indices.push(startIndex + 1);\n                indices.push(startIndex + 2);\n                indices.push(startIndex + 1);\n                indices.push(startIndex + 3);\n                indices.push(startIndex + 2);\n            }\n            else {\n                indices.push(startIndex);\n                indices.push(startIndex + 2);\n                indices.push(startIndex + 1);\n                indices.push(startIndex + 1);\n                indices.push(startIndex + 2);\n                indices.push(startIndex + 3);\n            }\n            startIndex += 4;\n        }\n    };\n    return PolygonMeshBuilder;\n}());\nexport { PolygonMeshBuilder };\n//# sourceMappingURL=polygonMesh.js.map","import { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\n\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\n/**\n * Defines a subdivision inside a mesh\n */\nvar SubMesh = /** @class */ (function () {\n    /**\n     * Creates a new submesh\n     * @param materialIndex defines the material index to use\n     * @param verticesStart defines vertex index start\n     * @param verticesCount defines vertices count\n     * @param indexStart defines index start\n     * @param indexCount defines indices count\n     * @param mesh defines the parent mesh\n     * @param renderingMesh defines an optional rendering mesh\n     * @param createBoundingBox defines if bounding box should be created for this submesh\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\n     */\n    function SubMesh(\n    /** the material index to use */\n    materialIndex, \n    /** vertex index start */\n    verticesStart, \n    /** vertices count */\n    verticesCount, \n    /** index start */\n    indexStart, \n    /** indices count */\n    indexCount, mesh, renderingMesh, createBoundingBox, addToMesh) {\n        if (createBoundingBox === void 0) { createBoundingBox = true; }\n        if (addToMesh === void 0) { addToMesh = true; }\n        this.materialIndex = materialIndex;\n        this.verticesStart = verticesStart;\n        this.verticesCount = verticesCount;\n        this.indexStart = indexStart;\n        this.indexCount = indexCount;\n        this._mainDrawWrapperOverride = null;\n        /** @hidden */\n        this._linesIndexCount = 0;\n        this._linesIndexBuffer = null;\n        /** @hidden */\n        this._lastColliderWorldVertices = null;\n        /** @hidden */\n        this._lastColliderTransformMatrix = null;\n        /** @hidden */\n        this._renderId = 0;\n        /** @hidden */\n        this._alphaIndex = 0;\n        /** @hidden */\n        this._distanceToCamera = 0;\n        this._currentMaterial = null;\n        this._mesh = mesh;\n        this._renderingMesh = renderingMesh || mesh;\n        if (addToMesh) {\n            mesh.subMeshes.push(this);\n        }\n        this._engine = this._mesh.getScene().getEngine();\n        this.resetDrawCache();\n        this._trianglePlanes = [];\n        this._id = mesh.subMeshes.length - 1;\n        if (createBoundingBox) {\n            this.refreshBoundingInfo();\n            mesh.computeWorldMatrix(true);\n        }\n    }\n    Object.defineProperty(SubMesh.prototype, \"materialDefines\", {\n        /**\n         * Gets material defines used by the effect associated to the sub mesh\n         */\n        get: function () {\n            var _a;\n            return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.defines;\n        },\n        /**\n         * Sets material defines used by the effect associated to the sub mesh\n         */\n        set: function (defines) {\n            var _a;\n            var drawWrapper = (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n            drawWrapper.defines = defines;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * @param passId\n     * @param createIfNotExisting\n     * @hidden\n     */\n    SubMesh.prototype._getDrawWrapper = function (passId, createIfNotExisting) {\n        if (createIfNotExisting === void 0) { createIfNotExisting = false; }\n        passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;\n        var drawWrapper = this._drawWrappers[passId];\n        if (!drawWrapper && createIfNotExisting) {\n            this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\n        }\n        return drawWrapper;\n    };\n    /**\n     * @param passId\n     * @param disposeWrapper\n     * @hidden\n     */\n    SubMesh.prototype._removeDrawWrapper = function (passId, disposeWrapper) {\n        var _a;\n        if (disposeWrapper === void 0) { disposeWrapper = true; }\n        if (disposeWrapper) {\n            (_a = this._drawWrappers[passId]) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n        this._drawWrappers[passId] = undefined;\n    };\n    Object.defineProperty(SubMesh.prototype, \"effect\", {\n        /**\n         * Gets associated (main) effect (possibly the effect override if defined)\n         */\n        get: function () {\n            var _a, _b;\n            return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b = (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SubMesh.prototype, \"_drawWrapper\", {\n        /** @hidden */\n        get: function () {\n            var _a;\n            return (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SubMesh.prototype, \"_drawWrapperOverride\", {\n        /** @hidden */\n        get: function () {\n            return this._mainDrawWrapperOverride;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * @param wrapper\n     * @hidden\n     */\n    SubMesh.prototype._setMainDrawWrapperOverride = function (wrapper) {\n        this._mainDrawWrapperOverride = wrapper;\n    };\n    /**\n     * Sets associated effect (effect used to render this submesh)\n     * @param effect defines the effect to associate with\n     * @param defines defines the set of defines used to compile this effect\n     * @param materialContext material context associated to the effect\n     * @param resetContext true to reset the draw context\n     */\n    SubMesh.prototype.setEffect = function (effect, defines, materialContext, resetContext) {\n        if (defines === void 0) { defines = null; }\n        if (resetContext === void 0) { resetContext = true; }\n        var drawWrapper = this._drawWrapper;\n        drawWrapper.setEffect(effect, defines, resetContext);\n        if (materialContext !== undefined) {\n            drawWrapper.materialContext = materialContext;\n        }\n        if (!effect) {\n            drawWrapper.defines = null;\n            drawWrapper.materialContext = undefined;\n        }\n    };\n    /**\n     * Resets the draw wrappers cache\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n     */\n    SubMesh.prototype.resetDrawCache = function (passId) {\n        if (this._drawWrappers) {\n            if (passId !== undefined) {\n                this._removeDrawWrapper(passId);\n                return;\n            }\n            else {\n                for (var _i = 0, _a = this._drawWrappers; _i < _a.length; _i++) {\n                    var drawWrapper = _a[_i];\n                    drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();\n                }\n            }\n        }\n        this._drawWrappers = [];\n    };\n    /**\n     * Add a new submesh to a mesh\n     * @param materialIndex defines the material index to use\n     * @param verticesStart defines vertex index start\n     * @param verticesCount defines vertices count\n     * @param indexStart defines index start\n     * @param indexCount defines indices count\n     * @param mesh defines the parent mesh\n     * @param renderingMesh defines an optional rendering mesh\n     * @param createBoundingBox defines if bounding box should be created for this submesh\n     * @returns the new submesh\n     */\n    SubMesh.AddToMesh = function (materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox) {\n        if (createBoundingBox === void 0) { createBoundingBox = true; }\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\n    };\n    Object.defineProperty(SubMesh.prototype, \"IsGlobal\", {\n        /**\n         * Returns true if this submesh covers the entire parent mesh\n         * @ignorenaming\n         */\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        get: function () {\n            return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the submesh BoundingInfo object\n     * @returns current bounding info (or mesh's one if the submesh is global)\n     */\n    SubMesh.prototype.getBoundingInfo = function () {\n        if (this.IsGlobal) {\n            return this._mesh.getBoundingInfo();\n        }\n        return this._boundingInfo;\n    };\n    /**\n     * Sets the submesh BoundingInfo\n     * @param boundingInfo defines the new bounding info to use\n     * @returns the SubMesh\n     */\n    SubMesh.prototype.setBoundingInfo = function (boundingInfo) {\n        this._boundingInfo = boundingInfo;\n        return this;\n    };\n    /**\n     * Returns the mesh of the current submesh\n     * @return the parent mesh\n     */\n    SubMesh.prototype.getMesh = function () {\n        return this._mesh;\n    };\n    /**\n     * Returns the rendering mesh of the submesh\n     * @returns the rendering mesh (could be different from parent mesh)\n     */\n    SubMesh.prototype.getRenderingMesh = function () {\n        return this._renderingMesh;\n    };\n    /**\n     * Returns the replacement mesh of the submesh\n     * @returns the replacement mesh (could be different from parent mesh)\n     */\n    SubMesh.prototype.getReplacementMesh = function () {\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n    };\n    /**\n     * Returns the effective mesh of the submesh\n     * @returns the effective mesh (could be different from parent mesh)\n     */\n    SubMesh.prototype.getEffectiveMesh = function () {\n        var replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n        return replacementMesh ? replacementMesh : this._renderingMesh;\n    };\n    /**\n     * Returns the submesh material\n     * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\n     * @returns null or the current material\n     */\n    SubMesh.prototype.getMaterial = function (getDefaultMaterial) {\n        var _a;\n        if (getDefaultMaterial === void 0) { getDefaultMaterial = true; }\n        var rootMaterial = (_a = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a !== void 0 ? _a : this._renderingMesh.material;\n        if (!rootMaterial) {\n            return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\n        }\n        else if (this._isMultiMaterial(rootMaterial)) {\n            var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\n            if (this._currentMaterial !== effectiveMaterial) {\n                this._currentMaterial = effectiveMaterial;\n                this.resetDrawCache();\n            }\n            return effectiveMaterial;\n        }\n        return rootMaterial;\n    };\n    SubMesh.prototype._isMultiMaterial = function (material) {\n        return material.getSubMaterial !== undefined;\n    };\n    // Methods\n    /**\n     * Sets a new updated BoundingInfo object to the submesh\n     * @param data defines an optional position array to use to determine the bounding info\n     * @returns the SubMesh\n     */\n    SubMesh.prototype.refreshBoundingInfo = function (data) {\n        if (data === void 0) { data = null; }\n        this._lastColliderWorldVertices = null;\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\n            return this;\n        }\n        if (!data) {\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\n        }\n        if (!data) {\n            this._boundingInfo = this._mesh.getBoundingInfo();\n            return this;\n        }\n        var indices = this._renderingMesh.getIndices();\n        var extend;\n        //is this the only submesh?\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\n            var boundingInfo = this._renderingMesh.getBoundingInfo();\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\n        }\n        else {\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n        }\n        if (this._boundingInfo) {\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n        }\n        else {\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n        }\n        return this;\n    };\n    /**\n     * @param collider\n     * @hidden\n     */\n    SubMesh.prototype._checkCollision = function (collider) {\n        var boundingInfo = this.getBoundingInfo();\n        return boundingInfo._checkCollision(collider);\n    };\n    /**\n     * Updates the submesh BoundingInfo\n     * @param world defines the world matrix to use to update the bounding info\n     * @returns the submesh\n     */\n    SubMesh.prototype.updateBoundingInfo = function (world) {\n        var boundingInfo = this.getBoundingInfo();\n        if (!boundingInfo) {\n            this.refreshBoundingInfo();\n            boundingInfo = this.getBoundingInfo();\n        }\n        if (boundingInfo) {\n            boundingInfo.update(world);\n        }\n        return this;\n    };\n    /**\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\n     * @param frustumPlanes defines the frustum planes\n     * @returns true if the submesh is intersecting with the frustum\n     */\n    SubMesh.prototype.isInFrustum = function (frustumPlanes) {\n        var boundingInfo = this.getBoundingInfo();\n        if (!boundingInfo) {\n            return false;\n        }\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\n    };\n    /**\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\n     * @param frustumPlanes defines the frustum planes\n     * @returns true if the submesh is inside the frustum\n     */\n    SubMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n        var boundingInfo = this.getBoundingInfo();\n        if (!boundingInfo) {\n            return false;\n        }\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\n    };\n    /**\n     * Renders the submesh\n     * @param enableAlphaMode defines if alpha needs to be used\n     * @returns the submesh\n     */\n    SubMesh.prototype.render = function (enableAlphaMode) {\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\n        return this;\n    };\n    /**\n     * @param indices\n     * @param engine\n     * @hidden\n     */\n    SubMesh.prototype._getLinesIndexBuffer = function (indices, engine) {\n        if (!this._linesIndexBuffer) {\n            var linesIndices = [];\n            for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n                linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\n            }\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\n            this._linesIndexCount = linesIndices.length;\n        }\n        return this._linesIndexBuffer;\n    };\n    /**\n     * Checks if the submesh intersects with a ray\n     * @param ray defines the ray to test\n     * @returns true is the passed ray intersects the submesh bounding box\n     */\n    SubMesh.prototype.canIntersects = function (ray) {\n        var boundingInfo = this.getBoundingInfo();\n        if (!boundingInfo) {\n            return false;\n        }\n        return ray.intersectsBox(boundingInfo.boundingBox);\n    };\n    /**\n     * Intersects current submesh with a ray\n     * @param ray defines the ray to test\n     * @param positions defines mesh's positions array\n     * @param indices defines mesh's indices array\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns intersection info or null if no intersection\n     */\n    SubMesh.prototype.intersects = function (ray, positions, indices, fastCheck, trianglePredicate) {\n        var material = this.getMaterial();\n        if (!material) {\n            return null;\n        }\n        var step = 3;\n        var checkStopper = false;\n        switch (material.fillMode) {\n            case 3:\n            case 5:\n            case 6:\n            case 8:\n                return null;\n            case 7:\n                step = 1;\n                checkStopper = true;\n                break;\n            default:\n                break;\n        }\n        // LineMesh first as it's also a Mesh...\n        if (material.fillMode === 4) {\n            // Check if mesh is unindexed\n            if (!indices.length) {\n                return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n            }\n            return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n        }\n        else {\n            // Check if mesh is unindexed\n            if (!indices.length && this._mesh._unIndexed) {\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\n            }\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\n        }\n    };\n    /**\n     * @param ray\n     * @param positions\n     * @param indices\n     * @param intersectionThreshold\n     * @param fastCheck\n     * @hidden\n     */\n    SubMesh.prototype._intersectLines = function (ray, positions, indices, intersectionThreshold, fastCheck) {\n        var intersectInfo = null;\n        // Line test\n        for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\n            var p0 = positions[indices[index]];\n            var p1 = positions[indices[index + 1]];\n            var length_1 = ray.intersectionSegment(p0, p1, intersectionThreshold);\n            if (length_1 < 0) {\n                continue;\n            }\n            if (fastCheck || !intersectInfo || length_1 < intersectInfo.distance) {\n                intersectInfo = new IntersectionInfo(null, null, length_1);\n                intersectInfo.faceId = index / 2;\n                if (fastCheck) {\n                    break;\n                }\n            }\n        }\n        return intersectInfo;\n    };\n    /**\n     * @param ray\n     * @param positions\n     * @param indices\n     * @param intersectionThreshold\n     * @param fastCheck\n     * @hidden\n     */\n    SubMesh.prototype._intersectUnIndexedLines = function (ray, positions, indices, intersectionThreshold, fastCheck) {\n        var intersectInfo = null;\n        // Line test\n        for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\n            var p0 = positions[index];\n            var p1 = positions[index + 1];\n            var length_2 = ray.intersectionSegment(p0, p1, intersectionThreshold);\n            if (length_2 < 0) {\n                continue;\n            }\n            if (fastCheck || !intersectInfo || length_2 < intersectInfo.distance) {\n                intersectInfo = new IntersectionInfo(null, null, length_2);\n                intersectInfo.faceId = index / 2;\n                if (fastCheck) {\n                    break;\n                }\n            }\n        }\n        return intersectInfo;\n    };\n    /**\n     * @param ray\n     * @param positions\n     * @param indices\n     * @param step\n     * @param checkStopper\n     * @param fastCheck\n     * @param trianglePredicate\n     * @hidden\n     */\n    SubMesh.prototype._intersectTriangles = function (ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {\n        var intersectInfo = null;\n        // Triangles test\n        var faceId = -1;\n        for (var index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\n            faceId++;\n            var indexA = indices[index];\n            var indexB = indices[index + 1];\n            var indexC = indices[index + 2];\n            if (checkStopper && indexC === 0xffffffff) {\n                index += 2;\n                continue;\n            }\n            var p0 = positions[indexA];\n            var p1 = positions[indexB];\n            var p2 = positions[indexC];\n            // stay defensive and don't check against undefined positions.\n            if (!p0 || !p1 || !p2) {\n                continue;\n            }\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\n                continue;\n            }\n            var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n            if (currentIntersectInfo) {\n                if (currentIntersectInfo.distance < 0) {\n                    continue;\n                }\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n                    intersectInfo = currentIntersectInfo;\n                    intersectInfo.faceId = faceId;\n                    if (fastCheck) {\n                        break;\n                    }\n                }\n            }\n        }\n        return intersectInfo;\n    };\n    /**\n     * @param ray\n     * @param positions\n     * @param indices\n     * @param fastCheck\n     * @param trianglePredicate\n     * @hidden\n     */\n    SubMesh.prototype._intersectUnIndexedTriangles = function (ray, positions, indices, fastCheck, trianglePredicate) {\n        var intersectInfo = null;\n        // Triangles test\n        for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n            var p0 = positions[index];\n            var p1 = positions[index + 1];\n            var p2 = positions[index + 2];\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {\n                continue;\n            }\n            var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n            if (currentIntersectInfo) {\n                if (currentIntersectInfo.distance < 0) {\n                    continue;\n                }\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n                    intersectInfo = currentIntersectInfo;\n                    intersectInfo.faceId = index / 3;\n                    if (fastCheck) {\n                        break;\n                    }\n                }\n            }\n        }\n        return intersectInfo;\n    };\n    /** @hidden */\n    SubMesh.prototype._rebuild = function () {\n        if (this._linesIndexBuffer) {\n            this._linesIndexBuffer = null;\n        }\n    };\n    // Clone\n    /**\n     * Creates a new submesh from the passed mesh\n     * @param newMesh defines the new hosting mesh\n     * @param newRenderingMesh defines an optional rendering mesh\n     * @returns the new submesh\n     */\n    SubMesh.prototype.clone = function (newMesh, newRenderingMesh) {\n        var result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\n        if (!this.IsGlobal) {\n            var boundingInfo = this.getBoundingInfo();\n            if (!boundingInfo) {\n                return result;\n            }\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n        }\n        return result;\n    };\n    // Dispose\n    /**\n     * Release associated resources\n     */\n    SubMesh.prototype.dispose = function () {\n        if (this._linesIndexBuffer) {\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\n            this._linesIndexBuffer = null;\n        }\n        // Remove from mesh\n        var index = this._mesh.subMeshes.indexOf(this);\n        this._mesh.subMeshes.splice(index, 1);\n        this.resetDrawCache();\n    };\n    /**\n     * Gets the class name\n     * @returns the string \"SubMesh\".\n     */\n    SubMesh.prototype.getClassName = function () {\n        return \"SubMesh\";\n    };\n    // Statics\n    /**\n     * Creates a new submesh from indices data\n     * @param materialIndex the index of the main mesh material\n     * @param startIndex the index where to start the copy in the mesh indices array\n     * @param indexCount the number of indices to copy then from the startIndex\n     * @param mesh the main mesh to create the submesh from\n     * @param renderingMesh the optional rendering mesh\n     * @param createBoundingBox defines if bounding box should be created for this submesh\n     * @returns a new submesh\n     */\n    SubMesh.CreateFromIndices = function (materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox) {\n        if (createBoundingBox === void 0) { createBoundingBox = true; }\n        var minVertexIndex = Number.MAX_VALUE;\n        var maxVertexIndex = -Number.MAX_VALUE;\n        var whatWillRender = renderingMesh || mesh;\n        var indices = whatWillRender.getIndices();\n        for (var index = startIndex; index < startIndex + indexCount; index++) {\n            var vertexIndex = indices[index];\n            if (vertexIndex < minVertexIndex) {\n                minVertexIndex = vertexIndex;\n            }\n            if (vertexIndex > maxVertexIndex) {\n                maxVertexIndex = vertexIndex;\n            }\n        }\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\n    };\n    return SubMesh;\n}());\nexport { SubMesh };\n//# sourceMappingURL=subMesh.js.map","\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { SubMesh } from \"./subMesh.js\";\n/**\n * @param vector\n * @param positions\n * @param indices\n * @param step\n * @param checkStopper\n * @param ref\n * @hidden\n */\nSubMesh.prototype._projectOnTrianglesToRef = function (vector, positions, indices, step, checkStopper, ref) {\n    // Triangles test\n    var proj = TmpVectors.Vector3[0];\n    var tmp = TmpVectors.Vector3[1];\n    var distance = +Infinity;\n    for (var index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\n        var indexA = indices[index];\n        var indexB = indices[index + 1];\n        var indexC = indices[index + 2];\n        if (checkStopper && indexC === 0xffffffff) {\n            index += 2;\n            continue;\n        }\n        var p0 = positions[indexA];\n        var p1 = positions[indexB];\n        var p2 = positions[indexC];\n        // stay defensive and don't check against undefined positions.\n        if (!p0 || !p1 || !p2) {\n            continue;\n        }\n        var tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\n        if (tmpDist < distance) {\n            proj.copyFrom(tmp);\n            distance = tmpDist;\n        }\n    }\n    ref.copyFrom(proj);\n    return distance;\n};\n/**\n * @param vector\n * @param positions\n * @param indices\n * @param ref\n * @hidden\n */\nSubMesh.prototype._projectOnUnIndexedTrianglesToRef = function (vector, positions, indices, ref) {\n    // Triangles test\n    var proj = TmpVectors.Vector3[0];\n    var tmp = TmpVectors.Vector3[1];\n    var distance = +Infinity;\n    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n        var p0 = positions[index];\n        var p1 = positions[index + 1];\n        var p2 = positions[index + 2];\n        var tmpDist = Vector3.ProjectOnTriangleToRef(vector, p0, p1, p2, tmp);\n        if (tmpDist < distance) {\n            proj.copyFrom(tmp);\n            distance = tmpDist;\n        }\n    }\n    ref.copyFrom(proj);\n    return distance;\n};\nSubMesh.prototype.projectToRef = function (vector, positions, indices, ref) {\n    var material = this.getMaterial();\n    if (!material) {\n        return -1;\n    }\n    var step = 3;\n    var checkStopper = false;\n    switch (material.fillMode) {\n        case 3:\n        case 5:\n        case 6:\n        case 8:\n            return -1;\n        case 7:\n            step = 1;\n            checkStopper = true;\n            break;\n        default:\n            break;\n    }\n    // LineMesh first as it's also a Mesh...\n    if (material.fillMode === 4) {\n        return -1;\n    }\n    else {\n        // Check if mesh is unindexed\n        if (!indices.length && this._mesh._unIndexed) {\n            return this._projectOnUnIndexedTrianglesToRef(vector, positions, indices, ref);\n        }\n        return this._projectOnTrianglesToRef(vector, positions, indices, step, checkStopper, ref);\n    }\n};\n//# sourceMappingURL=subMesh.project.js.map","import { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nMesh.prototype.thinInstanceAdd = function (matrix, refresh) {\n    if (refresh === void 0) { refresh = true; }\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\n    var index = this._thinInstanceDataStorage.instancesCount;\n    if (Array.isArray(matrix)) {\n        for (var i = 0; i < matrix.length; ++i) {\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\n        }\n    }\n    else {\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\n    }\n    return index;\n};\nMesh.prototype.thinInstanceAddSelf = function (refresh) {\n    if (refresh === void 0) { refresh = true; }\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\n};\nMesh.prototype.thinInstanceRegisterAttribute = function (kind, stride) {\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n        kind = VertexBuffer.ColorInstanceKind;\n    }\n    this.removeVerticesData(kind);\n    this._thinInstanceInitializeUserStorage();\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n};\nMesh.prototype.thinInstanceSetMatrixAt = function (index, matrix, refresh) {\n    if (refresh === void 0) { refresh = true; }\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\n        return false;\n    }\n    var matrixData = this._thinInstanceDataStorage.matrixData;\n    matrix.copyToArray(matrixData, index * 16);\n    if (this._thinInstanceDataStorage.worldMatrices) {\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix;\n    }\n    if (refresh) {\n        this.thinInstanceBufferUpdated(\"matrix\");\n        if (!this.doNotSyncBoundingInfo) {\n            this.thinInstanceRefreshBoundingInfo(false);\n        }\n    }\n    return true;\n};\nMesh.prototype.thinInstanceSetAttributeAt = function (kind, index, value, refresh) {\n    if (refresh === void 0) { refresh = true; }\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n        kind = VertexBuffer.ColorInstanceKind;\n    }\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\n        return false;\n    }\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\n    if (refresh) {\n        this.thinInstanceBufferUpdated(kind);\n    }\n    return true;\n};\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\n    get: function () {\n        return this._thinInstanceDataStorage.instancesCount;\n    },\n    set: function (value) {\n        var _a, _b;\n        var matrixData = (_a = this._thinInstanceDataStorage.matrixData) !== null && _a !== void 0 ? _a : (_b = this.source) === null || _b === void 0 ? void 0 : _b._thinInstanceDataStorage.matrixData;\n        var numMaxInstances = matrixData ? matrixData.length / 16 : 0;\n        if (value <= numMaxInstances) {\n            this._thinInstanceDataStorage.instancesCount = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind, buffer, staticBuffer) {\n    if (staticBuffer === void 0) { staticBuffer = false; }\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n        kind = VertexBuffer.ColorInstanceKind;\n    }\n    var matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\n    for (var i = 0; i < 4; i++) {\n        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\n    }\n    return matrixBuffer;\n};\nMesh.prototype.thinInstanceSetBuffer = function (kind, buffer, stride, staticBuffer) {\n    var _a, _b, _c;\n    if (stride === void 0) { stride = 0; }\n    if (staticBuffer === void 0) { staticBuffer = false; }\n    stride = stride || 16;\n    if (kind === \"matrix\") {\n        (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._thinInstanceDataStorage.matrixBuffer = null;\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\n        this._thinInstanceDataStorage.matrixData = buffer;\n        this._thinInstanceDataStorage.worldMatrices = null;\n        if (buffer !== null) {\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\n            if (!this.doNotSyncBoundingInfo) {\n                this.thinInstanceRefreshBoundingInfo(false);\n            }\n        }\n        else {\n            this._thinInstanceDataStorage.instancesCount = 0;\n            if (!this.doNotSyncBoundingInfo) {\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\n                this.refreshBoundingInfo();\n            }\n        }\n    }\n    else if (kind === \"previousMatrix\") {\n        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\n        this._thinInstanceDataStorage.previousMatrixData = buffer;\n        if (buffer !== null) {\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\n        }\n    }\n    else {\n        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\n        // hot switching kind here to preserve backward compatibility\n        if (kind === VertexBuffer.ColorKind) {\n            kind = VertexBuffer.ColorInstanceKind;\n        }\n        if (buffer === null) {\n            if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.data[kind]) {\n                this.removeVerticesData(kind);\n                delete this._userThinInstanceBuffersStorage.data[kind];\n                delete this._userThinInstanceBuffersStorage.strides[kind];\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\n            }\n        }\n        else {\n            this._thinInstanceInitializeUserStorage();\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n        }\n    }\n};\nMesh.prototype.thinInstanceBufferUpdated = function (kind) {\n    var _a, _b, _c;\n    if (kind === \"matrix\") {\n        (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);\n    }\n    else if (kind === \"previousMatrix\") {\n        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);\n    }\n    else {\n        // preserve backward compatibility\n        if (kind === VertexBuffer.ColorKind) {\n            kind = VertexBuffer.ColorInstanceKind;\n        }\n        if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.vertexBuffers[kind]) {\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\n        }\n    }\n};\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind, data, offset) {\n    var _a;\n    if (kind === \"matrix\") {\n        if (this._thinInstanceDataStorage.matrixBuffer) {\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\n        }\n    }\n    else {\n        // preserve backward compatibility\n        if (kind === VertexBuffer.ColorKind) {\n            kind = VertexBuffer.ColorInstanceKind;\n        }\n        if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);\n        }\n    }\n};\nMesh.prototype.thinInstanceGetWorldMatrices = function () {\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n        return [];\n    }\n    var matrixData = this._thinInstanceDataStorage.matrixData;\n    if (!this._thinInstanceDataStorage.worldMatrices) {\n        this._thinInstanceDataStorage.worldMatrices = new Array();\n        for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\n        }\n    }\n    return this._thinInstanceDataStorage.worldMatrices;\n};\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo, applySkeleton, applyMorph) {\n    if (forceRefreshParentInfo === void 0) { forceRefreshParentInfo = false; }\n    if (applySkeleton === void 0) { applySkeleton = false; }\n    if (applyMorph === void 0) { applyMorph = false; }\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n        return;\n    }\n    var vectors = this._thinInstanceDataStorage.boundingVectors;\n    if (forceRefreshParentInfo) {\n        vectors.length = 0;\n        this.refreshBoundingInfo(applySkeleton, applyMorph);\n    }\n    var boundingInfo = this.getBoundingInfo();\n    var matrixData = this._thinInstanceDataStorage.matrixData;\n    if (vectors.length === 0) {\n        for (var v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\n        }\n    }\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\n    for (var i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\n        for (var v = 0; v < vectors.length; ++v) {\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\n        }\n    }\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\n    this._updateBoundingInfo();\n};\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind, numInstances) {\n    var _a, _b, _c;\n    if (numInstances === void 0) { numInstances = 1; }\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n        kind = VertexBuffer.ColorInstanceKind;\n    }\n    var kindIsMatrix = kind === \"matrix\";\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\n        return;\n    }\n    var stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\n    var currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\n    var data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\n    var bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\n    var newSize = currentSize;\n    while (newSize < bufferSize) {\n        newSize *= 2;\n    }\n    if (!data || currentSize != newSize) {\n        if (!data) {\n            data = new Float32Array(newSize);\n        }\n        else {\n            var newData = new Float32Array(newSize);\n            newData.set(data, 0);\n            data = newData;\n        }\n        if (kindIsMatrix) {\n            (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\n            this._thinInstanceDataStorage.matrixData = data;\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\n            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\n                (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\n            }\n        }\n        else {\n            (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) === null || _c === void 0 ? void 0 : _c.dispose();\n            this._userThinInstanceBuffersStorage.data[kind] = data;\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n        }\n    }\n};\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\n    if (!this._userThinInstanceBuffersStorage) {\n        this._userThinInstanceBuffersStorage = {\n            data: {},\n            sizes: {},\n            vertexBuffers: {},\n            strides: {},\n        };\n    }\n};\nMesh.prototype._disposeThinInstanceSpecificData = function () {\n    var _a;\n    if ((_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.matrixBuffer) {\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\n        this._thinInstanceDataStorage.matrixBuffer = null;\n    }\n};\n//# sourceMappingURL=thinInstanceMesh.js.map","import { __decorate, __extends } from \"tslib\";\nimport { serialize, serializeAsVector3, serializeAsQuaternion, SerializationHelper } from \"../Misc/decorators.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Space } from \"../Maths/math.axis.js\";\n/**\n * A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.\n * @see https://doc.babylonjs.com/how_to/transformnode\n */\nvar TransformNode = /** @class */ (function (_super) {\n    __extends(TransformNode, _super);\n    function TransformNode(name, scene, isPure) {\n        if (scene === void 0) { scene = null; }\n        if (isPure === void 0) { isPure = true; }\n        var _this = _super.call(this, name, scene) || this;\n        _this._forward = new Vector3(0, 0, 1);\n        _this._up = new Vector3(0, 1, 0);\n        _this._right = new Vector3(1, 0, 0);\n        // Properties\n        _this._position = Vector3.Zero();\n        _this._rotation = Vector3.Zero();\n        _this._rotationQuaternion = null;\n        _this._scaling = Vector3.One();\n        _this._transformToBoneReferal = null;\n        _this._isAbsoluteSynced = false;\n        _this._billboardMode = TransformNode.BILLBOARDMODE_NONE;\n        _this._preserveParentRotationForBillboard = false;\n        /**\n         * Multiplication factor on scale x/y/z when computing the world matrix. Eg. for a 1x1x1 cube setting this to 2 will make it a 2x2x2 cube\n         */\n        _this.scalingDeterminant = 1;\n        _this._infiniteDistance = false;\n        /**\n         * Gets or sets a boolean indicating that non uniform scaling (when at least one component is different from others) should be ignored.\n         * By default the system will update normals to compensate\n         */\n        _this.ignoreNonUniformScaling = false;\n        /**\n         * Gets or sets a boolean indicating that even if rotationQuaternion is defined, you can keep updating rotation property and Babylon.js will just mix both\n         */\n        _this.reIntegrateRotationIntoRotationQuaternion = false;\n        // Cache\n        /** @hidden */\n        _this._poseMatrix = null;\n        /** @hidden */\n        _this._localMatrix = Matrix.Zero();\n        _this._usePivotMatrix = false;\n        _this._absolutePosition = Vector3.Zero();\n        _this._absoluteScaling = Vector3.Zero();\n        _this._absoluteRotationQuaternion = Quaternion.Identity();\n        _this._pivotMatrix = Matrix.Identity();\n        /** @hidden */\n        _this._postMultiplyPivotMatrix = false;\n        _this._isWorldMatrixFrozen = false;\n        /** @hidden */\n        _this._indexInSceneTransformNodesArray = -1;\n        /**\n         * An event triggered after the world matrix is updated\n         */\n        _this.onAfterWorldMatrixUpdateObservable = new Observable();\n        _this._nonUniformScaling = false;\n        if (isPure) {\n            _this.getScene().addTransformNode(_this);\n        }\n        return _this;\n    }\n    Object.defineProperty(TransformNode.prototype, \"billboardMode\", {\n        /**\n         * Gets or sets the billboard mode. Default is 0.\n         *\n         * | Value | Type | Description |\n         * | --- | --- | --- |\n         * | 0 | BILLBOARDMODE_NONE |  |\n         * | 1 | BILLBOARDMODE_X |  |\n         * | 2 | BILLBOARDMODE_Y |  |\n         * | 4 | BILLBOARDMODE_Z |  |\n         * | 7 | BILLBOARDMODE_ALL |  |\n         *\n         */\n        get: function () {\n            return this._billboardMode;\n        },\n        set: function (value) {\n            if (this._billboardMode === value) {\n                return;\n            }\n            this._billboardMode = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TransformNode.prototype, \"preserveParentRotationForBillboard\", {\n        /**\n         * Gets or sets a boolean indicating that parent rotation should be preserved when using billboards.\n         * This could be useful for glTF objects where parent rotation helps converting from right handed to left handed\n         */\n        get: function () {\n            return this._preserveParentRotationForBillboard;\n        },\n        set: function (value) {\n            if (value === this._preserveParentRotationForBillboard) {\n                return;\n            }\n            this._preserveParentRotationForBillboard = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TransformNode.prototype, \"infiniteDistance\", {\n        /**\n         * Gets or sets the distance of the object to max, often used by skybox\n         */\n        get: function () {\n            return this._infiniteDistance;\n        },\n        set: function (value) {\n            if (this._infiniteDistance === value) {\n                return;\n            }\n            this._infiniteDistance = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Gets a string identifying the name of the class\n     * @returns \"TransformNode\" string\n     */\n    TransformNode.prototype.getClassName = function () {\n        return \"TransformNode\";\n    };\n    Object.defineProperty(TransformNode.prototype, \"position\", {\n        /**\n         * Gets or set the node position (default is (0.0, 0.0, 0.0))\n         */\n        get: function () {\n            return this._position;\n        },\n        set: function (newPosition) {\n            this._position = newPosition;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * return true if a pivot has been set\n     * @returns true if a pivot matrix is used\n     */\n    TransformNode.prototype.isUsingPivotMatrix = function () {\n        return this._usePivotMatrix;\n    };\n    Object.defineProperty(TransformNode.prototype, \"rotation\", {\n        /**\n         * Gets or sets the rotation property : a Vector3 defining the rotation value in radians around each local axis X, Y, Z  (default is (0.0, 0.0, 0.0)).\n         * If rotation quaternion is set, this Vector3 will be ignored and copy from the quaternion\n         */\n        get: function () {\n            return this._rotation;\n        },\n        set: function (newRotation) {\n            this._rotation = newRotation;\n            this._rotationQuaternion = null;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TransformNode.prototype, \"scaling\", {\n        /**\n         * Gets or sets the scaling property : a Vector3 defining the node scaling along each local axis X, Y, Z (default is (0.0, 0.0, 0.0)).\n         */\n        get: function () {\n            return this._scaling;\n        },\n        set: function (newScaling) {\n            this._scaling = newScaling;\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TransformNode.prototype, \"rotationQuaternion\", {\n        /**\n         * Gets or sets the rotation Quaternion property : this a Quaternion object defining the node rotation by using a unit quaternion (undefined by default, but can be null).\n         * If set, only the rotationQuaternion is then used to compute the node rotation (ie. node.rotation will be ignored)\n         */\n        get: function () {\n            return this._rotationQuaternion;\n        },\n        set: function (quaternion) {\n            this._rotationQuaternion = quaternion;\n            //reset the rotation vector.\n            if (quaternion) {\n                this._rotation.setAll(0.0);\n            }\n            this._isDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TransformNode.prototype, \"forward\", {\n        /**\n         * The forward direction of that transform in world space.\n         */\n        get: function () {\n            Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1.0 : 1.0, this.getWorldMatrix(), this._forward);\n            return this._forward.normalize();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TransformNode.prototype, \"up\", {\n        /**\n         * The up direction of that transform in world space.\n         */\n        get: function () {\n            Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);\n            return this._up.normalize();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TransformNode.prototype, \"right\", {\n        /**\n         * The right direction of that transform in world space.\n         */\n        get: function () {\n            Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1.0 : 1.0, 0, 0, this.getWorldMatrix(), this._right);\n            return this._right.normalize();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Copies the parameter passed Matrix into the mesh Pose matrix.\n     * @param matrix the matrix to copy the pose from\n     * @returns this TransformNode.\n     */\n    TransformNode.prototype.updatePoseMatrix = function (matrix) {\n        if (!this._poseMatrix) {\n            this._poseMatrix = matrix.clone();\n            return this;\n        }\n        this._poseMatrix.copyFrom(matrix);\n        return this;\n    };\n    /**\n     * Returns the mesh Pose matrix.\n     * @returns the pose matrix\n     */\n    TransformNode.prototype.getPoseMatrix = function () {\n        if (!this._poseMatrix) {\n            this._poseMatrix = Matrix.Identity();\n        }\n        return this._poseMatrix;\n    };\n    /** @hidden */\n    TransformNode.prototype._isSynchronized = function () {\n        var cache = this._cache;\n        if (this._billboardMode !== cache.billboardMode || this._billboardMode !== TransformNode.BILLBOARDMODE_NONE) {\n            return false;\n        }\n        if (cache.pivotMatrixUpdated) {\n            return false;\n        }\n        if (this._infiniteDistance) {\n            return false;\n        }\n        if (this._position._isDirty) {\n            return false;\n        }\n        if (this._scaling._isDirty) {\n            return false;\n        }\n        if ((this._rotationQuaternion && this._rotationQuaternion._isDirty) || this._rotation._isDirty) {\n            return false;\n        }\n        return true;\n    };\n    /** @hidden */\n    TransformNode.prototype._initCache = function () {\n        _super.prototype._initCache.call(this);\n        var cache = this._cache;\n        cache.localMatrixUpdated = false;\n        cache.billboardMode = -1;\n        cache.infiniteDistance = false;\n    };\n    Object.defineProperty(TransformNode.prototype, \"absolutePosition\", {\n        /**\n         * Returns the current mesh absolute position.\n         * Returns a Vector3.\n         */\n        get: function () {\n            return this.getAbsolutePosition();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TransformNode.prototype, \"absoluteScaling\", {\n        /**\n         * Returns the current mesh absolute scaling.\n         * Returns a Vector3.\n         */\n        get: function () {\n            this._syncAbsoluteScalingAndRotation();\n            return this._absoluteScaling;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TransformNode.prototype, \"absoluteRotationQuaternion\", {\n        /**\n         * Returns the current mesh absolute rotation.\n         * Returns a Quaternion.\n         */\n        get: function () {\n            this._syncAbsoluteScalingAndRotation();\n            return this._absoluteRotationQuaternion;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Sets a new matrix to apply before all other transformation\n     * @param matrix defines the transform matrix\n     * @returns the current TransformNode\n     */\n    TransformNode.prototype.setPreTransformMatrix = function (matrix) {\n        return this.setPivotMatrix(matrix, false);\n    };\n    /**\n     * Sets a new pivot matrix to the current node\n     * @param matrix defines the new pivot matrix to use\n     * @param postMultiplyPivotMatrix defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect\n     * @returns the current TransformNode\n     */\n    TransformNode.prototype.setPivotMatrix = function (matrix, postMultiplyPivotMatrix) {\n        if (postMultiplyPivotMatrix === void 0) { postMultiplyPivotMatrix = true; }\n        this._pivotMatrix.copyFrom(matrix);\n        this._usePivotMatrix = !this._pivotMatrix.isIdentity();\n        this._cache.pivotMatrixUpdated = true;\n        this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;\n        if (this._postMultiplyPivotMatrix) {\n            if (!this._pivotMatrixInverse) {\n                this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);\n            }\n            else {\n                this._pivotMatrix.invertToRef(this._pivotMatrixInverse);\n            }\n        }\n        return this;\n    };\n    /**\n     * Returns the mesh pivot matrix.\n     * Default : Identity.\n     * @returns the matrix\n     */\n    TransformNode.prototype.getPivotMatrix = function () {\n        return this._pivotMatrix;\n    };\n    /**\n     * Instantiate (when possible) or clone that node with its hierarchy\n     * @param newParent defines the new parent to use for the instance (or clone)\n     * @param options defines options to configure how copy is done\n     * @param options.doNotInstantiate\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\n     * @returns an instance (or a clone) of the current node with its hierarchy\n     */\n    TransformNode.prototype.instantiateHierarchy = function (newParent, options, onNewNodeCreated) {\n        if (newParent === void 0) { newParent = null; }\n        var clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true);\n        if (clone) {\n            if (onNewNodeCreated) {\n                onNewNodeCreated(this, clone);\n            }\n        }\n        for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {\n            var child = _a[_i];\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\n        }\n        return clone;\n    };\n    /**\n     * Prevents the World matrix to be computed any longer\n     * @param newWorldMatrix defines an optional matrix to use as world matrix\n     * @param decompose defines whether to decompose the given newWorldMatrix or directly assign\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.freezeWorldMatrix = function (newWorldMatrix, decompose) {\n        if (newWorldMatrix === void 0) { newWorldMatrix = null; }\n        if (decompose === void 0) { decompose = false; }\n        if (newWorldMatrix) {\n            if (decompose) {\n                this._rotation.setAll(0);\n                this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();\n                newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);\n                this.computeWorldMatrix(true);\n            }\n            else {\n                this._worldMatrix = newWorldMatrix;\n                this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\n                this._afterComputeWorldMatrix();\n            }\n        }\n        else {\n            this._isWorldMatrixFrozen = false; // no guarantee world is not already frozen, switch off temporarily\n            this.computeWorldMatrix(true);\n        }\n        this._isDirty = false;\n        this._isWorldMatrixFrozen = true;\n        return this;\n    };\n    /**\n     * Allows back the World matrix computation.\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.unfreezeWorldMatrix = function () {\n        this._isWorldMatrixFrozen = false;\n        this.computeWorldMatrix(true);\n        return this;\n    };\n    Object.defineProperty(TransformNode.prototype, \"isWorldMatrixFrozen\", {\n        /**\n         * True if the World matrix has been frozen.\n         */\n        get: function () {\n            return this._isWorldMatrixFrozen;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the mesh absolute position in the World.\n     * @returns a Vector3.\n     */\n    TransformNode.prototype.getAbsolutePosition = function () {\n        this.computeWorldMatrix();\n        return this._absolutePosition;\n    };\n    /**\n     * Sets the mesh absolute position in the World from a Vector3 or an Array(3).\n     * @param absolutePosition the absolute position to set\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.setAbsolutePosition = function (absolutePosition) {\n        if (!absolutePosition) {\n            return this;\n        }\n        var absolutePositionX;\n        var absolutePositionY;\n        var absolutePositionZ;\n        if (absolutePosition.x === undefined) {\n            if (arguments.length < 3) {\n                return this;\n            }\n            absolutePositionX = arguments[0];\n            absolutePositionY = arguments[1];\n            absolutePositionZ = arguments[2];\n        }\n        else {\n            absolutePositionX = absolutePosition.x;\n            absolutePositionY = absolutePosition.y;\n            absolutePositionZ = absolutePosition.z;\n        }\n        if (this.parent) {\n            var invertParentWorldMatrix = TmpVectors.Matrix[0];\n            this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);\n            Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);\n        }\n        else {\n            this.position.x = absolutePositionX;\n            this.position.y = absolutePositionY;\n            this.position.z = absolutePositionZ;\n        }\n        this._absolutePosition.copyFrom(absolutePosition);\n        return this;\n    };\n    /**\n     * Sets the mesh position in its local space.\n     * @param vector3 the position to set in localspace\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.setPositionWithLocalVector = function (vector3) {\n        this.computeWorldMatrix();\n        this.position = Vector3.TransformNormal(vector3, this._localMatrix);\n        return this;\n    };\n    /**\n     * Returns the mesh position in the local space from the current World matrix values.\n     * @returns a new Vector3.\n     */\n    TransformNode.prototype.getPositionExpressedInLocalSpace = function () {\n        this.computeWorldMatrix();\n        var invLocalWorldMatrix = TmpVectors.Matrix[0];\n        this._localMatrix.invertToRef(invLocalWorldMatrix);\n        return Vector3.TransformNormal(this.position, invLocalWorldMatrix);\n    };\n    /**\n     * Translates the mesh along the passed Vector3 in its local space.\n     * @param vector3 the distance to translate in localspace\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.locallyTranslate = function (vector3) {\n        this.computeWorldMatrix(true);\n        this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);\n        return this;\n    };\n    /**\n     * Orients a mesh towards a target point. Mesh must be drawn facing user.\n     * @param targetPoint the position (must be in same space as current mesh) to look at\n     * @param yawCor optional yaw (y-axis) correction in radians\n     * @param pitchCor optional pitch (x-axis) correction in radians\n     * @param rollCor optional roll (z-axis) correction in radians\n     * @param space the chosen space of the target\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.lookAt = function (targetPoint, yawCor, pitchCor, rollCor, space) {\n        if (yawCor === void 0) { yawCor = 0; }\n        if (pitchCor === void 0) { pitchCor = 0; }\n        if (rollCor === void 0) { rollCor = 0; }\n        if (space === void 0) { space = Space.LOCAL; }\n        var dv = TransformNode._LookAtVectorCache;\n        var pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();\n        targetPoint.subtractToRef(pos, dv);\n        this.setDirection(dv, yawCor, pitchCor, rollCor);\n        // Correct for parent's rotation offset\n        if (space === Space.WORLD && this.parent) {\n            if (this.rotationQuaternion) {\n                // Get local rotation matrix of the looking object\n                var rotationMatrix = TmpVectors.Matrix[0];\n                this.rotationQuaternion.toRotationMatrix(rotationMatrix);\n                // Offset rotation by parent's inverted rotation matrix to correct in world space\n                var parentRotationMatrix = TmpVectors.Matrix[1];\n                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\n                parentRotationMatrix.invert();\n                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\n                this.rotationQuaternion.fromRotationMatrix(rotationMatrix);\n            }\n            else {\n                // Get local rotation matrix of the looking object\n                var quaternionRotation = TmpVectors.Quaternion[0];\n                Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);\n                var rotationMatrix = TmpVectors.Matrix[0];\n                quaternionRotation.toRotationMatrix(rotationMatrix);\n                // Offset rotation by parent's inverted rotation matrix to correct in world space\n                var parentRotationMatrix = TmpVectors.Matrix[1];\n                this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);\n                parentRotationMatrix.invert();\n                rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);\n                quaternionRotation.fromRotationMatrix(rotationMatrix);\n                quaternionRotation.toEulerAnglesToRef(this.rotation);\n            }\n        }\n        return this;\n    };\n    /**\n     * Returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\n     * This Vector3 is expressed in the World space.\n     * @param localAxis axis to rotate\n     * @returns a new Vector3 that is the localAxis, expressed in the mesh local space, rotated like the mesh.\n     */\n    TransformNode.prototype.getDirection = function (localAxis) {\n        var result = Vector3.Zero();\n        this.getDirectionToRef(localAxis, result);\n        return result;\n    };\n    /**\n     * Sets the Vector3 \"result\" as the rotated Vector3 \"localAxis\" in the same rotation than the mesh.\n     * localAxis is expressed in the mesh local space.\n     * result is computed in the World space from the mesh World matrix.\n     * @param localAxis axis to rotate\n     * @param result the resulting transformnode\n     * @returns this TransformNode.\n     */\n    TransformNode.prototype.getDirectionToRef = function (localAxis, result) {\n        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\n        return this;\n    };\n    /**\n     * Sets this transform node rotation to the given local axis.\n     * @param localAxis the axis in local space\n     * @param yawCor optional yaw (y-axis) correction in radians\n     * @param pitchCor optional pitch (x-axis) correction in radians\n     * @param rollCor optional roll (z-axis) correction in radians\n     * @returns this TransformNode\n     */\n    TransformNode.prototype.setDirection = function (localAxis, yawCor, pitchCor, rollCor) {\n        if (yawCor === void 0) { yawCor = 0; }\n        if (pitchCor === void 0) { pitchCor = 0; }\n        if (rollCor === void 0) { rollCor = 0; }\n        var yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;\n        var len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\n        var pitch = -Math.atan2(localAxis.y, len);\n        if (this.rotationQuaternion) {\n            Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);\n        }\n        else {\n            this.rotation.x = pitch + pitchCor;\n            this.rotation.y = yaw + yawCor;\n            this.rotation.z = rollCor;\n        }\n        return this;\n    };\n    /**\n     * Sets a new pivot point to the current node\n     * @param point defines the new pivot point to use\n     * @param space defines if the point is in world or local space (local by default)\n     * @returns the current TransformNode\n     */\n    TransformNode.prototype.setPivotPoint = function (point, space) {\n        if (space === void 0) { space = Space.LOCAL; }\n        if (this.getScene().getRenderId() == 0) {\n            this.computeWorldMatrix(true);\n        }\n        var wm = this.getWorldMatrix();\n        if (space == Space.WORLD) {\n            var tmat = TmpVectors.Matrix[0];\n            wm.invertToRef(tmat);\n            point = Vector3.TransformCoordinates(point, tmat);\n        }\n        return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);\n    };\n    /**\n     * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.\n     * @returns the pivot point\n     */\n    TransformNode.prototype.getPivotPoint = function () {\n        var point = Vector3.Zero();\n        this.getPivotPointToRef(point);\n        return point;\n    };\n    /**\n     * Sets the passed Vector3 \"result\" with the coordinates of the mesh pivot point in the local space.\n     * @param result the vector3 to store the result\n     * @returns this TransformNode.\n     */\n    TransformNode.prototype.getPivotPointToRef = function (result) {\n        result.x = -this._pivotMatrix.m[12];\n        result.y = -this._pivotMatrix.m[13];\n        result.z = -this._pivotMatrix.m[14];\n        return this;\n    };\n    /**\n     * Returns a new Vector3 set with the mesh pivot point World coordinates.\n     * @returns a new Vector3 set with the mesh pivot point World coordinates.\n     */\n    TransformNode.prototype.getAbsolutePivotPoint = function () {\n        var point = Vector3.Zero();\n        this.getAbsolutePivotPointToRef(point);\n        return point;\n    };\n    /**\n     * Sets the Vector3 \"result\" coordinates with the mesh pivot point World coordinates.\n     * @param result vector3 to store the result\n     * @returns this TransformNode.\n     */\n    TransformNode.prototype.getAbsolutePivotPointToRef = function (result) {\n        this.getPivotPointToRef(result);\n        Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);\n        return this;\n    };\n    /**\n     * Flag the transform node as dirty (Forcing it to update everything)\n     * @param property if set to \"rotation\" the objects rotationQuaternion will be set to null\n     * @returns this  node\n     */\n    TransformNode.prototype.markAsDirty = function (property) {\n        // We need to explicitly update the children\n        // as the scene.evaluateActiveMeshes will not poll the transform nodes\n        if (this._children) {\n            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                child.markAsDirty(property);\n            }\n        }\n        return _super.prototype.markAsDirty.call(this, property);\n    };\n    /**\n     * Defines the passed node as the parent of the current node.\n     * The node will remain exactly where it is and its position / rotation will be updated accordingly.\n     * Note that if the mesh has a pivot matrix / point defined it will be applied after the parent was updated.\n     * In that case the node will not remain in the same space as it is, as the pivot will be applied.\n     * @see https://doc.babylonjs.com/how_to/parenting\n     * @param node the node ot set as the parent\n     * @param preserveScalingSign if true, keep scaling sign of child. Otherwise, scaling sign might change.\n     * @returns this TransformNode.\n     */\n    TransformNode.prototype.setParent = function (node, preserveScalingSign) {\n        if (preserveScalingSign === void 0) { preserveScalingSign = false; }\n        if (!node && !this.parent) {\n            return this;\n        }\n        var quatRotation = TmpVectors.Quaternion[0];\n        var position = TmpVectors.Vector3[0];\n        var scale = TmpVectors.Vector3[1];\n        var invParentMatrix = TmpVectors.Matrix[1];\n        Matrix.IdentityToRef(invParentMatrix);\n        var composedMatrix = TmpVectors.Matrix[0];\n        this.computeWorldMatrix(true);\n        var currentRotation = this.rotationQuaternion;\n        if (!currentRotation) {\n            currentRotation = TransformNode._TmpRotation;\n            Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);\n        }\n        // current global transformation without pivot\n        Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);\n        if (this.parent) {\n            composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);\n        }\n        // is a node was set, calculate the difference between this and the node\n        if (node) {\n            node.computeWorldMatrix(true).invertToRef(invParentMatrix);\n            composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);\n        }\n        composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : undefined);\n        if (this.rotationQuaternion) {\n            this.rotationQuaternion.copyFrom(quatRotation);\n        }\n        else {\n            quatRotation.toEulerAnglesToRef(this.rotation);\n        }\n        this.scaling.copyFrom(scale);\n        this.position.copyFrom(position);\n        this.parent = node;\n        return this;\n    };\n    Object.defineProperty(TransformNode.prototype, \"nonUniformScaling\", {\n        /**\n         * True if the scaling property of this object is non uniform eg. (1,2,1)\n         */\n        get: function () {\n            return this._nonUniformScaling;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * @param value\n     * @hidden\n     */\n    TransformNode.prototype._updateNonUniformScalingState = function (value) {\n        if (this._nonUniformScaling === value) {\n            return false;\n        }\n        this._nonUniformScaling = value;\n        return true;\n    };\n    /**\n     * Attach the current TransformNode to another TransformNode associated with a bone\n     * @param bone Bone affecting the TransformNode\n     * @param affectedTransformNode TransformNode associated with the bone\n     * @returns this object\n     */\n    TransformNode.prototype.attachToBone = function (bone, affectedTransformNode) {\n        this._currentParentWhenAttachingToBone = this.parent;\n        this._transformToBoneReferal = affectedTransformNode;\n        this.parent = bone;\n        bone.getSkeleton().prepare();\n        if (bone.getWorldMatrix().determinant() < 0) {\n            this.scalingDeterminant *= -1;\n        }\n        return this;\n    };\n    /**\n     * Detach the transform node if its associated with a bone\n     * @param resetToPreviousParent Indicates if the parent that was in effect when attachToBone was called should be set back or if we should set parent to null instead (defaults to the latter)\n     * @returns this object\n     */\n    TransformNode.prototype.detachFromBone = function (resetToPreviousParent) {\n        if (resetToPreviousParent === void 0) { resetToPreviousParent = false; }\n        if (!this.parent) {\n            if (resetToPreviousParent) {\n                this.parent = this._currentParentWhenAttachingToBone;\n            }\n            return this;\n        }\n        if (this.parent.getWorldMatrix().determinant() < 0) {\n            this.scalingDeterminant *= -1;\n        }\n        this._transformToBoneReferal = null;\n        if (resetToPreviousParent) {\n            this.parent = this._currentParentWhenAttachingToBone;\n        }\n        else {\n            this.parent = null;\n        }\n        return this;\n    };\n    /**\n     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.\n     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\n     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\n     * The passed axis is also normalized.\n     * @param axis the axis to rotate around\n     * @param amount the amount to rotate in radians\n     * @param space Space to rotate in (Default: local)\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.rotate = function (axis, amount, space) {\n        axis.normalize();\n        if (!this.rotationQuaternion) {\n            this.rotationQuaternion = this.rotation.toQuaternion();\n            this.rotation.setAll(0);\n        }\n        var rotationQuaternion;\n        if (!space || space === Space.LOCAL) {\n            rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\n            this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);\n        }\n        else {\n            if (this.parent) {\n                var invertParentWorldMatrix = TmpVectors.Matrix[0];\n                this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);\n                axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);\n            }\n            rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);\n            rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n        }\n        return this;\n    };\n    /**\n     * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.\n     * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\n     * The passed axis is also normalized. .\n     * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm\n     * @param point the point to rotate around\n     * @param axis the axis to rotate around\n     * @param amount the amount to rotate in radians\n     * @returns the TransformNode\n     */\n    TransformNode.prototype.rotateAround = function (point, axis, amount) {\n        axis.normalize();\n        if (!this.rotationQuaternion) {\n            this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n            this.rotation.setAll(0);\n        }\n        var tmpVector = TmpVectors.Vector3[0];\n        var finalScale = TmpVectors.Vector3[1];\n        var finalTranslation = TmpVectors.Vector3[2];\n        var finalRotation = TmpVectors.Quaternion[0];\n        var translationMatrix = TmpVectors.Matrix[0]; // T\n        var translationMatrixInv = TmpVectors.Matrix[1]; // T'\n        var rotationMatrix = TmpVectors.Matrix[2]; // R\n        var finalMatrix = TmpVectors.Matrix[3]; // T' x R x T\n        point.subtractToRef(this.position, tmpVector);\n        Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix); // T\n        Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv); // T'\n        Matrix.RotationAxisToRef(axis, amount, rotationMatrix); // R\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x T\n        finalMatrix.decompose(finalScale, finalRotation, finalTranslation);\n        this.position.addInPlace(finalTranslation);\n        finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n        return this;\n    };\n    /**\n     * Translates the mesh along the axis vector for the passed distance in the given space.\n     * space (default LOCAL) can be either Space.LOCAL, either Space.WORLD.\n     * @param axis the axis to translate in\n     * @param distance the distance to translate\n     * @param space Space to rotate in (Default: local)\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.translate = function (axis, distance, space) {\n        var displacementVector = axis.scale(distance);\n        if (!space || space === Space.LOCAL) {\n            var tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);\n            this.setPositionWithLocalVector(tempV3);\n        }\n        else {\n            this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));\n        }\n        return this;\n    };\n    /**\n     * Adds a rotation step to the mesh current rotation.\n     * x, y, z are Euler angles expressed in radians.\n     * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.\n     * This means this rotation is made in the mesh local space only.\n     * It's useful to set a custom rotation order different from the BJS standard one YXZ.\n     * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.\n     * ```javascript\n     * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);\n     * ```\n     * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.\n     * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.\n     * @param x Rotation to add\n     * @param y Rotation to add\n     * @param z Rotation to add\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.addRotation = function (x, y, z) {\n        var rotationQuaternion;\n        if (this.rotationQuaternion) {\n            rotationQuaternion = this.rotationQuaternion;\n        }\n        else {\n            rotationQuaternion = TmpVectors.Quaternion[1];\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);\n        }\n        var accumulation = TmpVectors.Quaternion[0];\n        Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);\n        rotationQuaternion.multiplyInPlace(accumulation);\n        if (!this.rotationQuaternion) {\n            rotationQuaternion.toEulerAnglesToRef(this.rotation);\n        }\n        return this;\n    };\n    /**\n     * @hidden\n     */\n    TransformNode.prototype._getEffectiveParent = function () {\n        return this.parent;\n    };\n    /**\n     * Computes the world matrix of the node\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\n     * @returns the world matrix\n     */\n    TransformNode.prototype.computeWorldMatrix = function (force) {\n        if (this._isWorldMatrixFrozen && !this._isDirty) {\n            return this._worldMatrix;\n        }\n        var currentRenderId = this.getScene().getRenderId();\n        if (!this._isDirty && !force && (this._currentRenderId === currentRenderId || this.isSynchronized())) {\n            this._currentRenderId = currentRenderId;\n            return this._worldMatrix;\n        }\n        var camera = this.getScene().activeCamera;\n        var useBillboardPosition = (this._billboardMode & TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;\n        var useBillboardPath = this._billboardMode !== TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;\n        this._updateCache();\n        var cache = this._cache;\n        cache.pivotMatrixUpdated = false;\n        cache.billboardMode = this.billboardMode;\n        cache.infiniteDistance = this.infiniteDistance;\n        cache.parent = this._parentNode;\n        this._currentRenderId = currentRenderId;\n        this._childUpdateId += 1;\n        this._isDirty = false;\n        this._position._isDirty = false;\n        this._rotation._isDirty = false;\n        this._scaling._isDirty = false;\n        var parent = this._getEffectiveParent();\n        // Scaling\n        var scaling = TransformNode._TmpScaling;\n        var translation = this._position;\n        // Translation\n        if (this._infiniteDistance) {\n            if (!this.parent && camera) {\n                var cameraWorldMatrix = camera.getWorldMatrix();\n                var cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);\n                translation = TransformNode._TmpTranslation;\n                translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);\n            }\n        }\n        // Scaling\n        scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);\n        // Rotation\n        var rotation;\n        if (this._rotationQuaternion) {\n            this._rotationQuaternion._isDirty = false;\n            rotation = this._rotationQuaternion;\n            if (this.reIntegrateRotationIntoRotationQuaternion) {\n                var len = this.rotation.lengthSquared();\n                if (len) {\n                    this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));\n                    this._rotation.copyFromFloats(0, 0, 0);\n                }\n            }\n        }\n        else {\n            rotation = TransformNode._TmpRotation;\n            Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);\n        }\n        // Compose\n        if (this._usePivotMatrix) {\n            var scaleMatrix = TmpVectors.Matrix[1];\n            Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);\n            // Rotation\n            var rotationMatrix = TmpVectors.Matrix[0];\n            rotation.toRotationMatrix(rotationMatrix);\n            // Composing transformations\n            this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\n            TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);\n            // Post multiply inverse of pivotMatrix\n            if (this._postMultiplyPivotMatrix) {\n                this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);\n            }\n            this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);\n        }\n        else {\n            Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);\n        }\n        // Parent\n        if (parent && parent.getWorldMatrix) {\n            if (force) {\n                parent.computeWorldMatrix(force);\n            }\n            if (useBillboardPath) {\n                if (this._transformToBoneReferal) {\n                    parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);\n                }\n                else {\n                    TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());\n                }\n                // Extract scaling and translation from parent\n                var translation_1 = TmpVectors.Vector3[5];\n                var scale = TmpVectors.Vector3[6];\n                TmpVectors.Matrix[7].decompose(scale, undefined, translation_1);\n                Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);\n                TmpVectors.Matrix[7].setTranslation(translation_1);\n                this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);\n            }\n            else {\n                if (this._transformToBoneReferal) {\n                    this._localMatrix.multiplyToRef(parent.getWorldMatrix(), TmpVectors.Matrix[6]);\n                    TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);\n                }\n                else {\n                    this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);\n                }\n            }\n            this._markSyncedWithParent();\n        }\n        else {\n            this._worldMatrix.copyFrom(this._localMatrix);\n        }\n        // Billboarding based on camera orientation (testing PG:http://www.babylonjs-playground.com/#UJEIL#13)\n        if (useBillboardPath && camera && this.billboardMode && !useBillboardPosition) {\n            var storedTranslation = TmpVectors.Vector3[0];\n            this._worldMatrix.getTranslationToRef(storedTranslation); // Save translation\n            // Cancel camera rotation\n            TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());\n            TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);\n            TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);\n            if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\n                TmpVectors.Matrix[0].decompose(undefined, TmpVectors.Quaternion[0], undefined);\n                var eulerAngles = TmpVectors.Vector3[1];\n                TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\n                    eulerAngles.x = 0;\n                }\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\n                    eulerAngles.y = 0;\n                }\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\n                    eulerAngles.z = 0;\n                }\n                Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\n            }\n            this._worldMatrix.setTranslationFromFloats(0, 0, 0);\n            this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);\n            // Restore translation\n            this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\n        }\n        // Billboarding based on camera position\n        else if (useBillboardPath && camera && this.billboardMode && useBillboardPosition) {\n            var storedTranslation = TmpVectors.Vector3[0];\n            // Save translation\n            this._worldMatrix.getTranslationToRef(storedTranslation);\n            // Compute camera position in local space\n            var cameraPosition = camera.globalPosition;\n            this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);\n            var camInObjSpace = TmpVectors.Vector3[1];\n            Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);\n            camInObjSpace.normalize();\n            // Find the lookAt info in local space\n            var yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;\n            var len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);\n            var pitch = -Math.atan2(camInObjSpace.y, len);\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);\n            if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {\n                var eulerAngles = TmpVectors.Vector3[1];\n                TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {\n                    eulerAngles.x = 0;\n                }\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {\n                    eulerAngles.y = 0;\n                }\n                if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {\n                    eulerAngles.z = 0;\n                }\n                Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);\n            }\n            else {\n                Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);\n            }\n            // Cancel translation\n            this._worldMatrix.setTranslationFromFloats(0, 0, 0);\n            // Rotate according to lookat (diff from local to lookat)\n            this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);\n            // Restore translation\n            this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);\n        }\n        // Normal matrix\n        if (!this.ignoreNonUniformScaling) {\n            if (this._scaling.isNonUniformWithinEpsilon(0.000001)) {\n                this._updateNonUniformScalingState(true);\n            }\n            else if (parent && parent._nonUniformScaling) {\n                this._updateNonUniformScalingState(parent._nonUniformScaling);\n            }\n            else {\n                this._updateNonUniformScalingState(false);\n            }\n        }\n        else {\n            this._updateNonUniformScalingState(false);\n        }\n        this._afterComputeWorldMatrix();\n        // Absolute position\n        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\n        this._isAbsoluteSynced = false;\n        // Callbacks\n        this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);\n        if (!this._poseMatrix) {\n            this._poseMatrix = Matrix.Invert(this._worldMatrix);\n        }\n        // Cache the determinant\n        this._worldMatrixDeterminantIsDirty = true;\n        return this._worldMatrix;\n    };\n    /**\n     * Resets this nodeTransform's local matrix to Matrix.Identity().\n     * @param independentOfChildren indicates if all child nodeTransform's world-space transform should be preserved.\n     */\n    TransformNode.prototype.resetLocalMatrix = function (independentOfChildren) {\n        if (independentOfChildren === void 0) { independentOfChildren = true; }\n        this.computeWorldMatrix();\n        if (independentOfChildren) {\n            var children = this.getChildren();\n            for (var i = 0; i < children.length; ++i) {\n                var child = children[i];\n                if (child) {\n                    child.computeWorldMatrix();\n                    var bakedMatrix = TmpVectors.Matrix[0];\n                    child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);\n                    var tmpRotationQuaternion = TmpVectors.Quaternion[0];\n                    bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);\n                    if (child.rotationQuaternion) {\n                        child.rotationQuaternion.copyFrom(tmpRotationQuaternion);\n                    }\n                    else {\n                        tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);\n                    }\n                }\n            }\n        }\n        this.scaling.copyFromFloats(1, 1, 1);\n        this.position.copyFromFloats(0, 0, 0);\n        this.rotation.copyFromFloats(0, 0, 0);\n        //only if quaternion is already set\n        if (this.rotationQuaternion) {\n            this.rotationQuaternion = Quaternion.Identity();\n        }\n        this._worldMatrix = Matrix.Identity();\n    };\n    TransformNode.prototype._afterComputeWorldMatrix = function () { };\n    /**\n     * If you'd like to be called back after the mesh position, rotation or scaling has been updated.\n     * @param func callback function to add\n     *\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.registerAfterWorldMatrixUpdate = function (func) {\n        this.onAfterWorldMatrixUpdateObservable.add(func);\n        return this;\n    };\n    /**\n     * Removes a registered callback function.\n     * @param func callback function to remove\n     * @returns the TransformNode.\n     */\n    TransformNode.prototype.unregisterAfterWorldMatrixUpdate = function (func) {\n        this.onAfterWorldMatrixUpdateObservable.removeCallback(func);\n        return this;\n    };\n    /**\n     * Gets the position of the current mesh in camera space\n     * @param camera defines the camera to use\n     * @returns a position\n     */\n    TransformNode.prototype.getPositionInCameraSpace = function (camera) {\n        if (camera === void 0) { camera = null; }\n        if (!camera) {\n            camera = this.getScene().activeCamera;\n        }\n        return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());\n    };\n    /**\n     * Returns the distance from the mesh to the active camera\n     * @param camera defines the camera to use\n     * @returns the distance\n     */\n    TransformNode.prototype.getDistanceToCamera = function (camera) {\n        if (camera === void 0) { camera = null; }\n        if (!camera) {\n            camera = this.getScene().activeCamera;\n        }\n        return this.getAbsolutePosition().subtract(camera.globalPosition).length();\n    };\n    /**\n     * Clone the current transform node\n     * @param name Name of the new clone\n     * @param newParent New parent for the clone\n     * @param doNotCloneChildren Do not clone children hierarchy\n     * @returns the new transform node\n     */\n    TransformNode.prototype.clone = function (name, newParent, doNotCloneChildren) {\n        var _this = this;\n        var result = SerializationHelper.Clone(function () { return new TransformNode(name, _this.getScene()); }, this);\n        result.name = name;\n        result.id = name;\n        if (newParent) {\n            result.parent = newParent;\n        }\n        if (!doNotCloneChildren) {\n            // Children\n            var directDescendants = this.getDescendants(true);\n            for (var index = 0; index < directDescendants.length; index++) {\n                var child = directDescendants[index];\n                if (child.clone) {\n                    child.clone(name + \".\" + child.name, result);\n                }\n            }\n        }\n        return result;\n    };\n    /**\n     * Serializes the objects information.\n     * @param currentSerializationObject defines the object to serialize in\n     * @returns the serialized object\n     */\n    TransformNode.prototype.serialize = function (currentSerializationObject) {\n        var serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);\n        serializationObject.type = this.getClassName();\n        serializationObject.uniqueId = this.uniqueId;\n        // Parent\n        if (this.parent) {\n            serializationObject.parentId = this.parent.uniqueId;\n        }\n        serializationObject.localMatrix = this.getPivotMatrix().asArray();\n        serializationObject.isEnabled = this.isEnabled();\n        // Parent\n        if (this.parent) {\n            serializationObject.parentId = this.parent.uniqueId;\n        }\n        return serializationObject;\n    };\n    // Statics\n    /**\n     * Returns a new TransformNode object parsed from the source provided.\n     * @param parsedTransformNode is the source.\n     * @param scene the scene the object belongs to\n     * @param rootUrl is a string, it's the root URL to prefix the `delayLoadingFile` property with\n     * @returns a new TransformNode object parsed from the source provided.\n     */\n    TransformNode.Parse = function (parsedTransformNode, scene, rootUrl) {\n        var transformNode = SerializationHelper.Parse(function () { return new TransformNode(parsedTransformNode.name, scene); }, parsedTransformNode, scene, rootUrl);\n        if (parsedTransformNode.localMatrix) {\n            transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));\n        }\n        else if (parsedTransformNode.pivotMatrix) {\n            transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));\n        }\n        transformNode.setEnabled(parsedTransformNode.isEnabled);\n        // Parent\n        if (parsedTransformNode.parentId !== undefined) {\n            transformNode._waitingParentId = parsedTransformNode.parentId;\n        }\n        return transformNode;\n    };\n    /**\n     * Get all child-transformNodes of this node\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\n     * @returns an array of TransformNode\n     */\n    TransformNode.prototype.getChildTransformNodes = function (directDescendantsOnly, predicate) {\n        var results = [];\n        this._getDescendants(results, directDescendantsOnly, function (node) {\n            return (!predicate || predicate(node)) && node instanceof TransformNode;\n        });\n        return results;\n    };\n    /**\n     * Releases resources associated with this transform node.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n    TransformNode.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\n        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }\n        // Animations\n        this.getScene().stopAnimation(this);\n        // Remove from scene\n        this.getScene().removeTransformNode(this);\n        if (this._parentContainer) {\n            var index = this._parentContainer.transformNodes.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.transformNodes.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        this.onAfterWorldMatrixUpdateObservable.clear();\n        if (doNotRecurse) {\n            var transformNodes = this.getChildTransformNodes(true);\n            for (var _i = 0, transformNodes_1 = transformNodes; _i < transformNodes_1.length; _i++) {\n                var transformNode = transformNodes_1[_i];\n                transformNode.parent = null;\n                transformNode.computeWorldMatrix(true);\n            }\n        }\n        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\n    };\n    /**\n     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)\n     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false\n     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false\n     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling\n     * @returns the current mesh\n     */\n    TransformNode.prototype.normalizeToUnitCube = function (includeDescendants, ignoreRotation, predicate) {\n        if (includeDescendants === void 0) { includeDescendants = true; }\n        if (ignoreRotation === void 0) { ignoreRotation = false; }\n        var storedRotation = null;\n        var storedRotationQuaternion = null;\n        if (ignoreRotation) {\n            if (this.rotationQuaternion) {\n                storedRotationQuaternion = this.rotationQuaternion.clone();\n                this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\n            }\n            else if (this.rotation) {\n                storedRotation = this.rotation.clone();\n                this.rotation.copyFromFloats(0, 0, 0);\n            }\n        }\n        var boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);\n        var sizeVec = boundingVectors.max.subtract(boundingVectors.min);\n        var maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);\n        if (maxDimension === 0) {\n            return this;\n        }\n        var scale = 1 / maxDimension;\n        this.scaling.scaleInPlace(scale);\n        if (ignoreRotation) {\n            if (this.rotationQuaternion && storedRotationQuaternion) {\n                this.rotationQuaternion.copyFrom(storedRotationQuaternion);\n            }\n            else if (this.rotation && storedRotation) {\n                this.rotation.copyFrom(storedRotation);\n            }\n        }\n        return this;\n    };\n    TransformNode.prototype._syncAbsoluteScalingAndRotation = function () {\n        if (!this._isAbsoluteSynced) {\n            this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);\n            this._isAbsoluteSynced = true;\n        }\n    };\n    // Statics\n    /**\n     * Object will not rotate to face the camera\n     */\n    TransformNode.BILLBOARDMODE_NONE = 0;\n    /**\n     * Object will rotate to face the camera but only on the x axis\n     */\n    TransformNode.BILLBOARDMODE_X = 1;\n    /**\n     * Object will rotate to face the camera but only on the y axis\n     */\n    TransformNode.BILLBOARDMODE_Y = 2;\n    /**\n     * Object will rotate to face the camera but only on the z axis\n     */\n    TransformNode.BILLBOARDMODE_Z = 4;\n    /**\n     * Object will rotate to face the camera\n     */\n    TransformNode.BILLBOARDMODE_ALL = 7;\n    /**\n     * Object will rotate to face the camera's position instead of orientation\n     */\n    TransformNode.BILLBOARDMODE_USE_POSITION = 128;\n    TransformNode._TmpRotation = Quaternion.Zero();\n    TransformNode._TmpScaling = Vector3.Zero();\n    TransformNode._TmpTranslation = Vector3.Zero();\n    TransformNode._LookAtVectorCache = new Vector3(0, 0, 0);\n    TransformNode._RotationAxisCache = new Quaternion();\n    __decorate([\n        serializeAsVector3(\"position\")\n    ], TransformNode.prototype, \"_position\", void 0);\n    __decorate([\n        serializeAsVector3(\"rotation\")\n    ], TransformNode.prototype, \"_rotation\", void 0);\n    __decorate([\n        serializeAsQuaternion(\"rotationQuaternion\")\n    ], TransformNode.prototype, \"_rotationQuaternion\", void 0);\n    __decorate([\n        serializeAsVector3(\"scaling\")\n    ], TransformNode.prototype, \"_scaling\", void 0);\n    __decorate([\n        serialize(\"billboardMode\")\n    ], TransformNode.prototype, \"_billboardMode\", void 0);\n    __decorate([\n        serialize()\n    ], TransformNode.prototype, \"scalingDeterminant\", void 0);\n    __decorate([\n        serialize(\"infiniteDistance\")\n    ], TransformNode.prototype, \"_infiniteDistance\", void 0);\n    __decorate([\n        serialize()\n    ], TransformNode.prototype, \"ignoreNonUniformScaling\", void 0);\n    __decorate([\n        serialize()\n    ], TransformNode.prototype, \"reIntegrateRotationIntoRotationQuaternion\", void 0);\n    return TransformNode;\n}(Node));\nexport { TransformNode };\n//# sourceMappingURL=transformNode.js.map"],"names":["_PrimaryIsoTriangle","this","cartesian","vertices","max","min","closestTo","innerFacets","isoVecsABOB","isoVecsOBOA","isoVecsBAOA","vertexTypes","IDATA","PolyhedronData","prototype","setIndices","m1","n1","fr","rot","O","A","B","indexCount","vecToidx","m","n","g","idx","idxR","isoId","oVec","aVec","bVec","oaVec","abVec","obVec","verts","vDist","vertByDist","matchIdx","f","isoIdR","edgematch","face","x","y","i","length","calcCoeffs","thirdR3","Math","sqrt","LSQD","coau","cobu","coav","cobv","createInnerFacets","push","edgeVecsABOB","point","prev","next","pointR","clone","prevR","nextR","rotate60About","maxPoint","maxPrev","maxLeftPrev","mapABOBtoOBOA","temp","j","rotateNeg120","mapABOBtoBAOA","rotate120","MapToFace","faceNb","geodesicData","F","oidx","aidx","bidx","vertex","OA","subtract","OB","scale","add","mapped","tempVec","z","build","Array","y_1","x_1","ratio","y_2","x_2","sort","a","b","Infinity","len","distFrom","vert","primVert","v","distFromO","distFromA","distFromB","vertData","closest","dist","toCartesianOrigin","name","category","GeodesicData","_super","apply","arguments","innerToData","primTri","map","el","mapABOBtoDATA","mapOBOAtoDATA","mapBAOAtoDATA","orderData","nearTo","close","near","nearIndex","pop","sharedNodes","poleNodes","setOrder","faces","adjVerts","dualFaces","index","indexOf","splice","adjacentFaces","toGoldbergPolyhedronData","_this","goldbergPolyhedronData","verticesNb","cx","cy","cz","concat","forEach","BuildGeodesicData","c","d","Geometry","id","scene","vertexData","updatable","mesh","delayLoadState","_totalVertices","_isDisposed","_indexBufferIsUpdatable","_positionsCache","_parentContainer","useBoundingInfoFromGeometry","_scene","uniqueId","getUniqueId","_engine","getEngine","_meshes","_vertexBuffers","_indices","_updatable","setAllVerticesData","getCaps","vertexArrayObject","_vertexArrayObjects","applyToMesh","computeWorldMatrix","Object","defineProperty","get","_boundingBias","set","value","copyFrom","_updateBoundingInfo","enumerable","configurable","CreateGeometryForMesh","geometry","RandomId","getScene","_extend","isReady","doNotSerialize","_rebuild","key","_indexBuffer","createIndexBuffer","applyToGeometry","_notifyUpdate","setVerticesData","kind","data","stride","isArray","Float32Array","buffer","setVerticesBuffer","removeVerticesData","dispose","_disposeVertexArrayObjects","totalVertices","disposeExistingBuffer","getKind","_buffer","_increaseReferences","meshes","numOfMeshes","getData","type","byteStride","_updateExtend","_resetPointsArrayCache","buildBoundingInfo","minimum","maximum","_createGlobalSubMesh","isUnIndexed","synchronizeInstances","updateVerticesDataDirectly","offset","useBytes","vertexBuffer","getVertexBuffer","updateDirectly","updateVerticesData","updateExtends","update","_i","meshes_1","hasBoundingInfo","getBoundingInfo","reConstruct","_a","subMeshes_1","subMeshes","refreshBoundingInfo","_bind","effect","indexToBind","overrideVertexBuffers","overrideVertexArrayObjects","undefined","vbs","getVertexBuffers","vaos","recordVertexArrayObject","bindVertexArrayObject","bindBuffers","getTotalVertices","getVerticesData","copyWhenShared","forceCopy","getFloatData","isVertexBufferUpdatable","vb","isUpdatable","isVerticesDataPresent","_delayInfo","getVerticesDataKinds","result","updateIndices","indices","gpuMemoryOnly","needToUpdateSubMeshes","slice","updateDynamicIndexBuffer","_releaseBuffer","getTotalIndices","getIndices","orig","getIndexBuffer","_releaseVertexArrayObject","releaseVertexArrayObject","releaseForMesh","shouldDispose","_invalidateInstanceVertexArrayObject","_geometry","previousGeometry","_internalAbstractMeshDataInfo","_positions","pushGeometry","_applyToMesh","_boundingInfo","setBoundingInfo","boundingBias","create","_syncGeometryWithMorphTargetManager","onGeometryUpdated","_markSubMeshesAsAttributesDirty","load","onLoaded","_queueLoad","delayLoadingFile","_addPendingData","_loadFile","_delayLoadingFunction","JSON","parse","_removePendingData","toLeftHanded","tIndices","tTemp","tPositions","tNormals","_generatePointsArray","arrayIdx","isDisposed","removeGeometry","index_1","geometries","copy","stopChecking","serialize","serializationObject","tags","_toNumberArray","origin","call","clearCachedData","vbName","hasOwnProperty","_data","serializeVerticeData","positions","normals","tangents","uvs","uv2s","uv3s","uv4s","uv5s","uv6s","colors","matricesIndices","_isExpanded","matricesWeights","ExtractFromMesh","_GetGeometryByLoadedUniqueId","_loadedUniqueId","_ImportGeometry","parsedGeometry","geometryUniqueId","geometryId","getGeometryById","ArrayBuffer","binaryInfo","_binaryInfo","positionsAttrDesc","count","positionsData","normalsAttrDesc","normalsData","tangetsAttrDesc","tangentsData","uvsAttrDesc","uvsData","uvs2AttrDesc","uvs2Data","uvs3AttrDesc","uvs3Data","uvs4AttrDesc","uvs4Data","uvs5AttrDesc","uvs5Data","uvs6AttrDesc","uvs6Data","colorsAttrDesc","colorsData","matricesIndicesAttrDesc","matricesIndicesData","Int32Array","floatIndices","matricesIndicesExtraAttrDesc","matricesWeightsAttrDesc","matricesWeightsData","indicesAttrDesc","indicesData","subMeshesAttrDesc","subMeshesData","materialIndex","verticesStart","verticesCount","indexStart","uvs2","uvs3","uvs4","uvs5","uvs6","matricesIndex","matricesIndicesExtra","_CleanMatricesWeights","matricesWeightsExtra","subIndex","parsedSubMesh","_shouldGenerateFlatShading","convertToFlatShadedMesh","onMeshImportedObservable","notifyObservers","epsilon","noInfluenceBoneIndex","skeletonId","skeleton","getLastSkeletonById","bones","influencers","numBoneInfluencer","size","weight","firstZeroWeight","w","mweight","Parse","parsedVertexData","rootUrl","boundingBoxMinimum","boundingBoxMaximum","hasUVs","hasUVs2","hasUVs3","hasUVs4","hasUVs5","hasUVs6","hasColors","hasMatricesIndices","hasMatricesWeights","parsedMesh","GoldbergMesh","goldbergData","faceColors","faceCenters","faceZaxis","faceXaxis","faceYaxis","nbSharedFaces","nbUnsharedFaces","nbFaces","nbFacesAtPole","relatedGoldbergFace","poleOrShared","fromPole","_changeGoldbergFaceColors","colorRange","col","newCols","r","setGoldbergFaceColors","updateGoldbergFaceColors","_changeGoldbergFaceUVs","uvRange","center","radius","angle","points5","points6","u","p","cos","PI","sin","setGoldbergFaceUVs","newUVs","updateGoldbergFaceUVs","placeOnGoldbergFaceAt","position","orientation","rotation","color","asArray","_b","_c","vector","_d","_e","_f","_g","_h","_j","goldberg","GroundMesh","generateOctree","getClassName","_subdivisionsX","_subdivisionsY","optimize","chunksCount","octreeBlocksSize","subdivide","createOrUpdateSubmeshesOctree","getHeightAtCoordinates","world","getWorldMatrix","invMat","invertToRef","tmpVect","_minX","_maxX","_minZ","_maxZ","_heightQuads","_initHeightQuads","_computeHeightQuads","facet","_getFacetAt","getNormalAtCoordinates","normal","getNormalAtCoordinatesToRef","ref","tmpMat","updateCoordinateHeights","floor","_width","row","_height","quad","slope","facet1","facet2","subdivisionsX","subdivisionsY","v1","v2","v3","v4","v1v2","v1v3","v1v4","norm1","norm2","k","cd","h","d1","d2","subtractToRef","normalize","copyFromFloats","minX","maxX","minZ","maxZ","width","height","SimplificationType","currentCSGMeshId","Vertex","pos","uv","vertColor","flip","interpolate","other","t","Plane","FromPoints","v0","lengthSquared","scaleInPlace","splitPolygon","polygon","coplanarFront","coplanarBack","front","back","polygonType","types","EPSILON","plane","ti","tj","vi","vj","poly","Polygon","shared","reverse","Node","polygons","_plane","_front","_back","_polygons","node","invert","clipPolygons","clipTo","bsp","allPolygons","CSG","FromMesh","absolute","matrix","meshPosition","meshRotation","meshScaling","meshRotationQuaternion","invertWinding","rotationQuaternion","scaling","material","sideOrientation","vertColors","sm","sml","il","indexIndices","sourceNormal","sourcePosition","subMeshId","meshId","csg","_FromPolygons","copyTransformAttributes","union","unionInPlace","subtractInPlace","intersect","intersectInPlace","inverse","inverseInPlace","buildMeshGeometry","keepSubMeshes","vertex_idx","subMeshObj","polygonIndices","vertice_dict","currentIndex","subMeshDict","indexEnd","jl","localVertex","localNormal","areUvsDifferent","areColorsDifferent","materialIndexOffset","materialMaxIndex","toMesh","TrailMesh","generator","diameter","autoStart","_sectionPolygonPointsCount","_running","_autoStart","_generator","_diameter","_length","_sectionVectors","_sectionNormalVectors","_createMesh","meshCenter","boundingBox","centerWorld","alpha","l","start","_beforeRenderObserver","onBeforeRenderObservable","stop","remove","wm","newGenerator","MeshBuilder","CreateBox","CreateTiledBox","CreateSphere","CreateDisc","CreateIcoSphere","CreateRibbon","CreateCylinder","CreateTorus","CreateTorusKnot","CreateLineSystem","CreateLines","CreateDashedLines","ExtrudeShape","ExtrudeShapeCustom","CreateLathe","CreateTiledPlane","CreatePlane","CreateGround","CreateTiledGround","CreateGroundFromHeightMap","CreatePolygon","ExtrudePolygon","CreateTube","CreatePolyhedron","CreateGeodesic","CreateGoldberg","CreateDecal","CreateCapsule","SimplificationSettings","quality","distance","optimizeMesh","SimplificationQueue","running","_simplificationArray","addTask","task","executeNext","runSimplification","parallelProcessing","settings","setting","_getSimplifier","simplify","newMesh","addLODLevel","isVisible","successCallback","simplifier_1","loop","callback","simplificationType","QUADRATIC","QuadraticErrorSimplification","DecimationTriangle","_vertices","error","deleted","isDirty","deletePending","borderFactor","DecimationVertex","isBorder","q","QuadraticMatrix","triangleCount","triangleStart","originalOffsets","updatePosition","newPosition","det","a11","a12","a13","a21","a22","a23","a31","a32","a33","addInPlace","addArrayInPlace","FromData","DataFromNumbers","Reference","vertexId","triangleId","_mesh","syncIterations","aggressiveness","decimationIterations","boundingBoxEpsilon","_initDecimatedMesh","_initWithMesh","_runDecimation","setTimeout","_reconstructedMesh","submeshIndex","targetCount","_triangles","deletedTriangles","iteration","breakLoop","_updateMesh","threshold","pow","tIdx","_loop_1","deleted0","deleted1","_calculateError","delTr","_isFlipped","uniqueArray_1","deletedT","tStart","_references","_updateTriangles","tCount","_reconstructMesh","positionData","submesh","vertexReferences","positionToSearch","ii","equalsWithEpsilon","findInVertices","i0","i1","i2","triangle","originalOffset","_init","newTriangles","newPositionData","newNormalData","newUVsData","newColorsData","normalData","vertexCount","_loop_2","this_1","startingIndex","startingVertex","submeshesArray","newIndicesArray","originalIndices","originalSubmesh","getMesh","parent","renderingGroupId","vertex1","vertex2","deletedArray","s","abs","origVertex","newDeleted","_identifyBorder","vCount","vId","ofs","vv","identifyBorders","newTrianglesVector","newReferences","_vertexError","pointResult","border","qDet","p3","divide","error1","error2","error3","_simplificationQueue","component","_getComponent","SimplicationQueueSceneComponent","_addComponent","simplificationQueue","register","_beforeCameraUpdateStage","registerStep","_beforeCameraUpdate","rebuild","instance","InstancedMesh","instancedBuffers","source","_indexInSourceMeshInstanceArray","_distanceToCamera","addInstance","_sourceMesh","_unIndexed","animations","getAnimationRanges","range","createAnimationRange","from","to","infiniteDistance","setPivotMatrix","getPivotMatrix","_syncSubMeshes","_lightSources","_resyncLightSources","_resyncLightSource","_removeLightSource","receiveShadows","visibility","createInstance","completeCheck","sourceMesh","makeItUnique","applySkeleton","applyMorph","isLocked","bias","_refreshBoundingInfo","_getPositionData","_preActivate","_currentLOD","_activate","renderId","intermediateRendering","_getWorldMatrixDeterminant","_actAsRegularMesh","_registerInstanceForRenderId","_isActiveIntermediate","_onlyForInstancesIntermediate","_isActive","_onlyForInstances","_postActivate","edgesShareWithInstances","_edgesRenderer","isEnabled","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","billboardMode","_masterMesh","_billboardWorldMatrix","tempMaster","getLOD","camera","sourceMeshLODLevels","getLODLevels","boundingInfo","boundingSphere","_preActivateForIntermediateRendering","releaseSubMeshes","worldMatrixFromCache","absolutePosition","_updateSubMeshesBoundingInfo","newParent","doNotCloneChildren","onClonedObservable","doNotRecurse","disposeMaterialAndTextures","removeInstance","_userInstancedBuffersStorage","vertexBuffers","instances","strides","sizes","vertexArrayObjects","visibleInstances","renderSelf","instanceCount","expectedSize","toArray","copyToArray","instanceIndex","_instanceDataStorage","instancesBuffer","LinesMesh","useVertexColor","useVertexAlpha","intersectionThreshold","options","attributes","uniforms","needAlphaBlending","defines","useClipPlane","_color4","_isShaderMaterial","shader","_lineMaterial","fillMode","colorEffect","getEffect","setColor4","_draw","subMesh","instancesCount","engine","drawArraysType","drawElementsType","InstancedLinesMesh","_CreationDataStorage","_InstanceDataStorage","batchCache","_InstancesBatch","batchCacheReplacementModeInFrozenMode","instancesBufferSize","mustReturn","hardwareInstancedRendering","_ThinInstanceDataStorage","matrixBuffer","previousMatrixBuffer","matrixBufferSize","matrixData","boundingVectors","worldMatrices","_InternalMeshDataInfo","_areNormalsFrozen","_source","meshMap","_preActivateId","_LODLevels","_useLODScreenCoverage","_effectiveMaterial","_forcedInstanceCount","Mesh","clonePhysicsImpostor","_internalMeshDataInfo","_creationDataStorage","_thinInstanceDataStorage","_originalBuilderSideOrientation","DEFAULTSIDE","overrideMaterialSideOrientation","ignoreCameraMaxZ","_onBeforeDraw","isInstance","effectiveMaterial","_uniformBuffer","transferToEffect","bindOnlyWorldMatrix","useClonedMeshMap","_ranges","ranges","name_1","metadata","setEnabled","directDescendants","getDescendants","child","morphTargetManager","getPhysicsEngine","physicsEngine","impostor","getImpostorForPhysicsObject","physicsImpostor","particleSystems","system","emitter","instancedArrays","_onMeshReadyObserverAdded","observer","unregisterOnNextCall","onMeshReadyObservable","_checkReadinessObserver","_GetDefaultSideOrientation","FRONTSIDE","_computeBonesUsingShaders","_sourcePositions","_sourceNormals","_onBeforeRenderObservable","_onBeforeBindObservable","_onAfterRenderObservable","_onBetweenPassObservable","_onBeforeDrawObservable","_onBeforeDrawObserver","onBeforeDrawObservable","instancesData","instancesPreviousData","manualUpdate","previousManualUpdate","instantiateHierarchy","onNewNodeCreated","doNotInstantiate","getChildTransformNodes","toString","fullDetails","ret","_waitingParentId","ib","_unBindEffect","_sortLODLevels","sortingOrderFactor","distanceOrScreenCoverage","level","getLODLevelAtDistance","internalDataInfo","removeLODLevel","bSphere","distanceToCamera","globalPosition","compareValue","compareSign","screenArea","meshArea","radiusWorld","onLODLevelSelection","_checkDelayState","result_1","kinds","forceInstanceSupport","hasThinInstances","mat","defaultMaterial","_storeEffectOnSubMeshes","getMaterial","isReadyForSubMesh","currentRenderPassId","lightSources","getShadowGenerator","getShadowMap","renderList","renderPassId","_k","_l","needAlphaBlendingForMesh","_m","_o","lod","freezeNormals","unfreezeNormals","overridenInstanceCount","sceneRenderId","getRenderId","intermediateDefaultRenderId","defaultRenderId","selfDefaultRenderId","_renderId","previousRenderId","isFrozen","_afterComputeWorldMatrix","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","edgesRenderer","force","totalIndices","needToRecreate","subdivisionSize","markVerticesDataAsUpdatable","makeGeometryUnique","updateMeshPositions","positionFunction","computeNormals","oldGeometry","isUsingTextureForTargets","_getLinesIndexBuffer","forcedInstanceCount","_linesIndexCount","registerBeforeRender","func","unregisterBeforeRender","removeCallback","registerAfterRender","onAfterRenderObservable","unregisterAfterRender","_getInstancesRenderList","isReplacementMode","previousBatch","isInIntermediateRendering","_isInIntermediateRendering","onlyForInstances","currentRenderId","_renderWithInstances","batch","_id","instanceStorage","currentInstancesBufferSize","instancesPreviousBuffer","bufferSize","needsPreviousWorldMatrices","needUpdateBuffer","masterMeshPreviousWorldMatrix","INSTANCEDMESH_SORT_TRANSPARENT","activeCamera","getRenderingMesh","cameraPosition","instanceMesh","m2","_previousWorldMatrix","createVertexBuffer","_processInstancedBuffers","_activeIndices","addCount","_currentDrawContext","useInstancing","unbindInstanceAttributes","_renderWithThinInstances","previousMatrixData","_thinInstanceCreateMatrixBuffer","_processRendering","renderingMesh","onBeforeDraw","visibleInstancesForSubMesh","visibleInstanceCount","_freeze","_unFreeze","render","enableAlphaMode","effectiveMeshReplacement","_checkOcclusionQuery","_occlusionDataStorage","forceRenderingWhenOccluded","oldCameraMaxZ","oldCamera","updateTransformMatrix","drawWrapper","instanceDataStorage","_wasPreviouslyReady","setAlphaMode","alphaMode","_drawWrapper","_getDrawWrapper","_beforeRenderingMeshStage","action","effectiveMesh","backFaceCulling","mainDeterminant","_preBind","forceDepthWrite","setDepthWrite","forcePointsCloud","forceWireframe","bindForSubMesh","bind","separateCullingPass","setState","zOffset","cullBackFaces","stencil","zOffsetUnits","unbind","_afterRenderingMeshStage","cleanMatrixWeights","_normalizeSkinWeightsAndExtra","_normalizeSkinFourWeights","numWeights","recip","validateSkinning","skinned","valid","report","numberNotSorted","missingWeights","maxUsedWeights","numberNotNormalized","numInfluences","usedWeightCounts","lastWeight","usedWeights","tolerance","numBones","numBadBoneIndices","getBinaryData","offlineProvider","isInFrustum","frustumPlanes","setMaterialById","materials","multiMaterials","getAnimatables","results","bakeTransformIntoVertices","transform","submeshes","determinant","flipFaces","bakeCurrentTransformIntoVertices","bakeIndependenlyOfChildren","resetLocalMatrix","clear","_disposeInstanceSpecificData","_disposeThinInstanceSpecificData","applyDisplacementMap","url","minHeight","maxHeight","onSuccess","uvOffset","uvScale","forceUpdate","img","heightMapWidth","heightMapHeight","context","createCanvas","getContext","drawImage","getImageData","applyDisplacementMapFromBuffer","gradient","kindIndex","newdata","updatableNormals","previousSubmeshes","vertexIndex","getStrideSize","flipNormalGeneration","useRightHandedSystem","p1","p2","p1p2","p3p2","localIndex","previousOne","convertToUnIndexedMesh","flipNormals","vertex_data","increaseVertices","numberPerEdge","currentIndices","segments","tempIndices","deltaPosition","deltaNormal","deltaUV","side","positionPtr","uvPtr","normalsPtr","forceSharedVertices","currentUVs","currentPositions","currentColors","pstring","indexPtr","uniquePositions","ptr","_instancedMeshFactory","_PhysicsImpostorParser","physicObject","jsonObject","optimizeIndices","vectorPositions","dupes","realPos","testedPosition","againstPosition","equals","originalSubMeshes","_postMultiplyPivotMatrix","pivotMatrix","localMatrix","pickable","isPickable","checkCollisions","isBlocker","parentId","materialUniqueId","materialId","morphTargetManagerId","numBoneInfluencers","getPhysicsImpostor","physicsMass","getParam","physicsFriction","physicsRestitution","serializationInstance","serializeAnimationRanges","thinInstances","enablePicking","thinInstanceEnablePicking","_userThinInstanceBuffersStorage","userThinInstance","layerMask","alphaIndex","hasVertexAlpha","overlayAlpha","overlayColor","renderOverlay","applyFog","actionManager","actions","_morphTargetManager","numInfluencers","morphTarget","getActiveTarget","getPositions","getNormals","getTangents","getUVs","_LinesMeshParser","_GroundMeshParser","_GoldbergMeshParser","setPreTransformMatrix","showBoundingBox","showSubMeshesBoundingBox","useFlatShading","freezeWorldMatrix","_waitingData","_waitingMaterialId","getMorphTargetManagerById","animationIndex","parsedAnimation","internalClass","N","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","isNaN","parseInt","lodMeshIds","lods","ids","distances","lodDistances","coverages","lodCoverages","parsedInstance","thinInstanceSetBuffer","setPositionsForCPUSkinning","setNormalsForCPUSkinning","_softwareSkinningFrameId","getFrameId","hasNormals","inf","needExtras","matricesIndicesExtraData","matricesWeightsExtraData","skeletonMatrices","getTransformMatrices","tempVector3","finalMatrix","tempMatrix","matWeightIdx","addToSelf","reset","MinMax","minVector","maxVector","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","Center","meshesOrMinMaxVector","minMaxVector","MergeMeshes","disposeSource","allow32BitsIndices","meshSubclass","subdivideWithSubMeshes","multiMultiMaterials","_MergeMeshesCoroutine","MergeMeshesAsync","isAsync","materialArray","materialIndexArray","indiceArray","currentOverrideMaterialSideOrientation","matIndex","getVertexDataFromMesh","sourceVertexData","sourceTransform","meshVertexDatas","mergeCoroutine","mergeCoroutineStep","applyToCoroutine","applyToCoroutineStep","newMultiMaterial","label","filter","Boolean","isAnInstance","subMaterials","sent","_mergeCoroutine","done","_applyToCoroutine","last","_shouldConvertRHS","BACKSIDE","DOUBLESIDE","NO_CAP","CAP_START","CAP_END","CAP_ALL","NO_FLIP","FLIP_TILE","ROTATE_TILE","FLIP_ROW","ROTATE_ROW","FLIP_N_ROTATE_TILE","FLIP_N_ROTATE_ROW","CENTER","LEFT","RIGHT","TOP","BOTTOM","setMaterialByID","Error","ExtendToGoldberg","VertexData","_applyTo","updateMesh","_update","updateGeometry","meshOrGeometry","_TransformVector3Coordinates","coordinates","transformation","coordinate","transformedCoordinate","_TransformVector3Normals","transformedNormal","_TransformVector4Normals","_FlipFaces","tmp","merge","others","use32BitsIndices","forceCloneIndices","vertexDatas","others_1","sliceIndices","indicesOffset","positionsOffset","vertexDatas_1","transform_1","_validate","reduce","indexSum","some","Uint32Array","Uint16Array","_MergeElement","nonNullOthers","sumLen","elements","transformRange","ret32","nonNullOthers_1","transform_2","nonNullOthers_2","transform_3","getElementCount","values","positionsElementCount","validateElementCount","elementCount","_ExtractFrom","ExtractFromGeometry","fUV","fColors","frontUVs","backUVs","wrap","subdivisions","tessellation","capSubdivisions","ComputeNormals","p1p2x","p1p2y","p1p2z","p3p2x","p3p2y","p3p2z","faceNormalx","faceNormaly","faceNormalz","v1x","v1y","v1z","v2x","v2y","v2z","v3x","v3y","v3z","computeFacetNormals","computeFacetPositions","computeFacetPartitioning","computeDepthSort","faceNormalSign","distanceTo","facetNormals","facetPositions","facetPartitioning","depthSort","xSubRatio","ySubRatio","zSubRatio","subSq","bbSize","subDiv","X","Y","Z","ox","bInfo","oy","oz","b1x","b1y","b1z","b2x","b2y","b2z","b3x","b3y","b3z","block_idx_v1","block_idx_v2","block_idx_v3","block_idx_o","dsf","depthSortedFacets","ind","sqDistance","_ComputeSides","li","ln","lp","lu","ImportVertexData","MeshLODLevel","IndexedVector2","original","PolygonPoints","originalPoints","newPoint","computeBounds","lmin","lmax","Rectangle","xmin","ymin","xmax","ymax","Circle","numberOfSides","increment","input","floats","split","parseFloat","val","StartingAt","PolygonMeshBuilder","contours","earcutInjection","points","earcut","_points","_outlinepoints","_holes","_epoints","_eholes","bjsEarcut","_name","getPoints","_addToepoint","points_1","addHole","hole","holepoints","depth","smoothingThreshold","buildVertexData","bounds","res","positionscount","totalCount","_addSide","startIndex","ulength","p0","vc","vp","vn","vc_norm","normalizeToNew","vp_norm","vn_norm","dotp","dotn","SubMesh","createBoundingBox","addToMesh","_mainDrawWrapperOverride","_linesIndexBuffer","_lastColliderWorldVertices","_lastColliderTransformMatrix","_alphaIndex","_currentMaterial","_renderingMesh","resetDrawCache","_trianglePlanes","passId","createIfNotExisting","_drawWrappers","_removeDrawWrapper","disposeWrapper","_setMainDrawWrapperOverride","wrapper","setEffect","materialContext","resetContext","AddToMesh","IsGlobal","getReplacementMesh","getEffectiveMesh","replacementMesh","getDefaultMaterial","rootMaterial","getMaterialForRenderPass","_isMultiMaterial","getSubMaterial","extend","_checkCollision","collider","updateBoundingInfo","cullingStrategy","isCompletelyInFrustum","linesIndices","canIntersects","ray","intersectsBox","intersects","fastCheck","trianglePredicate","step","checkStopper","_intersectLines","_intersectUnIndexedLines","_intersectUnIndexedTriangles","_intersectTriangles","intersectInfo","length_1","intersectionSegment","faceId","length_2","indexA","indexB","indexC","currentIntersectInfo","intersectsTriangle","newRenderingMesh","CreateFromIndices","minVertexIndex","Number","MAX_VALUE","maxVertexIndex","proj","tmpDist","_projectOnUnIndexedTrianglesToRef","_projectOnTrianglesToRef","refresh","_thinInstanceUpdateBufferSize","thinInstanceSetMatrixAt","thinInstanceAdd","_thinInstanceInitializeUserStorage","thinInstanceBufferUpdated","staticBuffer","forceRefreshParentInfo","vectors","POSITIVE_INFINITY","NEGATIVE_INFINITY","numInstances","kindIsMatrix","currentSize","newSize","newData","TransformNode","isPure","_forward","_up","_right","_position","_rotation","_rotationQuaternion","_scaling","_transformToBoneReferal","_isAbsoluteSynced","_billboardMode","BILLBOARDMODE_NONE","_preserveParentRotationForBillboard","scalingDeterminant","_infiniteDistance","ignoreNonUniformScaling","reIntegrateRotationIntoRotationQuaternion","_poseMatrix","_localMatrix","_usePivotMatrix","_absolutePosition","_absoluteScaling","_absoluteRotationQuaternion","_pivotMatrix","_isWorldMatrixFrozen","_indexInSceneTransformNodesArray","onAfterWorldMatrixUpdateObservable","_nonUniformScaling","addTransformNode","_isDirty","isUsingPivotMatrix","newRotation","newScaling","quaternion","setAll","updatePoseMatrix","getPoseMatrix","_isSynchronized","cache","_cache","pivotMatrixUpdated","_initCache","localMatrixUpdated","getAbsolutePosition","_syncAbsoluteScalingAndRotation","postMultiplyPivotMatrix","isIdentity","_pivotMatrixInverse","newWorldMatrix","decompose","_worldMatrix","unfreezeWorldMatrix","setAbsolutePosition","absolutePositionX","absolutePositionY","absolutePositionZ","invertParentWorldMatrix","setPositionWithLocalVector","vector3","getPositionExpressedInLocalSpace","invLocalWorldMatrix","locallyTranslate","lookAt","targetPoint","yawCor","pitchCor","rollCor","space","dv","_LookAtVectorCache","setDirection","rotationMatrix","toRotationMatrix","parentRotationMatrix","getRotationMatrixToRef","multiplyToRef","fromRotationMatrix","quaternionRotation","toEulerAnglesToRef","getDirection","localAxis","getDirectionToRef","yaw","atan2","pitch","setPivotPoint","tmat","getPivotPoint","getPivotPointToRef","getAbsolutePivotPoint","getAbsolutePivotPointToRef","markAsDirty","property","_children","setParent","preserveScalingSign","quatRotation","invParentMatrix","composedMatrix","currentRotation","_TmpRotation","_updateNonUniformScalingState","attachToBone","bone","affectedTransformNode","_currentParentWhenAttachingToBone","getSkeleton","prepare","detachFromBone","resetToPreviousParent","rotate","axis","amount","toQuaternion","_RotationAxisCache","rotateAround","tmpVector","finalScale","finalTranslation","finalRotation","translationMatrix","translationMatrixInv","translate","displacementVector","tempV3","addRotation","accumulation","multiplyInPlace","_getEffectiveParent","_currentRenderId","isSynchronized","useBillboardPosition","BILLBOARDMODE_USE_POSITION","useBillboardPath","preserveParentRotationForBillboard","_updateCache","_parentNode","_childUpdateId","_TmpScaling","translation","cameraWorldMatrix","cameraGlobalPosition","_TmpTranslation","scaleMatrix","addTranslationFromFloats","translation_1","_markSyncedWithParent","storedTranslation","getTranslationToRef","getViewMatrix","BILLBOARDMODE_ALL","eulerAngles","BILLBOARDMODE_X","BILLBOARDMODE_Y","BILLBOARDMODE_Z","setTranslationFromFloats","setTranslation","camInObjSpace","isNonUniformWithinEpsilon","_worldMatrixDeterminantIsDirty","independentOfChildren","children","getChildren","bakedMatrix","tmpRotationQuaternion","registerAfterWorldMatrixUpdate","unregisterAfterWorldMatrixUpdate","getPositionInCameraSpace","getDistanceToCamera","currentSerializationObject","parsedTransformNode","transformNode","directDescendantsOnly","predicate","_getDescendants","stopAnimation","removeTransformNode","transformNodes","transformNodes_1","normalizeToUnitCube","includeDescendants","ignoreRotation","storedRotation","storedRotationQuaternion","getHierarchyBoundingVectors","sizeVec","maxDimension"],"sourceRoot":""}