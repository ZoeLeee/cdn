{"version":3,"file":"js/vender~9d1a53d8.1c3585c2.js","mappings":"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B,EACA0tB,EACAC,EACAC,EACAC,EACAC,EACAC,EACAX,GAEA,QAAkBx1B,IAAd+1B,EAEF,OAGF,IAAIhC,EAAOgC,EACX,KACEhC,IACCA,EAAKqC,4BAA8BJ,GAClC,cAA8BjC,EAAKsC,uBACnC,mBAAmCtC,EAAKsC,wBACtC,aACJ,CAGA,GAAIH,EACF,OAGF,MAAMI,EAASvC,EAAKuC,OACpB,GAAIL,GAAY,oBAAiCj2B,IAAXs2B,EAGpC,OAAQL,GACN,KAAK,cACHlC,EAAOA,IAASuC,EAAOC,eAAiBD,OAASt2B,EACjD,MACF,KAAK,cACH+zB,EAAOA,IAASuC,EAAOE,eAAiBF,OAASt2B,EACjD,MACF,KAAK,cACH+zB,EAAOA,IAASuC,EAAOG,eAAiBH,OAASt2B,EACjD,MACF,KAAK,cACH+zB,EAAOA,IAASuC,EAAOI,eAAiBJ,OAASt2B,OAIrD+zB,EAAOuC,EAIX,QAAat2B,IAAT+zB,EAIJ,GAAIA,EAAKsC,uBAAyB,cAkBlC,GACE,mBAAmCN,EAAUM,wBAC7C,WAOF,OAAQJ,GACN,KAAK,SACHJ,EACEN,EACAntB,EACA0tB,EACAC,EAAUQ,eACVP,EACAC,GACA,EACAE,EACAX,GAEFK,EACEN,EACAntB,EACA0tB,EACAC,EAAUU,eACVT,EACAC,GACA,EACAE,EACAX,GAEF,MACF,KAAK,SACHK,EACEN,EACAntB,EACA0tB,EACAC,EAAUW,eACVV,EACAC,GACA,EACAE,EACAX,GAEFK,EACEN,EACAntB,EACA0tB,EACAC,EAAUS,eACVR,EACAC,GACA,EACAE,EACAX,GAEF,MACF,KAAK,UACHK,EACEN,EACAntB,EACA0tB,EACAC,EAAUU,eACVT,EACAC,GACA,EACAE,EACAX,GAEFK,EACEN,EACAntB,EACA0tB,EACAC,EAAUW,eACVV,EACAC,GACA,EACAE,EACAX,GAEF,MACF,KAAK,UACHK,EACEN,EACAntB,EACA0tB,EACAC,EAAUS,eACVR,EACAC,GACA,EACAE,EACAX,GAEFK,EACEN,EACAntB,EACA0tB,EACAC,EAAUQ,eACVP,EACAC,GACA,EACAE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OAGrD,MAAM04B,EAAc7C,EACpB6C,EAAYhD,cAAgBA,EAC5BgD,EAAY/C,cAAgBA,EAE5B,MAAMgD,EAAShpB,EAASgpB,OACxB,IAAI5N,EAAa,IAAI6N,aAAaP,EAAiBM,GAE/CE,EAAY,EAChB,MAAMC,EAAiBD,EACvBA,EAAYE,EACV7vB,EACA4O,EACAnI,EACAob,EACA8N,EACA,EACA,EACAjC,EAASp2B,OACTo2B,EAAS3B,cACT,EACAyD,GAEFG,EAAYG,GACV7G,EACAjpB,EACAyG,EACAob,EACA8N,EACA1G,EAAK5C,UACL4C,EAAK7C,WACL,SACAoJ,GAEF,MAAMO,EAAiBJ,EACvBA,EAAYE,EACV7vB,EACA4O,EACAnI,EACAob,EACA8N,EACA,EACA,EACA/B,EAASt2B,OACTs2B,EAAS7B,cACT,EACAyD,GAEFG,EAAYG,GACV7G,EACAjpB,EACAyG,EACAob,EACA8N,EACA1G,EAAK1C,WACL0C,EAAK3C,YACL,UACAkJ,GAEF,MAAMQ,EAAiBL,EACvBA,EAAYE,EACV7vB,EACA4O,EACAnI,EACAob,EACA8N,EACA,EACA,EACA9B,EAASv2B,OACTu2B,EAAS9B,cACT,EACAyD,GAEFG,EAAYG,GACV7G,EACAjpB,EACAyG,EACAob,EACA8N,EACA1G,EAAKxC,UACLwC,EAAKzC,WACL,SACAgJ,GAEF,MAAMS,EAAiBN,EACvBA,EAAYE,EACV7vB,EACA4O,EACAnI,EACAob,EACA8N,EACA,EACA,EACA7B,EAASx2B,OACTw2B,EAAS/B,cACT,EACAyD,GAEFG,EAAYG,GACV7G,EACAjpB,EACAyG,EACAob,EACA8N,EACA1G,EAAKtC,WACLsC,EAAKvC,YACL,UACA8I,GAGFhD,EAAgBgD,EAAYhD,cAC5BC,EAAgB+C,EAAY/C,cAE5B,MAAMyD,EAAM,kBACVthB,EACA4d,EACAC,EACAvG,EAAKpS,aAAa9T,WAIdmwB,EAAiB,oCACrBvhB,EAAUG,OAENqhB,EACJ,GACC,oCAAsDxhB,EAAUK,OAC/DkhB,GACEE,GACH,oCACC7f,EAAmBpE,UAEnB+jB,GACFC,EAEInwB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","sources":["webpack:///../../../node_modules/cesium/Source/Scene/ShadowMap.js","webpack:///../../../node_modules/cesium/Source/Scene/ShadowMapShader.js","webpack:///../../../node_modules/cesium/Source/Scene/ShadowMode.js","webpack:///../../../node_modules/cesium/Source/Scene/ShadowVolumeAppearance.js","webpack:///../../../node_modules/cesium/Source/Scene/SingleTileImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/SkyAtmosphere.js","webpack:///../../../node_modules/cesium/Source/Scene/SkyBox.js","webpack:///../../../node_modules/cesium/Source/Scene/SphereEmitter.js","webpack:///../../../node_modules/cesium/Source/Scene/SplitDirection.js","webpack:///../../../node_modules/cesium/Source/Scene/Splitter.js","webpack:///../../../node_modules/cesium/Source/Scene/StencilConstants.js","webpack:///../../../node_modules/cesium/Source/Scene/StencilFunction.js","webpack:///../../../node_modules/cesium/Source/Scene/StencilOperation.js","webpack:///../../../node_modules/cesium/Source/Scene/StructuralMetadata.js","webpack:///../../../node_modules/cesium/Source/Scene/StyleExpression.js","webpack:///../../../node_modules/cesium/Source/Scene/Sun.js","webpack:///../../../node_modules/cesium/Source/Scene/SunLight.js","webpack:///../../../node_modules/cesium/Source/Scene/SunPostProcess.js","webpack:///../../../node_modules/cesium/Source/Scene/SupportedImageFormats.js","webpack:///../../../node_modules/cesium/Source/Scene/TerrainFillMesh.js","webpack:///../../../node_modules/cesium/Source/Scene/TerrainState.js","webpack:///../../../node_modules/cesium/Source/Scene/TextureAtlas.js","webpack:///../../../node_modules/cesium/Source/Scene/TileBoundingRegion.js","webpack:///../../../node_modules/cesium/Source/Scene/TileBoundingS2Cell.js","webpack:///../../../node_modules/cesium/Source/Scene/TileBoundingSphere.js","webpack:///../../../node_modules/cesium/Source/Scene/TileBoundingVolume.js","webpack:///../../../node_modules/cesium/Source/Scene/TileCoordinatesImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/TileDiscardPolicy.js","webpack:///../../../node_modules/cesium/Source/Scene/TileImagery.js","webpack:///../../../node_modules/cesium/Source/Scene/TileMapServiceImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/TileMetadata.js","webpack:///../../../node_modules/cesium/Source/Scene/TileOrientedBoundingBox.js","webpack:///../../../node_modules/cesium/Source/Scene/TileReplacementQueue.js","webpack:///../../../node_modules/cesium/Source/Scene/TileSelectionResult.js","webpack:///../../../node_modules/cesium/Source/Scene/TileState.js","webpack:///../../../node_modules/cesium/Source/Scene/Tileset3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/TilesetMetadata.js","webpack:///../../../node_modules/cesium/Source/Scene/TimeDynamicImagery.js","webpack:///../../../node_modules/cesium/Source/Scene/TimeDynamicPointCloud.js","webpack:///../../../node_modules/cesium/Source/Scene/Tonemapper.js","webpack:///../../../node_modules/cesium/Source/Scene/TranslucentTileClassification.js","webpack:///../../../node_modules/cesium/Source/Scene/TweenCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/UrlTemplateImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/Vector3DTileBatch.js","webpack:///../../../node_modules/cesium/Source/Scene/Vector3DTileClampedPolylines.js","webpack:///../../../node_modules/cesium/Source/Scene/Vector3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/Vector3DTileGeometry.js","webpack:///../../../node_modules/cesium/Source/Scene/Vector3DTilePoints.js","webpack:///../../../node_modules/cesium/Source/Scene/Vector3DTilePolygons.js","webpack:///../../../node_modules/cesium/Source/Scene/Vector3DTilePolylines.js","webpack:///../../../node_modules/cesium/Source/Scene/Vector3DTilePrimitive.js","webpack:///../../../node_modules/cesium/Source/Scene/VertexAttributeSemantic.js","webpack:///../../../node_modules/cesium/Source/Scene/VerticalOrigin.js"],"sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Renderbuffer from \"../Renderer/Renderbuffer.js\";\nimport RenderbufferFormat from \"../Renderer/RenderbufferFormat.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport Camera from \"./Camera.js\";\nimport CullFace from \"./CullFace.js\";\nimport DebugCameraPrimitive from \"./DebugCameraPrimitive.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport ShadowMapShader from \"./ShadowMapShader.js\";\n\n/**\n * Use {@link Viewer#shadowMap} to get the scene's shadow map. Do not construct this directly.\n *\n * <p>\n * The normalOffset bias pushes the shadows forward slightly, and may be disabled\n * for applications that require ultra precise shadows.\n * </p>\n *\n * @alias ShadowMap\n * @internalConstructor\n * @class\n *\n * @param {Object} options An object containing the following properties:\n * @param {Camera} options.lightCamera A camera representing the light source.\n * @param {Boolean} [options.enabled=true] Whether the shadow map is enabled.\n * @param {Boolean} [options.isPointLight=false] Whether the light source is a point light. Point light shadows do not use cascades.\n * @param {Number} [options.pointLightRadius=100.0] Radius of the point light.\n * @param {Boolean} [options.cascadesEnabled=true] Use multiple shadow maps to cover different partitions of the view frustum.\n * @param {Number} [options.numberOfCascades=4] The number of cascades to use for the shadow map. Supported values are one and four.\n * @param {Number} [options.maximumDistance=5000.0] The maximum distance used for generating cascaded shadows. Lower values improve shadow quality.\n * @param {Number} [options.size=2048] The width and height, in pixels, of each shadow map.\n * @param {Boolean} [options.softShadows=false] Whether percentage-closer-filtering is enabled for producing softer shadows.\n * @param {Number} [options.darkness=0.3] The shadow darkness.\n * @param {Boolean} [options.normalOffset=true] Whether a normal bias is applied to shadows.\n * @param {Boolean} [options.fadingEnabled=true] Whether shadows start to fade out once the light gets closer to the horizon.\n *\n * @exception {DeveloperError} Only one or four cascades are supported.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Shadows.html|Cesium Sandcastle Shadows Demo}\n */\nfunction ShadowMap(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  // options.context is an undocumented option\n  const context = options.context;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n  if (!defined(options.lightCamera)) {\n    throw new DeveloperError(\"lightCamera is required.\");\n  }\n  if (\n    defined(options.numberOfCascades) &&\n    options.numberOfCascades !== 1 &&\n    options.numberOfCascades !== 4\n  ) {\n    throw new DeveloperError(\"Only one or four cascades are supported.\");\n  }\n  //>>includeEnd('debug');\n\n  this._enabled = defaultValue(options.enabled, true);\n  this._softShadows = defaultValue(options.softShadows, false);\n  this._normalOffset = defaultValue(options.normalOffset, true);\n  this.dirty = true;\n\n  /**\n   * Specifies whether the shadow map originates from a light source. Shadow maps that are used for analytical\n   * purposes should set this to false so as not to affect scene rendering.\n   *\n   * @private\n   */\n  this.fromLightSource = defaultValue(options.fromLightSource, true);\n\n  /**\n   * Determines the darkness of the shadows.\n   *\n   * @type {Number}\n   * @default 0.3\n   */\n  this.darkness = defaultValue(options.darkness, 0.3);\n  this._darkness = this.darkness;\n\n  /**\n   * Determines whether shadows start to fade out once the light gets closer to the horizon.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.fadingEnabled = defaultValue(options.fadingEnabled, true);\n\n  /**\n   * Determines the maximum distance of the shadow map. Only applicable for cascaded shadows. Larger distances may result in lower quality shadows.\n   *\n   * @type {Number}\n   * @default 5000.0\n   */\n  this.maximumDistance = defaultValue(options.maximumDistance, 5000.0);\n\n  this._outOfView = false;\n  this._outOfViewPrevious = false;\n  this._needsUpdate = true;\n\n  // In IE11 and Edge polygon offset is not functional.\n  // TODO : Also disabled for instances of Firefox and Chrome running ANGLE that do not support depth textures.\n  // Re-enable once https://github.com/CesiumGS/cesium/issues/4560 is resolved.\n  let polygonOffsetSupported = true;\n  if (\n    FeatureDetection.isInternetExplorer() ||\n    FeatureDetection.isEdge() ||\n    ((FeatureDetection.isChrome() || FeatureDetection.isFirefox()) &&\n      FeatureDetection.isWindows() &&\n      !context.depthTexture)\n  ) {\n    polygonOffsetSupported = false;\n  }\n  this._polygonOffsetSupported = polygonOffsetSupported;\n\n  this._terrainBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.5,\n    normalShading: true,\n    normalShadingSmooth: 0.3,\n    depthBias: 0.0001,\n  };\n\n  this._primitiveBias = {\n    polygonOffset: polygonOffsetSupported,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.1,\n    normalShading: true,\n    normalShadingSmooth: 0.05,\n    depthBias: 0.00002,\n  };\n\n  this._pointBias = {\n    polygonOffset: false,\n    polygonOffsetFactor: 1.1,\n    polygonOffsetUnits: 4.0,\n    normalOffset: this._normalOffset,\n    normalOffsetScale: 0.0,\n    normalShading: true,\n    normalShadingSmooth: 0.1,\n    depthBias: 0.0005,\n  };\n\n  // Framebuffer resources\n  this._depthAttachment = undefined;\n  this._colorAttachment = undefined;\n\n  // Uniforms\n  this._shadowMapMatrix = new Matrix4();\n  this._shadowMapTexture = undefined;\n  this._lightDirectionEC = new Cartesian3();\n  this._lightPositionEC = new Cartesian4();\n  this._distance = 0.0;\n\n  this._lightCamera = options.lightCamera;\n  this._shadowMapCamera = new ShadowMapCamera();\n  this._shadowMapCullingVolume = undefined;\n  this._sceneCamera = undefined;\n  this._boundingSphere = new BoundingSphere();\n\n  this._isPointLight = defaultValue(options.isPointLight, false);\n  this._pointLightRadius = defaultValue(options.pointLightRadius, 100.0);\n\n  this._cascadesEnabled = this._isPointLight\n    ? false\n    : defaultValue(options.cascadesEnabled, true);\n  this._numberOfCascades = !this._cascadesEnabled\n    ? 0\n    : defaultValue(options.numberOfCascades, 4);\n  this._fitNearFar = true;\n  this._maximumCascadeDistances = [25.0, 150.0, 700.0, Number.MAX_VALUE];\n\n  this._textureSize = new Cartesian2();\n\n  this._isSpotLight = false;\n  if (this._cascadesEnabled) {\n    // Cascaded shadows are always orthographic. The frustum dimensions are calculated on the fly.\n    this._shadowMapCamera.frustum = new OrthographicOffCenterFrustum();\n  } else if (defined(this._lightCamera.frustum.fov)) {\n    // If the light camera uses a perspective frustum, then the light source is a spot light\n    this._isSpotLight = true;\n  }\n\n  // Uniforms\n  this._cascadeSplits = [new Cartesian4(), new Cartesian4()];\n  this._cascadeMatrices = [\n    new Matrix4(),\n    new Matrix4(),\n    new Matrix4(),\n    new Matrix4(),\n  ];\n  this._cascadeDistances = new Cartesian4();\n\n  let numberOfPasses;\n  if (this._isPointLight) {\n    numberOfPasses = 6; // One shadow map for each direction\n  } else if (!this._cascadesEnabled) {\n    numberOfPasses = 1;\n  } else {\n    numberOfPasses = this._numberOfCascades;\n  }\n\n  this._passes = new Array(numberOfPasses);\n  for (let i = 0; i < numberOfPasses; ++i) {\n    this._passes[i] = new ShadowPass(context);\n  }\n\n  this.debugShow = false;\n  this.debugFreezeFrame = false;\n  this._debugFreezeFrame = false;\n  this._debugCascadeColors = false;\n  this._debugLightFrustum = undefined;\n  this._debugCameraFrustum = undefined;\n  this._debugCascadeFrustums = new Array(this._numberOfCascades);\n  this._debugShadowViewCommand = undefined;\n\n  this._usesDepthTexture = context.depthTexture;\n\n  if (this._isPointLight) {\n    this._usesDepthTexture = false;\n  }\n\n  // Create render states for shadow casters\n  this._primitiveRenderState = undefined;\n  this._terrainRenderState = undefined;\n  this._pointRenderState = undefined;\n  createRenderStates(this);\n\n  // For clearing the shadow map texture every frame\n  this._clearCommand = new ClearCommand({\n    depth: 1.0,\n    color: new Color(),\n  });\n\n  this._clearPassState = new PassState(context);\n\n  this._size = defaultValue(options.size, 2048);\n  this.size = this._size;\n}\n\n/**\n * Global maximum shadow distance used to prevent far off receivers from extending\n * the shadow far plane. This helps set a tighter near/far when viewing objects from space.\n *\n * @private\n */\nShadowMap.MAXIMUM_DISTANCE = 20000.0;\n\nfunction ShadowPass(context) {\n  this.camera = new ShadowMapCamera();\n  this.passState = new PassState(context);\n  this.framebuffer = undefined;\n  this.textureOffsets = undefined;\n  this.commandList = [];\n  this.cullingVolume = undefined;\n}\n\nfunction createRenderState(colorMask, bias) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.BACK,\n    },\n    depthTest: {\n      enabled: true,\n    },\n    colorMask: {\n      red: colorMask,\n      green: colorMask,\n      blue: colorMask,\n      alpha: colorMask,\n    },\n    depthMask: true,\n    polygonOffset: {\n      enabled: bias.polygonOffset,\n      factor: bias.polygonOffsetFactor,\n      units: bias.polygonOffsetUnits,\n    },\n  });\n}\n\nfunction createRenderStates(shadowMap) {\n  // Enable the color mask if the shadow map is backed by a color texture, e.g. when depth textures aren't supported\n  const colorMask = !shadowMap._usesDepthTexture;\n  shadowMap._primitiveRenderState = createRenderState(\n    colorMask,\n    shadowMap._primitiveBias\n  );\n  shadowMap._terrainRenderState = createRenderState(\n    colorMask,\n    shadowMap._terrainBias\n  );\n  shadowMap._pointRenderState = createRenderState(\n    colorMask,\n    shadowMap._pointBias\n  );\n}\n\n/**\n * @private\n */\nShadowMap.prototype.debugCreateRenderStates = function () {\n  createRenderStates(this);\n};\n\nObject.defineProperties(ShadowMap.prototype, {\n  /**\n   * Determines if the shadow map will be shown.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      this.dirty = this._enabled !== value;\n      this._enabled = value;\n    },\n  },\n\n  /**\n   * Determines if a normal bias will be applied to shadows.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  normalOffset: {\n    get: function () {\n      return this._normalOffset;\n    },\n    set: function (value) {\n      this.dirty = this._normalOffset !== value;\n      this._normalOffset = value;\n      this._terrainBias.normalOffset = value;\n      this._primitiveBias.normalOffset = value;\n      this._pointBias.normalOffset = value;\n    },\n  },\n\n  /**\n   * Determines if soft shadows are enabled. Uses pcf filtering which requires more texture reads and may hurt performance.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  softShadows: {\n    get: function () {\n      return this._softShadows;\n    },\n    set: function (value) {\n      this.dirty = this._softShadows !== value;\n      this._softShadows = value;\n    },\n  },\n\n  /**\n   * The width and height, in pixels, of each shadow map.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Number}\n   * @default 2048\n   */\n  size: {\n    get: function () {\n      return this._size;\n    },\n    set: function (value) {\n      resize(this, value);\n    },\n  },\n\n  /**\n   * Whether the shadow map is out of view of the scene camera.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  outOfView: {\n    get: function () {\n      return this._outOfView;\n    },\n  },\n\n  /**\n   * The culling volume of the shadow frustum.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {CullingVolume}\n   * @readonly\n   * @private\n   */\n  shadowMapCullingVolume: {\n    get: function () {\n      return this._shadowMapCullingVolume;\n    },\n  },\n\n  /**\n   * The passes used for rendering shadows. Each face of a point light or each cascade for a cascaded shadow map is a separate pass.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {ShadowPass[]}\n   * @readonly\n   * @private\n   */\n  passes: {\n    get: function () {\n      return this._passes;\n    },\n  },\n\n  /**\n   * Whether the light source is a point light.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  isPointLight: {\n    get: function () {\n      return this._isPointLight;\n    },\n  },\n\n  /**\n   * Debug option for visualizing the cascades by color.\n   *\n   * @memberof ShadowMap.prototype\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  debugCascadeColors: {\n    get: function () {\n      return this._debugCascadeColors;\n    },\n    set: function (value) {\n      this.dirty = this._debugCascadeColors !== value;\n      this._debugCascadeColors = value;\n    },\n  },\n});\n\nfunction destroyFramebuffer(shadowMap) {\n  const length = shadowMap._passes.length;\n  for (let i = 0; i < length; ++i) {\n    const pass = shadowMap._passes[i];\n    const framebuffer = pass.framebuffer;\n    if (defined(framebuffer) && !framebuffer.isDestroyed()) {\n      framebuffer.destroy();\n    }\n    pass.framebuffer = undefined;\n  }\n\n  // Destroy the framebuffer attachments\n  shadowMap._depthAttachment =\n    shadowMap._depthAttachment && shadowMap._depthAttachment.destroy();\n  shadowMap._colorAttachment =\n    shadowMap._colorAttachment && shadowMap._colorAttachment.destroy();\n}\n\nfunction createFramebufferColor(shadowMap, context) {\n  const depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16,\n  });\n\n  const colorTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST,\n  });\n\n  const framebuffer = new Framebuffer({\n    context: context,\n    depthRenderbuffer: depthRenderbuffer,\n    colorTextures: [colorTexture],\n    destroyAttachments: false,\n  });\n\n  const length = shadowMap._passes.length;\n  for (let i = 0; i < length; ++i) {\n    const pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = colorTexture;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = colorTexture;\n}\n\nfunction createFramebufferDepth(shadowMap, context) {\n  const depthStencilTexture = new Texture({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.DEPTH_STENCIL,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT_24_8,\n    sampler: Sampler.NEAREST,\n  });\n\n  const framebuffer = new Framebuffer({\n    context: context,\n    depthStencilTexture: depthStencilTexture,\n    destroyAttachments: false,\n  });\n\n  const length = shadowMap._passes.length;\n  for (let i = 0; i < length; ++i) {\n    const pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = depthStencilTexture;\n  shadowMap._depthAttachment = depthStencilTexture;\n}\n\nfunction createFramebufferCube(shadowMap, context) {\n  const depthRenderbuffer = new Renderbuffer({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    format: RenderbufferFormat.DEPTH_COMPONENT16,\n  });\n\n  const cubeMap = new CubeMap({\n    context: context,\n    width: shadowMap._textureSize.x,\n    height: shadowMap._textureSize.y,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    sampler: Sampler.NEAREST,\n  });\n\n  const faces = [\n    cubeMap.negativeX,\n    cubeMap.negativeY,\n    cubeMap.negativeZ,\n    cubeMap.positiveX,\n    cubeMap.positiveY,\n    cubeMap.positiveZ,\n  ];\n\n  for (let i = 0; i < 6; ++i) {\n    const framebuffer = new Framebuffer({\n      context: context,\n      depthRenderbuffer: depthRenderbuffer,\n      colorTextures: [faces[i]],\n      destroyAttachments: false,\n    });\n    const pass = shadowMap._passes[i];\n    pass.framebuffer = framebuffer;\n    pass.passState.framebuffer = framebuffer;\n  }\n\n  shadowMap._shadowMapTexture = cubeMap;\n  shadowMap._depthAttachment = depthRenderbuffer;\n  shadowMap._colorAttachment = cubeMap;\n}\n\nfunction createFramebuffer(shadowMap, context) {\n  if (shadowMap._isPointLight) {\n    createFramebufferCube(shadowMap, context);\n  } else if (shadowMap._usesDepthTexture) {\n    createFramebufferDepth(shadowMap, context);\n  } else {\n    createFramebufferColor(shadowMap, context);\n  }\n}\n\nfunction checkFramebuffer(shadowMap, context) {\n  // Attempt to make an FBO with only a depth texture. If it fails, fallback to a color texture.\n  if (\n    shadowMap._usesDepthTexture &&\n    shadowMap._passes[0].framebuffer.status !==\n      WebGLConstants.FRAMEBUFFER_COMPLETE\n  ) {\n    shadowMap._usesDepthTexture = false;\n    createRenderStates(shadowMap);\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n  }\n}\n\nfunction updateFramebuffer(shadowMap, context) {\n  if (\n    !defined(shadowMap._passes[0].framebuffer) ||\n    shadowMap._shadowMapTexture.width !== shadowMap._textureSize.x\n  ) {\n    destroyFramebuffer(shadowMap);\n    createFramebuffer(shadowMap, context);\n    checkFramebuffer(shadowMap, context);\n    clearFramebuffer(shadowMap, context);\n  }\n}\n\nfunction clearFramebuffer(shadowMap, context, shadowPass) {\n  shadowPass = defaultValue(shadowPass, 0);\n  if (shadowMap._isPointLight || shadowPass === 0) {\n    shadowMap._clearCommand.framebuffer =\n      shadowMap._passes[shadowPass].framebuffer;\n    shadowMap._clearCommand.execute(context, shadowMap._clearPassState);\n  }\n}\n\nfunction resize(shadowMap, size) {\n  shadowMap._size = size;\n  const passes = shadowMap._passes;\n  const numberOfPasses = passes.length;\n  const textureSize = shadowMap._textureSize;\n\n  if (shadowMap._isPointLight) {\n    size =\n      ContextLimits.maximumCubeMapSize >= size\n        ? size\n        : ContextLimits.maximumCubeMapSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    const faceViewport = new BoundingRectangle(0, 0, size, size);\n    passes[0].passState.viewport = faceViewport;\n    passes[1].passState.viewport = faceViewport;\n    passes[2].passState.viewport = faceViewport;\n    passes[3].passState.viewport = faceViewport;\n    passes[4].passState.viewport = faceViewport;\n    passes[5].passState.viewport = faceViewport;\n  } else if (numberOfPasses === 1) {\n    // +----+\n    // |  1 |\n    // +----+\n    size =\n      ContextLimits.maximumTextureSize >= size\n        ? size\n        : ContextLimits.maximumTextureSize;\n    textureSize.x = size;\n    textureSize.y = size;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n  } else if (numberOfPasses === 4) {\n    // +----+----+\n    // |  3 |  4 |\n    // +----+----+\n    // |  1 |  2 |\n    // +----+----+\n    size =\n      ContextLimits.maximumTextureSize >= size * 2\n        ? size\n        : ContextLimits.maximumTextureSize / 2;\n    textureSize.x = size * 2;\n    textureSize.y = size * 2;\n    passes[0].passState.viewport = new BoundingRectangle(0, 0, size, size);\n    passes[1].passState.viewport = new BoundingRectangle(size, 0, size, size);\n    passes[2].passState.viewport = new BoundingRectangle(0, size, size, size);\n    passes[3].passState.viewport = new BoundingRectangle(\n      size,\n      size,\n      size,\n      size\n    );\n  }\n\n  // Update clear pass state\n  shadowMap._clearPassState.viewport = new BoundingRectangle(\n    0,\n    0,\n    textureSize.x,\n    textureSize.y\n  );\n\n  // Transforms shadow coordinates [0, 1] into the pass's region of the texture\n  for (let i = 0; i < numberOfPasses; ++i) {\n    const pass = passes[i];\n    const viewport = pass.passState.viewport;\n    const biasX = viewport.x / textureSize.x;\n    const biasY = viewport.y / textureSize.y;\n    const scaleX = viewport.width / textureSize.x;\n    const scaleY = viewport.height / textureSize.y;\n    pass.textureOffsets = new Matrix4(\n      scaleX,\n      0.0,\n      0.0,\n      biasX,\n      0.0,\n      scaleY,\n      0.0,\n      biasY,\n      0.0,\n      0.0,\n      1.0,\n      0.0,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n}\n\nconst scratchViewport = new BoundingRectangle();\n\nfunction createDebugShadowViewCommand(shadowMap, context) {\n  let fs;\n  if (shadowMap._isPointLight) {\n    fs =\n      \"uniform samplerCube shadowMap_textureCube; \\n\" +\n      \"varying vec2 v_textureCoordinates; \\n\" +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    vec2 uv = v_textureCoordinates; \\n\" +\n      \"    vec3 dir; \\n\" +\n      \" \\n\" +\n      \"    if (uv.y < 0.5) \\n\" +\n      \"    { \\n\" +\n      \"        if (uv.x < 0.333) \\n\" +\n      \"        { \\n\" +\n      \"            dir.x = -1.0; \\n\" +\n      \"            dir.y = uv.x * 6.0 - 1.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 1.0; \\n\" +\n      \"        } \\n\" +\n      \"        else if (uv.x < 0.666) \\n\" +\n      \"        { \\n\" +\n      \"            dir.y = -1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 3.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 1.0; \\n\" +\n      \"        } \\n\" +\n      \"        else \\n\" +\n      \"        { \\n\" +\n      \"            dir.z = -1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 5.0; \\n\" +\n      \"            dir.y = uv.y * 4.0 - 1.0; \\n\" +\n      \"        } \\n\" +\n      \"    } \\n\" +\n      \"    else \\n\" +\n      \"    { \\n\" +\n      \"        if (uv.x < 0.333) \\n\" +\n      \"        { \\n\" +\n      \"            dir.x = 1.0; \\n\" +\n      \"            dir.y = uv.x * 6.0 - 1.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 3.0; \\n\" +\n      \"        } \\n\" +\n      \"        else if (uv.x < 0.666) \\n\" +\n      \"        { \\n\" +\n      \"            dir.y = 1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 3.0; \\n\" +\n      \"            dir.z = uv.y * 4.0 - 3.0; \\n\" +\n      \"        } \\n\" +\n      \"        else \\n\" +\n      \"        { \\n\" +\n      \"            dir.z = 1.0; \\n\" +\n      \"            dir.x = uv.x * 6.0 - 5.0; \\n\" +\n      \"            dir.y = uv.y * 4.0 - 3.0; \\n\" +\n      \"        } \\n\" +\n      \"    } \\n\" +\n      \" \\n\" +\n      \"    float shadow = czm_unpackDepth(textureCube(shadowMap_textureCube, dir)); \\n\" +\n      \"    gl_FragColor = vec4(vec3(shadow), 1.0); \\n\" +\n      \"} \\n\";\n  } else {\n    fs =\n      `${\n        \"uniform sampler2D shadowMap_texture; \\n\" +\n        \"varying vec2 v_textureCoordinates; \\n\" +\n        \"void main() \\n\" +\n        \"{ \\n\"\n      }${\n        shadowMap._usesDepthTexture\n          ? \"    float shadow = texture2D(shadowMap_texture, v_textureCoordinates).r; \\n\"\n          : \"    float shadow = czm_unpackDepth(texture2D(shadowMap_texture, v_textureCoordinates)); \\n\"\n      }    gl_FragColor = vec4(vec3(shadow), 1.0); \\n` + `} \\n`;\n  }\n\n  const drawCommand = context.createViewportQuadCommand(fs, {\n    uniformMap: {\n      shadowMap_texture: function () {\n        return shadowMap._shadowMapTexture;\n      },\n      shadowMap_textureCube: function () {\n        return shadowMap._shadowMapTexture;\n      },\n    },\n  });\n  drawCommand.pass = Pass.OVERLAY;\n  return drawCommand;\n}\n\nfunction updateDebugShadowViewCommand(shadowMap, frameState) {\n  // Draws the shadow map on the bottom-right corner of the screen\n  const context = frameState.context;\n  const screenWidth = frameState.context.drawingBufferWidth;\n  const screenHeight = frameState.context.drawingBufferHeight;\n  const size = Math.min(screenWidth, screenHeight) * 0.3;\n\n  const viewport = scratchViewport;\n  viewport.x = screenWidth - size;\n  viewport.y = 0;\n  viewport.width = size;\n  viewport.height = size;\n\n  let debugCommand = shadowMap._debugShadowViewCommand;\n  if (!defined(debugCommand)) {\n    debugCommand = createDebugShadowViewCommand(shadowMap, context);\n    shadowMap._debugShadowViewCommand = debugCommand;\n  }\n\n  // Get a new RenderState for the updated viewport size\n  if (\n    !defined(debugCommand.renderState) ||\n    !BoundingRectangle.equals(debugCommand.renderState.viewport, viewport)\n  ) {\n    debugCommand.renderState = RenderState.fromCache({\n      viewport: BoundingRectangle.clone(viewport),\n    });\n  }\n\n  frameState.commandList.push(shadowMap._debugShadowViewCommand);\n}\n\nconst frustumCornersNDC = new Array(8);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, -1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, -1.0, 1.0);\nfrustumCornersNDC[4] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[5] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[6] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[7] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\n\nconst scratchMatrix = new Matrix4();\nconst scratchFrustumCorners = new Array(8);\nfor (let i = 0; i < 8; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nfunction createDebugPointLight(modelMatrix, color) {\n  const box = new GeometryInstance({\n    geometry: new BoxOutlineGeometry({\n      minimum: new Cartesian3(-0.5, -0.5, -0.5),\n      maximum: new Cartesian3(0.5, 0.5, 0.5),\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  const sphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({\n      radius: 0.5,\n    }),\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: [box, sphere],\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n    modelMatrix: modelMatrix,\n  });\n}\n\nconst debugOutlineColors = [Color.RED, Color.GREEN, Color.BLUE, Color.MAGENTA];\nconst scratchScale = new Cartesian3();\n\nfunction applyDebugSettings(shadowMap, frameState) {\n  updateDebugShadowViewCommand(shadowMap, frameState);\n\n  const enterFreezeFrame =\n    shadowMap.debugFreezeFrame && !shadowMap._debugFreezeFrame;\n  shadowMap._debugFreezeFrame = shadowMap.debugFreezeFrame;\n\n  // Draw scene camera in freeze frame mode\n  if (shadowMap.debugFreezeFrame) {\n    if (enterFreezeFrame) {\n      // Recreate debug camera when entering freeze frame mode\n      shadowMap._debugCameraFrustum =\n        shadowMap._debugCameraFrustum &&\n        shadowMap._debugCameraFrustum.destroy();\n      shadowMap._debugCameraFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._sceneCamera,\n        color: Color.CYAN,\n        updateOnChange: false,\n      });\n    }\n    shadowMap._debugCameraFrustum.update(frameState);\n  }\n\n  if (shadowMap._cascadesEnabled) {\n    // Draw cascades only in freeze frame mode\n    if (shadowMap.debugFreezeFrame) {\n      if (enterFreezeFrame) {\n        // Recreate debug frustum when entering freeze frame mode\n        shadowMap._debugLightFrustum =\n          shadowMap._debugLightFrustum &&\n          shadowMap._debugLightFrustum.destroy();\n        shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n          camera: shadowMap._shadowMapCamera,\n          color: Color.YELLOW,\n          updateOnChange: false,\n        });\n      }\n      shadowMap._debugLightFrustum.update(frameState);\n\n      for (let i = 0; i < shadowMap._numberOfCascades; ++i) {\n        if (enterFreezeFrame) {\n          // Recreate debug frustum when entering freeze frame mode\n          shadowMap._debugCascadeFrustums[i] =\n            shadowMap._debugCascadeFrustums[i] &&\n            shadowMap._debugCascadeFrustums[i].destroy();\n          shadowMap._debugCascadeFrustums[i] = new DebugCameraPrimitive({\n            camera: shadowMap._passes[i].camera,\n            color: debugOutlineColors[i],\n            updateOnChange: false,\n          });\n        }\n        shadowMap._debugCascadeFrustums[i].update(frameState);\n      }\n    }\n  } else if (shadowMap._isPointLight) {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      const translation = shadowMap._shadowMapCamera.positionWC;\n      const rotation = Quaternion.IDENTITY;\n      const uniformScale = shadowMap._pointLightRadius * 2.0;\n      const scale = Cartesian3.fromElements(\n        uniformScale,\n        uniformScale,\n        uniformScale,\n        scratchScale\n      );\n      const modelMatrix = Matrix4.fromTranslationQuaternionRotationScale(\n        translation,\n        rotation,\n        scale,\n        scratchMatrix\n      );\n\n      shadowMap._debugLightFrustum =\n        shadowMap._debugLightFrustum && shadowMap._debugLightFrustum.destroy();\n      shadowMap._debugLightFrustum = createDebugPointLight(\n        modelMatrix,\n        Color.YELLOW\n      );\n    }\n    shadowMap._debugLightFrustum.update(frameState);\n  } else {\n    if (!defined(shadowMap._debugLightFrustum) || shadowMap._needsUpdate) {\n      shadowMap._debugLightFrustum = new DebugCameraPrimitive({\n        camera: shadowMap._shadowMapCamera,\n        color: Color.YELLOW,\n        updateOnChange: false,\n      });\n    }\n    shadowMap._debugLightFrustum.update(frameState);\n  }\n}\n\nfunction ShadowMapCamera() {\n  this.viewMatrix = new Matrix4();\n  this.inverseViewMatrix = new Matrix4();\n  this.frustum = undefined;\n  this.positionCartographic = new Cartographic();\n  this.positionWC = new Cartesian3();\n  this.directionWC = Cartesian3.clone(Cartesian3.UNIT_Z);\n  this.upWC = Cartesian3.clone(Cartesian3.UNIT_Y);\n  this.rightWC = Cartesian3.clone(Cartesian3.UNIT_X);\n  this.viewProjectionMatrix = new Matrix4();\n}\n\nShadowMapCamera.prototype.clone = function (camera) {\n  Matrix4.clone(camera.viewMatrix, this.viewMatrix);\n  Matrix4.clone(camera.inverseViewMatrix, this.inverseViewMatrix);\n  this.frustum = camera.frustum.clone(this.frustum);\n  Cartographic.clone(camera.positionCartographic, this.positionCartographic);\n  Cartesian3.clone(camera.positionWC, this.positionWC);\n  Cartesian3.clone(camera.directionWC, this.directionWC);\n  Cartesian3.clone(camera.upWC, this.upWC);\n  Cartesian3.clone(camera.rightWC, this.rightWC);\n};\n\n// Converts from NDC space to texture space\nconst scaleBiasMatrix = new Matrix4(\n  0.5,\n  0.0,\n  0.0,\n  0.5,\n  0.0,\n  0.5,\n  0.0,\n  0.5,\n  0.0,\n  0.0,\n  0.5,\n  0.5,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\n\nShadowMapCamera.prototype.getViewProjection = function () {\n  const view = this.viewMatrix;\n  const projection = this.frustum.projectionMatrix;\n  Matrix4.multiply(projection, view, this.viewProjectionMatrix);\n  Matrix4.multiply(\n    scaleBiasMatrix,\n    this.viewProjectionMatrix,\n    this.viewProjectionMatrix\n  );\n  return this.viewProjectionMatrix;\n};\n\nconst scratchSplits = new Array(5);\nconst scratchFrustum = new PerspectiveFrustum();\nconst scratchCascadeDistances = new Array(4);\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\n\nfunction computeCascades(shadowMap, frameState) {\n  const shadowMapCamera = shadowMap._shadowMapCamera;\n  const sceneCamera = shadowMap._sceneCamera;\n  const cameraNear = sceneCamera.frustum.near;\n  const cameraFar = sceneCamera.frustum.far;\n  const numberOfCascades = shadowMap._numberOfCascades;\n\n  // Split cascades. Use a mix of linear and log splits.\n  let i;\n  const range = cameraFar - cameraNear;\n  const ratio = cameraFar / cameraNear;\n\n  let lambda = 0.9;\n  let clampCascadeDistances = false;\n\n  // When the camera is close to a relatively small model, provide more detail in the closer cascades.\n  // If the camera is near or inside a large model, such as the root tile of a city, then use the default values.\n  // To get the most accurate cascade splits we would need to find the min and max values from the depth texture.\n  if (frameState.shadowState.closestObjectSize < 200.0) {\n    clampCascadeDistances = true;\n    lambda = 0.9;\n  }\n\n  const cascadeDistances = scratchCascadeDistances;\n  const splits = scratchSplits;\n  splits[0] = cameraNear;\n  splits[numberOfCascades] = cameraFar;\n\n  // Find initial splits\n  for (i = 0; i < numberOfCascades; ++i) {\n    const p = (i + 1) / numberOfCascades;\n    const logScale = cameraNear * Math.pow(ratio, p);\n    const uniformScale = cameraNear + range * p;\n    const split = CesiumMath.lerp(uniformScale, logScale, lambda);\n    splits[i + 1] = split;\n    cascadeDistances[i] = split - splits[i];\n  }\n\n  if (clampCascadeDistances) {\n    // Clamp each cascade to its maximum distance\n    for (i = 0; i < numberOfCascades; ++i) {\n      cascadeDistances[i] = Math.min(\n        cascadeDistances[i],\n        shadowMap._maximumCascadeDistances[i]\n      );\n    }\n\n    // Recompute splits\n    let distance = splits[0];\n    for (i = 0; i < numberOfCascades - 1; ++i) {\n      distance += cascadeDistances[i];\n      splits[i + 1] = distance;\n    }\n  }\n\n  Cartesian4.unpack(splits, 0, shadowMap._cascadeSplits[0]);\n  Cartesian4.unpack(splits, 1, shadowMap._cascadeSplits[1]);\n  Cartesian4.unpack(cascadeDistances, 0, shadowMap._cascadeDistances);\n\n  const shadowFrustum = shadowMapCamera.frustum;\n  const left = shadowFrustum.left;\n  const right = shadowFrustum.right;\n  const bottom = shadowFrustum.bottom;\n  const top = shadowFrustum.top;\n  const near = shadowFrustum.near;\n  const far = shadowFrustum.far;\n\n  const position = shadowMapCamera.positionWC;\n  const direction = shadowMapCamera.directionWC;\n  const up = shadowMapCamera.upWC;\n\n  const cascadeSubFrustum = sceneCamera.frustum.clone(scratchFrustum);\n  const shadowViewProjection = shadowMapCamera.getViewProjection();\n\n  for (i = 0; i < numberOfCascades; ++i) {\n    // Find the bounding box of the camera sub-frustum in shadow map texture space\n    cascadeSubFrustum.near = splits[i];\n    cascadeSubFrustum.far = splits[i + 1];\n    const viewProjection = Matrix4.multiply(\n      cascadeSubFrustum.projectionMatrix,\n      sceneCamera.viewMatrix,\n      scratchMatrix\n    );\n    const inverseViewProjection = Matrix4.inverse(\n      viewProjection,\n      scratchMatrix\n    );\n    const shadowMapMatrix = Matrix4.multiply(\n      shadowViewProjection,\n      inverseViewProjection,\n      scratchMatrix\n    );\n\n    // Project each corner from camera NDC space to shadow map texture space. Min and max will be from 0 to 1.\n    const min = Cartesian3.fromElements(\n      Number.MAX_VALUE,\n      Number.MAX_VALUE,\n      Number.MAX_VALUE,\n      scratchMin\n    );\n    const max = Cartesian3.fromElements(\n      -Number.MAX_VALUE,\n      -Number.MAX_VALUE,\n      -Number.MAX_VALUE,\n      scratchMax\n    );\n\n    for (let k = 0; k < 8; ++k) {\n      const corner = Cartesian4.clone(\n        frustumCornersNDC[k],\n        scratchFrustumCorners[k]\n      );\n      Matrix4.multiplyByVector(shadowMapMatrix, corner, corner);\n      Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n      Cartesian3.minimumByComponent(corner, min, min);\n      Cartesian3.maximumByComponent(corner, max, max);\n    }\n\n    // Limit light-space coordinates to the [0, 1] range\n    min.x = Math.max(min.x, 0.0);\n    min.y = Math.max(min.y, 0.0);\n    min.z = 0.0; // Always start cascade frustum at the top of the light frustum to capture objects in the light's path\n    max.x = Math.min(max.x, 1.0);\n    max.y = Math.min(max.y, 1.0);\n    max.z = Math.min(max.z, 1.0);\n\n    const pass = shadowMap._passes[i];\n    const cascadeCamera = pass.camera;\n    cascadeCamera.clone(shadowMapCamera); // PERFORMANCE_IDEA : could do a shallow clone for all properties except the frustum\n\n    const frustum = cascadeCamera.frustum;\n    frustum.left = left + min.x * (right - left);\n    frustum.right = left + max.x * (right - left);\n    frustum.bottom = bottom + min.y * (top - bottom);\n    frustum.top = bottom + max.y * (top - bottom);\n    frustum.near = near + min.z * (far - near);\n    frustum.far = near + max.z * (far - near);\n\n    pass.cullingVolume = cascadeCamera.frustum.computeCullingVolume(\n      position,\n      direction,\n      up\n    );\n\n    // Transforms from eye space to the cascade's texture space\n    const cascadeMatrix = shadowMap._cascadeMatrices[i];\n    Matrix4.multiply(\n      cascadeCamera.getViewProjection(),\n      sceneCamera.inverseViewMatrix,\n      cascadeMatrix\n    );\n    Matrix4.multiply(pass.textureOffsets, cascadeMatrix, cascadeMatrix);\n  }\n}\n\nconst scratchLightView = new Matrix4();\nconst scratchRight = new Cartesian3();\nconst scratchUp = new Cartesian3();\nconst scratchTranslation = new Cartesian3();\n\nfunction fitShadowMapToScene(shadowMap, frameState) {\n  const shadowMapCamera = shadowMap._shadowMapCamera;\n  const sceneCamera = shadowMap._sceneCamera;\n\n  // 1. First find a tight bounding box in light space that contains the entire camera frustum.\n  const viewProjection = Matrix4.multiply(\n    sceneCamera.frustum.projectionMatrix,\n    sceneCamera.viewMatrix,\n    scratchMatrix\n  );\n  const inverseViewProjection = Matrix4.inverse(viewProjection, scratchMatrix);\n\n  // Start to construct the light view matrix. Set translation later once the bounding box is found.\n  const lightDir = shadowMapCamera.directionWC;\n  let lightUp = sceneCamera.directionWC; // Align shadows to the camera view.\n  if (Cartesian3.equalsEpsilon(lightDir, lightUp, CesiumMath.EPSILON10)) {\n    lightUp = sceneCamera.upWC;\n  }\n  const lightRight = Cartesian3.cross(lightDir, lightUp, scratchRight);\n  lightUp = Cartesian3.cross(lightRight, lightDir, scratchUp); // Recalculate up now that right is derived\n  Cartesian3.normalize(lightUp, lightUp);\n  Cartesian3.normalize(lightRight, lightRight);\n  const lightPosition = Cartesian3.fromElements(\n    0.0,\n    0.0,\n    0.0,\n    scratchTranslation\n  );\n\n  let lightView = Matrix4.computeView(\n    lightPosition,\n    lightDir,\n    lightUp,\n    lightRight,\n    scratchLightView\n  );\n  const cameraToLight = Matrix4.multiply(\n    lightView,\n    inverseViewProjection,\n    scratchMatrix\n  );\n\n  // Project each corner from NDC space to light view space, and calculate a min and max in light view space\n  const min = Cartesian3.fromElements(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    scratchMin\n  );\n  const max = Cartesian3.fromElements(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    scratchMax\n  );\n\n  for (let i = 0; i < 8; ++i) {\n    const corner = Cartesian4.clone(\n      frustumCornersNDC[i],\n      scratchFrustumCorners[i]\n    );\n    Matrix4.multiplyByVector(cameraToLight, corner, corner);\n    Cartesian3.divideByScalar(corner, corner.w, corner); // Handle the perspective divide\n    Cartesian3.minimumByComponent(corner, min, min);\n    Cartesian3.maximumByComponent(corner, max, max);\n  }\n\n  // 2. Set bounding box back to include objects in the light's view\n  max.z += 1000.0; // Note: in light space, a positive number is behind the camera\n  min.z -= 10.0; // Extend the shadow volume forward slightly to avoid problems right at the edge\n\n  // 3. Adjust light view matrix so that it is centered on the bounding volume\n  const translation = scratchTranslation;\n  translation.x = -(0.5 * (min.x + max.x));\n  translation.y = -(0.5 * (min.y + max.y));\n  translation.z = -max.z;\n\n  const translationMatrix = Matrix4.fromTranslation(translation, scratchMatrix);\n  lightView = Matrix4.multiply(translationMatrix, lightView, lightView);\n\n  // 4. Create an orthographic frustum that covers the bounding box extents\n  const halfWidth = 0.5 * (max.x - min.x);\n  const halfHeight = 0.5 * (max.y - min.y);\n  const depth = max.z - min.z;\n\n  const frustum = shadowMapCamera.frustum;\n  frustum.left = -halfWidth;\n  frustum.right = halfWidth;\n  frustum.bottom = -halfHeight;\n  frustum.top = halfHeight;\n  frustum.near = 0.01;\n  frustum.far = depth;\n\n  // 5. Update the shadow map camera\n  Matrix4.clone(lightView, shadowMapCamera.viewMatrix);\n  Matrix4.inverse(lightView, shadowMapCamera.inverseViewMatrix);\n  Matrix4.getTranslation(\n    shadowMapCamera.inverseViewMatrix,\n    shadowMapCamera.positionWC\n  );\n  frameState.mapProjection.ellipsoid.cartesianToCartographic(\n    shadowMapCamera.positionWC,\n    shadowMapCamera.positionCartographic\n  );\n  Cartesian3.clone(lightDir, shadowMapCamera.directionWC);\n  Cartesian3.clone(lightUp, shadowMapCamera.upWC);\n  Cartesian3.clone(lightRight, shadowMapCamera.rightWC);\n}\n\nconst directions = [\n  new Cartesian3(-1.0, 0.0, 0.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, 0.0, -1.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n  new Cartesian3(0.0, 1.0, 0.0),\n  new Cartesian3(0.0, 0.0, 1.0),\n];\n\nconst ups = [\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, 0.0, -1.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n  new Cartesian3(0.0, 0.0, 1.0),\n  new Cartesian3(0.0, -1.0, 0.0),\n];\n\nconst rights = [\n  new Cartesian3(0.0, 0.0, 1.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n  new Cartesian3(-1.0, 0.0, 0.0),\n  new Cartesian3(0.0, 0.0, -1.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n  new Cartesian3(1.0, 0.0, 0.0),\n];\n\nfunction computeOmnidirectional(shadowMap, frameState) {\n  // All sides share the same frustum\n  const frustum = new PerspectiveFrustum();\n  frustum.fov = CesiumMath.PI_OVER_TWO;\n  frustum.near = 1.0;\n  frustum.far = shadowMap._pointLightRadius;\n  frustum.aspectRatio = 1.0;\n\n  for (let i = 0; i < 6; ++i) {\n    const camera = shadowMap._passes[i].camera;\n    camera.positionWC = shadowMap._shadowMapCamera.positionWC;\n    camera.positionCartographic = frameState.mapProjection.ellipsoid.cartesianToCartographic(\n      camera.positionWC,\n      camera.positionCartographic\n    );\n    camera.directionWC = directions[i];\n    camera.upWC = ups[i];\n    camera.rightWC = rights[i];\n\n    Matrix4.computeView(\n      camera.positionWC,\n      camera.directionWC,\n      camera.upWC,\n      camera.rightWC,\n      camera.viewMatrix\n    );\n    Matrix4.inverse(camera.viewMatrix, camera.inverseViewMatrix);\n\n    camera.frustum = frustum;\n  }\n}\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchBoundingSphere = new BoundingSphere();\nconst scratchCenter = scratchBoundingSphere.center;\n\nfunction checkVisibility(shadowMap, frameState) {\n  const sceneCamera = shadowMap._sceneCamera;\n  const shadowMapCamera = shadowMap._shadowMapCamera;\n\n  const boundingSphere = scratchBoundingSphere;\n\n  // Check whether the shadow map is in view and needs to be updated\n  if (shadowMap._cascadesEnabled) {\n    // If the nearest shadow receiver is further than the shadow map's maximum distance then the shadow map is out of view.\n    if (sceneCamera.frustum.near >= shadowMap.maximumDistance) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    }\n\n    // If the light source is below the horizon then the shadow map is out of view\n    const surfaceNormal = frameState.mapProjection.ellipsoid.geodeticSurfaceNormal(\n      sceneCamera.positionWC,\n      scratchCartesian1\n    );\n    const lightDirection = Cartesian3.negate(\n      shadowMapCamera.directionWC,\n      scratchCartesian2\n    );\n    const dot = Cartesian3.dot(surfaceNormal, lightDirection);\n    if (shadowMap.fadingEnabled) {\n      // Shadows start to fade out once the light gets closer to the horizon.\n      // At this point the globe uses vertex lighting alone to darken the surface.\n      const darknessAmount = CesiumMath.clamp(dot / 0.1, 0.0, 1.0);\n      shadowMap._darkness = CesiumMath.lerp(\n        1.0,\n        shadowMap.darkness,\n        darknessAmount\n      );\n    } else {\n      shadowMap._darkness = shadowMap.darkness;\n    }\n\n    if (dot < 0.0) {\n      shadowMap._outOfView = true;\n      shadowMap._needsUpdate = false;\n      return;\n    }\n\n    // By default cascaded shadows need to update and are always in view\n    shadowMap._needsUpdate = true;\n    shadowMap._outOfView = false;\n  } else if (shadowMap._isPointLight) {\n    // Sphere-frustum intersection test\n    boundingSphere.center = shadowMapCamera.positionWC;\n    boundingSphere.radius = shadowMap._pointLightRadius;\n    shadowMap._outOfView =\n      frameState.cullingVolume.computeVisibility(boundingSphere) ===\n      Intersect.OUTSIDE;\n    shadowMap._needsUpdate =\n      !shadowMap._outOfView &&\n      !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  } else {\n    // Simplify frustum-frustum intersection test as a sphere-frustum test\n    const frustumRadius = shadowMapCamera.frustum.far / 2.0;\n    const frustumCenter = Cartesian3.add(\n      shadowMapCamera.positionWC,\n      Cartesian3.multiplyByScalar(\n        shadowMapCamera.directionWC,\n        frustumRadius,\n        scratchCenter\n      ),\n      scratchCenter\n    );\n    boundingSphere.center = frustumCenter;\n    boundingSphere.radius = frustumRadius;\n    shadowMap._outOfView =\n      frameState.cullingVolume.computeVisibility(boundingSphere) ===\n      Intersect.OUTSIDE;\n    shadowMap._needsUpdate =\n      !shadowMap._outOfView &&\n      !shadowMap._boundingSphere.equals(boundingSphere);\n    BoundingSphere.clone(boundingSphere, shadowMap._boundingSphere);\n  }\n}\n\nfunction updateCameras(shadowMap, frameState) {\n  const camera = frameState.camera; // The actual camera in the scene\n  const lightCamera = shadowMap._lightCamera; // The external camera representing the light source\n  const sceneCamera = shadowMap._sceneCamera; // Clone of camera, with clamped near and far planes\n  const shadowMapCamera = shadowMap._shadowMapCamera; // Camera representing the shadow volume, initially cloned from lightCamera\n\n  // Clone light camera into the shadow map camera\n  if (shadowMap._cascadesEnabled) {\n    Cartesian3.clone(lightCamera.directionWC, shadowMapCamera.directionWC);\n  } else if (shadowMap._isPointLight) {\n    Cartesian3.clone(lightCamera.positionWC, shadowMapCamera.positionWC);\n  } else {\n    shadowMapCamera.clone(lightCamera);\n  }\n\n  // Get the light direction in eye coordinates\n  const lightDirection = shadowMap._lightDirectionEC;\n  Matrix4.multiplyByPointAsVector(\n    camera.viewMatrix,\n    shadowMapCamera.directionWC,\n    lightDirection\n  );\n  Cartesian3.normalize(lightDirection, lightDirection);\n  Cartesian3.negate(lightDirection, lightDirection);\n\n  // Get the light position in eye coordinates\n  Matrix4.multiplyByPoint(\n    camera.viewMatrix,\n    shadowMapCamera.positionWC,\n    shadowMap._lightPositionEC\n  );\n  shadowMap._lightPositionEC.w = shadowMap._pointLightRadius;\n\n  // Get the near and far of the scene camera\n  let near;\n  let far;\n  if (shadowMap._fitNearFar) {\n    // shadowFar can be very large, so limit to shadowMap.maximumDistance\n    // Push the far plane slightly further than the near plane to avoid degenerate frustum\n    near = Math.min(\n      frameState.shadowState.nearPlane,\n      shadowMap.maximumDistance\n    );\n    far = Math.min(frameState.shadowState.farPlane, shadowMap.maximumDistance);\n    far = Math.max(far, near + 1.0);\n  } else {\n    near = camera.frustum.near;\n    far = shadowMap.maximumDistance;\n  }\n\n  shadowMap._sceneCamera = Camera.clone(camera, sceneCamera);\n  camera.frustum.clone(shadowMap._sceneCamera.frustum);\n  shadowMap._sceneCamera.frustum.near = near;\n  shadowMap._sceneCamera.frustum.far = far;\n  shadowMap._distance = far - near;\n\n  checkVisibility(shadowMap, frameState);\n\n  if (!shadowMap._outOfViewPrevious && shadowMap._outOfView) {\n    shadowMap._needsUpdate = true;\n  }\n  shadowMap._outOfViewPrevious = shadowMap._outOfView;\n}\n\n/**\n * @private\n */\nShadowMap.prototype.update = function (frameState) {\n  updateCameras(this, frameState);\n\n  if (this._needsUpdate) {\n    updateFramebuffer(this, frameState.context);\n\n    if (this._isPointLight) {\n      computeOmnidirectional(this, frameState);\n    }\n\n    if (this._cascadesEnabled) {\n      fitShadowMapToScene(this, frameState);\n\n      if (this._numberOfCascades > 1) {\n        computeCascades(this, frameState);\n      }\n    }\n\n    if (!this._isPointLight) {\n      // Compute the culling volume\n      const shadowMapCamera = this._shadowMapCamera;\n      const position = shadowMapCamera.positionWC;\n      const direction = shadowMapCamera.directionWC;\n      const up = shadowMapCamera.upWC;\n      this._shadowMapCullingVolume = shadowMapCamera.frustum.computeCullingVolume(\n        position,\n        direction,\n        up\n      );\n\n      if (this._passes.length === 1) {\n        // Since there is only one pass, use the shadow map camera as the pass camera.\n        this._passes[0].camera.clone(shadowMapCamera);\n      }\n    } else {\n      this._shadowMapCullingVolume = CullingVolume.fromBoundingSphere(\n        this._boundingSphere\n      );\n    }\n  }\n\n  if (this._passes.length === 1) {\n    // Transforms from eye space to shadow texture space.\n    // Always requires an update since the scene camera constantly changes.\n    const inverseView = this._sceneCamera.inverseViewMatrix;\n    Matrix4.multiply(\n      this._shadowMapCamera.getViewProjection(),\n      inverseView,\n      this._shadowMapMatrix\n    );\n  }\n\n  if (this.debugShow) {\n    applyDebugSettings(this, frameState);\n  }\n};\n\n/**\n * @private\n */\nShadowMap.prototype.updatePass = function (context, shadowPass) {\n  clearFramebuffer(this, context, shadowPass);\n};\n\nconst scratchTexelStepSize = new Cartesian2();\n\nfunction combineUniforms(shadowMap, uniforms, isTerrain) {\n  const bias = shadowMap._isPointLight\n    ? shadowMap._pointBias\n    : isTerrain\n    ? shadowMap._terrainBias\n    : shadowMap._primitiveBias;\n\n  const mapUniforms = {\n    shadowMap_texture: function () {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_textureCube: function () {\n      return shadowMap._shadowMapTexture;\n    },\n    shadowMap_matrix: function () {\n      return shadowMap._shadowMapMatrix;\n    },\n    shadowMap_cascadeSplits: function () {\n      return shadowMap._cascadeSplits;\n    },\n    shadowMap_cascadeMatrices: function () {\n      return shadowMap._cascadeMatrices;\n    },\n    shadowMap_lightDirectionEC: function () {\n      return shadowMap._lightDirectionEC;\n    },\n    shadowMap_lightPositionEC: function () {\n      return shadowMap._lightPositionEC;\n    },\n    shadowMap_cascadeDistances: function () {\n      return shadowMap._cascadeDistances;\n    },\n    shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function () {\n      const texelStepSize = scratchTexelStepSize;\n      texelStepSize.x = 1.0 / shadowMap._textureSize.x;\n      texelStepSize.y = 1.0 / shadowMap._textureSize.y;\n\n      return Cartesian4.fromElements(\n        texelStepSize.x,\n        texelStepSize.y,\n        bias.depthBias,\n        bias.normalShadingSmooth,\n        this.combinedUniforms1\n      );\n    },\n    shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function () {\n      return Cartesian4.fromElements(\n        bias.normalOffsetScale,\n        shadowMap._distance,\n        shadowMap.maximumDistance,\n        shadowMap._darkness,\n        this.combinedUniforms2\n      );\n    },\n\n    combinedUniforms1: new Cartesian4(),\n    combinedUniforms2: new Cartesian4(),\n  };\n\n  return combine(uniforms, mapUniforms, false);\n}\n\nfunction createCastDerivedCommand(\n  shadowMap,\n  shadowsDirty,\n  command,\n  context,\n  oldShaderId,\n  result\n) {\n  let castShader;\n  let castRenderState;\n  let castUniformMap;\n  if (defined(result)) {\n    castShader = result.shaderProgram;\n    castRenderState = result.renderState;\n    castUniformMap = result.uniformMap;\n  }\n\n  result = DrawCommand.shallowClone(command, result);\n  result.castShadows = true;\n  result.receiveShadows = false;\n\n  if (\n    !defined(castShader) ||\n    oldShaderId !== command.shaderProgram.id ||\n    shadowsDirty\n  ) {\n    const shaderProgram = command.shaderProgram;\n\n    const isTerrain = command.pass === Pass.GLOBE;\n    const isOpaque = command.pass !== Pass.TRANSLUCENT;\n    const isPointLight = shadowMap._isPointLight;\n    const usesDepthTexture = shadowMap._usesDepthTexture;\n\n    const keyword = ShadowMapShader.getShadowCastShaderKeyword(\n      isPointLight,\n      isTerrain,\n      usesDepthTexture,\n      isOpaque\n    );\n    castShader = context.shaderCache.getDerivedShaderProgram(\n      shaderProgram,\n      keyword\n    );\n    if (!defined(castShader)) {\n      const vertexShaderSource = shaderProgram.vertexShaderSource;\n      const fragmentShaderSource = shaderProgram.fragmentShaderSource;\n\n      const castVS = ShadowMapShader.createShadowCastVertexShader(\n        vertexShaderSource,\n        isPointLight,\n        isTerrain\n      );\n      const castFS = ShadowMapShader.createShadowCastFragmentShader(\n        fragmentShaderSource,\n        isPointLight,\n        usesDepthTexture,\n        isOpaque\n      );\n\n      castShader = context.shaderCache.createDerivedShaderProgram(\n        shaderProgram,\n        keyword,\n        {\n          vertexShaderSource: castVS,\n          fragmentShaderSource: castFS,\n          attributeLocations: shaderProgram._attributeLocations,\n        }\n      );\n    }\n\n    castRenderState = shadowMap._primitiveRenderState;\n    if (isPointLight) {\n      castRenderState = shadowMap._pointRenderState;\n    } else if (isTerrain) {\n      castRenderState = shadowMap._terrainRenderState;\n    }\n\n    // Modify the render state for commands that do not use back-face culling, e.g. flat textured walls\n    const cullEnabled = command.renderState.cull.enabled;\n    if (!cullEnabled) {\n      castRenderState = clone(castRenderState, false);\n      castRenderState.cull = clone(castRenderState.cull, false);\n      castRenderState.cull.enabled = false;\n      castRenderState = RenderState.fromCache(castRenderState);\n    }\n\n    castUniformMap = combineUniforms(shadowMap, command.uniformMap, isTerrain);\n  }\n\n  result.shaderProgram = castShader;\n  result.renderState = castRenderState;\n  result.uniformMap = castUniformMap;\n\n  return result;\n}\n\nShadowMap.createReceiveDerivedCommand = function (\n  lightShadowMaps,\n  command,\n  shadowsDirty,\n  context,\n  result\n) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  const lightShadowMapsEnabled = lightShadowMaps.length > 0;\n  const shaderProgram = command.shaderProgram;\n  const vertexShaderSource = shaderProgram.vertexShaderSource;\n  const fragmentShaderSource = shaderProgram.fragmentShaderSource;\n  const isTerrain = command.pass === Pass.GLOBE;\n\n  let hasTerrainNormal = false;\n  if (isTerrain) {\n    hasTerrainNormal =\n      command.owner.data.renderedMesh.encoding.hasVertexNormals;\n  }\n\n  if (command.receiveShadows && lightShadowMapsEnabled) {\n    // Only generate a receiveCommand if there is a shadow map originating from a light source.\n    let receiveShader;\n    let receiveUniformMap;\n    if (defined(result.receiveCommand)) {\n      receiveShader = result.receiveCommand.shaderProgram;\n      receiveUniformMap = result.receiveCommand.uniformMap;\n    }\n\n    result.receiveCommand = DrawCommand.shallowClone(\n      command,\n      result.receiveCommand\n    );\n    result.castShadows = false;\n    result.receiveShadows = true;\n\n    // If castShadows changed, recompile the receive shadows shader. The normal shading technique simulates\n    // self-shadowing so it should be turned off if castShadows is false.\n    const castShadowsDirty =\n      result.receiveShaderCastShadows !== command.castShadows;\n    const shaderDirty =\n      result.receiveShaderProgramId !== command.shaderProgram.id;\n\n    if (\n      !defined(receiveShader) ||\n      shaderDirty ||\n      shadowsDirty ||\n      castShadowsDirty\n    ) {\n      const keyword = ShadowMapShader.getShadowReceiveShaderKeyword(\n        lightShadowMaps[0],\n        command.castShadows,\n        isTerrain,\n        hasTerrainNormal\n      );\n      receiveShader = context.shaderCache.getDerivedShaderProgram(\n        shaderProgram,\n        keyword\n      );\n      if (!defined(receiveShader)) {\n        const receiveVS = ShadowMapShader.createShadowReceiveVertexShader(\n          vertexShaderSource,\n          isTerrain,\n          hasTerrainNormal\n        );\n        const receiveFS = ShadowMapShader.createShadowReceiveFragmentShader(\n          fragmentShaderSource,\n          lightShadowMaps[0],\n          command.castShadows,\n          isTerrain,\n          hasTerrainNormal\n        );\n\n        receiveShader = context.shaderCache.createDerivedShaderProgram(\n          shaderProgram,\n          keyword,\n          {\n            vertexShaderSource: receiveVS,\n            fragmentShaderSource: receiveFS,\n            attributeLocations: shaderProgram._attributeLocations,\n          }\n        );\n      }\n\n      receiveUniformMap = combineUniforms(\n        lightShadowMaps[0],\n        command.uniformMap,\n        isTerrain\n      );\n    }\n\n    result.receiveCommand.shaderProgram = receiveShader;\n    result.receiveCommand.uniformMap = receiveUniformMap;\n    result.receiveShaderProgramId = command.shaderProgram.id;\n    result.receiveShaderCastShadows = command.castShadows;\n  }\n\n  return result;\n};\n\nShadowMap.createCastDerivedCommand = function (\n  shadowMaps,\n  command,\n  shadowsDirty,\n  context,\n  result\n) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  if (command.castShadows) {\n    let castCommands = result.castCommands;\n    if (!defined(castCommands)) {\n      castCommands = result.castCommands = [];\n    }\n\n    const oldShaderId = result.castShaderProgramId;\n\n    const shadowMapLength = shadowMaps.length;\n    castCommands.length = shadowMapLength;\n\n    for (let i = 0; i < shadowMapLength; ++i) {\n      castCommands[i] = createCastDerivedCommand(\n        shadowMaps[i],\n        shadowsDirty,\n        command,\n        context,\n        oldShaderId,\n        castCommands[i]\n      );\n    }\n\n    result.castShaderProgramId = command.shaderProgram.id;\n  }\n\n  return result;\n};\n\n/**\n * @private\n */\nShadowMap.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nShadowMap.prototype.destroy = function () {\n  destroyFramebuffer(this);\n\n  this._debugLightFrustum =\n    this._debugLightFrustum && this._debugLightFrustum.destroy();\n  this._debugCameraFrustum =\n    this._debugCameraFrustum && this._debugCameraFrustum.destroy();\n  this._debugShadowViewCommand =\n    this._debugShadowViewCommand &&\n    this._debugShadowViewCommand.shaderProgram &&\n    this._debugShadowViewCommand.shaderProgram.destroy();\n\n  for (let i = 0; i < this._numberOfCascades; ++i) {\n    this._debugCascadeFrustums[i] =\n      this._debugCascadeFrustums[i] && this._debugCascadeFrustums[i].destroy();\n  }\n\n  return destroyObject(this);\n};\nexport default ShadowMap;\n","import defined from \"../Core/defined.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\n\n/**\n * @private\n */\nfunction ShadowMapShader() {}\n\nShadowMapShader.getShadowCastShaderKeyword = function (\n  isPointLight,\n  isTerrain,\n  usesDepthTexture,\n  isOpaque\n) {\n  return `castShadow ${isPointLight} ${isTerrain} ${usesDepthTexture} ${isOpaque}`;\n};\n\nShadowMapShader.createShadowCastVertexShader = function (\n  vs,\n  isPointLight,\n  isTerrain\n) {\n  const defines = vs.defines.slice(0);\n  const sources = vs.sources.slice(0);\n\n  defines.push(\"SHADOW_MAP\");\n\n  if (isTerrain) {\n    defines.push(\"GENERATE_POSITION\");\n  }\n\n  const positionVaryingName = ShaderSource.findPositionVarying(vs);\n  const hasPositionVarying = defined(positionVaryingName);\n\n  if (isPointLight && !hasPositionVarying) {\n    const length = sources.length;\n    for (let j = 0; j < length; ++j) {\n      sources[j] = ShaderSource.replaceMain(sources[j], \"czm_shadow_cast_main\");\n    }\n\n    const shadowVS =\n      \"varying vec3 v_positionEC; \\n\" +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    czm_shadow_cast_main(); \\n\" +\n      \"    v_positionEC = (czm_inverseProjection * gl_Position).xyz; \\n\" +\n      \"}\";\n    sources.push(shadowVS);\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\n\nShadowMapShader.createShadowCastFragmentShader = function (\n  fs,\n  isPointLight,\n  usesDepthTexture,\n  opaque\n) {\n  const defines = fs.defines.slice(0);\n  const sources = fs.sources.slice(0);\n\n  defines.push(\"SHADOW_MAP\");\n\n  let positionVaryingName = ShaderSource.findPositionVarying(fs);\n  const hasPositionVarying = defined(positionVaryingName);\n  if (!hasPositionVarying) {\n    positionVaryingName = \"v_positionEC\";\n  }\n\n  const length = sources.length;\n  for (let i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(sources[i], \"czm_shadow_cast_main\");\n  }\n\n  let fsSource = \"\";\n\n  if (isPointLight) {\n    if (!hasPositionVarying) {\n      fsSource += \"varying vec3 v_positionEC; \\n\";\n    }\n    fsSource += \"uniform vec4 shadowMap_lightPositionEC; \\n\";\n  }\n\n  if (opaque) {\n    fsSource += \"void main() \\n\" + \"{ \\n\";\n  } else {\n    fsSource +=\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    czm_shadow_cast_main(); \\n\" +\n      \"    if (gl_FragColor.a == 0.0) \\n\" +\n      \"    { \\n\" +\n      \"       discard; \\n\" +\n      \"    } \\n\";\n  }\n\n  if (isPointLight) {\n    fsSource +=\n      `    float distance = length(${positionVaryingName}); \\n` +\n      `    if (distance >= shadowMap_lightPositionEC.w) \\n` +\n      `    { \\n` +\n      `        discard; \\n` +\n      `    } \\n` +\n      `    distance /= shadowMap_lightPositionEC.w; // radius \\n` +\n      `    gl_FragColor = czm_packDepth(distance); \\n`;\n  } else if (usesDepthTexture) {\n    fsSource += \"    gl_FragColor = vec4(1.0); \\n\";\n  } else {\n    fsSource += \"    gl_FragColor = czm_packDepth(gl_FragCoord.z); \\n\";\n  }\n\n  fsSource += \"} \\n\";\n\n  sources.push(fsSource);\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\n\nShadowMapShader.getShadowReceiveShaderKeyword = function (\n  shadowMap,\n  castShadows,\n  isTerrain,\n  hasTerrainNormal\n) {\n  const usesDepthTexture = shadowMap._usesDepthTexture;\n  const polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  const isPointLight = shadowMap._isPointLight;\n  const isSpotLight = shadowMap._isSpotLight;\n  const hasCascades = shadowMap._numberOfCascades > 1;\n  const debugCascadeColors = shadowMap.debugCascadeColors;\n  const softShadows = shadowMap.softShadows;\n\n  return `receiveShadow ${usesDepthTexture}${polygonOffsetSupported}${isPointLight}${isSpotLight}${hasCascades}${debugCascadeColors}${softShadows}${castShadows}${isTerrain}${hasTerrainNormal}`;\n};\n\nShadowMapShader.createShadowReceiveVertexShader = function (\n  vs,\n  isTerrain,\n  hasTerrainNormal\n) {\n  const defines = vs.defines.slice(0);\n  const sources = vs.sources.slice(0);\n\n  defines.push(\"SHADOW_MAP\");\n\n  if (isTerrain) {\n    if (hasTerrainNormal) {\n      defines.push(\"GENERATE_POSITION_AND_NORMAL\");\n    } else {\n      defines.push(\"GENERATE_POSITION\");\n    }\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\n\nShadowMapShader.createShadowReceiveFragmentShader = function (\n  fs,\n  shadowMap,\n  castShadows,\n  isTerrain,\n  hasTerrainNormal\n) {\n  const normalVaryingName = ShaderSource.findNormalVarying(fs);\n  const hasNormalVarying =\n    (!isTerrain && defined(normalVaryingName)) ||\n    (isTerrain && hasTerrainNormal);\n\n  const positionVaryingName = ShaderSource.findPositionVarying(fs);\n  const hasPositionVarying = defined(positionVaryingName);\n\n  const usesDepthTexture = shadowMap._usesDepthTexture;\n  const polygonOffsetSupported = shadowMap._polygonOffsetSupported;\n  const isPointLight = shadowMap._isPointLight;\n  const isSpotLight = shadowMap._isSpotLight;\n  const hasCascades = shadowMap._numberOfCascades > 1;\n  const debugCascadeColors = shadowMap.debugCascadeColors;\n  const softShadows = shadowMap.softShadows;\n  const bias = isPointLight\n    ? shadowMap._pointBias\n    : isTerrain\n    ? shadowMap._terrainBias\n    : shadowMap._primitiveBias;\n\n  const defines = fs.defines.slice(0);\n  const sources = fs.sources.slice(0);\n\n  const length = sources.length;\n  for (let i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(\n      sources[i],\n      \"czm_shadow_receive_main\"\n    );\n  }\n\n  if (isPointLight) {\n    defines.push(\"USE_CUBE_MAP_SHADOW\");\n  } else if (usesDepthTexture) {\n    defines.push(\"USE_SHADOW_DEPTH_TEXTURE\");\n  }\n\n  if (softShadows && !isPointLight) {\n    defines.push(\"USE_SOFT_SHADOWS\");\n  }\n\n  // Enable day-night shading so that the globe is dark when the light is below the horizon\n  if (hasCascades && castShadows && isTerrain) {\n    if (hasNormalVarying) {\n      defines.push(\"ENABLE_VERTEX_LIGHTING\");\n    } else {\n      defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n    }\n  }\n\n  if (castShadows && bias.normalShading && hasNormalVarying) {\n    defines.push(\"USE_NORMAL_SHADING\");\n    if (bias.normalShadingSmooth > 0.0) {\n      defines.push(\"USE_NORMAL_SHADING_SMOOTH\");\n    }\n  }\n\n  let fsSource = \"\";\n\n  if (isPointLight) {\n    fsSource += \"uniform samplerCube shadowMap_textureCube; \\n\";\n  } else {\n    fsSource += \"uniform sampler2D shadowMap_texture; \\n\";\n  }\n\n  let returnPositionEC;\n  if (hasPositionVarying) {\n    returnPositionEC = `    return vec4(${positionVaryingName}, 1.0); \\n`;\n  } else {\n    returnPositionEC =\n      \"#ifndef LOG_DEPTH \\n\" +\n      \"    return czm_windowToEyeCoordinates(gl_FragCoord); \\n\" +\n      \"#else \\n\" +\n      \"    return vec4(v_logPositionEC, 1.0); \\n\" +\n      \"#endif \\n\";\n  }\n\n  fsSource +=\n    `${\n      \"uniform mat4 shadowMap_matrix; \\n\" +\n      \"uniform vec3 shadowMap_lightDirectionEC; \\n\" +\n      \"uniform vec4 shadowMap_lightPositionEC; \\n\" +\n      \"uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \\n\" +\n      \"uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \\n\" +\n      \"#ifdef LOG_DEPTH \\n\" +\n      \"varying vec3 v_logPositionEC; \\n\" +\n      \"#endif \\n\" +\n      \"vec4 getPositionEC() \\n\" +\n      \"{ \\n\"\n    }${returnPositionEC}} \\n` +\n    `vec3 getNormalEC() \\n` +\n    `{ \\n${\n      hasNormalVarying\n        ? `    return normalize(${normalVaryingName}); \\n`\n        : \"    return vec3(1.0); \\n\"\n    }} \\n` +\n    // Offset the shadow position in the direction of the normal for perpendicular and back faces\n    `void applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) \\n` +\n    `{ \\n${\n      bias.normalOffset && hasNormalVarying\n        ? \"    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; \\n\" +\n          \"    float normalOffsetScale = 1.0 - nDotL; \\n\" +\n          \"    vec3 offset = normalOffset * normalOffsetScale * normalEC; \\n\" +\n          \"    positionEC.xyz += offset; \\n\"\n        : \"\"\n    }} \\n`;\n\n  fsSource +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_shadow_receive_main(); \\n\" +\n    \"    vec4 positionEC = getPositionEC(); \\n\" +\n    \"    vec3 normalEC = getNormalEC(); \\n\" +\n    \"    float depth = -positionEC.z; \\n\";\n\n  fsSource +=\n    \"    czm_shadowParameters shadowParameters; \\n\" +\n    \"    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \\n\" +\n    \"    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \\n\" +\n    \"    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \\n\" +\n    \"    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \\n\";\n\n  if (isTerrain) {\n    // Scale depth bias based on view distance to reduce z-fighting in distant terrain\n    fsSource += \"    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \\n\";\n  } else if (!polygonOffsetSupported) {\n    // If polygon offset isn't supported push the depth back based on view, however this\n    // causes light leaking at further away views\n    fsSource +=\n      \"    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); \\n\";\n  }\n\n  if (isPointLight) {\n    fsSource +=\n      \"    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; \\n\" +\n      \"    float distance = length(directionEC); \\n\" +\n      \"    directionEC = normalize(directionEC); \\n\" +\n      \"    float radius = shadowMap_lightPositionEC.w; \\n\" +\n      \"    // Stop early if the fragment is beyond the point light radius \\n\" +\n      \"    if (distance > radius) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    vec3 directionWC  = czm_inverseViewRotation * directionEC; \\n\" +\n      \"    shadowParameters.depth = distance / radius; \\n\" +\n      \"    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" +\n      \"    shadowParameters.texCoords = directionWC; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); \\n\";\n  } else if (isSpotLight) {\n    fsSource +=\n      \"    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \\n\" +\n      \"    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \\n\" +\n      \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" +\n      \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" +\n      \"    // Spot light uses a perspective projection, so perform the perspective divide \\n\" +\n      \"    shadowPosition /= shadowPosition.w; \\n\" +\n      \"    // Stop early if the fragment is not in the shadow bounds \\n\" +\n      \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" +\n      \"    shadowParameters.depth = shadowPosition.z; \\n\" +\n      \"    shadowParameters.nDotL = nDotL; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  } else if (hasCascades) {\n    fsSource += `${\n      \"    float maxDepth = shadowMap_cascadeSplits[1].w; \\n\" +\n      \"    // Stop early if the eye depth exceeds the last cascade \\n\" +\n      \"    if (depth > maxDepth) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    // Get the cascade based on the eye-space depth \\n\" +\n      \"    vec4 weights = czm_cascadeWeights(depth); \\n\" +\n      \"    // Apply normal offset \\n\" +\n      \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" +\n      \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" +\n      \"    // Transform position into the cascade \\n\" +\n      \"    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; \\n\" +\n      \"    // Get visibility \\n\" +\n      \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" +\n      \"    shadowParameters.depth = shadowPosition.z; \\n\" +\n      \"    shadowParameters.nDotL = nDotL; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\" +\n      \"    // Fade out shadows that are far away \\n\" +\n      \"    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; \\n\" +\n      \"    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); \\n\" +\n      \"    visibility = mix(visibility, 1.0, fade); \\n\"\n    }${\n      debugCascadeColors\n        ? \"    // Draw cascade colors for debugging \\n\" +\n          \"    gl_FragColor *= czm_cascadeColor(weights); \\n\"\n        : \"\"\n    }`;\n  } else {\n    fsSource +=\n      \"    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); \\n\" +\n      \"    applyNormalOffset(positionEC, normalEC, nDotL); \\n\" +\n      \"    vec4 shadowPosition = shadowMap_matrix * positionEC; \\n\" +\n      \"    // Stop early if the fragment is not in the shadow bounds \\n\" +\n      \"    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \\n\" +\n      \"    { \\n\" +\n      \"        return; \\n\" +\n      \"    } \\n\" +\n      \"    shadowParameters.texCoords = shadowPosition.xy; \\n\" +\n      \"    shadowParameters.depth = shadowPosition.z; \\n\" +\n      \"    shadowParameters.nDotL = nDotL; \\n\" +\n      \"    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); \\n\";\n  }\n\n  fsSource += \"    gl_FragColor.rgb *= visibility; \\n\" + \"} \\n\";\n\n  sources.push(fsSource);\n\n  return new ShaderSource({\n    defines: defines,\n    sources: sources,\n  });\n};\nexport default ShadowMapShader;\n","/**\n * Specifies whether the object casts or receives shadows from light sources when\n * shadows are enabled.\n *\n * @enum {Number}\n */\nconst ShadowMode = {\n  /**\n   * The object does not cast or receive shadows.\n   *\n   * @type {Number}\n   * @constant\n   */\n  DISABLED: 0,\n\n  /**\n   * The object casts and receives shadows.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ENABLED: 1,\n\n  /**\n   * The object casts shadows only.\n   *\n   * @type {Number}\n   * @constant\n   */\n  CAST_ONLY: 2,\n\n  /**\n   * The object receives shadows only.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RECEIVE_ONLY: 3,\n};\n\n/**\n * @private\n */\nShadowMode.NUMBER_OF_SHADOW_MODES = 4;\n\n/**\n * @private\n */\nShadowMode.castShadows = function (shadowMode) {\n  return (\n    shadowMode === ShadowMode.ENABLED || shadowMode === ShadowMode.CAST_ONLY\n  );\n};\n\n/**\n * @private\n */\nShadowMode.receiveShadows = function (shadowMode) {\n  return (\n    shadowMode === ShadowMode.ENABLED || shadowMode === ShadowMode.RECEIVE_ONLY\n  );\n};\n\n/**\n * @private\n */\nShadowMode.fromCastReceive = function (castShadows, receiveShadows) {\n  if (castShadows && receiveShadows) {\n    return ShadowMode.ENABLED;\n  } else if (castShadows) {\n    return ShadowMode.CAST_ONLY;\n  } else if (receiveShadows) {\n    return ShadowMode.RECEIVE_ONLY;\n  }\n  return ShadowMode.DISABLED;\n};\n\nexport default Object.freeze(ShadowMode);\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ShadowVolumeAppearanceFS from \"../Shaders/ShadowVolumeAppearanceFS.js\";\n\n/**\n * Creates shaders for a ClassificationPrimitive to use a given Appearance, as well as for picking.\n *\n * @param {Boolean} extentsCulling Discard fragments outside the instance's texture coordinate extents.\n * @param {Boolean} planarExtents If true, texture coordinates will be computed using planes instead of spherical coordinates.\n * @param {Appearance} appearance An Appearance to be used with a ClassificationPrimitive via GroundPrimitive.\n * @private\n */\nfunction ShadowVolumeAppearance(extentsCulling, planarExtents, appearance) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"extentsCulling\", extentsCulling);\n  Check.typeOf.bool(\"planarExtents\", planarExtents);\n  Check.typeOf.object(\"appearance\", appearance);\n  //>>includeEnd('debug');\n\n  this._projectionExtentDefines = {\n    eastMostYhighDefine: \"\",\n    eastMostYlowDefine: \"\",\n    westMostYhighDefine: \"\",\n    westMostYlowDefine: \"\",\n  };\n\n  // Compute shader dependencies\n  const colorShaderDependencies = new ShaderDependencies();\n  colorShaderDependencies.requiresTextureCoordinates = extentsCulling;\n  colorShaderDependencies.requiresEC = !appearance.flat;\n\n  const pickShaderDependencies = new ShaderDependencies();\n  pickShaderDependencies.requiresTextureCoordinates = extentsCulling;\n\n  if (appearance instanceof PerInstanceColorAppearance) {\n    // PerInstanceColorAppearance doesn't have material.shaderSource, instead it has its own vertex and fragment shaders\n    colorShaderDependencies.requiresNormalEC = !appearance.flat;\n  } else {\n    // Scan material source for what hookups are needed. Assume czm_materialInput materialInput.\n    const materialShaderSource = `${appearance.material.shaderSource}\\n${appearance.fragmentShaderSource}`;\n\n    colorShaderDependencies.normalEC =\n      materialShaderSource.indexOf(\"materialInput.normalEC\") !== -1 ||\n      materialShaderSource.indexOf(\"czm_getDefaultMaterial\") !== -1;\n    colorShaderDependencies.positionToEyeEC =\n      materialShaderSource.indexOf(\"materialInput.positionToEyeEC\") !== -1;\n    colorShaderDependencies.tangentToEyeMatrix =\n      materialShaderSource.indexOf(\"materialInput.tangentToEyeMatrix\") !== -1;\n    colorShaderDependencies.st =\n      materialShaderSource.indexOf(\"materialInput.st\") !== -1;\n  }\n\n  this._colorShaderDependencies = colorShaderDependencies;\n  this._pickShaderDependencies = pickShaderDependencies;\n  this._appearance = appearance;\n  this._extentsCulling = extentsCulling;\n  this._planarExtents = planarExtents;\n}\n\n/**\n * Create the fragment shader for a ClassificationPrimitive's color pass when rendering for color.\n *\n * @param {Boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @returns {ShaderSource} Shader source for the fragment shader.\n */\nShadowVolumeAppearance.prototype.createFragmentShader = function (\n  columbusView2D\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  //>>includeEnd('debug');\n\n  const appearance = this._appearance;\n  const dependencies = this._colorShaderDependencies;\n\n  const defines = [];\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n  if (dependencies.requiresNormalEC) {\n    defines.push(\"NORMAL_EC\");\n  }\n  if (appearance instanceof PerInstanceColorAppearance) {\n    defines.push(\"PER_INSTANCE_COLOR\");\n  }\n\n  // Material inputs. Use of parameters in the material is different\n  // from requirement of the parameters in the overall shader, for example,\n  // texture coordinates may be used for fragment culling but not for the material itself.\n  if (dependencies.normalEC) {\n    defines.push(\"USES_NORMAL_EC\");\n  }\n  if (dependencies.positionToEyeEC) {\n    defines.push(\"USES_POSITION_TO_EYE_EC\");\n  }\n  if (dependencies.tangentToEyeMatrix) {\n    defines.push(\"USES_TANGENT_TO_EYE\");\n  }\n  if (dependencies.st) {\n    defines.push(\"USES_ST\");\n  }\n\n  if (appearance.flat) {\n    defines.push(\"FLAT\");\n  }\n\n  let materialSource = \"\";\n  if (!(appearance instanceof PerInstanceColorAppearance)) {\n    materialSource = appearance.material.shaderSource;\n  }\n\n  return new ShaderSource({\n    defines: defines,\n    sources: [materialSource, ShadowVolumeAppearanceFS],\n  });\n};\n\nShadowVolumeAppearance.prototype.createPickFragmentShader = function (\n  columbusView2D\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  //>>includeEnd('debug');\n\n  const dependencies = this._pickShaderDependencies;\n\n  const defines = [\"PICK\"];\n  if (!columbusView2D && !this._planarExtents) {\n    defines.push(\"SPHERICAL\");\n  }\n  if (dependencies.requiresEC) {\n    defines.push(\"REQUIRES_EC\");\n  }\n  if (dependencies.requiresWC) {\n    defines.push(\"REQUIRES_WC\");\n  }\n  if (dependencies.requiresTextureCoordinates) {\n    defines.push(\"TEXTURE_COORDINATES\");\n  }\n  if (this._extentsCulling) {\n    defines.push(\"CULL_FRAGMENTS\");\n  }\n  return new ShaderSource({\n    defines: defines,\n    sources: [ShadowVolumeAppearanceFS],\n    pickColorQualifier: \"varying\",\n  });\n};\n\n/**\n * Create the vertex shader for a ClassificationPrimitive's color pass on the final of 3 shadow volume passes\n *\n * @param {String[]} defines External defines to pass to the vertex shader.\n * @param {String} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position.\n * @param {Boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {String} Shader source for the vertex shader.\n */\nShadowVolumeAppearance.prototype.createVertexShader = function (\n  defines,\n  vertexShaderSource,\n  columbusView2D,\n  mapProjection\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection);\n  //>>includeEnd('debug');\n  return createShadowVolumeAppearanceVS(\n    this._colorShaderDependencies,\n    this._planarExtents,\n    columbusView2D,\n    defines,\n    vertexShaderSource,\n    this._appearance,\n    mapProjection,\n    this._projectionExtentDefines\n  );\n};\n\n/**\n * Create the vertex shader for a ClassificationPrimitive's pick pass on the final of 3 shadow volume passes\n *\n * @param {String[]} defines External defines to pass to the vertex shader.\n * @param {String} vertexShaderSource ShadowVolumeAppearanceVS with any required modifications for computing position and picking.\n * @param {Boolean} columbusView2D Whether the shader will be used for Columbus View or 2D.\n * @param {MapProjection} mapProjection Current scene's map projection.\n * @returns {String} Shader source for the vertex shader.\n */\nShadowVolumeAppearance.prototype.createPickVertexShader = function (\n  defines,\n  vertexShaderSource,\n  columbusView2D,\n  mapProjection\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"defines\", defines);\n  Check.typeOf.string(\"vertexShaderSource\", vertexShaderSource);\n  Check.typeOf.bool(\"columbusView2D\", columbusView2D);\n  Check.defined(\"mapProjection\", mapProjection);\n  //>>includeEnd('debug');\n  return createShadowVolumeAppearanceVS(\n    this._pickShaderDependencies,\n    this._planarExtents,\n    columbusView2D,\n    defines,\n    vertexShaderSource,\n    undefined,\n    mapProjection,\n    this._projectionExtentDefines\n  );\n};\n\nconst longitudeExtentsCartesianScratch = new Cartesian3();\nconst longitudeExtentsCartographicScratch = new Cartographic();\nconst longitudeExtentsEncodeScratch = {\n  high: 0.0,\n  low: 0.0,\n};\nfunction createShadowVolumeAppearanceVS(\n  shaderDependencies,\n  planarExtents,\n  columbusView2D,\n  defines,\n  vertexShaderSource,\n  appearance,\n  mapProjection,\n  projectionExtentDefines\n) {\n  const allDefines = defines.slice();\n\n  if (projectionExtentDefines.eastMostYhighDefine === \"\") {\n    const eastMostCartographic = longitudeExtentsCartographicScratch;\n    eastMostCartographic.longitude = CesiumMath.PI;\n    eastMostCartographic.latitude = 0.0;\n    eastMostCartographic.height = 0.0;\n    const eastMostCartesian = mapProjection.project(\n      eastMostCartographic,\n      longitudeExtentsCartesianScratch\n    );\n    let encoded = EncodedCartesian3.encode(\n      eastMostCartesian.x,\n      longitudeExtentsEncodeScratch\n    );\n    projectionExtentDefines.eastMostYhighDefine = `EAST_MOST_X_HIGH ${encoded.high.toFixed(\n      `${encoded.high}`.length + 1\n    )}`;\n    projectionExtentDefines.eastMostYlowDefine = `EAST_MOST_X_LOW ${encoded.low.toFixed(\n      `${encoded.low}`.length + 1\n    )}`;\n\n    const westMostCartographic = longitudeExtentsCartographicScratch;\n    westMostCartographic.longitude = -CesiumMath.PI;\n    westMostCartographic.latitude = 0.0;\n    westMostCartographic.height = 0.0;\n    const westMostCartesian = mapProjection.project(\n      westMostCartographic,\n      longitudeExtentsCartesianScratch\n    );\n    encoded = EncodedCartesian3.encode(\n      westMostCartesian.x,\n      longitudeExtentsEncodeScratch\n    );\n    projectionExtentDefines.westMostYhighDefine = `WEST_MOST_X_HIGH ${encoded.high.toFixed(\n      `${encoded.high}`.length + 1\n    )}`;\n    projectionExtentDefines.westMostYlowDefine = `WEST_MOST_X_LOW ${encoded.low.toFixed(\n      `${encoded.low}`.length + 1\n    )}`;\n  }\n\n  if (columbusView2D) {\n    allDefines.push(projectionExtentDefines.eastMostYhighDefine);\n    allDefines.push(projectionExtentDefines.eastMostYlowDefine);\n    allDefines.push(projectionExtentDefines.westMostYhighDefine);\n    allDefines.push(projectionExtentDefines.westMostYlowDefine);\n  }\n\n  if (defined(appearance) && appearance instanceof PerInstanceColorAppearance) {\n    allDefines.push(\"PER_INSTANCE_COLOR\");\n  }\n  if (shaderDependencies.requiresTextureCoordinates) {\n    allDefines.push(\"TEXTURE_COORDINATES\");\n    if (!(planarExtents || columbusView2D)) {\n      allDefines.push(\"SPHERICAL\");\n    }\n    if (columbusView2D) {\n      allDefines.push(\"COLUMBUS_VIEW_2D\");\n    }\n  }\n\n  return new ShaderSource({\n    defines: allDefines,\n    sources: [vertexShaderSource],\n  });\n}\n\n/**\n * Tracks shader dependencies.\n * @private\n */\nfunction ShaderDependencies() {\n  this._requiresEC = false;\n  this._requiresWC = false; // depends on eye coordinates, needed for material and for phong\n  this._requiresNormalEC = false; // depends on eye coordinates, needed for material\n  this._requiresTextureCoordinates = false; // depends on world coordinates, needed for material and for culling\n\n  this._usesNormalEC = false;\n  this._usesPositionToEyeEC = false;\n  this._usesTangentToEyeMat = false;\n  this._usesSt = false;\n}\n\nObject.defineProperties(ShaderDependencies.prototype, {\n  // Set when assessing final shading (flat vs. phong) and culling using computed texture coordinates\n  requiresEC: {\n    get: function () {\n      return this._requiresEC;\n    },\n    set: function (value) {\n      this._requiresEC = value || this._requiresEC;\n    },\n  },\n  requiresWC: {\n    get: function () {\n      return this._requiresWC;\n    },\n    set: function (value) {\n      this._requiresWC = value || this._requiresWC;\n      this.requiresEC = this._requiresWC;\n    },\n  },\n  requiresNormalEC: {\n    get: function () {\n      return this._requiresNormalEC;\n    },\n    set: function (value) {\n      this._requiresNormalEC = value || this._requiresNormalEC;\n      this.requiresEC = this._requiresNormalEC;\n    },\n  },\n  requiresTextureCoordinates: {\n    get: function () {\n      return this._requiresTextureCoordinates;\n    },\n    set: function (value) {\n      this._requiresTextureCoordinates =\n        value || this._requiresTextureCoordinates;\n      this.requiresWC = this._requiresTextureCoordinates;\n    },\n  },\n  // Get/Set when assessing material hookups\n  normalEC: {\n    set: function (value) {\n      this.requiresNormalEC = value;\n      this._usesNormalEC = value;\n    },\n    get: function () {\n      return this._usesNormalEC;\n    },\n  },\n  tangentToEyeMatrix: {\n    set: function (value) {\n      this.requiresWC = value;\n      this.requiresNormalEC = value;\n      this._usesTangentToEyeMat = value;\n    },\n    get: function () {\n      return this._usesTangentToEyeMat;\n    },\n  },\n  positionToEyeEC: {\n    set: function (value) {\n      this.requiresEC = value;\n      this._usesPositionToEyeEC = value;\n    },\n    get: function () {\n      return this._usesPositionToEyeEC;\n    },\n  },\n  st: {\n    set: function (value) {\n      this.requiresTextureCoordinates = value;\n      this._usesSt = value;\n    },\n    get: function () {\n      return this._usesSt;\n    },\n  },\n});\n\nfunction pointLineDistance(point1, point2, point) {\n  return (\n    Math.abs(\n      (point2.y - point1.y) * point.x -\n        (point2.x - point1.x) * point.y +\n        point2.x * point1.y -\n        point2.y * point1.x\n    ) / Cartesian2.distance(point2, point1)\n  );\n}\n\nconst points2DScratch = [\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n];\n\n// textureCoordinateRotationPoints form 2 lines in the computed UV space that remap to desired texture coordinates.\n// This allows simulation of baked texture coordinates for EllipseGeometry, RectangleGeometry, and PolygonGeometry.\nfunction addTextureCoordinateRotationAttributes(\n  attributes,\n  textureCoordinateRotationPoints\n) {\n  const points2D = points2DScratch;\n\n  const minXYCorner = Cartesian2.unpack(\n    textureCoordinateRotationPoints,\n    0,\n    points2D[0]\n  );\n  const maxYCorner = Cartesian2.unpack(\n    textureCoordinateRotationPoints,\n    2,\n    points2D[1]\n  );\n  const maxXCorner = Cartesian2.unpack(\n    textureCoordinateRotationPoints,\n    4,\n    points2D[2]\n  );\n\n  attributes.uMaxVmax = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [maxYCorner.x, maxYCorner.y, maxXCorner.x, maxXCorner.y],\n  });\n\n  const inverseExtentX =\n    1.0 / pointLineDistance(minXYCorner, maxYCorner, maxXCorner);\n  const inverseExtentY =\n    1.0 / pointLineDistance(minXYCorner, maxXCorner, maxYCorner);\n\n  attributes.uvMinAndExtents = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: [minXYCorner.x, minXYCorner.y, inverseExtentX, inverseExtentY],\n  });\n}\n\nconst cartographicScratch = new Cartographic();\nconst cornerScratch = new Cartesian3();\nconst northWestScratch = new Cartesian3();\nconst southEastScratch = new Cartesian3();\nconst highLowScratch = { high: 0.0, low: 0.0 };\nfunction add2DTextureCoordinateAttributes(rectangle, projection, attributes) {\n  // Compute corner positions in double precision\n  const carto = cartographicScratch;\n  carto.height = 0.0;\n\n  carto.longitude = rectangle.west;\n  carto.latitude = rectangle.south;\n\n  const southWestCorner = projection.project(carto, cornerScratch);\n\n  carto.latitude = rectangle.north;\n  const northWest = projection.project(carto, northWestScratch);\n\n  carto.longitude = rectangle.east;\n  carto.latitude = rectangle.south;\n  const southEast = projection.project(carto, southEastScratch);\n\n  // Since these positions are all in the 2D plane, there's a lot of zeros\n  // and a lot of repetition. So we only need to encode 4 values.\n  // Encode:\n  // x: x value for southWestCorner\n  // y: y value for southWestCorner\n  // z: y value for northWest\n  // w: x value for southEast\n\n  const valuesHigh = [0, 0, 0, 0];\n  const valuesLow = [0, 0, 0, 0];\n  let encoded = EncodedCartesian3.encode(southWestCorner.x, highLowScratch);\n  valuesHigh[0] = encoded.high;\n  valuesLow[0] = encoded.low;\n\n  encoded = EncodedCartesian3.encode(southWestCorner.y, highLowScratch);\n  valuesHigh[1] = encoded.high;\n  valuesLow[1] = encoded.low;\n\n  encoded = EncodedCartesian3.encode(northWest.y, highLowScratch);\n  valuesHigh[2] = encoded.high;\n  valuesLow[2] = encoded.low;\n\n  encoded = EncodedCartesian3.encode(southEast.x, highLowScratch);\n  valuesHigh[3] = encoded.high;\n  valuesLow[3] = encoded.low;\n\n  attributes.planes2D_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesHigh,\n  });\n\n  attributes.planes2D_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 4,\n    normalize: false,\n    value: valuesLow,\n  });\n}\n\nconst enuMatrixScratch = new Matrix4();\nconst inverseEnuScratch = new Matrix4();\nconst rectanglePointCartesianScratch = new Cartesian3();\nconst rectangleCenterScratch = new Cartographic();\nconst pointsCartographicScratch = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\n/**\n * When computing planes to bound the rectangle,\n * need to factor in \"bulge\" and other distortion.\n * Flatten the ellipsoid-centered corners and edge-centers of the rectangle\n * into the plane of the local ENU system, compute bounds in 2D, and\n * project back to ellipsoid-centered.\n *\n * @private\n */\nfunction computeRectangleBounds(\n  rectangle,\n  ellipsoid,\n  height,\n  southWestCornerResult,\n  eastVectorResult,\n  northVectorResult\n) {\n  // Compute center of rectangle\n  const centerCartographic = Rectangle.center(\n    rectangle,\n    rectangleCenterScratch\n  );\n  centerCartographic.height = height;\n  const centerCartesian = Cartographic.toCartesian(\n    centerCartographic,\n    ellipsoid,\n    rectanglePointCartesianScratch\n  );\n  const enuMatrix = Transforms.eastNorthUpToFixedFrame(\n    centerCartesian,\n    ellipsoid,\n    enuMatrixScratch\n  );\n  const inverseEnu = Matrix4.inverse(enuMatrix, inverseEnuScratch);\n\n  const west = rectangle.west;\n  const east = rectangle.east;\n  const north = rectangle.north;\n  const south = rectangle.south;\n\n  const cartographics = pointsCartographicScratch;\n  cartographics[0].latitude = south;\n  cartographics[0].longitude = west;\n  cartographics[1].latitude = north;\n  cartographics[1].longitude = west;\n  cartographics[2].latitude = north;\n  cartographics[2].longitude = east;\n  cartographics[3].latitude = south;\n  cartographics[3].longitude = east;\n\n  const longitudeCenter = (west + east) * 0.5;\n  const latitudeCenter = (north + south) * 0.5;\n\n  cartographics[4].latitude = south;\n  cartographics[4].longitude = longitudeCenter;\n  cartographics[5].latitude = north;\n  cartographics[5].longitude = longitudeCenter;\n  cartographics[6].latitude = latitudeCenter;\n  cartographics[6].longitude = west;\n  cartographics[7].latitude = latitudeCenter;\n  cartographics[7].longitude = east;\n\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n  for (let i = 0; i < 8; i++) {\n    cartographics[i].height = height;\n    const pointCartesian = Cartographic.toCartesian(\n      cartographics[i],\n      ellipsoid,\n      rectanglePointCartesianScratch\n    );\n    Matrix4.multiplyByPoint(inverseEnu, pointCartesian, pointCartesian);\n    pointCartesian.z = 0.0; // flatten into XY plane of ENU coordinate system\n    minX = Math.min(minX, pointCartesian.x);\n    maxX = Math.max(maxX, pointCartesian.x);\n    minY = Math.min(minY, pointCartesian.y);\n    maxY = Math.max(maxY, pointCartesian.y);\n  }\n\n  const southWestCorner = southWestCornerResult;\n  southWestCorner.x = minX;\n  southWestCorner.y = minY;\n  southWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southWestCorner, southWestCorner);\n\n  const southEastCorner = eastVectorResult;\n  southEastCorner.x = maxX;\n  southEastCorner.y = minY;\n  southEastCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, southEastCorner, southEastCorner);\n  // make eastward vector\n  Cartesian3.subtract(southEastCorner, southWestCorner, eastVectorResult);\n\n  const northWestCorner = northVectorResult;\n  northWestCorner.x = minX;\n  northWestCorner.y = maxY;\n  northWestCorner.z = 0.0;\n  Matrix4.multiplyByPoint(enuMatrix, northWestCorner, northWestCorner);\n  // make eastward vector\n  Cartesian3.subtract(northWestCorner, southWestCorner, northVectorResult);\n}\n\nconst eastwardScratch = new Cartesian3();\nconst northwardScratch = new Cartesian3();\nconst encodeScratch = new EncodedCartesian3();\n/**\n * Gets an attributes object containing:\n * - 3 high-precision points as 6 GeometryInstanceAttributes. These points are used to compute eye-space planes.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used to compute texture coordinates for small-area ClassificationPrimitives with materials or multiple non-overlapping instances.\n *\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the points will approximately bound\n * @param {Number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @param {Number} [height=0] The maximum height for the shadow volume.\n * @returns {Object} An attributes dictionary containing planar texture coordinate attributes.\n */\nShadowVolumeAppearance.getPlanarTextureCoordinateAttributes = function (\n  boundingRectangle,\n  textureCoordinateRotationPoints,\n  ellipsoid,\n  projection,\n  height\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\n    \"textureCoordinateRotationPoints\",\n    textureCoordinateRotationPoints\n  );\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection);\n  //>>includeEnd('debug');\n\n  const corner = cornerScratch;\n  const eastward = eastwardScratch;\n  const northward = northwardScratch;\n  computeRectangleBounds(\n    boundingRectangle,\n    ellipsoid,\n    defaultValue(height, 0.0),\n    corner,\n    eastward,\n    northward\n  );\n\n  const attributes = {};\n  addTextureCoordinateRotationAttributes(\n    attributes,\n    textureCoordinateRotationPoints\n  );\n\n  const encoded = EncodedCartesian3.fromCartesian(corner, encodeScratch);\n\n  attributes.southWest_HIGH = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.high, [0, 0, 0]),\n  });\n  attributes.southWest_LOW = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(encoded.low, [0, 0, 0]),\n  });\n  attributes.eastward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(eastward, [0, 0, 0]),\n  });\n  attributes.northward = new GeometryInstanceAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    normalize: false,\n    value: Cartesian3.pack(northward, [0, 0, 0]),\n  });\n\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\n\nconst spherePointScratch = new Cartesian3();\nfunction latLongToSpherical(latitude, longitude, ellipsoid, result) {\n  const cartographic = cartographicScratch;\n  cartographic.latitude = latitude;\n  cartographic.longitude = longitude;\n  cartographic.height = 0.0;\n\n  const spherePoint = Cartographic.toCartesian(\n    cartographic,\n    ellipsoid,\n    spherePointScratch\n  );\n\n  // Project into plane with vertical for latitude\n  const magXY = Math.sqrt(\n    spherePoint.x * spherePoint.x + spherePoint.y * spherePoint.y\n  );\n\n  // Use fastApproximateAtan2 for alignment with shader\n  const sphereLatitude = CesiumMath.fastApproximateAtan2(magXY, spherePoint.z);\n  const sphereLongitude = CesiumMath.fastApproximateAtan2(\n    spherePoint.x,\n    spherePoint.y\n  );\n\n  result.x = sphereLatitude;\n  result.y = sphereLongitude;\n\n  return result;\n}\n\nconst sphericalScratch = new Cartesian2();\n/**\n * Gets an attributes object containing:\n * - the southwest corner of a rectangular area in spherical coordinates, as well as the inverse of the latitude/longitude range.\n *   These are computed using the same atan2 approximation used in the shader.\n * - 1 texture coordinate rotation GeometryInstanceAttributes\n * - 2 GeometryInstanceAttributes used to compute high-precision points in 2D and Columbus View.\n *   These points are used to compute eye-space planes like above.\n *\n * Used when computing texture coordinates for large-area ClassificationPrimitives with materials or\n * multiple non-overlapping instances.\n * @see ShadowVolumeAppearance\n * @private\n *\n * @param {Rectangle} boundingRectangle Rectangle object that the spherical extents will approximately bound\n * @param {Number[]} textureCoordinateRotationPoints Points in the computed texture coordinate system for remapping texture coordinates\n * @param {Ellipsoid} ellipsoid Ellipsoid for converting Rectangle points to world coordinates\n * @param {MapProjection} projection The MapProjection used for 2D and Columbus View.\n * @returns {Object} An attributes dictionary containing spherical texture coordinate attributes.\n */\nShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes = function (\n  boundingRectangle,\n  textureCoordinateRotationPoints,\n  ellipsoid,\n  projection\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"boundingRectangle\", boundingRectangle);\n  Check.defined(\n    \"textureCoordinateRotationPoints\",\n    textureCoordinateRotationPoints\n  );\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  Check.typeOf.object(\"projection\", projection);\n  //>>includeEnd('debug');\n\n  // rectangle cartographic coords !== spherical because it's on an ellipsoid\n  const southWestExtents = latLongToSpherical(\n    boundingRectangle.south,\n    boundingRectangle.west,\n    ellipsoid,\n    sphericalScratch\n  );\n\n  let south = southWestExtents.x;\n  let west = southWestExtents.y;\n\n  const northEastExtents = latLongToSpherical(\n    boundingRectangle.north,\n    boundingRectangle.east,\n    ellipsoid,\n    sphericalScratch\n  );\n  let north = northEastExtents.x;\n  let east = northEastExtents.y;\n\n  // If the bounding rectangle crosses the IDL, rotate the spherical extents so the cross no longer happens.\n  // This rotation must happen in the shader too.\n  let rotationRadians = 0.0;\n  if (west > east) {\n    rotationRadians = CesiumMath.PI - west;\n    west = -CesiumMath.PI;\n    east += rotationRadians;\n  }\n\n  // Slightly pad extents to avoid floating point error when fragment culling at edges.\n  south -= CesiumMath.EPSILON5;\n  west -= CesiumMath.EPSILON5;\n  north += CesiumMath.EPSILON5;\n  east += CesiumMath.EPSILON5;\n\n  const longitudeRangeInverse = 1.0 / (east - west);\n  const latitudeRangeInverse = 1.0 / (north - south);\n\n  const attributes = {\n    sphericalExtents: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 4,\n      normalize: false,\n      value: [south, west, latitudeRangeInverse, longitudeRangeInverse],\n    }),\n    longitudeRotation: new GeometryInstanceAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 1,\n      normalize: false,\n      value: [rotationRadians],\n    }),\n  };\n\n  addTextureCoordinateRotationAttributes(\n    attributes,\n    textureCoordinateRotationPoints\n  );\n  add2DTextureCoordinateAttributes(boundingRectangle, projection, attributes);\n  return attributes;\n};\n\nShadowVolumeAppearance.hasAttributesForTextureCoordinatePlanes = function (\n  attributes\n) {\n  return (\n    defined(attributes.southWest_HIGH) &&\n    defined(attributes.southWest_LOW) &&\n    defined(attributes.northward) &&\n    defined(attributes.eastward) &&\n    defined(attributes.planes2D_HIGH) &&\n    defined(attributes.planes2D_LOW) &&\n    defined(attributes.uMaxVmax) &&\n    defined(attributes.uvMinAndExtents)\n  );\n};\n\nShadowVolumeAppearance.hasAttributesForSphericalExtents = function (\n  attributes\n) {\n  return (\n    defined(attributes.sphericalExtents) &&\n    defined(attributes.longitudeRotation) &&\n    defined(attributes.planes2D_HIGH) &&\n    defined(attributes.planes2D_LOW) &&\n    defined(attributes.uMaxVmax) &&\n    defined(attributes.uvMinAndExtents)\n  );\n};\n\nfunction shouldUseSpherical(rectangle) {\n  return (\n    Math.max(rectangle.width, rectangle.height) >\n    ShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS\n  );\n}\n\n/**\n * Computes whether the given rectangle is wide enough that texture coordinates\n * over its area should be computed using spherical extents instead of distance to planes.\n *\n * @param {Rectangle} rectangle A rectangle\n * @private\n */\nShadowVolumeAppearance.shouldUseSphericalCoordinates = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  return shouldUseSpherical(rectangle);\n};\n\n/**\n * Texture coordinates for ground primitives are computed either using spherical coordinates for large areas or\n * using distance from planes for small areas.\n *\n * @type {Number}\n * @constant\n * @private\n */\nShadowVolumeAppearance.MAX_WIDTH_FOR_PLANAR_EXTENTS = CesiumMath.toRadians(1.0);\nexport default ShadowVolumeAppearance;\n","import Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport ImageryProvider from \"./ImageryProvider.js\";\n\n/**\n * @typedef {Object} SingleTileImageryProvider.ConstructorOptions\n *\n * Initialization options for the SingleTileImageryProvider constructor\n *\n * @property {Resource|String} url The url for the tile.\n * @property {Rectangle} [rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @property {Credit|String} [credit] A credit for the data source, which is displayed on the canvas.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n */\n\n/**\n * Provides a single, top-level imagery tile.  The single image is assumed to use a\n * {@link GeographicTilingScheme}.\n *\n * @alias SingleTileImageryProvider\n * @constructor\n *\n * @param {SingleTileImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n */\nfunction SingleTileImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  const resource = Resource.createIfNeeded(options.url);\n\n  const rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  const tilingScheme = new GeographicTilingScheme({\n    rectangle: rectangle,\n    numberOfLevelZeroTilesX: 1,\n    numberOfLevelZeroTilesY: 1,\n    ellipsoid: options.ellipsoid,\n  });\n  this._tilingScheme = tilingScheme;\n  this._resource = resource;\n  this._image = undefined;\n  this._texture = undefined;\n  this._tileWidth = 0;\n  this._tileHeight = 0;\n\n  this._errorEvent = new Event();\n\n  this._ready = false;\n  this._readyPromise = defer();\n\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  const that = this;\n  let error;\n\n  function success(image) {\n    that._image = image;\n    that._tileWidth = image.width;\n    that._tileHeight = image.height;\n    that._ready = true;\n    that._readyPromise.resolve(true);\n    TileProviderError.handleSuccess(that._errorEvent);\n  }\n\n  function failure(e) {\n    const message = `Failed to load image ${resource.url}.`;\n    error = TileProviderError.handleError(\n      error,\n      that,\n      that._errorEvent,\n      message,\n      0,\n      0,\n      0,\n      doRequest,\n      e\n    );\n    if (!error.retry) {\n      that._readyPromise.reject(new RuntimeError(message));\n    }\n  }\n\n  function doRequest() {\n    ImageryProvider.loadImage(null, resource).then(success).catch(failure);\n  }\n\n  doRequest();\n}\n\nObject.defineProperties(SingleTileImageryProvider.prototype, {\n  /**\n   * Gets the URL of the single, top-level imagery tile.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._resource.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._resource.proxy;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileWidth must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"maximumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"minimumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._tilingScheme.rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileDiscardPolicy must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link SingleTileImageryProvider#ready} returns true.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof SingleTileImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return true;\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nSingleTileImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link SingleTileImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} The resolved image\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nSingleTileImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestImage must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(this._image)) {\n    return;\n  }\n\n  return Promise.resolve(this._image);\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {undefined} Undefined since picking is not supported.\n */\nSingleTileImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return undefined;\n};\nexport default SingleTileImageryProvider;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport AtmosphereCommon from \"../Shaders/AtmosphereCommon.js\";\nimport SkyAtmosphereCommon from \"../Shaders/SkyAtmosphereCommon.js\";\nimport SkyAtmosphereFS from \"../Shaders/SkyAtmosphereFS.js\";\nimport SkyAtmosphereVS from \"../Shaders/SkyAtmosphereVS.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * An atmosphere drawn around the limb of the provided ellipsoid. Based on\n * {@link http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf|Display of The Earth Taking Into Account Atmospheric Scattering}.\n * <p>\n * This is only supported in 3D. Atmosphere is faded out when morphing to 2D or Columbus view.\n * </p>\n *\n * @alias SkyAtmosphere\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that the atmosphere is drawn around.\n *\n * @example\n * scene.skyAtmosphere = new Cesium.SkyAtmosphere();\n *\n * @see Scene.skyAtmosphere\n */\nfunction SkyAtmosphere(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  /**\n   * Determines if the atmosphere is shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = true;\n\n  /**\n   * Compute atmosphere per-fragment instead of per-vertex.\n   * This produces better looking atmosphere with a slight performance penalty.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.perFragmentAtmosphere = false;\n\n  this._ellipsoid = ellipsoid;\n\n  const outerEllipsoidScale = 1.025;\n  const scaleVector = Cartesian3.multiplyByScalar(\n    ellipsoid.radii,\n    outerEllipsoidScale,\n    new Cartesian3()\n  );\n  this._scaleMatrix = Matrix4.fromScale(scaleVector);\n  this._modelMatrix = new Matrix4();\n\n  this._command = new DrawCommand({\n    owner: this,\n    modelMatrix: this._modelMatrix,\n  });\n  this._spSkyFromSpace = undefined;\n  this._spSkyFromAtmosphere = undefined;\n\n  this._flags = undefined;\n\n  /**\n   * The intensity of the light that is used for computing the sky atmosphere color.\n   *\n   * @type {Number}\n   * @default 50.0\n   */\n  this.atmosphereLightIntensity = 50.0;\n\n  /**\n   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(5.5e-6, 13.0e-6, 28.4e-6)\n   */\n  this.atmosphereRayleighCoefficient = new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6);\n\n  /**\n   * The Mie scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(21e-6, 21e-6, 21e-6)\n   */\n  this.atmosphereMieCoefficient = new Cartesian3(21e-6, 21e-6, 21e-6);\n\n  /**\n   * The Rayleigh scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   *\n   * @type {Number}\n   * @default 10000.0\n   */\n  this.atmosphereRayleighScaleHeight = 10000.0;\n\n  /**\n   * The Mie scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.\n   *\n   * @type {Number}\n   * @default 3200.0\n   */\n  this.atmosphereMieScaleHeight = 3200.0;\n\n  /**\n   * The anisotropy of the medium to consider for Mie scattering.\n   * <p>\n   * Valid values are between -1.0 and 1.0.\n   * </p>\n   * @type {Number}\n   * @default 0.9\n   */\n  this.atmosphereMieAnisotropy = 0.9;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.hueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.saturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.brightnessShift = 0.0;\n\n  this._hueSaturationBrightness = new Cartesian3();\n\n  // outer radius, inner radius, dynamic atmosphere color flag\n  const radiiAndDynamicAtmosphereColor = new Cartesian3();\n\n  radiiAndDynamicAtmosphereColor.x =\n    ellipsoid.maximumRadius * outerEllipsoidScale;\n  radiiAndDynamicAtmosphereColor.y = ellipsoid.maximumRadius;\n\n  // Toggles whether the sun position is used. 0 treats the sun as always directly overhead.\n  radiiAndDynamicAtmosphereColor.z = 0;\n\n  this._radiiAndDynamicAtmosphereColor = radiiAndDynamicAtmosphereColor;\n\n  const that = this;\n\n  this._command.uniformMap = {\n    u_radiiAndDynamicAtmosphereColor: function () {\n      return that._radiiAndDynamicAtmosphereColor;\n    },\n    u_hsbShift: function () {\n      that._hueSaturationBrightness.x = that.hueShift;\n      that._hueSaturationBrightness.y = that.saturationShift;\n      that._hueSaturationBrightness.z = that.brightnessShift;\n      return that._hueSaturationBrightness;\n    },\n    u_atmosphereLightIntensity: function () {\n      return that.atmosphereLightIntensity;\n    },\n    u_atmosphereRayleighCoefficient: function () {\n      return that.atmosphereRayleighCoefficient;\n    },\n    u_atmosphereMieCoefficient: function () {\n      return that.atmosphereMieCoefficient;\n    },\n    u_atmosphereRayleighScaleHeight: function () {\n      return that.atmosphereRayleighScaleHeight;\n    },\n    u_atmosphereMieScaleHeight: function () {\n      return that.atmosphereMieScaleHeight;\n    },\n    u_atmosphereMieAnisotropy: function () {\n      return that.atmosphereMieAnisotropy;\n    },\n  };\n}\n\nObject.defineProperties(SkyAtmosphere.prototype, {\n  /**\n   * Gets the ellipsoid the atmosphere is drawn around.\n   * @memberof SkyAtmosphere.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * @private\n */\nSkyAtmosphere.prototype.setDynamicAtmosphereColor = function (\n  enableLighting,\n  useSunDirection\n) {\n  const lightEnum = enableLighting ? (useSunDirection ? 2.0 : 1.0) : 0.0;\n  this._radiiAndDynamicAtmosphereColor.z = lightEnum;\n};\n\nconst scratchModelMatrix = new Matrix4();\n\n/**\n * @private\n */\nSkyAtmosphere.prototype.update = function (frameState, globe) {\n  if (!this.show) {\n    return undefined;\n  }\n\n  const mode = frameState.mode;\n  if (mode !== SceneMode.SCENE3D && mode !== SceneMode.MORPHING) {\n    return undefined;\n  }\n\n  // The atmosphere is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  // Align the ellipsoid geometry so it always faces the same direction as the\n  // camera to reduce artifacts when rendering atmosphere per-vertex\n  const rotationMatrix = Matrix4.fromRotationTranslation(\n    frameState.context.uniformState.inverseViewRotation,\n    Cartesian3.ZERO,\n    scratchModelMatrix\n  );\n  const rotationOffsetMatrix = Matrix4.multiplyTransformation(\n    rotationMatrix,\n    Axis.Y_UP_TO_Z_UP,\n    scratchModelMatrix\n  );\n  const modelMatrix = Matrix4.multiply(\n    this._scaleMatrix,\n    rotationOffsetMatrix,\n    scratchModelMatrix\n  );\n  Matrix4.clone(modelMatrix, this._modelMatrix);\n\n  const context = frameState.context;\n\n  const colorCorrect = hasColorCorrection(this);\n  const translucent = frameState.globeTranslucencyState.translucent;\n  const perFragmentAtmosphere =\n    this.perFragmentAtmosphere || translucent || !defined(globe) || !globe.show;\n\n  const command = this._command;\n\n  if (!defined(command.vertexArray)) {\n    const geometry = EllipsoidGeometry.createGeometry(\n      new EllipsoidGeometry({\n        radii: new Cartesian3(1.0, 1.0, 1.0),\n        slicePartitions: 256,\n        stackPartitions: 256,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: GeometryPipeline.createAttributeLocations(geometry),\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n    command.renderState = RenderState.fromCache({\n      cull: {\n        enabled: true,\n        face: CullFace.FRONT,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: false,\n    });\n  }\n\n  const flags =\n    colorCorrect | (perFragmentAtmosphere << 2) | (translucent << 3);\n\n  if (flags !== this._flags) {\n    this._flags = flags;\n\n    const defines = [];\n\n    if (colorCorrect) {\n      defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (perFragmentAtmosphere) {\n      defines.push(\"PER_FRAGMENT_ATMOSPHERE\");\n    }\n\n    if (translucent) {\n      defines.push(\"GLOBE_TRANSLUCENT\");\n    }\n\n    const vs = new ShaderSource({\n      defines: defines,\n      sources: [AtmosphereCommon, SkyAtmosphereCommon, SkyAtmosphereVS],\n    });\n\n    const fs = new ShaderSource({\n      defines: defines,\n      sources: [AtmosphereCommon, SkyAtmosphereCommon, SkyAtmosphereFS],\n    });\n\n    this._spSkyAtmosphere = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n    });\n\n    command.shaderProgram = this._spSkyAtmosphere;\n  }\n\n  return command;\n};\n\nfunction hasColorCorrection(skyAtmosphere) {\n  return !(\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.hueShift,\n      0.0,\n      CesiumMath.EPSILON7\n    ) &&\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.saturationShift,\n      0.0,\n      CesiumMath.EPSILON7\n    ) &&\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.brightnessShift,\n      0.0,\n      CesiumMath.EPSILON7\n    )\n  );\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyAtmosphere#destroy\n */\nSkyAtmosphere.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();\n *\n * @see SkyAtmosphere#isDestroyed\n */\nSkyAtmosphere.prototype.destroy = function () {\n  const command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  this._spSkyAtmosphere =\n    this._spSkyAtmosphere && this._spSkyAtmosphere.destroy();\n  return destroyObject(this);\n};\nexport default SkyAtmosphere;\n","import BoxGeometry from \"../Core/BoxGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport loadCubeMap from \"../Renderer/loadCubeMap.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport SkyBoxFS from \"../Shaders/SkyBoxFS.js\";\nimport SkyBoxVS from \"../Shaders/SkyBoxVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.\n * <p>\n * This is only supported in 3D.  The sky box is faded out when morphing to 2D or Columbus view.  The size of\n * the sky box must not exceed {@link Scene#maximumCubeMapSize}.\n * </p>\n *\n * @alias SkyBox\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} [options.sources] The source URL or <code>Image</code> object for each of the six cube map faces.  See the example below.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n *\n *\n * @example\n * scene.skyBox = new Cesium.SkyBox({\n *   sources : {\n *     positiveX : 'skybox_px.png',\n *     negativeX : 'skybox_nx.png',\n *     positiveY : 'skybox_py.png',\n *     negativeY : 'skybox_ny.png',\n *     positiveZ : 'skybox_pz.png',\n *     negativeZ : 'skybox_nz.png'\n *   }\n * });\n *\n * @see Scene#skyBox\n * @see Transforms.computeTemeToPseudoFixedMatrix\n */\nfunction SkyBox(options) {\n  /**\n   * The sources used to create the cube map faces: an object\n   * with <code>positiveX</code>, <code>negativeX</code>, <code>positiveY</code>,\n   * <code>negativeY</code>, <code>positiveZ</code>, and <code>negativeZ</code> properties.\n   * These can be either URLs or <code>Image</code> objects.\n   *\n   * @type Object\n   * @default undefined\n   */\n  this.sources = options.sources;\n  this._sources = undefined;\n\n  /**\n   * Determines if the sky box will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  this._command = new DrawCommand({\n    modelMatrix: Matrix4.clone(Matrix4.IDENTITY),\n    owner: this,\n  });\n  this._cubeMap = undefined;\n\n  this._attributeLocations = undefined;\n  this._useHdr = undefined;\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.\n * @exception {DeveloperError} this.sources properties must all be the same type.\n */\nSkyBox.prototype.update = function (frameState, useHdr) {\n  const that = this;\n\n  if (!this.show) {\n    return undefined;\n  }\n\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    frameState.mode !== SceneMode.MORPHING\n  ) {\n    return undefined;\n  }\n\n  // The sky box is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  const context = frameState.context;\n\n  if (this._sources !== this.sources) {\n    this._sources = this.sources;\n    const sources = this.sources;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !defined(sources.positiveX) ||\n      !defined(sources.negativeX) ||\n      !defined(sources.positiveY) ||\n      !defined(sources.negativeY) ||\n      !defined(sources.positiveZ) ||\n      !defined(sources.negativeZ)\n    ) {\n      throw new DeveloperError(\n        \"this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.\"\n      );\n    }\n\n    if (\n      typeof sources.positiveX !== typeof sources.negativeX ||\n      typeof sources.positiveX !== typeof sources.positiveY ||\n      typeof sources.positiveX !== typeof sources.negativeY ||\n      typeof sources.positiveX !== typeof sources.positiveZ ||\n      typeof sources.positiveX !== typeof sources.negativeZ\n    ) {\n      throw new DeveloperError(\n        \"this.sources properties must all be the same type.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    if (typeof sources.positiveX === \"string\") {\n      // Given urls for cube-map images.  Load them.\n      loadCubeMap(context, this._sources).then(function (cubeMap) {\n        that._cubeMap = that._cubeMap && that._cubeMap.destroy();\n        that._cubeMap = cubeMap;\n      });\n    } else {\n      this._cubeMap = this._cubeMap && this._cubeMap.destroy();\n      this._cubeMap = new CubeMap({\n        context: context,\n        source: sources,\n      });\n    }\n  }\n\n  const command = this._command;\n\n  if (!defined(command.vertexArray)) {\n    command.uniformMap = {\n      u_cubeMap: function () {\n        return that._cubeMap;\n      },\n    };\n\n    const geometry = BoxGeometry.createGeometry(\n      BoxGeometry.fromDimensions({\n        dimensions: new Cartesian3(2.0, 2.0, 2.0),\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n    const attributeLocations = (this._attributeLocations = GeometryPipeline.createAttributeLocations(\n      geometry\n    ));\n\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: attributeLocations,\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n\n    command.renderState = RenderState.fromCache({\n      blending: BlendingState.ALPHA_BLEND,\n    });\n  }\n\n  if (!defined(command.shaderProgram) || this._useHdr !== useHdr) {\n    const fs = new ShaderSource({\n      defines: [useHdr ? \"HDR\" : \"\"],\n      sources: [SkyBoxFS],\n    });\n    command.shaderProgram = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: SkyBoxVS,\n      fragmentShaderSource: fs,\n      attributeLocations: this._attributeLocations,\n    });\n    this._useHdr = useHdr;\n  }\n\n  if (!defined(this._cubeMap)) {\n    return undefined;\n  }\n\n  return command;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyBox#destroy\n */\nSkyBox.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyBox = skyBox && skyBox.destroy();\n *\n * @see SkyBox#isDestroyed\n */\nSkyBox.prototype.destroy = function () {\n  const command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  command.shaderProgram =\n    command.shaderProgram && command.shaderProgram.destroy();\n  this._cubeMap = this._cubeMap && this._cubeMap.destroy();\n  return destroyObject(this);\n};\nexport default SkyBox;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport CesiumMath from \"../Core/Math.js\";\n\n/**\n * A ParticleEmitter that emits particles within a sphere.\n * Particles will be positioned randomly within the sphere and have initial velocities emanating from the center of the sphere.\n *\n * @alias SphereEmitter\n * @constructor\n *\n * @param {Number} [radius=1.0] The radius of the sphere in meters.\n */\nfunction SphereEmitter(radius) {\n  radius = defaultValue(radius, 1.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"radius\", radius, 0.0);\n  //>>includeEnd('debug');\n\n  this._radius = defaultValue(radius, 1.0);\n}\n\nObject.defineProperties(SphereEmitter.prototype, {\n  /**\n   * The radius of the sphere in meters.\n   * @memberof SphereEmitter.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  radius: {\n    get: function () {\n      return this._radius;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThan(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._radius = value;\n    },\n  },\n});\n\n/**\n * Initializes the given {Particle} by setting it's position and velocity.\n *\n * @private\n * @param {Particle} particle The particle to initialize\n */\nSphereEmitter.prototype.emit = function (particle) {\n  const theta = CesiumMath.randomBetween(0.0, CesiumMath.TWO_PI);\n  const phi = CesiumMath.randomBetween(0.0, CesiumMath.PI);\n  const rad = CesiumMath.randomBetween(0.0, this._radius);\n\n  const x = rad * Math.cos(theta) * Math.sin(phi);\n  const y = rad * Math.sin(theta) * Math.sin(phi);\n  const z = rad * Math.cos(phi);\n\n  particle.position = Cartesian3.fromElements(x, y, z, particle.position);\n  particle.velocity = Cartesian3.normalize(\n    particle.position,\n    particle.velocity\n  );\n};\nexport default SphereEmitter;\n","/**\n * The direction to display a primitive or ImageryLayer relative to the {@link Scene#splitPosition}.\n *\n * @enum {Number}\n *\n * @see ImageryLayer#splitDirection\n * @see Cesium3DTileset#splitDirection\n */\nconst SplitDirection = {\n  /**\n   * Display the primitive or ImageryLayer to the left of the {@link Scene#splitPosition}.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LEFT: -1.0,\n\n  /**\n   *  Always display the primitive or ImageryLayer.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0.0,\n\n  /**\n   * Display the primitive or ImageryLayer to the right of the {@link Scene#splitPosition}.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RIGHT: 1.0,\n};\nexport default Object.freeze(SplitDirection);\n","import ShaderSource from \"../Renderer/ShaderSource.js\";\n\n/**\n * Support for rendering things on only one side of the screen.\n *\n * @private\n */\nconst Splitter = {\n  /**\n   * Given a fragment shader string, returns a modified version of it that\n   * only renders on one side of the screen or the other. Fragments on the\n   * other side are discarded. The screen side is given by a uniform called\n   * `czm_splitDirection`, which can be added by calling\n   * {@link Splitter#addUniforms}, and the split position is given by an\n   * automatic uniform called `czm_splitPosition`.\n   */\n  modifyFragmentShader: function modifyFragmentShader(shader) {\n    shader = ShaderSource.replaceMain(shader, \"czm_splitter_main\");\n    shader +=\n      // czm_splitPosition is not declared because it is an automatic uniform.\n      \"uniform float czm_splitDirection; \\n\" +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      // Don't split when rendering the shadow map, because it is rendered from\n      // the perspective of a totally different camera.\n      \"#ifndef SHADOW_MAP\\n\" +\n      \"    if (czm_splitDirection < 0.0 && gl_FragCoord.x > czm_splitPosition) discard; \\n\" +\n      \"    if (czm_splitDirection > 0.0 && gl_FragCoord.x < czm_splitPosition) discard; \\n\" +\n      \"#endif\\n\" +\n      \"    czm_splitter_main(); \\n\" +\n      \"} \\n\";\n\n    return shader;\n  },\n\n  /**\n   * Add `czm_splitDirection` to the given uniform map.\n   *\n   * @param {Object} object The object on which the `splitDirection` property may be found.\n   * @param {Object} uniformMap The uniform map.\n   */\n  addUniforms: function addUniforms(object, uniformMap) {\n    uniformMap.czm_splitDirection = function () {\n      return object.splitDirection;\n    };\n  },\n};\n\nexport default Splitter;\n","import StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * The most significant bit is used to identify whether the pixel is 3D Tiles.\n * The next three bits store selection depth for the skip LODs optimization.\n * The last four bits are for increment/decrement shadow volume operations for classification.\n *\n * @private\n */\nconst StencilConstants = {\n  CESIUM_3D_TILE_MASK: 0x80,\n  SKIP_LOD_MASK: 0x70,\n  SKIP_LOD_BIT_SHIFT: 4,\n  CLASSIFICATION_MASK: 0x0f,\n};\n\nStencilConstants.setCesium3DTileBit = function () {\n  return {\n    enabled: true,\n    frontFunction: StencilFunction.ALWAYS,\n    frontOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.REPLACE,\n    },\n    backFunction: StencilFunction.ALWAYS,\n    backOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.REPLACE,\n    },\n    reference: StencilConstants.CESIUM_3D_TILE_MASK,\n    mask: StencilConstants.CESIUM_3D_TILE_MASK,\n  };\n};\nexport default Object.freeze(StencilConstants);\n","import WebGLConstants from \"../Core/WebGLConstants.js\";\n\n/**\n * Determines the function used to compare stencil values for the stencil test.\n *\n * @enum {Number}\n */\nconst StencilFunction = {\n  /**\n   * The stencil test never passes.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NEVER: WebGLConstants.NEVER,\n\n  /**\n   * The stencil test passes when the masked reference value is less than the masked stencil value.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LESS: WebGLConstants.LESS,\n\n  /**\n   * The stencil test passes when the masked reference value is equal to the masked stencil value.\n   *\n   * @type {Number}\n   * @constant\n   */\n  EQUAL: WebGLConstants.EQUAL,\n\n  /**\n   * The stencil test passes when the masked reference value is less than or equal to the masked stencil value.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LESS_OR_EQUAL: WebGLConstants.LEQUAL,\n\n  /**\n   * The stencil test passes when the masked reference value is greater than the masked stencil value.\n   *\n   * @type {Number}\n   * @constant\n   */\n  GREATER: WebGLConstants.GREATER,\n\n  /**\n   * The stencil test passes when the masked reference value is not equal to the masked stencil value.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NOT_EQUAL: WebGLConstants.NOTEQUAL,\n\n  /**\n   * The stencil test passes when the masked reference value is greater than or equal to the masked stencil value.\n   *\n   * @type {Number}\n   * @constant\n   */\n  GREATER_OR_EQUAL: WebGLConstants.GEQUAL,\n\n  /**\n   * The stencil test always passes.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ALWAYS: WebGLConstants.ALWAYS,\n};\nexport default Object.freeze(StencilFunction);\n","import WebGLConstants from \"../Core/WebGLConstants.js\";\n\n/**\n * Determines the action taken based on the result of the stencil test.\n *\n * @enum {Number}\n */\nconst StencilOperation = {\n  /**\n   * Sets the stencil buffer value to zero.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ZERO: WebGLConstants.ZERO,\n\n  /**\n   * Does not change the stencil buffer.\n   *\n   * @type {Number}\n   * @constant\n   */\n  KEEP: WebGLConstants.KEEP,\n\n  /**\n   * Replaces the stencil buffer value with the reference value.\n   *\n   * @type {Number}\n   * @constant\n   */\n  REPLACE: WebGLConstants.REPLACE,\n\n  /**\n   * Increments the stencil buffer value, clamping to unsigned byte.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INCREMENT: WebGLConstants.INCR,\n\n  /**\n   * Decrements the stencil buffer value, clamping to zero.\n   *\n   * @type {Number}\n   * @constant\n   */\n  DECREMENT: WebGLConstants.DECR,\n\n  /**\n   * Bitwise inverts the existing stencil buffer value.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INVERT: WebGLConstants.INVERT,\n\n  /**\n   * Increments the stencil buffer value, wrapping to zero when exceeding the unsigned byte range.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INCREMENT_WRAP: WebGLConstants.INCR_WRAP,\n\n  /**\n   * Decrements the stencil buffer value, wrapping to the maximum unsigned byte instead of going below zero.\n   *\n   * @type {Number}\n   * @constant\n   */\n  DECREMENT_WRAP: WebGLConstants.DECR_WRAP,\n};\nexport default Object.freeze(StencilOperation);\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\n\n/**\n * An object containing structural metadata.\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadatas|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {MetadataSchema} options.schema The parsed schema.\n * @param {PropertyTable[]} [options.propertyTables] An array of property table objects. For the legacy <code>EXT_feature_metadata</code> extension, this is sorted by the key in the propertyTables dictionary\n * @param {PropertyTexture[]} [options.propertyTextures] An array of property texture objects. For the legacy <code>EXT_feature_metadata</code> extension, this is sorted by the key in the propertyTextures dictionary\n * @param {PropertyAttribute[]} [options.propertyAttributes] An array of property attribute objects. This is new in <code>EXT_structural_metadata</code>\n * @param {Object} [options.statistics] Statistics about metadata\n * @param {Object} [options.extras] Extra user-defined properties\n * @param {Object} [options.extensions] An object containing extensions\n *\n * @alias StructuralMetadata\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction StructuralMetadata(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.schema\", options.schema);\n  //>>includeEnd('debug');\n\n  this._schema = options.schema;\n  const propertyTables = options.propertyTables;\n  this._propertyTableCount = defined(propertyTables)\n    ? propertyTables.length\n    : 0;\n  this._propertyTables = propertyTables;\n  this._propertyTextures = options.propertyTextures;\n  this._propertyAttributes = options.propertyAttributes;\n  this._statistics = options.statistics;\n  this._extras = options.extras;\n  this._extensions = options.extensions;\n}\n\nObject.defineProperties(StructuralMetadata.prototype, {\n  /**\n   * Schema containing classes and enums.\n   *\n   * @memberof StructuralMetadata.prototype\n   * @type {MetadataSchema}\n   * @readonly\n   * @private\n   */\n  schema: {\n    get: function () {\n      return this._schema;\n    },\n  },\n\n  /**\n   * Statistics about the metadata.\n   * <p>\n   * See the {@link https://github.com/CesiumGS/glTF/blob/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata/schema/statistics.schema.json|statistics schema reference} for the full set of properties.\n   * </p>\n   *\n   * @memberof StructuralMetadata.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  statistics: {\n    get: function () {\n      return this._statistics;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof StructuralMetadata.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof StructuralMetadata.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n\n  /**\n   * Number of property tables in the metadata.\n   *\n   * @memberof StructuralMetadata.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  propertyTableCount: {\n    get: function () {\n      return this._propertyTableCount;\n    },\n  },\n\n  /**\n   * The property tables in the metadata.\n   *\n   * @memberof StructuralMetadata.prototype\n   * @type {PropertyTable[]}\n   * @readonly\n   * @private\n   */\n  propertyTables: {\n    get: function () {\n      return this._propertyTables;\n    },\n  },\n\n  /**\n   * The property textures in the metadata.\n   *\n   * @memberof StructuralMetadata.prototype\n   * @type {PropertyTexture[]}\n   * @readonly\n   * @private\n   */\n  propertyTextures: {\n    get: function () {\n      return this._propertyTextures;\n    },\n  },\n\n  /**\n   * The property attributes from the structural metadata extension\n   *\n   * @memberof StructuralMetadata.prototype\n   * @type {PropertyAttribute[]}\n   * @readonly\n   * @private\n   */\n  propertyAttributes: {\n    get: function () {\n      return this._propertyAttributes;\n    },\n  },\n});\n\n/**\n * Gets the property table with the given ID.\n * <p>\n * For the legacy <code>EXT_feature_metadata</code>, textures are stored in an array sorted\n * by the key in the propertyTables dictionary.\n * </p>\n *\n * @param {Number} propertyTableId The property table ID.\n * @returns {PropertyTable} The property table.\n * @private\n */\nStructuralMetadata.prototype.getPropertyTable = function (propertyTableId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"propertyTableId\", propertyTableId);\n  //>>includeEnd('debug');\n\n  return this._propertyTables[propertyTableId];\n};\n\n/**\n * Gets the property texture with the given ID.\n * <p>\n * For the legacy <code>EXT_feature_metadata</code>, textures are stored in an array sorted\n * by the key in the propertyTextures dictionary.\n * </p>\n *\n * @param {Number} propertyTextureId The index into the property textures array.\n * @returns {PropertyTexture} The property texture\n * @private\n */\nStructuralMetadata.prototype.getPropertyTexture = function (propertyTextureId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"propertyTextureId\", propertyTextureId);\n  //>>includeEnd('debug');\n\n  return this._propertyTextures[propertyTextureId];\n};\n\n/**\n * Gets the property attribute with the given ID. This concept is new in\n * EXT_structural_metadata\n *\n * @param {Number} propertyAttributeId The index into the property attributes array.\n * @returns {PropertyAttribute} The property attribute\n * @private\n */\nStructuralMetadata.prototype.getPropertyAttribute = function (\n  propertyAttributeId\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"propertyAttributeId\", propertyAttributeId);\n  //>>includeEnd('debug');\n\n  return this._propertyAttributes[propertyAttributeId];\n};\n\nexport default StructuralMetadata;\n","import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * An expression for a style applied to a {@link Cesium3DTileset}.\n * <p>\n * Derived classes of this interface evaluate expressions in the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.\n * </p>\n * <p>\n * This type describes an interface and is not intended to be instantiated directly.\n * </p>\n *\n * @alias StyleExpression\n * @constructor\n *\n * @see Expression\n * @see ConditionsExpression\n */\nfunction StyleExpression() {}\n\n/**\n * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of\n * the expression in the\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}\n * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript\n * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>\n * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,\n * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is\n * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Object} [result] The object onto which to store the result.\n * @returns {Boolean|Number|String|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.\n */\nStyleExpression.prototype.evaluate = function (feature, result) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Evaluates the result of a Color expression, optionally using the provided feature's properties.\n * <p>\n * This is equivalent to {@link StyleExpression#evaluate} but always returns a {@link Color} object.\n * </p>\n *\n * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.\n * @param {Color} [result] The object in which to store the result.\n * @returns {Color} The modified result parameter or a new Color instance if one was not provided.\n */\nStyleExpression.prototype.evaluateColor = function (feature, result) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Gets the shader function for this expression.\n * Returns undefined if the shader function can't be generated from this expression.\n *\n * @param {String} functionSignature Signature of the generated function.\n * @param {Object} variableSubstitutionMap Maps variable names to shader variable names.\n * @param {Object} shaderState Stores information about the generated shader function, including whether it is translucent.\n * @param {String} returnType The return type of the generated function.\n *\n * @returns {String} The shader function.\n *\n * @private\n */\nStyleExpression.prototype.getShaderFunction = function (\n  functionSignature,\n  variableSubstitutionMap,\n  shaderState,\n  returnType\n) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Gets the variables used by the expression.\n *\n * @returns {String[]} The variables used by the expression.\n *\n * @private\n */\nStyleExpression.prototype.getVariables = function () {\n  DeveloperError.throwInstantiationError();\n};\n\nexport default StyleExpression;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport SunFS from \"../Shaders/SunFS.js\";\nimport SunTextureFS from \"../Shaders/SunTextureFS.js\";\nimport SunVS from \"../Shaders/SunVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\n\n/**\n * Draws a sun billboard.\n * <p>This is only supported in 3D and Columbus view.</p>\n *\n * @alias Sun\n * @constructor\n *\n *\n * @example\n * scene.sun = new Cesium.Sun();\n *\n * @see Scene#sun\n */\nfunction Sun() {\n  /**\n   * Determines if the sun will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = true;\n\n  this._drawCommand = new DrawCommand({\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingVolume: new BoundingSphere(),\n    owner: this,\n  });\n  this._commands = {\n    drawCommand: this._drawCommand,\n    computeCommand: undefined,\n  };\n  this._boundingVolume = new BoundingSphere();\n  this._boundingVolume2D = new BoundingSphere();\n\n  this._texture = undefined;\n  this._drawingBufferWidth = undefined;\n  this._drawingBufferHeight = undefined;\n  this._radiusTS = undefined;\n  this._size = undefined;\n\n  this.glowFactor = 1.0;\n  this._glowFactorDirty = false;\n\n  this._useHdr = undefined;\n\n  const that = this;\n  this._uniformMap = {\n    u_texture: function () {\n      return that._texture;\n    },\n    u_size: function () {\n      return that._size;\n    },\n  };\n}\n\nObject.defineProperties(Sun.prototype, {\n  /**\n   * Gets or sets a number that controls how \"bright\" the Sun's lens flare appears\n   * to be.  Zero shows just the Sun's disc without any flare.\n   * Use larger values for a more pronounced flare around the Sun.\n   *\n   * @memberof Sun.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  glowFactor: {\n    get: function () {\n      return this._glowFactor;\n    },\n    set: function (glowFactor) {\n      glowFactor = Math.max(glowFactor, 0.0);\n      this._glowFactor = glowFactor;\n      this._glowFactorDirty = true;\n    },\n  },\n});\n\nconst scratchPositionWC = new Cartesian2();\nconst scratchLimbWC = new Cartesian2();\nconst scratchPositionEC = new Cartesian4();\nconst scratchCartesian4 = new Cartesian4();\n\n/**\n * @private\n */\nSun.prototype.update = function (frameState, passState, useHdr) {\n  if (!this.show) {\n    return undefined;\n  }\n\n  const mode = frameState.mode;\n  if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n    return undefined;\n  }\n\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  const context = frameState.context;\n  const drawingBufferWidth = passState.viewport.width;\n  const drawingBufferHeight = passState.viewport.height;\n\n  if (\n    !defined(this._texture) ||\n    drawingBufferWidth !== this._drawingBufferWidth ||\n    drawingBufferHeight !== this._drawingBufferHeight ||\n    this._glowFactorDirty ||\n    useHdr !== this._useHdr\n  ) {\n    this._texture = this._texture && this._texture.destroy();\n    this._drawingBufferWidth = drawingBufferWidth;\n    this._drawingBufferHeight = drawingBufferHeight;\n    this._glowFactorDirty = false;\n    this._useHdr = useHdr;\n\n    let size = Math.max(drawingBufferWidth, drawingBufferHeight);\n    size = Math.pow(2.0, Math.ceil(Math.log(size) / Math.log(2.0)) - 2.0);\n\n    // The size computed above can be less than 1.0 if size < 4.0. This will probably\n    // never happen in practice, but does in the tests. Clamp to 1.0 to prevent WebGL\n    // errors in the tests.\n    size = Math.max(1.0, size);\n\n    const pixelDatatype = useHdr\n      ? context.halfFloatingPointTexture\n        ? PixelDatatype.HALF_FLOAT\n        : PixelDatatype.FLOAT\n      : PixelDatatype.UNSIGNED_BYTE;\n    this._texture = new Texture({\n      context: context,\n      width: size,\n      height: size,\n      pixelFormat: PixelFormat.RGBA,\n      pixelDatatype: pixelDatatype,\n    });\n\n    this._glowLengthTS = this._glowFactor * 5.0;\n    this._radiusTS = (1.0 / (1.0 + 2.0 * this._glowLengthTS)) * 0.5;\n\n    const that = this;\n    const uniformMap = {\n      u_radiusTS: function () {\n        return that._radiusTS;\n      },\n    };\n\n    this._commands.computeCommand = new ComputeCommand({\n      fragmentShaderSource: SunTextureFS,\n      outputTexture: this._texture,\n      uniformMap: uniformMap,\n      persists: false,\n      owner: this,\n      postExecute: function () {\n        that._commands.computeCommand = undefined;\n      },\n    });\n  }\n\n  const drawCommand = this._drawCommand;\n\n  if (!defined(drawCommand.vertexArray)) {\n    const attributeLocations = {\n      direction: 0,\n    };\n\n    const directions = new Uint8Array(4 * 2);\n    directions[0] = 0;\n    directions[1] = 0;\n\n    directions[2] = 255;\n    directions[3] = 0.0;\n\n    directions[4] = 255;\n    directions[5] = 255;\n\n    directions[6] = 0.0;\n    directions[7] = 255;\n\n    const vertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: directions,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const attributes = [\n      {\n        index: attributeLocations.direction,\n        vertexBuffer: vertexBuffer,\n        componentsPerAttribute: 2,\n        normalize: true,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      },\n    ];\n    // Workaround Internet Explorer 11.0.8 lack of TRIANGLE_FAN\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n    });\n    drawCommand.vertexArray = new VertexArray({\n      context: context,\n      attributes: attributes,\n      indexBuffer: indexBuffer,\n    });\n\n    drawCommand.shaderProgram = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: SunVS,\n      fragmentShaderSource: SunFS,\n      attributeLocations: attributeLocations,\n    });\n\n    drawCommand.renderState = RenderState.fromCache({\n      blending: BlendingState.ALPHA_BLEND,\n    });\n    drawCommand.uniformMap = this._uniformMap;\n  }\n\n  const sunPosition = context.uniformState.sunPositionWC;\n  const sunPositionCV = context.uniformState.sunPositionColumbusView;\n\n  const boundingVolume = this._boundingVolume;\n  const boundingVolume2D = this._boundingVolume2D;\n\n  Cartesian3.clone(sunPosition, boundingVolume.center);\n  boundingVolume2D.center.x = sunPositionCV.z;\n  boundingVolume2D.center.y = sunPositionCV.x;\n  boundingVolume2D.center.z = sunPositionCV.y;\n\n  boundingVolume.radius =\n    CesiumMath.SOLAR_RADIUS + CesiumMath.SOLAR_RADIUS * this._glowLengthTS;\n  boundingVolume2D.radius = boundingVolume.radius;\n\n  if (mode === SceneMode.SCENE3D) {\n    BoundingSphere.clone(boundingVolume, drawCommand.boundingVolume);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    BoundingSphere.clone(boundingVolume2D, drawCommand.boundingVolume);\n  }\n\n  const position = SceneTransforms.computeActualWgs84Position(\n    frameState,\n    sunPosition,\n    scratchCartesian4\n  );\n\n  const dist = Cartesian3.magnitude(\n    Cartesian3.subtract(position, frameState.camera.position, scratchCartesian4)\n  );\n  const projMatrix = context.uniformState.projection;\n\n  const positionEC = scratchPositionEC;\n  positionEC.x = 0;\n  positionEC.y = 0;\n  positionEC.z = -dist;\n  positionEC.w = 1;\n\n  const positionCC = Matrix4.multiplyByVector(\n    projMatrix,\n    positionEC,\n    scratchCartesian4\n  );\n  const positionWC = SceneTransforms.clipToGLWindowCoordinates(\n    passState.viewport,\n    positionCC,\n    scratchPositionWC\n  );\n\n  positionEC.x = CesiumMath.SOLAR_RADIUS;\n  const limbCC = Matrix4.multiplyByVector(\n    projMatrix,\n    positionEC,\n    scratchCartesian4\n  );\n  const limbWC = SceneTransforms.clipToGLWindowCoordinates(\n    passState.viewport,\n    limbCC,\n    scratchLimbWC\n  );\n\n  this._size = Cartesian2.magnitude(\n    Cartesian2.subtract(limbWC, positionWC, scratchCartesian4)\n  );\n  this._size = 2.0 * this._size * (1.0 + 2.0 * this._glowLengthTS);\n  this._size = Math.ceil(this._size);\n\n  return this._commands;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Sun#destroy\n */\nSun.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * sun = sun && sun.destroy();\n *\n *  @see Sun#isDestroyed\n */\nSun.prototype.destroy = function () {\n  const command = this._drawCommand;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  command.shaderProgram =\n    command.shaderProgram && command.shaderProgram.destroy();\n\n  this._texture = this._texture && this._texture.destroy();\n\n  return destroyObject(this);\n};\nexport default Sun;\n","import Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\n\n/**\n * A directional light source that originates from the Sun.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Color} [options.color=Color.WHITE] The light's color.\n * @param {Number} [options.intensity=2.0] The light's intensity.\n *\n * @alias SunLight\n * @constructor\n */\nfunction SunLight(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * The color of the light.\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  this.color = Color.clone(defaultValue(options.color, Color.WHITE));\n\n  /**\n   * The intensity of the light.\n   * @type {Number}\n   * @default 2.0\n   */\n  this.intensity = defaultValue(options.intensity, 2.0);\n}\n\nexport default SunLight;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport AdditiveBlend from \"../Shaders/PostProcessStages/AdditiveBlend.js\";\nimport BrightPass from \"../Shaders/PostProcessStages/BrightPass.js\";\nimport GaussianBlur1D from \"../Shaders/PostProcessStages/GaussianBlur1D.js\";\nimport PassThrough from \"../Shaders/PostProcessStages/PassThrough.js\";\nimport PostProcessStage from \"./PostProcessStage.js\";\nimport PostProcessStageComposite from \"./PostProcessStageComposite.js\";\nimport PostProcessStageSampleMode from \"./PostProcessStageSampleMode.js\";\nimport PostProcessStageTextureCache from \"./PostProcessStageTextureCache.js\";\nimport SceneFramebuffer from \"./SceneFramebuffer.js\";\n\nfunction SunPostProcess() {\n  this._sceneFramebuffer = new SceneFramebuffer();\n\n  const scale = 0.125;\n  const stages = new Array(6);\n\n  stages[0] = new PostProcessStage({\n    fragmentShader: PassThrough,\n    textureScale: scale,\n    forcePowerOfTwo: true,\n    sampleMode: PostProcessStageSampleMode.LINEAR,\n  });\n\n  const brightPass = (stages[1] = new PostProcessStage({\n    fragmentShader: BrightPass,\n    uniforms: {\n      avgLuminance: 0.5, // A guess at the average luminance across the entire scene\n      threshold: 0.25,\n      offset: 0.1,\n    },\n    textureScale: scale,\n    forcePowerOfTwo: true,\n  }));\n\n  const that = this;\n  this._delta = 1.0;\n  this._sigma = 2.0;\n  this._blurStep = new Cartesian2();\n\n  stages[2] = new PostProcessStage({\n    fragmentShader: GaussianBlur1D,\n    uniforms: {\n      step: function () {\n        that._blurStep.x = that._blurStep.y =\n          1.0 / brightPass.outputTexture.width;\n        return that._blurStep;\n      },\n      delta: function () {\n        return that._delta;\n      },\n      sigma: function () {\n        return that._sigma;\n      },\n      direction: 0.0,\n    },\n    textureScale: scale,\n    forcePowerOfTwo: true,\n  });\n\n  stages[3] = new PostProcessStage({\n    fragmentShader: GaussianBlur1D,\n    uniforms: {\n      step: function () {\n        that._blurStep.x = that._blurStep.y =\n          1.0 / brightPass.outputTexture.width;\n        return that._blurStep;\n      },\n      delta: function () {\n        return that._delta;\n      },\n      sigma: function () {\n        return that._sigma;\n      },\n      direction: 1.0,\n    },\n    textureScale: scale,\n    forcePowerOfTwo: true,\n  });\n\n  stages[4] = new PostProcessStage({\n    fragmentShader: PassThrough,\n    sampleMode: PostProcessStageSampleMode.LINEAR,\n  });\n\n  this._uCenter = new Cartesian2();\n  this._uRadius = undefined;\n\n  stages[5] = new PostProcessStage({\n    fragmentShader: AdditiveBlend,\n    uniforms: {\n      center: function () {\n        return that._uCenter;\n      },\n      radius: function () {\n        return that._uRadius;\n      },\n      colorTexture2: function () {\n        return that._sceneFramebuffer.framebuffer.getColorTexture(0);\n      },\n    },\n  });\n\n  this._stages = new PostProcessStageComposite({\n    stages: stages,\n  });\n\n  const textureCache = new PostProcessStageTextureCache(this);\n  const length = stages.length;\n  for (let i = 0; i < length; ++i) {\n    stages[i]._textureCache = textureCache;\n  }\n\n  this._textureCache = textureCache;\n  this.length = stages.length;\n}\n\nSunPostProcess.prototype.get = function (index) {\n  return this._stages.get(index);\n};\n\nSunPostProcess.prototype.getStageByName = function (name) {\n  const length = this._stages.length;\n  for (let i = 0; i < length; ++i) {\n    const stage = this._stages.get(i);\n    if (stage.name === name) {\n      return stage;\n    }\n  }\n  return undefined;\n};\n\nconst sunPositionECScratch = new Cartesian4();\nconst sunPositionWCScratch = new Cartesian2();\nconst sizeScratch = new Cartesian2();\nconst postProcessMatrix4Scratch = new Matrix4();\n\nfunction updateSunPosition(postProcess, context, viewport) {\n  const us = context.uniformState;\n  const sunPosition = us.sunPositionWC;\n  const viewMatrix = us.view;\n  const viewProjectionMatrix = us.viewProjection;\n  const projectionMatrix = us.projection;\n\n  // create up sampled render state\n  let viewportTransformation = Matrix4.computeViewportTransformation(\n    viewport,\n    0.0,\n    1.0,\n    postProcessMatrix4Scratch\n  );\n  const sunPositionEC = Matrix4.multiplyByPoint(\n    viewMatrix,\n    sunPosition,\n    sunPositionECScratch\n  );\n  let sunPositionWC = Transforms.pointToGLWindowCoordinates(\n    viewProjectionMatrix,\n    viewportTransformation,\n    sunPosition,\n    sunPositionWCScratch\n  );\n\n  sunPositionEC.x += CesiumMath.SOLAR_RADIUS;\n  const limbWC = Transforms.pointToGLWindowCoordinates(\n    projectionMatrix,\n    viewportTransformation,\n    sunPositionEC,\n    sunPositionEC\n  );\n  const sunSize =\n    Cartesian2.magnitude(Cartesian2.subtract(limbWC, sunPositionWC, limbWC)) *\n    30.0 *\n    2.0;\n\n  const size = sizeScratch;\n  size.x = sunSize;\n  size.y = sunSize;\n\n  postProcess._uCenter = Cartesian2.clone(sunPositionWC, postProcess._uCenter);\n  postProcess._uRadius = Math.max(size.x, size.y) * 0.15;\n\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n\n  const stages = postProcess._stages;\n  const firstStage = stages.get(0);\n\n  const downSampleWidth = firstStage.outputTexture.width;\n  const downSampleHeight = firstStage.outputTexture.height;\n\n  const downSampleViewport = new BoundingRectangle();\n  downSampleViewport.width = downSampleWidth;\n  downSampleViewport.height = downSampleHeight;\n\n  // create down sampled render state\n  viewportTransformation = Matrix4.computeViewportTransformation(\n    downSampleViewport,\n    0.0,\n    1.0,\n    postProcessMatrix4Scratch\n  );\n  sunPositionWC = Transforms.pointToGLWindowCoordinates(\n    viewProjectionMatrix,\n    viewportTransformation,\n    sunPosition,\n    sunPositionWCScratch\n  );\n\n  size.x *= downSampleWidth / width;\n  size.y *= downSampleHeight / height;\n\n  const scissorRectangle = firstStage.scissorRectangle;\n  scissorRectangle.x = Math.max(sunPositionWC.x - size.x * 0.5, 0.0);\n  scissorRectangle.y = Math.max(sunPositionWC.y - size.y * 0.5, 0.0);\n  scissorRectangle.width = Math.min(size.x, width);\n  scissorRectangle.height = Math.min(size.y, height);\n\n  for (let i = 1; i < 4; ++i) {\n    BoundingRectangle.clone(scissorRectangle, stages.get(i).scissorRectangle);\n  }\n}\n\nSunPostProcess.prototype.clear = function (context, passState, clearColor) {\n  this._sceneFramebuffer.clear(context, passState, clearColor);\n  this._textureCache.clear(context);\n};\n\nSunPostProcess.prototype.update = function (passState) {\n  const context = passState.context;\n  const viewport = passState.viewport;\n\n  const sceneFramebuffer = this._sceneFramebuffer;\n  sceneFramebuffer.update(context, viewport);\n  const framebuffer = sceneFramebuffer.framebuffer;\n\n  this._textureCache.update(context);\n  this._stages.update(context, false);\n\n  updateSunPosition(this, context, viewport);\n\n  return framebuffer;\n};\n\nSunPostProcess.prototype.execute = function (context) {\n  const colorTexture = this._sceneFramebuffer.framebuffer.getColorTexture(0);\n  const stages = this._stages;\n  const length = stages.length;\n  stages.get(0).execute(context, colorTexture);\n  for (let i = 1; i < length; ++i) {\n    stages.get(i).execute(context, stages.get(i - 1).outputTexture);\n  }\n};\n\nSunPostProcess.prototype.copy = function (context, framebuffer) {\n  if (!defined(this._copyColorCommand)) {\n    const that = this;\n    this._copyColorCommand = context.createViewportQuadCommand(PassThrough, {\n      uniformMap: {\n        colorTexture: function () {\n          return that._stages.get(that._stages.length - 1).outputTexture;\n        },\n      },\n      owner: this,\n    });\n  }\n\n  this._copyColorCommand.framebuffer = framebuffer;\n  this._copyColorCommand.execute(context);\n};\n\nSunPostProcess.prototype.isDestroyed = function () {\n  return false;\n};\n\nSunPostProcess.prototype.destroy = function () {\n  this._textureCache.destroy();\n  this._stages.destroy();\n  return destroyObject(this);\n};\nexport default SunPostProcess;\n","import defaultValue from \"../Core/defaultValue.js\";\n\n/**\n * Image formats supported by the browser.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.webp=false] Whether the browser supports WebP images.\n * @param {Boolean} [options.basis=false] Whether the browser supports compressed textures required to view KTX2 + Basis Universal images.\n *\n * @private\n */\nexport default function SupportedImageFormats(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this.webp = defaultValue(options.webp, false);\n  this.basis = defaultValue(options.basis, false);\n}\n","import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport binarySearch from \"../Core/binarySearch.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport HeightmapTerrainData from \"../Core/HeightmapTerrainData.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Queue from \"../Core/Queue.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport TerrainMesh from \"../Core/TerrainMesh.js\";\nimport TileEdge from \"../Core/TileEdge.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\nfunction TerrainFillMesh(tile) {\n  this.tile = tile;\n  this.frameLastUpdated = undefined;\n  this.westMeshes = []; // north to south (CCW)\n  this.westTiles = [];\n  this.southMeshes = []; // west to east (CCW)\n  this.southTiles = [];\n  this.eastMeshes = []; // south to north (CCW)\n  this.eastTiles = [];\n  this.northMeshes = []; // east to west (CCW)\n  this.northTiles = [];\n  this.southwestMesh = undefined;\n  this.southwestTile = undefined;\n  this.southeastMesh = undefined;\n  this.southeastTile = undefined;\n  this.northwestMesh = undefined;\n  this.northwestTile = undefined;\n  this.northeastMesh = undefined;\n  this.northeastTile = undefined;\n  this.changedThisFrame = true;\n  this.visitedFrame = undefined;\n  this.enqueuedFrame = undefined;\n  this.mesh = undefined;\n  this.vertexArray = undefined;\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4();\n}\n\nTerrainFillMesh.prototype.update = function (\n  tileProvider,\n  frameState,\n  vertexArraysToDestroy\n) {\n  if (this.changedThisFrame) {\n    createFillMesh(tileProvider, frameState, this.tile, vertexArraysToDestroy);\n    this.changedThisFrame = false;\n  }\n};\n\nTerrainFillMesh.prototype.destroy = function (vertexArraysToDestroy) {\n  this._destroyVertexArray(vertexArraysToDestroy);\n\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n    this.waterMaskTexture = undefined;\n  }\n\n  return undefined;\n};\n\nTerrainFillMesh.prototype._destroyVertexArray = function (\n  vertexArraysToDestroy\n) {\n  if (defined(this.vertexArray)) {\n    if (defined(vertexArraysToDestroy)) {\n      vertexArraysToDestroy.push(this.vertexArray);\n    } else {\n      GlobeSurfaceTile._freeVertexArray(this.vertexArray);\n    }\n    this.vertexArray = undefined;\n  }\n};\n\nconst traversalQueueScratch = new Queue();\n\nTerrainFillMesh.updateFillTiles = function (\n  tileProvider,\n  renderedTiles,\n  frameState,\n  vertexArraysToDestroy\n) {\n  // We want our fill tiles to look natural, which means they should align perfectly with\n  // adjacent loaded tiles, and their edges that are not adjacent to loaded tiles should have\n  // sensible heights (e.g. the average of the heights of loaded edges). Some fill tiles may\n  // be adjacent only to other fill tiles, and in that case heights should be assigned fanning\n  // outward from the loaded tiles so that there are no sudden changes in height.\n\n  // We do this with a breadth-first traversal of the rendered tiles, starting with the loaded\n  // ones. Graph nodes are tiles and graph edges connect to other rendered tiles that are spatially adjacent\n  // to those tiles. As we visit each node, we propagate tile edges to adjacent tiles. If there's no data\n  // for a tile edge,  we create an edge with an average height and then propagate it. If an edge is partially defined\n  // (e.g. an edge is adjacent to multiple more-detailed tiles and only some of them are loaded), we\n  // fill in the rest of the edge with the same height.\n  const quadtree = tileProvider._quadtree;\n  const levelZeroTiles = quadtree._levelZeroTiles;\n  const lastSelectionFrameNumber = quadtree._lastSelectionFrameNumber;\n\n  const traversalQueue = traversalQueueScratch;\n  traversalQueue.clear();\n\n  // Add the tiles with real geometry to the traversal queue.\n  for (let i = 0; i < renderedTiles.length; ++i) {\n    const renderedTile = renderedTiles[i];\n    if (defined(renderedTile.data.vertexArray)) {\n      traversalQueue.enqueue(renderedTiles[i]);\n    }\n  }\n\n  let tile = traversalQueue.dequeue();\n\n  while (tile !== undefined) {\n    const tileToWest = tile.findTileToWest(levelZeroTiles);\n    const tileToSouth = tile.findTileToSouth(levelZeroTiles);\n    const tileToEast = tile.findTileToEast(levelZeroTiles);\n    const tileToNorth = tile.findTileToNorth(levelZeroTiles);\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToWest,\n      lastSelectionFrameNumber,\n      TileEdge.EAST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToSouth,\n      lastSelectionFrameNumber,\n      TileEdge.NORTH,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToEast,\n      lastSelectionFrameNumber,\n      TileEdge.WEST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToNorth,\n      lastSelectionFrameNumber,\n      TileEdge.SOUTH,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n\n    const tileToNorthwest = tileToWest.findTileToNorth(levelZeroTiles);\n    const tileToSouthwest = tileToWest.findTileToSouth(levelZeroTiles);\n    const tileToNortheast = tileToEast.findTileToNorth(levelZeroTiles);\n    const tileToSoutheast = tileToEast.findTileToSouth(levelZeroTiles);\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToNorthwest,\n      lastSelectionFrameNumber,\n      TileEdge.SOUTHEAST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToNortheast,\n      lastSelectionFrameNumber,\n      TileEdge.SOUTHWEST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToSouthwest,\n      lastSelectionFrameNumber,\n      TileEdge.NORTHEAST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToSoutheast,\n      lastSelectionFrameNumber,\n      TileEdge.NORTHWEST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n\n    tile = traversalQueue.dequeue();\n  }\n};\n\nfunction visitRenderedTiles(\n  tileProvider,\n  frameState,\n  sourceTile,\n  startTile,\n  currentFrameNumber,\n  tileEdge,\n  downOnly,\n  traversalQueue,\n  vertexArraysToDestroy\n) {\n  if (startTile === undefined) {\n    // There are no tiles North or South of the poles.\n    return;\n  }\n\n  let tile = startTile;\n  while (\n    tile &&\n    (tile._lastSelectionResultFrame !== currentFrameNumber ||\n      TileSelectionResult.wasKicked(tile._lastSelectionResult) ||\n      TileSelectionResult.originalResult(tile._lastSelectionResult) ===\n        TileSelectionResult.CULLED)\n  ) {\n    // This tile wasn't visited or it was visited and then kicked, so walk up to find the closest ancestor that was rendered.\n    // We also walk up if the tile was culled, because if siblings were kicked an ancestor may have been rendered.\n    if (downOnly) {\n      return;\n    }\n\n    const parent = tile.parent;\n    if (tileEdge >= TileEdge.NORTHWEST && parent !== undefined) {\n      // When we're looking for a corner, verify that the parent tile is still relevant.\n      // That is, the parent and child must share the corner in question.\n      switch (tileEdge) {\n        case TileEdge.NORTHWEST:\n          tile = tile === parent.northwestChild ? parent : undefined;\n          break;\n        case TileEdge.NORTHEAST:\n          tile = tile === parent.northeastChild ? parent : undefined;\n          break;\n        case TileEdge.SOUTHWEST:\n          tile = tile === parent.southwestChild ? parent : undefined;\n          break;\n        case TileEdge.SOUTHEAST:\n          tile = tile === parent.southeastChild ? parent : undefined;\n          break;\n      }\n    } else {\n      tile = parent;\n    }\n  }\n\n  if (tile === undefined) {\n    return;\n  }\n\n  if (tile._lastSelectionResult === TileSelectionResult.RENDERED) {\n    if (defined(tile.data.vertexArray)) {\n      // No further processing necessary for renderable tiles.\n      return;\n    }\n    visitTile(\n      tileProvider,\n      frameState,\n      sourceTile,\n      tile,\n      tileEdge,\n      currentFrameNumber,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    return;\n  }\n\n  if (\n    TileSelectionResult.originalResult(startTile._lastSelectionResult) ===\n    TileSelectionResult.CULLED\n  ) {\n    return;\n  }\n\n  // This tile was refined, so find rendered children, if any.\n  // Visit the tiles in counter-clockwise order.\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.EAST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.SOUTH:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.NORTH:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.NORTHWEST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.NORTHEAST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.SOUTHWEST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.SOUTHEAST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    default:\n      throw new DeveloperError(\"Invalid edge\");\n  }\n}\n\nfunction visitTile(\n  tileProvider,\n  frameState,\n  sourceTile,\n  destinationTile,\n  tileEdge,\n  frameNumber,\n  traversalQueue,\n  vertexArraysToDestroy\n) {\n  const destinationSurfaceTile = destinationTile.data;\n\n  if (destinationSurfaceTile.fill === undefined) {\n    destinationSurfaceTile.fill = new TerrainFillMesh(destinationTile);\n  } else if (destinationSurfaceTile.fill.visitedFrame === frameNumber) {\n    // Don't propagate edges to tiles that have already been visited this frame.\n    return;\n  }\n\n  if (destinationSurfaceTile.fill.enqueuedFrame !== frameNumber) {\n    // First time visiting this tile this frame, add it to the traversal queue.\n    destinationSurfaceTile.fill.enqueuedFrame = frameNumber;\n    destinationSurfaceTile.fill.changedThisFrame = false;\n    traversalQueue.enqueue(destinationTile);\n  }\n\n  propagateEdge(\n    tileProvider,\n    frameState,\n    sourceTile,\n    destinationTile,\n    tileEdge,\n    vertexArraysToDestroy\n  );\n}\n\nfunction propagateEdge(\n  tileProvider,\n  frameState,\n  sourceTile,\n  destinationTile,\n  tileEdge,\n  vertexArraysToDestroy\n) {\n  const destinationFill = destinationTile.data.fill;\n\n  let sourceMesh;\n  const sourceFill = sourceTile.data.fill;\n  if (defined(sourceFill)) {\n    sourceFill.visitedFrame = frameState.frameNumber;\n\n    // Source is a fill, create/update it if necessary.\n    if (sourceFill.changedThisFrame) {\n      createFillMesh(\n        tileProvider,\n        frameState,\n        sourceTile,\n        vertexArraysToDestroy\n      );\n      sourceFill.changedThisFrame = false;\n    }\n    sourceMesh = sourceTile.data.fill.mesh;\n  } else {\n    sourceMesh = sourceTile.data.mesh;\n  }\n\n  let edgeMeshes;\n  let edgeTiles;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      edgeMeshes = destinationFill.westMeshes;\n      edgeTiles = destinationFill.westTiles;\n      break;\n    case TileEdge.SOUTH:\n      edgeMeshes = destinationFill.southMeshes;\n      edgeTiles = destinationFill.southTiles;\n      break;\n    case TileEdge.EAST:\n      edgeMeshes = destinationFill.eastMeshes;\n      edgeTiles = destinationFill.eastTiles;\n      break;\n    case TileEdge.NORTH:\n      edgeMeshes = destinationFill.northMeshes;\n      edgeTiles = destinationFill.northTiles;\n      break;\n    // Corners are simpler.\n    case TileEdge.NORTHWEST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.northwestMesh !== sourceMesh;\n      destinationFill.northwestMesh = sourceMesh;\n      destinationFill.northwestTile = sourceTile;\n      return;\n    case TileEdge.NORTHEAST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.northeastMesh !== sourceMesh;\n      destinationFill.northeastMesh = sourceMesh;\n      destinationFill.northeastTile = sourceTile;\n      return;\n    case TileEdge.SOUTHWEST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.southwestMesh !== sourceMesh;\n      destinationFill.southwestMesh = sourceMesh;\n      destinationFill.southwestTile = sourceTile;\n      return;\n    case TileEdge.SOUTHEAST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.southeastMesh !== sourceMesh;\n      destinationFill.southeastMesh = sourceMesh;\n      destinationFill.southeastTile = sourceTile;\n      return;\n  }\n\n  if (sourceTile.level <= destinationTile.level) {\n    // Source edge completely spans the destination edge.\n    destinationFill.changedThisFrame =\n      destinationFill.changedThisFrame ||\n      edgeMeshes[0] !== sourceMesh ||\n      edgeMeshes.length !== 1;\n    edgeMeshes[0] = sourceMesh;\n    edgeTiles[0] = sourceTile;\n    edgeMeshes.length = 1;\n    edgeTiles.length = 1;\n    return;\n  }\n\n  // Source edge is a subset of the destination edge.\n  // Figure out the range of meshes we're replacing.\n  let startIndex, endIndex, existingTile, existingRectangle;\n  const sourceRectangle = sourceTile.rectangle;\n\n  let epsilon;\n  const destinationRectangle = destinationTile.rectangle;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      epsilon =\n        (destinationRectangle.north - destinationRectangle.south) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThan(\n            sourceRectangle.north,\n            existingRectangle.south,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThanOrEquals(\n            sourceRectangle.south,\n            existingRectangle.north,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.SOUTH:\n      epsilon =\n        (destinationRectangle.east - destinationRectangle.west) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThan(\n            sourceRectangle.west,\n            existingRectangle.east,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThanOrEquals(\n            sourceRectangle.east,\n            existingRectangle.west,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.EAST:\n      epsilon =\n        (destinationRectangle.north - destinationRectangle.south) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThan(\n            sourceRectangle.south,\n            existingRectangle.north,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThanOrEquals(\n            sourceRectangle.north,\n            existingRectangle.south,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.NORTH:\n      epsilon =\n        (destinationRectangle.east - destinationRectangle.west) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThan(\n            sourceRectangle.east,\n            existingRectangle.west,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThanOrEquals(\n            sourceRectangle.west,\n            existingRectangle.east,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n  }\n\n  if (endIndex - startIndex === 1) {\n    destinationFill.changedThisFrame =\n      destinationFill.changedThisFrame || edgeMeshes[startIndex] !== sourceMesh;\n    edgeMeshes[startIndex] = sourceMesh;\n    edgeTiles[startIndex] = sourceTile;\n  } else {\n    destinationFill.changedThisFrame = true;\n    edgeMeshes.splice(startIndex, endIndex - startIndex, sourceMesh);\n    edgeTiles.splice(startIndex, endIndex - startIndex, sourceTile);\n  }\n}\n\nconst cartographicScratch = new Cartographic();\nconst centerCartographicScratch = new Cartographic();\nconst cartesianScratch = new Cartesian3();\nconst normalScratch = new Cartesian3();\nconst octEncodedNormalScratch = new Cartesian2();\nconst uvScratch2 = new Cartesian2();\nconst uvScratch = new Cartesian2();\n\nfunction HeightAndNormal() {\n  this.height = 0.0;\n  this.encodedNormal = new Cartesian2();\n}\n\nfunction fillMissingCorner(\n  fill,\n  ellipsoid,\n  u,\n  v,\n  corner,\n  adjacentCorner1,\n  adjacentCorner2,\n  oppositeCorner,\n  vertex\n) {\n  if (defined(corner)) {\n    return corner;\n  }\n\n  let height;\n\n  if (defined(adjacentCorner1) && defined(adjacentCorner2)) {\n    height = (adjacentCorner1.height + adjacentCorner2.height) * 0.5;\n  } else if (defined(adjacentCorner1)) {\n    height = adjacentCorner1.height;\n  } else if (defined(adjacentCorner2)) {\n    height = adjacentCorner2.height;\n  } else if (defined(oppositeCorner)) {\n    height = oppositeCorner.height;\n  } else {\n    const surfaceTile = fill.tile.data;\n    const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n    let minimumHeight = 0.0;\n    let maximumHeight = 0.0;\n    if (defined(tileBoundingRegion)) {\n      minimumHeight = tileBoundingRegion.minimumHeight;\n      maximumHeight = tileBoundingRegion.maximumHeight;\n    }\n    height = (minimumHeight + maximumHeight) * 0.5;\n  }\n\n  getVertexWithHeightAtCorner(fill, ellipsoid, u, v, height, vertex);\n  return vertex;\n}\n\nconst heightRangeScratch = {\n  minimumHeight: 0.0,\n  maximumHeight: 0.0,\n};\n\nconst scratchCenter = new Cartesian3();\nconst swVertexScratch = new HeightAndNormal();\nconst seVertexScratch = new HeightAndNormal();\nconst nwVertexScratch = new HeightAndNormal();\nconst neVertexScratch = new HeightAndNormal();\nconst heightmapBuffer =\n  typeof Uint8Array !== \"undefined\" ? new Uint8Array(9 * 9) : undefined;\n\nconst scratchCreateMeshSyncOptions = {\n  tilingScheme: undefined,\n  x: 0,\n  y: 0,\n  level: 0,\n  exaggeration: 1.0,\n  exaggerationRelativeHeight: 0.0,\n};\nfunction createFillMesh(tileProvider, frameState, tile, vertexArraysToDestroy) {\n  GlobeSurfaceTile.initialize(\n    tile,\n    tileProvider.terrainProvider,\n    tileProvider._imageryLayers\n  );\n\n  const surfaceTile = tile.data;\n  const fill = surfaceTile.fill;\n  const rectangle = tile.rectangle;\n\n  const exaggeration = frameState.terrainExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.terrainExaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n\n  const ellipsoid = tile.tilingScheme.ellipsoid;\n\n  let nwCorner = getCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    1.0,\n    fill.northwestTile,\n    fill.northwestMesh,\n    fill.northTiles,\n    fill.northMeshes,\n    fill.westTiles,\n    fill.westMeshes,\n    nwVertexScratch\n  );\n  let swCorner = getCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    0.0,\n    fill.southwestTile,\n    fill.southwestMesh,\n    fill.westTiles,\n    fill.westMeshes,\n    fill.southTiles,\n    fill.southMeshes,\n    swVertexScratch\n  );\n  let seCorner = getCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    0.0,\n    fill.southeastTile,\n    fill.southeastMesh,\n    fill.southTiles,\n    fill.southMeshes,\n    fill.eastTiles,\n    fill.eastMeshes,\n    seVertexScratch\n  );\n  let neCorner = getCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    1.0,\n    fill.northeastTile,\n    fill.northeastMesh,\n    fill.eastTiles,\n    fill.eastMeshes,\n    fill.northTiles,\n    fill.northMeshes,\n    neVertexScratch\n  );\n\n  nwCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    1.0,\n    nwCorner,\n    swCorner,\n    neCorner,\n    seCorner,\n    nwVertexScratch\n  );\n  swCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    0.0,\n    swCorner,\n    nwCorner,\n    seCorner,\n    neCorner,\n    swVertexScratch\n  );\n  seCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    1.0,\n    seCorner,\n    swCorner,\n    neCorner,\n    nwCorner,\n    seVertexScratch\n  );\n  neCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    1.0,\n    neCorner,\n    seCorner,\n    nwCorner,\n    swCorner,\n    neVertexScratch\n  );\n\n  const southwestHeight = swCorner.height;\n  const southeastHeight = seCorner.height;\n  const northwestHeight = nwCorner.height;\n  const northeastHeight = neCorner.height;\n\n  let minimumHeight = Math.min(\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n  let maximumHeight = Math.max(\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n\n  const middleHeight = (minimumHeight + maximumHeight) * 0.5;\n\n  let i;\n  let len;\n\n  // For low-detail tiles, our usual fill tile approach will create tiles that\n  // look really blocky because they don't have enough vertices to account for the\n  // Earth's curvature. But the height range will also typically be well within\n  // the allowed geometric error for those levels. So fill such tiles with a\n  // constant-height heightmap.\n  const geometricError = tileProvider.getLevelMaximumGeometricError(tile.level);\n  const minCutThroughRadius = ellipsoid.maximumRadius - geometricError;\n  let maxTileWidth =\n    Math.acos(minCutThroughRadius / ellipsoid.maximumRadius) * 4.0;\n\n  // When the tile width is greater than maxTileWidth as computed above, the error\n  // of a normal fill tile from globe curvature alone will exceed the allowed geometric\n  // error. Terrain won't change that much. However, we can allow more error than that.\n  // A little blockiness during load is acceptable. For the WGS84 ellipsoid and\n  // standard geometric error setup, the value here will have us use a heightmap\n  // at levels 1, 2, and 3.\n  maxTileWidth *= 1.5;\n\n  if (\n    rectangle.width > maxTileWidth &&\n    maximumHeight - minimumHeight <= geometricError\n  ) {\n    const terrainData = new HeightmapTerrainData({\n      width: 9,\n      height: 9,\n      buffer: heightmapBuffer,\n      structure: {\n        // Use the maximum as the constant height so that this tile's skirt\n        // covers any cracks with adjacent tiles.\n        heightOffset: maximumHeight,\n      },\n    });\n\n    const createMeshSyncOptions = scratchCreateMeshSyncOptions;\n    createMeshSyncOptions.tilingScheme = tile.tilingScheme;\n    createMeshSyncOptions.x = tile.x;\n    createMeshSyncOptions.y = tile.y;\n    createMeshSyncOptions.level = tile.level;\n    createMeshSyncOptions.exaggeration = exaggeration;\n    createMeshSyncOptions.exaggerationRelativeHeight = exaggerationRelativeHeight;\n\n    fill.mesh = terrainData._createMeshSync(createMeshSyncOptions);\n  } else {\n    const hasGeodeticSurfaceNormals = hasExaggeration;\n    const centerCartographic = Rectangle.center(\n      rectangle,\n      centerCartographicScratch\n    );\n    centerCartographic.height = middleHeight;\n    const center = ellipsoid.cartographicToCartesian(\n      centerCartographic,\n      scratchCenter\n    );\n    const encoding = new TerrainEncoding(\n      center,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      true,\n      true,\n      hasGeodeticSurfaceNormals,\n      exaggeration,\n      exaggerationRelativeHeight\n    );\n\n    // At _most_, we have vertices for the 4 corners, plus 1 center, plus every adjacent edge vertex.\n    // In reality there will be less most of the time, but close enough; better\n    // to overestimate than to re-allocate/copy/traverse the vertices twice.\n    // Also, we'll often be able to squeeze the index data into the extra space in the buffer.\n    let maxVertexCount = 5;\n    let meshes;\n\n    meshes = fill.westMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].eastIndicesNorthToSouth.length;\n    }\n\n    meshes = fill.southMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].northIndicesWestToEast.length;\n    }\n\n    meshes = fill.eastMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].westIndicesSouthToNorth.length;\n    }\n\n    meshes = fill.northMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].southIndicesEastToWest.length;\n    }\n\n    const heightRange = heightRangeScratch;\n    heightRange.minimumHeight = minimumHeight;\n    heightRange.maximumHeight = maximumHeight;\n\n    const stride = encoding.stride;\n    let typedArray = new Float32Array(maxVertexCount * stride);\n\n    let nextIndex = 0;\n    const northwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      0.0,\n      1.0,\n      nwCorner.height,\n      nwCorner.encodedNormal,\n      1.0,\n      heightRange\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.westTiles,\n      fill.westMeshes,\n      TileEdge.EAST,\n      heightRange\n    );\n    const southwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      0.0,\n      0.0,\n      swCorner.height,\n      swCorner.encodedNormal,\n      0.0,\n      heightRange\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.southTiles,\n      fill.southMeshes,\n      TileEdge.NORTH,\n      heightRange\n    );\n    const southeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      1.0,\n      0.0,\n      seCorner.height,\n      seCorner.encodedNormal,\n      0.0,\n      heightRange\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.eastTiles,\n      fill.eastMeshes,\n      TileEdge.WEST,\n      heightRange\n    );\n    const northeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      1.0,\n      1.0,\n      neCorner.height,\n      neCorner.encodedNormal,\n      1.0,\n      heightRange\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.northTiles,\n      fill.northMeshes,\n      TileEdge.SOUTH,\n      heightRange\n    );\n\n    minimumHeight = heightRange.minimumHeight;\n    maximumHeight = heightRange.maximumHeight;\n\n    const obb = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minimumHeight,\n      maximumHeight,\n      tile.tilingScheme.ellipsoid\n    );\n\n    // Add a single vertex at the center of the tile.\n    const southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      rectangle.south\n    );\n    const oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(rectangle.north) -\n        southMercatorY);\n    const centerWebMercatorT =\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n        centerCartographic.latitude\n      ) -\n        southMercatorY) *\n      oneOverMercatorHeight;\n\n    const geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n      cartographicScratch,\n      normalScratch\n    );\n    const centerEncodedNormal = AttributeCompression.octEncode(\n      geodeticSurfaceNormal,\n      octEncodedNormalScratch\n    );\n\n    const centerIndex = nextIndex;\n    encoding.encode(\n      typedArray,\n      nextIndex * stride,\n      obb.center,\n      Cartesian2.fromElements(0.5, 0.5, uvScratch),\n      middleHeight,\n      centerEncodedNormal,\n      centerWebMercatorT,\n      geodeticSurfaceNormal\n    );\n    ++nextIndex;\n\n    const vertexCount = nextIndex;\n\n    const bytesPerIndex = vertexCount < 256 ? 1 : 2;\n    const indexCount = (vertexCount - 1) * 3; // one triangle per edge vertex\n    const indexDataBytes = indexCount * bytesPerIndex;\n    const availableBytesInBuffer =\n      (typedArray.length - vertexCount * stride) *\n      Float32Array.BYTES_PER_ELEMENT;\n\n    let indices;\n    if (availableBytesInBuffer >= indexDataBytes) {\n      // Store the index data in the same buffer as the vertex data.\n      const startIndex = vertexCount * stride * Float32Array.BYTES_PER_ELEMENT;\n      indices =\n        vertexCount < 256\n          ? new Uint8Array(typedArray.buffer, startIndex, indexCount)\n          : new Uint16Array(typedArray.buffer, startIndex, indexCount);\n    } else {\n      // Allocate a new buffer for the index data.\n      indices =\n        vertexCount < 256\n          ? new Uint8Array(indexCount)\n          : new Uint16Array(indexCount);\n    }\n\n    typedArray = new Float32Array(typedArray.buffer, 0, vertexCount * stride);\n\n    let indexOut = 0;\n    for (i = 0; i < vertexCount - 2; ++i) {\n      indices[indexOut++] = centerIndex;\n      indices[indexOut++] = i;\n      indices[indexOut++] = i + 1;\n    }\n\n    indices[indexOut++] = centerIndex;\n    indices[indexOut++] = i;\n    indices[indexOut++] = 0;\n\n    const westIndicesSouthToNorth = [];\n    for (i = southwestIndex; i >= northwestIndex; --i) {\n      westIndicesSouthToNorth.push(i);\n    }\n\n    const southIndicesEastToWest = [];\n    for (i = southeastIndex; i >= southwestIndex; --i) {\n      southIndicesEastToWest.push(i);\n    }\n\n    const eastIndicesNorthToSouth = [];\n    for (i = northeastIndex; i >= southeastIndex; --i) {\n      eastIndicesNorthToSouth.push(i);\n    }\n\n    const northIndicesWestToEast = [];\n    northIndicesWestToEast.push(0);\n    for (i = centerIndex - 1; i >= northeastIndex; --i) {\n      northIndicesWestToEast.push(i);\n    }\n\n    fill.mesh = new TerrainMesh(\n      encoding.center,\n      typedArray,\n      indices,\n      indexCount,\n      vertexCount,\n      minimumHeight,\n      maximumHeight,\n      BoundingSphere.fromOrientedBoundingBox(obb),\n      computeOccludeePoint(\n        tileProvider,\n        obb.center,\n        rectangle,\n        minimumHeight,\n        maximumHeight\n      ),\n      encoding.stride,\n      obb,\n      encoding,\n      westIndicesSouthToNorth,\n      southIndicesEastToWest,\n      eastIndicesNorthToSouth,\n      northIndicesWestToEast\n    );\n  }\n\n  const context = frameState.context;\n\n  fill._destroyVertexArray(vertexArraysToDestroy);\n\n  fill.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n    context,\n    fill.mesh\n  );\n  surfaceTile.processImagery(\n    tile,\n    tileProvider.terrainProvider,\n    frameState,\n    true\n  );\n\n  const oldTexture = fill.waterMaskTexture;\n  fill.waterMaskTexture = undefined;\n\n  if (tileProvider.terrainProvider.hasWaterMask) {\n    const waterSourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n    if (\n      defined(waterSourceTile) &&\n      defined(waterSourceTile.data.waterMaskTexture)\n    ) {\n      fill.waterMaskTexture = waterSourceTile.data.waterMaskTexture;\n      ++fill.waterMaskTexture.referenceCount;\n      surfaceTile._computeWaterMaskTranslationAndScale(\n        tile,\n        waterSourceTile,\n        fill.waterMaskTranslationAndScale\n      );\n    }\n  }\n\n  if (defined(oldTexture)) {\n    --oldTexture.referenceCount;\n    if (oldTexture.referenceCount === 0) {\n      oldTexture.destroy();\n    }\n  }\n}\n\nfunction addVertexWithComputedPosition(\n  ellipsoid,\n  rectangle,\n  encoding,\n  buffer,\n  index,\n  u,\n  v,\n  height,\n  encodedNormal,\n  webMercatorT,\n  heightRange\n) {\n  const cartographic = cartographicScratch;\n  cartographic.longitude = CesiumMath.lerp(rectangle.west, rectangle.east, u);\n  cartographic.latitude = CesiumMath.lerp(rectangle.south, rectangle.north, v);\n  cartographic.height = height;\n  const position = ellipsoid.cartographicToCartesian(\n    cartographic,\n    cartesianScratch\n  );\n\n  let geodeticSurfaceNormal;\n  if (encoding.hasGeodeticSurfaceNormals) {\n    geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      position,\n      normalScratch\n    );\n  }\n\n  const uv = uvScratch2;\n  uv.x = u;\n  uv.y = v;\n\n  encoding.encode(\n    buffer,\n    index * encoding.stride,\n    position,\n    uv,\n    height,\n    encodedNormal,\n    webMercatorT,\n    geodeticSurfaceNormal\n  );\n\n  heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n  heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n\n  return index + 1;\n}\n\nconst sourceRectangleScratch = new Rectangle();\n\nfunction transformTextureCoordinates(\n  sourceTile,\n  targetTile,\n  coordinates,\n  result\n) {\n  let sourceRectangle = sourceTile.rectangle;\n  const targetRectangle = targetTile.rectangle;\n\n  // Handle transforming across the anti-meridian.\n  if (\n    targetTile.x === 0 &&\n    coordinates.x === 1.0 &&\n    sourceTile.x ===\n      sourceTile.tilingScheme.getNumberOfXTilesAtLevel(sourceTile.level) - 1\n  ) {\n    sourceRectangle = Rectangle.clone(\n      sourceTile.rectangle,\n      sourceRectangleScratch\n    );\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (\n    sourceTile.x === 0 &&\n    coordinates.x === 0.0 &&\n    targetTile.x ===\n      targetTile.tilingScheme.getNumberOfXTilesAtLevel(targetTile.level) - 1\n  ) {\n    sourceRectangle = Rectangle.clone(\n      sourceTile.rectangle,\n      sourceRectangleScratch\n    );\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n\n  const sourceWidth = sourceRectangle.east - sourceRectangle.west;\n  const umin = (targetRectangle.west - sourceRectangle.west) / sourceWidth;\n  const umax = (targetRectangle.east - sourceRectangle.west) / sourceWidth;\n\n  const sourceHeight = sourceRectangle.north - sourceRectangle.south;\n  const vmin = (targetRectangle.south - sourceRectangle.south) / sourceHeight;\n  const vmax = (targetRectangle.north - sourceRectangle.south) / sourceHeight;\n\n  let u = (coordinates.x - umin) / (umax - umin);\n  let v = (coordinates.y - vmin) / (vmax - vmin);\n\n  // Ensure that coordinates very near the corners are at the corners.\n  if (Math.abs(u) < Math.EPSILON5) {\n    u = 0.0;\n  } else if (Math.abs(u - 1.0) < Math.EPSILON5) {\n    u = 1.0;\n  }\n\n  if (Math.abs(v) < Math.EPSILON5) {\n    v = 0.0;\n  } else if (Math.abs(v - 1.0) < Math.EPSILON5) {\n    v = 1.0;\n  }\n\n  result.x = u;\n  result.y = v;\n  return result;\n}\n\nconst encodedNormalScratch = new Cartesian2();\n\nfunction getVertexFromTileAtCorner(sourceMesh, sourceIndex, u, v, vertex) {\n  const sourceEncoding = sourceMesh.encoding;\n  const sourceVertices = sourceMesh.vertices;\n\n  vertex.height = sourceEncoding.decodeHeight(sourceVertices, sourceIndex);\n\n  if (sourceEncoding.hasVertexNormals) {\n    sourceEncoding.getOctEncodedNormal(\n      sourceVertices,\n      sourceIndex,\n      vertex.encodedNormal\n    );\n  } else {\n    const normal = vertex.encodedNormal;\n    normal.x = 0.0;\n    normal.y = 0.0;\n  }\n}\n\nconst encodedNormalScratch2 = new Cartesian2();\nconst cartesianScratch2 = new Cartesian3();\n\nfunction getInterpolatedVertexAtCorner(\n  ellipsoid,\n  sourceTile,\n  targetTile,\n  sourceMesh,\n  previousIndex,\n  nextIndex,\n  u,\n  v,\n  interpolateU,\n  vertex\n) {\n  const sourceEncoding = sourceMesh.encoding;\n  const sourceVertices = sourceMesh.vertices;\n\n  const previousUv = transformTextureCoordinates(\n    sourceTile,\n    targetTile,\n    sourceEncoding.decodeTextureCoordinates(\n      sourceVertices,\n      previousIndex,\n      uvScratch\n    ),\n    uvScratch\n  );\n  const nextUv = transformTextureCoordinates(\n    sourceTile,\n    targetTile,\n    sourceEncoding.decodeTextureCoordinates(\n      sourceVertices,\n      nextIndex,\n      uvScratch2\n    ),\n    uvScratch2\n  );\n\n  let ratio;\n  if (interpolateU) {\n    ratio = (u - previousUv.x) / (nextUv.x - previousUv.x);\n  } else {\n    ratio = (v - previousUv.y) / (nextUv.y - previousUv.y);\n  }\n\n  const height1 = sourceEncoding.decodeHeight(sourceVertices, previousIndex);\n  const height2 = sourceEncoding.decodeHeight(sourceVertices, nextIndex);\n\n  const targetRectangle = targetTile.rectangle;\n  cartographicScratch.longitude = CesiumMath.lerp(\n    targetRectangle.west,\n    targetRectangle.east,\n    u\n  );\n  cartographicScratch.latitude = CesiumMath.lerp(\n    targetRectangle.south,\n    targetRectangle.north,\n    v\n  );\n  vertex.height = cartographicScratch.height = CesiumMath.lerp(\n    height1,\n    height2,\n    ratio\n  );\n\n  let normal;\n  if (sourceEncoding.hasVertexNormals) {\n    const encodedNormal1 = sourceEncoding.getOctEncodedNormal(\n      sourceVertices,\n      previousIndex,\n      encodedNormalScratch\n    );\n    const encodedNormal2 = sourceEncoding.getOctEncodedNormal(\n      sourceVertices,\n      nextIndex,\n      encodedNormalScratch2\n    );\n    const normal1 = AttributeCompression.octDecode(\n      encodedNormal1.x,\n      encodedNormal1.y,\n      cartesianScratch\n    );\n    const normal2 = AttributeCompression.octDecode(\n      encodedNormal2.x,\n      encodedNormal2.y,\n      cartesianScratch2\n    );\n    normal = Cartesian3.lerp(normal1, normal2, ratio, cartesianScratch);\n    Cartesian3.normalize(normal, normal);\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormalCartographic(\n      cartographicScratch,\n      cartesianScratch\n    );\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  }\n}\n\nfunction getVertexWithHeightAtCorner(\n  terrainFillMesh,\n  ellipsoid,\n  u,\n  v,\n  height,\n  vertex\n) {\n  vertex.height = height;\n  const normal = ellipsoid.geodeticSurfaceNormalCartographic(\n    cartographicScratch,\n    cartesianScratch\n  );\n  AttributeCompression.octEncode(normal, vertex.encodedNormal);\n}\n\nfunction getCorner(\n  terrainFillMesh,\n  ellipsoid,\n  u,\n  v,\n  cornerTile,\n  cornerMesh,\n  previousEdgeTiles,\n  previousEdgeMeshes,\n  nextEdgeTiles,\n  nextEdgeMeshes,\n  vertex\n) {\n  const gotCorner =\n    getCornerFromEdge(\n      terrainFillMesh,\n      ellipsoid,\n      previousEdgeMeshes,\n      previousEdgeTiles,\n      false,\n      u,\n      v,\n      vertex\n    ) ||\n    getCornerFromEdge(\n      terrainFillMesh,\n      ellipsoid,\n      nextEdgeMeshes,\n      nextEdgeTiles,\n      true,\n      u,\n      v,\n      vertex\n    );\n  if (gotCorner) {\n    return vertex;\n  }\n\n  let vertexIndex;\n\n  if (meshIsUsable(cornerTile, cornerMesh)) {\n    // Corner mesh is valid, copy its corner vertex to this mesh.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest destination, northeast source\n        vertexIndex = cornerMesh.eastIndicesNorthToSouth[0];\n      } else {\n        // northwest destination, southeast source\n        vertexIndex = cornerMesh.southIndicesEastToWest[0];\n      }\n    } else if (v === 0.0) {\n      // southeast destination, northwest source\n      vertexIndex = cornerMesh.northIndicesWestToEast[0];\n    } else {\n      // northeast destination, southwest source\n      vertexIndex = cornerMesh.westIndicesSouthToNorth[0];\n    }\n    getVertexFromTileAtCorner(cornerMesh, vertexIndex, u, v, vertex);\n    return vertex;\n  }\n\n  // There is no precise vertex available from the corner or from either adjacent edge.\n  // This is either because there are no tiles at all at the edges and corner, or\n  // because the tiles at the edge are higher-level-number and don't extend all the way\n  // to the corner.\n  // Try to grab a height from the adjacent edges.\n  let height;\n  if (u === 0.0) {\n    if (v === 0.0) {\n      // southwest\n      height = getClosestHeightToCorner(\n        terrainFillMesh.westMeshes,\n        terrainFillMesh.westTiles,\n        TileEdge.EAST,\n        terrainFillMesh.southMeshes,\n        terrainFillMesh.southTiles,\n        TileEdge.NORTH,\n        u,\n        v\n      );\n    } else {\n      // northwest\n      height = getClosestHeightToCorner(\n        terrainFillMesh.northMeshes,\n        terrainFillMesh.northTiles,\n        TileEdge.SOUTH,\n        terrainFillMesh.westMeshes,\n        terrainFillMesh.westTiles,\n        TileEdge.EAST,\n        u,\n        v\n      );\n    }\n  } else if (v === 0.0) {\n    // southeast\n    height = getClosestHeightToCorner(\n      terrainFillMesh.southMeshes,\n      terrainFillMesh.southTiles,\n      TileEdge.NORTH,\n      terrainFillMesh.eastMeshes,\n      terrainFillMesh.eastTiles,\n      TileEdge.WEST,\n      u,\n      v\n    );\n  } else {\n    // northeast\n    height = getClosestHeightToCorner(\n      terrainFillMesh.eastMeshes,\n      terrainFillMesh.eastTiles,\n      TileEdge.WEST,\n      terrainFillMesh.northMeshes,\n      terrainFillMesh.northTiles,\n      TileEdge.SOUTH,\n      u,\n      v\n    );\n  }\n\n  if (defined(height)) {\n    getVertexWithHeightAtCorner(\n      terrainFillMesh,\n      ellipsoid,\n      u,\n      v,\n      height,\n      vertex\n    );\n    return vertex;\n  }\n\n  // No heights available that are closer than the adjacent corners.\n  return undefined;\n}\n\nfunction getClosestHeightToCorner(\n  previousMeshes,\n  previousTiles,\n  previousEdge,\n  nextMeshes,\n  nextTiles,\n  nextEdge,\n  u,\n  v\n) {\n  const height1 = getNearestHeightOnEdge(\n    previousMeshes,\n    previousTiles,\n    false,\n    previousEdge,\n    u,\n    v\n  );\n  const height2 = getNearestHeightOnEdge(\n    nextMeshes,\n    nextTiles,\n    true,\n    nextEdge,\n    u,\n    v\n  );\n  if (defined(height1) && defined(height2)) {\n    // It would be slightly better to do a weighted average of the two heights\n    // based on their distance from the corner, but it shouldn't matter much in practice.\n    return (height1 + height2) * 0.5;\n  } else if (defined(height1)) {\n    return height1;\n  }\n  return height2;\n}\n\nfunction addEdge(\n  terrainFillMesh,\n  ellipsoid,\n  encoding,\n  typedArray,\n  nextIndex,\n  edgeTiles,\n  edgeMeshes,\n  tileEdge,\n  heightRange\n) {\n  for (let i = 0; i < edgeTiles.length; ++i) {\n    nextIndex = addEdgeMesh(\n      terrainFillMesh,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      edgeTiles[i],\n      edgeMeshes[i],\n      tileEdge,\n      heightRange\n    );\n  }\n  return nextIndex;\n}\n\nfunction addEdgeMesh(\n  terrainFillMesh,\n  ellipsoid,\n  encoding,\n  typedArray,\n  nextIndex,\n  edgeTile,\n  edgeMesh,\n  tileEdge,\n  heightRange\n) {\n  // Handle copying edges across the anti-meridian.\n  let sourceRectangle = edgeTile.rectangle;\n  if (tileEdge === TileEdge.EAST && terrainFillMesh.tile.x === 0) {\n    sourceRectangle = Rectangle.clone(\n      edgeTile.rectangle,\n      sourceRectangleScratch\n    );\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (tileEdge === TileEdge.WEST && edgeTile.x === 0) {\n    sourceRectangle = Rectangle.clone(\n      edgeTile.rectangle,\n      sourceRectangleScratch\n    );\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n\n  const targetRectangle = terrainFillMesh.tile.rectangle;\n\n  let lastU;\n  let lastV;\n\n  if (nextIndex > 0) {\n    encoding.decodeTextureCoordinates(typedArray, nextIndex - 1, uvScratch);\n    lastU = uvScratch.x;\n    lastV = uvScratch.y;\n  }\n\n  let indices;\n  let compareU;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      indices = edgeMesh.westIndicesSouthToNorth;\n      compareU = false;\n      break;\n    case TileEdge.NORTH:\n      indices = edgeMesh.northIndicesWestToEast;\n      compareU = true;\n      break;\n    case TileEdge.EAST:\n      indices = edgeMesh.eastIndicesNorthToSouth;\n      compareU = false;\n      break;\n    case TileEdge.SOUTH:\n      indices = edgeMesh.southIndicesEastToWest;\n      compareU = true;\n      break;\n  }\n\n  const sourceTile = edgeTile;\n  const targetTile = terrainFillMesh.tile;\n  const sourceEncoding = edgeMesh.encoding;\n  const sourceVertices = edgeMesh.vertices;\n  const targetStride = encoding.stride;\n\n  let southMercatorY;\n  let oneOverMercatorHeight;\n  if (sourceEncoding.hasWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      targetRectangle.south\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n        targetRectangle.north\n      ) -\n        southMercatorY);\n  }\n\n  for (let i = 0; i < indices.length; ++i) {\n    const index = indices[i];\n\n    const uv = sourceEncoding.decodeTextureCoordinates(\n      sourceVertices,\n      index,\n      uvScratch\n    );\n    transformTextureCoordinates(sourceTile, targetTile, uv, uv);\n    const u = uv.x;\n    const v = uv.y;\n    const uOrV = compareU ? u : v;\n\n    if (uOrV < 0.0 || uOrV > 1.0) {\n      // Vertex is outside the target tile - skip it.\n      continue;\n    }\n\n    if (\n      Math.abs(u - lastU) < CesiumMath.EPSILON5 &&\n      Math.abs(v - lastV) < CesiumMath.EPSILON5\n    ) {\n      // Vertex is very close to the previous one - skip it.\n      continue;\n    }\n\n    const nearlyEdgeU =\n      Math.abs(u) < CesiumMath.EPSILON5 ||\n      Math.abs(u - 1.0) < CesiumMath.EPSILON5;\n    const nearlyEdgeV =\n      Math.abs(v) < CesiumMath.EPSILON5 ||\n      Math.abs(v - 1.0) < CesiumMath.EPSILON5;\n\n    if (nearlyEdgeU && nearlyEdgeV) {\n      // Corner vertex - skip it.\n      continue;\n    }\n\n    const position = sourceEncoding.decodePosition(\n      sourceVertices,\n      index,\n      cartesianScratch\n    );\n    const height = sourceEncoding.decodeHeight(sourceVertices, index);\n\n    let normal;\n    if (sourceEncoding.hasVertexNormals) {\n      normal = sourceEncoding.getOctEncodedNormal(\n        sourceVertices,\n        index,\n        octEncodedNormalScratch\n      );\n    } else {\n      normal = octEncodedNormalScratch;\n      normal.x = 0.0;\n      normal.y = 0.0;\n    }\n\n    let webMercatorT = v;\n    if (sourceEncoding.hasWebMercatorT) {\n      const latitude = CesiumMath.lerp(\n        targetRectangle.south,\n        targetRectangle.north,\n        v\n      );\n      webMercatorT =\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    let geodeticSurfaceNormal;\n    if (encoding.hasGeodeticSurfaceNormals) {\n      geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n        position,\n        normalScratch\n      );\n    }\n\n    encoding.encode(\n      typedArray,\n      nextIndex * targetStride,\n      position,\n      uv,\n      height,\n      normal,\n      webMercatorT,\n      geodeticSurfaceNormal\n    );\n\n    heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n    heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n\n    ++nextIndex;\n  }\n\n  return nextIndex;\n}\n\nfunction getNearestHeightOnEdge(meshes, tiles, isNext, edge, u, v) {\n  let meshStart;\n  let meshEnd;\n  let meshStep;\n\n  if (isNext) {\n    meshStart = 0;\n    meshEnd = meshes.length;\n    meshStep = 1;\n  } else {\n    meshStart = meshes.length - 1;\n    meshEnd = -1;\n    meshStep = -1;\n  }\n\n  for (\n    let meshIndex = meshStart;\n    meshIndex !== meshEnd;\n    meshIndex += meshStep\n  ) {\n    const mesh = meshes[meshIndex];\n    const tile = tiles[meshIndex];\n    if (!meshIsUsable(tile, mesh)) {\n      continue;\n    }\n\n    let indices;\n    switch (edge) {\n      case TileEdge.WEST:\n        indices = mesh.westIndicesSouthToNorth;\n        break;\n      case TileEdge.SOUTH:\n        indices = mesh.southIndicesEastToWest;\n        break;\n      case TileEdge.EAST:\n        indices = mesh.eastIndicesNorthToSouth;\n        break;\n      case TileEdge.NORTH:\n        indices = mesh.northIndicesWestToEast;\n        break;\n    }\n\n    const index = indices[isNext ? 0 : indices.length - 1];\n    if (defined(index)) {\n      return mesh.encoding.decodeHeight(mesh.vertices, index);\n    }\n  }\n\n  return undefined;\n}\n\nfunction meshIsUsable(tile, mesh) {\n  return (\n    defined(mesh) &&\n    (!defined(tile.data.fill) || !tile.data.fill.changedThisFrame)\n  );\n}\n\nfunction getCornerFromEdge(\n  terrainFillMesh,\n  ellipsoid,\n  edgeMeshes,\n  edgeTiles,\n  isNext,\n  u,\n  v,\n  vertex\n) {\n  let edgeVertices;\n  let compareU;\n  let increasing;\n  let vertexIndexIndex;\n  let vertexIndex;\n  const sourceTile = edgeTiles[isNext ? 0 : edgeMeshes.length - 1];\n  const sourceMesh = edgeMeshes[isNext ? 0 : edgeMeshes.length - 1];\n\n  if (meshIsUsable(sourceTile, sourceMesh)) {\n    // Previous mesh is valid, but we don't know yet if it covers this corner.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest\n        edgeVertices = isNext\n          ? sourceMesh.northIndicesWestToEast\n          : sourceMesh.eastIndicesNorthToSouth;\n        compareU = isNext;\n        increasing = isNext;\n      } else {\n        // northwest\n        edgeVertices = isNext\n          ? sourceMesh.eastIndicesNorthToSouth\n          : sourceMesh.southIndicesEastToWest;\n        compareU = !isNext;\n        increasing = false;\n      }\n    } else if (v === 0.0) {\n      // southeast\n      edgeVertices = isNext\n        ? sourceMesh.westIndicesSouthToNorth\n        : sourceMesh.northIndicesWestToEast;\n      compareU = !isNext;\n      increasing = true;\n    } else {\n      // northeast\n      edgeVertices = isNext\n        ? sourceMesh.southIndicesEastToWest\n        : sourceMesh.westIndicesSouthToNorth;\n      compareU = isNext;\n      increasing = !isNext;\n    }\n\n    if (edgeVertices.length > 0) {\n      // The vertex we want will very often be the first/last vertex so check that first.\n      vertexIndexIndex = isNext ? 0 : edgeVertices.length - 1;\n      vertexIndex = edgeVertices[vertexIndexIndex];\n      sourceMesh.encoding.decodeTextureCoordinates(\n        sourceMesh.vertices,\n        vertexIndex,\n        uvScratch\n      );\n      const targetUv = transformTextureCoordinates(\n        sourceTile,\n        terrainFillMesh.tile,\n        uvScratch,\n        uvScratch\n      );\n      if (targetUv.x === u && targetUv.y === v) {\n        // Vertex is good!\n        getVertexFromTileAtCorner(sourceMesh, vertexIndex, u, v, vertex);\n        return true;\n      }\n\n      // The last vertex is not the one we need, try binary searching for the right one.\n      vertexIndexIndex = binarySearch(edgeVertices, compareU ? u : v, function (\n        vertexIndex,\n        textureCoordinate\n      ) {\n        sourceMesh.encoding.decodeTextureCoordinates(\n          sourceMesh.vertices,\n          vertexIndex,\n          uvScratch\n        );\n        const targetUv = transformTextureCoordinates(\n          sourceTile,\n          terrainFillMesh.tile,\n          uvScratch,\n          uvScratch\n        );\n        if (increasing) {\n          if (compareU) {\n            return targetUv.x - u;\n          }\n          return targetUv.y - v;\n        } else if (compareU) {\n          return u - targetUv.x;\n        }\n        return v - targetUv.y;\n      });\n\n      if (vertexIndexIndex < 0) {\n        vertexIndexIndex = ~vertexIndexIndex;\n\n        if (vertexIndexIndex > 0 && vertexIndexIndex < edgeVertices.length) {\n          // The corner falls between two vertices, so interpolate between them.\n          getInterpolatedVertexAtCorner(\n            ellipsoid,\n            sourceTile,\n            terrainFillMesh.tile,\n            sourceMesh,\n            edgeVertices[vertexIndexIndex - 1],\n            edgeVertices[vertexIndexIndex],\n            u,\n            v,\n            compareU,\n            vertex\n          );\n          return true;\n        }\n      } else {\n        // Found a vertex that fits in the corner exactly.\n        getVertexFromTileAtCorner(\n          sourceMesh,\n          edgeVertices[vertexIndexIndex],\n          u,\n          v,\n          vertex\n        );\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nconst cornerPositionsScratch = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeOccludeePoint(\n  tileProvider,\n  center,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  result\n) {\n  const ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  const ellipsoid = ellipsoidalOccluder.ellipsoid;\n\n  const cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[0]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[1]\n  );\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[2]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[3]\n  );\n\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    center,\n    cornerPositions,\n    minimumHeight,\n    result\n  );\n}\nexport default TerrainFillMesh;\n","/**\n * @private\n */\nconst TerrainState = {\n  FAILED: 0,\n  UNLOADED: 1,\n  RECEIVING: 2,\n  RECEIVED: 3,\n  TRANSFORMING: 4,\n  TRANSFORMED: 5,\n  READY: 6,\n};\nexport default Object.freeze(TerrainState);\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Framebuffer from \"../Renderer/Framebuffer.js\";\nimport Texture from \"../Renderer/Texture.js\";\n\n// The atlas is made up of regions of space called nodes that contain images or child nodes.\nfunction TextureAtlasNode(\n  bottomLeft,\n  topRight,\n  childNode1,\n  childNode2,\n  imageIndex\n) {\n  this.bottomLeft = defaultValue(bottomLeft, Cartesian2.ZERO);\n  this.topRight = defaultValue(topRight, Cartesian2.ZERO);\n  this.childNode1 = childNode1;\n  this.childNode2 = childNode2;\n  this.imageIndex = imageIndex;\n}\n\nconst defaultInitialSize = new Cartesian2(16.0, 16.0);\n\n/**\n * A TextureAtlas stores multiple images in one square texture and keeps\n * track of the texture coordinates for each image. TextureAtlas is dynamic,\n * meaning new images can be added at any point in time.\n * Texture coordinates are subject to change if the texture atlas resizes, so it is\n * important to check {@link TextureAtlas#getGUID} before using old values.\n *\n * @alias TextureAtlas\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Scene} options.context The context in which the texture gets created.\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The pixel format of the texture.\n * @param {Number} [options.borderWidthInPixels=1] The amount of spacing between adjacent images in pixels.\n * @param {Cartesian2} [options.initialSize=new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.\n *\n * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.\n * @exception {DeveloperError} initialSize must be greater than zero.\n *\n * @private\n */\nfunction TextureAtlas(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const borderWidthInPixels = defaultValue(options.borderWidthInPixels, 1.0);\n  const initialSize = defaultValue(options.initialSize, defaultInitialSize);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.context)) {\n    throw new DeveloperError(\"context is required.\");\n  }\n  if (borderWidthInPixels < 0) {\n    throw new DeveloperError(\n      \"borderWidthInPixels must be greater than or equal to zero.\"\n    );\n  }\n  if (initialSize.x < 1 || initialSize.y < 1) {\n    throw new DeveloperError(\"initialSize must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  this._context = options.context;\n  this._pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);\n  this._borderWidthInPixels = borderWidthInPixels;\n  this._textureCoordinates = [];\n  this._guid = createGuid();\n  this._idHash = {};\n  this._indexHash = {};\n  this._initialSize = initialSize;\n\n  this._root = undefined;\n}\n\nObject.defineProperties(TextureAtlas.prototype, {\n  /**\n   * The amount of spacing between adjacent images in pixels.\n   * @memberof TextureAtlas.prototype\n   * @type {Number}\n   */\n  borderWidthInPixels: {\n    get: function () {\n      return this._borderWidthInPixels;\n    },\n  },\n\n  /**\n   * An array of {@link BoundingRectangle} texture coordinate regions for all the images in the texture atlas.\n   * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.\n   * The coordinates are in the order that the corresponding images were added to the atlas.\n   * @memberof TextureAtlas.prototype\n   * @type {BoundingRectangle[]}\n   */\n  textureCoordinates: {\n    get: function () {\n      return this._textureCoordinates;\n    },\n  },\n\n  /**\n   * The texture that all of the images are being written to.\n   * @memberof TextureAtlas.prototype\n   * @type {Texture}\n   */\n  texture: {\n    get: function () {\n      if (!defined(this._texture)) {\n        this._texture = new Texture({\n          context: this._context,\n          width: this._initialSize.x,\n          height: this._initialSize.y,\n          pixelFormat: this._pixelFormat,\n        });\n      }\n      return this._texture;\n    },\n  },\n\n  /**\n   * The number of images in the texture atlas. This value increases\n   * every time addImage or addImages is called.\n   * Texture coordinates are subject to change if the texture atlas resizes, so it is\n   * important to check {@link TextureAtlas#getGUID} before using old values.\n   * @memberof TextureAtlas.prototype\n   * @type {Number}\n   */\n  numberOfImages: {\n    get: function () {\n      return this._textureCoordinates.length;\n    },\n  },\n\n  /**\n   * The atlas' globally unique identifier (GUID).\n   * The GUID changes whenever the texture atlas is modified.\n   * Classes that use a texture atlas should check if the GUID\n   * has changed before processing the atlas data.\n   * @memberof TextureAtlas.prototype\n   * @type {String}\n   */\n  guid: {\n    get: function () {\n      return this._guid;\n    },\n  },\n});\n\n// Builds a larger texture and copies the old texture into the new one.\nfunction resizeAtlas(textureAtlas, image) {\n  const context = textureAtlas._context;\n  const numImages = textureAtlas.numberOfImages;\n  const scalingFactor = 2.0;\n  const borderWidthInPixels = textureAtlas._borderWidthInPixels;\n  if (numImages > 0) {\n    const oldAtlasWidth = textureAtlas._texture.width;\n    const oldAtlasHeight = textureAtlas._texture.height;\n    const atlasWidth =\n      scalingFactor * (oldAtlasWidth + image.width + borderWidthInPixels);\n    const atlasHeight =\n      scalingFactor * (oldAtlasHeight + image.height + borderWidthInPixels);\n    const widthRatio = oldAtlasWidth / atlasWidth;\n    const heightRatio = oldAtlasHeight / atlasHeight;\n\n    // Create new node structure, putting the old root node in the bottom left.\n    const nodeBottomRight = new TextureAtlasNode(\n      new Cartesian2(oldAtlasWidth + borderWidthInPixels, borderWidthInPixels),\n      new Cartesian2(atlasWidth, oldAtlasHeight)\n    );\n    const nodeBottomHalf = new TextureAtlasNode(\n      new Cartesian2(),\n      new Cartesian2(atlasWidth, oldAtlasHeight),\n      textureAtlas._root,\n      nodeBottomRight\n    );\n    const nodeTopHalf = new TextureAtlasNode(\n      new Cartesian2(borderWidthInPixels, oldAtlasHeight + borderWidthInPixels),\n      new Cartesian2(atlasWidth, atlasHeight)\n    );\n    const nodeMain = new TextureAtlasNode(\n      new Cartesian2(),\n      new Cartesian2(atlasWidth, atlasHeight),\n      nodeBottomHalf,\n      nodeTopHalf\n    );\n\n    // Resize texture coordinates.\n    for (let i = 0; i < textureAtlas._textureCoordinates.length; i++) {\n      const texCoord = textureAtlas._textureCoordinates[i];\n      if (defined(texCoord)) {\n        texCoord.x *= widthRatio;\n        texCoord.y *= heightRatio;\n        texCoord.width *= widthRatio;\n        texCoord.height *= heightRatio;\n      }\n    }\n\n    // Copy larger texture.\n    const newTexture = new Texture({\n      context: textureAtlas._context,\n      width: atlasWidth,\n      height: atlasHeight,\n      pixelFormat: textureAtlas._pixelFormat,\n    });\n\n    const framebuffer = new Framebuffer({\n      context: context,\n      colorTextures: [textureAtlas._texture],\n      destroyAttachments: false,\n    });\n\n    framebuffer._bind();\n    newTexture.copyFromFramebuffer(0, 0, 0, 0, atlasWidth, atlasHeight);\n    framebuffer._unBind();\n    framebuffer.destroy();\n    textureAtlas._texture =\n      textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = newTexture;\n    textureAtlas._root = nodeMain;\n  } else {\n    // First image exceeds initialSize\n    let initialWidth = scalingFactor * (image.width + 2 * borderWidthInPixels);\n    let initialHeight =\n      scalingFactor * (image.height + 2 * borderWidthInPixels);\n    if (initialWidth < textureAtlas._initialSize.x) {\n      initialWidth = textureAtlas._initialSize.x;\n    }\n    if (initialHeight < textureAtlas._initialSize.y) {\n      initialHeight = textureAtlas._initialSize.y;\n    }\n    textureAtlas._texture =\n      textureAtlas._texture && textureAtlas._texture.destroy();\n    textureAtlas._texture = new Texture({\n      context: textureAtlas._context,\n      width: initialWidth,\n      height: initialHeight,\n      pixelFormat: textureAtlas._pixelFormat,\n    });\n    textureAtlas._root = new TextureAtlasNode(\n      new Cartesian2(borderWidthInPixels, borderWidthInPixels),\n      new Cartesian2(initialWidth, initialHeight)\n    );\n  }\n}\n\n// A recursive function that finds the best place to insert\n// a new image based on existing image 'nodes'.\n// Inspired by: http://blackpawn.com/texts/lightmaps/default.html\nfunction findNode(textureAtlas, node, image) {\n  if (!defined(node)) {\n    return undefined;\n  }\n\n  // If a leaf node\n  if (!defined(node.childNode1) && !defined(node.childNode2)) {\n    // Node already contains an image, don't add to it.\n    if (defined(node.imageIndex)) {\n      return undefined;\n    }\n\n    const nodeWidth = node.topRight.x - node.bottomLeft.x;\n    const nodeHeight = node.topRight.y - node.bottomLeft.y;\n    const widthDifference = nodeWidth - image.width;\n    const heightDifference = nodeHeight - image.height;\n\n    // Node is smaller than the image.\n    if (widthDifference < 0 || heightDifference < 0) {\n      return undefined;\n    }\n\n    // If the node is the same size as the image, return the node\n    if (widthDifference === 0 && heightDifference === 0) {\n      return node;\n    }\n\n    // Vertical split (childNode1 = left half, childNode2 = right half).\n    if (widthDifference > heightDifference) {\n      node.childNode1 = new TextureAtlasNode(\n        new Cartesian2(node.bottomLeft.x, node.bottomLeft.y),\n        new Cartesian2(node.bottomLeft.x + image.width, node.topRight.y)\n      );\n      // Only make a second child if the border gives enough space.\n      const childNode2BottomLeftX =\n        node.bottomLeft.x + image.width + textureAtlas._borderWidthInPixels;\n      if (childNode2BottomLeftX < node.topRight.x) {\n        node.childNode2 = new TextureAtlasNode(\n          new Cartesian2(childNode2BottomLeftX, node.bottomLeft.y),\n          new Cartesian2(node.topRight.x, node.topRight.y)\n        );\n      }\n    }\n    // Horizontal split (childNode1 = bottom half, childNode2 = top half).\n    else {\n      node.childNode1 = new TextureAtlasNode(\n        new Cartesian2(node.bottomLeft.x, node.bottomLeft.y),\n        new Cartesian2(node.topRight.x, node.bottomLeft.y + image.height)\n      );\n      // Only make a second child if the border gives enough space.\n      const childNode2BottomLeftY =\n        node.bottomLeft.y + image.height + textureAtlas._borderWidthInPixels;\n      if (childNode2BottomLeftY < node.topRight.y) {\n        node.childNode2 = new TextureAtlasNode(\n          new Cartesian2(node.bottomLeft.x, childNode2BottomLeftY),\n          new Cartesian2(node.topRight.x, node.topRight.y)\n        );\n      }\n    }\n    return findNode(textureAtlas, node.childNode1, image);\n  }\n\n  // If not a leaf node\n  return (\n    findNode(textureAtlas, node.childNode1, image) ||\n    findNode(textureAtlas, node.childNode2, image)\n  );\n}\n\n// Adds image of given index to the texture atlas. Called from addImage and addImages.\nfunction addImage(textureAtlas, image, index) {\n  const node = findNode(textureAtlas, textureAtlas._root, image);\n  if (defined(node)) {\n    // Found a node that can hold the image.\n    node.imageIndex = index;\n\n    // Add texture coordinate and write to texture\n    const atlasWidth = textureAtlas._texture.width;\n    const atlasHeight = textureAtlas._texture.height;\n    const nodeWidth = node.topRight.x - node.bottomLeft.x;\n    const nodeHeight = node.topRight.y - node.bottomLeft.y;\n    const x = node.bottomLeft.x / atlasWidth;\n    const y = node.bottomLeft.y / atlasHeight;\n    const w = nodeWidth / atlasWidth;\n    const h = nodeHeight / atlasHeight;\n    textureAtlas._textureCoordinates[index] = new BoundingRectangle(x, y, w, h);\n    textureAtlas._texture.copyFrom({\n      source: image,\n      xOffset: node.bottomLeft.x,\n      yOffset: node.bottomLeft.y,\n    });\n  } else {\n    // No node found, must resize the texture atlas.\n    resizeAtlas(textureAtlas, image);\n    addImage(textureAtlas, image, index);\n  }\n\n  textureAtlas._guid = createGuid();\n}\n\nfunction getIndex(atlas, image) {\n  if (!defined(atlas) || atlas.isDestroyed()) {\n    return -1;\n  }\n\n  const index = atlas.numberOfImages;\n\n  addImage(atlas, image, index);\n\n  return index;\n}\n\n/**\n * If the image is already in the atlas, the existing index is returned. Otherwise, the result is undefined.\n *\n * @param {String} id An identifier to detect whether the image already exists in the atlas.\n * @returns {Number|undefined} The image index, or undefined if the image does not exist in the atlas.\n */\nTextureAtlas.prototype.getImageIndex = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._indexHash[id];\n};\n\n/**\n * Adds an image to the atlas synchronously.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n *\n * @param {String} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement} image An image or canvas to add to the texture atlas.\n * @returns {Number} The image index.\n */\nTextureAtlas.prototype.addImageSync = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(image)) {\n    throw new DeveloperError(\"image is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let index = this._indexHash[id];\n  if (defined(index)) {\n    // we're already aware of this source\n    return index;\n  }\n\n  index = getIndex(this, image);\n  // store the promise\n  this._idHash[id] = Promise.resolve(index);\n  this._indexHash[id] = index;\n  // but return the value synchronously\n  return index;\n};\n\n/**\n * Adds an image to the atlas.  If the image is already in the atlas, the atlas is unchanged and\n * the existing index is used.\n *\n * @param {String} id An identifier to detect whether the image already exists in the atlas.\n * @param {HTMLImageElement|HTMLCanvasElement|String|Resource|Promise|TextureAtlas.CreateImageCallback} image An image or canvas to add to the texture atlas,\n *        or a URL to an Image, or a Promise for an image, or a function that creates an image.\n * @returns {Promise.<Number>} A Promise for the image index.\n */\nTextureAtlas.prototype.addImage = function (id, image) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(image)) {\n    throw new DeveloperError(\"image is required.\");\n  }\n  //>>includeEnd('debug');\n\n  let indexPromise = this._idHash[id];\n  if (defined(indexPromise)) {\n    // we're already aware of this source\n    return indexPromise;\n  }\n\n  // not in atlas, create the promise for the index\n\n  if (typeof image === \"function\") {\n    // if image is a function, call it\n    image = image(id);\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(image)) {\n      throw new DeveloperError(\"image is required.\");\n    }\n    //>>includeEnd('debug');\n  } else if (typeof image === \"string\" || image instanceof Resource) {\n    // Get a resource\n    const resource = Resource.createIfNeeded(image);\n    image = resource.fetchImage();\n  }\n\n  const that = this;\n  indexPromise = Promise.resolve(image).then(function (image) {\n    const index = getIndex(that, image);\n    that._indexHash[id] = index;\n    return index;\n  });\n\n  // store the promise\n  this._idHash[id] = indexPromise;\n\n  return indexPromise;\n};\n\n/**\n * Add a sub-region of an existing atlas image as additional image indices.\n *\n * @param {String} id The identifier of the existing image.\n * @param {BoundingRectangle} subRegion An {@link BoundingRectangle} sub-region measured in pixels from the bottom-left.\n *\n * @returns {Promise.<Number>} A Promise for the image index.\n */\nTextureAtlas.prototype.addSubRegion = function (id, subRegion) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required.\");\n  }\n  if (!defined(subRegion)) {\n    throw new DeveloperError(\"subRegion is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indexPromise = this._idHash[id];\n  if (!defined(indexPromise)) {\n    throw new RuntimeError(`image with id \"${id}\" not found in the atlas.`);\n  }\n\n  const that = this;\n  return Promise.resolve(indexPromise).then(function (index) {\n    if (index === -1) {\n      // the atlas is destroyed\n      return -1;\n    }\n    const atlasWidth = that._texture.width;\n    const atlasHeight = that._texture.height;\n    const numImages = that.numberOfImages;\n\n    const baseRegion = that._textureCoordinates[index];\n    const x = baseRegion.x + subRegion.x / atlasWidth;\n    const y = baseRegion.y + subRegion.y / atlasHeight;\n    const w = subRegion.width / atlasWidth;\n    const h = subRegion.height / atlasHeight;\n    that._textureCoordinates.push(new BoundingRectangle(x, y, w, h));\n    that._guid = createGuid();\n\n    return numImages;\n  });\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureAtlas#destroy\n */\nTextureAtlas.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * atlas = atlas && atlas.destroy();\n *\n * @see TextureAtlas#isDestroyed\n */\nTextureAtlas.prototype.destroy = function () {\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\n\n/**\n * A function that creates an image.\n * @callback TextureAtlas.CreateImageCallback\n * @param {String} id The identifier of the image to load.\n * @returns {HTMLImageElement|Promise<HTMLImageElement>} The image, or a promise that will resolve to an image.\n */\nexport default TextureAtlas;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RectangleOutlineGeometry from \"../Core/RectangleOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * A tile bounding volume specified as a longitude/latitude/height region.\n * @alias TileBoundingRegion\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Rectangle} options.rectangle The rectangle specifying the longitude and latitude range of the region.\n * @param {Number} [options.minimumHeight=0.0] The minimum height of the region.\n * @param {Number} [options.maximumHeight=0.0] The maximum height of the region.\n * @param {Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] The ellipsoid.\n * @param {Boolean} [options.computeBoundingVolumes=true] True to compute the {@link TileBoundingRegion#boundingVolume} and\n *                  {@link TileBoundingVolume#boundingSphere}. If false, these properties will be undefined.\n *\n * @private\n */\nfunction TileBoundingRegion(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.rectangle\", options.rectangle);\n  //>>includeEnd('debug');\n\n  this.rectangle = Rectangle.clone(options.rectangle);\n  this.minimumHeight = defaultValue(options.minimumHeight, 0.0);\n  this.maximumHeight = defaultValue(options.maximumHeight, 0.0);\n\n  /**\n   * The world coordinates of the southwest corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.southwestCornerCartesian = new Cartesian3();\n\n  /**\n   * The world coordinates of the northeast corner of the tile's rectangle.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.northeastCornerCartesian = new Cartesian3();\n\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the western edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.westNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with southwestCornerCartesian, defines a plane at the southern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.southNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.eastNormal = new Cartesian3();\n\n  /**\n   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of\n   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.\n   * Because points of constant latitude do not necessary lie in a plane, positions below this\n   * plane are not necessarily inside the tile, but they are close.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3()\n   */\n  this.northNormal = new Cartesian3();\n\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  computeBox(this, options.rectangle, ellipsoid);\n\n  this._orientedBoundingBox = undefined;\n  this._boundingSphere = undefined;\n\n  if (defaultValue(options.computeBoundingVolumes, true)) {\n    this.computeBoundingVolumes(ellipsoid);\n  }\n}\n\nObject.defineProperties(TileBoundingRegion.prototype, {\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._orientedBoundingBox;\n    },\n  },\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingRegion.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\nTileBoundingRegion.prototype.computeBoundingVolumes = function (ellipsoid) {\n  // An oriented bounding box that encloses this tile's region.  This is used to calculate tile visibility.\n  this._orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    this.rectangle,\n    this.minimumHeight,\n    this.maximumHeight,\n    ellipsoid\n  );\n\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox\n  );\n};\n\nconst cartesian3Scratch = new Cartesian3();\nconst cartesian3Scratch2 = new Cartesian3();\nconst cartesian3Scratch3 = new Cartesian3();\nconst westNormalScratch = new Cartesian3();\nconst eastWestNormalScratch = new Cartesian3();\nconst westernMidpointScratch = new Cartesian3();\nconst easternMidpointScratch = new Cartesian3();\nconst cartographicScratch = new Cartographic();\nconst planeScratch = new Plane(Cartesian3.UNIT_X, 0.0);\nconst rayScratch = new Ray();\n\nfunction computeBox(tileBB, rectangle, ellipsoid) {\n  ellipsoid.cartographicToCartesian(\n    Rectangle.southwest(rectangle),\n    tileBB.southwestCornerCartesian\n  );\n  ellipsoid.cartographicToCartesian(\n    Rectangle.northeast(rectangle),\n    tileBB.northeastCornerCartesian\n  );\n\n  // The middle latitude on the western edge.\n  cartographicScratch.longitude = rectangle.west;\n  cartographicScratch.latitude = (rectangle.south + rectangle.north) * 0.5;\n  cartographicScratch.height = 0.0;\n  const westernMidpointCartesian = ellipsoid.cartographicToCartesian(\n    cartographicScratch,\n    westernMidpointScratch\n  );\n\n  // Compute the normal of the plane on the western edge of the tile.\n  const westNormal = Cartesian3.cross(\n    westernMidpointCartesian,\n    Cartesian3.UNIT_Z,\n    westNormalScratch\n  );\n  Cartesian3.normalize(westNormal, tileBB.westNormal);\n\n  // The middle latitude on the eastern edge.\n  cartographicScratch.longitude = rectangle.east;\n  const easternMidpointCartesian = ellipsoid.cartographicToCartesian(\n    cartographicScratch,\n    easternMidpointScratch\n  );\n\n  // Compute the normal of the plane on the eastern edge of the tile.\n  const eastNormal = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    easternMidpointCartesian,\n    cartesian3Scratch\n  );\n  Cartesian3.normalize(eastNormal, tileBB.eastNormal);\n\n  let westVector = Cartesian3.subtract(\n    westernMidpointCartesian,\n    easternMidpointCartesian,\n    cartesian3Scratch\n  );\n\n  if (Cartesian3.magnitude(westVector) === 0.0) {\n    westVector = Cartesian3.clone(westNormal, westVector);\n  }\n\n  const eastWestNormal = Cartesian3.normalize(\n    westVector,\n    eastWestNormalScratch\n  );\n\n  // Compute the normal of the plane bounding the southern edge of the tile.\n  const south = rectangle.south;\n  let southSurfaceNormal;\n\n  if (south > 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = south;\n    const southCenterCartesian = ellipsoid.cartographicToCartesian(\n      cartographicScratch,\n      rayScratch.origin\n    );\n    Cartesian3.clone(eastWestNormal, rayScratch.direction);\n    const westPlane = Plane.fromPointNormal(\n      tileBB.southwestCornerCartesian,\n      tileBB.westNormal,\n      planeScratch\n    );\n    // Find a point that is on the west and the south planes\n    IntersectionTests.rayPlane(\n      rayScratch,\n      westPlane,\n      tileBB.southwestCornerCartesian\n    );\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      southCenterCartesian,\n      cartesian3Scratch2\n    );\n  } else {\n    southSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n      Rectangle.southeast(rectangle),\n      cartesian3Scratch2\n    );\n  }\n  const southNormal = Cartesian3.cross(\n    southSurfaceNormal,\n    westVector,\n    cartesian3Scratch3\n  );\n  Cartesian3.normalize(southNormal, tileBB.southNormal);\n\n  // Compute the normal of the plane bounding the northern edge of the tile.\n  const north = rectangle.north;\n  let northSurfaceNormal;\n\n  if (north < 0.0) {\n    // Compute a plane that doesn't cut through the tile.\n    cartographicScratch.longitude = (rectangle.west + rectangle.east) * 0.5;\n    cartographicScratch.latitude = north;\n    const northCenterCartesian = ellipsoid.cartographicToCartesian(\n      cartographicScratch,\n      rayScratch.origin\n    );\n    Cartesian3.negate(eastWestNormal, rayScratch.direction);\n    const eastPlane = Plane.fromPointNormal(\n      tileBB.northeastCornerCartesian,\n      tileBB.eastNormal,\n      planeScratch\n    );\n    // Find a point that is on the east and the north planes\n    IntersectionTests.rayPlane(\n      rayScratch,\n      eastPlane,\n      tileBB.northeastCornerCartesian\n    );\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      northCenterCartesian,\n      cartesian3Scratch2\n    );\n  } else {\n    northSurfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n      Rectangle.northwest(rectangle),\n      cartesian3Scratch2\n    );\n  }\n  const northNormal = Cartesian3.cross(\n    westVector,\n    northSurfaceNormal,\n    cartesian3Scratch3\n  );\n  Cartesian3.normalize(northNormal, tileBB.northNormal);\n}\n\nconst southwestCornerScratch = new Cartesian3();\nconst northeastCornerScratch = new Cartesian3();\nconst negativeUnitY = new Cartesian3(0.0, -1.0, 0.0);\nconst negativeUnitZ = new Cartesian3(0.0, 0.0, -1.0);\nconst vectorScratch = new Cartesian3();\n\nfunction distanceToCameraRegion(tileBB, frameState) {\n  const camera = frameState.camera;\n  const cameraCartesianPosition = camera.positionWC;\n  const cameraCartographicPosition = camera.positionCartographic;\n\n  let result = 0.0;\n  if (!Rectangle.contains(tileBB.rectangle, cameraCartographicPosition)) {\n    let southwestCornerCartesian = tileBB.southwestCornerCartesian;\n    let northeastCornerCartesian = tileBB.northeastCornerCartesian;\n    let westNormal = tileBB.westNormal;\n    let southNormal = tileBB.southNormal;\n    let eastNormal = tileBB.eastNormal;\n    let northNormal = tileBB.northNormal;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      southwestCornerCartesian = frameState.mapProjection.project(\n        Rectangle.southwest(tileBB.rectangle),\n        southwestCornerScratch\n      );\n      southwestCornerCartesian.z = southwestCornerCartesian.y;\n      southwestCornerCartesian.y = southwestCornerCartesian.x;\n      southwestCornerCartesian.x = 0.0;\n      northeastCornerCartesian = frameState.mapProjection.project(\n        Rectangle.northeast(tileBB.rectangle),\n        northeastCornerScratch\n      );\n      northeastCornerCartesian.z = northeastCornerCartesian.y;\n      northeastCornerCartesian.y = northeastCornerCartesian.x;\n      northeastCornerCartesian.x = 0.0;\n      westNormal = negativeUnitY;\n      eastNormal = Cartesian3.UNIT_Y;\n      southNormal = negativeUnitZ;\n      northNormal = Cartesian3.UNIT_Z;\n    }\n\n    const vectorFromSouthwestCorner = Cartesian3.subtract(\n      cameraCartesianPosition,\n      southwestCornerCartesian,\n      vectorScratch\n    );\n    const distanceToWestPlane = Cartesian3.dot(\n      vectorFromSouthwestCorner,\n      westNormal\n    );\n    const distanceToSouthPlane = Cartesian3.dot(\n      vectorFromSouthwestCorner,\n      southNormal\n    );\n\n    const vectorFromNortheastCorner = Cartesian3.subtract(\n      cameraCartesianPosition,\n      northeastCornerCartesian,\n      vectorScratch\n    );\n    const distanceToEastPlane = Cartesian3.dot(\n      vectorFromNortheastCorner,\n      eastNormal\n    );\n    const distanceToNorthPlane = Cartesian3.dot(\n      vectorFromNortheastCorner,\n      northNormal\n    );\n\n    if (distanceToWestPlane > 0.0) {\n      result += distanceToWestPlane * distanceToWestPlane;\n    } else if (distanceToEastPlane > 0.0) {\n      result += distanceToEastPlane * distanceToEastPlane;\n    }\n\n    if (distanceToSouthPlane > 0.0) {\n      result += distanceToSouthPlane * distanceToSouthPlane;\n    } else if (distanceToNorthPlane > 0.0) {\n      result += distanceToNorthPlane * distanceToNorthPlane;\n    }\n  }\n\n  let cameraHeight;\n  let minimumHeight;\n  let maximumHeight;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    cameraHeight = cameraCartographicPosition.height;\n    minimumHeight = tileBB.minimumHeight;\n    maximumHeight = tileBB.maximumHeight;\n  } else {\n    cameraHeight = cameraCartesianPosition.x;\n    minimumHeight = 0.0;\n    maximumHeight = 0.0;\n  }\n\n  if (cameraHeight > maximumHeight) {\n    const distanceAboveTop = cameraHeight - maximumHeight;\n    result += distanceAboveTop * distanceAboveTop;\n  } else if (cameraHeight < minimumHeight) {\n    const distanceBelowBottom = minimumHeight - cameraHeight;\n    result += distanceBelowBottom * distanceBelowBottom;\n  }\n\n  return Math.sqrt(result);\n}\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level of detail selection.\n *\n * @param {FrameState} frameState The state information of the current rendering frame.\n * @returns {Number} The distance from the camera to the closest point on the tile, in meters.\n */\nTileBoundingRegion.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const regionResult = distanceToCameraRegion(this, frameState);\n  if (\n    frameState.mode === SceneMode.SCENE3D &&\n    defined(this._orientedBoundingBox)\n  ) {\n    const obbResult = Math.sqrt(\n      this._orientedBoundingBox.distanceSquaredTo(frameState.camera.positionWC)\n    );\n    return Math.max(regionResult, obbResult);\n  }\n  return regionResult;\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nTileBoundingRegion.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n\n/**\n * Creates a debug primitive that shows the outline of the tile bounding region.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n *\n * @private\n */\nTileBoundingRegion.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  const modelMatrix = new Matrix4.clone(Matrix4.IDENTITY);\n  const geometry = new RectangleOutlineGeometry({\n    rectangle: this.rectangle,\n    height: this.minimumHeight,\n    extrudedHeight: this.maximumHeight,\n  });\n  const instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\nexport default TileBoundingRegion;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Plane from \"../Core/Plane.js\";\nimport CoplanarPolygonOutlineGeometry from \"../Core/CoplanarPolygonOutlineGeometry.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport S2Cell from \"../Core/S2Cell.js\";\nlet centerCartographicScratch = new Cartographic();\n/**\n * A tile bounding volume specified as an S2 cell token with minimum and maximum heights.\n * The bounding volume is a k DOP. A k-DOP is the Boolean intersection of extents along k directions.\n *\n * @alias TileBoundingS2Cell\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {String} options.token The token of the S2 cell.\n * @param {Number} [options.minimumHeight=0.0] The minimum height of the bounding volume.\n * @param {Number} [options.maximumHeight=0.0] The maximum height of the bounding volume.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @param {Boolean} [options.computeBoundingVolumes=true] True to compute the {@link TileBoundingS2Cell#boundingVolume} and\n *                  {@link TileBoundingS2Cell#boundingSphere}. If false, these properties will be undefined.\n *\n * @private\n */\nfunction TileBoundingS2Cell(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.string(\"options.token\", options.token);\n  //>>includeEnd('debug');\n\n  const s2Cell = S2Cell.fromToken(options.token);\n  const minimumHeight = defaultValue(options.minimumHeight, 0.0);\n  const maximumHeight = defaultValue(options.maximumHeight, 0.0);\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  this.s2Cell = s2Cell;\n  this.minimumHeight = minimumHeight;\n  this.maximumHeight = maximumHeight;\n  this.ellipsoid = ellipsoid;\n\n  const boundingPlanes = computeBoundingPlanes(\n    s2Cell,\n    minimumHeight,\n    maximumHeight,\n    ellipsoid\n  );\n  this._boundingPlanes = boundingPlanes;\n\n  // Pre-compute vertices to speed up the plane intersection test.\n  const vertices = computeVertices(boundingPlanes);\n  this._vertices = vertices;\n\n  // Pre-compute edge normals to speed up the point-polygon distance check in distanceToCamera.\n  this._edgeNormals = new Array(6);\n\n  this._edgeNormals[0] = computeEdgeNormals(\n    boundingPlanes[0],\n    vertices.slice(0, 4)\n  );\n  let i;\n  // Based on the way the edge normals are computed, the edge normals all point away from the \"face\"\n  // of the polyhedron they surround, except the plane for the top plane. Therefore, we negate the normals\n  // for the top plane.\n  for (i = 0; i < 4; i++) {\n    this._edgeNormals[0][i] = Cartesian3.negate(\n      this._edgeNormals[0][i],\n      this._edgeNormals[0][i]\n    );\n  }\n\n  this._edgeNormals[1] = computeEdgeNormals(\n    boundingPlanes[1],\n    vertices.slice(4, 8)\n  );\n  for (i = 0; i < 4; i++) {\n    // For each plane, iterate through the vertices in CCW order.\n    this._edgeNormals[2 + i] = computeEdgeNormals(boundingPlanes[2 + i], [\n      vertices[i % 4],\n      vertices[(i + 1) % 4],\n      vertices[4 + ((i + 1) % 4)],\n      vertices[4 + i],\n    ]);\n  }\n\n  this._planeVertices = [\n    this._vertices.slice(0, 4),\n    this._vertices.slice(4, 8),\n  ];\n  for (i = 0; i < 4; i++) {\n    this._planeVertices.push([\n      this._vertices[i % 4],\n      this._vertices[(i + 1) % 4],\n      this._vertices[4 + ((i + 1) % 4)],\n      this._vertices[4 + i],\n    ]);\n  }\n\n  const center = s2Cell.getCenter();\n  centerCartographicScratch = ellipsoid.cartesianToCartographic(\n    center,\n    centerCartographicScratch\n  );\n  centerCartographicScratch.height = (maximumHeight + minimumHeight) / 2;\n  this.center = ellipsoid.cartographicToCartesian(\n    centerCartographicScratch,\n    center\n  );\n\n  this._boundingSphere = BoundingSphere.fromPoints(vertices);\n}\n\nconst centerGeodeticNormalScratch = new Cartesian3();\nconst topCartographicScratch = new Cartographic();\nconst topScratch = new Cartesian3();\nconst vertexCartographicScratch = new Cartographic();\nconst vertexScratch = new Cartesian3();\nconst vertexGeodeticNormalScratch = new Cartesian3();\nconst sideNormalScratch = new Cartesian3();\nconst sideScratch = new Cartesian3();\n/**\n * Computes bounding planes of the kDOP.\n * @private\n */\nfunction computeBoundingPlanes(\n  s2Cell,\n  minimumHeight,\n  maximumHeight,\n  ellipsoid\n) {\n  const planes = new Array(6);\n  const centerPoint = s2Cell.getCenter();\n\n  // Compute top plane.\n  // - Get geodetic surface normal at the center of the S2 cell.\n  // - Get center point at maximum height of bounding volume.\n  // - Create top plane from surface normal and top point.\n  const centerSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n    centerPoint,\n    centerGeodeticNormalScratch\n  );\n  const topCartographic = ellipsoid.cartesianToCartographic(\n    centerPoint,\n    topCartographicScratch\n  );\n  topCartographic.height = maximumHeight;\n  const top = ellipsoid.cartographicToCartesian(topCartographic, topScratch);\n  const topPlane = Plane.fromPointNormal(top, centerSurfaceNormal);\n  planes[0] = topPlane;\n\n  // Compute bottom plane.\n  // - Iterate through bottom vertices\n  //   - Get distance from vertex to top plane\n  // - Find longest distance from vertex to top plane\n  // - Translate top plane by the distance\n  let maxDistance = 0;\n  let i;\n  const vertices = [];\n  let vertex, vertexCartographic;\n  for (i = 0; i < 4; i++) {\n    vertex = s2Cell.getVertex(i);\n    vertices[i] = vertex;\n    vertexCartographic = ellipsoid.cartesianToCartographic(\n      vertex,\n      vertexCartographicScratch\n    );\n    vertexCartographic.height = minimumHeight;\n    const distance = Plane.getPointDistance(\n      topPlane,\n      ellipsoid.cartographicToCartesian(vertexCartographic, vertexScratch)\n    );\n    if (distance < maxDistance) {\n      maxDistance = distance;\n    }\n  }\n  const bottomPlane = Plane.clone(topPlane);\n  // Negate the normal of the bottom plane since we want all normals to point \"outwards\".\n  bottomPlane.normal = Cartesian3.negate(\n    bottomPlane.normal,\n    bottomPlane.normal\n  );\n  bottomPlane.distance = bottomPlane.distance * -1 + maxDistance;\n  planes[1] = bottomPlane;\n\n  // Compute side planes.\n  // - Iterate through vertices (in CCW order, by default)\n  //   - Get a vertex and another vertex adjacent to it.\n  //   - Compute geodetic surface normal at one vertex.\n  //   - Compute vector between vertices.\n  //   - Compute normal of side plane. (cross product of top dir and side dir)\n  for (i = 0; i < 4; i++) {\n    vertex = vertices[i];\n    const adjacentVertex = vertices[(i + 1) % 4];\n    const geodeticNormal = ellipsoid.geodeticSurfaceNormal(\n      vertex,\n      vertexGeodeticNormalScratch\n    );\n    const side = Cartesian3.subtract(adjacentVertex, vertex, sideScratch);\n    let sideNormal = Cartesian3.cross(side, geodeticNormal, sideNormalScratch);\n    sideNormal = Cartesian3.normalize(sideNormal, sideNormal);\n    planes[2 + i] = Plane.fromPointNormal(vertex, sideNormal);\n  }\n\n  return planes;\n}\n\nlet n0Scratch = new Cartesian3();\nlet n1Scratch = new Cartesian3();\nlet n2Scratch = new Cartesian3();\nlet x0Scratch = new Cartesian3();\nlet x1Scratch = new Cartesian3();\nlet x2Scratch = new Cartesian3();\nconst t0Scratch = new Cartesian3();\nconst t1Scratch = new Cartesian3();\nconst t2Scratch = new Cartesian3();\nlet f0Scratch = new Cartesian3();\nlet f1Scratch = new Cartesian3();\nlet f2Scratch = new Cartesian3();\nlet sScratch = new Cartesian3();\nconst matrixScratch = new Matrix3();\n/**\n * Computes intersection of 3 planes.\n * @private\n */\nfunction computeIntersection(p0, p1, p2) {\n  n0Scratch = p0.normal;\n  n1Scratch = p1.normal;\n  n2Scratch = p2.normal;\n\n  x0Scratch = Cartesian3.multiplyByScalar(p0.normal, -p0.distance, x0Scratch);\n  x1Scratch = Cartesian3.multiplyByScalar(p1.normal, -p1.distance, x1Scratch);\n  x2Scratch = Cartesian3.multiplyByScalar(p2.normal, -p2.distance, x2Scratch);\n\n  f0Scratch = Cartesian3.multiplyByScalar(\n    Cartesian3.cross(n1Scratch, n2Scratch, t0Scratch),\n    Cartesian3.dot(x0Scratch, n0Scratch),\n    f0Scratch\n  );\n  f1Scratch = Cartesian3.multiplyByScalar(\n    Cartesian3.cross(n2Scratch, n0Scratch, t1Scratch),\n    Cartesian3.dot(x1Scratch, n1Scratch),\n    f1Scratch\n  );\n  f2Scratch = Cartesian3.multiplyByScalar(\n    Cartesian3.cross(n0Scratch, n1Scratch, t2Scratch),\n    Cartesian3.dot(x2Scratch, n2Scratch),\n    f2Scratch\n  );\n\n  matrixScratch[0] = n0Scratch.x;\n  matrixScratch[1] = n1Scratch.x;\n  matrixScratch[2] = n2Scratch.x;\n  matrixScratch[3] = n0Scratch.y;\n  matrixScratch[4] = n1Scratch.y;\n  matrixScratch[5] = n2Scratch.y;\n  matrixScratch[6] = n0Scratch.z;\n  matrixScratch[7] = n1Scratch.z;\n  matrixScratch[8] = n2Scratch.z;\n  const determinant = Matrix3.determinant(matrixScratch);\n  sScratch = Cartesian3.add(f0Scratch, f1Scratch, sScratch);\n  sScratch = Cartesian3.add(sScratch, f2Scratch, sScratch);\n  return new Cartesian3(\n    sScratch.x / determinant,\n    sScratch.y / determinant,\n    sScratch.z / determinant\n  );\n}\n/**\n * Compute the vertices of the kDOP.\n * @private\n */\nfunction computeVertices(boundingPlanes) {\n  const vertices = new Array(8);\n  for (let i = 0; i < 4; i++) {\n    // Vertices on the top plane.\n    vertices[i] = computeIntersection(\n      boundingPlanes[0],\n      boundingPlanes[2 + ((i + 3) % 4)],\n      boundingPlanes[2 + (i % 4)]\n    );\n    // Vertices on the bottom plane.\n    vertices[i + 4] = computeIntersection(\n      boundingPlanes[1],\n      boundingPlanes[2 + ((i + 3) % 4)],\n      boundingPlanes[2 + (i % 4)]\n    );\n  }\n  return vertices;\n}\n\nlet edgeScratch = new Cartesian3();\nlet edgeNormalScratch = new Cartesian3();\n/**\n * Compute edge normals on a plane.\n * @private\n */\nfunction computeEdgeNormals(plane, vertices) {\n  const edgeNormals = [];\n  for (let i = 0; i < 4; i++) {\n    edgeScratch = Cartesian3.subtract(\n      vertices[(i + 1) % 4],\n      vertices[i],\n      edgeScratch\n    );\n    edgeNormalScratch = Cartesian3.cross(\n      plane.normal,\n      edgeScratch,\n      edgeNormalScratch\n    );\n    edgeNormalScratch = Cartesian3.normalize(\n      edgeNormalScratch,\n      edgeNormalScratch\n    );\n    edgeNormals[i] = Cartesian3.clone(edgeNormalScratch);\n  }\n  return edgeNormals;\n}\n\nObject.defineProperties(TileBoundingS2Cell.prototype, {\n  /**\n   * The underlying bounding volume.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this;\n    },\n  },\n  /**\n   * The underlying bounding sphere.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\nconst facePointScratch = new Cartesian3();\n/**\n * The distance to point check for this kDOP involves checking the signed distance of the point to each bounding\n * plane. A plane qualifies for a distance check if the point being tested against is in the half-space in the direction\n * of the normal i.e. if the signed distance of the point from the plane is greater than 0.\n *\n * There are 4 possible cases for a point if it is outside the polyhedron:\n *\n *   \\     X     /     X \\           /       \\           /       \\           /\n * ---\\---------/---   ---\\---------/---   ---X---------/---   ---\\---------/---\n *     \\       /           \\       /           \\       /           \\       /\n *   ---\\-----/---       ---\\-----/---       ---\\-----/---       ---\\-----/---\n *       \\   /               \\   /               \\   /               \\   /\n *                                                                    \\ /\n *                                                                     \\\n *                                                                    / \\\n *                                                                   / X \\\n *\n *         I                  II                  III                 IV\n *\n * Case I: There is only one plane selected.\n * In this case, we project the point onto the plane and do a point polygon distance check to find the closest point on the polygon.\n * The point may lie inside the \"face\" of the polygon or outside. If it is outside, we need to determine which edges to test against.\n *\n * Case II: There are two planes selected.\n * In this case, the point will lie somewhere on the line created at the intersection of the selected planes or one of the planes.\n *\n * Case III: There are three planes selected.\n * In this case, the point will lie on the vertex, at the intersection of the selected planes.\n *\n * Case IV: There are more than three planes selected.\n * Since we are on an ellipsoid, this will only happen in the bottom plane, which is what we will use for the distance test.\n */\nTileBoundingS2Cell.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  const point = frameState.camera.positionWC;\n\n  const selectedPlaneIndices = [];\n  const vertices = [];\n  let edgeNormals;\n\n  if (Plane.getPointDistance(this._boundingPlanes[0], point) > 0) {\n    selectedPlaneIndices.push(0);\n    vertices.push(this._planeVertices[0]);\n    edgeNormals = this._edgeNormals[0];\n  } else if (Plane.getPointDistance(this._boundingPlanes[1], point) > 0) {\n    selectedPlaneIndices.push(1);\n    vertices.push(this._planeVertices[1]);\n    edgeNormals = this._edgeNormals[1];\n  }\n\n  let i;\n  let sidePlaneIndex;\n  for (i = 0; i < 4; i++) {\n    sidePlaneIndex = 2 + i;\n    if (\n      Plane.getPointDistance(this._boundingPlanes[sidePlaneIndex], point) > 0\n    ) {\n      selectedPlaneIndices.push(sidePlaneIndex);\n      // Store vertices in CCW order.\n      vertices.push(this._planeVertices[sidePlaneIndex]);\n      edgeNormals = this._edgeNormals[sidePlaneIndex];\n    }\n  }\n\n  // Check if inside all planes.\n  if (selectedPlaneIndices.length === 0) {\n    return 0.0;\n  }\n\n  // We use the skip variable when the side plane indices are non-consecutive.\n  let facePoint;\n  let selectedPlane;\n  if (selectedPlaneIndices.length === 1) {\n    // Handles Case I\n    selectedPlane = this._boundingPlanes[selectedPlaneIndices[0]];\n    facePoint = closestPointPolygon(\n      Plane.projectPointOntoPlane(selectedPlane, point, facePointScratch),\n      vertices[0],\n      selectedPlane,\n      edgeNormals\n    );\n\n    return Cartesian3.distance(facePoint, point);\n  } else if (selectedPlaneIndices.length === 2) {\n    // Handles Case II\n    // Since we are on the ellipsoid, the dihedral angle between a top plane and a side plane\n    // will always be acute, so we can do a faster check there.\n    if (selectedPlaneIndices[0] === 0) {\n      const edge = [\n        this._vertices[\n          4 * selectedPlaneIndices[0] + (selectedPlaneIndices[1] - 2)\n        ],\n        this._vertices[\n          4 * selectedPlaneIndices[0] + ((selectedPlaneIndices[1] - 2 + 1) % 4)\n        ],\n      ];\n      facePoint = closestPointLineSegment(point, edge[0], edge[1]);\n      return Cartesian3.distance(facePoint, point);\n    }\n    let minimumDistance = Number.MAX_VALUE;\n    let distance;\n    for (i = 0; i < 2; i++) {\n      selectedPlane = this._boundingPlanes[selectedPlaneIndices[i]];\n      facePoint = closestPointPolygon(\n        Plane.projectPointOntoPlane(selectedPlane, point, facePointScratch),\n        vertices[i],\n        selectedPlane,\n        this._edgeNormals[selectedPlaneIndices[i]]\n      );\n\n      distance = Cartesian3.distanceSquared(facePoint, point);\n      if (distance < minimumDistance) {\n        minimumDistance = distance;\n      }\n    }\n    return Math.sqrt(minimumDistance);\n  } else if (selectedPlaneIndices.length > 3) {\n    // Handles Case IV\n    facePoint = closestPointPolygon(\n      Plane.projectPointOntoPlane(\n        this._boundingPlanes[1],\n        point,\n        facePointScratch\n      ),\n      this._planeVertices[1],\n      this._boundingPlanes[1],\n      this._edgeNormals[1]\n    );\n    return Cartesian3.distance(facePoint, point);\n  }\n\n  // Handles Case III\n  const skip =\n    selectedPlaneIndices[1] === 2 && selectedPlaneIndices[2] === 5 ? 0 : 1;\n\n  // Vertex is on top plane.\n  if (selectedPlaneIndices[0] === 0) {\n    return Cartesian3.distance(\n      point,\n      this._vertices[(selectedPlaneIndices[1] - 2 + skip) % 4]\n    );\n  }\n\n  // Vertex is on bottom plane.\n  return Cartesian3.distance(\n    point,\n    this._vertices[4 + ((selectedPlaneIndices[1] - 2 + skip) % 4)]\n  );\n};\n\nconst dScratch = new Cartesian3();\nconst pL0Scratch = new Cartesian3();\n/**\n * Finds point on a line segment closest to a given point.\n * @private\n */\nfunction closestPointLineSegment(p, l0, l1) {\n  const d = Cartesian3.subtract(l1, l0, dScratch);\n  const pL0 = Cartesian3.subtract(p, l0, pL0Scratch);\n  let t = Cartesian3.dot(d, pL0);\n\n  if (t <= 0) {\n    return l0;\n  }\n\n  const dMag = Cartesian3.dot(d, d);\n  if (t >= dMag) {\n    return l1;\n  }\n\n  t = t / dMag;\n  return new Cartesian3(\n    (1 - t) * l0.x + t * l1.x,\n    (1 - t) * l0.y + t * l1.y,\n    (1 - t) * l0.z + t * l1.z\n  );\n}\n\nconst edgePlaneScratch = new Plane(Cartesian3.UNIT_X, 0.0);\n/**\n * Finds closes point on the polygon, created by the given vertices, from\n * a point. The test point and the polygon are all on the same plane.\n * @private\n */\nfunction closestPointPolygon(p, vertices, plane, edgeNormals) {\n  let minDistance = Number.MAX_VALUE;\n  let distance;\n  let closestPoint;\n  let closestPointOnEdge;\n\n  for (let i = 0; i < vertices.length; i++) {\n    const edgePlane = Plane.fromPointNormal(\n      vertices[i],\n      edgeNormals[i],\n      edgePlaneScratch\n    );\n    const edgePlaneDistance = Plane.getPointDistance(edgePlane, p);\n\n    // Skip checking against the edge if the point is not in the half-space that the\n    // edgePlane's normal points towards i.e. if the edgePlane is facing away from the point.\n    if (edgePlaneDistance < 0) {\n      continue;\n    }\n\n    closestPointOnEdge = closestPointLineSegment(\n      p,\n      vertices[i],\n      vertices[(i + 1) % 4]\n    );\n\n    distance = Cartesian3.distance(p, closestPointOnEdge);\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestPoint = closestPointOnEdge;\n    }\n  }\n\n  if (!defined(closestPoint)) {\n    return p;\n  }\n  return closestPoint;\n}\n\n/**\n * Determines which side of a plane this volume is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire volume is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire volume is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the volume\n *                      intersects the plane.\n */\nTileBoundingS2Cell.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  let plusCount = 0;\n  let negCount = 0;\n  for (let i = 0; i < this._vertices.length; i++) {\n    const distanceToPlane =\n      Cartesian3.dot(plane.normal, this._vertices[i]) + plane.distance;\n    if (distanceToPlane < 0) {\n      negCount++;\n    } else {\n      plusCount++;\n    }\n  }\n\n  if (plusCount === this._vertices.length) {\n    return Intersect.INSIDE;\n  } else if (negCount === this._vertices.length) {\n    return Intersect.OUTSIDE;\n  }\n  return Intersect.INTERSECTING;\n};\n\n/**\n * Creates a debug primitive that shows the outline of the tile bounding\n * volume.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileBoundingS2Cell.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  const modelMatrix = new Matrix4.clone(Matrix4.IDENTITY);\n  const topPlanePolygon = new CoplanarPolygonOutlineGeometry({\n    polygonHierarchy: {\n      positions: this._planeVertices[0],\n    },\n  });\n  const topPlaneGeometry = CoplanarPolygonOutlineGeometry.createGeometry(\n    topPlanePolygon\n  );\n  const topPlaneInstance = new GeometryInstance({\n    geometry: topPlaneGeometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  const bottomPlanePolygon = new CoplanarPolygonOutlineGeometry({\n    polygonHierarchy: {\n      positions: this._planeVertices[1],\n    },\n  });\n  const bottomPlaneGeometry = CoplanarPolygonOutlineGeometry.createGeometry(\n    bottomPlanePolygon\n  );\n  const bottomPlaneInstance = new GeometryInstance({\n    geometry: bottomPlaneGeometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  const sideInstances = [];\n  for (let i = 0; i < 4; i++) {\n    const sidePlanePolygon = new CoplanarPolygonOutlineGeometry({\n      polygonHierarchy: {\n        positions: this._planeVertices[2 + i],\n      },\n    });\n    const sidePlaneGeometry = CoplanarPolygonOutlineGeometry.createGeometry(\n      sidePlanePolygon\n    );\n    sideInstances[i] = new GeometryInstance({\n      geometry: sidePlaneGeometry,\n      id: \"outline\",\n      modelMatrix: modelMatrix,\n      attributes: {\n        color: ColorGeometryInstanceAttribute.fromColor(color),\n      },\n    });\n  }\n\n  return new Primitive({\n    geometryInstances: [\n      sideInstances[0],\n      sideInstances[1],\n      sideInstances[2],\n      sideInstances[3],\n      bottomPlaneInstance,\n      topPlaneInstance,\n    ],\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\n\nexport default TileBoundingS2Cell;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\n\n/**\n * A tile bounding volume specified as a sphere.\n * @alias TileBoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {Number} [radius=0.0] The radius of the bounding sphere.\n *\n * @private\n */\nfunction TileBoundingSphere(center, radius) {\n  if (radius === 0) {\n    radius = CesiumMath.EPSILON7;\n  }\n  this._boundingSphere = new BoundingSphere(center, radius);\n}\n\nObject.defineProperties(TileBoundingSphere.prototype, {\n  /**\n   * The center of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  center: {\n    get: function () {\n      return this._boundingSphere.center;\n    },\n  },\n\n  /**\n   * The radius of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  radius: {\n    get: function () {\n      return this._boundingSphere.radius;\n    },\n  },\n\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\n/**\n * Computes the distance between this bounding sphere and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {Number} The distance between the camera and the bounding sphere in meters. Returns 0 if the camera is inside the bounding volume.\n *\n */\nTileBoundingSphere.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n  const boundingSphere = this._boundingSphere;\n  return Math.max(\n    0.0,\n    Cartesian3.distance(boundingSphere.center, frameState.camera.positionWC) -\n      boundingSphere.radius\n  );\n};\n\n/**\n * Determines which side of a plane this sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nTileBoundingSphere.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return BoundingSphere.intersectPlane(this._boundingSphere, plane);\n};\n\n/**\n * Update the bounding sphere after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the bounding sphere.\n * @param {Number} radius The radius of the bounding sphere.\n */\nTileBoundingSphere.prototype.update = function (center, radius) {\n  Cartesian3.clone(center, this._boundingSphere.center);\n  this._boundingSphere.radius = radius;\n};\n\n/**\n * Creates a debug primitive that shows the outline of the sphere.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileBoundingSphere.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n  const geometry = new SphereOutlineGeometry({\n    radius: this.radius,\n  });\n  const modelMatrix = Matrix4.fromTranslation(\n    this.center,\n    new Matrix4.clone(Matrix4.IDENTITY)\n  );\n  const instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\nexport default TileBoundingSphere;\n","import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * Defines a bounding volume for a tile. This type describes an interface\n * and is not intended to be instantiated directly.\n *\n * @alias TileBoundingVolume\n * @constructor\n *\n * @see TileBoundingRegion\n * @see TileBoundingSphere\n * @see TileOrientedBoundingBox\n *\n * @private\n */\nfunction TileBoundingVolume() {}\n\n/**\n * The underlying bounding volume.\n *\n * @type {Object}\n * @readonly\n */\nTileBoundingVolume.prototype.boundingVolume = undefined;\n\n/**\n * The underlying bounding sphere.\n *\n * @type {BoundingSphere}\n * @readonly\n */\nTileBoundingVolume.prototype.boundingSphere = undefined;\n\n/**\n * Calculates the distance between the tile and the camera.\n *\n * @param {FrameState} frameState The frame state.\n * @return {Number} The distance between the tile and the camera, in meters.\n *                  Returns 0.0 if the camera is inside the tile.\n */\nTileBoundingVolume.prototype.distanceToCamera = function (frameState) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Determines which side of a plane this volume is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire volume is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire volume is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the volume\n *                      intersects the plane.\n */\nTileBoundingVolume.prototype.intersectPlane = function (plane) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Creates a debug primitive that shows the outline of the tile bounding\n * volume.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileBoundingVolume.prototype.createDebugVolume = function (color) {\n  DeveloperError.throwInstantiationError();\n};\nexport default TileBoundingVolume;\n","import Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\n\n/**\n * @typedef {Object} TileCoordinatesImageryProvider.ConstructorOptions\n *\n * Initialization options for the TileCoordinatesImageryProvider constructor\n *\n * @property {TilingScheme} [tilingScheme=new GeographicTilingScheme()] The tiling scheme for which to draw tiles.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n *                    parameter is specified, the WGS84 ellipsoid is used.\n * @property {Color} [color=Color.YELLOW] The color to draw the tile box and label.\n * @property {Number} [tileWidth=256] The width of the tile for level-of-detail selection purposes.\n * @property {Number} [tileHeight=256] The height of the tile for level-of-detail selection purposes.\n */\n\n/**\n * An {@link ImageryProvider} that draws a box around every rendered tile in the tiling scheme, and draws\n * a label inside it indicating the X, Y, Level coordinates of the tile.  This is mostly useful for\n * debugging terrain and imagery rendering problems.\n *\n * @alias TileCoordinatesImageryProvider\n * @constructor\n *\n * @param {TileCoordinatesImageryProvider.ConstructorOptions} [options] Object describing initialization options\n */\nfunction TileCoordinatesImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._tilingScheme = defined(options.tilingScheme)\n    ? options.tilingScheme\n    : new GeographicTilingScheme({ ellipsoid: options.ellipsoid });\n  this._color = defaultValue(options.color, Color.YELLOW);\n  this._errorEvent = new Event();\n  this._tileWidth = defaultValue(options.tileWidth, 256);\n  this._tileHeight = defaultValue(options.tileHeight, 256);\n  this._readyPromise = Promise.resolve(true);\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n}\n\nObject.defineProperties(TileCoordinatesImageryProvider.prototype, {\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._tilingScheme.rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return true;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link TileCoordinatesImageryProvider#ready} returns true.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage\n   * and texture upload time.\n   * @memberof TileCoordinatesImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return true;\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nTileCoordinatesImageryProvider.prototype.getTileCredits = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<HTMLCanvasElement>} The resolved image as a Canvas DOM object.\n */\nTileCoordinatesImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 256;\n  canvas.height = 256;\n  const context = canvas.getContext(\"2d\");\n\n  const cssColor = this._color.toCssColorString();\n\n  context.strokeStyle = cssColor;\n  context.lineWidth = 2;\n  context.strokeRect(1, 1, 255, 255);\n\n  context.font = \"bold 25px Arial\";\n  context.textAlign = \"center\";\n  context.fillStyle = cssColor;\n  context.fillText(`L: ${level}`, 124, 86);\n  context.fillText(`X: ${x}`, 124, 136);\n  context.fillText(`Y: ${y}`, 124, 186);\n\n  return Promise.resolve(canvas);\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {undefined} Undefined since picking is not supported.\n */\nTileCoordinatesImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return undefined;\n};\nexport default TileCoordinatesImageryProvider;\n","import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * A policy for discarding tile images according to some criteria.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TileDiscardPolicy\n * @constructor\n *\n * @see DiscardMissingTileImagePolicy\n * @see NeverTileDiscardPolicy\n */\nfunction TileDiscardPolicy(options) {\n  DeveloperError.throwInstantiationError();\n}\n\n/**\n * Determines if the discard policy is ready to process images.\n * @function\n *\n * @returns {Boolean} True if the discard policy is ready to process images; otherwise, false.\n */\nTileDiscardPolicy.prototype.isReady = DeveloperError.throwInstantiationError;\n\n/**\n * Given a tile image, decide whether to discard that image.\n * @function\n *\n * @param {HTMLImageElement} image An image to test.\n * @returns {Boolean} True if the image should be discarded; otherwise, false.\n */\nTileDiscardPolicy.prototype.shouldDiscardImage =\n  DeveloperError.throwInstantiationError;\nexport default TileDiscardPolicy;\n","import defined from \"../Core/defined.js\";\nimport ImageryState from \"./ImageryState.js\";\n\n/**\n * The assocation between a terrain tile and an imagery tile.\n *\n * @alias TileImagery\n * @private\n *\n * @param {Imagery} imagery The imagery tile.\n * @param {Cartesian4} textureCoordinateRectangle The texture rectangle of the tile that is covered\n *        by the imagery, where X=west, Y=south, Z=east, W=north.\n * @param {Boolean} useWebMercatorT true to use the Web Mercator texture coordinates for this imagery tile.\n */\nfunction TileImagery(imagery, textureCoordinateRectangle, useWebMercatorT) {\n  this.readyImagery = undefined;\n  this.loadingImagery = imagery;\n  this.textureCoordinateRectangle = textureCoordinateRectangle;\n  this.textureTranslationAndScale = undefined;\n  this.useWebMercatorT = useWebMercatorT;\n}\n\n/**\n * Frees the resources held by this instance.\n */\nTileImagery.prototype.freeResources = function () {\n  if (defined(this.readyImagery)) {\n    this.readyImagery.releaseReference();\n  }\n\n  if (defined(this.loadingImagery)) {\n    this.loadingImagery.releaseReference();\n  }\n};\n\n/**\n * Processes the load state machine for this instance.\n *\n * @param {Tile} tile The tile to which this instance belongs.\n * @param {FrameState} frameState The frameState.\n * @param {Boolean} skipLoading True to skip loading, e.g. new requests, creating textures. This function will\n *                  still synchronously process imagery that's already mostly ready to go, e.g. use textures\n *                  already loaded on ancestor tiles.\n * @returns {Boolean} True if this instance is done loading; otherwise, false.\n */\nTileImagery.prototype.processStateMachine = function (\n  tile,\n  frameState,\n  skipLoading\n) {\n  const loadingImagery = this.loadingImagery;\n  const imageryLayer = loadingImagery.imageryLayer;\n\n  loadingImagery.processStateMachine(\n    frameState,\n    !this.useWebMercatorT,\n    skipLoading\n  );\n\n  if (loadingImagery.state === ImageryState.READY) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n    this.readyImagery = this.loadingImagery;\n    this.loadingImagery = undefined;\n    this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(\n      tile,\n      this\n    );\n    return true; // done loading\n  }\n\n  // Find some ancestor imagery we can use while this imagery is still loading.\n  let ancestor = loadingImagery.parent;\n  let closestAncestorThatNeedsLoading;\n  while (\n    defined(ancestor) &&\n    (ancestor.state !== ImageryState.READY ||\n      (!this.useWebMercatorT && !defined(ancestor.texture)))\n  ) {\n    if (\n      ancestor.state !== ImageryState.FAILED &&\n      ancestor.state !== ImageryState.INVALID\n    ) {\n      // ancestor is still loading\n      closestAncestorThatNeedsLoading =\n        closestAncestorThatNeedsLoading || ancestor;\n    }\n    ancestor = ancestor.parent;\n  }\n\n  if (this.readyImagery !== ancestor) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n\n    this.readyImagery = ancestor;\n\n    if (defined(ancestor)) {\n      ancestor.addReference();\n      this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(\n        tile,\n        this\n      );\n    }\n  }\n\n  if (\n    loadingImagery.state === ImageryState.FAILED ||\n    loadingImagery.state === ImageryState.INVALID\n  ) {\n    // The imagery tile is failed or invalid, so we'd like to use an ancestor instead.\n    if (defined(closestAncestorThatNeedsLoading)) {\n      // Push the ancestor's load process along a bit.  This is necessary because some ancestor imagery\n      // tiles may not be attached directly to a terrain tile.  Such tiles will never load if\n      // we don't do it here.\n      closestAncestorThatNeedsLoading.processStateMachine(\n        frameState,\n        !this.useWebMercatorT,\n        skipLoading\n      );\n      return false; // not done loading\n    }\n    // This imagery tile is failed or invalid, and we have the \"best available\" substitute.\n    return true; // done loading\n  }\n\n  return false; // not done loading\n};\nexport default TileImagery;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\n\n/**\n * @typedef {Object} TileMapServiceImageryProvider.ConstructorOptions\n *\n * Initialization options for the TileMapServiceImageryProvider constructor\n *\n * @property {Resource|String|Promise<Resource>|Promise<String>} [url='.'] Path to image tiles on server.\n * @property {String} [fileExtension='png'] The file extension for images on the server.\n * @property {Credit|String} [credit=''] A credit for the data source, which is displayed on the canvas.\n * @property {Number} [minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @property {Number} [maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.\n * @property {Rectangle} [rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @property {TilingScheme} [tilingScheme] The tiling scheme specifying how the ellipsoidal\n * surface is broken into tiles.  If this parameter is not provided, a {@link WebMercatorTilingScheme}\n * is used.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n *                    parameter is specified, the WGS84 ellipsoid is used.\n * @property {Number} [tileWidth=256] Pixel width of image tiles.\n * @property {Number} [tileHeight=256] Pixel height of image tiles.\n * @property {Boolean} [flipXY] Older versions of gdal2tiles.py flipped X and Y values in tilemapresource.xml.\n * Specifying this option will do the same, allowing for loading of these incorrect tilesets.\n */\n\n/**\n * An imagery provider that provides tiled imagery as generated by\n * {@link http://www.maptiler.org/|MapTiler}, {@link http://www.klokan.cz/projects/gdal2tiles/|GDAL2Tiles}, etc.\n *\n * @alias TileMapServiceImageryProvider\n * @constructor\n * @extends UrlTemplateImageryProvider\n *\n * @param {TileMapServiceImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n *\n * @example\n * const tms = new Cesium.TileMapServiceImageryProvider({\n *    url : '../images/cesium_maptiler/Cesium_Logo_Color',\n *    fileExtension: 'png',\n *    maximumLevel: 4,\n *    rectangle: new Cesium.Rectangle(\n *        Cesium.Math.toRadians(-120.0),\n *        Cesium.Math.toRadians(20.0),\n *        Cesium.Math.toRadians(-60.0),\n *        Cesium.Math.toRadians(40.0))\n * });\n */\nfunction TileMapServiceImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const deferred = defer();\n  UrlTemplateImageryProvider.call(this, deferred.promise);\n\n  this._tmsResource = undefined;\n  this._xmlResource = undefined;\n  this._options = options;\n  this._deferred = deferred;\n  this._metadataError = undefined;\n\n  this._metadataSuccess = this._metadataSuccess.bind(this);\n  this._metadataFailure = this._metadataFailure.bind(this);\n  this._requestMetadata = this._requestMetadata.bind(this);\n\n  let resource;\n  const that = this;\n  Promise.resolve(options.url)\n    .then(function (url) {\n      resource = Resource.createIfNeeded(url);\n      resource.appendForwardSlash();\n\n      that._tmsResource = resource;\n      that._xmlResource = resource.getDerivedResource({\n        url: \"tilemapresource.xml\",\n      });\n\n      that._requestMetadata();\n    })\n    .catch(function (e) {\n      deferred.reject(e);\n    });\n}\n\nif (defined(Object.create)) {\n  TileMapServiceImageryProvider.prototype = Object.create(\n    UrlTemplateImageryProvider.prototype\n  );\n  TileMapServiceImageryProvider.prototype.constructor = TileMapServiceImageryProvider;\n}\n\nTileMapServiceImageryProvider.prototype._requestMetadata = function () {\n  // Try to load remaining parameters from XML\n  this._xmlResource\n    .fetchXML()\n    .then(this._metadataSuccess)\n    .catch(this._metadataFailure);\n};\n\n/**\n * Mutates the properties of a given rectangle so it does not extend outside of the given tiling scheme's rectangle\n * @private\n */\nfunction confineRectangleToTilingScheme(rectangle, tilingScheme) {\n  if (rectangle.west < tilingScheme.rectangle.west) {\n    rectangle.west = tilingScheme.rectangle.west;\n  }\n  if (rectangle.east > tilingScheme.rectangle.east) {\n    rectangle.east = tilingScheme.rectangle.east;\n  }\n  if (rectangle.south < tilingScheme.rectangle.south) {\n    rectangle.south = tilingScheme.rectangle.south;\n  }\n  if (rectangle.north > tilingScheme.rectangle.north) {\n    rectangle.north = tilingScheme.rectangle.north;\n  }\n  return rectangle;\n}\n\nfunction calculateSafeMinimumDetailLevel(\n  tilingScheme,\n  rectangle,\n  minimumLevel\n) {\n  // Check the number of tiles at the minimum level.  If it's more than four,\n  // try requesting the lower levels anyway, because starting at the higher minimum\n  // level will cause too many tiles to be downloaded and rendered.\n  const swTile = tilingScheme.positionToTileXY(\n    Rectangle.southwest(rectangle),\n    minimumLevel\n  );\n  const neTile = tilingScheme.positionToTileXY(\n    Rectangle.northeast(rectangle),\n    minimumLevel\n  );\n  const tileCount =\n    (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);\n  if (tileCount > 4) {\n    return 0;\n  }\n  return minimumLevel;\n}\n\nTileMapServiceImageryProvider.prototype._metadataSuccess = function (xml) {\n  const tileFormatRegex = /tileformat/i;\n  const tileSetRegex = /tileset/i;\n  const tileSetsRegex = /tilesets/i;\n  const bboxRegex = /boundingbox/i;\n  let format, bbox, tilesets;\n  const tilesetsList = []; //list of TileSets\n  const xmlResource = this._xmlResource;\n  let metadataError = this._metadataError;\n  const deferred = this._deferred;\n  const requestMetadata = this._requestMetadata;\n\n  // Allowing options properties (already copied to that) to override XML values\n\n  // Iterate XML Document nodes for properties\n  const nodeList = xml.childNodes[0].childNodes;\n  for (let i = 0; i < nodeList.length; i++) {\n    if (tileFormatRegex.test(nodeList.item(i).nodeName)) {\n      format = nodeList.item(i);\n    } else if (tileSetsRegex.test(nodeList.item(i).nodeName)) {\n      tilesets = nodeList.item(i); // Node list of TileSets\n      const tileSetNodes = nodeList.item(i).childNodes;\n      // Iterate the nodes to find all TileSets\n      for (let j = 0; j < tileSetNodes.length; j++) {\n        if (tileSetRegex.test(tileSetNodes.item(j).nodeName)) {\n          // Add them to tilesets list\n          tilesetsList.push(tileSetNodes.item(j));\n        }\n      }\n    } else if (bboxRegex.test(nodeList.item(i).nodeName)) {\n      bbox = nodeList.item(i);\n    }\n  }\n\n  let message;\n  if (!defined(tilesets) || !defined(bbox)) {\n    message = `Unable to find expected tilesets or bbox attributes in ${xmlResource.url}.`;\n    metadataError = TileProviderError.handleError(\n      metadataError,\n      this,\n      this.errorEvent,\n      message,\n      undefined,\n      undefined,\n      undefined,\n      requestMetadata\n    );\n    if (!metadataError.retry) {\n      deferred.reject(new RuntimeError(message));\n    }\n    this._metadataError = metadataError;\n    return;\n  }\n\n  const options = this._options;\n  const fileExtension = defaultValue(\n    options.fileExtension,\n    format.getAttribute(\"extension\")\n  );\n  const tileWidth = defaultValue(\n    options.tileWidth,\n    parseInt(format.getAttribute(\"width\"), 10)\n  );\n  const tileHeight = defaultValue(\n    options.tileHeight,\n    parseInt(format.getAttribute(\"height\"), 10)\n  );\n  let minimumLevel = defaultValue(\n    options.minimumLevel,\n    parseInt(tilesetsList[0].getAttribute(\"order\"), 10)\n  );\n  const maximumLevel = defaultValue(\n    options.maximumLevel,\n    parseInt(tilesetsList[tilesetsList.length - 1].getAttribute(\"order\"), 10)\n  );\n  const tilingSchemeName = tilesets.getAttribute(\"profile\");\n  let tilingScheme = options.tilingScheme;\n\n  if (!defined(tilingScheme)) {\n    if (\n      tilingSchemeName === \"geodetic\" ||\n      tilingSchemeName === \"global-geodetic\"\n    ) {\n      tilingScheme = new GeographicTilingScheme({\n        ellipsoid: options.ellipsoid,\n      });\n    } else if (\n      tilingSchemeName === \"mercator\" ||\n      tilingSchemeName === \"global-mercator\"\n    ) {\n      tilingScheme = new WebMercatorTilingScheme({\n        ellipsoid: options.ellipsoid,\n      });\n    } else {\n      message = `${xmlResource.url}specifies an unsupported profile attribute, ${tilingSchemeName}.`;\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        this,\n        this.errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestMetadata\n      );\n      if (!metadataError.retry) {\n        deferred.reject(new RuntimeError(message));\n      }\n      this._metadataError = metadataError;\n      return;\n    }\n  }\n\n  // rectangle handling\n  let rectangle = Rectangle.clone(options.rectangle);\n\n  if (!defined(rectangle)) {\n    let sw;\n    let ne;\n    let swXY;\n    let neXY;\n\n    // In older versions of gdal x and y values were flipped, which is why we check for an option to flip\n    // the values here as well. Unfortunately there is no way to autodetect whether flipping is needed.\n    const flipXY = defaultValue(options.flipXY, false);\n    if (flipXY) {\n      swXY = new Cartesian2(\n        parseFloat(bbox.getAttribute(\"miny\")),\n        parseFloat(bbox.getAttribute(\"minx\"))\n      );\n      neXY = new Cartesian2(\n        parseFloat(bbox.getAttribute(\"maxy\")),\n        parseFloat(bbox.getAttribute(\"maxx\"))\n      );\n    } else {\n      swXY = new Cartesian2(\n        parseFloat(bbox.getAttribute(\"minx\")),\n        parseFloat(bbox.getAttribute(\"miny\"))\n      );\n      neXY = new Cartesian2(\n        parseFloat(bbox.getAttribute(\"maxx\")),\n        parseFloat(bbox.getAttribute(\"maxy\"))\n      );\n    }\n\n    // Determine based on the profile attribute if this tileset was generated by gdal2tiles.py, which\n    // uses 'mercator' and 'geodetic' profiles, or by a tool compliant with the TMS standard, which is\n    // 'global-mercator' and 'global-geodetic' profiles. In the gdal2Tiles case, X and Y are always in\n    // geodetic degrees.\n    const isGdal2tiles =\n      tilingSchemeName === \"geodetic\" || tilingSchemeName === \"mercator\";\n    if (\n      tilingScheme.projection instanceof GeographicProjection ||\n      isGdal2tiles\n    ) {\n      sw = Cartographic.fromDegrees(swXY.x, swXY.y);\n      ne = Cartographic.fromDegrees(neXY.x, neXY.y);\n    } else {\n      const projection = tilingScheme.projection;\n      sw = projection.unproject(swXY);\n      ne = projection.unproject(neXY);\n    }\n\n    rectangle = new Rectangle(\n      sw.longitude,\n      sw.latitude,\n      ne.longitude,\n      ne.latitude\n    );\n  }\n\n  // The rectangle must not be outside the bounds allowed by the tiling scheme.\n  rectangle = confineRectangleToTilingScheme(rectangle, tilingScheme);\n  // clamp our minimum detail level to something that isn't going to request a ridiculous number of tiles\n  minimumLevel = calculateSafeMinimumDetailLevel(\n    tilingScheme,\n    rectangle,\n    minimumLevel\n  );\n\n  const templateResource = this._tmsResource.getDerivedResource({\n    url: `{z}/{x}/{reverseY}.${fileExtension}`,\n  });\n\n  deferred.resolve({\n    url: templateResource,\n    tilingScheme: tilingScheme,\n    rectangle: rectangle,\n    tileWidth: tileWidth,\n    tileHeight: tileHeight,\n    minimumLevel: minimumLevel,\n    maximumLevel: maximumLevel,\n    tileDiscardPolicy: options.tileDiscardPolicy,\n    credit: options.credit,\n  });\n};\n\nTileMapServiceImageryProvider.prototype._metadataFailure = function (error) {\n  // Can't load XML, still allow options and defaults\n  const options = this._options;\n  const fileExtension = defaultValue(options.fileExtension, \"png\");\n  const tileWidth = defaultValue(options.tileWidth, 256);\n  const tileHeight = defaultValue(options.tileHeight, 256);\n  const maximumLevel = options.maximumLevel;\n  const tilingScheme = defined(options.tilingScheme)\n    ? options.tilingScheme\n    : new WebMercatorTilingScheme({ ellipsoid: options.ellipsoid });\n\n  let rectangle = defaultValue(options.rectangle, tilingScheme.rectangle);\n  // The rectangle must not be outside the bounds allowed by the tiling scheme.\n  rectangle = confineRectangleToTilingScheme(rectangle, tilingScheme);\n\n  // make sure we use a safe minimum detail level, so we don't request a ridiculous number of tiles\n  const minimumLevel = calculateSafeMinimumDetailLevel(\n    tilingScheme,\n    rectangle,\n    options.minimumLevel\n  );\n\n  const templateResource = this._tmsResource.getDerivedResource({\n    url: `{z}/{x}/{reverseY}.${fileExtension}`,\n  });\n\n  this._deferred.resolve({\n    url: templateResource,\n    tilingScheme: tilingScheme,\n    rectangle: rectangle,\n    tileWidth: tileWidth,\n    tileHeight: tileHeight,\n    minimumLevel: minimumLevel,\n    maximumLevel: maximumLevel,\n    tileDiscardPolicy: options.tileDiscardPolicy,\n    credit: options.credit,\n  });\n};\n\nexport default TileMapServiceImageryProvider;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport MetadataEntity from \"./MetadataEntity.js\";\n\n/**\n * Metadata about a 3D Tile. This represents the tile metadata JSON (3D Tiles 1.1)\n * or the <code>3DTILES_metadata</code> extension on a single {@link Cesium3DTile}\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.tile Either the tile metadata JSON (3D Tiles 1.1), or the extension JSON attached to the tile.\n * @param {MetadataClass} options.class The class that the tile metadata conforms to.\n *\n * @alias TileMetadata\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function TileMetadata(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const tile = options.tile;\n  const metadataClass = options.class;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tile\", tile);\n  Check.typeOf.object(\"options.class\", metadataClass);\n  //>>includeEnd('debug');\n\n  this._class = metadataClass;\n  this._properties = tile.properties;\n  this._extensions = tile.extensions;\n  this._extras = tile.extras;\n}\n\nObject.defineProperties(TileMetadata.prototype, {\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof TileMetadata.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    get: function () {\n      return this._class;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof TileMetadata.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof TileMetadata.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * Returns whether the tile has this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the tile has this property.\n * @private\n */\nTileMetadata.prototype.hasProperty = function (propertyId) {\n  return MetadataEntity.hasProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Returns whether the tile has a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {Boolean} Whether the tile has a property with the given semantic.\n * @private\n */\nTileMetadata.prototype.hasPropertyBySemantic = function (semantic) {\n  return MetadataEntity.hasPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nTileMetadata.prototype.getPropertyIds = function (results) {\n  return MetadataEntity.getPropertyIds(this._properties, this._class, results);\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the tile does not have this property.\n * @private\n */\nTileMetadata.prototype.getProperty = function (propertyId) {\n  return MetadataEntity.getProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nTileMetadata.prototype.setProperty = function (propertyId, value) {\n  return MetadataEntity.setProperty(\n    propertyId,\n    value,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the tile does not have this semantic.\n * @private\n */\nTileMetadata.prototype.getPropertyBySemantic = function (semantic) {\n  return MetadataEntity.getPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nTileMetadata.prototype.setPropertyBySemantic = function (semantic, value) {\n  return MetadataEntity.setPropertyBySemantic(\n    semantic,\n    value,\n    this._properties,\n    this._class\n  );\n};\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\n\nconst scratchU = new Cartesian3();\nconst scratchV = new Cartesian3();\nconst scratchW = new Cartesian3();\nconst scratchCartesian = new Cartesian3();\n\nfunction computeMissingVector(a, b, result) {\n  result = Cartesian3.cross(a, b, result);\n  const magnitude = Cartesian3.magnitude(result);\n  return Cartesian3.multiplyByScalar(\n    result,\n    CesiumMath.EPSILON7 / magnitude,\n    result\n  );\n}\n\nfunction findOrthogonalVector(a, result) {\n  const temp = Cartesian3.normalize(a, scratchCartesian);\n  const b = Cartesian3.equalsEpsilon(\n    temp,\n    Cartesian3.UNIT_X,\n    CesiumMath.EPSILON6\n  )\n    ? Cartesian3.UNIT_Y\n    : Cartesian3.UNIT_X;\n  return computeMissingVector(a, b, result);\n}\n\nfunction checkHalfAxes(halfAxes) {\n  let u = Matrix3.getColumn(halfAxes, 0, scratchU);\n  let v = Matrix3.getColumn(halfAxes, 1, scratchV);\n  let w = Matrix3.getColumn(halfAxes, 2, scratchW);\n\n  const uZero = Cartesian3.equals(u, Cartesian3.ZERO);\n  const vZero = Cartesian3.equals(v, Cartesian3.ZERO);\n  const wZero = Cartesian3.equals(w, Cartesian3.ZERO);\n\n  if (!uZero && !vZero && !wZero) {\n    return halfAxes;\n  }\n  if (uZero && vZero && wZero) {\n    halfAxes[0] = CesiumMath.EPSILON7;\n    halfAxes[4] = CesiumMath.EPSILON7;\n    halfAxes[8] = CesiumMath.EPSILON7;\n    return halfAxes;\n  }\n  if (uZero && !vZero && !wZero) {\n    u = computeMissingVector(v, w, u);\n  } else if (!uZero && vZero && !wZero) {\n    v = computeMissingVector(u, w, v);\n  } else if (!uZero && !vZero && wZero) {\n    w = computeMissingVector(v, u, w);\n  } else if (!uZero) {\n    v = findOrthogonalVector(u, v);\n    w = computeMissingVector(v, u, w);\n  } else if (!vZero) {\n    u = findOrthogonalVector(v, u);\n    w = computeMissingVector(v, u, w);\n  } else if (!wZero) {\n    u = findOrthogonalVector(w, u);\n    v = computeMissingVector(w, u, v);\n  }\n\n  Matrix3.setColumn(halfAxes, 0, u, halfAxes);\n  Matrix3.setColumn(halfAxes, 1, v, halfAxes);\n  Matrix3.setColumn(halfAxes, 2, w, halfAxes);\n\n  return halfAxes;\n}\n\n/**\n * A tile bounding volume specified as an oriented bounding box.\n * @alias TileOrientedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\n * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\n *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                                          cube centered at the origin.\n *\n * @private\n */\nfunction TileOrientedBoundingBox(center, halfAxes) {\n  halfAxes = checkHalfAxes(halfAxes);\n  this._orientedBoundingBox = new OrientedBoundingBox(center, halfAxes);\n  this._boundingSphere = BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox\n  );\n}\n\nObject.defineProperties(TileOrientedBoundingBox.prototype, {\n  /**\n   * The underlying bounding volume.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._orientedBoundingBox;\n    },\n  },\n  /**\n   * The underlying bounding sphere.\n   *\n   * @memberof TileOrientedBoundingBox.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\n/**\n * Computes the distance between this bounding box and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {Number} The distance between the camera and the bounding box in meters. Returns 0 if the camera is inside the bounding volume.\n */\nTileOrientedBoundingBox.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n  return Math.sqrt(\n    this._orientedBoundingBox.distanceSquaredTo(frameState.camera.positionWC)\n  );\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nTileOrientedBoundingBox.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return this._orientedBoundingBox.intersectPlane(plane);\n};\n\n/**\n * Update the bounding box after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the box.\n * @param {Matrix3} halfAxes The three orthogonal half-axes of the bounding box.\n *                           Equivalently, the transformation matrix, to rotate and scale a 2x2x2\n *                           cube centered at the origin.\n */\nTileOrientedBoundingBox.prototype.update = function (center, halfAxes) {\n  Cartesian3.clone(center, this._orientedBoundingBox.center);\n  halfAxes = checkHalfAxes(halfAxes);\n  Matrix3.clone(halfAxes, this._orientedBoundingBox.halfAxes);\n  BoundingSphere.fromOrientedBoundingBox(\n    this._orientedBoundingBox,\n    this._boundingSphere\n  );\n};\n\n/**\n * Creates a debug primitive that shows the outline of the box.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileOrientedBoundingBox.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n\n  const geometry = new BoxOutlineGeometry({\n    // Make a 2x2x2 cube\n    minimum: new Cartesian3(-1.0, -1.0, -1.0),\n    maximum: new Cartesian3(1.0, 1.0, 1.0),\n  });\n  const modelMatrix = Matrix4.fromRotationTranslation(\n    this.boundingVolume.halfAxes,\n    this.boundingVolume.center\n  );\n  const instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\nexport default TileOrientedBoundingBox;\n","import defined from \"../Core/defined.js\";\n\n/**\n * A priority queue of tiles to be replaced, if necessary, to make room for new tiles.  The queue\n * is implemented as a linked list.\n *\n * @alias TileReplacementQueue\n * @private\n */\nfunction TileReplacementQueue() {\n  this.head = undefined;\n  this.tail = undefined;\n  this.count = 0;\n  this._lastBeforeStartOfFrame = undefined;\n}\n\n/**\n * Marks the start of the render frame.  Tiles before (closer to the head) this tile in the\n * list were used last frame and must not be unloaded.\n */\nTileReplacementQueue.prototype.markStartOfRenderFrame = function () {\n  this._lastBeforeStartOfFrame = this.head;\n};\n\n/**\n * Reduces the size of the queue to a specified size by unloading the least-recently used\n * tiles.  Tiles that were used last frame will not be unloaded, even if that puts the number\n * of tiles above the specified maximum.\n *\n * @param {Number} maximumTiles The maximum number of tiles in the queue.\n */\nTileReplacementQueue.prototype.trimTiles = function (maximumTiles) {\n  let tileToTrim = this.tail;\n  let keepTrimming = true;\n  while (\n    keepTrimming &&\n    defined(this._lastBeforeStartOfFrame) &&\n    this.count > maximumTiles &&\n    defined(tileToTrim)\n  ) {\n    // Stop trimming after we process the last tile not used in the\n    // current frame.\n    keepTrimming = tileToTrim !== this._lastBeforeStartOfFrame;\n\n    const previous = tileToTrim.replacementPrevious;\n\n    if (tileToTrim.eligibleForUnloading) {\n      tileToTrim.freeResources();\n      remove(this, tileToTrim);\n    }\n\n    tileToTrim = previous;\n  }\n};\n\nfunction remove(tileReplacementQueue, item) {\n  const previous = item.replacementPrevious;\n  const next = item.replacementNext;\n\n  if (item === tileReplacementQueue._lastBeforeStartOfFrame) {\n    tileReplacementQueue._lastBeforeStartOfFrame = next;\n  }\n\n  if (item === tileReplacementQueue.head) {\n    tileReplacementQueue.head = next;\n  } else {\n    previous.replacementNext = next;\n  }\n\n  if (item === tileReplacementQueue.tail) {\n    tileReplacementQueue.tail = previous;\n  } else {\n    next.replacementPrevious = previous;\n  }\n\n  item.replacementPrevious = undefined;\n  item.replacementNext = undefined;\n\n  --tileReplacementQueue.count;\n}\n\n/**\n * Marks a tile as rendered this frame and moves it before the first tile that was not rendered\n * this frame.\n *\n * @param {TileReplacementQueue} item The tile that was rendered.\n */\nTileReplacementQueue.prototype.markTileRendered = function (item) {\n  const head = this.head;\n  if (head === item) {\n    if (item === this._lastBeforeStartOfFrame) {\n      this._lastBeforeStartOfFrame = item.replacementNext;\n    }\n    return;\n  }\n\n  ++this.count;\n\n  if (!defined(head)) {\n    // no other tiles in the list\n    item.replacementPrevious = undefined;\n    item.replacementNext = undefined;\n    this.head = item;\n    this.tail = item;\n    return;\n  }\n\n  if (defined(item.replacementPrevious) || defined(item.replacementNext)) {\n    // tile already in the list, remove from its current location\n    remove(this, item);\n  }\n\n  item.replacementPrevious = undefined;\n  item.replacementNext = head;\n  head.replacementPrevious = item;\n\n  this.head = item;\n};\nexport default TileReplacementQueue;\n","/**\n * Indicates what happened the last time this tile was visited for selection.\n * @private\n */\nconst TileSelectionResult = {\n  /**\n   * There was no selection result, perhaps because the tile wasn't visited\n   * last frame.\n   */\n  NONE: 0,\n\n  /**\n   * This tile was deemed not visible and culled.\n   */\n  CULLED: 1,\n\n  /**\n   * The tile was selected for rendering.\n   */\n  RENDERED: 2,\n\n  /**\n   * This tile did not meet the required screen-space error and was refined.\n   */\n  REFINED: 3,\n\n  /**\n   * This tile was originally rendered, but it got kicked out of the render list\n   * in favor of an ancestor because it is not yet renderable.\n   */\n  RENDERED_AND_KICKED: 2 | 4,\n\n  /**\n   * This tile was originally refined, but its rendered descendants got kicked out of the\n   * render list in favor of an ancestor because it is not yet renderable.\n   */\n  REFINED_AND_KICKED: 3 | 4,\n\n  /**\n   * This tile was culled because it was not visible, but it still needs to be loaded\n   * and any heights on it need to be updated because the camera's position or the\n   * camera's reference frame's origin falls inside this tile. Loading this tile\n   * could affect the position of the camera if the camera is currently below\n   * terrain or if it is tracking an object whose height is referenced to terrain.\n   * And a change in the camera position may, in turn, affect what is culled.\n   */\n  CULLED_BUT_NEEDED: 1 | 8,\n\n  /**\n   * Determines if a selection result indicates that this tile or its descendants were\n   * kicked from the render list. In other words, if it is <code>RENDERED_AND_KICKED</code>\n   * or <code>REFINED_AND_KICKED</code>.\n   *\n   * @param {TileSelectionResult} value The selection result to test.\n   * @returns {Boolean} true if the tile was kicked, no matter if it was originally rendered or refined.\n   */\n  wasKicked: function (value) {\n    return value >= TileSelectionResult.RENDERED_AND_KICKED;\n  },\n\n  /**\n   * Determines the original selection result prior to being kicked or CULLED_BUT_NEEDED.\n   * If the tile wasn't kicked or CULLED_BUT_NEEDED, the original value is returned.\n   * @param {TileSelectionResult} value The selection result.\n   * @returns {TileSelectionResult} The original selection result prior to kicking.\n   */\n  originalResult: function (value) {\n    return value & 3;\n  },\n\n  /**\n   * Converts this selection result to a kick.\n   * @param {TileSelectionResult} value The original selection result.\n   * @returns {TileSelectionResult} The kicked form of the selection result.\n   */\n  kick: function (value) {\n    return value | 4;\n  },\n};\nexport default TileSelectionResult;\n","/**\n * @private\n */\nconst TileState = {\n  START: 0,\n  LOADING: 1,\n  READY: 2,\n  UPSAMPLED_ONLY: 3,\n};\nexport default Object.freeze(TileState);\n","import destroyObject from \"../Core/destroyObject.js\";\n\n/**\n * Represents content for a tile in a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset whose\n * content points to another 3D Tiles tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Tileset3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Tileset3DTileContent(tileset, tile, resource, json) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this.featurePropertiesDirty = false;\n\n  this._metadata = undefined;\n  this._group = undefined;\n\n  this._readyPromise = initialize(this, json);\n}\n\nObject.defineProperties(Tileset3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\nfunction initialize(content, json) {\n  content._tileset.loadTileset(content._resource, json, content._tile);\n  return Promise.resolve(content);\n}\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Tileset3DTileContent</code>\n * always returns <code>false</code> since a tile of this type does not have any features.\n */\nTileset3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return false;\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Tileset3DTileContent</code>\n * always returns <code>undefined</code> since a tile of this type does not have any features.\n */\nTileset3DTileContent.prototype.getFeature = function (batchId) {\n  return undefined;\n};\n\nTileset3DTileContent.prototype.applyDebugSettings = function (\n  enabled,\n  color\n) {};\n\nTileset3DTileContent.prototype.applyStyle = function (style) {};\n\nTileset3DTileContent.prototype.update = function (tileset, frameState) {};\n\nTileset3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nTileset3DTileContent.prototype.destroy = function () {\n  return destroyObject(this);\n};\nexport default Tileset3DTileContent;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataEntity from \"./MetadataEntity.js\";\n\n/**\n * Metadata about the tileset.\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.tileset The tileset metadata JSON object.\n * @param {MetadataClass} options.class The class that tileset metadata conforms to.\n *\n * @alias TilesetMetadata\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction TilesetMetadata(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const tileset = options.tileset;\n  const metadataClass = options.class;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tileset\", tileset);\n  Check.typeOf.object(\"options.class\", metadataClass);\n  //>>includeEnd('debug');\n\n  const properties = defined(tileset.properties) ? tileset.properties : {};\n\n  this._class = metadataClass;\n  this._properties = properties;\n  this._extras = tileset.extras;\n  this._extensions = tileset.extensions;\n}\n\nObject.defineProperties(TilesetMetadata.prototype, {\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof TilesetMetadata.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    get: function () {\n      return this._class;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof TilesetMetadata.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof TilesetMetadata.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * Returns whether the tileset has this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the tileset has this property.\n * @private\n */\nTilesetMetadata.prototype.hasProperty = function (propertyId) {\n  return MetadataEntity.hasProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Returns whether the tileset has a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {Boolean} Whether the tileset has a property with the given semantic.\n * @private\n */\nTilesetMetadata.prototype.hasPropertyBySemantic = function (semantic) {\n  return MetadataEntity.hasPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nTilesetMetadata.prototype.getPropertyIds = function (results) {\n  return MetadataEntity.getPropertyIds(this._properties, this._class, results);\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the tileset does not have this property.\n * @private\n */\nTilesetMetadata.prototype.getProperty = function (propertyId) {\n  return MetadataEntity.getProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nTilesetMetadata.prototype.setProperty = function (propertyId, value) {\n  return MetadataEntity.setProperty(\n    propertyId,\n    value,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the tileset does not have this semantic.\n * @private\n */\nTilesetMetadata.prototype.getPropertyBySemantic = function (semantic) {\n  return MetadataEntity.getPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nTilesetMetadata.prototype.setPropertyBySemantic = function (semantic, value) {\n  return MetadataEntity.setPropertyBySemantic(\n    semantic,\n    value,\n    this._properties,\n    this._class\n  );\n};\n\nexport default TilesetMetadata;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestType from \"../Core/RequestType.js\";\n\n/**\n * Provides functionality for ImageryProviders that have time dynamic imagery\n *\n * @alias TimeDynamicImagery\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Clock} options.clock A Clock instance that is used when determining the value for the time dimension. Required when <code>options.times</code> is specified.\n * @param {TimeIntervalCollection} options.times TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.\n * @param {Function} options.requestImageFunction A function that will request imagery tiles.\n * @param {Function} options.reloadFunction A function that will be called when all imagery tiles need to be reloaded.\n */\nfunction TimeDynamicImagery(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.times\", options.times);\n  Check.typeOf.func(\n    \"options.requestImageFunction\",\n    options.requestImageFunction\n  );\n  Check.typeOf.func(\"options.reloadFunction\", options.reloadFunction);\n  //>>includeEnd('debug');\n\n  this._tileCache = {};\n  this._tilesRequestedForInterval = [];\n\n  const clock = (this._clock = options.clock);\n  this._times = options.times;\n  this._requestImageFunction = options.requestImageFunction;\n  this._reloadFunction = options.reloadFunction;\n  this._currentIntervalIndex = -1;\n\n  clock.onTick.addEventListener(this._clockOnTick, this);\n  this._clockOnTick(clock);\n}\n\nObject.defineProperties(TimeDynamicImagery.prototype, {\n  /**\n   * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._clock !== value) {\n        this._clock = value;\n        this._clockOnTick(value);\n        this._reloadFunction();\n      }\n    },\n  },\n  /**\n   * Gets or sets a time interval collection.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeIntervalCollection}\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._times !== value) {\n        this._times = value;\n        this._clockOnTick(this._clock);\n        this._reloadFunction();\n      }\n    },\n  },\n  /**\n   * Gets the current interval.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeInterval}\n   */\n  currentInterval: {\n    get: function () {\n      return this._times.get(this._currentIntervalIndex);\n    },\n  },\n});\n\n/**\n * Gets the tile from the cache if its available.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<HTMLImageElement>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if the tile is not in the cache.\n */\nTimeDynamicImagery.prototype.getFromCache = function (x, y, level, request) {\n  const key = getKey(x, y, level);\n  let result;\n  const cache = this._tileCache[this._currentIntervalIndex];\n  if (defined(cache) && defined(cache[key])) {\n    const item = cache[key];\n    result = item.promise.catch(function (e) {\n      // Set the correct state in case it was cancelled\n      request.state = item.request.state;\n      throw e;\n    });\n    delete cache[key];\n  }\n\n  return result;\n};\n\n/**\n * Checks if the next interval is approaching and will start preload the tile if necessary. Otherwise it will\n * just add the tile to a list to preload when we approach the next interval.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n */\nTimeDynamicImagery.prototype.checkApproachingInterval = function (\n  x,\n  y,\n  level,\n  request\n) {\n  const key = getKey(x, y, level);\n  const tilesRequestedForInterval = this._tilesRequestedForInterval;\n\n  // If we are approaching an interval, preload this tile in the next interval\n  const approachingInterval = getApproachingInterval(this);\n  const tile = {\n    key: key,\n    // Determines priority based on camera distance to the tile.\n    // Since the imagery regardless of time will be attached to the same tile we can just steal it.\n    priorityFunction: request.priorityFunction,\n  };\n  if (\n    !defined(approachingInterval) ||\n    !addToCache(this, tile, approachingInterval)\n  ) {\n    // Add to recent request list if we aren't approaching and interval or the request was throttled\n    tilesRequestedForInterval.push(tile);\n  }\n\n  // Don't let the tile list get out of hand\n  if (tilesRequestedForInterval.length >= 512) {\n    tilesRequestedForInterval.splice(0, 256);\n  }\n};\n\nTimeDynamicImagery.prototype._clockOnTick = function (clock) {\n  const time = clock.currentTime;\n  const times = this._times;\n  const index = times.indexOf(time);\n  const currentIntervalIndex = this._currentIntervalIndex;\n\n  if (index !== currentIntervalIndex) {\n    // Cancel all outstanding requests and clear out caches not from current time interval\n    const currentCache = this._tileCache[currentIntervalIndex];\n    for (const t in currentCache) {\n      if (currentCache.hasOwnProperty(t)) {\n        currentCache[t].request.cancel();\n      }\n    }\n    delete this._tileCache[currentIntervalIndex];\n    this._tilesRequestedForInterval = [];\n\n    this._currentIntervalIndex = index;\n    this._reloadFunction();\n\n    return;\n  }\n\n  const approachingInterval = getApproachingInterval(this);\n  if (defined(approachingInterval)) {\n    // Start loading recent tiles from end of this._tilesRequestedForInterval\n    //  We keep preloading until we hit a throttling limit.\n    const tilesRequested = this._tilesRequestedForInterval;\n    let success = true;\n    while (success) {\n      if (tilesRequested.length === 0) {\n        break;\n      }\n\n      const tile = tilesRequested.pop();\n      success = addToCache(this, tile, approachingInterval);\n      if (!success) {\n        tilesRequested.push(tile);\n      }\n    }\n  }\n};\n\nfunction getKey(x, y, level) {\n  return `${x}-${y}-${level}`;\n}\n\nfunction getKeyElements(key) {\n  const s = key.split(\"-\");\n  if (s.length !== 3) {\n    return undefined;\n  }\n\n  return {\n    x: Number(s[0]),\n    y: Number(s[1]),\n    level: Number(s[2]),\n  };\n}\n\nfunction getApproachingInterval(that) {\n  const times = that._times;\n  if (!defined(times)) {\n    return undefined;\n  }\n  const clock = that._clock;\n  const time = clock.currentTime;\n  const isAnimating = clock.canAnimate && clock.shouldAnimate;\n  const multiplier = clock.multiplier;\n\n  if (!isAnimating && multiplier !== 0) {\n    return undefined;\n  }\n\n  let seconds;\n  let index = times.indexOf(time);\n  if (index < 0) {\n    return undefined;\n  }\n\n  const interval = times.get(index);\n  if (multiplier > 0) {\n    // animating forward\n    seconds = JulianDate.secondsDifference(interval.stop, time);\n    ++index;\n  } else {\n    //backwards\n    seconds = JulianDate.secondsDifference(interval.start, time); // Will be negative\n    --index;\n  }\n  seconds /= multiplier; // Will always be positive\n\n  // Less than 5 wall time seconds\n  return index >= 0 && seconds <= 5.0 ? times.get(index) : undefined;\n}\n\nfunction addToCache(that, tile, interval) {\n  const index = that._times.indexOf(interval.start);\n  const tileCache = that._tileCache;\n  let intervalTileCache = tileCache[index];\n  if (!defined(intervalTileCache)) {\n    intervalTileCache = tileCache[index] = {};\n  }\n\n  const key = tile.key;\n  if (defined(intervalTileCache[key])) {\n    return true; // Already in the cache\n  }\n\n  const keyElements = getKeyElements(key);\n  const request = new Request({\n    throttle: false,\n    throttleByServer: true,\n    type: RequestType.IMAGERY,\n    priorityFunction: tile.priorityFunction,\n  });\n  const promise = that._requestImageFunction(\n    keyElements.x,\n    keyElements.y,\n    keyElements.level,\n    request,\n    interval\n  );\n  if (!defined(promise)) {\n    return false;\n  }\n\n  intervalTileCache[key] = {\n    promise: promise,\n    request: request,\n  };\n\n  return true;\n}\nexport default TimeDynamicImagery;\n","import arrayFill from \"../Core/arrayFill.js\";\nimport Check from \"../Core/Check.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport PointCloud from \"./PointCloud.js\";\nimport PointCloudEyeDomeLighting from \"./PointCloudEyeDomeLighting.js\";\nimport PointCloudShading from \"./PointCloudShading.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * Provides playback of time-dynamic point cloud data.\n * <p>\n * Point cloud frames are prefetched in intervals determined by the average frame load time and the current clock speed.\n * If intermediate frames cannot be loaded in time to meet playback speed, they will be skipped. If frames are sufficiently\n * small or the clock is sufficiently slow then no frames will be skipped.\n * </p>\n *\n * @alias TimeDynamicPointCloud\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Clock} options.clock A {@link Clock} instance that is used when determining the value for the time dimension.\n * @param {TimeIntervalCollection} options.intervals A {@link TimeIntervalCollection} with its data property being an object containing a <code>uri</code> to a 3D Tiles Point Cloud tile and an optional <code>transform</code>.\n * @param {Boolean} [options.show=true] Determines if the point cloud will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] A 4x4 transformation matrix that transforms the point cloud.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the point cloud casts or receives shadows from light sources.\n * @param {Number} [options.maximumMemoryUsage=256] The maximum amount of memory in MB that can be used by the point cloud.\n * @param {Object} [options.shading] Options for constructing a {@link PointCloudShading} object to control point attenuation and eye dome lighting.\n * @param {Cesium3DTileStyle} [options.style] The style, defined using the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}, applied to each point in the point cloud.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n */\nfunction TimeDynamicPointCloud(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.intervals\", options.intervals);\n  //>>includeEnd('debug');\n\n  /**\n   * Determines if the point cloud will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * A 4x4 transformation matrix that transforms the point cloud.\n   *\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n\n  /**\n   * Determines whether the point cloud casts or receives shadows from light sources.\n   * <p>\n   * Enabling shadows has a performance impact. A point cloud that casts shadows must be rendered twice, once from the camera and again from the light's point of view.\n   * </p>\n   * <p>\n   * Shadows are rendered only when {@link Viewer#shadows} is <code>true</code>.\n   * </p>\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.ENABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n\n  /**\n   * The maximum amount of GPU memory (in MB) that may be used to cache point cloud frames.\n   * <p>\n   * Frames that are not being loaded or rendered are unloaded to enforce this.\n   * </p>\n   * <p>\n   * If decreasing this value results in unloading tiles, the tiles are unloaded the next frame.\n   * </p>\n   *\n   * @type {Number}\n   * @default 256\n   *\n   * @see TimeDynamicPointCloud#totalMemoryUsageInBytes\n   */\n  this.maximumMemoryUsage = defaultValue(options.maximumMemoryUsage, 256);\n\n  /**\n   * Options for controlling point size based on geometric error and eye dome lighting.\n   * @type {PointCloudShading}\n   */\n  this.shading = new PointCloudShading(options.shading);\n\n  /**\n   * The style, defined using the\n   * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language},\n   * applied to each point in the point cloud.\n   * <p>\n   * Assign <code>undefined</code> to remove the style, which will restore the visual\n   * appearance of the point cloud to its default when no style was applied.\n   * </p>\n   *\n   * @type {Cesium3DTileStyle}\n   *\n   * @example\n   * pointCloud.style = new Cesium.Cesium3DTileStyle({\n   *    color : {\n   *        conditions : [\n   *            ['${Classification} === 0', 'color(\"purple\", 0.5)'],\n   *            ['${Classification} === 1', 'color(\"red\")'],\n   *            ['true', '${COLOR}']\n   *        ]\n   *    },\n   *    show : '${Classification} !== 2'\n   * });\n   *\n   * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}\n   */\n  this.style = options.style;\n\n  /**\n   * The event fired to indicate that a frame failed to load. A frame may fail to load if the\n   * request for its uri fails or processing fails due to invalid content.\n   * <p>\n   * If there are no event listeners, error messages will be logged to the console.\n   * </p>\n   * <p>\n   * The error object passed to the listener contains two properties:\n   * <ul>\n   * <li><code>uri</code>: the uri of the failed frame.</li>\n   * <li><code>message</code>: the error message.</li>\n   * </ul>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameFailed.addEventListener(function(error) {\n   *     console.log('An error occurred loading frame: ' + error.uri);\n   *     console.log('Error: ' + error.message);\n   * });\n   */\n  this.frameFailed = new Event();\n\n  /**\n   * The event fired to indicate that a new frame was rendered.\n   * <p>\n   * The time dynamic point cloud {@link TimeDynamicPointCloud} is passed to the event listener.\n   * </p>\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * pointCloud.frameChanged.addEventListener(function(timeDynamicPointCloud) {\n   *     viewer.camera.viewBoundingSphere(timeDynamicPointCloud.boundingSphere);\n   * });\n   */\n  this.frameChanged = new Event();\n\n  this._clock = options.clock;\n  this._intervals = options.intervals;\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes; // Call setter\n  this._pointCloudEyeDomeLighting = new PointCloudEyeDomeLighting();\n  this._loadTimestamp = undefined;\n  this._clippingPlanesState = 0;\n  this._styleDirty = false;\n  this._pickId = undefined;\n  this._totalMemoryUsageInBytes = 0;\n  this._frames = [];\n  this._previousInterval = undefined;\n  this._nextInterval = undefined;\n  this._lastRenderedFrame = undefined;\n  this._clockMultiplier = 0.0;\n  this._resolveReadyPromise = undefined;\n  const that = this;\n  this._readyPromise = new Promise(function (resolve) {\n    that._resolveReadyPromise = resolve;\n  });\n\n  // For calculating average load time of the last N frames\n  this._runningSum = 0.0;\n  this._runningLength = 0;\n  this._runningIndex = 0;\n  this._runningSamples = arrayFill(new Array(5), 0.0);\n  this._runningAverage = 0.0;\n}\n\nObject.defineProperties(TimeDynamicPointCloud.prototype, {\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * The total amount of GPU memory in bytes used by the point cloud.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @see TimeDynamicPointCloud#maximumMemoryUsage\n   */\n  totalMemoryUsageInBytes: {\n    get: function () {\n      return this._totalMemoryUsageInBytes;\n    },\n  },\n\n  /**\n   * The bounding sphere of the frame being rendered. Returns <code>undefined</code> if no frame is being rendered.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      if (defined(this._lastRenderedFrame)) {\n        return this._lastRenderedFrame.pointCloud.boundingSphere;\n      }\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the promise that will be resolved when the point cloud renders a frame for the first time.\n   *\n   * @memberof TimeDynamicPointCloud.prototype\n   *\n   * @type {Promise.<TimeDynamicPointCloud>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n});\n\nfunction getFragmentShaderLoaded(fs) {\n  return `uniform vec4 czm_pickColor;\\n${fs}`;\n}\n\nfunction getUniformMapLoaded(stream) {\n  return function (uniformMap) {\n    return combine(uniformMap, {\n      czm_pickColor: function () {\n        return stream._pickId.color;\n      },\n    });\n  };\n}\n\nfunction getPickIdLoaded() {\n  return \"czm_pickColor\";\n}\n\n/**\n * Marks the point cloud's {@link TimeDynamicPointCloud#style} as dirty, which forces all\n * points to re-evaluate the style in the next frame.\n */\nTimeDynamicPointCloud.prototype.makeStyleDirty = function () {\n  this._styleDirty = true;\n};\n\n/**\n * Exposed for testing.\n *\n * @private\n */\nTimeDynamicPointCloud.prototype._getAverageLoadTime = function () {\n  if (this._runningLength === 0) {\n    // Before any frames have loaded make a best guess about the average load time\n    return 0.05;\n  }\n  return this._runningAverage;\n};\n\nconst scratchDate = new JulianDate();\n\nfunction getClockMultiplier(that) {\n  const clock = that._clock;\n  const isAnimating = clock.canAnimate && clock.shouldAnimate;\n  const multiplier = clock.multiplier;\n  return isAnimating ? multiplier : 0.0;\n}\n\nfunction getIntervalIndex(that, interval) {\n  return that._intervals.indexOf(interval.start);\n}\n\nfunction getNextInterval(that, currentInterval) {\n  const intervals = that._intervals;\n  const clock = that._clock;\n  const multiplier = getClockMultiplier(that);\n\n  if (multiplier === 0.0) {\n    return undefined;\n  }\n\n  const averageLoadTime = that._getAverageLoadTime();\n  const time = JulianDate.addSeconds(\n    clock.currentTime,\n    averageLoadTime * multiplier,\n    scratchDate\n  );\n  let index = intervals.indexOf(time);\n\n  const currentIndex = getIntervalIndex(that, currentInterval);\n  if (index === currentIndex) {\n    if (multiplier >= 0) {\n      ++index;\n    } else {\n      --index;\n    }\n  }\n\n  // Returns undefined if not in range\n  return intervals.get(index);\n}\n\nfunction getCurrentInterval(that) {\n  const intervals = that._intervals;\n  const clock = that._clock;\n  const time = clock.currentTime;\n  const index = intervals.indexOf(time);\n\n  // Returns undefined if not in range\n  return intervals.get(index);\n}\n\nfunction reachedInterval(that, currentInterval, nextInterval) {\n  const multiplier = getClockMultiplier(that);\n  const currentIndex = getIntervalIndex(that, currentInterval);\n  const nextIndex = getIntervalIndex(that, nextInterval);\n\n  if (multiplier >= 0) {\n    return currentIndex >= nextIndex;\n  }\n  return currentIndex <= nextIndex;\n}\n\nfunction handleFrameFailure(that, uri) {\n  return function (error) {\n    const message = defined(error.message) ? error.message : error.toString();\n    if (that.frameFailed.numberOfListeners > 0) {\n      that.frameFailed.raiseEvent({\n        uri: uri,\n        message: message,\n      });\n    } else {\n      console.log(`A frame failed to load: ${uri}`);\n      console.log(`Error: ${message}`);\n    }\n  };\n}\n\nfunction requestFrame(that, interval, frameState) {\n  const index = getIntervalIndex(that, interval);\n  const frames = that._frames;\n  let frame = frames[index];\n  if (!defined(frame)) {\n    const transformArray = interval.data.transform;\n    const transform = defined(transformArray)\n      ? Matrix4.fromArray(transformArray)\n      : undefined;\n    const uri = interval.data.uri;\n    frame = {\n      pointCloud: undefined,\n      transform: transform,\n      timestamp: getTimestamp(),\n      sequential: true,\n      ready: false,\n      touchedFrameNumber: frameState.frameNumber,\n    };\n    frames[index] = frame;\n    Resource.fetchArrayBuffer({\n      url: uri,\n    })\n      .then(function (arrayBuffer) {\n        // PERFORMANCE_IDEA: share a memory pool, render states, shaders, and other resources among all\n        // frames. Each frame just needs an index/offset into the pool.\n        frame.pointCloud = new PointCloud({\n          arrayBuffer: arrayBuffer,\n          cull: true,\n          fragmentShaderLoaded: getFragmentShaderLoaded,\n          uniformMapLoaded: getUniformMapLoaded(that),\n          pickIdLoaded: getPickIdLoaded,\n        });\n        return frame.pointCloud.readyPromise;\n      })\n      .catch(handleFrameFailure(that, uri));\n  }\n  return frame;\n}\n\nfunction updateAverageLoadTime(that, loadTime) {\n  that._runningSum += loadTime;\n  that._runningSum -= that._runningSamples[that._runningIndex];\n  that._runningSamples[that._runningIndex] = loadTime;\n  that._runningLength = Math.min(\n    that._runningLength + 1,\n    that._runningSamples.length\n  );\n  that._runningIndex = (that._runningIndex + 1) % that._runningSamples.length;\n  that._runningAverage = that._runningSum / that._runningLength;\n}\n\nfunction prepareFrame(that, frame, updateState, frameState) {\n  if (frame.touchedFrameNumber < frameState.frameNumber - 1) {\n    // If this frame was not loaded in sequential updates then it can't be used it for calculating the average load time.\n    // For example: selecting a frame on the timeline, selecting another frame before the request finishes, then selecting this frame later.\n    frame.sequential = false;\n  }\n\n  const pointCloud = frame.pointCloud;\n\n  if (defined(pointCloud) && !frame.ready) {\n    // Call update to prepare renderer resources. Don't render anything yet.\n    const commandList = frameState.commandList;\n    const lengthBeforeUpdate = commandList.length;\n    renderFrame(that, frame, updateState, frameState);\n\n    if (pointCloud.ready) {\n      // Point cloud became ready this update\n      frame.ready = true;\n      that._totalMemoryUsageInBytes += pointCloud.geometryByteLength;\n      commandList.length = lengthBeforeUpdate; // Don't allow preparing frame to insert commands.\n      if (frame.sequential) {\n        // Update the values used to calculate average load time\n        const loadTime = (getTimestamp() - frame.timestamp) / 1000.0;\n        updateAverageLoadTime(that, loadTime);\n      }\n    }\n  }\n\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\n\nconst scratchModelMatrix = new Matrix4();\n\nfunction getGeometricError(that, pointCloud) {\n  const shading = that.shading;\n  if (defined(shading) && defined(shading.baseResolution)) {\n    return shading.baseResolution;\n  } else if (defined(pointCloud.boundingSphere)) {\n    return CesiumMath.cbrt(\n      pointCloud.boundingSphere.volume() / pointCloud.pointsLength\n    );\n  }\n  return 0.0;\n}\n\nfunction getMaximumAttenuation(that) {\n  const shading = that.shading;\n  if (defined(shading) && defined(shading.maximumAttenuation)) {\n    return shading.maximumAttenuation;\n  }\n\n  // Return a hardcoded maximum attenuation. For a tileset this would instead be the maximum screen space error.\n  return 10.0;\n}\n\nconst defaultShading = new PointCloudShading();\n\nfunction renderFrame(that, frame, updateState, frameState) {\n  const shading = defaultValue(that.shading, defaultShading);\n  const pointCloud = frame.pointCloud;\n  const transform = defaultValue(frame.transform, Matrix4.IDENTITY);\n  pointCloud.modelMatrix = Matrix4.multiplyTransformation(\n    that.modelMatrix,\n    transform,\n    scratchModelMatrix\n  );\n  pointCloud.style = that.style;\n  pointCloud.time = updateState.timeSinceLoad;\n  pointCloud.shadows = that.shadows;\n  pointCloud.clippingPlanes = that._clippingPlanes;\n  pointCloud.isClipped = updateState.isClipped;\n  pointCloud.attenuation = shading.attenuation;\n  pointCloud.backFaceCulling = shading.backFaceCulling;\n  pointCloud.normalShading = shading.normalShading;\n  pointCloud.geometricError = getGeometricError(that, pointCloud);\n  pointCloud.geometricErrorScale = shading.geometricErrorScale;\n  pointCloud.maximumAttenuation = getMaximumAttenuation(that);\n\n  pointCloud.update(frameState);\n  frame.touchedFrameNumber = frameState.frameNumber;\n}\n\nfunction loadFrame(that, interval, updateState, frameState) {\n  const frame = requestFrame(that, interval, frameState);\n  prepareFrame(that, frame, updateState, frameState);\n}\n\nfunction getUnloadCondition(frameState) {\n  return function (frame) {\n    // Unload all frames that aren't currently being loaded or rendered\n    return frame.touchedFrameNumber < frameState.frameNumber;\n  };\n}\n\nfunction unloadFrames(that, unloadCondition) {\n  const frames = that._frames;\n  const length = frames.length;\n  for (let i = 0; i < length; ++i) {\n    const frame = frames[i];\n    if (defined(frame)) {\n      if (!defined(unloadCondition) || unloadCondition(frame)) {\n        const pointCloud = frame.pointCloud;\n        if (frame.ready) {\n          that._totalMemoryUsageInBytes -= pointCloud.geometryByteLength;\n        }\n        if (defined(pointCloud)) {\n          pointCloud.destroy();\n        }\n        if (frame === that._lastRenderedFrame) {\n          that._lastRenderedFrame = undefined;\n        }\n        frames[i] = undefined;\n      }\n    }\n  }\n}\n\nfunction getFrame(that, interval) {\n  const index = getIntervalIndex(that, interval);\n  const frame = that._frames[index];\n  if (defined(frame) && frame.ready) {\n    return frame;\n  }\n}\n\nfunction updateInterval(that, interval, frame, updateState, frameState) {\n  if (defined(frame)) {\n    if (frame.ready) {\n      return true;\n    }\n    loadFrame(that, interval, updateState, frameState);\n    return frame.ready;\n  }\n  return false;\n}\n\nfunction getNearestReadyInterval(\n  that,\n  previousInterval,\n  currentInterval,\n  updateState,\n  frameState\n) {\n  let i;\n  let interval;\n  let frame;\n  const intervals = that._intervals;\n  const frames = that._frames;\n  const currentIndex = getIntervalIndex(that, currentInterval);\n  const previousIndex = getIntervalIndex(that, previousInterval);\n\n  if (currentIndex >= previousIndex) {\n    // look backwards\n    for (i = currentIndex; i >= previousIndex; --i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  } else {\n    // look forwards\n    for (i = currentIndex; i <= previousIndex; ++i) {\n      interval = intervals.get(i);\n      frame = frames[i];\n      if (updateInterval(that, interval, frame, updateState, frameState)) {\n        return interval;\n      }\n    }\n  }\n\n  // If no intervals are ready return the previous interval\n  return previousInterval;\n}\n\nfunction setFramesDirty(that, clippingPlanesDirty, styleDirty) {\n  const frames = that._frames;\n  const framesLength = frames.length;\n  for (let i = 0; i < framesLength; ++i) {\n    const frame = frames[i];\n    if (defined(frame) && defined(frame.pointCloud)) {\n      frame.pointCloud.clippingPlanesDirty = clippingPlanesDirty;\n      frame.pointCloud.styleDirty = styleDirty;\n    }\n  }\n}\n\nconst updateState = {\n  timeSinceLoad: 0,\n  isClipped: false,\n  clippingPlanesDirty: false,\n};\n\n/**\n * @private\n */\nTimeDynamicPointCloud.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!this.show) {\n    return;\n  }\n\n  if (!defined(this._pickId)) {\n    this._pickId = frameState.context.createPickId({\n      primitive: this,\n    });\n  }\n\n  if (!defined(this._loadTimestamp)) {\n    this._loadTimestamp = JulianDate.clone(frameState.time);\n  }\n\n  // For styling\n  const timeSinceLoad = Math.max(\n    JulianDate.secondsDifference(frameState.time, this._loadTimestamp) * 1000,\n    0.0\n  );\n\n  // Update clipping planes\n  const clippingPlanes = this._clippingPlanes;\n  let clippingPlanesState = 0;\n  let clippingPlanesDirty = false;\n  const isClipped = defined(clippingPlanes) && clippingPlanes.enabled;\n\n  if (isClipped) {\n    clippingPlanes.update(frameState);\n    clippingPlanesState = clippingPlanes.clippingPlanesState;\n  }\n\n  if (this._clippingPlanesState !== clippingPlanesState) {\n    this._clippingPlanesState = clippingPlanesState;\n    clippingPlanesDirty = true;\n  }\n\n  const styleDirty = this._styleDirty;\n  this._styleDirty = false;\n\n  if (clippingPlanesDirty || styleDirty) {\n    setFramesDirty(this, clippingPlanesDirty, styleDirty);\n  }\n\n  updateState.timeSinceLoad = timeSinceLoad;\n  updateState.isClipped = isClipped;\n\n  const shading = this.shading;\n  const eyeDomeLighting = this._pointCloudEyeDomeLighting;\n\n  const commandList = frameState.commandList;\n  const lengthBeforeUpdate = commandList.length;\n\n  let previousInterval = this._previousInterval;\n  let nextInterval = this._nextInterval;\n  const currentInterval = getCurrentInterval(this);\n\n  if (!defined(currentInterval)) {\n    return;\n  }\n\n  let clockMultiplierChanged = false;\n  const clockMultiplier = getClockMultiplier(this);\n  const clockPaused = clockMultiplier === 0;\n  if (clockMultiplier !== this._clockMultiplier) {\n    clockMultiplierChanged = true;\n    this._clockMultiplier = clockMultiplier;\n  }\n\n  if (!defined(previousInterval) || clockPaused) {\n    previousInterval = currentInterval;\n  }\n\n  if (\n    !defined(nextInterval) ||\n    clockMultiplierChanged ||\n    reachedInterval(this, currentInterval, nextInterval)\n  ) {\n    nextInterval = getNextInterval(this, currentInterval);\n  }\n\n  previousInterval = getNearestReadyInterval(\n    this,\n    previousInterval,\n    currentInterval,\n    updateState,\n    frameState\n  );\n  let frame = getFrame(this, previousInterval);\n\n  if (!defined(frame)) {\n    // The frame is not ready to render. This can happen when the simulation starts or when scrubbing the timeline\n    // to a frame that hasn't loaded yet. Just render the last rendered frame in its place until it finishes loading.\n    loadFrame(this, previousInterval, updateState, frameState);\n    frame = this._lastRenderedFrame;\n  }\n\n  if (defined(frame)) {\n    renderFrame(this, frame, updateState, frameState);\n  }\n\n  if (defined(nextInterval)) {\n    // Start loading the next frame\n    loadFrame(this, nextInterval, updateState, frameState);\n  }\n\n  const that = this;\n  if (defined(frame) && !defined(this._lastRenderedFrame)) {\n    frameState.afterRender.push(function () {\n      that._resolveReadyPromise(that);\n    });\n  }\n\n  if (defined(frame) && frame !== this._lastRenderedFrame) {\n    if (that.frameChanged.numberOfListeners > 0) {\n      frameState.afterRender.push(function () {\n        that.frameChanged.raiseEvent(that);\n      });\n    }\n  }\n\n  this._previousInterval = previousInterval;\n  this._nextInterval = nextInterval;\n  this._lastRenderedFrame = frame;\n\n  const totalMemoryUsageInBytes = this._totalMemoryUsageInBytes;\n  const maximumMemoryUsageInBytes = this.maximumMemoryUsage * 1024 * 1024;\n\n  if (totalMemoryUsageInBytes > maximumMemoryUsageInBytes) {\n    unloadFrames(this, getUnloadCondition(frameState));\n  }\n\n  const lengthAfterUpdate = commandList.length;\n  const addedCommandsLength = lengthAfterUpdate - lengthBeforeUpdate;\n\n  if (\n    defined(shading) &&\n    shading.attenuation &&\n    shading.eyeDomeLighting &&\n    addedCommandsLength > 0\n  ) {\n    eyeDomeLighting.update(\n      frameState,\n      lengthBeforeUpdate,\n      shading,\n      this.boundingSphere\n    );\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see TimeDynamicPointCloud#destroy\n */\nTimeDynamicPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * pointCloud = pointCloud && pointCloud.destroy();\n *\n * @see TimeDynamicPointCloud#isDestroyed\n */\nTimeDynamicPointCloud.prototype.destroy = function () {\n  unloadFrames(this);\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  this._pickId = this._pickId && this._pickId.destroy();\n  return destroyObject(this);\n};\nexport default TimeDynamicPointCloud;\n","/**\n * A tonemapping algorithm when rendering with high dynamic range.\n *\n * @enum {Number}\n * @private\n */\nconst Tonemapper = {\n  /**\n   * Use the Reinhard tonemapping operator.\n   *\n   * @type {Number}\n   * @constant\n   */\n  REINHARD: 0,\n\n  /**\n   * Use the modified Reinhard tonemapping operator.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MODIFIED_REINHARD: 1,\n\n  /**\n   * Use the Filmic tonemapping operator.\n   *\n   * @type {Number}\n   * @constant\n   */\n  FILMIC: 2,\n\n  /**\n   * Use the ACES tonemapping operator.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ACES: 3,\n\n  /**\n   * @private\n   */\n  validate: function (tonemapper) {\n    return (\n      tonemapper === Tonemapper.REINHARD ||\n      tonemapper === Tonemapper.MODIFIED_REINHARD ||\n      tonemapper === Tonemapper.FILMIC ||\n      tonemapper === Tonemapper.ACES\n    );\n  },\n};\nexport default Object.freeze(Tonemapper);\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport CompareAndPackTranslucentDepth from \"../Shaders/CompareAndPackTranslucentDepth.js\";\nimport CompositeTranslucentClassification from \"../Shaders/PostProcessStages/CompositeTranslucentClassification.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\n\nconst debugShowPackedDepth = false;\n\n/**\n * Handles buffers, drawing, and deriving commands needed for classifying translucent 3D Tiles.\n * Uses a depth texture, so classification on translucent 3D Tiles is not available in Internet Explorer.\n *\n * @private\n */\nfunction TranslucentTileClassification(context) {\n  this._drawClassificationFBO = new FramebufferManager({\n    createDepthAttachments: false,\n  });\n  this._accumulationFBO = new FramebufferManager({\n    createDepthAttachments: false,\n  });\n  this._packFBO = new FramebufferManager();\n\n  this._opaqueDepthStencilTexture = undefined;\n\n  // Reference to either colorTexture or accumulationTexture\n  this._textureToComposite = undefined;\n\n  this._translucentDepthStencilTexture = undefined;\n\n  this._packDepthCommand = undefined;\n  this._accumulateCommand = undefined;\n  this._compositeCommand = undefined;\n  this._copyCommand = undefined;\n\n  this._clearColorCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    owner: this,\n  });\n\n  this._clearDepthStencilCommand = new ClearCommand({\n    depth: 1.0,\n    stencil: 0,\n    owner: this,\n  });\n\n  this._supported = context.depthTexture;\n\n  this._viewport = new BoundingRectangle();\n  this._rsDepth = undefined;\n  this._rsAccumulate = undefined;\n  this._rsComp = undefined;\n  this._useScissorTest = undefined;\n  this._scissorRectangle = undefined;\n\n  this._hasTranslucentDepth = false;\n  this._frustumsDrawn = 0;\n}\n\nObject.defineProperties(TranslucentTileClassification.prototype, {\n  /**\n   * Gets whether or not translucent depth was rendered.\n   * @memberof TranslucentTileClassification.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  hasTranslucentDepth: {\n    get: function () {\n      return this._hasTranslucentDepth;\n    },\n  },\n});\n\nfunction destroyTextures(transpClass) {\n  transpClass._textureToComposite = undefined;\n\n  transpClass._translucentDepthStencilTexture =\n    transpClass._translucentDepthStencilTexture &&\n    !transpClass._translucentDepthStencilTexture.isDestroyed() &&\n    transpClass._translucentDepthStencilTexture.destroy();\n}\n\nfunction destroyFramebuffers(transpClass) {\n  transpClass._drawClassificationFBO.destroy();\n  transpClass._accumulationFBO.destroy();\n  transpClass._packFBO.destroy();\n}\n\nfunction updateTextures(transpClass, context, width, height) {\n  destroyTextures(transpClass);\n\n  transpClass._translucentDepthStencilTexture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: PixelFormat.DEPTH_STENCIL,\n    pixelDatatype: PixelDatatype.UNSIGNED_INT_24_8,\n    sampler: Sampler.NEAREST,\n  });\n}\n\nfunction updateFramebuffers(transpClass, context, width, height) {\n  destroyFramebuffers(transpClass);\n  transpClass._drawClassificationFBO.setDepthStencilTexture(\n    transpClass._translucentDepthStencilTexture\n  );\n  transpClass._drawClassificationFBO.update(context, width, height);\n\n  transpClass._accumulationFBO.setDepthStencilTexture(\n    transpClass._translucentDepthStencilTexture\n  );\n  transpClass._accumulationFBO.update(context, width, height);\n\n  transpClass._packFBO.update(context, width, height);\n}\n\nfunction updateResources(\n  transpClass,\n  context,\n  passState,\n  globeDepthStencilTexture\n) {\n  if (!transpClass.isSupported()) {\n    return;\n  }\n\n  transpClass._opaqueDepthStencilTexture = globeDepthStencilTexture;\n\n  const width = transpClass._opaqueDepthStencilTexture.width;\n  const height = transpClass._opaqueDepthStencilTexture.height;\n  if (transpClass._drawClassificationFBO.isDirty(width, height)) {\n    updateTextures(transpClass, context, width, height);\n    updateFramebuffers(transpClass, context, width, height);\n  }\n\n  let fs;\n  let uniformMap;\n\n  if (!defined(transpClass._packDepthCommand)) {\n    fs = new ShaderSource({\n      sources: [CompareAndPackTranslucentDepth],\n    });\n\n    uniformMap = {\n      u_opaqueDepthTexture: function () {\n        return transpClass._opaqueDepthStencilTexture;\n      },\n      u_translucentDepthTexture: function () {\n        return transpClass._translucentDepthStencilTexture;\n      },\n    };\n\n    transpClass._packDepthCommand = context.createViewportQuadCommand(fs, {\n      uniformMap: uniformMap,\n      owner: transpClass,\n    });\n  }\n\n  if (!defined(transpClass._compositeCommand)) {\n    fs = new ShaderSource({\n      sources: [CompositeTranslucentClassification],\n    });\n\n    uniformMap = {\n      colorTexture: function () {\n        return transpClass._textureToComposite;\n      },\n    };\n\n    if (debugShowPackedDepth) {\n      fs.defines = [\"DEBUG_SHOW_DEPTH\"];\n      uniformMap.u_packedTranslucentDepth = function () {\n        return transpClass._packFBO.getColorTexture();\n      };\n    }\n\n    transpClass._compositeCommand = context.createViewportQuadCommand(fs, {\n      uniformMap: uniformMap,\n      owner: transpClass,\n    });\n\n    const compositeCommand = transpClass._compositeCommand;\n    const compositeProgram = compositeCommand.shaderProgram;\n    const compositePickProgram = context.shaderCache.createDerivedShaderProgram(\n      compositeProgram,\n      \"pick\",\n      {\n        vertexShaderSource: compositeProgram.vertexShaderSource,\n        fragmentShaderSource: new ShaderSource({\n          sources: fs.sources,\n          defines: [\"PICK\"],\n        }),\n        attributeLocations: compositeProgram._attributeLocations,\n      }\n    );\n    const compositePickCommand = DrawCommand.shallowClone(compositeCommand);\n    compositePickCommand.shaderProgram = compositePickProgram;\n    compositeCommand.derivedCommands.pick = compositePickCommand;\n  }\n\n  if (!defined(transpClass._copyCommand)) {\n    fs = new ShaderSource({\n      sources: [CompositeTranslucentClassification],\n    });\n\n    uniformMap = {\n      colorTexture: function () {\n        return transpClass._drawClassificationFBO.getColorTexture();\n      },\n    };\n\n    transpClass._copyCommand = context.createViewportQuadCommand(fs, {\n      uniformMap: uniformMap,\n      owner: transpClass,\n    });\n  }\n\n  if (!defined(transpClass._accumulateCommand)) {\n    fs = new ShaderSource({\n      sources: [CompositeTranslucentClassification],\n    });\n\n    uniformMap = {\n      colorTexture: function () {\n        return transpClass._drawClassificationFBO.getColorTexture();\n      },\n    };\n\n    transpClass._accumulateCommand = context.createViewportQuadCommand(fs, {\n      uniformMap: uniformMap,\n      owner: transpClass,\n    });\n  }\n\n  transpClass._viewport.width = width;\n  transpClass._viewport.height = height;\n\n  const useScissorTest = !BoundingRectangle.equals(\n    transpClass._viewport,\n    passState.viewport\n  );\n  let updateScissor = useScissorTest !== transpClass._useScissorTest;\n  transpClass._useScissorTest = useScissorTest;\n\n  if (\n    !BoundingRectangle.equals(transpClass._scissorRectangle, passState.viewport)\n  ) {\n    transpClass._scissorRectangle = BoundingRectangle.clone(\n      passState.viewport,\n      transpClass._scissorRectangle\n    );\n    updateScissor = true;\n  }\n\n  if (\n    !defined(transpClass._rsDepth) ||\n    !BoundingRectangle.equals(\n      transpClass._viewport,\n      transpClass._rsDepth.viewport\n    ) ||\n    updateScissor\n  ) {\n    transpClass._rsDepth = RenderState.fromCache({\n      viewport: transpClass._viewport,\n      scissorTest: {\n        enabled: transpClass._useScissorTest,\n        rectangle: transpClass._scissorRectangle,\n      },\n    });\n  }\n\n  if (defined(transpClass._packDepthCommand)) {\n    transpClass._packDepthCommand.renderState = transpClass._rsDepth;\n  }\n\n  if (\n    !defined(transpClass._rsAccumulate) ||\n    !BoundingRectangle.equals(\n      transpClass._viewport,\n      transpClass._rsAccumulate.viewport\n    ) ||\n    updateScissor\n  ) {\n    transpClass._rsAccumulate = RenderState.fromCache({\n      viewport: transpClass._viewport,\n      scissorTest: {\n        enabled: transpClass._useScissorTest,\n        rectangle: transpClass._scissorRectangle,\n      },\n      stencilTest: {\n        enabled: true,\n        frontFunction: StencilFunction.EQUAL,\n        reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      },\n    });\n  }\n\n  if (defined(transpClass._accumulateCommand)) {\n    transpClass._accumulateCommand.renderState = transpClass._rsAccumulate;\n  }\n\n  if (\n    !defined(transpClass._rsComp) ||\n    !BoundingRectangle.equals(\n      transpClass._viewport,\n      transpClass._rsComp.viewport\n    ) ||\n    updateScissor\n  ) {\n    transpClass._rsComp = RenderState.fromCache({\n      viewport: transpClass._viewport,\n      scissorTest: {\n        enabled: transpClass._useScissorTest,\n        rectangle: transpClass._scissorRectangle,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n    });\n  }\n\n  if (defined(transpClass._compositeCommand)) {\n    transpClass._compositeCommand.renderState = transpClass._rsComp;\n    transpClass._compositeCommand.derivedCommands.pick.renderState =\n      transpClass._rsComp;\n  }\n}\n\nTranslucentTileClassification.prototype.executeTranslucentCommands = function (\n  scene,\n  executeCommand,\n  passState,\n  commands,\n  globeDepthStencilTexture\n) {\n  // Check for translucent commands that should be classified\n  const length = commands.length;\n  let command;\n  let i;\n\n  const useLogDepth = scene.frameState.useLogDepth;\n  const context = scene.context;\n  const framebuffer = passState.framebuffer;\n\n  for (i = 0; i < length; ++i) {\n    command = commands[i];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n\n    if (command.depthForTranslucentClassification) {\n      this._hasTranslucentDepth = true;\n      break;\n    }\n  }\n\n  if (!this._hasTranslucentDepth) {\n    return;\n  }\n\n  updateResources(this, context, passState, globeDepthStencilTexture);\n\n  // Get translucent depth\n  passState.framebuffer = this._drawClassificationFBO.framebuffer;\n\n  // Clear depth for multifrustum\n  this._clearDepthStencilCommand.execute(context, passState);\n\n  for (i = 0; i < length; ++i) {\n    command = commands[i];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n\n    if (!command.depthForTranslucentClassification) {\n      continue;\n    }\n\n    // Depth-only commands are created for all translucent 3D Tiles commands\n    const depthOnlyCommand = command.derivedCommands.depth.depthOnlyCommand;\n    executeCommand(depthOnlyCommand, scene, context, passState);\n  }\n\n  this._frustumsDrawn += this._hasTranslucentDepth ? 1 : 0;\n\n  // Pack depth if any translucent depth commands were performed\n  if (this._hasTranslucentDepth) {\n    passState.framebuffer = this._packFBO.framebuffer;\n    this._packDepthCommand.execute(context, passState);\n  }\n\n  passState.framebuffer = framebuffer;\n};\n\nTranslucentTileClassification.prototype.executeClassificationCommands = function (\n  scene,\n  executeCommand,\n  passState,\n  frustumCommands\n) {\n  if (!this._hasTranslucentDepth) {\n    return;\n  }\n\n  const context = scene.context;\n  const us = context.uniformState;\n  const framebuffer = passState.framebuffer;\n\n  if (this._frustumsDrawn === 2) {\n    // copy classification from first frustum\n    passState.framebuffer = this._accumulationFBO.framebuffer;\n    this._copyCommand.execute(context, passState);\n  }\n\n  passState.framebuffer = this._drawClassificationFBO.framebuffer;\n  if (this._frustumsDrawn > 1) {\n    this._clearColorCommand.execute(context, passState);\n  }\n\n  us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION);\n  const swapGlobeDepth = us.globeDepthTexture;\n  us.globeDepthTexture = this._packFBO.getColorTexture();\n  const commands = frustumCommands.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n  const length = frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION];\n  for (let i = 0; i < length; ++i) {\n    executeCommand(commands[i], scene, context, passState);\n  }\n\n  us.globeDepthTexture = swapGlobeDepth;\n  passState.framebuffer = framebuffer;\n\n  if (this._frustumsDrawn === 1) {\n    return;\n  }\n\n  passState.framebuffer = this._accumulationFBO.framebuffer;\n  this._accumulateCommand.execute(context, passState);\n\n  passState.framebuffer = framebuffer;\n};\n\nTranslucentTileClassification.prototype.execute = function (scene, passState) {\n  if (!this._hasTranslucentDepth) {\n    return;\n  }\n  if (this._frustumsDrawn === 1) {\n    this._textureToComposite = this._drawClassificationFBO.getColorTexture();\n  } else {\n    this._textureToComposite = this._accumulationFBO.getColorTexture();\n  }\n\n  const command = scene.frameState.passes.pick\n    ? this._compositeCommand.derivedCommands.pick\n    : this._compositeCommand;\n  command.execute(scene.context, passState);\n\n  clear(this, scene, passState);\n};\n\nfunction clear(translucentTileClassification, scene, passState) {\n  if (!translucentTileClassification._hasTranslucentDepth) {\n    return;\n  }\n\n  const framebuffer = passState.framebuffer;\n\n  passState.framebuffer =\n    translucentTileClassification._drawClassificationFBO.framebuffer;\n  translucentTileClassification._clearColorCommand.execute(\n    scene._context,\n    passState\n  );\n\n  passState.framebuffer = framebuffer;\n\n  if (translucentTileClassification._frustumsDrawn > 1) {\n    passState.framebuffer =\n      translucentTileClassification._accumulationFBO.framebuffer;\n    translucentTileClassification._clearColorCommand.execute(\n      scene._context,\n      passState\n    );\n  }\n\n  translucentTileClassification._hasTranslucentDepth = false;\n  translucentTileClassification._frustumsDrawn = 0;\n}\n\nTranslucentTileClassification.prototype.isSupported = function () {\n  return this._supported;\n};\n\nTranslucentTileClassification.prototype.isDestroyed = function () {\n  return false;\n};\n\nTranslucentTileClassification.prototype.destroy = function () {\n  destroyTextures(this);\n  destroyFramebuffers(this);\n\n  if (defined(this._compositeCommand)) {\n    this._compositeCommand.shaderProgram =\n      this._compositeCommand.shaderProgram &&\n      this._compositeCommand.shaderProgram.destroy();\n  }\n\n  if (defined(this._packDepthCommand)) {\n    this._packDepthCommand.shaderProgram =\n      this._packDepthCommand.shaderProgram &&\n      this._packDepthCommand.shaderProgram.destroy();\n  }\n  return destroyObject(this);\n};\n\nexport default TranslucentTileClassification;\n","import clone from \"../Core/clone.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport TimeConstants from \"../Core/TimeConstants.js\";\nimport TweenJS from \"../ThirdParty/Tween.js\";\n\n/**\n * A tween is an animation that interpolates the properties of two objects using an {@link EasingFunction}.  Create\n * one using {@link Scene#tweens} and {@link TweenCollection#add} and related add functions.\n *\n * @alias Tween\n * @constructor\n *\n * @private\n */\nfunction Tween(\n  tweens,\n  tweenjs,\n  startObject,\n  stopObject,\n  duration,\n  delay,\n  easingFunction,\n  update,\n  complete,\n  cancel\n) {\n  this._tweens = tweens;\n  this._tweenjs = tweenjs;\n\n  this._startObject = clone(startObject);\n  this._stopObject = clone(stopObject);\n\n  this._duration = duration;\n  this._delay = delay;\n  this._easingFunction = easingFunction;\n\n  this._update = update;\n  this._complete = complete;\n\n  /**\n   * The callback to call if the tween is canceled either because {@link Tween#cancelTween}\n   * was called or because the tween was removed from the collection.\n   *\n   * @type {TweenCollection.TweenCancelledCallback}\n   */\n  this.cancel = cancel;\n\n  /**\n   * @private\n   */\n  this.needsStart = true;\n}\n\nObject.defineProperties(Tween.prototype, {\n  /**\n   * An object with properties for initial values of the tween.  The properties of this object are changed during the tween's animation.\n   * @memberof Tween.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  startObject: {\n    get: function () {\n      return this._startObject;\n    },\n  },\n\n  /**\n   * An object with properties for the final values of the tween.\n   * @memberof Tween.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  stopObject: {\n    get: function () {\n      return this._stopObject;\n    },\n  },\n\n  /**\n   * The duration, in seconds, for the tween.  The tween is automatically removed from the collection when it stops.\n   * @memberof Tween.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  duration: {\n    get: function () {\n      return this._duration;\n    },\n  },\n\n  /**\n   * The delay, in seconds, before the tween starts animating.\n   * @memberof Tween.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  delay: {\n    get: function () {\n      return this._delay;\n    },\n  },\n\n  /**\n   * Determines the curve for animtion.\n   * @memberof Tween.prototype\n   *\n   * @type {EasingFunction}\n   * @readonly\n   */\n  easingFunction: {\n    get: function () {\n      return this._easingFunction;\n    },\n  },\n\n  /**\n   * The callback to call at each animation update (usually tied to the a rendered frame).\n   * @memberof Tween.prototype\n   *\n   * @type {TweenCollection.TweenUpdateCallback}\n   * @readonly\n   */\n  update: {\n    get: function () {\n      return this._update;\n    },\n  },\n\n  /**\n   * The callback to call when the tween finishes animating.\n   * @memberof Tween.prototype\n   *\n   * @type {TweenCollection.TweenCompleteCallback}\n   * @readonly\n   */\n  complete: {\n    get: function () {\n      return this._complete;\n    },\n  },\n\n  /**\n   * @memberof Tween.prototype\n   *\n   * @private\n   */\n  tweenjs: {\n    get: function () {\n      return this._tweenjs;\n    },\n  },\n});\n\n/**\n * Cancels the tween calling the {@link Tween#cancel} callback if one exists.  This\n * has no effect if the tween finished or was already canceled.\n */\nTween.prototype.cancelTween = function () {\n  this._tweens.remove(this);\n};\n\n/**\n * A collection of tweens for animating properties.  Commonly accessed using {@link Scene#tweens}.\n *\n * @alias TweenCollection\n * @constructor\n *\n * @private\n */\nfunction TweenCollection() {\n  this._tweens = [];\n}\n\nObject.defineProperties(TweenCollection.prototype, {\n  /**\n   * The number of tweens in the collection.\n   * @memberof TweenCollection.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._tweens.length;\n    },\n  },\n});\n\n/**\n * Creates a tween for animating between two sets of properties.  The tween starts animating at the next call to {@link TweenCollection#update}, which\n * is implicit when {@link Viewer} or {@link CesiumWidget} render the scene.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Object} options.startObject An object with properties for initial values of the tween.  The properties of this object are changed during the tween's animation.\n * @param {Object} options.stopObject An object with properties for the final values of the tween.\n * @param {Number} options.duration The duration, in seconds, for the tween.  The tween is automatically removed from the collection when it stops.\n * @param {Number} [options.delay=0.0] The delay, in seconds, before the tween starts animating.\n * @param {EasingFunction} [options.easingFunction=EasingFunction.LINEAR_NONE] Determines the curve for animtion.\n * @param {TweenCollection.TweenUpdateCallback} [options.update] The callback to call at each animation update (usually tied to the a rendered frame).\n * @param {TweenCollection.TweenCompleteCallback} [options.complete] The callback to call when the tween finishes animating.\n * @param {TweenCollection.TweenCancelledCallback} [options.cancel] The callback to call if the tween is canceled either because {@link Tween#cancelTween} was called or because the tween was removed from the collection.\n * @returns {Tween} The tween.\n *\n * @exception {DeveloperError} options.duration must be positive.\n */\nTweenCollection.prototype.add = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.startObject) || !defined(options.stopObject)) {\n    throw new DeveloperError(\n      \"options.startObject and options.stopObject are required.\"\n    );\n  }\n\n  if (!defined(options.duration) || options.duration < 0.0) {\n    throw new DeveloperError(\n      \"options.duration is required and must be positive.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (options.duration === 0.0) {\n    if (defined(options.complete)) {\n      options.complete();\n    }\n    return new Tween(this);\n  }\n\n  const duration = options.duration / TimeConstants.SECONDS_PER_MILLISECOND;\n  const delayInSeconds = defaultValue(options.delay, 0.0);\n  const delay = delayInSeconds / TimeConstants.SECONDS_PER_MILLISECOND;\n  const easingFunction = defaultValue(\n    options.easingFunction,\n    EasingFunction.LINEAR_NONE\n  );\n\n  const value = options.startObject;\n  const tweenjs = new TweenJS.Tween(value);\n  tweenjs.to(clone(options.stopObject), duration);\n  tweenjs.delay(delay);\n  tweenjs.easing(easingFunction);\n  if (defined(options.update)) {\n    tweenjs.onUpdate(function () {\n      options.update(value);\n    });\n  }\n  tweenjs.onComplete(defaultValue(options.complete, null));\n  tweenjs.repeat(defaultValue(options._repeat, 0.0));\n\n  const tween = new Tween(\n    this,\n    tweenjs,\n    options.startObject,\n    options.stopObject,\n    options.duration,\n    delayInSeconds,\n    easingFunction,\n    options.update,\n    options.complete,\n    options.cancel\n  );\n  this._tweens.push(tween);\n  return tween;\n};\n\n/**\n * Creates a tween for animating a scalar property on the given object.  The tween starts animating at the next call to {@link TweenCollection#update}, which\n * is implicit when {@link Viewer} or {@link CesiumWidget} render the scene.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Object} options.object The object containing the property to animate.\n * @param {String} options.property The name of the property to animate.\n * @param {Number} options.startValue The initial value.\n * @param {Number} options.stopValue The final value.\n * @param {Number} [options.duration=3.0] The duration, in seconds, for the tween.  The tween is automatically removed from the collection when it stops.\n * @param {Number} [options.delay=0.0] The delay, in seconds, before the tween starts animating.\n * @param {EasingFunction} [options.easingFunction=EasingFunction.LINEAR_NONE] Determines the curve for animtion.\n * @param {TweenCollection.TweenUpdateCallback} [options.update] The callback to call at each animation update (usually tied to the a rendered frame).\n * @param {TweenCollection.TweenCompleteCallback} [options.complete] The callback to call when the tween finishes animating.\n * @param {TweenCollection.TweenCancelledCallback} [options.cancel] The callback to call if the tween is canceled either because {@link Tween#cancelTween} was called or because the tween was removed from the collection.\n * @returns {Tween} The tween.\n *\n * @exception {DeveloperError} options.object must have the specified property.\n * @exception {DeveloperError} options.duration must be positive.\n */\nTweenCollection.prototype.addProperty = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const object = options.object;\n  const property = options.property;\n  const startValue = options.startValue;\n  const stopValue = options.stopValue;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(object) || !defined(options.property)) {\n    throw new DeveloperError(\n      \"options.object and options.property are required.\"\n    );\n  }\n  if (!defined(object[property])) {\n    throw new DeveloperError(\n      \"options.object must have the specified property.\"\n    );\n  }\n  if (!defined(startValue) || !defined(stopValue)) {\n    throw new DeveloperError(\n      \"options.startValue and options.stopValue are required.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  function update(value) {\n    object[property] = value.value;\n  }\n\n  return this.add({\n    startObject: {\n      value: startValue,\n    },\n    stopObject: {\n      value: stopValue,\n    },\n    duration: defaultValue(options.duration, 3.0),\n    delay: options.delay,\n    easingFunction: options.easingFunction,\n    update: update,\n    complete: options.complete,\n    cancel: options.cancel,\n    _repeat: options._repeat,\n  });\n};\n\n/**\n * Creates a tween for animating the alpha of all color uniforms on a {@link Material}.  The tween starts animating at the next call to {@link TweenCollection#update}, which\n * is implicit when {@link Viewer} or {@link CesiumWidget} render the scene.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Material} options.material The material to animate.\n * @param {Number} [options.startValue=0.0] The initial alpha value.\n * @param {Number} [options.stopValue=1.0] The final alpha value.\n * @param {Number} [options.duration=3.0] The duration, in seconds, for the tween.  The tween is automatically removed from the collection when it stops.\n * @param {Number} [options.delay=0.0] The delay, in seconds, before the tween starts animating.\n * @param {EasingFunction} [options.easingFunction=EasingFunction.LINEAR_NONE] Determines the curve for animtion.\n * @param {TweenCollection.TweenUpdateCallback} [options.update] The callback to call at each animation update (usually tied to the a rendered frame).\n * @param {TweenCollection.TweenCompleteCallback} [options.complete] The callback to call when the tween finishes animating.\n * @param {TweenCollection.TweenCancelledCallback} [options.cancel] The callback to call if the tween is canceled either because {@link Tween#cancelTween} was called or because the tween was removed from the collection.\n * @returns {Tween} The tween.\n *\n * @exception {DeveloperError} material has no properties with alpha components.\n * @exception {DeveloperError} options.duration must be positive.\n */\nTweenCollection.prototype.addAlpha = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const material = options.material;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(material)) {\n    throw new DeveloperError(\"options.material is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const properties = [];\n\n  for (const property in material.uniforms) {\n    if (\n      material.uniforms.hasOwnProperty(property) &&\n      defined(material.uniforms[property]) &&\n      defined(material.uniforms[property].alpha)\n    ) {\n      properties.push(property);\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (properties.length === 0) {\n    throw new DeveloperError(\n      \"material has no properties with alpha components.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  function update(value) {\n    const length = properties.length;\n    for (let i = 0; i < length; ++i) {\n      material.uniforms[properties[i]].alpha = value.alpha;\n    }\n  }\n\n  return this.add({\n    startObject: {\n      alpha: defaultValue(options.startValue, 0.0), // Default to fade in\n    },\n    stopObject: {\n      alpha: defaultValue(options.stopValue, 1.0),\n    },\n    duration: defaultValue(options.duration, 3.0),\n    delay: options.delay,\n    easingFunction: options.easingFunction,\n    update: update,\n    complete: options.complete,\n    cancel: options.cancel,\n  });\n};\n\n/**\n * Creates a tween for animating the offset uniform of a {@link Material}.  The tween starts animating at the next call to {@link TweenCollection#update}, which\n * is implicit when {@link Viewer} or {@link CesiumWidget} render the scene.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Material} options.material The material to animate.\n * @param {Number} options.startValue The initial alpha value.\n * @param {Number} options.stopValue The final alpha value.\n * @param {Number} [options.duration=3.0] The duration, in seconds, for the tween.  The tween is automatically removed from the collection when it stops.\n * @param {Number} [options.delay=0.0] The delay, in seconds, before the tween starts animating.\n * @param {EasingFunction} [options.easingFunction=EasingFunction.LINEAR_NONE] Determines the curve for animtion.\n * @param {TweenCollection.TweenUpdateCallback} [options.update] The callback to call at each animation update (usually tied to the a rendered frame).\n * @param {TweenCollection.TweenCancelledCallback} [options.cancel] The callback to call if the tween is canceled either because {@link Tween#cancelTween} was called or because the tween was removed from the collection.\n * @returns {Tween} The tween.\n *\n * @exception {DeveloperError} material.uniforms must have an offset property.\n * @exception {DeveloperError} options.duration must be positive.\n */\nTweenCollection.prototype.addOffsetIncrement = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const material = options.material;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(material)) {\n    throw new DeveloperError(\"material is required.\");\n  }\n  if (!defined(material.uniforms.offset)) {\n    throw new DeveloperError(\"material.uniforms must have an offset property.\");\n  }\n  //>>includeEnd('debug');\n\n  const uniforms = material.uniforms;\n  return this.addProperty({\n    object: uniforms,\n    property: \"offset\",\n    startValue: uniforms.offset,\n    stopValue: uniforms.offset + 1,\n    duration: options.duration,\n    delay: options.delay,\n    easingFunction: options.easingFunction,\n    update: options.update,\n    cancel: options.cancel,\n    _repeat: Infinity,\n  });\n};\n\n/**\n * Removes a tween from the collection.\n * <p>\n * This calls the {@link Tween#cancel} callback if the tween has one.\n * </p>\n *\n * @param {Tween} tween The tween to remove.\n * @returns {Boolean} <code>true</code> if the tween was removed; <code>false</code> if the tween was not found in the collection.\n */\nTweenCollection.prototype.remove = function (tween) {\n  if (!defined(tween)) {\n    return false;\n  }\n\n  const index = this._tweens.indexOf(tween);\n  if (index !== -1) {\n    tween.tweenjs.stop();\n    if (defined(tween.cancel)) {\n      tween.cancel();\n    }\n    this._tweens.splice(index, 1);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all tweens from the collection.\n * <p>\n * This calls the {@link Tween#cancel} callback for each tween that has one.\n * </p>\n */\nTweenCollection.prototype.removeAll = function () {\n  const tweens = this._tweens;\n\n  for (let i = 0; i < tweens.length; ++i) {\n    const tween = tweens[i];\n    tween.tweenjs.stop();\n    if (defined(tween.cancel)) {\n      tween.cancel();\n    }\n  }\n  tweens.length = 0;\n};\n\n/**\n * Determines whether this collection contains a given tween.\n *\n * @param {Tween} tween The tween to check for.\n * @returns {Boolean} <code>true</code> if this collection contains the tween, <code>false</code> otherwise.\n */\nTweenCollection.prototype.contains = function (tween) {\n  return defined(tween) && this._tweens.indexOf(tween) !== -1;\n};\n\n/**\n * Returns the tween in the collection at the specified index.  Indices are zero-based\n * and increase as tweens are added.  Removing a tween shifts all tweens after\n * it to the left, changing their indices.  This function is commonly used to iterate over\n * all the tween in the collection.\n *\n * @param {Number} index The zero-based index of the tween.\n * @returns {Tween} The tween at the specified index.\n *\n * @example\n * // Output the duration of all the tweens in the collection.\n * const tweens = scene.tweens;\n * const length = tweens.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(tweens.get(i).duration);\n * }\n */\nTweenCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._tweens[index];\n};\n\n/**\n * Updates the tweens in the collection to be at the provide time.  When a tween finishes, it is removed\n * from the collection.\n *\n * @param {Number} [time=getTimestamp()] The time in seconds.  By default tweens are synced to the system clock.\n */\nTweenCollection.prototype.update = function (time) {\n  const tweens = this._tweens;\n\n  let i = 0;\n  time = defined(time)\n    ? time / TimeConstants.SECONDS_PER_MILLISECOND\n    : getTimestamp();\n  while (i < tweens.length) {\n    const tween = tweens[i];\n    const tweenjs = tween.tweenjs;\n\n    if (tween.needsStart) {\n      tween.needsStart = false;\n      tweenjs.start(time);\n    } else if (tweenjs.update(time)) {\n      i++;\n    } else {\n      tweenjs.stop();\n      tweens.splice(i, 1);\n    }\n  }\n};\n\n/**\n * A function that will execute when a tween completes.\n * @callback TweenCollection.TweenCompleteCallback\n */\n\n/**\n * A function that will execute when a tween updates.\n * @callback TweenCollection.TweenUpdateCallback\n */\n\n/**\n * A function that will execute when a tween is cancelled.\n * @callback TweenCollection.TweenCancelledCallback\n */\nexport default TweenCollection;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport combine from \"../Core/combine.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport ImageryProvider from \"./ImageryProvider.js\";\n\nconst templateRegex = /{[^}]+}/g;\n\nconst tags = {\n  x: xTag,\n  y: yTag,\n  z: zTag,\n  s: sTag,\n  reverseX: reverseXTag,\n  reverseY: reverseYTag,\n  reverseZ: reverseZTag,\n  westDegrees: westDegreesTag,\n  southDegrees: southDegreesTag,\n  eastDegrees: eastDegreesTag,\n  northDegrees: northDegreesTag,\n  westProjected: westProjectedTag,\n  southProjected: southProjectedTag,\n  eastProjected: eastProjectedTag,\n  northProjected: northProjectedTag,\n  width: widthTag,\n  height: heightTag,\n};\n\nconst pickFeaturesTags = combine(tags, {\n  i: iTag,\n  j: jTag,\n  reverseI: reverseITag,\n  reverseJ: reverseJTag,\n  longitudeDegrees: longitudeDegreesTag,\n  latitudeDegrees: latitudeDegreesTag,\n  longitudeProjected: longitudeProjectedTag,\n  latitudeProjected: latitudeProjectedTag,\n  format: formatTag,\n});\n\n/**\n * @typedef {Object} UrlTemplateImageryProvider.ConstructorOptions\n *\n * Initialization options for the UrlTemplateImageryProvider constructor\n *\n * @property {Promise.<Object>|Object} [options] Object with the following properties:\n * @property {Resource|String} url  The URL template to use to request tiles.  It has the following keywords:\n * <ul>\n *     <li><code>{z}</code>: The level of the tile in the tiling scheme.  Level zero is the root of the quadtree pyramid.</li>\n *     <li><code>{x}</code>: The tile X coordinate in the tiling scheme, where 0 is the Westernmost tile.</li>\n *     <li><code>{y}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Northernmost tile.</li>\n *     <li><code>{s}</code>: One of the available subdomains, used to overcome browser limits on the number of simultaneous requests per host.</li>\n *     <li><code>{reverseX}</code>: The tile X coordinate in the tiling scheme, where 0 is the Easternmost tile.</li>\n *     <li><code>{reverseY}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Southernmost tile.</li>\n *     <li><code>{reverseZ}</code>: The level of the tile in the tiling scheme, where level zero is the maximum level of the quadtree pyramid.  In order to use reverseZ, maximumLevel must be defined.</li>\n *     <li><code>{westDegrees}</code>: The Western edge of the tile in geodetic degrees.</li>\n *     <li><code>{southDegrees}</code>: The Southern edge of the tile in geodetic degrees.</li>\n *     <li><code>{eastDegrees}</code>: The Eastern edge of the tile in geodetic degrees.</li>\n *     <li><code>{northDegrees}</code>: The Northern edge of the tile in geodetic degrees.</li>\n *     <li><code>{westProjected}</code>: The Western edge of the tile in projected coordinates of the tiling scheme.</li>\n *     <li><code>{southProjected}</code>: The Southern edge of the tile in projected coordinates of the tiling scheme.</li>\n *     <li><code>{eastProjected}</code>: The Eastern edge of the tile in projected coordinates of the tiling scheme.</li>\n *     <li><code>{northProjected}</code>: The Northern edge of the tile in projected coordinates of the tiling scheme.</li>\n *     <li><code>{width}</code>: The width of each tile in pixels.</li>\n *     <li><code>{height}</code>: The height of each tile in pixels.</li>\n * </ul>\n * @property {Resource|String} [pickFeaturesUrl] The URL template to use to pick features.  If this property is not specified,\n *                 {@link UrlTemplateImageryProvider#pickFeatures} will immediately returned undefined, indicating no\n *                 features picked.  The URL template supports all of the keywords supported by the <code>url</code>\n *                 parameter, plus the following:\n * <ul>\n *     <li><code>{i}</code>: The pixel column (horizontal coordinate) of the picked position, where the Westernmost pixel is 0.</li>\n *     <li><code>{j}</code>: The pixel row (vertical coordinate) of the picked position, where the Northernmost pixel is 0.</li>\n *     <li><code>{reverseI}</code>: The pixel column (horizontal coordinate) of the picked position, where the Easternmost pixel is 0.</li>\n *     <li><code>{reverseJ}</code>: The pixel row (vertical coordinate) of the picked position, where the Southernmost pixel is 0.</li>\n *     <li><code>{longitudeDegrees}</code>: The longitude of the picked position in degrees.</li>\n *     <li><code>{latitudeDegrees}</code>: The latitude of the picked position in degrees.</li>\n *     <li><code>{longitudeProjected}</code>: The longitude of the picked position in the projected coordinates of the tiling scheme.</li>\n *     <li><code>{latitudeProjected}</code>: The latitude of the picked position in the projected coordinates of the tiling scheme.</li>\n *     <li><code>{format}</code>: The format in which to get feature information, as specified in the {@link GetFeatureInfoFormat}.</li>\n * </ul>\n * @property {Object} [urlSchemeZeroPadding] Gets the URL scheme zero padding for each tile coordinate. The format is '000' where\n * each coordinate will be padded on the left with zeros to match the width of the passed string of zeros. e.g. Setting:\n * urlSchemeZeroPadding : { '{x}' : '0000'}\n * will cause an 'x' value of 12 to return the string '0012' for {x} in the generated URL.\n * It the passed object has the following keywords:\n * <ul>\n *  <li> <code>{z}</code>: The zero padding for the level of the tile in the tiling scheme.</li>\n *  <li> <code>{x}</code>: The zero padding for the tile X coordinate in the tiling scheme.</li>\n *  <li> <code>{y}</code>: The zero padding for the the tile Y coordinate in the tiling scheme.</li>\n *  <li> <code>{reverseX}</code>: The zero padding for the tile reverseX coordinate in the tiling scheme.</li>\n *  <li> <code>{reverseY}</code>: The zero padding for the tile reverseY coordinate in the tiling scheme.</li>\n *  <li> <code>{reverseZ}</code>: The zero padding for the reverseZ coordinate of the tile in the tiling scheme.</li>\n * </ul>\n * @property {String|String[]} [subdomains='abc'] The subdomains to use for the <code>{s}</code> placeholder in the URL template.\n *                          If this parameter is a single string, each character in the string is a subdomain.  If it is\n *                          an array, each element in the array is a subdomain.\n * @property {Credit|String} [credit=''] A credit for the data source, which is displayed on the canvas.\n * @property {Number} [minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @property {Number} [maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.\n * @property {Rectangle} [rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @property {TilingScheme} [tilingScheme=WebMercatorTilingScheme] The tiling scheme specifying how the ellipsoidal\n * surface is broken into tiles.  If this parameter is not provided, a {@link WebMercatorTilingScheme}\n * is used.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n *                    parameter is specified, the WGS84 ellipsoid is used.\n * @property {Number} [tileWidth=256] Pixel width of image tiles.\n * @property {Number} [tileHeight=256] Pixel height of image tiles.\n * @property {Boolean} [hasAlphaChannel=true] true if the images provided by this imagery provider\n *                  include an alpha channel; otherwise, false.  If this property is false, an alpha channel, if\n *                  present, will be ignored.  If this property is true, any images without an alpha channel will\n *                  be treated as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n *                  and texture upload time are potentially reduced.\n * @property {GetFeatureInfoFormat[]} [getFeatureInfoFormats] The formats in which to get feature information at a\n *                                 specific location when {@link UrlTemplateImageryProvider#pickFeatures} is invoked.  If this\n *                                 parameter is not specified, feature picking is disabled.\n * @property {Boolean} [enablePickFeatures=true] If true, {@link UrlTemplateImageryProvider#pickFeatures} will\n *        request the <code>pickFeaturesUrl</code> and attempt to interpret the features included in the response.  If false,\n *        {@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable\n *        features) without communicating with the server.  Set this property to false if you know your data\n *        source does not support picking features or if you don't want this provider's features to be pickable. Note\n *        that this can be dynamically overridden by modifying the {@link UriTemplateImageryProvider#enablePickFeatures}\n *        property.\n * @property {Object} [customTags] Allow to replace custom keywords in the URL template. The object must have strings as keys and functions as values.\n */\n\n/**\n * Provides imagery by requesting tiles using a specified URL template.\n *\n * @alias UrlTemplateImageryProvider\n * @constructor\n *\n * @param {UrlTemplateImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @example\n * // Access Natural Earth II imagery, which uses a TMS tiling scheme and Geographic (EPSG:4326) project\n * const tms = new Cesium.UrlTemplateImageryProvider({\n *     url : Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII') + '/{z}/{x}/{reverseY}.jpg',\n *     credit : '© Analytical Graphics, Inc.',\n *     tilingScheme : new Cesium.GeographicTilingScheme(),\n *     maximumLevel : 5\n * });\n * // Access the CartoDB Positron basemap, which uses an OpenStreetMap-like tiling scheme.\n * const positron = new Cesium.UrlTemplateImageryProvider({\n *     url : 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',\n *     credit : 'Map tiles by CartoDB, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'\n * });\n * // Access a Web Map Service (WMS) server.\n * const wms = new Cesium.UrlTemplateImageryProvider({\n *    url : 'https://programs.communications.gov.au/geoserver/ows?tiled=true&' +\n *          'transparent=true&format=image%2Fpng&exceptions=application%2Fvnd.ogc.se_xml&' +\n *          'styles=&service=WMS&version=1.1.1&request=GetMap&' +\n *          'layers=public%3AMyBroadband_Availability&srs=EPSG%3A3857&' +\n *          'bbox={westProjected}%2C{southProjected}%2C{eastProjected}%2C{northProjected}&' +\n *          'width=256&height=256',\n *    rectangle : Cesium.Rectangle.fromDegrees(96.799393, -43.598214999057824, 153.63925700000001, -9.2159219997013)\n * });\n * // Using custom tags in your template url.\n * const custom = new Cesium.UrlTemplateImageryProvider({\n *    url : 'https://yoururl/{Time}/{z}/{y}/{x}.png',\n *    customTags : {\n *        Time: function(imageryProvider, x, y, level) {\n *            return '20171231'\n *        }\n *    }\n * });\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n */\nfunction UrlTemplateImageryProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.then) && !defined(options.url)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._errorEvent = new Event();\n\n  this._resource = undefined;\n  this._urlSchemeZeroPadding = undefined;\n  this._pickFeaturesResource = undefined;\n  this._tileWidth = undefined;\n  this._tileHeight = undefined;\n  this._maximumLevel = undefined;\n  this._minimumLevel = undefined;\n  this._tilingScheme = undefined;\n  this._rectangle = undefined;\n  this._tileDiscardPolicy = undefined;\n  this._credit = undefined;\n  this._hasAlphaChannel = undefined;\n  this._readyPromise = undefined;\n  this._tags = undefined;\n  this._pickFeaturesTags = undefined;\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  /**\n   * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link UrlTemplateImageryProvider#pickFeatures} will\n   * request the <code>options.pickFeaturesUrl</code> and attempt to interpret the features included in the response.  If false,\n   * {@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable\n   * features) without communicating with the server.  Set this property to false if you know your data\n   * source does not support picking features or if you don't want this provider's features to be pickable.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enablePickFeatures = true;\n\n  this.reinitialize(options);\n}\n\nObject.defineProperties(UrlTemplateImageryProvider.prototype, {\n  /**\n   * Gets the URL template to use to request tiles.  It has the following keywords:\n   * <ul>\n   *  <li> <code>{z}</code>: The level of the tile in the tiling scheme.  Level zero is the root of the quadtree pyramid.</li>\n   *  <li> <code>{x}</code>: The tile X coordinate in the tiling scheme, where 0 is the Westernmost tile.</li>\n   *  <li> <code>{y}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Northernmost tile.</li>\n   *  <li> <code>{s}</code>: One of the available subdomains, used to overcome browser limits on the number of simultaneous requests per host.</li>\n   *  <li> <code>{reverseX}</code>: The tile X coordinate in the tiling scheme, where 0 is the Easternmost tile.</li>\n   *  <li> <code>{reverseY}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Southernmost tile.</li>\n   *  <li> <code>{reverseZ}</code>: The level of the tile in the tiling scheme, where level zero is the maximum level of the quadtree pyramid.  In order to use reverseZ, maximumLevel must be defined.</li>\n   *  <li> <code>{westDegrees}</code>: The Western edge of the tile in geodetic degrees.</li>\n   *  <li> <code>{southDegrees}</code>: The Southern edge of the tile in geodetic degrees.</li>\n   *  <li> <code>{eastDegrees}</code>: The Eastern edge of the tile in geodetic degrees.</li>\n   *  <li> <code>{northDegrees}</code>: The Northern edge of the tile in geodetic degrees.</li>\n   *  <li> <code>{westProjected}</code>: The Western edge of the tile in projected coordinates of the tiling scheme.</li>\n   *  <li> <code>{southProjected}</code>: The Southern edge of the tile in projected coordinates of the tiling scheme.</li>\n   *  <li> <code>{eastProjected}</code>: The Eastern edge of the tile in projected coordinates of the tiling scheme.</li>\n   *  <li> <code>{northProjected}</code>: The Northern edge of the tile in projected coordinates of the tiling scheme.</li>\n   *  <li> <code>{width}</code>: The width of each tile in pixels.</li>\n   *  <li> <code>{height}</code>: The height of each tile in pixels.</li>\n   * </ul>\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._resource.url;\n    },\n  },\n\n  /**\n   * Gets the URL scheme zero padding for each tile coordinate. The format is '000' where each coordinate will be padded on\n   * the left with zeros to match the width of the passed string of zeros. e.g. Setting:\n   * urlSchemeZeroPadding : { '{x}' : '0000'}\n   * will cause an 'x' value of 12 to return the string '0012' for {x} in the generated URL.\n   * It has the following keywords:\n   * <ul>\n   *  <li> <code>{z}</code>: The zero padding for the level of the tile in the tiling scheme.</li>\n   *  <li> <code>{x}</code>: The zero padding for the tile X coordinate in the tiling scheme.</li>\n   *  <li> <code>{y}</code>: The zero padding for the the tile Y coordinate in the tiling scheme.</li>\n   *  <li> <code>{reverseX}</code>: The zero padding for the tile reverseX coordinate in the tiling scheme.</li>\n   *  <li> <code>{reverseY}</code>: The zero padding for the tile reverseY coordinate in the tiling scheme.</li>\n   *  <li> <code>{reverseZ}</code>: The zero padding for the reverseZ coordinate of the tile in the tiling scheme.</li>\n   * </ul>\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Object}\n   * @readonly\n   */\n  urlSchemeZeroPadding: {\n    get: function () {\n      return this._urlSchemeZeroPadding;\n    },\n  },\n\n  /**\n   * Gets the URL template to use to use to pick features.  If this property is not specified,\n   * {@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined, indicating no\n   * features picked.  The URL template supports all of the keywords supported by the\n   * {@link UrlTemplateImageryProvider#url} property, plus the following:\n   * <ul>\n   *     <li><code>{i}</code>: The pixel column (horizontal coordinate) of the picked position, where the Westernmost pixel is 0.</li>\n   *     <li><code>{j}</code>: The pixel row (vertical coordinate) of the picked position, where the Northernmost pixel is 0.</li>\n   *     <li><code>{reverseI}</code>: The pixel column (horizontal coordinate) of the picked position, where the Easternmost pixel is 0.</li>\n   *     <li><code>{reverseJ}</code>: The pixel row (vertical coordinate) of the picked position, where the Southernmost pixel is 0.</li>\n   *     <li><code>{longitudeDegrees}</code>: The longitude of the picked position in degrees.</li>\n   *     <li><code>{latitudeDegrees}</code>: The latitude of the picked position in degrees.</li>\n   *     <li><code>{longitudeProjected}</code>: The longitude of the picked position in the projected coordinates of the tiling scheme.</li>\n   *     <li><code>{latitudeProjected}</code>: The latitude of the picked position in the projected coordinates of the tiling scheme.</li>\n   *     <li><code>{format}</code>: The format in which to get feature information, as specified in the {@link GetFeatureInfoFormat}.</li>\n   * </ul>\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  pickFeaturesUrl: {\n    get: function () {\n      return this._pickFeaturesResource.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   * @default undefined\n   */\n  proxy: {\n    get: function () {\n      return this._resource.proxy;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link UrlTemplateImageryProvider#ready} returns true.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   * @default 256\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"tileWidth must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link UrlTemplateImageryProvider#ready} returns true.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   * @default 256\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested, or undefined if there is no limit.\n   * This function should not be called before {@link UrlTemplateImageryProvider#ready} returns true.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   * @default undefined\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"maximumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link UrlTemplateImageryProvider#ready} returns true.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   * @default 0\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"minimumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._minimumLevel;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link UrlTemplateImageryProvider#ready} returns true.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   * @default new WebMercatorTilingScheme()\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link UrlTemplateImageryProvider#ready} returns true.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   * @default tilingScheme.rectangle\n   */\n  rectangle: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"rectangle must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link UrlTemplateImageryProvider#ready} returns true.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   * @default undefined\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"tileDiscardPolicy must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return defined(this._resource);\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link UrlTemplateImageryProvider#ready} returns true.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   * @default undefined\n   */\n  credit: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"credit must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.  This function should\n   * not be called before {@link ImageryProvider#ready} returns true.\n   * @memberof UrlTemplateImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   * @default true\n   */\n  hasAlphaChannel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this.ready) {\n        throw new DeveloperError(\n          \"hasAlphaChannel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._hasAlphaChannel;\n    },\n  },\n});\n\n/**\n * Reinitializes this instance.  Reinitializing an instance already in use is supported, but it is not\n * recommended because existing tiles provided by the imagery provider will not be updated.\n *\n * @param {Promise.<Object>|Object} options Any of the options that may be passed to the {@link UrlTemplateImageryProvider} constructor.\n */\nUrlTemplateImageryProvider.prototype.reinitialize = function (options) {\n  const that = this;\n  that._readyPromise = Promise.resolve(options).then(function (properties) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(properties)) {\n      throw new DeveloperError(\"options is required.\");\n    }\n    if (!defined(properties.url)) {\n      throw new DeveloperError(\"options.url is required.\");\n    }\n    //>>includeEnd('debug');\n\n    const customTags = properties.customTags;\n    const allTags = combine(tags, customTags);\n    const allPickFeaturesTags = combine(pickFeaturesTags, customTags);\n    const resource = Resource.createIfNeeded(properties.url);\n    const pickFeaturesResource = Resource.createIfNeeded(\n      properties.pickFeaturesUrl\n    );\n\n    that.enablePickFeatures = defaultValue(\n      properties.enablePickFeatures,\n      that.enablePickFeatures\n    );\n    that._urlSchemeZeroPadding = defaultValue(\n      properties.urlSchemeZeroPadding,\n      that.urlSchemeZeroPadding\n    );\n    that._tileDiscardPolicy = properties.tileDiscardPolicy;\n    that._getFeatureInfoFormats = properties.getFeatureInfoFormats;\n\n    that._subdomains = properties.subdomains;\n    if (Array.isArray(that._subdomains)) {\n      that._subdomains = that._subdomains.slice();\n    } else if (defined(that._subdomains) && that._subdomains.length > 0) {\n      that._subdomains = that._subdomains.split(\"\");\n    } else {\n      that._subdomains = [\"a\", \"b\", \"c\"];\n    }\n\n    that._tileWidth = defaultValue(properties.tileWidth, 256);\n    that._tileHeight = defaultValue(properties.tileHeight, 256);\n    that._minimumLevel = defaultValue(properties.minimumLevel, 0);\n    that._maximumLevel = properties.maximumLevel;\n    that._tilingScheme = defaultValue(\n      properties.tilingScheme,\n      new WebMercatorTilingScheme({ ellipsoid: properties.ellipsoid })\n    );\n    that._rectangle = defaultValue(\n      properties.rectangle,\n      that._tilingScheme.rectangle\n    );\n    that._rectangle = Rectangle.intersection(\n      that._rectangle,\n      that._tilingScheme.rectangle\n    );\n    that._hasAlphaChannel = defaultValue(properties.hasAlphaChannel, true);\n\n    let credit = properties.credit;\n    if (typeof credit === \"string\") {\n      credit = new Credit(credit);\n    }\n    that._credit = credit;\n\n    that._resource = resource;\n    that._tags = allTags;\n    that._pickFeaturesResource = pickFeaturesResource;\n    that._pickFeaturesTags = allPickFeaturesTags;\n\n    return true;\n  });\n};\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nUrlTemplateImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this.ready) {\n    throw new DeveloperError(\n      \"getTileCredits must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link UrlTemplateImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n */\nUrlTemplateImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this.ready) {\n    throw new DeveloperError(\n      \"requestImage must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n  return ImageryProvider.loadImage(\n    this,\n    buildImageResource(this, x, y, level, request)\n  );\n};\n\n/**\n * Asynchronously determines what features, if any, are located at a given longitude and latitude within\n * a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n */\nUrlTemplateImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this.ready) {\n    throw new DeveloperError(\n      \"pickFeatures must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (\n    !this.enablePickFeatures ||\n    !defined(this._pickFeaturesResource) ||\n    this._getFeatureInfoFormats.length === 0\n  ) {\n    return undefined;\n  }\n\n  let formatIndex = 0;\n\n  const that = this;\n\n  function handleResponse(format, data) {\n    return format.callback(data);\n  }\n\n  function doRequest() {\n    if (formatIndex >= that._getFeatureInfoFormats.length) {\n      // No valid formats, so no features picked.\n      return Promise.resolve([]);\n    }\n\n    const format = that._getFeatureInfoFormats[formatIndex];\n    const resource = buildPickFeaturesResource(\n      that,\n      x,\n      y,\n      level,\n      longitude,\n      latitude,\n      format.format\n    );\n\n    ++formatIndex;\n\n    if (format.type === \"json\") {\n      return resource.fetchJson().then(format.callback).catch(doRequest);\n    } else if (format.type === \"xml\") {\n      return resource.fetchXML().then(format.callback).catch(doRequest);\n    } else if (format.type === \"text\" || format.type === \"html\") {\n      return resource.fetchText().then(format.callback).catch(doRequest);\n    }\n    return resource\n      .fetch({\n        responseType: format.format,\n      })\n      .then(handleResponse.bind(undefined, format))\n      .catch(doRequest);\n  }\n\n  return doRequest();\n};\n\nlet degreesScratchComputed = false;\nconst degreesScratch = new Rectangle();\nlet projectedScratchComputed = false;\nconst projectedScratch = new Rectangle();\n\nfunction buildImageResource(imageryProvider, x, y, level, request) {\n  degreesScratchComputed = false;\n  projectedScratchComputed = false;\n\n  const resource = imageryProvider._resource;\n  const url = resource.getUrlComponent(true);\n  const allTags = imageryProvider._tags;\n  const templateValues = {};\n\n  const match = url.match(templateRegex);\n  if (defined(match)) {\n    match.forEach(function (tag) {\n      const key = tag.substring(1, tag.length - 1); //strip {}\n      if (defined(allTags[key])) {\n        templateValues[key] = allTags[key](imageryProvider, x, y, level);\n      }\n    });\n  }\n\n  return resource.getDerivedResource({\n    request: request,\n    templateValues: templateValues,\n  });\n}\n\nlet ijScratchComputed = false;\nconst ijScratch = new Cartesian2();\nlet longitudeLatitudeProjectedScratchComputed = false;\n\nfunction buildPickFeaturesResource(\n  imageryProvider,\n  x,\n  y,\n  level,\n  longitude,\n  latitude,\n  format\n) {\n  degreesScratchComputed = false;\n  projectedScratchComputed = false;\n  ijScratchComputed = false;\n  longitudeLatitudeProjectedScratchComputed = false;\n\n  const resource = imageryProvider._pickFeaturesResource;\n  const url = resource.getUrlComponent(true);\n  const allTags = imageryProvider._pickFeaturesTags;\n  const templateValues = {};\n  const match = url.match(templateRegex);\n  if (defined(match)) {\n    match.forEach(function (tag) {\n      const key = tag.substring(1, tag.length - 1); //strip {}\n      if (defined(allTags[key])) {\n        templateValues[key] = allTags[key](\n          imageryProvider,\n          x,\n          y,\n          level,\n          longitude,\n          latitude,\n          format\n        );\n      }\n    });\n  }\n\n  return resource.getDerivedResource({\n    templateValues: templateValues,\n  });\n}\n\nfunction padWithZerosIfNecessary(imageryProvider, key, value) {\n  if (\n    imageryProvider &&\n    imageryProvider.urlSchemeZeroPadding &&\n    imageryProvider.urlSchemeZeroPadding.hasOwnProperty(key)\n  ) {\n    const paddingTemplate = imageryProvider.urlSchemeZeroPadding[key];\n    if (typeof paddingTemplate === \"string\") {\n      const paddingTemplateWidth = paddingTemplate.length;\n      if (paddingTemplateWidth > 1) {\n        value =\n          value.length >= paddingTemplateWidth\n            ? value\n            : new Array(\n                paddingTemplateWidth - value.toString().length + 1\n              ).join(\"0\") + value;\n      }\n    }\n  }\n  return value;\n}\n\nfunction xTag(imageryProvider, x, y, level) {\n  return padWithZerosIfNecessary(imageryProvider, \"{x}\", x);\n}\n\nfunction reverseXTag(imageryProvider, x, y, level) {\n  const reverseX =\n    imageryProvider.tilingScheme.getNumberOfXTilesAtLevel(level) - x - 1;\n  return padWithZerosIfNecessary(imageryProvider, \"{reverseX}\", reverseX);\n}\n\nfunction yTag(imageryProvider, x, y, level) {\n  return padWithZerosIfNecessary(imageryProvider, \"{y}\", y);\n}\n\nfunction reverseYTag(imageryProvider, x, y, level) {\n  const reverseY =\n    imageryProvider.tilingScheme.getNumberOfYTilesAtLevel(level) - y - 1;\n  return padWithZerosIfNecessary(imageryProvider, \"{reverseY}\", reverseY);\n}\n\nfunction reverseZTag(imageryProvider, x, y, level) {\n  const maximumLevel = imageryProvider.maximumLevel;\n  const reverseZ =\n    defined(maximumLevel) && level < maximumLevel\n      ? maximumLevel - level - 1\n      : level;\n  return padWithZerosIfNecessary(imageryProvider, \"{reverseZ}\", reverseZ);\n}\n\nfunction zTag(imageryProvider, x, y, level) {\n  return padWithZerosIfNecessary(imageryProvider, \"{z}\", level);\n}\n\nfunction sTag(imageryProvider, x, y, level) {\n  const index = (x + y + level) % imageryProvider._subdomains.length;\n  return imageryProvider._subdomains[index];\n}\n\nfunction computeDegrees(imageryProvider, x, y, level) {\n  if (degreesScratchComputed) {\n    return;\n  }\n\n  imageryProvider.tilingScheme.tileXYToRectangle(x, y, level, degreesScratch);\n  degreesScratch.west = CesiumMath.toDegrees(degreesScratch.west);\n  degreesScratch.south = CesiumMath.toDegrees(degreesScratch.south);\n  degreesScratch.east = CesiumMath.toDegrees(degreesScratch.east);\n  degreesScratch.north = CesiumMath.toDegrees(degreesScratch.north);\n\n  degreesScratchComputed = true;\n}\n\nfunction westDegreesTag(imageryProvider, x, y, level) {\n  computeDegrees(imageryProvider, x, y, level);\n  return degreesScratch.west;\n}\n\nfunction southDegreesTag(imageryProvider, x, y, level) {\n  computeDegrees(imageryProvider, x, y, level);\n  return degreesScratch.south;\n}\n\nfunction eastDegreesTag(imageryProvider, x, y, level) {\n  computeDegrees(imageryProvider, x, y, level);\n  return degreesScratch.east;\n}\n\nfunction northDegreesTag(imageryProvider, x, y, level) {\n  computeDegrees(imageryProvider, x, y, level);\n  return degreesScratch.north;\n}\n\nfunction computeProjected(imageryProvider, x, y, level) {\n  if (projectedScratchComputed) {\n    return;\n  }\n\n  imageryProvider.tilingScheme.tileXYToNativeRectangle(\n    x,\n    y,\n    level,\n    projectedScratch\n  );\n\n  projectedScratchComputed = true;\n}\n\nfunction westProjectedTag(imageryProvider, x, y, level) {\n  computeProjected(imageryProvider, x, y, level);\n  return projectedScratch.west;\n}\n\nfunction southProjectedTag(imageryProvider, x, y, level) {\n  computeProjected(imageryProvider, x, y, level);\n  return projectedScratch.south;\n}\n\nfunction eastProjectedTag(imageryProvider, x, y, level) {\n  computeProjected(imageryProvider, x, y, level);\n  return projectedScratch.east;\n}\n\nfunction northProjectedTag(imageryProvider, x, y, level) {\n  computeProjected(imageryProvider, x, y, level);\n  return projectedScratch.north;\n}\n\nfunction widthTag(imageryProvider, x, y, level) {\n  return imageryProvider.tileWidth;\n}\n\nfunction heightTag(imageryProvider, x, y, level) {\n  return imageryProvider.tileHeight;\n}\n\nfunction iTag(imageryProvider, x, y, level, longitude, latitude, format) {\n  computeIJ(imageryProvider, x, y, level, longitude, latitude);\n  return ijScratch.x;\n}\n\nfunction jTag(imageryProvider, x, y, level, longitude, latitude, format) {\n  computeIJ(imageryProvider, x, y, level, longitude, latitude);\n  return ijScratch.y;\n}\n\nfunction reverseITag(\n  imageryProvider,\n  x,\n  y,\n  level,\n  longitude,\n  latitude,\n  format\n) {\n  computeIJ(imageryProvider, x, y, level, longitude, latitude);\n  return imageryProvider.tileWidth - ijScratch.x - 1;\n}\n\nfunction reverseJTag(\n  imageryProvider,\n  x,\n  y,\n  level,\n  longitude,\n  latitude,\n  format\n) {\n  computeIJ(imageryProvider, x, y, level, longitude, latitude);\n  return imageryProvider.tileHeight - ijScratch.y - 1;\n}\n\nconst rectangleScratch = new Rectangle();\nconst longitudeLatitudeProjectedScratch = new Cartesian3();\n\nfunction computeIJ(imageryProvider, x, y, level, longitude, latitude, format) {\n  if (ijScratchComputed) {\n    return;\n  }\n\n  computeLongitudeLatitudeProjected(\n    imageryProvider,\n    x,\n    y,\n    level,\n    longitude,\n    latitude\n  );\n  const projected = longitudeLatitudeProjectedScratch;\n\n  const rectangle = imageryProvider.tilingScheme.tileXYToNativeRectangle(\n    x,\n    y,\n    level,\n    rectangleScratch\n  );\n  ijScratch.x =\n    ((imageryProvider.tileWidth * (projected.x - rectangle.west)) /\n      rectangle.width) |\n    0;\n  ijScratch.y =\n    ((imageryProvider.tileHeight * (rectangle.north - projected.y)) /\n      rectangle.height) |\n    0;\n  ijScratchComputed = true;\n}\n\nfunction longitudeDegreesTag(\n  imageryProvider,\n  x,\n  y,\n  level,\n  longitude,\n  latitude,\n  format\n) {\n  return CesiumMath.toDegrees(longitude);\n}\n\nfunction latitudeDegreesTag(\n  imageryProvider,\n  x,\n  y,\n  level,\n  longitude,\n  latitude,\n  format\n) {\n  return CesiumMath.toDegrees(latitude);\n}\n\nfunction longitudeProjectedTag(\n  imageryProvider,\n  x,\n  y,\n  level,\n  longitude,\n  latitude,\n  format\n) {\n  computeLongitudeLatitudeProjected(\n    imageryProvider,\n    x,\n    y,\n    level,\n    longitude,\n    latitude\n  );\n  return longitudeLatitudeProjectedScratch.x;\n}\n\nfunction latitudeProjectedTag(\n  imageryProvider,\n  x,\n  y,\n  level,\n  longitude,\n  latitude,\n  format\n) {\n  computeLongitudeLatitudeProjected(\n    imageryProvider,\n    x,\n    y,\n    level,\n    longitude,\n    latitude\n  );\n  return longitudeLatitudeProjectedScratch.y;\n}\n\nconst cartographicScratch = new Cartographic();\n\nfunction computeLongitudeLatitudeProjected(\n  imageryProvider,\n  x,\n  y,\n  level,\n  longitude,\n  latitude,\n  format\n) {\n  if (longitudeLatitudeProjectedScratchComputed) {\n    return;\n  }\n\n  if (imageryProvider.tilingScheme.projection instanceof GeographicProjection) {\n    longitudeLatitudeProjectedScratch.x = CesiumMath.toDegrees(longitude);\n    longitudeLatitudeProjectedScratch.y = CesiumMath.toDegrees(latitude);\n  } else {\n    const cartographic = cartographicScratch;\n    cartographic.longitude = longitude;\n    cartographic.latitude = latitude;\n    imageryProvider.tilingScheme.projection.project(\n      cartographic,\n      longitudeLatitudeProjectedScratch\n    );\n  }\n\n  longitudeLatitudeProjectedScratchComputed = true;\n}\n\nfunction formatTag(imageryProvider, x, y, level, longitude, latitude, format) {\n  return format;\n}\nexport default UrlTemplateImageryProvider;\n","/**\n * Describes a renderable batch of geometry.\n *\n * @alias Vector3DTileBatch\n * @constructor\n *\n * @param {Object} options An object with the following properties:\n * @param {Number} options.offset The offset of the batch into the indices buffer.\n * @param {Number} options.count The number of indices in the batch.\n * @param {Color} options.color The color of the geometry in the batch.\n * @param {Number[]} options.batchIds An array where each element is the batch id of the geometry in the batch.\n *\n * @private\n */\nfunction Vector3DTileBatch(options) {\n  /**\n   * The offset of the batch into the indices buffer.\n   * @type {Number}\n   */\n  this.offset = options.offset;\n  /**\n   * The number of indices in the batch.\n   * @type {Number}\n   */\n  this.count = options.count;\n  /**\n   * The color of the geometry in the batch.\n   * @type {Color}\n   */\n  this.color = options.color;\n  /**\n   * An array where each element is the batch id of the geometry in the batch.\n   * @type {Number[]}\n   */\n  this.batchIds = options.batchIds;\n}\nexport default Vector3DTileBatch;\n","import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport arraySlice from \"../Core/arraySlice.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport Vector3DTileClampedPolylinesVS from \"../Shaders/Vector3DTileClampedPolylinesVS.js\";\nimport Vector3DTileClampedPolylinesFS from \"../Shaders/Vector3DTileClampedPolylinesFS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport CullFace from \"./CullFace.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTilePolylines from \"./Vector3DTilePolylines.js\";\n\n/**\n * Creates a batch of polylines as volumes with shader-adjustable width.\n *\n * @alias Vector3DTileClampedPolylines\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Uint16Array} options.positions The positions of the polylines\n * @param {Uint32Array} options.counts The number or positions in the each polyline.\n * @param {Uint16Array} options.widths The width of each polyline.\n * @param {Number} options.minimumHeight The minimum height of the tile's region.\n * @param {Number} options.maximumHeight The maximum height of the tile's region.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polylines.\n * @param {Uint16Array} options.batchIds The batch ids for each polyline.\n * @param {ClassificationType} options.classificationType The classification type.\n * @param {Boolean} options.keepDecodedPositions Whether to keep decoded positions in memory.\n *\n * @private\n */\nfunction Vector3DTileClampedPolylines(options) {\n  // these arrays hold data from the tile payload\n  // and are all released after the first update.\n  this._positions = options.positions;\n  this._widths = options.widths;\n  this._counts = options.counts;\n  this._batchIds = options.batchIds;\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._center = options.center;\n  this._rectangle = options.rectangle;\n\n  this._batchTable = options.batchTable;\n\n  this._va = undefined;\n  this._sp = undefined;\n  this._rs = undefined;\n  this._uniformMap = undefined;\n  this._command = undefined;\n\n  this._transferrableBatchIds = undefined;\n  this._packedBuffer = undefined;\n  this._minimumMaximumVectorHeights = new Cartesian2(\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    ApproximateTerrainHeights._defaultMaxTerrainHeight\n  );\n  this._boundingVolume = OrientedBoundingBox.fromRectangle(\n    options.rectangle,\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    ApproximateTerrainHeights._defaultMaxTerrainHeight,\n    this._ellipsoid\n  );\n  this._classificationType = options.classificationType;\n\n  this._keepDecodedPositions = options.keepDecodedPositions;\n  this._decodedPositions = undefined;\n  this._decodedPositionOffsets = undefined;\n\n  // Fat vertices - all information for each volume packed to a vec3 and 5 vec4s\n  this._startEllipsoidNormals = undefined;\n  this._endEllipsoidNormals = undefined;\n  this._startPositionAndHeights = undefined;\n  this._startFaceNormalAndVertexCornerIds = undefined;\n  this._endPositionAndHeights = undefined;\n  this._endFaceNormalAndHalfWidths = undefined;\n  this._vertexBatchIds = undefined;\n\n  this._indices = undefined;\n\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n\n  this._trianglesLength = 0;\n  this._geometryByteLength = 0;\n\n  this._ready = false;\n  this._update = function (polylines, frameState) {};\n  this._readyPromise = initialize(this);\n  this._verticesPromise = undefined;\n}\n\nObject.defineProperties(Vector3DTileClampedPolylines.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTileClampedPolylines.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTileClampedPolylines.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Vector3DTileClampedPolylines.prototype\n   * @type {Promise}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n});\n\nfunction updateMinimumMaximumHeights(polylines, rectangle, ellipsoid) {\n  const result = ApproximateTerrainHeights.getMinimumMaximumHeights(\n    rectangle,\n    ellipsoid\n  );\n  const min = result.minimumTerrainHeight;\n  const max = result.maximumTerrainHeight;\n  const minimumMaximumVectorHeights = polylines._minimumMaximumVectorHeights;\n  minimumMaximumVectorHeights.x = min;\n  minimumMaximumVectorHeights.y = max;\n\n  const obb = polylines._boundingVolume;\n  const rect = polylines._rectangle;\n  OrientedBoundingBox.fromRectangle(rect, min, max, ellipsoid, obb);\n}\n\nfunction packBuffer(polylines) {\n  const rectangle = polylines._rectangle;\n  const minimumHeight = polylines._minimumHeight;\n  const maximumHeight = polylines._maximumHeight;\n  const ellipsoid = polylines._ellipsoid;\n  const center = polylines._center;\n\n  const packedLength =\n    2 +\n    Rectangle.packedLength +\n    Ellipsoid.packedLength +\n    Cartesian3.packedLength;\n  const packedBuffer = new Float64Array(packedLength);\n\n  let offset = 0;\n  packedBuffer[offset++] = minimumHeight;\n  packedBuffer[offset++] = maximumHeight;\n\n  Rectangle.pack(rectangle, packedBuffer, offset);\n  offset += Rectangle.packedLength;\n\n  Ellipsoid.pack(ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n\n  Cartesian3.pack(center, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nconst createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTileClampedPolylines\"\n);\nconst attributeLocations = {\n  startEllipsoidNormal: 0,\n  endEllipsoidNormal: 1,\n  startPositionAndHeight: 2,\n  endPositionAndHeight: 3,\n  startFaceNormalAndVertexCorner: 4,\n  endFaceNormalAndHalfWidth: 5,\n  a_batchId: 6,\n};\n\nfunction createVertexArray(polylines, context) {\n  if (defined(polylines._va)) {\n    return;\n  }\n\n  if (!defined(polylines._verticesPromise)) {\n    let positions = polylines._positions;\n    let widths = polylines._widths;\n    let counts = polylines._counts;\n    let batchIds = polylines._transferrableBatchIds;\n\n    let packedBuffer = polylines._packedBuffer;\n\n    if (!defined(packedBuffer)) {\n      // Copy because they may be the views on the same buffer.\n      positions = polylines._positions = arraySlice(positions);\n      widths = polylines._widths = arraySlice(widths);\n      counts = polylines._counts = arraySlice(counts);\n\n      batchIds = polylines._transferrableBatchIds = arraySlice(\n        polylines._batchIds\n      );\n\n      packedBuffer = polylines._packedBuffer = packBuffer(polylines);\n    }\n\n    const transferrableObjects = [\n      positions.buffer,\n      widths.buffer,\n      counts.buffer,\n      batchIds.buffer,\n      packedBuffer.buffer,\n    ];\n    const parameters = {\n      positions: positions.buffer,\n      widths: widths.buffer,\n      counts: counts.buffer,\n      batchIds: batchIds.buffer,\n      packedBuffer: packedBuffer.buffer,\n      keepDecodedPositions: polylines._keepDecodedPositions,\n    };\n\n    const verticesPromise = (polylines._verticesPromise = createVerticesTaskProcessor.scheduleTask(\n      parameters,\n      transferrableObjects\n    ));\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    return verticesPromise.then(function (result) {\n      if (polylines._keepDecodedPositions) {\n        polylines._decodedPositions = new Float64Array(result.decodedPositions);\n        polylines._decodedPositionOffsets = new Uint32Array(\n          result.decodedPositionOffsets\n        );\n      }\n\n      polylines._startEllipsoidNormals = new Float32Array(\n        result.startEllipsoidNormals\n      );\n      polylines._endEllipsoidNormals = new Float32Array(\n        result.endEllipsoidNormals\n      );\n      polylines._startPositionAndHeights = new Float32Array(\n        result.startPositionAndHeights\n      );\n      polylines._startFaceNormalAndVertexCornerIds = new Float32Array(\n        result.startFaceNormalAndVertexCornerIds\n      );\n      polylines._endPositionAndHeights = new Float32Array(\n        result.endPositionAndHeights\n      );\n      polylines._endFaceNormalAndHalfWidths = new Float32Array(\n        result.endFaceNormalAndHalfWidths\n      );\n      polylines._vertexBatchIds = new Uint16Array(result.vertexBatchIds);\n\n      const indexDatatype = result.indexDatatype;\n      polylines._indices =\n        indexDatatype === IndexDatatype.UNSIGNED_SHORT\n          ? new Uint16Array(result.indices)\n          : new Uint32Array(result.indices);\n\n      polylines._ready = true;\n    });\n  }\n}\n\nfunction finishVertexArray(polylines, context) {\n  if (polylines._ready && !defined(polylines._va)) {\n    const startEllipsoidNormals = polylines._startEllipsoidNormals;\n    const endEllipsoidNormals = polylines._endEllipsoidNormals;\n    const startPositionAndHeights = polylines._startPositionAndHeights;\n    const endPositionAndHeights = polylines._endPositionAndHeights;\n    const startFaceNormalAndVertexCornerIds =\n      polylines._startFaceNormalAndVertexCornerIds;\n    const endFaceNormalAndHalfWidths = polylines._endFaceNormalAndHalfWidths;\n    const batchIdAttribute = polylines._vertexBatchIds;\n\n    const indices = polylines._indices;\n\n    let byteLength =\n      startEllipsoidNormals.byteLength + endEllipsoidNormals.byteLength;\n    byteLength +=\n      startPositionAndHeights.byteLength + endPositionAndHeights.byteLength;\n    byteLength +=\n      startFaceNormalAndVertexCornerIds.byteLength +\n      endFaceNormalAndHalfWidths.byteLength;\n    byteLength += batchIdAttribute.byteLength + indices.byteLength;\n\n    polylines._trianglesLength = indices.length / 3;\n    polylines._geometryByteLength = byteLength;\n\n    const startEllipsoidNormalsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: startEllipsoidNormals,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const endEllipsoidNormalsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: endEllipsoidNormals,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const startPositionAndHeightsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: startPositionAndHeights,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const endPositionAndHeightsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: endPositionAndHeights,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const startFaceNormalAndVertexCornerIdsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: startFaceNormalAndVertexCornerIds,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const endFaceNormalAndHalfWidthsBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: endFaceNormalAndHalfWidths,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const batchIdAttributeBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIdAttribute,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype:\n        indices.BYTES_PER_ELEMENT === 2\n          ? IndexDatatype.UNSIGNED_SHORT\n          : IndexDatatype.UNSIGNED_INT,\n    });\n\n    const vertexAttributes = [\n      {\n        index: attributeLocations.startEllipsoidNormal,\n        vertexBuffer: startEllipsoidNormalsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.endEllipsoidNormal,\n        vertexBuffer: endEllipsoidNormalsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.startPositionAndHeight,\n        vertexBuffer: startPositionAndHeightsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 4,\n      },\n      {\n        index: attributeLocations.endPositionAndHeight,\n        vertexBuffer: endPositionAndHeightsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 4,\n      },\n      {\n        index: attributeLocations.startFaceNormalAndVertexCorner,\n        vertexBuffer: startFaceNormalAndVertexCornerIdsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 4,\n      },\n      {\n        index: attributeLocations.endFaceNormalAndHalfWidth,\n        vertexBuffer: endFaceNormalAndHalfWidthsBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 4,\n      },\n      {\n        index: attributeLocations.a_batchId,\n        vertexBuffer: batchIdAttributeBuffer,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        componentsPerAttribute: 1,\n      },\n    ];\n\n    polylines._va = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: indexBuffer,\n    });\n\n    polylines._positions = undefined;\n    polylines._widths = undefined;\n    polylines._counts = undefined;\n\n    polylines._ellipsoid = undefined;\n    polylines._minimumHeight = undefined;\n    polylines._maximumHeight = undefined;\n    polylines._rectangle = undefined;\n\n    polylines._transferrableBatchIds = undefined;\n    polylines._packedBuffer = undefined;\n\n    polylines._startEllipsoidNormals = undefined;\n    polylines._endEllipsoidNormals = undefined;\n    polylines._startPositionAndHeights = undefined;\n    polylines._startFaceNormalAndVertexCornerIds = undefined;\n    polylines._endPositionAndHeights = undefined;\n    polylines._endFaceNormalAndHalfWidths = undefined;\n    polylines._vertexBatchIds = undefined;\n\n    polylines._indices = undefined;\n  }\n}\n\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  primitive._uniformMap = {\n    u_modifiedModelView: function () {\n      const viewMatrix = context.uniformState.view;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive._center,\n        rtcScratch\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch\n      );\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    },\n    u_minimumMaximumVectorHeights: function () {\n      return primitive._minimumMaximumVectorHeights;\n    },\n  };\n}\n\nfunction getRenderState(mask3DTiles) {\n  /**\n   * Cull front faces of each volume (relative to camera) to prevent\n   * classification drawing from both the front and back faces, double-draw.\n   * The geometry is \"inverted\" (inside-out winding order for the indices) but\n   * the vertex shader seems to re-invert so that the triangles face \"out\" again.\n   * So cull FRONT faces.\n   */\n  return RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.FRONT,\n    },\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n    depthMask: false,\n    stencilTest: {\n      enabled: mask3DTiles,\n      frontFunction: StencilFunction.EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: StencilFunction.EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n  });\n}\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rs)) {\n    return;\n  }\n\n  primitive._rs = getRenderState(false);\n  primitive._rs3DTiles = getRenderState(true);\n}\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  const batchTable = primitive._batchTable;\n\n  const vsSource = batchTable.getVertexShaderCallback(\n    false,\n    \"a_batchId\",\n    undefined\n  )(Vector3DTileClampedPolylinesVS);\n  const fsSource = batchTable.getFragmentShaderCallback(\n    false,\n    undefined,\n    true\n  )(Vector3DTileClampedPolylinesFS);\n\n  const vs = new ShaderSource({\n    defines: [\n      \"VECTOR_TILE\",\n      !FeatureDetection.isInternetExplorer() ? \"CLIP_POLYLINE\" : \"\",\n    ],\n    sources: [PolylineCommon, vsSource],\n  });\n  const fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction queueCommands(primitive, frameState) {\n  let command = primitive._command;\n  if (!defined(primitive._command)) {\n    const uniformMap = primitive._batchTable.getUniformMapCallback()(\n      primitive._uniformMap\n    );\n    command = primitive._command = new DrawCommand({\n      owner: primitive,\n      vertexArray: primitive._va,\n      renderState: primitive._rs,\n      shaderProgram: primitive._sp,\n      uniformMap: uniformMap,\n      boundingVolume: primitive._boundingVolume,\n      pass: Pass.TERRAIN_CLASSIFICATION,\n      pickId: primitive._batchTable.getPickId(),\n    });\n\n    const derivedTilesetCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset\n    );\n    derivedTilesetCommand.renderState = primitive._rs3DTiles;\n    derivedTilesetCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedTilesetCommand;\n  }\n\n  const classificationType = primitive._classificationType;\n  if (\n    classificationType === ClassificationType.TERRAIN ||\n    classificationType === ClassificationType.BOTH\n  ) {\n    frameState.commandList.push(command);\n  }\n  if (\n    classificationType === ClassificationType.CESIUM_3D_TILE ||\n    classificationType === ClassificationType.BOTH\n  ) {\n    frameState.commandList.push(command.derivedCommands.tileset);\n  }\n}\n\n/**\n * Get the polyline positions for the given feature.\n *\n * @param {Number} batchId The batch ID of the feature.\n */\nVector3DTileClampedPolylines.prototype.getPositions = function (batchId) {\n  return Vector3DTilePolylines.getPolylinePositions(this, batchId);\n};\n\n/**\n * Creates features for each polyline and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTileClampedPolylines.prototype.createFeatures = function (\n  content,\n  features\n) {\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polyline batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTileClampedPolylines.prototype.applyDebugSettings = function (\n  enabled,\n  color\n) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  const batchIds = polygons._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n}\n\nconst scratchColor = new Color();\n\nconst DEFAULT_COLOR_VALUE = Color.WHITE;\nconst DEFAULT_SHOW_VALUE = true;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The dictionary of features.\n */\nVector3DTileClampedPolylines.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.color = defined(style.color)\n      ? style.color.evaluateColor(feature, scratchColor)\n      : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show)\n      ? style.show.evaluate(feature)\n      : DEFAULT_SHOW_VALUE;\n  }\n};\n\nfunction initialize(polylines) {\n  return ApproximateTerrainHeights.initialize().then(function () {\n    updateMinimumMaximumHeights(\n      polylines,\n      polylines._rectangle,\n      polylines._ellipsoid\n    );\n\n    return new Promise(function (resolve, reject) {\n      polylines._update = function (polylines, frameState) {\n        const context = frameState.context;\n        const promise = createVertexArray(polylines, context);\n        createUniformMap(polylines, context);\n        createShaders(polylines, context);\n        createRenderStates(polylines);\n\n        if (polylines._ready) {\n          const passes = frameState.passes;\n          if (passes.render || passes.pick) {\n            queueCommands(polylines, frameState);\n          }\n        }\n\n        if (!defined(promise)) {\n          return;\n        }\n\n        promise\n          .then(function () {\n            finishVertexArray(polylines, context);\n            resolve(polylines);\n          })\n          .catch(function (e) {\n            reject(e);\n          });\n      };\n    });\n  });\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTileClampedPolylines.prototype.update = function (frameState) {\n  this._update(this, frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTileClampedPolylines.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTileClampedPolylines.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTileClampedPolylines;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport Vector3DTilePoints from \"./Vector3DTilePoints.js\";\nimport Vector3DTilePolygons from \"./Vector3DTilePolygons.js\";\nimport Vector3DTilePolylines from \"./Vector3DTilePolylines.js\";\nimport Vector3DTileClampedPolylines from \"./Vector3DTileClampedPolylines.js\";\nimport decodeVectorPolylinePositions from \"../Core/decodeVectorPolylinePositions.js\";\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/vctr/TileFormats/VectorData|Vector}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Vector3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Vector3DTileContent(tileset, tile, resource, arrayBuffer, byteOffset) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this._polygons = undefined;\n  this._polylines = undefined;\n  this._points = undefined;\n\n  this._metadata = undefined;\n\n  this._batchTable = undefined;\n  this._features = undefined;\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   */\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n\n  initialize(this, arrayBuffer, byteOffset);\n}\n\nObject.defineProperties(Vector3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.featuresLength : 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.pointsLength;\n      }\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      let trianglesLength = 0;\n      if (defined(this._polygons)) {\n        trianglesLength += this._polygons.trianglesLength;\n      }\n      if (defined(this._polylines)) {\n        trianglesLength += this._polylines.trianglesLength;\n      }\n      return trianglesLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      let geometryByteLength = 0;\n      if (defined(this._polygons)) {\n        geometryByteLength += this._polygons.geometryByteLength;\n      }\n      if (defined(this._polylines)) {\n        geometryByteLength += this._polylines.geometryByteLength;\n      }\n      return geometryByteLength;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      if (defined(this._points)) {\n        return this._points.texturesByteLength;\n      }\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.memorySizeInBytes : 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      const pointsPromise = defined(this._points)\n        ? this._points.readyPromise\n        : undefined;\n      const polygonPromise = defined(this._polygons)\n        ? this._polygons.readyPromise\n        : undefined;\n      const polylinePromise = defined(this._polylines)\n        ? this._polylines.readyPromise\n        : undefined;\n\n      const that = this;\n      return Promise.all([pointsPromise, polygonPromise, polylinePromise]).then(\n        function () {\n          return that;\n        }\n      );\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\nfunction createColorChangedCallback(content) {\n  return function (batchId, color) {\n    if (defined(content._polygons)) {\n      content._polygons.updateCommands(batchId, color);\n    }\n  };\n}\n\nfunction getBatchIds(featureTableJson, featureTableBinary) {\n  let polygonBatchIds;\n  let polylineBatchIds;\n  let pointBatchIds;\n  let i;\n\n  const numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  const numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  const numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n\n  if (numberOfPolygons > 0 && defined(featureTableJson.POLYGON_BATCH_IDS)) {\n    const polygonBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.POLYGON_BATCH_IDS.byteOffset;\n    polygonBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      polygonBatchIdsByteOffset,\n      numberOfPolygons\n    );\n  }\n\n  if (numberOfPolylines > 0 && defined(featureTableJson.POLYLINE_BATCH_IDS)) {\n    const polylineBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.POLYLINE_BATCH_IDS.byteOffset;\n    polylineBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      polylineBatchIdsByteOffset,\n      numberOfPolylines\n    );\n  }\n\n  if (numberOfPoints > 0 && defined(featureTableJson.POINT_BATCH_IDS)) {\n    const pointBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.POINT_BATCH_IDS.byteOffset;\n    pointBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      pointBatchIdsByteOffset,\n      numberOfPoints\n    );\n  }\n\n  const atLeastOneDefined =\n    defined(polygonBatchIds) ||\n    defined(polylineBatchIds) ||\n    defined(pointBatchIds);\n  const atLeastOneUndefined =\n    (numberOfPolygons > 0 && !defined(polygonBatchIds)) ||\n    (numberOfPolylines > 0 && !defined(polylineBatchIds)) ||\n    (numberOfPoints > 0 && !defined(pointBatchIds));\n\n  if (atLeastOneDefined && atLeastOneUndefined) {\n    throw new RuntimeError(\n      \"If one group of batch ids is defined, then all batch ids must be defined.\"\n    );\n  }\n\n  const allUndefinedBatchIds =\n    !defined(polygonBatchIds) &&\n    !defined(polylineBatchIds) &&\n    !defined(pointBatchIds);\n  if (allUndefinedBatchIds) {\n    let id = 0;\n    if (!defined(polygonBatchIds) && numberOfPolygons > 0) {\n      polygonBatchIds = new Uint16Array(numberOfPolygons);\n      for (i = 0; i < numberOfPolygons; ++i) {\n        polygonBatchIds[i] = id++;\n      }\n    }\n    if (!defined(polylineBatchIds) && numberOfPolylines > 0) {\n      polylineBatchIds = new Uint16Array(numberOfPolylines);\n      for (i = 0; i < numberOfPolylines; ++i) {\n        polylineBatchIds[i] = id++;\n      }\n    }\n    if (!defined(pointBatchIds) && numberOfPoints > 0) {\n      pointBatchIds = new Uint16Array(numberOfPoints);\n      for (i = 0; i < numberOfPoints; ++i) {\n        pointBatchIds[i] = id++;\n      }\n    }\n  }\n\n  return {\n    polygons: polygonBatchIds,\n    polylines: polylineBatchIds,\n    points: pointBatchIds,\n  };\n}\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction createFloatingPolylines(options) {\n  return new Vector3DTilePolylines(options);\n}\n\nfunction createClampedPolylines(options) {\n  return new Vector3DTileClampedPolylines(options);\n}\n\nfunction initialize(content, arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic number\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Vector tile version 1 is supported.  Version ${version} is not.`\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (byteLength === 0) {\n    return Promise.resolve(content);\n  }\n\n  const featureTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (featureTableJSONByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\"\n    );\n  }\n\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const indicesByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const positionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const polylinePositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const pointsPositionByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const featureTableJson = getJsonFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJSONByteLength\n  );\n  byteOffset += featureTableJSONByteLength;\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJSONByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJSONByteLength\n    );\n    byteOffset += batchTableJSONByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength\n      );\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  const numberOfPolygons = defaultValue(featureTableJson.POLYGONS_LENGTH, 0);\n  const numberOfPolylines = defaultValue(featureTableJson.POLYLINES_LENGTH, 0);\n  const numberOfPoints = defaultValue(featureTableJson.POINTS_LENGTH, 0);\n  const totalPrimitives = numberOfPolygons + numberOfPolylines + numberOfPoints;\n\n  const batchTable = new Cesium3DTileBatchTable(\n    content,\n    totalPrimitives,\n    batchTableJson,\n    batchTableBinary,\n    createColorChangedCallback(content)\n  );\n  content._batchTable = batchTable;\n\n  if (totalPrimitives === 0) {\n    return;\n  }\n\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary\n  );\n  const region = featureTable.getGlobalProperty(\"REGION\");\n  if (!defined(region)) {\n    throw new RuntimeError(\n      \"Feature table global property: REGION must be defined\"\n    );\n  }\n  const rectangle = Rectangle.unpack(region);\n  const minHeight = region[4];\n  const maxHeight = region[5];\n\n  const modelMatrix = content._tile.computedTransform;\n\n  let center = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n  if (defined(center)) {\n    center = Cartesian3.unpack(center);\n    Matrix4.multiplyByPoint(modelMatrix, center, center);\n  } else {\n    center = Rectangle.center(rectangle);\n    center.height = CesiumMath.lerp(minHeight, maxHeight, 0.5);\n    center = Ellipsoid.WGS84.cartographicToCartesian(center);\n  }\n\n  const batchIds = getBatchIds(featureTableJson, featureTableBinary);\n  byteOffset += (4 - (byteOffset % 4)) % 4;\n\n  if (numberOfPolygons > 0) {\n    featureTable.featuresLength = numberOfPolygons;\n\n    const polygonCounts = defaultValue(\n      featureTable.getPropertyArray(\n        \"POLYGON_COUNTS\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ),\n      featureTable.getPropertyArray(\n        \"POLYGON_COUNT\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ) // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polygonCounts)) {\n      throw new RuntimeError(\n        \"Feature table property: POLYGON_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\"\n      );\n    }\n\n    const polygonIndexCounts = defaultValue(\n      featureTable.getPropertyArray(\n        \"POLYGON_INDEX_COUNTS\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ),\n      featureTable.getPropertyArray(\n        \"POLYGON_INDEX_COUNT\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ) // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polygonIndexCounts)) {\n      throw new RuntimeError(\n        \"Feature table property: POLYGON_INDEX_COUNTS must be defined when POLYGONS_LENGTH is greater than 0\"\n      );\n    }\n\n    // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n    const numPolygonPositions = polygonCounts.reduce(function (total, count) {\n      return total + count * 2;\n    }, 0);\n\n    const numPolygonIndices = polygonIndexCounts.reduce(function (\n      total,\n      count\n    ) {\n      return total + count;\n    },\n    0);\n\n    const indices = new Uint32Array(arrayBuffer, byteOffset, numPolygonIndices);\n    byteOffset += indicesByteLength;\n\n    const polygonPositions = new Uint16Array(\n      arrayBuffer,\n      byteOffset,\n      numPolygonPositions\n    );\n    byteOffset += positionByteLength;\n\n    let polygonMinimumHeights;\n    let polygonMaximumHeights;\n    if (\n      defined(featureTableJson.POLYGON_MINIMUM_HEIGHTS) &&\n      defined(featureTableJson.POLYGON_MAXIMUM_HEIGHTS)\n    ) {\n      polygonMinimumHeights = featureTable.getPropertyArray(\n        \"POLYGON_MINIMUM_HEIGHTS\",\n        ComponentDatatype.FLOAT,\n        1\n      );\n      polygonMaximumHeights = featureTable.getPropertyArray(\n        \"POLYGON_MAXIMUM_HEIGHTS\",\n        ComponentDatatype.FLOAT,\n        1\n      );\n    }\n\n    content._polygons = new Vector3DTilePolygons({\n      positions: polygonPositions,\n      counts: polygonCounts,\n      indexCounts: polygonIndexCounts,\n      indices: indices,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      polygonMinimumHeights: polygonMinimumHeights,\n      polygonMaximumHeights: polygonMaximumHeights,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable,\n      batchIds: batchIds.polygons,\n      modelMatrix: modelMatrix,\n    });\n  }\n\n  if (numberOfPolylines > 0) {\n    featureTable.featuresLength = numberOfPolylines;\n\n    const polylineCounts = defaultValue(\n      featureTable.getPropertyArray(\n        \"POLYLINE_COUNTS\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ),\n      featureTable.getPropertyArray(\n        \"POLYLINE_COUNT\",\n        ComponentDatatype.UNSIGNED_INT,\n        1\n      ) // Workaround for old vector tilesets using the non-plural name\n    );\n\n    if (!defined(polylineCounts)) {\n      throw new RuntimeError(\n        \"Feature table property: POLYLINE_COUNTS must be defined when POLYLINES_LENGTH is greater than 0\"\n      );\n    }\n\n    let widths = featureTable.getPropertyArray(\n      \"POLYLINE_WIDTHS\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1\n    );\n    if (!defined(widths)) {\n      widths = new Uint16Array(numberOfPolylines);\n      for (let i = 0; i < numberOfPolylines; ++i) {\n        widths[i] = 2.0;\n      }\n    }\n\n    // Use the counts array to determine how many position values we want. If we used the byte length then\n    // zero padding values would be included and cause the delta zig-zag decoding to fail\n    const numPolylinePositions = polylineCounts.reduce(function (total, count) {\n      return total + count * 3;\n    }, 0);\n    const polylinePositions = new Uint16Array(\n      arrayBuffer,\n      byteOffset,\n      numPolylinePositions\n    );\n    byteOffset += polylinePositionByteLength;\n\n    const tileset = content._tileset;\n    const examineVectorLinesFunction = tileset.examineVectorLinesFunction;\n    if (defined(examineVectorLinesFunction)) {\n      const decodedPositions = decodeVectorPolylinePositions(\n        new Uint16Array(polylinePositions),\n        rectangle,\n        minHeight,\n        maxHeight,\n        Ellipsoid.WGS84\n      );\n      examineVectorLines(\n        decodedPositions,\n        polylineCounts,\n        batchIds.polylines,\n        batchTable,\n        content.url,\n        examineVectorLinesFunction\n      );\n    }\n\n    let createPolylines = createFloatingPolylines;\n    if (defined(tileset.classificationType)) {\n      createPolylines = createClampedPolylines;\n    }\n\n    content._polylines = createPolylines({\n      positions: polylinePositions,\n      widths: widths,\n      counts: polylineCounts,\n      batchIds: batchIds.polylines,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      center: center,\n      rectangle: rectangle,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n      batchTable: batchTable,\n      classificationType: tileset.classificationType,\n      keepDecodedPositions: tileset.vectorKeepDecodedPositions,\n    });\n  }\n\n  if (numberOfPoints > 0) {\n    const pointPositions = new Uint16Array(\n      arrayBuffer,\n      byteOffset,\n      numberOfPoints * 3\n    );\n    byteOffset += pointsPositionByteLength;\n    content._points = new Vector3DTilePoints({\n      positions: pointPositions,\n      batchIds: batchIds.points,\n      minimumHeight: minHeight,\n      maximumHeight: maxHeight,\n      rectangle: rectangle,\n      batchTable: batchTable,\n    });\n  }\n\n  return Promise.resolve(content);\n}\n\nfunction createFeatures(content) {\n  const featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    const features = new Array(featuresLength);\n\n    if (defined(content._polygons)) {\n      content._polygons.createFeatures(content, features);\n    }\n    if (defined(content._polylines)) {\n      content._polylines.createFeatures(content, features);\n    }\n    if (defined(content._points)) {\n      content._points.createFeatures(content, features);\n    }\n    content._features = features;\n  }\n}\n\nVector3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\n\nVector3DTileContent.prototype.getFeature = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = this.featuresLength;\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${\n        featuresLength - 1\n      }).`\n    );\n  }\n  //>>includeEnd('debug');\n\n  createFeatures(this);\n  return this._features[batchId];\n};\n\nVector3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  if (defined(this._polygons)) {\n    this._polygons.applyDebugSettings(enabled, color);\n  }\n  if (defined(this._polylines)) {\n    this._polylines.applyDebugSettings(enabled, color);\n  }\n  if (defined(this._points)) {\n    this._points.applyDebugSettings(enabled, color);\n  }\n};\n\nVector3DTileContent.prototype.applyStyle = function (style) {\n  createFeatures(this);\n  if (defined(this._polygons)) {\n    this._polygons.applyStyle(style, this._features);\n  }\n  if (defined(this._polylines)) {\n    this._polylines.applyStyle(style, this._features);\n  }\n  if (defined(this._points)) {\n    this._points.applyStyle(style, this._features);\n  }\n};\n\nVector3DTileContent.prototype.update = function (tileset, frameState) {\n  let ready = true;\n  if (defined(this._polygons)) {\n    this._polygons.classificationType = this._tileset.classificationType;\n    this._polygons.debugWireframe = this._tileset.debugWireframe;\n    this._polygons.update(frameState);\n    ready = ready && this._polygons._ready;\n  }\n  if (defined(this._polylines)) {\n    this._polylines.update(frameState);\n    ready = ready && this._polylines._ready;\n  }\n  if (defined(this._points)) {\n    this._points.update(frameState);\n    ready = ready && this._points._ready;\n  }\n  if (defined(this._batchTable) && ready) {\n    this._batchTable.update(tileset, frameState);\n  }\n};\n\nVector3DTileContent.prototype.getPolylinePositions = function (batchId) {\n  const polylines = this._polylines;\n  if (!defined(polylines)) {\n    return undefined;\n  }\n\n  return polylines.getPositions(batchId);\n};\n\nVector3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nVector3DTileContent.prototype.destroy = function () {\n  this._polygons = this._polygons && this._polygons.destroy();\n  this._polylines = this._polylines && this._polylines.destroy();\n  this._points = this._points && this._points.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\n\nfunction examineVectorLines(\n  positions,\n  counts,\n  batchIds,\n  batchTable,\n  url,\n  callback\n) {\n  const countsLength = counts.length;\n  let polylineStart = 0;\n  for (let i = 0; i < countsLength; i++) {\n    const count = counts[i] * 3;\n    const linePositions = positions.slice(polylineStart, polylineStart + count);\n    polylineStart += count;\n\n    callback(linePositions, batchIds[i], url, batchTable);\n  }\n}\n\nexport default Vector3DTileContent;\n","import arraySlice from \"../Core/arraySlice.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n\n/**\n * Creates a batch of box, cylinder, ellipsoid and/or sphere geometries intersecting terrain or 3D Tiles.\n *\n * @alias Vector3DTileGeometry\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array} [options.boxes] The boxes in the tile.\n * @param {Uint16Array} [options.boxBatchIds] The batch ids for each box.\n * @param {Float32Array} [options.cylinders] The cylinders in the tile.\n * @param {Uint16Array} [options.cylinderBatchIds] The batch ids for each cylinder.\n * @param {Float32Array} [options.ellipsoids] The ellipsoids in the tile.\n * @param {Uint16Array} [options.ellipsoidBatchIds] The batch ids for each ellipsoid.\n * @param {Float32Array} [options.spheres] The spheres in the tile.\n * @param {Uint16Array} [options.sphereBatchIds] The batch ids for each sphere.\n * @param {Cartesian3} options.center The RTC center of all geometries.\n * @param {Matrix4} options.modelMatrix The model matrix of all geometries. Applied after the individual geometry model matrices.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table.\n * @param {BoundingSphere} options.boundingVolume The bounding volume containing all of the geometry in the tile.\n *\n * @private\n */\nfunction Vector3DTileGeometry(options) {\n  // these will all be released after the primitive is created\n  this._boxes = options.boxes;\n  this._boxBatchIds = options.boxBatchIds;\n  this._cylinders = options.cylinders;\n  this._cylinderBatchIds = options.cylinderBatchIds;\n  this._ellipsoids = options.ellipsoids;\n  this._ellipsoidBatchIds = options.ellipsoidBatchIds;\n  this._spheres = options.spheres;\n  this._sphereBatchIds = options.sphereBatchIds;\n  this._modelMatrix = options.modelMatrix;\n  this._batchTable = options.batchTable;\n  this._boundingVolume = options.boundingVolume;\n\n  this._center = options.center;\n  if (!defined(this._center)) {\n    if (defined(this._boundingVolume)) {\n      this._center = Cartesian3.clone(this._boundingVolume.center);\n    } else {\n      this._center = Cartesian3.clone(Cartesian3.ZERO);\n    }\n  }\n\n  this._boundingVolumes = undefined;\n  this._batchedIndices = undefined;\n\n  this._indices = undefined;\n  this._indexOffsets = undefined;\n  this._indexCounts = undefined;\n\n  this._positions = undefined;\n  this._vertexBatchIds = undefined;\n\n  this._batchIds = undefined;\n\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n\n  this._ready = false;\n  this._update = function (geometries, frameState) {};\n  this._readyPromise = initialize(this);\n\n  this._verticesPromise = undefined;\n\n  this._primitive = undefined;\n\n  /**\n   * Draws the wireframe of the classification geometries.\n   * @type {Boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = ClassificationType.BOTH;\n}\n\nObject.defineProperties(Vector3DTileGeometry.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTileGeometry.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Vector3DTileGeometry.prototype\n   * @type {Promise<void>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n});\n\nVector3DTileGeometry.packedBoxLength =\n  Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedCylinderLength = Matrix4.packedLength + 2;\nVector3DTileGeometry.packedEllipsoidLength =\n  Matrix4.packedLength + Cartesian3.packedLength;\nVector3DTileGeometry.packedSphereLength = Cartesian3.packedLength + 1;\n\nfunction packBuffer(geometries) {\n  const packedBuffer = new Float64Array(\n    Matrix4.packedLength + Cartesian3.packedLength\n  );\n\n  let offset = 0;\n  Cartesian3.pack(geometries._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n  Matrix4.pack(geometries._modelMatrix, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nfunction unpackBuffer(geometries, packedBuffer) {\n  let offset = 0;\n\n  const indicesBytesPerElement = packedBuffer[offset++];\n  const numBVS = packedBuffer[offset++];\n  const bvs = (geometries._boundingVolumes = new Array(numBVS));\n\n  for (let i = 0; i < numBVS; ++i) {\n    bvs[i] = BoundingSphere.unpack(packedBuffer, offset);\n    offset += BoundingSphere.packedLength;\n  }\n\n  const numBatchedIndices = packedBuffer[offset++];\n  const bis = (geometries._batchedIndices = new Array(numBatchedIndices));\n\n  for (let j = 0; j < numBatchedIndices; ++j) {\n    const color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n\n    const indexOffset = packedBuffer[offset++];\n    const count = packedBuffer[offset++];\n\n    const length = packedBuffer[offset++];\n    const batchIds = new Array(length);\n\n    for (let k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds,\n    });\n  }\n\n  return indicesBytesPerElement;\n}\n\nconst createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTileGeometries\",\n  5\n);\nconst scratchColor = new Color();\n\nfunction createPrimitive(geometries) {\n  if (defined(geometries._primitive)) {\n    return;\n  }\n\n  if (!defined(geometries._verticesPromise)) {\n    let boxes = geometries._boxes;\n    let boxBatchIds = geometries._boxBatchIds;\n    let cylinders = geometries._cylinders;\n    let cylinderBatchIds = geometries._cylinderBatchIds;\n    let ellipsoids = geometries._ellipsoids;\n    let ellipsoidBatchIds = geometries._ellipsoidBatchIds;\n    let spheres = geometries._spheres;\n    let sphereBatchIds = geometries._sphereBatchIds;\n\n    let batchTableColors = geometries._batchTableColors;\n    let packedBuffer = geometries._packedBuffer;\n\n    if (!defined(batchTableColors)) {\n      // Copy because they may be the views on the same buffer.\n      let length = 0;\n      if (defined(geometries._boxes)) {\n        boxes = geometries._boxes = arraySlice(boxes);\n        boxBatchIds = geometries._boxBatchIds = arraySlice(boxBatchIds);\n        length += boxBatchIds.length;\n      }\n      if (defined(geometries._cylinders)) {\n        cylinders = geometries._cylinders = arraySlice(cylinders);\n        cylinderBatchIds = geometries._cylinderBatchIds = arraySlice(\n          cylinderBatchIds\n        );\n        length += cylinderBatchIds.length;\n      }\n      if (defined(geometries._ellipsoids)) {\n        ellipsoids = geometries._ellipsoids = arraySlice(ellipsoids);\n        ellipsoidBatchIds = geometries._ellipsoidBatchIds = arraySlice(\n          ellipsoidBatchIds\n        );\n        length += ellipsoidBatchIds.length;\n      }\n      if (defined(geometries._spheres)) {\n        spheres = geometries._sphere = arraySlice(spheres);\n        sphereBatchIds = geometries._sphereBatchIds = arraySlice(\n          sphereBatchIds\n        );\n        length += sphereBatchIds.length;\n      }\n\n      batchTableColors = geometries._batchTableColors = new Uint32Array(length);\n      const batchTable = geometries._batchTable;\n\n      for (let i = 0; i < length; ++i) {\n        const color = batchTable.getColor(i, scratchColor);\n        batchTableColors[i] = color.toRgba();\n      }\n\n      packedBuffer = geometries._packedBuffer = packBuffer(geometries);\n    }\n\n    const transferrableObjects = [];\n    if (defined(boxes)) {\n      transferrableObjects.push(boxes.buffer, boxBatchIds.buffer);\n    }\n    if (defined(cylinders)) {\n      transferrableObjects.push(cylinders.buffer, cylinderBatchIds.buffer);\n    }\n    if (defined(ellipsoids)) {\n      transferrableObjects.push(ellipsoids.buffer, ellipsoidBatchIds.buffer);\n    }\n    if (defined(spheres)) {\n      transferrableObjects.push(spheres.buffer, sphereBatchIds.buffer);\n    }\n    transferrableObjects.push(batchTableColors.buffer, packedBuffer.buffer);\n\n    const parameters = {\n      boxes: defined(boxes) ? boxes.buffer : undefined,\n      boxBatchIds: defined(boxes) ? boxBatchIds.buffer : undefined,\n      cylinders: defined(cylinders) ? cylinders.buffer : undefined,\n      cylinderBatchIds: defined(cylinders)\n        ? cylinderBatchIds.buffer\n        : undefined,\n      ellipsoids: defined(ellipsoids) ? ellipsoids.buffer : undefined,\n      ellipsoidBatchIds: defined(ellipsoids)\n        ? ellipsoidBatchIds.buffer\n        : undefined,\n      spheres: defined(spheres) ? spheres.buffer : undefined,\n      sphereBatchIds: defined(spheres) ? sphereBatchIds.buffer : undefined,\n      batchTableColors: batchTableColors.buffer,\n      packedBuffer: packedBuffer.buffer,\n    };\n\n    const verticesPromise = (geometries._verticesPromise = createVerticesTaskProcessor.scheduleTask(\n      parameters,\n      transferrableObjects\n    ));\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    return verticesPromise.then(function (result) {\n      const packedBuffer = new Float64Array(result.packedBuffer);\n      const indicesBytesPerElement = unpackBuffer(geometries, packedBuffer);\n\n      if (indicesBytesPerElement === 2) {\n        geometries._indices = new Uint16Array(result.indices);\n      } else {\n        geometries._indices = new Uint32Array(result.indices);\n      }\n\n      geometries._indexOffsets = new Uint32Array(result.indexOffsets);\n      geometries._indexCounts = new Uint32Array(result.indexCounts);\n\n      geometries._positions = new Float32Array(result.positions);\n      geometries._vertexBatchIds = new Uint16Array(result.vertexBatchIds);\n\n      geometries._batchIds = new Uint16Array(result.batchIds);\n\n      geometries._ready = true;\n    });\n  }\n}\n\nfunction finishPrimitive(geometries) {\n  if (geometries._ready && !defined(geometries._primitive)) {\n    geometries._primitive = new Vector3DTilePrimitive({\n      batchTable: geometries._batchTable,\n      positions: geometries._positions,\n      batchIds: geometries._batchIds,\n      vertexBatchIds: geometries._vertexBatchIds,\n      indices: geometries._indices,\n      indexOffsets: geometries._indexOffsets,\n      indexCounts: geometries._indexCounts,\n      batchedIndices: geometries._batchedIndices,\n      boundingVolume: geometries._boundingVolume,\n      boundingVolumes: geometries._boundingVolumes,\n      center: geometries._center,\n      pickObject: defaultValue(geometries._pickObject, geometries),\n    });\n\n    geometries._boxes = undefined;\n    geometries._boxBatchIds = undefined;\n    geometries._cylinders = undefined;\n    geometries._cylinderBatchIds = undefined;\n    geometries._ellipsoids = undefined;\n    geometries._ellipsoidBatchIds = undefined;\n    geometries._spheres = undefined;\n    geometries._sphereBatchIds = undefined;\n    geometries._center = undefined;\n    geometries._modelMatrix = undefined;\n    geometries._batchTable = undefined;\n    geometries._boundingVolume = undefined;\n\n    geometries._boundingVolumes = undefined;\n    geometries._batchedIndices = undefined;\n\n    geometries._indices = undefined;\n    geometries._indexOffsets = undefined;\n    geometries._indexCounts = undefined;\n\n    geometries._positions = undefined;\n    geometries._vertexBatchIds = undefined;\n\n    geometries._batchIds = undefined;\n\n    geometries._batchTableColors = undefined;\n    geometries._packedBuffer = undefined;\n\n    geometries._verticesPromise = undefined;\n  }\n}\n\n/**\n * Creates features for each geometry and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTileGeometry.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (geometry batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTileGeometry.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTileGeometry.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n\n/**\n * Call when updating the color of a geometry with batchId changes color. The geometries will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the geometries whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTileGeometry.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\nfunction initialize(geometries) {\n  return new Promise(function (resolve, reject) {\n    geometries._update = function (geometries, frameState) {\n      const promise = createPrimitive(geometries);\n\n      if (geometries._ready) {\n        geometries._primitive.debugWireframe = geometries.debugWireframe;\n        geometries._primitive.forceRebatch = geometries.forceRebatch;\n        geometries._primitive.classificationType =\n          geometries.classificationType;\n        geometries._primitive.update(frameState);\n      }\n\n      if (!defined(promise)) {\n        return;\n      }\n\n      promise\n        .then(function () {\n          finishPrimitive(geometries);\n          resolve(geometries);\n        })\n        .catch(function (e) {\n          reject(e);\n        });\n    };\n  });\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTileGeometry.prototype.update = function (frameState) {\n  this._update(this, frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTileGeometry.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTileGeometry.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTileGeometry;\n","import arraySlice from \"../Core/arraySlice.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport BillboardCollection from \"./BillboardCollection.js\";\nimport Cesium3DTilePointFeature from \"./Cesium3DTilePointFeature.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport LabelCollection from \"./LabelCollection.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport PolylineCollection from \"./PolylineCollection.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\n\n/**\n * Creates a batch of points or billboards and labels.\n *\n * @alias Vector3DTilePoints\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Uint16Array} options.positions The positions of the polygons.\n * @param {Number} options.minimumHeight The minimum height of the terrain covered by the tile.\n * @param {Number} options.maximumHeight The maximum height of the terrain covered by the tile.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polygons.\n * @param {Uint16Array} options.batchIds The batch ids for each polygon.\n *\n * @private\n */\nfunction Vector3DTilePoints(options) {\n  // released after the first update\n  this._positions = options.positions;\n\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds;\n\n  this._rectangle = options.rectangle;\n  this._minHeight = options.minimumHeight;\n  this._maxHeight = options.maximumHeight;\n\n  this._billboardCollection = new BillboardCollection({\n    batchTable: options.batchTable,\n  });\n  this._labelCollection = new LabelCollection({\n    batchTable: options.batchTable,\n  });\n  this._polylineCollection = new PolylineCollection();\n  this._polylineCollection._useHighlightColor = true;\n\n  this._verticesPromise = undefined;\n  this._packedBuffer = undefined;\n\n  this._ready = false;\n  this._update = function (points, frameState) {};\n  this._readyPromise = initialize(this);\n}\n\nObject.defineProperties(Vector3DTilePoints.prototype, {\n  /**\n   * Gets the number of points.\n   *\n   * @memberof Vector3DTilePoints.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pointsLength: {\n    get: function () {\n      return this._billboardCollection.length;\n    },\n  },\n\n  /**\n   * Gets the texture atlas memory in bytes.\n   *\n   * @memberof Vector3DTilePoints.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  texturesByteLength: {\n    get: function () {\n      const billboardSize = this._billboardCollection.textureAtlas.texture\n        .sizeInBytes;\n      const labelSize = this._labelCollection._textureAtlas.texture.sizeInBytes;\n      return billboardSize + labelSize;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Vector3DTilePoints.prototype\n   * @type {Promise<void>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n});\n\nfunction packBuffer(points, ellipsoid) {\n  const rectangle = points._rectangle;\n  const minimumHeight = points._minHeight;\n  const maximumHeight = points._maxHeight;\n\n  const packedLength = 2 + Rectangle.packedLength + Ellipsoid.packedLength;\n  const packedBuffer = new Float64Array(packedLength);\n\n  let offset = 0;\n  packedBuffer[offset++] = minimumHeight;\n  packedBuffer[offset++] = maximumHeight;\n\n  Rectangle.pack(rectangle, packedBuffer, offset);\n  offset += Rectangle.packedLength;\n\n  Ellipsoid.pack(ellipsoid, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nconst createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTilePoints\",\n  5\n);\nconst scratchPosition = new Cartesian3();\n\nfunction createPoints(points, ellipsoid) {\n  let positions;\n  if (!defined(points._verticesPromise)) {\n    positions = points._positions;\n    let packedBuffer = points._packedBuffer;\n\n    if (!defined(packedBuffer)) {\n      // Copy because they may be the views on the same buffer.\n      positions = points._positions = arraySlice(positions);\n      points._batchIds = arraySlice(points._batchIds);\n\n      packedBuffer = points._packedBuffer = packBuffer(points, ellipsoid);\n    }\n\n    const transferrableObjects = [positions.buffer, packedBuffer.buffer];\n    const parameters = {\n      positions: positions.buffer,\n      packedBuffer: packedBuffer.buffer,\n    };\n\n    const verticesPromise = (points._verticesPromise = createVerticesTaskProcessor.scheduleTask(\n      parameters,\n      transferrableObjects\n    ));\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    return verticesPromise.then(function (result) {\n      points._positions = new Float64Array(result.positions);\n      const billboardCollection = points._billboardCollection;\n      const labelCollection = points._labelCollection;\n      const polylineCollection = points._polylineCollection;\n      positions = points._positions;\n      const batchIds = points._batchIds;\n      const numberOfPoints = positions.length / 3;\n\n      for (let i = 0; i < numberOfPoints; ++i) {\n        const id = batchIds[i];\n\n        const position = Cartesian3.unpack(positions, i * 3, scratchPosition);\n\n        const b = billboardCollection.add();\n        b.position = position;\n        b._batchIndex = id;\n\n        const l = labelCollection.add();\n        l.text = \" \";\n        l.position = position;\n        l._batchIndex = id;\n\n        const p = polylineCollection.add();\n        p.positions = [Cartesian3.clone(position), Cartesian3.clone(position)];\n      }\n\n      points._positions = undefined;\n      points._packedBuffer = undefined;\n      points._ready = true;\n    });\n  }\n}\n\n/**\n * Creates features for each point and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the point features will be placed.\n */\nVector3DTilePoints.prototype.createFeatures = function (content, features) {\n  const billboardCollection = this._billboardCollection;\n  const labelCollection = this._labelCollection;\n  const polylineCollection = this._polylineCollection;\n\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n\n    const billboard = billboardCollection.get(i);\n    const label = labelCollection.get(i);\n    const polyline = polylineCollection.get(i);\n\n    features[batchId] = new Cesium3DTilePointFeature(\n      content,\n      batchId,\n      billboard,\n      label,\n      polyline\n    );\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePoints.prototype.applyDebugSettings = function (enabled, color) {\n  if (enabled) {\n    Color.clone(color, this._billboardCollection._highlightColor);\n    Color.clone(color, this._labelCollection._highlightColor);\n    Color.clone(color, this._polylineCollection._highlightColor);\n  } else {\n    Color.clone(Color.WHITE, this._billboardCollection._highlightColor);\n    Color.clone(Color.WHITE, this._labelCollection._highlightColor);\n    Color.clone(Color.WHITE, this._polylineCollection._highlightColor);\n  }\n};\n\nfunction clearStyle(polygons, features) {\n  const batchIds = polygons._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.show = true;\n    feature.pointSize = Cesium3DTilePointFeature.defaultPointSize;\n    feature.color = Cesium3DTilePointFeature.defaultColor;\n    feature.pointOutlineColor =\n      Cesium3DTilePointFeature.defaultPointOutlineColor;\n    feature.pointOutlineWidth =\n      Cesium3DTilePointFeature.defaultPointOutlineWidth;\n    feature.labelColor = Color.WHITE;\n    feature.labelOutlineColor = Color.WHITE;\n    feature.labelOutlineWidth = 1.0;\n    feature.font = \"30px sans-serif\";\n    feature.labelStyle = LabelStyle.FILL;\n    feature.labelText = undefined;\n    feature.backgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\n    feature.backgroundPadding = new Cartesian2(7, 5);\n    feature.backgroundEnabled = false;\n    feature.scaleByDistance = undefined;\n    feature.translucencyByDistance = undefined;\n    feature.distanceDisplayCondition = undefined;\n    feature.heightOffset = 0.0;\n    feature.anchorLineEnabled = false;\n    feature.anchorLineColor = Color.WHITE;\n    feature.image = undefined;\n    feature.disableDepthTestDistance = 0.0;\n    feature.horizontalOrigin = HorizontalOrigin.CENTER;\n    feature.verticalOrigin = VerticalOrigin.CENTER;\n    feature.labelHorizontalOrigin = HorizontalOrigin.RIGHT;\n    feature.labelVerticalOrigin = VerticalOrigin.BASELINE;\n  }\n}\n\nconst scratchColor = new Color();\nconst scratchColor2 = new Color();\nconst scratchColor3 = new Color();\nconst scratchColor4 = new Color();\nconst scratchColor5 = new Color();\nconst scratchColor6 = new Color();\nconst scratchScaleByDistance = new NearFarScalar();\nconst scratchTranslucencyByDistance = new NearFarScalar();\nconst scratchDistanceDisplayCondition = new DistanceDisplayCondition();\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePoints.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    if (defined(style.show)) {\n      feature.show = style.show.evaluate(feature);\n    }\n\n    if (defined(style.pointSize)) {\n      feature.pointSize = style.pointSize.evaluate(feature);\n    }\n\n    if (defined(style.color)) {\n      feature.color = style.color.evaluateColor(feature, scratchColor);\n    }\n\n    if (defined(style.pointOutlineColor)) {\n      feature.pointOutlineColor = style.pointOutlineColor.evaluateColor(\n        feature,\n        scratchColor2\n      );\n    }\n\n    if (defined(style.pointOutlineWidth)) {\n      feature.pointOutlineWidth = style.pointOutlineWidth.evaluate(feature);\n    }\n\n    if (defined(style.labelColor)) {\n      feature.labelColor = style.labelColor.evaluateColor(\n        feature,\n        scratchColor3\n      );\n    }\n\n    if (defined(style.labelOutlineColor)) {\n      feature.labelOutlineColor = style.labelOutlineColor.evaluateColor(\n        feature,\n        scratchColor4\n      );\n    }\n\n    if (defined(style.labelOutlineWidth)) {\n      feature.labelOutlineWidth = style.labelOutlineWidth.evaluate(feature);\n    }\n\n    if (defined(style.font)) {\n      feature.font = style.font.evaluate(feature);\n    }\n\n    if (defined(style.labelStyle)) {\n      feature.labelStyle = style.labelStyle.evaluate(feature);\n    }\n\n    if (defined(style.labelText)) {\n      feature.labelText = style.labelText.evaluate(feature);\n    } else {\n      feature.labelText = undefined;\n    }\n\n    if (defined(style.backgroundColor)) {\n      feature.backgroundColor = style.backgroundColor.evaluateColor(\n        feature,\n        scratchColor5\n      );\n    }\n\n    if (defined(style.backgroundPadding)) {\n      feature.backgroundPadding = style.backgroundPadding.evaluate(feature);\n    }\n\n    if (defined(style.backgroundEnabled)) {\n      feature.backgroundEnabled = style.backgroundEnabled.evaluate(feature);\n    }\n\n    if (defined(style.scaleByDistance)) {\n      const scaleByDistanceCart4 = style.scaleByDistance.evaluate(feature);\n      scratchScaleByDistance.near = scaleByDistanceCart4.x;\n      scratchScaleByDistance.nearValue = scaleByDistanceCart4.y;\n      scratchScaleByDistance.far = scaleByDistanceCart4.z;\n      scratchScaleByDistance.farValue = scaleByDistanceCart4.w;\n      feature.scaleByDistance = scratchScaleByDistance;\n    } else {\n      feature.scaleByDistance = undefined;\n    }\n\n    if (defined(style.translucencyByDistance)) {\n      const translucencyByDistanceCart4 = style.translucencyByDistance.evaluate(\n        feature\n      );\n      scratchTranslucencyByDistance.near = translucencyByDistanceCart4.x;\n      scratchTranslucencyByDistance.nearValue = translucencyByDistanceCart4.y;\n      scratchTranslucencyByDistance.far = translucencyByDistanceCart4.z;\n      scratchTranslucencyByDistance.farValue = translucencyByDistanceCart4.w;\n      feature.translucencyByDistance = scratchTranslucencyByDistance;\n    } else {\n      feature.translucencyByDistance = undefined;\n    }\n\n    if (defined(style.distanceDisplayCondition)) {\n      const distanceDisplayConditionCart2 = style.distanceDisplayCondition.evaluate(\n        feature\n      );\n      scratchDistanceDisplayCondition.near = distanceDisplayConditionCart2.x;\n      scratchDistanceDisplayCondition.far = distanceDisplayConditionCart2.y;\n      feature.distanceDisplayCondition = scratchDistanceDisplayCondition;\n    } else {\n      feature.distanceDisplayCondition = undefined;\n    }\n\n    if (defined(style.heightOffset)) {\n      feature.heightOffset = style.heightOffset.evaluate(feature);\n    }\n\n    if (defined(style.anchorLineEnabled)) {\n      feature.anchorLineEnabled = style.anchorLineEnabled.evaluate(feature);\n    }\n\n    if (defined(style.anchorLineColor)) {\n      feature.anchorLineColor = style.anchorLineColor.evaluateColor(\n        feature,\n        scratchColor6\n      );\n    }\n\n    if (defined(style.image)) {\n      feature.image = style.image.evaluate(feature);\n    } else {\n      feature.image = undefined;\n    }\n\n    if (defined(style.disableDepthTestDistance)) {\n      feature.disableDepthTestDistance = style.disableDepthTestDistance.evaluate(\n        feature\n      );\n    }\n\n    if (defined(style.horizontalOrigin)) {\n      feature.horizontalOrigin = style.horizontalOrigin.evaluate(feature);\n    }\n\n    if (defined(style.verticalOrigin)) {\n      feature.verticalOrigin = style.verticalOrigin.evaluate(feature);\n    }\n\n    if (defined(style.labelHorizontalOrigin)) {\n      feature.labelHorizontalOrigin = style.labelHorizontalOrigin.evaluate(\n        feature\n      );\n    }\n\n    if (defined(style.labelVerticalOrigin)) {\n      feature.labelVerticalOrigin = style.labelVerticalOrigin.evaluate(feature);\n    }\n  }\n};\n\nfunction initialize(points) {\n  return new Promise(function (resolve, reject) {\n    points._update = function (points, frameState) {\n      const promise = createPoints(points, frameState.mapProjection.ellipsoid);\n\n      if (points._ready) {\n        points._polylineCollection.update(frameState);\n        points._billboardCollection.update(frameState);\n        points._labelCollection.update(frameState);\n      }\n\n      if (!defined(promise)) {\n        return;\n      }\n\n      promise\n        .then(function () {\n          resolve();\n        })\n        .catch(function (e) {\n          reject(e);\n        });\n    };\n  });\n}\n\n/**\n * @private\n */\nVector3DTilePoints.prototype.update = function (frameState) {\n  this._update(this, frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePoints.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePoints.prototype.destroy = function () {\n  this._billboardCollection =\n    this._billboardCollection && this._billboardCollection.destroy();\n  this._labelCollection =\n    this._labelCollection && this._labelCollection.destroy();\n  this._polylineCollection =\n    this._polylineCollection && this._polylineCollection.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePoints;\n","import arraySlice from \"../Core/arraySlice.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\nimport Vector3DTilePrimitive from \"./Vector3DTilePrimitive.js\";\n\n/**\n * Creates a batch of pre-triangulated polygons draped on terrain and/or 3D Tiles.\n *\n * @alias Vector3DTilePolygons\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array|Uint16Array} options.positions The positions of the polygons. The positions must be contiguous\n * so that the positions for polygon n are in [c, c + counts[n]] where c = sum{counts[0], counts[n - 1]} and they are the outer ring of\n * the polygon in counter-clockwise order.\n * @param {Uint32Array} options.counts The number of positions in the each polygon.\n * @param {Uint32Array} options.indices The indices of the triangulated polygons. The indices must be contiguous so that\n * the indices for polygon n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each polygon.\n * @param {Number} options.minimumHeight The minimum height of the terrain covered by the tile.\n * @param {Number} options.maximumHeight The maximum height of the terrain covered by the tile.\n * @param {Float32Array} [options.polygonMinimumHeights] An array containing the minimum heights for each polygon.\n * @param {Float32Array} [options.polygonMaximumHeights] An array containing the maximum heights for each polygon.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polygons.\n * @param {Uint16Array} options.batchIds The batch ids for each polygon.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of polygons.\n *\n * @private\n */\nfunction Vector3DTilePolygons(options) {\n  // All of the private properties will be released except _readyPromise\n  // and _primitive after the Vector3DTilePrimitive is created.\n  this._batchTable = options.batchTable;\n\n  this._batchIds = options.batchIds;\n  this._positions = options.positions;\n  this._counts = options.counts;\n\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = undefined;\n\n  this._batchTableColors = undefined;\n  this._packedBuffer = undefined;\n\n  this._batchedPositions = undefined;\n  this._transferrableBatchIds = undefined;\n  this._vertexBatchIds = undefined;\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._polygonMinimumHeights = options.polygonMinimumHeights;\n  this._polygonMaximumHeights = options.polygonMaximumHeights;\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n  this._rectangle = options.rectangle;\n\n  this._center = undefined;\n\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = undefined;\n\n  this._batchedIndices = undefined;\n\n  this._ready = false;\n  this._update = function (polygons, frameState) {};\n  this._readyPromise = initialize(this);\n  this._verticesPromise = undefined;\n\n  this._primitive = undefined;\n\n  /**\n   * Draws the wireframe of the classification meshes.\n   * @type {Boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = ClassificationType.BOTH;\n}\n\nObject.defineProperties(Vector3DTilePolygons.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.trianglesLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePolygons.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._primitive)) {\n        return this._primitive.geometryByteLength;\n      }\n      return 0;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Vector3DTilePolygons.prototype\n   * @type {Promise<void>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n});\n\nfunction packBuffer(polygons) {\n  const packedBuffer = new Float64Array(\n    3 +\n      Cartesian3.packedLength +\n      Ellipsoid.packedLength +\n      Rectangle.packedLength\n  );\n\n  let offset = 0;\n  packedBuffer[offset++] = polygons._indices.BYTES_PER_ELEMENT;\n\n  packedBuffer[offset++] = polygons._minimumHeight;\n  packedBuffer[offset++] = polygons._maximumHeight;\n\n  Cartesian3.pack(polygons._center, packedBuffer, offset);\n  offset += Cartesian3.packedLength;\n\n  Ellipsoid.pack(polygons._ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n\n  Rectangle.pack(polygons._rectangle, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nfunction unpackBuffer(polygons, packedBuffer) {\n  let offset = 1;\n\n  const numBVS = packedBuffer[offset++];\n  const bvs = (polygons._boundingVolumes = new Array(numBVS));\n\n  for (let i = 0; i < numBVS; ++i) {\n    bvs[i] = OrientedBoundingBox.unpack(packedBuffer, offset);\n    offset += OrientedBoundingBox.packedLength;\n  }\n\n  const numBatchedIndices = packedBuffer[offset++];\n  const bis = (polygons._batchedIndices = new Array(numBatchedIndices));\n\n  for (let j = 0; j < numBatchedIndices; ++j) {\n    const color = Color.unpack(packedBuffer, offset);\n    offset += Color.packedLength;\n\n    const indexOffset = packedBuffer[offset++];\n    const count = packedBuffer[offset++];\n\n    const length = packedBuffer[offset++];\n    const batchIds = new Array(length);\n\n    for (let k = 0; k < length; ++k) {\n      batchIds[k] = packedBuffer[offset++];\n    }\n\n    bis[j] = new Vector3DTileBatch({\n      color: color,\n      offset: indexOffset,\n      count: count,\n      batchIds: batchIds,\n    });\n  }\n}\n\nconst createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTilePolygons\",\n  5\n);\nconst scratchColor = new Color();\n\nfunction createPrimitive(polygons) {\n  if (defined(polygons._primitive)) {\n    return;\n  }\n\n  if (!defined(polygons._verticesPromise)) {\n    let positions = polygons._positions;\n    let counts = polygons._counts;\n    let indexCounts = polygons._indexCounts;\n    let indices = polygons._indices;\n\n    let batchIds = polygons._transferrableBatchIds;\n    let batchTableColors = polygons._batchTableColors;\n\n    let packedBuffer = polygons._packedBuffer;\n\n    if (!defined(batchTableColors)) {\n      // Copy because they may be the views on the same buffer.\n      positions = polygons._positions = arraySlice(polygons._positions);\n      counts = polygons._counts = arraySlice(polygons._counts);\n      indexCounts = polygons._indexCounts = arraySlice(polygons._indexCounts);\n      indices = polygons._indices = arraySlice(polygons._indices);\n\n      polygons._center = polygons._ellipsoid.cartographicToCartesian(\n        Rectangle.center(polygons._rectangle)\n      );\n\n      batchIds = polygons._transferrableBatchIds = new Uint32Array(\n        polygons._batchIds\n      );\n      batchTableColors = polygons._batchTableColors = new Uint32Array(\n        batchIds.length\n      );\n      const batchTable = polygons._batchTable;\n\n      const length = batchTableColors.length;\n      for (let i = 0; i < length; ++i) {\n        const color = batchTable.getColor(i, scratchColor);\n        batchTableColors[i] = color.toRgba();\n      }\n\n      packedBuffer = polygons._packedBuffer = packBuffer(polygons);\n    }\n\n    const transferrableObjects = [\n      positions.buffer,\n      counts.buffer,\n      indexCounts.buffer,\n      indices.buffer,\n      batchIds.buffer,\n      batchTableColors.buffer,\n      packedBuffer.buffer,\n    ];\n    const parameters = {\n      packedBuffer: packedBuffer.buffer,\n      positions: positions.buffer,\n      counts: counts.buffer,\n      indexCounts: indexCounts.buffer,\n      indices: indices.buffer,\n      batchIds: batchIds.buffer,\n      batchTableColors: batchTableColors.buffer,\n    };\n\n    let minimumHeights = polygons._polygonMinimumHeights;\n    let maximumHeights = polygons._polygonMaximumHeights;\n    if (defined(minimumHeights) && defined(maximumHeights)) {\n      minimumHeights = arraySlice(minimumHeights);\n      maximumHeights = arraySlice(maximumHeights);\n\n      transferrableObjects.push(minimumHeights.buffer, maximumHeights.buffer);\n      parameters.minimumHeights = minimumHeights;\n      parameters.maximumHeights = maximumHeights;\n    }\n\n    const verticesPromise = (polygons._verticesPromise = createVerticesTaskProcessor.scheduleTask(\n      parameters,\n      transferrableObjects\n    ));\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    return verticesPromise.then(function (result) {\n      polygons._positions = undefined;\n      polygons._counts = undefined;\n      polygons._polygonMinimumHeights = undefined;\n      polygons._polygonMaximumHeights = undefined;\n\n      const packedBuffer = new Float64Array(result.packedBuffer);\n      const indexDatatype = packedBuffer[0];\n      unpackBuffer(polygons, packedBuffer);\n\n      polygons._indices =\n        IndexDatatype.getSizeInBytes(indexDatatype) === 2\n          ? new Uint16Array(result.indices)\n          : new Uint32Array(result.indices);\n      polygons._indexOffsets = new Uint32Array(result.indexOffsets);\n      polygons._indexCounts = new Uint32Array(result.indexCounts);\n\n      // will be released\n      polygons._batchedPositions = new Float32Array(result.positions);\n      polygons._vertexBatchIds = new Uint16Array(result.batchIds);\n\n      polygons._ready = true;\n    });\n  }\n}\n\nfunction finishPrimitive(polygons) {\n  if (polygons._ready && !defined(polygons._primitive)) {\n    polygons._primitive = new Vector3DTilePrimitive({\n      batchTable: polygons._batchTable,\n      positions: polygons._batchedPositions,\n      batchIds: polygons._batchIds,\n      vertexBatchIds: polygons._vertexBatchIds,\n      indices: polygons._indices,\n      indexOffsets: polygons._indexOffsets,\n      indexCounts: polygons._indexCounts,\n      batchedIndices: polygons._batchedIndices,\n      boundingVolume: polygons._boundingVolume,\n      boundingVolumes: polygons._boundingVolumes,\n      center: polygons._center,\n    });\n\n    polygons._batchTable = undefined;\n    polygons._batchIds = undefined;\n    polygons._positions = undefined;\n    polygons._counts = undefined;\n    polygons._indices = undefined;\n    polygons._indexCounts = undefined;\n    polygons._indexOffsets = undefined;\n    polygons._batchTableColors = undefined;\n    polygons._packedBuffer = undefined;\n    polygons._batchedPositions = undefined;\n    polygons._transferrableBatchIds = undefined;\n    polygons._vertexBatchIds = undefined;\n    polygons._ellipsoid = undefined;\n    polygons._minimumHeight = undefined;\n    polygons._maximumHeight = undefined;\n    polygons._polygonMinimumHeights = undefined;\n    polygons._polygonMaximumHeights = undefined;\n    polygons._center = undefined;\n    polygons._rectangle = undefined;\n    polygons._boundingVolume = undefined;\n    polygons._boundingVolumes = undefined;\n    polygons._batchedIndices = undefined;\n    polygons._verticesPromise = undefined;\n  }\n}\n\n/**\n * Creates features for each polygon and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePolygons.prototype.createFeatures = function (content, features) {\n  this._primitive.createFeatures(content, features);\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polygon batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePolygons.prototype.applyDebugSettings = function (enabled, color) {\n  this._primitive.applyDebugSettings(enabled, color);\n};\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePolygons.prototype.applyStyle = function (style, features) {\n  this._primitive.applyStyle(style, features);\n};\n\n/**\n * Call when updating the color of a polygon with batchId changes color. The polygons will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the polygon whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTilePolygons.prototype.updateCommands = function (batchId, color) {\n  this._primitive.updateCommands(batchId, color);\n};\n\nfunction initialize(polygons) {\n  return new Promise(function (resolve, reject) {\n    polygons._update = function (polygons, frameState) {\n      const promise = createPrimitive(polygons);\n\n      if (polygons._ready) {\n        polygons._primitive.debugWireframe = polygons.debugWireframe;\n        polygons._primitive.forceRebatch = polygons.forceRebatch;\n        polygons._primitive.classificationType = polygons.classificationType;\n        polygons._primitive.update(frameState);\n      }\n\n      if (!defined(promise)) {\n        return;\n      }\n\n      promise\n        .then(function () {\n          finishPrimitive(polygons);\n          resolve(polygons);\n        })\n        .catch(function (e) {\n          reject(e);\n        });\n    };\n  });\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePolygons.prototype.update = function (frameState) {\n  this._update(this, frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePolygons.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePolygons.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePolygons;\n","import arraySlice from \"../Core/arraySlice.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport PolylineCommon from \"../Shaders/PolylineCommon.js\";\nimport Vector3DTilePolylinesVS from \"../Shaders/Vector3DTilePolylinesVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\n\n/**\n * Creates a batch of polylines that have been subdivided to be draped on terrain.\n *\n * @alias Vector3DTilePolylines\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Uint16Array} options.positions The positions of the polylines\n * @param {Uint32Array} options.counts The number or positions in the each polyline.\n * @param {Uint16Array} options.widths The width of each polyline.\n * @param {Number} options.minimumHeight The minimum height of the terrain covered by the tile.\n * @param {Number} options.maximumHeight The maximum height of the terrain covered by the tile.\n * @param {Rectangle} options.rectangle The rectangle containing the tile.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched polylines.\n * @param {Uint16Array} options.batchIds The batch ids for each polyline.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of polylines.\n * @param {Boolean} options.keepDecodedPositions Whether to keep decoded positions in memory.\n *\n * @private\n */\nfunction Vector3DTilePolylines(options) {\n  // these arrays are all released after the first update.\n  this._positions = options.positions;\n  this._widths = options.widths;\n  this._counts = options.counts;\n  this._batchIds = options.batchIds;\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._center = options.center;\n  this._rectangle = options.rectangle;\n\n  this._boundingVolume = options.boundingVolume;\n  this._batchTable = options.batchTable;\n\n  this._va = undefined;\n  this._sp = undefined;\n  this._rs = undefined;\n  this._uniformMap = undefined;\n  this._command = undefined;\n\n  this._transferrableBatchIds = undefined;\n  this._packedBuffer = undefined;\n\n  this._keepDecodedPositions = options.keepDecodedPositions;\n  this._decodedPositions = undefined;\n  this._decodedPositionOffsets = undefined;\n\n  this._currentPositions = undefined;\n  this._previousPositions = undefined;\n  this._nextPositions = undefined;\n  this._expandAndWidth = undefined;\n  this._vertexBatchIds = undefined;\n  this._indices = undefined;\n\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n\n  this._trianglesLength = 0;\n  this._geometryByteLength = 0;\n\n  this._ready = false;\n  this._update = function (polylines, frameState) {};\n  this._readyPromise = initialize(this);\n\n  this._verticesPromise = undefined;\n}\n\nObject.defineProperties(Vector3DTilePolylines.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePolylines.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePolylines.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Vector3DTilePolylines.prototype\n   * @type {Promise<void>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n});\n\nfunction packBuffer(polylines) {\n  const rectangle = polylines._rectangle;\n  const minimumHeight = polylines._minimumHeight;\n  const maximumHeight = polylines._maximumHeight;\n  const ellipsoid = polylines._ellipsoid;\n  const center = polylines._center;\n\n  const packedLength =\n    2 +\n    Rectangle.packedLength +\n    Ellipsoid.packedLength +\n    Cartesian3.packedLength;\n  const packedBuffer = new Float64Array(packedLength);\n\n  let offset = 0;\n  packedBuffer[offset++] = minimumHeight;\n  packedBuffer[offset++] = maximumHeight;\n\n  Rectangle.pack(rectangle, packedBuffer, offset);\n  offset += Rectangle.packedLength;\n\n  Ellipsoid.pack(ellipsoid, packedBuffer, offset);\n  offset += Ellipsoid.packedLength;\n\n  Cartesian3.pack(center, packedBuffer, offset);\n\n  return packedBuffer;\n}\n\nconst createVerticesTaskProcessor = new TaskProcessor(\n  \"createVectorTilePolylines\",\n  5\n);\nconst attributeLocations = {\n  previousPosition: 0,\n  currentPosition: 1,\n  nextPosition: 2,\n  expandAndWidth: 3,\n  a_batchId: 4,\n};\n\nfunction createVertexArray(polylines, context) {\n  if (defined(polylines._va)) {\n    return;\n  }\n\n  if (!defined(polylines._verticesPromise)) {\n    let positions = polylines._positions;\n    let widths = polylines._widths;\n    let counts = polylines._counts;\n    let batchIds = polylines._transferrableBatchIds;\n\n    let packedBuffer = polylines._packedBuffer;\n\n    if (!defined(packedBuffer)) {\n      // Copy because they may be the views on the same buffer.\n      positions = polylines._positions = arraySlice(positions);\n      widths = polylines._widths = arraySlice(widths);\n      counts = polylines._counts = arraySlice(counts);\n\n      batchIds = polylines._transferrableBatchIds = arraySlice(\n        polylines._batchIds\n      );\n\n      packedBuffer = polylines._packedBuffer = packBuffer(polylines);\n    }\n\n    const transferrableObjects = [\n      positions.buffer,\n      widths.buffer,\n      counts.buffer,\n      batchIds.buffer,\n      packedBuffer.buffer,\n    ];\n    const parameters = {\n      positions: positions.buffer,\n      widths: widths.buffer,\n      counts: counts.buffer,\n      batchIds: batchIds.buffer,\n      packedBuffer: packedBuffer.buffer,\n      keepDecodedPositions: polylines._keepDecodedPositions,\n    };\n\n    const verticesPromise = (polylines._verticesPromise = createVerticesTaskProcessor.scheduleTask(\n      parameters,\n      transferrableObjects\n    ));\n    if (!defined(verticesPromise)) {\n      // Postponed\n      return;\n    }\n\n    return verticesPromise.then(function (result) {\n      if (polylines._keepDecodedPositions) {\n        polylines._decodedPositions = new Float64Array(result.decodedPositions);\n        polylines._decodedPositionOffsets = new Uint32Array(\n          result.decodedPositionOffsets\n        );\n      }\n\n      polylines._currentPositions = new Float32Array(result.currentPositions);\n      polylines._previousPositions = new Float32Array(result.previousPositions);\n      polylines._nextPositions = new Float32Array(result.nextPositions);\n      polylines._expandAndWidth = new Float32Array(result.expandAndWidth);\n      polylines._vertexBatchIds = new Uint16Array(result.batchIds);\n\n      const indexDatatype = result.indexDatatype;\n      polylines._indices =\n        indexDatatype === IndexDatatype.UNSIGNED_SHORT\n          ? new Uint16Array(result.indices)\n          : new Uint32Array(result.indices);\n\n      polylines._ready = true;\n    });\n  }\n}\n\nfunction finishVertexArray(polylines, context) {\n  if (polylines._ready && !defined(polylines._va)) {\n    const curPositions = polylines._currentPositions;\n    const prevPositions = polylines._previousPositions;\n    const nextPositions = polylines._nextPositions;\n    const expandAndWidth = polylines._expandAndWidth;\n    const vertexBatchIds = polylines._vertexBatchIds;\n    const indices = polylines._indices;\n\n    let byteLength =\n      prevPositions.byteLength +\n      curPositions.byteLength +\n      nextPositions.byteLength;\n    byteLength +=\n      expandAndWidth.byteLength +\n      vertexBatchIds.byteLength +\n      indices.byteLength;\n    polylines._trianglesLength = indices.length / 3;\n    polylines._geometryByteLength = byteLength;\n\n    const prevPositionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: prevPositions,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const curPositionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: curPositions,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const nextPositionBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: nextPositions,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const expandAndWidthBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: expandAndWidth,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    const idBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: vertexBatchIds,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype:\n        indices.BYTES_PER_ELEMENT === 2\n          ? IndexDatatype.UNSIGNED_SHORT\n          : IndexDatatype.UNSIGNED_INT,\n    });\n\n    const vertexAttributes = [\n      {\n        index: attributeLocations.previousPosition,\n        vertexBuffer: prevPositionBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.currentPosition,\n        vertexBuffer: curPositionBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.nextPosition,\n        vertexBuffer: nextPositionBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        index: attributeLocations.expandAndWidth,\n        vertexBuffer: expandAndWidthBuffer,\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n      },\n      {\n        index: attributeLocations.a_batchId,\n        vertexBuffer: idBuffer,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        componentsPerAttribute: 1,\n      },\n    ];\n\n    polylines._va = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: indexBuffer,\n    });\n\n    polylines._positions = undefined;\n    polylines._widths = undefined;\n    polylines._counts = undefined;\n\n    polylines._ellipsoid = undefined;\n    polylines._minimumHeight = undefined;\n    polylines._maximumHeight = undefined;\n    polylines._rectangle = undefined;\n\n    polylines._transferrableBatchIds = undefined;\n    polylines._packedBuffer = undefined;\n\n    polylines._currentPositions = undefined;\n    polylines._previousPositions = undefined;\n    polylines._nextPositions = undefined;\n    polylines._expandAndWidth = undefined;\n    polylines._vertexBatchIds = undefined;\n    polylines._indices = undefined;\n  }\n}\n\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  primitive._uniformMap = {\n    u_modifiedModelView: function () {\n      const viewMatrix = context.uniformState.view;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive._center,\n        rtcScratch\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch\n      );\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    },\n  };\n}\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rs)) {\n    return;\n  }\n\n  const polygonOffset = {\n    enabled: true,\n    factor: -5.0,\n    units: -5.0,\n  };\n\n  primitive._rs = RenderState.fromCache({\n    blending: BlendingState.ALPHA_BLEND,\n    depthMask: false,\n    depthTest: {\n      enabled: true,\n    },\n    polygonOffset: polygonOffset,\n  });\n}\n\nconst PolylineFS =\n  \"uniform vec4 u_highlightColor; \\n\" +\n  \"void main()\\n\" +\n  \"{\\n\" +\n  \"    gl_FragColor = u_highlightColor;\\n\" +\n  \"}\\n\";\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  const batchTable = primitive._batchTable;\n\n  const vsSource = batchTable.getVertexShaderCallback(\n    false,\n    \"a_batchId\",\n    undefined\n  )(Vector3DTilePolylinesVS);\n  const fsSource = batchTable.getFragmentShaderCallback(\n    false,\n    undefined,\n    false\n  )(PolylineFS);\n\n  const vs = new ShaderSource({\n    defines: [\n      \"VECTOR_TILE\",\n      !FeatureDetection.isInternetExplorer() ? \"CLIP_POLYLINE\" : \"\",\n    ],\n    sources: [PolylineCommon, vsSource],\n  });\n  const fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction queueCommands(primitive, frameState) {\n  if (!defined(primitive._command)) {\n    const uniformMap = primitive._batchTable.getUniformMapCallback()(\n      primitive._uniformMap\n    );\n    primitive._command = new DrawCommand({\n      owner: primitive,\n      vertexArray: primitive._va,\n      renderState: primitive._rs,\n      shaderProgram: primitive._sp,\n      uniformMap: uniformMap,\n      boundingVolume: primitive._boundingVolume,\n      pass: Pass.TRANSLUCENT,\n      pickId: primitive._batchTable.getPickId(),\n    });\n  }\n\n  frameState.commandList.push(primitive._command);\n}\n\nVector3DTilePolylines.getPolylinePositions = function (polylines, batchId) {\n  const batchIds = polylines._batchIds;\n  const positions = polylines._decodedPositions;\n  const offsets = polylines._decodedPositionOffsets;\n\n  if (!defined(batchIds) || !defined(positions)) {\n    return undefined;\n  }\n\n  let i;\n  let j;\n  const polylinesLength = batchIds.length;\n  let positionsLength = 0;\n  let resultCounter = 0;\n\n  for (i = 0; i < polylinesLength; ++i) {\n    if (batchIds[i] === batchId) {\n      positionsLength += offsets[i + 1] - offsets[i];\n    }\n  }\n\n  if (positionsLength === 0) {\n    return undefined;\n  }\n\n  const results = new Float64Array(positionsLength * 3);\n\n  for (i = 0; i < polylinesLength; ++i) {\n    if (batchIds[i] === batchId) {\n      const offset = offsets[i];\n      const count = offsets[i + 1] - offset;\n      for (j = 0; j < count; ++j) {\n        const decodedOffset = (offset + j) * 3;\n        results[resultCounter++] = positions[decodedOffset];\n        results[resultCounter++] = positions[decodedOffset + 1];\n        results[resultCounter++] = positions[decodedOffset + 2];\n      }\n    }\n  }\n\n  return results;\n};\n\n/**\n * Get the polyline positions for the given feature.\n *\n * @param {Number} batchId The batch ID of the feature.\n */\nVector3DTilePolylines.prototype.getPositions = function (batchId) {\n  return Vector3DTilePolylines.getPolylinePositions(this, batchId);\n};\n\n/**\n * Creates features for each polyline and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePolylines.prototype.createFeatures = function (content, features) {\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (polyline batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePolylines.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  const batchIds = polygons._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n}\n\nconst scratchColor = new Color();\n\nconst DEFAULT_COLOR_VALUE = Color.WHITE;\nconst DEFAULT_SHOW_VALUE = true;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePolylines.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.color = defined(style.color)\n      ? style.color.evaluateColor(feature, scratchColor)\n      : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show)\n      ? style.show.evaluate(feature)\n      : DEFAULT_SHOW_VALUE;\n  }\n};\n\nfunction initialize(polylines) {\n  return new Promise(function (resolve, reject) {\n    polylines._update = function (polylines, frameState) {\n      const context = frameState.context;\n      const promise = createVertexArray(polylines, context);\n      createUniformMap(polylines, context);\n      createShaders(polylines, context);\n      createRenderStates(polylines);\n\n      if (polylines._ready) {\n        const passes = frameState.passes;\n        if (passes.render || passes.pick) {\n          queueCommands(polylines, frameState);\n        }\n      }\n\n      if (!defined(promise)) {\n        return;\n      }\n\n      promise\n        .then(function () {\n          finishVertexArray(polylines, context);\n          resolve();\n        })\n        .catch(function (e) {\n          reject(e);\n        });\n    };\n  });\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePolylines.prototype.update = function (frameState) {\n  this._update(this, frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePolylines.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePolylines.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePolylines;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport VectorTileVS from \"../Shaders/VectorTileVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport Expression from \"./Expression.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\n\n/**\n * Creates a batch of classification meshes.\n *\n * @alias Vector3DTilePrimitive\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array} options.positions The positions of the meshes.\n * @param {Uint16Array|Uint32Array} options.indices The indices of the triangulated meshes. The indices must be contiguous so that\n * the indices for mesh n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each mesh.\n * @param {Uint32Array} options.indexOffsets The offset into the index buffer for each mesh.\n * @param {Vector3DTileBatch[]} options.batchedIndices The index offset and count for each batch with the same color.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched meshes.\n * @param {Uint16Array} options.batchIds The batch ids for each mesh.\n * @param {Uint16Array} options.vertexBatchIds The batch id for each vertex.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of meshes.\n * @param {BoundingSphere[]} options.boundingVolumes The bounding volume for each mesh.\n * @param {ClassificationType} [options.classificationType] What this tile will classify.\n *\n * @private\n */\nfunction Vector3DTilePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds;\n\n  // These arrays are released after VAO creation.\n  this._positions = options.positions;\n  this._vertexBatchIds = options.vertexBatchIds;\n\n  // These arrays are kept for re-batching indices based on colors.\n  // If WebGL 2 is supported, indices will be released and re-batching uses buffer-to-buffer copies.\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = options.indexOffsets;\n  this._batchedIndices = options.batchedIndices;\n\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = options.boundingVolumes;\n\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n\n  this._va = undefined;\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._uniformMap = undefined;\n\n  // Only used with WebGL 2 to ping-pong ibos after copy.\n  this._vaSwap = undefined;\n\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n  this._rsWireframe = undefined;\n\n  this._commands = [];\n  this._commandsIgnoreShow = [];\n  this._pickCommands = [];\n\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n\n  this._batchDirty = true;\n  this._pickCommandsDirty = true;\n  this._framesSinceLastRebatch = 0;\n\n  this._updatingAllCommands = false;\n\n  this._trianglesLength = this._indices.length / 3;\n  this._geometryByteLength =\n    this._indices.byteLength +\n    this._positions.byteLength +\n    this._vertexBatchIds.byteLength;\n\n  /**\n   * Draw the wireframe of the classification meshes.\n   * @type {Boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n  this._debugWireframe = this.debugWireframe;\n  this._wireframeDirty = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH\n  );\n\n  // Hidden options\n  this._vertexShaderSource = options._vertexShaderSource;\n  this._fragmentShaderSource = options._fragmentShaderSource;\n  this._attributeLocations = options._attributeLocations;\n  this._uniformMap = options._uniformMap;\n  this._pickId = options._pickId;\n  this._modelMatrix = options._modelMatrix;\n  this._boundingSphere = options._boundingSphere;\n\n  this._batchIdLookUp = {};\n\n  const length = this._batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = this._batchIds[i];\n    this._batchIdLookUp[batchId] = i;\n  }\n}\n\nObject.defineProperties(Vector3DTilePrimitive.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n});\n\nconst defaultAttributeLocations = {\n  position: 0,\n  a_batchId: 1,\n};\n\nfunction createVertexArray(primitive, context) {\n  if (defined(primitive._va)) {\n    return;\n  }\n\n  const positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._positions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const idBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._vertexBatchIds,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: primitive._indices,\n    usage: BufferUsage.DYNAMIC_DRAW,\n    indexDatatype:\n      primitive._indices.BYTES_PER_ELEMENT === 2\n        ? IndexDatatype.UNSIGNED_SHORT\n        : IndexDatatype.UNSIGNED_INT,\n  });\n\n  const vertexAttributes = [\n    {\n      index: 0,\n      vertexBuffer: positionBuffer,\n      componentDatatype: ComponentDatatype.fromTypedArray(primitive._positions),\n      componentsPerAttribute: 3,\n    },\n    {\n      index: 1,\n      vertexBuffer: idBuffer,\n      componentDatatype: ComponentDatatype.fromTypedArray(\n        primitive._vertexBatchIds\n      ),\n      componentsPerAttribute: 1,\n    },\n  ];\n\n  primitive._va = new VertexArray({\n    context: context,\n    attributes: vertexAttributes,\n    indexBuffer: indexBuffer,\n  });\n\n  if (context.webgl2) {\n    primitive._vaSwap = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: Buffer.createIndexBuffer({\n        context: context,\n        sizeInBytes: indexBuffer.sizeInBytes,\n        usage: BufferUsage.DYNAMIC_DRAW,\n        indexDatatype: indexBuffer.indexDatatype,\n      }),\n    });\n  }\n\n  primitive._batchedPositions = undefined;\n  primitive._transferrableBatchIds = undefined;\n  primitive._vertexBatchIds = undefined;\n  primitive._verticesPromise = undefined;\n}\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  const batchTable = primitive._batchTable;\n  const attributeLocations = defaultValue(\n    primitive._attributeLocations,\n    defaultAttributeLocations\n  );\n\n  let pickId = primitive._pickId;\n  const vertexShaderSource = primitive._vertexShaderSource;\n  let fragmentShaderSource = primitive._fragmentShaderSource;\n  if (defined(vertexShaderSource)) {\n    primitive._sp = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations,\n    });\n    primitive._spStencil = primitive._sp;\n\n    fragmentShaderSource = ShaderSource.replaceMain(\n      fragmentShaderSource,\n      \"czm_non_pick_main\"\n    );\n    fragmentShaderSource =\n      `${fragmentShaderSource}void main() \\n` +\n      `{ \\n` +\n      `    czm_non_pick_main(); \\n` +\n      `    gl_FragColor = ${pickId}; \\n` +\n      `} \\n`;\n    primitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations,\n    });\n    return;\n  }\n\n  const vsSource = batchTable.getVertexShaderCallback(\n    false,\n    \"a_batchId\",\n    undefined\n  )(VectorTileVS);\n  let fsSource = batchTable.getFragmentShaderCallback(\n    false,\n    undefined,\n    true\n  )(ShadowVolumeFS);\n\n  pickId = batchTable.getPickId();\n\n  let vs = new ShaderSource({\n    sources: [vsSource],\n  });\n  let fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  vs = new ShaderSource({\n    sources: [VectorTileVS],\n  });\n  fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [ShadowVolumeFS],\n  });\n\n  primitive._spStencil = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  fsSource = ShaderSource.replaceMain(fsSource, \"czm_non_pick_main\");\n  fsSource =\n    `${fsSource}\\n` +\n    `void main() \\n` +\n    `{ \\n` +\n    `    czm_non_pick_main(); \\n` +\n    `    gl_FragColor = ${pickId}; \\n` +\n    `} \\n`;\n\n  const pickVS = new ShaderSource({\n    sources: [vsSource],\n  });\n  const pickFS = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n  primitive._spPick = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: pickVS,\n    fragmentShaderSource: pickFS,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction getStencilDepthRenderState(mask3DTiles) {\n  const stencilFunction = mask3DTiles\n    ? StencilFunction.EQUAL\n    : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: false,\n  };\n}\n\nconst colorRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n  blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n};\n\nconst pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n};\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rsStencilDepthPass)) {\n    return;\n  }\n\n  primitive._rsStencilDepthPass = RenderState.fromCache(\n    getStencilDepthRenderState(false)\n  );\n  primitive._rsStencilDepthPass3DTiles = RenderState.fromCache(\n    getStencilDepthRenderState(true)\n  );\n  primitive._rsColorPass = RenderState.fromCache(colorRenderState);\n  primitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\n\nconst modifiedModelViewScratch = new Matrix4();\nconst rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  const uniformMap = {\n    u_modifiedModelViewProjection: function () {\n      const viewMatrix = context.uniformState.view;\n      const projectionMatrix = context.uniformState.projection;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive._center,\n        rtcScratch\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch\n      );\n      Matrix4.multiply(\n        projectionMatrix,\n        modifiedModelViewScratch,\n        modifiedModelViewScratch\n      );\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    },\n  };\n\n  primitive._uniformMap = primitive._batchTable.getUniformMapCallback()(\n    uniformMap\n  );\n}\n\nfunction copyIndicesCPU(\n  indices,\n  newIndices,\n  currentOffset,\n  offsets,\n  counts,\n  batchIds,\n  batchIdLookUp\n) {\n  const sizeInBytes = indices.constructor.BYTES_PER_ELEMENT;\n\n  const batchedIdsLength = batchIds.length;\n  for (let j = 0; j < batchedIdsLength; ++j) {\n    const batchedId = batchIds[j];\n    const index = batchIdLookUp[batchedId];\n    const offset = offsets[index];\n    const count = counts[index];\n\n    const subarray = new indices.constructor(\n      indices.buffer,\n      sizeInBytes * offset,\n      count\n    );\n    newIndices.set(subarray, currentOffset);\n\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchCPU(primitive, batchedIndices) {\n  const indices = primitive._indices;\n  const indexOffsets = primitive._indexOffsets;\n  const indexCounts = primitive._indexCounts;\n  const batchIdLookUp = primitive._batchIdLookUp;\n\n  const newIndices = new indices.constructor(indices.length);\n\n  let current = batchedIndices.pop();\n  const newBatchedIndices = [current];\n\n  let currentOffset = copyIndicesCPU(\n    indices,\n    newIndices,\n    0,\n    indexOffsets,\n    indexCounts,\n    current.batchIds,\n    batchIdLookUp\n  );\n\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    const next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesCPU(\n        indices,\n        newIndices,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      const offset = currentOffset;\n      currentOffset = copyIndicesCPU(\n        indices,\n        newIndices,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  primitive._va.indexBuffer.copyFromArrayView(newIndices);\n\n  primitive._indices = newIndices;\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction copyIndicesGPU(\n  readBuffer,\n  writeBuffer,\n  currentOffset,\n  offsets,\n  counts,\n  batchIds,\n  batchIdLookUp\n) {\n  const sizeInBytes = readBuffer.bytesPerIndex;\n\n  const batchedIdsLength = batchIds.length;\n  for (let j = 0; j < batchedIdsLength; ++j) {\n    const batchedId = batchIds[j];\n    const index = batchIdLookUp[batchedId];\n    const offset = offsets[index];\n    const count = counts[index];\n\n    writeBuffer.copyFromBuffer(\n      readBuffer,\n      offset * sizeInBytes,\n      currentOffset * sizeInBytes,\n      count * sizeInBytes\n    );\n\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchGPU(primitive, batchedIndices) {\n  const indexOffsets = primitive._indexOffsets;\n  const indexCounts = primitive._indexCounts;\n  const batchIdLookUp = primitive._batchIdLookUp;\n\n  let current = batchedIndices.pop();\n  const newBatchedIndices = [current];\n\n  const readBuffer = primitive._va.indexBuffer;\n  const writeBuffer = primitive._vaSwap.indexBuffer;\n\n  let currentOffset = copyIndicesGPU(\n    readBuffer,\n    writeBuffer,\n    0,\n    indexOffsets,\n    indexCounts,\n    current.batchIds,\n    batchIdLookUp\n  );\n\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    const next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesGPU(\n        readBuffer,\n        writeBuffer,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      const offset = currentOffset;\n      currentOffset = copyIndicesGPU(\n        readBuffer,\n        writeBuffer,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  const temp = primitive._va;\n  primitive._va = primitive._vaSwap;\n  primitive._vaSwap = temp;\n\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction compareColors(a, b) {\n  return b.color.toRgba() - a.color.toRgba();\n}\n\n// PERFORMANCE_IDEA: For WebGL 2, we can use copyBufferSubData for buffer-to-buffer copies.\n// PERFORMANCE_IDEA: Not supported, but we could use glMultiDrawElements here.\nfunction rebatchCommands(primitive, context) {\n  if (!primitive._batchDirty) {\n    return false;\n  }\n\n  const batchedIndices = primitive._batchedIndices;\n  const length = batchedIndices.length;\n\n  let needToRebatch = false;\n  const colorCounts = {};\n\n  for (let i = 0; i < length; ++i) {\n    const color = batchedIndices[i].color;\n    const rgba = color.toRgba();\n    if (defined(colorCounts[rgba])) {\n      needToRebatch = true;\n      break;\n    } else {\n      colorCounts[rgba] = true;\n    }\n  }\n\n  if (!needToRebatch) {\n    primitive._batchDirty = false;\n    return false;\n  }\n\n  if (\n    needToRebatch &&\n    !primitive.forceRebatch &&\n    primitive._framesSinceLastRebatch < 120\n  ) {\n    ++primitive._framesSinceLastRebatch;\n    return;\n  }\n\n  batchedIndices.sort(compareColors);\n\n  if (context.webgl2) {\n    rebatchGPU(primitive, batchedIndices);\n  } else {\n    rebatchCPU(primitive, batchedIndices);\n  }\n\n  primitive._framesSinceLastRebatch = 0;\n  primitive._batchDirty = false;\n  primitive._pickCommandsDirty = true;\n  primitive._wireframeDirty = true;\n  return true;\n}\n\nfunction createColorCommands(primitive, context) {\n  const needsRebatch = rebatchCommands(primitive, context);\n\n  const commands = primitive._commands;\n  const batchedIndices = primitive._batchedIndices;\n  const length = batchedIndices.length;\n  const commandsLength = length * 2;\n\n  if (\n    defined(commands) &&\n    !needsRebatch &&\n    commands.length === commandsLength\n  ) {\n    return;\n  }\n\n  commands.length = commandsLength;\n\n  const vertexArray = primitive._va;\n  const sp = primitive._sp;\n  const modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  const uniformMap = primitive._uniformMap;\n  const bv = primitive._boundingVolume;\n\n  for (let j = 0; j < length; ++j) {\n    const offset = batchedIndices[j].offset;\n    const count = batchedIndices[j].count;\n\n    let stencilDepthCommand = commands[j * 2];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = commands[j * 2] = new DrawCommand({\n        owner: primitive,\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = sp;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.cull = false;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    const stencilDepthDerivedCommand = DrawCommand.shallowClone(\n      stencilDepthCommand,\n      stencilDepthCommand.derivedCommands.tileset\n    );\n    stencilDepthDerivedCommand.renderState =\n      primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n\n    let colorCommand = commands[j * 2 + 1];\n    if (!defined(colorCommand)) {\n      colorCommand = commands[j * 2 + 1] = new DrawCommand({\n        owner: primitive,\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsColorPass;\n    colorCommand.shaderProgram = sp;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.cull = false;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    const colorDerivedCommand = DrawCommand.shallowClone(\n      colorCommand,\n      colorCommand.derivedCommands.tileset\n    );\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._commandsDirty = true;\n}\n\nfunction createColorCommandsIgnoreShow(primitive, frameState) {\n  if (\n    primitive.classificationType === ClassificationType.TERRAIN ||\n    !frameState.invertClassification ||\n    (defined(primitive._commandsIgnoreShow) && !primitive._commandsDirty)\n  ) {\n    return;\n  }\n\n  const commands = primitive._commands;\n  const commandsIgnoreShow = primitive._commandsIgnoreShow;\n  const spStencil = primitive._spStencil;\n\n  const commandsLength = commands.length;\n  const length = (commandsIgnoreShow.length = commandsLength / 2);\n\n  let commandIndex = 0;\n  for (let j = 0; j < length; ++j) {\n    const commandIgnoreShow = (commandsIgnoreShow[j] = DrawCommand.shallowClone(\n      commands[commandIndex],\n      commandsIgnoreShow[j]\n    ));\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n\n    commandIndex += 2;\n  }\n\n  primitive._commandsDirty = false;\n}\n\nfunction createPickCommands(primitive) {\n  if (!primitive._pickCommandsDirty) {\n    return;\n  }\n\n  const length = primitive._indexOffsets.length;\n  const pickCommands = primitive._pickCommands;\n  pickCommands.length = length * 2;\n\n  const vertexArray = primitive._va;\n  const spStencil = primitive._spStencil;\n  const spPick = primitive._spPick;\n  const modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  const uniformMap = primitive._uniformMap;\n\n  for (let j = 0; j < length; ++j) {\n    const offset = primitive._indexOffsets[j];\n    const count = primitive._indexCounts[j];\n    const bv = defined(primitive._boundingVolumes)\n      ? primitive._boundingVolumes[j]\n      : primitive.boundingVolume;\n\n    let stencilDepthCommand = pickCommands[j * 2];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = pickCommands[j * 2] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true,\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = spStencil;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    const stencilDepthDerivedCommand = DrawCommand.shallowClone(\n      stencilDepthCommand,\n      stencilDepthCommand.derivedCommands.tileset\n    );\n    stencilDepthDerivedCommand.renderState =\n      primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n\n    let colorCommand = pickCommands[j * 2 + 1];\n    if (!defined(colorCommand)) {\n      colorCommand = pickCommands[j * 2 + 1] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true,\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsPickPass;\n    colorCommand.shaderProgram = spPick;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    const colorDerivedCommand = DrawCommand.shallowClone(\n      colorCommand,\n      colorCommand.derivedCommands.tileset\n    );\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._pickCommandsDirty = false;\n}\n\n/**\n * Creates features for each mesh and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePrimitive.prototype.createFeatures = function (content, features) {\n  const batchIds = this._batchIds;\n  const length = batchIds.length;\n  for (let i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (mesh batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePrimitive.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  polygons._updatingAllCommands = true;\n\n  const batchIds = polygons._batchIds;\n  let length = batchIds.length;\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n\n  const batchedIndices = polygons._batchedIndices;\n  length = batchedIndices.length;\n\n  for (i = 0; i < length; ++i) {\n    batchedIndices[i].color = Color.clone(Color.WHITE);\n  }\n\n  polygons._updatingAllCommands = false;\n  polygons._batchDirty = true;\n}\n\nconst scratchColor = new Color();\n\nconst DEFAULT_COLOR_VALUE = Color.WHITE;\nconst DEFAULT_SHOW_VALUE = true;\n\nconst complexExpressionReg = /\\$/;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePrimitive.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  const colorExpression = style.color;\n  const isSimpleStyle =\n    colorExpression instanceof Expression &&\n    !complexExpressionReg.test(colorExpression.expression);\n  this._updatingAllCommands = isSimpleStyle;\n\n  const batchIds = this._batchIds;\n  let length = batchIds.length;\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    const batchId = batchIds[i];\n    const feature = features[batchId];\n\n    feature.color = defined(style.color)\n      ? style.color.evaluateColor(feature, scratchColor)\n      : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show)\n      ? style.show.evaluate(feature)\n      : DEFAULT_SHOW_VALUE;\n  }\n\n  if (isSimpleStyle) {\n    const batchedIndices = this._batchedIndices;\n    length = batchedIndices.length;\n\n    for (i = 0; i < length; ++i) {\n      batchedIndices[i].color = Color.clone(Color.WHITE);\n    }\n\n    this._updatingAllCommands = false;\n    this._batchDirty = true;\n  }\n};\n\n/**\n * Call when updating the color of a mesh with batchId changes color. The meshes will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the meshes whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTilePrimitive.prototype.updateCommands = function (batchId, color) {\n  if (this._updatingAllCommands) {\n    return;\n  }\n\n  const batchIdLookUp = this._batchIdLookUp;\n  const index = batchIdLookUp[batchId];\n  if (!defined(index)) {\n    return;\n  }\n\n  const indexOffsets = this._indexOffsets;\n  const indexCounts = this._indexCounts;\n\n  const offset = indexOffsets[index];\n  const count = indexCounts[index];\n\n  const batchedIndices = this._batchedIndices;\n  const length = batchedIndices.length;\n\n  let i;\n  for (i = 0; i < length; ++i) {\n    const batchedOffset = batchedIndices[i].offset;\n    const batchedCount = batchedIndices[i].count;\n\n    if (offset >= batchedOffset && offset < batchedOffset + batchedCount) {\n      break;\n    }\n  }\n\n  batchedIndices.push(\n    new Vector3DTileBatch({\n      color: Color.clone(color),\n      offset: offset,\n      count: count,\n      batchIds: [batchId],\n    })\n  );\n\n  const startIds = [];\n  const endIds = [];\n\n  const batchIds = batchedIndices[i].batchIds;\n  const batchIdsLength = batchIds.length;\n\n  for (let j = 0; j < batchIdsLength; ++j) {\n    const id = batchIds[j];\n    if (id === batchId) {\n      continue;\n    }\n\n    const offsetIndex = batchIdLookUp[id];\n    if (indexOffsets[offsetIndex] < offset) {\n      startIds.push(id);\n    } else {\n      endIds.push(id);\n    }\n  }\n\n  if (endIds.length !== 0) {\n    batchedIndices.push(\n      new Vector3DTileBatch({\n        color: Color.clone(batchedIndices[i].color),\n        offset: offset + count,\n        count:\n          batchedIndices[i].offset + batchedIndices[i].count - (offset + count),\n        batchIds: endIds,\n      })\n    );\n  }\n\n  if (startIds.length !== 0) {\n    batchedIndices[i].count = offset - batchedIndices[i].offset;\n    batchedIndices[i].batchIds = startIds;\n  } else {\n    batchedIndices.splice(i, 1);\n  }\n\n  this._batchDirty = true;\n};\n\nfunction queueCommands(primitive, frameState, commands, commandsIgnoreShow) {\n  const classificationType = primitive.classificationType;\n  const queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands =\n    classificationType !== ClassificationType.TERRAIN;\n\n  const commandList = frameState.commandList;\n  let commandLength = commands.length;\n  let command;\n  let i;\n  for (i = 0; i < commandLength; ++i) {\n    if (queueTerrainCommands) {\n      command = commands[i];\n      command.pass = Pass.TERRAIN_CLASSIFICATION;\n      commandList.push(command);\n    }\n    if (queue3DTilesCommands) {\n      command = commands[i].derivedCommands.tileset;\n      command.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n      commandList.push(command);\n    }\n  }\n\n  if (!frameState.invertClassification || !defined(commandsIgnoreShow)) {\n    return;\n  }\n\n  commandLength = commandsIgnoreShow.length;\n  for (i = 0; i < commandLength; ++i) {\n    commandList.push(commandsIgnoreShow[i]);\n  }\n}\n\nfunction queueWireframeCommands(frameState, commands) {\n  const commandList = frameState.commandList;\n  const commandLength = commands.length;\n  for (let i = 0; i < commandLength; i += 2) {\n    const command = commands[i + 1];\n    command.pass = Pass.OPAQUE;\n    commandList.push(command);\n  }\n}\n\nfunction updateWireframe(primitive) {\n  let earlyExit = primitive.debugWireframe === primitive._debugWireframe;\n  earlyExit =\n    earlyExit && !(primitive.debugWireframe && primitive._wireframeDirty);\n  if (earlyExit) {\n    return;\n  }\n\n  if (!defined(primitive._rsWireframe)) {\n    primitive._rsWireframe = RenderState.fromCache({});\n  }\n\n  let rs;\n  let type;\n\n  if (primitive.debugWireframe) {\n    rs = primitive._rsWireframe;\n    type = PrimitiveType.LINES;\n  } else {\n    rs = primitive._rsColorPass;\n    type = PrimitiveType.TRIANGLES;\n  }\n\n  const commands = primitive._commands;\n  const commandLength = commands.length;\n  for (let i = 0; i < commandLength; i += 2) {\n    const command = commands[i + 1];\n    command.renderState = rs;\n    command.primitiveType = type;\n  }\n\n  primitive._debugWireframe = primitive.debugWireframe;\n  primitive._wireframeDirty = false;\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePrimitive.prototype.update = function (frameState) {\n  const context = frameState.context;\n\n  createVertexArray(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n  createUniformMap(this, context);\n\n  const passes = frameState.passes;\n  if (passes.render) {\n    createColorCommands(this, context);\n    createColorCommandsIgnoreShow(this, frameState);\n    updateWireframe(this);\n\n    if (this._debugWireframe) {\n      queueWireframeCommands(frameState, this._commands);\n    } else {\n      queueCommands(this, frameState, this._commands, this._commandsIgnoreShow);\n    }\n  }\n\n  if (passes.pick) {\n    createPickCommands(this);\n    queueCommands(this, frameState, this._pickCommands);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePrimitive.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaSwap = this._vaSwap && this._vaSwap.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePrimitive;\n","import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * An enum describing the built-in vertex attribute semantics.\n *\n * @enum {String}\n *\n * @private\n */\nconst VertexAttributeSemantic = {\n  /**\n   * Per-vertex position.\n   *\n   * @type {String}\n   * @constant\n   */\n  POSITION: \"POSITION\",\n\n  /**\n   * Per-vertex normal.\n   *\n   * @type {String}\n   * @constant\n   */\n  NORMAL: \"NORMAL\",\n\n  /**\n   * Per-vertex tangent.\n   *\n   * @type {String}\n   * @constant\n   */\n  TANGENT: \"TANGENT\",\n\n  /**\n   * Per-vertex texture coordinates.\n   *\n   * @type {String}\n   * @constant\n   */\n  TEXCOORD: \"TEXCOORD\",\n\n  /**\n   * Per-vertex color.\n   *\n   * @type {String}\n   * @constant\n   */\n  COLOR: \"COLOR\",\n\n  /**\n   * Per-vertex joint IDs for skinning.\n   *\n   * @type {String}\n   * @constant\n   */\n  JOINTS: \"JOINTS\",\n\n  /**\n   * Per-vertex joint weights for skinning.\n   *\n   * @type {String}\n   * @constant\n   */\n  WEIGHTS: \"WEIGHTS\",\n\n  /**\n   * Per-vertex feature ID.\n   *\n   * @type {String}\n   * @constant\n   */\n  FEATURE_ID: \"_FEATURE_ID\",\n};\n\nfunction semanticToVariableName(semantic) {\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n      return \"positionMC\";\n    case VertexAttributeSemantic.NORMAL:\n      return \"normalMC\";\n    case VertexAttributeSemantic.TANGENT:\n      return \"tangentMC\";\n    case VertexAttributeSemantic.TEXCOORD:\n      return \"texCoord\";\n    case VertexAttributeSemantic.COLOR:\n      return \"color\";\n    case VertexAttributeSemantic.JOINTS:\n      return \"joints\";\n    case VertexAttributeSemantic.WEIGHTS:\n      return \"weights\";\n    case VertexAttributeSemantic.FEATURE_ID:\n      return \"featureId\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"semantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n}\n\n/**\n * Returns whether the vertex attribute semantic can have a set index.\n *\n * @param {VertexAttributeSemantic} semantic The semantic.\n *\n * @returns {Boolean} Whether the semantic can have a set index.\n *\n * @private\n */\nVertexAttributeSemantic.hasSetIndex = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n    case VertexAttributeSemantic.NORMAL:\n    case VertexAttributeSemantic.TANGENT:\n      return false;\n    case VertexAttributeSemantic.TEXCOORD:\n    case VertexAttributeSemantic.COLOR:\n    case VertexAttributeSemantic.JOINTS:\n    case VertexAttributeSemantic.WEIGHTS:\n    case VertexAttributeSemantic.FEATURE_ID:\n      return true;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"semantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the vertex attribute semantic matching the glTF semantic.\n *\n * @param {String} gltfSemantic The glTF semantic.\n *\n * @returns {VertexAttributeSemantic|undefined} The vertex attribute semantic, or undefined if there is no match.\n *\n * @private\n */\nVertexAttributeSemantic.fromGltfSemantic = function (gltfSemantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"gltfSemantic\", gltfSemantic);\n  //>>includeEnd('debug');\n\n  let semantic = gltfSemantic;\n\n  // Strip the set index from the semantic\n  const setIndexRegex = /^(\\w+)_\\d+$/;\n  const setIndexMatch = setIndexRegex.exec(gltfSemantic);\n  if (setIndexMatch !== null) {\n    semantic = setIndexMatch[1];\n  }\n\n  switch (semantic) {\n    case \"POSITION\":\n      return VertexAttributeSemantic.POSITION;\n    case \"NORMAL\":\n      return VertexAttributeSemantic.NORMAL;\n    case \"TANGENT\":\n      return VertexAttributeSemantic.TANGENT;\n    case \"TEXCOORD\":\n      return VertexAttributeSemantic.TEXCOORD;\n    case \"COLOR\":\n      return VertexAttributeSemantic.COLOR;\n    case \"JOINTS\":\n      return VertexAttributeSemantic.JOINTS;\n    case \"WEIGHTS\":\n      return VertexAttributeSemantic.WEIGHTS;\n    case \"_FEATURE_ID\":\n      return VertexAttributeSemantic.FEATURE_ID;\n  }\n\n  return undefined;\n};\n\n/**\n * Gets the vertex attribute semantic matching the pnts semantic.\n *\n * @param {String} pntsSemantic The pnts semantic.\n *\n * @returns {VertexAttributeSemantic|undefined} The vertex attribute semantic, or undefined if there is no match.\n *\n * @private\n */\nVertexAttributeSemantic.fromPntsSemantic = function (pntsSemantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"pntsSemantic\", pntsSemantic);\n  //>>includeEnd('debug');\n\n  switch (pntsSemantic) {\n    case \"POSITION\":\n    case \"POSITION_QUANTIZED\":\n      return VertexAttributeSemantic.POSITION;\n    case \"RGBA\":\n    case \"RGB\":\n    case \"RGB565\":\n      return VertexAttributeSemantic.COLOR;\n    case \"NORMAL\":\n    case \"NORMAL_OCT16P\":\n      return VertexAttributeSemantic.NORMAL;\n    case \"BATCH_ID\":\n      return VertexAttributeSemantic.FEATURE_ID;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"pntsSemantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the GLSL type (such as <code>vec3</code> or <code>int</code>) for the\n * given vertex attribute.\n *\n * @param {VertexAttributeSemantic} semantic The semantic.\n *\n * @returns {String} The shader type.\n *\n * @private\n */\nVertexAttributeSemantic.getGlslType = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n    case VertexAttributeSemantic.NORMAL:\n    case VertexAttributeSemantic.TANGENT:\n      return \"vec3\";\n    case VertexAttributeSemantic.TEXCOORD:\n      return \"vec2\";\n    case VertexAttributeSemantic.COLOR:\n      return \"vec4\";\n    case VertexAttributeSemantic.JOINTS:\n      return \"ivec4\";\n    case VertexAttributeSemantic.WEIGHTS:\n      return \"vec4\";\n    case VertexAttributeSemantic.FEATURE_ID:\n      return \"int\";\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"semantic is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Gets the variable name for the given semantic and set index.\n *\n * @param {VertexAttributeSemantic} semantic The semantic.\n * @param {Number} [setIndex] The set index.\n *\n * @returns {String} The variable name.\n *\n * @private\n */\nVertexAttributeSemantic.getVariableName = function (semantic, setIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let variableName = semanticToVariableName(semantic);\n  if (defined(setIndex)) {\n    variableName += `_${setIndex}`;\n  }\n  return variableName;\n};\n\nexport default Object.freeze(VertexAttributeSemantic);\n","/**\n * The vertical location of an origin relative to an object, e.g., a {@link Billboard}\n * or {@link Label}.  For example, setting the vertical origin to <code>TOP</code>\n * or <code>BOTTOM</code> will display a billboard above or below (in screen space)\n * the anchor position.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />\n * </div>\n *\n * @enum {Number}\n *\n * @see Billboard#verticalOrigin\n * @see Label#verticalOrigin\n */\nconst VerticalOrigin = {\n  /**\n   * The origin is at the vertical center between <code>BASELINE</code> and <code>TOP</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  CENTER: 0,\n\n  /**\n   * The origin is at the bottom of the object.\n   *\n   * @type {Number}\n   * @constant\n   */\n  BOTTOM: 1,\n\n  /**\n   * If the object contains text, the origin is at the baseline of the text, else the origin is at the bottom of the object.\n   *\n   * @type {Number}\n   * @constant\n   */\n  BASELINE: 2,\n\n  /**\n   * The origin is at the top of the object.\n   *\n   * @type {Number}\n   * @constant\n   */\n  TOP: -1,\n};\nexport default Object.freeze(VerticalOrigin);\n"],"names":["ShadowMap","options","context","lightCamera","numberOfCascades","this","_enabled","enabled","_softShadows","softShadows","_normalOffset","normalOffset","dirty","fromLightSource","darkness","_darkness","fadingEnabled","maximumDistance","_outOfView","_outOfViewPrevious","_needsUpdate","numberOfPasses","polygonOffsetSupported","depthTexture","_polygonOffsetSupported","_terrainBias","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","normalOffsetScale","normalShading","normalShadingSmooth","depthBias","_primitiveBias","_pointBias","_depthAttachment","undefined","_colorAttachment","_shadowMapMatrix","_shadowMapTexture","_lightDirectionEC","_lightPositionEC","_distance","_lightCamera","_shadowMapCamera","ShadowMapCamera","_shadowMapCullingVolume","_sceneCamera","_boundingSphere","_isPointLight","isPointLight","_pointLightRadius","pointLightRadius","_cascadesEnabled","cascadesEnabled","_numberOfCascades","_fitNearFar","_maximumCascadeDistances","Number","MAX_VALUE","_textureSize","_isSpotLight","frustum","fov","_cascadeSplits","_cascadeMatrices","_cascadeDistances","_passes","Array","i","ShadowPass","debugShow","debugFreezeFrame","_debugFreezeFrame","_debugCascadeColors","_debugLightFrustum","_debugCameraFrustum","_debugCascadeFrustums","_debugShadowViewCommand","_usesDepthTexture","_primitiveRenderState","_terrainRenderState","_pointRenderState","createRenderStates","_clearCommand","depth","color","_clearPassState","_size","size","camera","passState","framebuffer","textureOffsets","commandList","cullingVolume","createRenderState","colorMask","bias","cull","face","depthTest","red","green","blue","alpha","depthMask","factor","units","shadowMap","destroyFramebuffer","length","pass","isDestroyed","destroy","createFramebuffer","depthRenderbuffer","width","x","height","y","format","cubeMap","pixelFormat","pixelDatatype","sampler","faces","negativeX","negativeY","negativeZ","positiveX","positiveY","positiveZ","colorTextures","destroyAttachments","createFramebufferCube","depthStencilTexture","createFramebufferDepth","colorTexture","createFramebufferColor","updateFramebuffer","status","checkFramebuffer","clearFramebuffer","shadowPass","execute","MAXIMUM_DISTANCE","prototype","debugCreateRenderStates","Object","defineProperties","get","set","value","passes","textureSize","faceViewport","viewport","biasX","biasY","scaleX","scaleY","resize","outOfView","shadowMapCullingVolume","debugCascadeColors","scratchViewport","updateDebugShadowViewCommand","frameState","screenWidth","drawingBufferWidth","screenHeight","drawingBufferHeight","Math","min","debugCommand","fs","drawCommand","createViewportQuadCommand","uniformMap","shadowMap_texture","shadowMap_textureCube","createDebugShadowViewCommand","renderState","push","frustumCornersNDC","scratchMatrix","scratchFrustumCorners","debugOutlineColors","scratchScale","applyDebugSettings","enterFreezeFrame","updateOnChange","update","translation","positionWC","rotation","uniformScale","scale","modelMatrix","box","geometry","minimum","maximum","attributes","sphere","radius","geometryInstances","appearance","translucent","flat","asynchronous","createDebugPointLight","viewMatrix","inverseViewMatrix","positionCartographic","directionWC","upWC","rightWC","viewProjectionMatrix","clone","scaleBiasMatrix","getViewProjection","view","projection","projectionMatrix","scratchSplits","scratchFrustum","scratchCascadeDistances","scratchMin","scratchMax","scratchLightView","scratchRight","scratchUp","scratchTranslation","directions","ups","rights","scratchCartesian1","scratchCartesian2","scratchBoundingSphere","scratchCenter","center","updateCameras","sceneCamera","shadowMapCamera","lightDirection","near","far","w","shadowState","nearPlane","farPlane","max","boundingSphere","surfaceNormal","mapProjection","ellipsoid","geodeticSurfaceNormal","dot","darknessAmount","computeVisibility","equals","frustumRadius","frustumCenter","checkVisibility","aspectRatio","cartesianToCartographic","computeOmnidirectional","viewProjection","inverseViewProjection","lightDir","lightUp","lightRight","lightPosition","lightView","cameraToLight","corner","z","translationMatrix","halfWidth","halfHeight","left","right","bottom","top","fitShadowMapToScene","cameraNear","cameraFar","range","ratio","lambda","clampCascadeDistances","closestObjectSize","cascadeDistances","splits","p","logScale","pow","split","distance","shadowFrustum","position","direction","up","cascadeSubFrustum","shadowViewProjection","shadowMapMatrix","k","cascadeCamera","computeCullingVolume","cascadeMatrix","computeCascades","inverseView","updatePass","scratchTexelStepSize","combineUniforms","uniforms","isTerrain","mapUniforms","shadowMap_matrix","shadowMap_cascadeSplits","shadowMap_cascadeMatrices","shadowMap_lightDirectionEC","shadowMap_lightPositionEC","shadowMap_cascadeDistances","shadowMap_texelSizeDepthBiasAndNormalShadingSmooth","texelStepSize","combinedUniforms1","shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness","combinedUniforms2","createCastDerivedCommand","shadowsDirty","command","oldShaderId","result","castShader","castRenderState","castUniformMap","shaderProgram","castShadows","receiveShadows","id","isOpaque","usesDepthTexture","keyword","shaderCache","getDerivedShaderProgram","vertexShaderSource","fragmentShaderSource","castVS","castFS","createDerivedShaderProgram","attributeLocations","_attributeLocations","createReceiveDerivedCommand","lightShadowMaps","lightShadowMapsEnabled","hasTerrainNormal","owner","data","renderedMesh","encoding","hasVertexNormals","receiveShader","receiveUniformMap","receiveCommand","castShadowsDirty","receiveShaderCastShadows","shaderDirty","receiveShaderProgramId","receiveVS","receiveFS","shadowMaps","castCommands","castShaderProgramId","shadowMapLength","ShadowMapShader","getShadowCastShaderKeyword","createShadowCastVertexShader","vs","defines","slice","sources","positionVaryingName","hasPositionVarying","j","shadowVS","createShadowCastFragmentShader","opaque","fsSource","getShadowReceiveShaderKeyword","createShadowReceiveVertexShader","createShadowReceiveFragmentShader","normalVaryingName","hasNormalVarying","isSpotLight","hasCascades","returnPositionEC","ShadowMode","DISABLED","ENABLED","CAST_ONLY","RECEIVE_ONLY","shadowMode","freeze","ShadowVolumeAppearance","extentsCulling","planarExtents","_projectionExtentDefines","eastMostYhighDefine","eastMostYlowDefine","westMostYhighDefine","westMostYlowDefine","colorShaderDependencies","ShaderDependencies","requiresTextureCoordinates","requiresEC","pickShaderDependencies","requiresNormalEC","materialShaderSource","material","shaderSource","normalEC","indexOf","positionToEyeEC","tangentToEyeMatrix","st","_colorShaderDependencies","_pickShaderDependencies","_appearance","_extentsCulling","_planarExtents","createFragmentShader","columbusView2D","dependencies","requiresWC","materialSource","createPickFragmentShader","pickColorQualifier","createVertexShader","createShadowVolumeAppearanceVS","createPickVertexShader","longitudeExtentsCartesianScratch","longitudeExtentsCartographicScratch","longitudeExtentsEncodeScratch","high","low","shaderDependencies","projectionExtentDefines","allDefines","eastMostCartographic","longitude","latitude","eastMostCartesian","project","encoded","toFixed","westMostCartographic","westMostCartesian","_requiresEC","_requiresWC","_requiresNormalEC","_requiresTextureCoordinates","_usesNormalEC","_usesPositionToEyeEC","_usesTangentToEyeMat","_usesSt","pointLineDistance","point1","point2","point","abs","points2DScratch","addTextureCoordinateRotationAttributes","textureCoordinateRotationPoints","points2D","minXYCorner","maxYCorner","maxXCorner","uMaxVmax","componentDatatype","componentsPerAttribute","normalize","inverseExtentX","inverseExtentY","uvMinAndExtents","cartographicScratch","cornerScratch","northWestScratch","southEastScratch","highLowScratch","add2DTextureCoordinateAttributes","rectangle","carto","west","south","southWestCorner","north","northWest","east","southEast","valuesHigh","valuesLow","planes2D_HIGH","planes2D_LOW","enuMatrixScratch","inverseEnuScratch","rectanglePointCartesianScratch","rectangleCenterScratch","pointsCartographicScratch","eastwardScratch","northwardScratch","encodeScratch","getPlanarTextureCoordinateAttributes","boundingRectangle","eastward","northward","southWestCornerResult","eastVectorResult","northVectorResult","centerCartographic","centerCartesian","enuMatrix","inverseEnu","cartographics","longitudeCenter","latitudeCenter","minX","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","pointCartesian","southEastCorner","northWestCorner","computeRectangleBounds","southWest_HIGH","southWest_LOW","spherePointScratch","latLongToSpherical","cartographic","spherePoint","magXY","sqrt","sphereLatitude","sphereLongitude","sphericalScratch","getSphericalExtentGeometryInstanceAttributes","southWestExtents","northEastExtents","rotationRadians","longitudeRangeInverse","latitudeRangeInverse","sphericalExtents","longitudeRotation","hasAttributesForTextureCoordinatePlanes","hasAttributesForSphericalExtents","shouldUseSphericalCoordinates","MAX_WIDTH_FOR_PLANAR_EXTENTS","shouldUseSpherical","SingleTileImageryProvider","url","defaultAlpha","defaultNightAlpha","defaultDayAlpha","defaultBrightness","defaultContrast","defaultHue","defaultSaturation","defaultGamma","defaultMinificationFilter","defaultMagnificationFilter","resource","tilingScheme","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","_tilingScheme","_resource","_image","_texture","_tileWidth","_tileHeight","_errorEvent","_ready","_readyPromise","credit","_credit","that","error","success","image","resolve","failure","e","message","doRequest","retry","reject","then","catch","proxy","tileWidth","tileHeight","maximumLevel","minimumLevel","tileDiscardPolicy","errorEvent","ready","readyPromise","promise","hasAlphaChannel","getTileCredits","level","requestImage","request","Promise","pickFeatures","SkyAtmosphere","show","perFragmentAtmosphere","_ellipsoid","scaleVector","radii","_scaleMatrix","_modelMatrix","_command","_spSkyFromSpace","_spSkyFromAtmosphere","_flags","atmosphereLightIntensity","atmosphereRayleighCoefficient","atmosphereMieCoefficient","atmosphereRayleighScaleHeight","atmosphereMieScaleHeight","atmosphereMieAnisotropy","hueShift","saturationShift","brightnessShift","_hueSaturationBrightness","radiiAndDynamicAtmosphereColor","maximumRadius","_radiiAndDynamicAtmosphereColor","u_radiiAndDynamicAtmosphereColor","u_hsbShift","u_atmosphereLightIntensity","u_atmosphereRayleighCoefficient","u_atmosphereMieCoefficient","u_atmosphereRayleighScaleHeight","u_atmosphereMieScaleHeight","u_atmosphereMieAnisotropy","setDynamicAtmosphereColor","enableLighting","useSunDirection","lightEnum","scratchModelMatrix","globe","mode","render","rotationMatrix","uniformState","inverseViewRotation","rotationOffsetMatrix","colorCorrect","skyAtmosphere","globeTranslucencyState","vertexArray","slicePartitions","stackPartitions","vertexFormat","bufferUsage","blending","flags","_spSkyAtmosphere","SkyBox","_sources","_cubeMap","_useHdr","useHdr","source","u_cubeMap","dimensions","SphereEmitter","_radius","emit","particle","theta","phi","rad","cos","sin","velocity","LEFT","NONE","RIGHT","modifyFragmentShader","shader","addUniforms","object","czm_splitDirection","splitDirection","StencilConstants","CESIUM_3D_TILE_MASK","SKIP_LOD_MASK","SKIP_LOD_BIT_SHIFT","CLASSIFICATION_MASK","frontFunction","frontOperation","fail","zFail","zPass","backFunction","backOperation","reference","mask","StencilFunction","NEVER","LESS","EQUAL","LESS_OR_EQUAL","GREATER","NOT_EQUAL","GREATER_OR_EQUAL","ALWAYS","StencilOperation","ZERO","KEEP","REPLACE","INCREMENT","DECREMENT","INVERT","INCREMENT_WRAP","DECREMENT_WRAP","StructuralMetadata","schema","_schema","propertyTables","_propertyTableCount","_propertyTables","_propertyTextures","propertyTextures","_propertyAttributes","propertyAttributes","_statistics","statistics","_extras","extras","_extensions","extensions","propertyTableCount","getPropertyTable","propertyTableId","getPropertyTexture","propertyTextureId","getPropertyAttribute","propertyAttributeId","StyleExpression","evaluate","feature","evaluateColor","getShaderFunction","functionSignature","variableSubstitutionMap","shaderState","returnType","getVariables","Sun","_drawCommand","primitiveType","boundingVolume","_commands","computeCommand","_boundingVolume","_boundingVolume2D","_drawingBufferWidth","_drawingBufferHeight","_radiusTS","glowFactor","_glowFactorDirty","_uniformMap","u_texture","u_size","_glowFactor","scratchPositionWC","scratchLimbWC","scratchPositionEC","scratchCartesian4","ceil","log","halfFloatingPointTexture","_glowLengthTS","u_radiusTS","outputTexture","persists","postExecute","Uint8Array","vertexBuffer","typedArray","usage","index","indexBuffer","Uint16Array","indexDatatype","sunPosition","sunPositionWC","sunPositionCV","sunPositionColumbusView","boundingVolume2D","dist","projMatrix","positionEC","positionCC","limbCC","limbWC","intensity","SunPostProcess","_sceneFramebuffer","stages","fragmentShader","textureScale","forcePowerOfTwo","sampleMode","brightPass","avgLuminance","threshold","offset","_delta","_sigma","_blurStep","step","delta","sigma","_uCenter","_uRadius","colorTexture2","getColorTexture","_stages","textureCache","_textureCache","getStageByName","name","stage","sunPositionECScratch","sunPositionWCScratch","sizeScratch","postProcessMatrix4Scratch","clear","clearColor","sceneFramebuffer","postProcess","us","viewportTransformation","sunPositionEC","sunSize","firstStage","downSampleWidth","downSampleHeight","downSampleViewport","scissorRectangle","updateSunPosition","copy","_copyColorCommand","SupportedImageFormats","webp","basis","TerrainFillMesh","tile","frameLastUpdated","westMeshes","westTiles","southMeshes","southTiles","eastMeshes","eastTiles","northMeshes","northTiles","southwestMesh","southwestTile","southeastMesh","southeastTile","northwestMesh","northwestTile","northeastMesh","northeastTile","changedThisFrame","visitedFrame","enqueuedFrame","mesh","waterMaskTexture","waterMaskTranslationAndScale","tileProvider","vertexArraysToDestroy","createFillMesh","_destroyVertexArray","referenceCount","traversalQueueScratch","visitRenderedTiles","sourceTile","startTile","currentFrameNumber","tileEdge","downOnly","traversalQueue","_lastSelectionResultFrame","_lastSelectionResult","parent","northwestChild","northeastChild","southwestChild","southeastChild","destinationTile","frameNumber","destinationSurfaceTile","fill","enqueue","destinationFill","sourceMesh","sourceFill","edgeMeshes","edgeTiles","startIndex","endIndex","existingTile","existingRectangle","sourceRectangle","epsilon","destinationRectangle","splice","propagateEdge","visitTile","updateFillTiles","renderedTiles","quadtree","_quadtree","levelZeroTiles","_levelZeroTiles","lastSelectionFrameNumber","_lastSelectionFrameNumber","renderedTile","dequeue","tileToWest","findTileToWest","tileToSouth","findTileToSouth","tileToEast","findTileToEast","tileToNorth","findTileToNorth","tileToNorthwest","tileToSouthwest","tileToNortheast","tileToSoutheast","centerCartographicScratch","cartesianScratch","normalScratch","octEncodedNormalScratch","uvScratch2","uvScratch","HeightAndNormal","encodedNormal","fillMissingCorner","u","v","adjacentCorner1","adjacentCorner2","oppositeCorner","vertex","tileBoundingRegion","minimumHeight","maximumHeight","getVertexWithHeightAtCorner","heightRangeScratch","swVertexScratch","seVertexScratch","nwVertexScratch","neVertexScratch","heightmapBuffer","scratchCreateMeshSyncOptions","exaggeration","exaggerationRelativeHeight","terrainProvider","_imageryLayers","surfaceTile","terrainExaggeration","terrainExaggerationRelativeHeight","hasExaggeration","nwCorner","getCorner","swCorner","seCorner","neCorner","southwestHeight","southeastHeight","northwestHeight","northeastHeight","middleHeight","len","geometricError","getLevelMaximumGeometricError","minCutThroughRadius","maxTileWidth","acos","terrainData","buffer","structure","heightOffset","createMeshSyncOptions","_createMeshSync","hasGeodeticSurfaceNormals","cartographicToCartesian","meshes","maxVertexCount","eastIndicesNorthToSouth","northIndicesWestToEast","westIndicesSouthToNorth","southIndicesEastToWest","heightRange","stride","Float32Array","nextIndex","northwestIndex","addVertexWithComputedPosition","addEdge","southwestIndex","southeastIndex","northeastIndex","obb","southMercatorY","oneOverMercatorHeight","centerWebMercatorT","geodeticSurfaceNormalCartographic","centerEncodedNormal","centerIndex","encode","vertexCount","indexCount","indexDataBytes","indices","BYTES_PER_ELEMENT","indexOut","ellipsoidalOccluder","_occluders","cornerPositions","cornerPositionsScratch","computeHorizonCullingPointPossiblyUnderEllipsoid","computeOccludeePoint","processImagery","oldTexture","hasWaterMask","waterSourceTile","_findAncestorTileWithTerrainData","_computeWaterMaskTranslationAndScale","webMercatorT","uv","sourceRectangleScratch","transformTextureCoordinates","targetTile","coordinates","targetRectangle","getNumberOfXTilesAtLevel","sourceWidth","umin","umax","sourceHeight","vmin","vmax","EPSILON5","encodedNormalScratch","getVertexFromTileAtCorner","sourceIndex","sourceEncoding","sourceVertices","vertices","decodeHeight","getOctEncodedNormal","normal","encodedNormalScratch2","cartesianScratch2","terrainFillMesh","cornerTile","cornerMesh","previousEdgeTiles","previousEdgeMeshes","nextEdgeTiles","nextEdgeMeshes","getCornerFromEdge","vertexIndex","meshIsUsable","getClosestHeightToCorner","previousMeshes","previousTiles","previousEdge","nextMeshes","nextTiles","nextEdge","height1","getNearestHeightOnEdge","height2","addEdgeMesh","edgeTile","edgeMesh","lastU","lastV","compareU","decodeTextureCoordinates","targetStride","hasWebMercatorT","uOrV","nearlyEdgeU","nearlyEdgeV","decodePosition","tiles","isNext","edge","meshStart","meshEnd","meshStep","meshIndex","edgeVertices","increasing","vertexIndexIndex","targetUv","textureCoordinate","previousIndex","interpolateU","previousUv","nextUv","encodedNormal1","encodedNormal2","normal1","normal2","getInterpolatedVertexAtCorner","FAILED","UNLOADED","RECEIVING","RECEIVED","TRANSFORMING","TRANSFORMED","READY","TextureAtlasNode","bottomLeft","topRight","childNode1","childNode2","imageIndex","defaultInitialSize","TextureAtlas","borderWidthInPixels","initialSize","_context","_pixelFormat","_borderWidthInPixels","_textureCoordinates","_guid","_idHash","_indexHash","_initialSize","_root","findNode","textureAtlas","node","nodeWidth","nodeHeight","widthDifference","heightDifference","childNode2BottomLeftX","childNode2BottomLeftY","addImage","atlasWidth","atlasHeight","h","copyFrom","xOffset","yOffset","numImages","numberOfImages","oldAtlasWidth","oldAtlasHeight","widthRatio","heightRatio","nodeBottomRight","nodeBottomHalf","nodeTopHalf","nodeMain","texCoord","newTexture","_bind","copyFromFramebuffer","_unBind","initialWidth","initialHeight","resizeAtlas","getIndex","atlas","textureCoordinates","texture","guid","getImageIndex","addImageSync","indexPromise","fetchImage","addSubRegion","subRegion","baseRegion","TileBoundingRegion","southwestCornerCartesian","northeastCornerCartesian","westNormal","southNormal","eastNormal","northNormal","tileBB","westernMidpointCartesian","westernMidpointScratch","westNormalScratch","easternMidpointCartesian","easternMidpointScratch","cartesian3Scratch","westVector","eastWestNormal","eastWestNormalScratch","southSurfaceNormal","southCenterCartesian","rayScratch","origin","westPlane","planeScratch","cartesian3Scratch2","cartesian3Scratch3","northSurfaceNormal","northCenterCartesian","eastPlane","computeBox","_orientedBoundingBox","computeBoundingVolumes","southwestCornerScratch","northeastCornerScratch","negativeUnitY","negativeUnitZ","vectorScratch","distanceToCamera","regionResult","cameraCartesianPosition","cameraCartographicPosition","cameraHeight","vectorFromSouthwestCorner","distanceToWestPlane","distanceToSouthPlane","vectorFromNortheastCorner","distanceToEastPlane","distanceToNorthPlane","distanceAboveTop","distanceBelowBottom","distanceToCameraRegion","obbResult","distanceSquaredTo","intersectPlane","plane","createDebugVolume","extrudedHeight","instance","TileBoundingS2Cell","token","s2Cell","boundingPlanes","planes","centerPoint","getCenter","centerSurfaceNormal","centerGeodeticNormalScratch","topCartographic","topCartographicScratch","topScratch","topPlane","maxDistance","vertexCartographic","getVertex","vertexCartographicScratch","vertexScratch","bottomPlane","adjacentVertex","geodeticNormal","vertexGeodeticNormalScratch","side","sideScratch","sideNormal","sideNormalScratch","computeBoundingPlanes","_boundingPlanes","computeIntersection","computeVertices","_vertices","_edgeNormals","computeEdgeNormals","_planeVertices","n0Scratch","n1Scratch","n2Scratch","x0Scratch","x1Scratch","x2Scratch","t0Scratch","t1Scratch","t2Scratch","f0Scratch","f1Scratch","f2Scratch","sScratch","matrixScratch","p0","p1","p2","determinant","edgeScratch","edgeNormalScratch","edgeNormals","facePointScratch","selectedPlaneIndices","sidePlaneIndex","facePoint","selectedPlane","closestPointPolygon","closestPointLineSegment","minimumDistance","skip","dScratch","pL0Scratch","l0","l1","d","pL0","t","dMag","edgePlaneScratch","closestPoint","closestPointOnEdge","minDistance","edgePlane","plusCount","negCount","topPlanePolygon","polygonHierarchy","positions","topPlaneGeometry","topPlaneInstance","bottomPlanePolygon","bottomPlaneGeometry","bottomPlaneInstance","sideInstances","sidePlanePolygon","sidePlaneGeometry","TileBoundingSphere","TileBoundingVolume","TileCoordinatesImageryProvider","_color","canvas","document","createElement","getContext","cssColor","toCssColorString","strokeStyle","lineWidth","strokeRect","font","textAlign","fillStyle","fillText","TileDiscardPolicy","isReady","shouldDiscardImage","TileImagery","imagery","textureCoordinateRectangle","useWebMercatorT","readyImagery","loadingImagery","textureTranslationAndScale","freeResources","releaseReference","processStateMachine","skipLoading","imageryLayer","state","_calculateTextureTranslationAndScale","closestAncestorThatNeedsLoading","ancestor","addReference","TileMapServiceImageryProvider","deferred","_tmsResource","_xmlResource","_options","_deferred","_metadataError","_metadataSuccess","bind","_metadataFailure","_requestMetadata","appendForwardSlash","getDerivedResource","confineRectangleToTilingScheme","calculateSafeMinimumDetailLevel","swTile","positionToTileXY","neTile","create","constructor","fetchXML","xml","tileFormatRegex","tileSetRegex","tileSetsRegex","bboxRegex","bbox","tilesets","tilesetsList","xmlResource","metadataError","requestMetadata","nodeList","childNodes","test","item","nodeName","tileSetNodes","fileExtension","getAttribute","parseInt","tilingSchemeName","sw","ne","swXY","neXY","flipXY","parseFloat","isGdal2tiles","unproject","templateResource","TileMetadata","metadataClass","class","_class","_properties","properties","hasProperty","propertyId","hasPropertyBySemantic","semantic","getPropertyIds","results","getProperty","setProperty","getPropertyBySemantic","setPropertyBySemantic","scratchU","scratchV","scratchW","scratchCartesian","computeMissingVector","a","b","magnitude","findOrthogonalVector","temp","checkHalfAxes","halfAxes","uZero","vZero","wZero","TileOrientedBoundingBox","TileReplacementQueue","head","tail","count","_lastBeforeStartOfFrame","remove","tileReplacementQueue","previous","replacementPrevious","next","replacementNext","markStartOfRenderFrame","trimTiles","maximumTiles","tileToTrim","keepTrimming","eligibleForUnloading","markTileRendered","TileSelectionResult","CULLED","RENDERED","REFINED","RENDERED_AND_KICKED","REFINED_AND_KICKED","CULLED_BUT_NEEDED","wasKicked","originalResult","kick","START","LOADING","UPSAMPLED_ONLY","Tileset3DTileContent","tileset","json","_tileset","_tile","featurePropertiesDirty","_metadata","_group","content","loadTileset","initialize","featuresLength","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","innerContents","getUrlComponent","batchTable","metadata","group","batchId","getFeature","applyStyle","style","TilesetMetadata","TimeDynamicImagery","clock","times","requestImageFunction","reloadFunction","_tileCache","_tilesRequestedForInterval","_clock","_times","_requestImageFunction","_reloadFunction","_currentIntervalIndex","onTick","addEventListener","_clockOnTick","getKey","getApproachingInterval","time","currentTime","isAnimating","canAnimate","shouldAnimate","multiplier","seconds","interval","stop","start","addToCache","tileCache","intervalTileCache","key","keyElements","s","getKeyElements","throttle","throttleByServer","type","priorityFunction","currentInterval","getFromCache","cache","checkApproachingInterval","tilesRequestedForInterval","approachingInterval","currentIntervalIndex","currentCache","hasOwnProperty","cancel","tilesRequested","pop","TimeDynamicPointCloud","intervals","shadows","maximumMemoryUsage","shading","frameFailed","frameChanged","_intervals","_clippingPlanes","clippingPlanes","_pointCloudEyeDomeLighting","_loadTimestamp","_clippingPlanesState","_styleDirty","_pickId","_totalMemoryUsageInBytes","_frames","_previousInterval","_nextInterval","_lastRenderedFrame","_clockMultiplier","_resolveReadyPromise","_runningSum","_runningLength","_runningIndex","_runningSamples","_runningAverage","getFragmentShaderLoaded","getPickIdLoaded","totalMemoryUsageInBytes","pointCloud","makeStyleDirty","_getAverageLoadTime","scratchDate","getClockMultiplier","getIntervalIndex","requestFrame","frames","frame","transformArray","transform","uri","timestamp","sequential","touchedFrameNumber","arrayBuffer","stream","fragmentShaderLoaded","uniformMapLoaded","czm_pickColor","pickIdLoaded","toString","numberOfListeners","raiseEvent","handleFrameFailure","prepareFrame","updateState","lengthBeforeUpdate","renderFrame","loadTime","updateAverageLoadTime","defaultShading","timeSinceLoad","isClipped","attenuation","backFaceCulling","baseResolution","volume","getGeometricError","geometricErrorScale","maximumAttenuation","getMaximumAttenuation","loadFrame","unloadFrames","unloadCondition","updateInterval","clippingPlanesDirty","createPickId","primitive","clippingPlanesState","styleDirty","framesLength","setFramesDirty","eyeDomeLighting","previousInterval","nextInterval","getCurrentInterval","clockMultiplierChanged","clockMultiplier","clockPaused","currentIndex","reachedInterval","averageLoadTime","getNextInterval","getNearestReadyInterval","getFrame","afterRender","getUnloadCondition","addedCommandsLength","Tonemapper","REINHARD","MODIFIED_REINHARD","FILMIC","ACES","validate","tonemapper","TranslucentTileClassification","_drawClassificationFBO","createDepthAttachments","_accumulationFBO","_packFBO","_opaqueDepthStencilTexture","_textureToComposite","_translucentDepthStencilTexture","_packDepthCommand","_accumulateCommand","_compositeCommand","_copyCommand","_clearColorCommand","_clearDepthStencilCommand","stencil","_supported","_viewport","_rsDepth","_rsAccumulate","_rsComp","_useScissorTest","_scissorRectangle","_hasTranslucentDepth","_frustumsDrawn","destroyTextures","transpClass","destroyFramebuffers","updateResources","globeDepthStencilTexture","isSupported","isDirty","updateTextures","setDepthStencilTexture","updateFramebuffers","u_opaqueDepthTexture","u_translucentDepthTexture","compositeCommand","compositeProgram","compositePickProgram","compositePickCommand","derivedCommands","pick","useScissorTest","updateScissor","scissorTest","stencilTest","hasTranslucentDepth","executeTranslucentCommands","scene","executeCommand","commands","useLogDepth","logDepth","depthForTranslucentClassification","depthOnlyCommand","executeClassificationCommands","frustumCommands","swapGlobeDepth","globeDepthTexture","translucentTileClassification","Tween","tweens","tweenjs","startObject","stopObject","duration","delay","easingFunction","complete","_tweens","_tweenjs","_startObject","_stopObject","_duration","_delay","_easingFunction","_update","_complete","needsStart","TweenCollection","cancelTween","add","delayInSeconds","to","easing","onUpdate","onComplete","repeat","_repeat","tween","addProperty","property","startValue","stopValue","addAlpha","addOffsetIncrement","Infinity","removeAll","contains","templateRegex","tags","imageryProvider","padWithZerosIfNecessary","_subdomains","reverseX","reverseY","getNumberOfYTilesAtLevel","reverseZ","westDegrees","computeDegrees","degreesScratch","southDegrees","eastDegrees","northDegrees","westProjected","computeProjected","projectedScratch","southProjected","eastProjected","northProjected","pickFeaturesTags","computeIJ","ijScratch","reverseI","reverseJ","longitudeDegrees","latitudeDegrees","longitudeProjected","computeLongitudeLatitudeProjected","longitudeLatitudeProjectedScratch","latitudeProjected","UrlTemplateImageryProvider","_urlSchemeZeroPadding","_pickFeaturesResource","_maximumLevel","_minimumLevel","_rectangle","_tileDiscardPolicy","_hasAlphaChannel","_tags","_pickFeaturesTags","enablePickFeatures","reinitialize","urlSchemeZeroPadding","pickFeaturesUrl","customTags","allTags","allPickFeaturesTags","pickFeaturesResource","_getFeatureInfoFormats","getFeatureInfoFormats","subdomains","isArray","degreesScratchComputed","projectedScratchComputed","templateValues","match","forEach","tag","substring","buildImageResource","formatIndex","handleResponse","callback","ijScratchComputed","longitudeLatitudeProjectedScratchComputed","buildPickFeaturesResource","fetchJson","fetchText","fetch","responseType","paddingTemplate","paddingTemplateWidth","join","tileXYToRectangle","tileXYToNativeRectangle","rectangleScratch","projected","batchIds","Vector3DTileClampedPolylines","polylines","_positions","_widths","widths","_counts","counts","_batchIds","_minimumHeight","_maximumHeight","_center","_batchTable","_va","_sp","_rs","_transferrableBatchIds","_packedBuffer","_minimumMaximumVectorHeights","_classificationType","classificationType","_keepDecodedPositions","keepDecodedPositions","_decodedPositions","_decodedPositionOffsets","_startEllipsoidNormals","_endEllipsoidNormals","_startPositionAndHeights","_startFaceNormalAndVertexCornerIds","_endPositionAndHeights","_endFaceNormalAndHalfWidths","_vertexBatchIds","_indices","_constantColor","_highlightColor","_trianglesLength","_geometryByteLength","minimumTerrainHeight","maximumTerrainHeight","minimumMaximumVectorHeights","rect","updateMinimumMaximumHeights","_verticesPromise","packedBuffer","packedLength","Float64Array","packBuffer","transferrableObjects","parameters","verticesPromise","createVerticesTaskProcessor","scheduleTask","decodedPositions","Uint32Array","decodedPositionOffsets","startEllipsoidNormals","endEllipsoidNormals","startPositionAndHeights","startFaceNormalAndVertexCornerIds","endPositionAndHeights","endFaceNormalAndHalfWidths","vertexBatchIds","createVertexArray","u_modifiedModelView","modifiedModelViewScratch","rtcScratch","u_highlightColor","u_minimumMaximumVectorHeights","createUniformMap","vsSource","getVertexShaderCallback","getFragmentShaderCallback","createShaders","getRenderState","_rs3DTiles","getUniformMapCallback","pickId","getPickId","derivedTilesetCommand","queueCommands","batchIdAttribute","byteLength","startEllipsoidNormalsBuffer","endEllipsoidNormalsBuffer","startPositionAndHeightsBuffer","endPositionAndHeightsBuffer","startFaceNormalAndVertexCornerIdsBuffer","endFaceNormalAndHalfWidthsBuffer","batchIdAttributeBuffer","vertexAttributes","startEllipsoidNormal","endEllipsoidNormal","startPositionAndHeight","endPositionAndHeight","startFaceNormalAndVertexCorner","endFaceNormalAndHalfWidth","a_batchId","finishVertexArray","mask3DTiles","getPositions","createFeatures","features","scratchColor","DEFAULT_COLOR_VALUE","polygons","clearStyle","Vector3DTileContent","byteOffset","_polygons","_polylines","_points","_features","uint8Array","DataView","sizeOfUint32","version","getUint32","featureTableJSONByteLength","featureTableBinaryByteLength","batchTableJSONByteLength","batchTableBinaryByteLength","indicesByteLength","positionByteLength","polylinePositionByteLength","pointsPositionByteLength","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","numberOfPolygons","POLYGONS_LENGTH","numberOfPolylines","POLYLINES_LENGTH","numberOfPoints","POINTS_LENGTH","totalPrimitives","updateCommands","createColorChangedCallback","featureTable","region","getGlobalProperty","minHeight","maxHeight","computedTransform","polygonBatchIds","polylineBatchIds","pointBatchIds","POLYGON_BATCH_IDS","polygonBatchIdsByteOffset","POLYLINE_BATCH_IDS","polylineBatchIdsByteOffset","POINT_BATCH_IDS","pointBatchIdsByteOffset","atLeastOneDefined","atLeastOneUndefined","points","getBatchIds","polygonCounts","getPropertyArray","polygonIndexCounts","numPolygonPositions","reduce","total","numPolygonIndices","polygonPositions","polygonMinimumHeights","polygonMaximumHeights","POLYGON_MINIMUM_HEIGHTS","POLYGON_MAXIMUM_HEIGHTS","indexCounts","polylineCounts","numPolylinePositions","polylinePositions","examineVectorLinesFunction","countsLength","polylineStart","linePositions","examineVectorLines","createPolylines","createFloatingPolylines","createClampedPolylines","vectorKeepDecodedPositions","pointPositions","memorySizeInBytes","pointsPromise","polygonPromise","polylinePromise","all","debugWireframe","getPolylinePositions","Vector3DTileGeometry","geometries","_boxes","boxes","_boxBatchIds","boxBatchIds","_cylinders","cylinders","_cylinderBatchIds","cylinderBatchIds","_ellipsoids","ellipsoids","_ellipsoidBatchIds","ellipsoidBatchIds","_spheres","spheres","_sphereBatchIds","sphereBatchIds","_boundingVolumes","_batchedIndices","_indexOffsets","_indexCounts","_batchTableColors","_primitive","batchTableColors","_sphere","getColor","toRgba","indicesBytesPerElement","numBVS","bvs","numBatchedIndices","bis","indexOffset","unpackBuffer","indexOffsets","createPrimitive","forceRebatch","batchedIndices","boundingVolumes","pickObject","_pickObject","finishPrimitive","packedBoxLength","packedCylinderLength","packedEllipsoidLength","packedSphereLength","Vector3DTilePoints","_minHeight","_maxHeight","_billboardCollection","_labelCollection","_polylineCollection","_useHighlightColor","billboardCollection","labelCollection","polylineCollection","scratchPosition","_batchIndex","l","text","createPoints","sizeInBytes","_textureAtlas","billboard","label","polyline","scratchColor2","scratchColor3","scratchColor4","scratchColor5","scratchColor6","scratchScaleByDistance","scratchTranslucencyByDistance","scratchDistanceDisplayCondition","pointSize","pointOutlineColor","pointOutlineWidth","labelColor","labelOutlineColor","labelOutlineWidth","labelStyle","labelText","backgroundColor","backgroundPadding","backgroundEnabled","scaleByDistance","translucencyByDistance","distanceDisplayCondition","anchorLineEnabled","anchorLineColor","disableDepthTestDistance","horizontalOrigin","verticalOrigin","labelHorizontalOrigin","labelVerticalOrigin","scaleByDistanceCart4","nearValue","farValue","translucencyByDistanceCart4","distanceDisplayConditionCart2","Vector3DTilePolygons","_batchedPositions","_polygonMinimumHeights","_polygonMaximumHeights","minimumHeights","maximumHeights","Vector3DTilePolylines","_currentPositions","_previousPositions","_nextPositions","_expandAndWidth","currentPositions","previousPositions","nextPositions","expandAndWidth","PolylineFS","curPositions","prevPositions","prevPositionBuffer","curPositionBuffer","nextPositionBuffer","expandAndWidthBuffer","idBuffer","previousPosition","currentPosition","nextPosition","offsets","polylinesLength","positionsLength","resultCounter","decodedOffset","Vector3DTilePrimitive","_spStencil","_spPick","_vaSwap","_rsStencilDepthPass","_rsStencilDepthPass3DTiles","_rsColorPass","_rsPickPass","_rsWireframe","_commandsIgnoreShow","_pickCommands","_batchDirty","_pickCommandsDirty","_framesSinceLastRebatch","_updatingAllCommands","_debugWireframe","_wireframeDirty","_vertexShaderSource","_fragmentShaderSource","_batchIdLookUp","defaultAttributeLocations","getStencilDepthRenderState","stencilFunction","stencilMask","func","colorRenderState","pickRenderState","copyIndicesCPU","newIndices","currentOffset","batchIdLookUp","batchedIdsLength","subarray","copyIndicesGPU","readBuffer","writeBuffer","bytesPerIndex","copyFromBuffer","compareColors","rebatchCommands","needToRebatch","colorCounts","rgba","sort","webgl2","current","newBatchedIndices","concat","rebatchGPU","copyFromArrayView","rebatchCPU","complexExpressionReg","commandsIgnoreShow","queueTerrainCommands","queue3DTilesCommands","commandLength","invertClassification","colorExpression","isSimpleStyle","expression","batchedOffset","batchedCount","startIds","endIds","batchIdsLength","positionBuffer","pickVS","pickFS","u_modifiedModelViewProjection","needsRebatch","commandsLength","sp","bv","stencilDepthCommand","stencilDepthDerivedCommand","colorCommand","colorDerivedCommand","_commandsDirty","createColorCommands","spStencil","commandIndex","commandIgnoreShow","createColorCommandsIgnoreShow","rs","earlyExit","updateWireframe","queueWireframeCommands","pickCommands","spPick","pickOnly","createPickCommands","VertexAttributeSemantic","POSITION","NORMAL","TANGENT","TEXCOORD","COLOR","JOINTS","WEIGHTS","FEATURE_ID","hasSetIndex","fromGltfSemantic","gltfSemantic","setIndexMatch","exec","fromPntsSemantic","pntsSemantic","getGlslType","getVariableName","setIndex","variableName","semanticToVariableName","CENTER","BOTTOM","BASELINE","TOP"],"sourceRoot":""}