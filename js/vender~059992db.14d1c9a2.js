"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6023],{4034:(t,e,n)=>{n.d(e,{Z:()=>i});const i=Object.freeze({ROUNDED:0,MITERED:1,BEVELED:2})},83315:(t,e,n)=>{n.d(e,{Z:()=>J});var i=n(65730),o=n(55993),r=n(52351),s=n(93517),a=n(66866),u=n(17497),c=n(44990),l=n(4034),Z=n(52304),d=n(88779),h=n(54485),f=n(99996),p=n(97845),m=n(94061),y=n(77683),g=n(97029),_=n(39172),w=n(22874),b=n(14777),A=n(84473),v=n(34152),x=n(25225);const O=new s.Z,P=new s.Z,T=new s.Z,E=new s.Z,S=new s.Z,I=new s.Z,N=new s.Z,M=new s.Z;function L(t,e){for(let n=0;n<t.length;n++)t[n]=e.scaleToGeodeticSurface(t[n],t[n]);return t}function R(t,e,n,i,o,r){const a=t.normals,u=t.tangents,c=t.bitangents,l=s.Z.normalize(s.Z.cross(n,e,N),N);r.normal&&Z.Z.addAttribute(a,e,i,o),r.tangent&&Z.Z.addAttribute(u,l,i,o),r.bitangent&&Z.Z.addAttribute(c,n,i,o)}function C(t,e,n){const i=t.positions,o=t.corners,r=t.endPositions,a=t.lefts,u=t.normals,l=new y.Z;let d,f,p,g=0,b=0,A=0;for(f=0;f<i.length;f+=2)p=i[f].length-3,g+=p,A+=2*p,b+=i[f+1].length-3;for(g+=3,b+=3,f=0;f<o.length;f++){d=o[f];const t=o[f].leftPositions;(0,h.Z)(t)?(p=t.length,g+=p,A+=p):(p=o[f].rightPositions.length,b+=p,A+=p)}const v=(0,h.Z)(r);let x;v&&(x=r[0].length-3,g+=x,b+=x,x/=3,A+=6*x);const S=g+b,L=new Float64Array(S),C={normals:e.normal?new Float32Array(S):void 0,tangents:e.tangent?new Float32Array(S):void 0,bitangents:e.bitangent?new Float32Array(S):void 0};let k,z,D,F,q,U,B=0,V=S-1,G=O,j=P;const W=x/2,H=_.Z.createTypedArray(S/3,A);let Y=0;if(v){U=T,q=E;const t=r[0];for(G=s.Z.fromArray(u,0,G),j=s.Z.fromArray(a,0,j),f=0;f<W;f++)U=s.Z.fromArray(t,3*(W-1-f),U),q=s.Z.fromArray(t,3*(W+f),q),Z.Z.addAttribute(L,q,B),Z.Z.addAttribute(L,U,void 0,V),R(C,G,j,B,V,e),z=B/3,F=z+1,k=(V-2)/3,D=k-1,H[Y++]=k,H[Y++]=z,H[Y++]=D,H[Y++]=D,H[Y++]=z,H[Y++]=F,B+=3,V-=3}let Q,X,J=0,$=0,K=i[J++],tt=i[J++];for(L.set(K,B),L.set(tt,V-tt.length+1),j=s.Z.fromArray(a,$,j),p=tt.length-3,f=0;f<p;f+=3)Q=n.geodeticSurfaceNormal(s.Z.fromArray(K,f,N),N),X=n.geodeticSurfaceNormal(s.Z.fromArray(tt,p-f,M),M),G=s.Z.normalize(s.Z.add(Q,X,G),G),R(C,G,j,B,V,e),z=B/3,F=z+1,k=(V-2)/3,D=k-1,H[Y++]=k,H[Y++]=z,H[Y++]=D,H[Y++]=D,H[Y++]=z,H[Y++]=F,B+=3,V-=3;for(Q=n.geodeticSurfaceNormal(s.Z.fromArray(K,p,N),N),X=n.geodeticSurfaceNormal(s.Z.fromArray(tt,p,M),M),G=s.Z.normalize(s.Z.add(Q,X,G),G),$+=3,f=0;f<o.length;f++){let t;d=o[f];const r=d.leftPositions,c=d.rightPositions;let l,m,y=I,g=T,_=E;if(G=s.Z.fromArray(u,$,G),(0,h.Z)(r)){for(R(C,G,j,void 0,V,e),V-=3,l=F,m=D,t=0;t<r.length/3;t++)y=s.Z.fromArray(r,3*t,y),H[Y++]=l,H[Y++]=m-t-1,H[Y++]=m-t,Z.Z.addAttribute(L,y,void 0,V),g=s.Z.fromArray(L,3*(m-t-1),g),_=s.Z.fromArray(L,3*l,_),j=s.Z.normalize(s.Z.subtract(g,_,j),j),R(C,G,j,void 0,V,e),V-=3;y=s.Z.fromArray(L,3*l,y),g=s.Z.subtract(s.Z.fromArray(L,3*m,g),y,g),_=s.Z.subtract(s.Z.fromArray(L,3*(m-t),_),y,_),j=s.Z.normalize(s.Z.add(g,_,j),j),R(C,G,j,B,void 0,e),B+=3}else{for(R(C,G,j,B,void 0,e),B+=3,l=D,m=F,t=0;t<c.length/3;t++)y=s.Z.fromArray(c,3*t,y),H[Y++]=l,H[Y++]=m+t,H[Y++]=m+t+1,Z.Z.addAttribute(L,y,B),g=s.Z.fromArray(L,3*l,g),_=s.Z.fromArray(L,3*(m+t),_),j=s.Z.normalize(s.Z.subtract(g,_,j),j),R(C,G,j,B,void 0,e),B+=3;y=s.Z.fromArray(L,3*l,y),g=s.Z.subtract(s.Z.fromArray(L,3*(m+t),g),y,g),_=s.Z.subtract(s.Z.fromArray(L,3*m,_),y,_),j=s.Z.normalize(s.Z.negate(s.Z.add(_,g,j),j),j),R(C,G,j,void 0,V,e),V-=3}for(K=i[J++],tt=i[J++],K.splice(0,3),tt.splice(tt.length-3,3),L.set(K,B),L.set(tt,V-tt.length+1),p=tt.length-3,$+=3,j=s.Z.fromArray(a,$,j),t=0;t<tt.length;t+=3)Q=n.geodeticSurfaceNormal(s.Z.fromArray(K,t,N),N),X=n.geodeticSurfaceNormal(s.Z.fromArray(tt,p-t,M),M),G=s.Z.normalize(s.Z.add(Q,X,G),G),R(C,G,j,B,V,e),F=B/3,z=F-1,D=(V-2)/3,k=D+1,H[Y++]=k,H[Y++]=z,H[Y++]=D,H[Y++]=D,H[Y++]=z,H[Y++]=F,B+=3,V-=3;B-=3,V+=3}if(G=s.Z.fromArray(u,u.length-3,G),R(C,G,j,B,V,e),v){B+=3,V-=3,U=T,q=E;const t=r[1];for(f=0;f<W;f++)U=s.Z.fromArray(t,3*(x-f-1),U),q=s.Z.fromArray(t,3*f,q),Z.Z.addAttribute(L,U,void 0,V),Z.Z.addAttribute(L,q,B),R(C,G,j,B,V,e),F=B/3,z=F-1,D=(V-2)/3,k=D+1,H[Y++]=k,H[Y++]=z,H[Y++]=D,H[Y++]=D,H[Y++]=z,H[Y++]=F,B+=3,V-=3}if(l.position=new m.Z({componentDatatype:c.Z.DOUBLE,componentsPerAttribute:3,values:L}),e.st){const t=new Float32Array(S/3*2);let e,n,i=0;if(v){g/=3,b/=3;const o=Math.PI/(x+1);let r;n=1/(g-x+1),e=1/(b-x+1);const s=x/2;for(f=s+1;f<x+1;f++)r=w.Z.PI_OVER_TWO+o*f,t[i++]=e*(1+Math.cos(r)),t[i++]=.5*(1+Math.sin(r));for(f=1;f<b-x+1;f++)t[i++]=f*e,t[i++]=0;for(f=x;f>s;f--)r=w.Z.PI_OVER_TWO-f*o,t[i++]=1-e*(1+Math.cos(r)),t[i++]=.5*(1+Math.sin(r));for(f=s;f>0;f--)r=w.Z.PI_OVER_TWO-o*f,t[i++]=1-n*(1+Math.cos(r)),t[i++]=.5*(1+Math.sin(r));for(f=g-x;f>0;f--)t[i++]=f*n,t[i++]=1;for(f=1;f<s+1;f++)r=w.Z.PI_OVER_TWO+o*f,t[i++]=n*(1+Math.cos(r)),t[i++]=.5*(1+Math.sin(r))}else{for(g/=3,b/=3,n=1/(g-1),e=1/(b-1),f=0;f<b;f++)t[i++]=f*e,t[i++]=0;for(f=g;f>0;f--)t[i++]=(f-1)*n,t[i++]=1}l.st=new m.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(l.normal=new m.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:C.normals})),e.tangent&&(l.tangent=new m.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:C.tangents})),e.bitangent&&(l.bitangent=new m.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:C.bitangents})),{attributes:l,indices:H}}function k(t,e,n){n[e++]=t[0],n[e++]=t[1],n[e++]=t[2];for(let i=3;i<t.length;i+=3){const o=t[i],r=t[i+1],s=t[i+2];n[e++]=o,n[e++]=r,n[e++]=s,n[e++]=o,n[e++]=r,n[e++]=s}return n[e++]=t[0],n[e++]=t[1],n[e++]=t[2],n}function z(t,e){const n=new x.Z({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),o=t.ellipsoid,r=C(Z.Z.computePositions(t),n,o),a=t.height,u=t.extrudedHeight;let l=r.attributes;const d=r.indices;let f=l.position.values,p=f.length;const y=new Float64Array(6*p);let w=new Float64Array(p);w.set(f);let A,v=new Float64Array(4*p);f=b.Z.scaleToGeodeticHeight(f,a,o),v=k(f,0,v),w=b.Z.scaleToGeodeticHeight(w,u,o),v=k(w,2*p,v),y.set(f),y.set(w,p),y.set(v,2*p),l.position.values=y,l=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;const n=t.position.values;let i,o;(e.normal||e.bitangent)&&(i=t.normal.values,o=t.bitangent.values);const r=t.position.values.length/18,a=3*r,u=2*r,c=2*a;let l;if(e.normal||e.bitangent||e.tangent){const r=e.normal?new Float32Array(6*a):void 0,u=e.tangent?new Float32Array(6*a):void 0,d=e.bitangent?new Float32Array(6*a):void 0;let h=O,f=P,p=T,m=E,y=S,g=I,_=c;for(l=0;l<a;l+=3){const t=_+c;h=s.Z.fromArray(n,l,h),f=s.Z.fromArray(n,l+a,f),p=s.Z.fromArray(n,(l+3)%a,p),f=s.Z.subtract(f,h,f),p=s.Z.subtract(p,h,p),m=s.Z.normalize(s.Z.cross(f,p,m),m),e.normal&&(Z.Z.addAttribute(r,m,t),Z.Z.addAttribute(r,m,t+3),Z.Z.addAttribute(r,m,_),Z.Z.addAttribute(r,m,_+3)),(e.tangent||e.bitangent)&&(g=s.Z.fromArray(i,l,g),e.bitangent&&(Z.Z.addAttribute(d,g,t),Z.Z.addAttribute(d,g,t+3),Z.Z.addAttribute(d,g,_),Z.Z.addAttribute(d,g,_+3)),e.tangent&&(y=s.Z.normalize(s.Z.cross(g,m,y),y),Z.Z.addAttribute(u,y,t),Z.Z.addAttribute(u,y,t+3),Z.Z.addAttribute(u,y,_),Z.Z.addAttribute(u,y,_+3))),_+=6}if(e.normal){for(r.set(i),l=0;l<a;l+=3)r[l+a]=-i[l],r[l+a+1]=-i[l+1],r[l+a+2]=-i[l+2];t.normal.values=r}else t.normal=void 0;if(e.bitangent?(d.set(o),d.set(o,a),t.bitangent.values=d):t.bitangent=void 0,e.tangent){const e=t.tangent.values;u.set(e),u.set(e,a),t.tangent.values=u}}if(e.st){const e=t.st.values,n=new Float32Array(6*u);n.set(e),n.set(e,u);let i=2*u;for(let t=0;t<2;t++){for(n[i++]=e[0],n[i++]=e[1],l=2;l<u;l+=2){const t=e[l],o=e[l+1];n[i++]=t,n[i++]=o,n[i++]=t,n[i++]=o}n[i++]=e[0],n[i++]=e[1]}t.st.values=n}return t}(l,e);const N=p/3;if(t.shadowVolume){const t=l.normal.values;p=t.length;let n=new Float32Array(6*p);for(A=0;A<p;A++)t[A]=-t[A];n.set(t,p),n=k(t,4*p,n),l.extrudeDirection=new m.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:n}),e.normal||(l.normal=void 0)}if((0,h.Z)(t.offsetAttribute)){let e=new Uint8Array(6*N);if(t.offsetAttribute===g.Z.TOP)e=(0,i.Z)(e,1,0,N),e=(0,i.Z)(e,1,2*N,4*N);else{const n=t.offsetAttribute===g.Z.NONE?0:1;e=(0,i.Z)(e,n)}l.applyOffset=new m.Z({componentDatatype:c.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}const M=d.length,L=N+N,R=_.Z.createTypedArray(y.length/3,2*M+3*L);R.set(d);let z,D,F,q,U=M;for(A=0;A<M;A+=3){const t=d[A],e=d[A+1],n=d[A+2];R[U++]=n+N,R[U++]=e+N,R[U++]=t+N}for(A=0;A<L;A+=2)z=A+L,D=z+L,F=z+1,q=D+1,R[U++]=z,R[U++]=D,R[U++]=F,R[U++]=F,R[U++]=D,R[U++]=q;return{attributes:l,indices:R}}const D=new s.Z,F=new s.Z,q=new a.Z;function U(t,e,n,i,o,r){const a=s.Z.subtract(e,t,D);s.Z.normalize(a,a);const u=n.geodeticSurfaceNormal(t,F),c=s.Z.cross(a,u,D);s.Z.multiplyByScalar(c,i,c);let l=o.latitude,Z=o.longitude,d=r.latitude,h=r.longitude;s.Z.add(t,c,F),n.cartesianToCartographic(F,q);let f=q.latitude,p=q.longitude;l=Math.min(l,f),Z=Math.min(Z,p),d=Math.max(d,f),h=Math.max(h,p),s.Z.subtract(t,c,F),n.cartesianToCartographic(F,q),f=q.latitude,p=q.longitude,l=Math.min(l,f),Z=Math.min(Z,p),d=Math.max(d,f),h=Math.max(h,p),o.latitude=l,o.longitude=Z,r.latitude=d,r.longitude=h}const B=new s.Z,V=new s.Z,G=new a.Z,j=new a.Z;function W(t,e,n,i,r){t=L(t,e);const a=(0,o.Z)(t,s.Z.equalsEpsilon),u=a.length;if(u<2||n<=0)return new v.Z;const c=.5*n;let Z,d;if(G.latitude=Number.POSITIVE_INFINITY,G.longitude=Number.POSITIVE_INFINITY,j.latitude=Number.NEGATIVE_INFINITY,j.longitude=Number.NEGATIVE_INFINITY,i===l.Z.ROUNDED){const t=a[0];s.Z.subtract(t,a[1],B),s.Z.normalize(B,B),s.Z.multiplyByScalar(B,c,B),s.Z.add(t,B,V),e.cartesianToCartographic(V,q),Z=q.latitude,d=q.longitude,G.latitude=Math.min(G.latitude,Z),G.longitude=Math.min(G.longitude,d),j.latitude=Math.max(j.latitude,Z),j.longitude=Math.max(j.longitude,d)}for(let t=0;t<u-1;++t)U(a[t],a[t+1],e,c,G,j);const f=a[u-1];s.Z.subtract(f,a[u-2],B),s.Z.normalize(B,B),s.Z.multiplyByScalar(B,c,B),s.Z.add(f,B,V),U(f,V,e,c,G,j),i===l.Z.ROUNDED&&(e.cartesianToCartographic(V,q),Z=q.latitude,d=q.longitude,G.latitude=Math.min(G.latitude,Z),G.longitude=Math.min(G.longitude,d),j.latitude=Math.max(j.latitude,Z),j.longitude=Math.max(j.longitude,d));const p=(0,h.Z)(r)?r:new v.Z;return p.north=j.latitude,p.south=G.latitude,p.east=j.longitude,p.west=G.longitude,p}function H(t){const e=(t=(0,d.Z)(t,d.Z.EMPTY_OBJECT)).positions,n=t.width;u.Z.defined("options.positions",e),u.Z.defined("options.width",n);const i=(0,d.Z)(t.height,0),o=(0,d.Z)(t.extrudedHeight,i);this._positions=e,this._ellipsoid=f.Z.clone((0,d.Z)(t.ellipsoid,f.Z.WGS84)),this._vertexFormat=x.Z.clone((0,d.Z)(t.vertexFormat,x.Z.DEFAULT)),this._width=n,this._height=Math.max(i,o),this._extrudedHeight=Math.min(i,o),this._cornerType=(0,d.Z)(t.cornerType,l.Z.ROUNDED),this._granularity=(0,d.Z)(t.granularity,w.Z.RADIANS_PER_DEGREE),this._shadowVolume=(0,d.Z)(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*s.Z.packedLength+f.Z.packedLength+x.Z.packedLength+7}H.pack=function(t,e,n){u.Z.defined("value",t),u.Z.defined("array",e),n=(0,d.Z)(n,0);const i=t._positions,o=i.length;e[n++]=o;for(let t=0;t<o;++t,n+=s.Z.packedLength)s.Z.pack(i[t],e,n);return f.Z.pack(t._ellipsoid,e,n),n+=f.Z.packedLength,x.Z.pack(t._vertexFormat,e,n),n+=x.Z.packedLength,e[n++]=t._width,e[n++]=t._height,e[n++]=t._extrudedHeight,e[n++]=t._cornerType,e[n++]=t._granularity,e[n++]=t._shadowVolume?1:0,e[n]=(0,d.Z)(t._offsetAttribute,-1),e};const Y=f.Z.clone(f.Z.UNIT_SPHERE),Q=new x.Z,X={positions:void 0,ellipsoid:Y,vertexFormat:Q,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};H.unpack=function(t,e,n){u.Z.defined("array",t),e=(0,d.Z)(e,0);const i=t[e++],o=new Array(i);for(let n=0;n<i;++n,e+=s.Z.packedLength)o[n]=s.Z.unpack(t,e);const r=f.Z.unpack(t,e,Y);e+=f.Z.packedLength;const a=x.Z.unpack(t,e,Q);e+=x.Z.packedLength;const c=t[e++],l=t[e++],Z=t[e++],p=t[e++],m=t[e++],y=1===t[e++],g=t[e];return(0,h.Z)(n)?(n._positions=o,n._ellipsoid=f.Z.clone(r,n._ellipsoid),n._vertexFormat=x.Z.clone(a,n._vertexFormat),n._width=c,n._height=l,n._extrudedHeight=Z,n._cornerType=p,n._granularity=m,n._shadowVolume=y,n._offsetAttribute=-1===g?void 0:g,n):(X.positions=o,X.width=c,X.height=l,X.extrudedHeight=Z,X.cornerType=p,X.granularity=m,X.shadowVolume=y,X.offsetAttribute=-1===g?void 0:g,new H(X))},H.computeRectangle=function(t,e){const n=(t=(0,d.Z)(t,d.Z.EMPTY_OBJECT)).positions,i=t.width;u.Z.defined("options.positions",n),u.Z.defined("options.width",i);return W(n,(0,d.Z)(t.ellipsoid,f.Z.WGS84),i,(0,d.Z)(t.cornerType,l.Z.ROUNDED),e)},H.createGeometry=function(t){let e=t._positions;const n=t._width,a=t._ellipsoid;e=L(e,a);const u=(0,o.Z)(e,s.Z.equalsEpsilon);if(u.length<2||n<=0)return;const l=t._height,d=t._extrudedHeight,f=!w.Z.equalsEpsilon(l,d,0,w.Z.EPSILON2),y=t._vertexFormat,_={ellipsoid:a,positions:u,width:n,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!0};let v;if(f)_.height=l,_.extrudedHeight=d,_.shadowVolume=t._shadowVolume,_.offsetAttribute=t._offsetAttribute,v=z(_,y);else{if(v=C(Z.Z.computePositions(_),y,a),v.attributes.position.values=b.Z.scaleToGeodeticHeight(v.attributes.position.values,l,a),(0,h.Z)(t._offsetAttribute)){const e=t._offsetAttribute===g.Z.NONE?0:1,n=v.attributes.position.values.length,o=new Uint8Array(n/3);(0,i.Z)(o,e),v.attributes.applyOffset=new m.Z({componentDatatype:c.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}}const x=v.attributes,O=r.Z.fromVertices(x.position.values,void 0,3);return y.position||(v.attributes.position.values=void 0),new p.Z({attributes:x,indices:v.indices,primitiveType:A.Z.TRIANGLES,boundingSphere:O,offsetAttribute:t._offsetAttribute})},H.createShadowVolume=function(t,e,n){const i=t._granularity,o=t._ellipsoid,r=e(i,o),s=n(i,o);return new H({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:o,granularity:i,extrudedHeight:r,height:s,vertexFormat:x.Z.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(H.prototype,{rectangle:{get:function(){return(0,h.Z)(this._rectangle)||(this._rectangle=W(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});const J=H},52304:(t,e,n)=>{n.d(e,{Z:()=>R});var i=n(93517),o=n(4034),r=n(54485),s=n(22874),a=n(39109),u=n(5316),c=n(92069),l=n(20291);const Z={},d=new i.Z,h=new i.Z,f=new i.Z,p=new i.Z,m=[new i.Z,new i.Z],y=new i.Z,g=new i.Z,_=new i.Z,w=new i.Z,b=new i.Z,A=new i.Z,v=new i.Z,x=new i.Z,O=new i.Z,P=new i.Z,T=new l.Z,E=new a.Z;function S(t,e,n,r,u){const c=i.Z.angleBetween(i.Z.subtract(e,t,d),i.Z.subtract(n,t,h)),Z=r===o.Z.BEVELED?1:Math.ceil(c/s.Z.toRadians(5))+1,f=3*Z,p=new Array(f);let m;p[f-3]=n.x,p[f-2]=n.y,p[f-1]=n.z,m=u?a.Z.fromQuaternion(l.Z.fromAxisAngle(i.Z.negate(t,d),c/Z,T),E):a.Z.fromQuaternion(l.Z.fromAxisAngle(t,c/Z,T),E);let y=0;e=i.Z.clone(e,d);for(let t=0;t<Z;t++)e=a.Z.multiplyByVector(m,e,e),p[y++]=e.x,p[y++]=e.y,p[y++]=e.z;return p}function I(t,e,n,o){let r=d;return o||(e=i.Z.negate(e,e)),r=i.Z.add(t,e,r),[r.x,r.y,r.z,n.x,n.y,n.z]}function N(t,e,n,o){const r=new Array(t.length),s=new Array(t.length),a=i.Z.multiplyByScalar(e,n,d),u=i.Z.negate(a,h);let c=0,l=t.length-1;for(let e=0;e<t.length;e+=3){const n=i.Z.fromArray(t,e,f),o=i.Z.add(n,u,p);r[c++]=o.x,r[c++]=o.y,r[c++]=o.z;const Z=i.Z.add(n,a,p);s[l--]=Z.z,s[l--]=Z.y,s[l--]=Z.x}return o.push(r,s),o}Z.addAttribute=function(t,e,n,i){const o=e.x,s=e.y,a=e.z;(0,r.Z)(n)&&(t[n]=o,t[n+1]=s,t[n+2]=a),(0,r.Z)(i)&&(t[i]=a,t[i-1]=s,t[i-2]=o)};const M=new i.Z,L=new i.Z;Z.computePositions=function(t){const e=t.granularity,n=t.positions,r=t.ellipsoid,a=t.width/2,l=t.cornerType,Z=t.saveAttributes;let h=y,f=g,p=_,T=w,E=b,R=A,C=v,k=x,z=O,D=P,F=[];const q=Z?[]:void 0,U=Z?[]:void 0;let B,V=n[0],G=n[1];f=i.Z.normalize(i.Z.subtract(G,V,f),f),h=r.geodeticSurfaceNormal(V,h),T=i.Z.normalize(i.Z.cross(h,f,T),T),Z&&(q.push(T.x,T.y,T.z),U.push(h.x,h.y,h.z)),C=i.Z.clone(V,C),V=G,p=i.Z.negate(f,p);const j=[];let W;const H=n.length;for(W=1;W<H-1;W++){h=r.geodeticSurfaceNormal(V,h),G=n[W+1],f=i.Z.normalize(i.Z.subtract(G,V,f),f),E=i.Z.normalize(i.Z.add(f,p,E),E);const t=i.Z.multiplyByScalar(h,i.Z.dot(f,h),M);i.Z.subtract(f,t,t),i.Z.normalize(t,t);const y=i.Z.multiplyByScalar(h,i.Z.dot(p,h),L);i.Z.subtract(p,y,y),i.Z.normalize(y,y);if(!s.Z.equalsEpsilon(Math.abs(i.Z.dot(t,y)),1,s.Z.EPSILON7)){E=i.Z.cross(E,h,E),E=i.Z.cross(h,E,E),E=i.Z.normalize(E,E);const t=a/Math.max(.25,i.Z.magnitude(i.Z.cross(E,p,d))),n=c.Z.angleIsGreaterThanPi(f,p,V,r);E=i.Z.multiplyByScalar(E,t,E),n?(k=i.Z.add(V,E,k),D=i.Z.add(k,i.Z.multiplyByScalar(T,a,D),D),z=i.Z.add(k,i.Z.multiplyByScalar(T,2*a,z),z),m[0]=i.Z.clone(C,m[0]),m[1]=i.Z.clone(D,m[1]),B=u.Z.generateArc({positions:m,granularity:e,ellipsoid:r}),F=N(B,T,a,F),Z&&(q.push(T.x,T.y,T.z),U.push(h.x,h.y,h.z)),R=i.Z.clone(z,R),T=i.Z.normalize(i.Z.cross(h,f,T),T),z=i.Z.add(k,i.Z.multiplyByScalar(T,2*a,z),z),C=i.Z.add(k,i.Z.multiplyByScalar(T,a,C),C),l===o.Z.ROUNDED||l===o.Z.BEVELED?j.push({leftPositions:S(k,R,z,l,n)}):j.push({leftPositions:I(V,i.Z.negate(E,E),z,n)})):(z=i.Z.add(V,E,z),D=i.Z.add(z,i.Z.negate(i.Z.multiplyByScalar(T,a,D),D),D),k=i.Z.add(z,i.Z.negate(i.Z.multiplyByScalar(T,2*a,k),k),k),m[0]=i.Z.clone(C,m[0]),m[1]=i.Z.clone(D,m[1]),B=u.Z.generateArc({positions:m,granularity:e,ellipsoid:r}),F=N(B,T,a,F),Z&&(q.push(T.x,T.y,T.z),U.push(h.x,h.y,h.z)),R=i.Z.clone(k,R),T=i.Z.normalize(i.Z.cross(h,f,T),T),k=i.Z.add(z,i.Z.negate(i.Z.multiplyByScalar(T,2*a,k),k),k),C=i.Z.add(z,i.Z.negate(i.Z.multiplyByScalar(T,a,C),C),C),l===o.Z.ROUNDED||l===o.Z.BEVELED?j.push({rightPositions:S(z,R,k,l,n)}):j.push({rightPositions:I(V,E,k,n)})),p=i.Z.negate(f,p)}V=G}let Y;return h=r.geodeticSurfaceNormal(V,h),m[0]=i.Z.clone(C,m[0]),m[1]=i.Z.clone(V,m[1]),B=u.Z.generateArc({positions:m,granularity:e,ellipsoid:r}),F=N(B,T,a,F),Z&&(q.push(T.x,T.y,T.z),U.push(h.x,h.y,h.z)),l===o.Z.ROUNDED&&(Y=function(t){let e=y,n=g,r=_,s=t[1];n=i.Z.fromArray(t[1],s.length-3,n),r=i.Z.fromArray(t[0],0,r),e=i.Z.midpoint(n,r,e);const a=S(e,n,r,o.Z.ROUNDED,!1),u=t.length-1,c=t[u-1];return s=t[u],n=i.Z.fromArray(c,c.length-3,n),r=i.Z.fromArray(s,0,r),e=i.Z.midpoint(n,r,e),[a,S(e,n,r,o.Z.ROUNDED,!1)]}(F)),{positions:F,corners:j,lefts:q,normals:U,endPositions:Y}};const R=Z},29949:(t,e,n)=>{n.d(e,{Z:()=>S});var i=n(65730),o=n(55993),r=n(52351),s=n(93517),a=n(17497),u=n(44990),c=n(4034),l=n(52304),Z=n(88779),d=n(54485),h=n(99996),f=n(97845),p=n(94061),m=n(77683),y=n(97029),g=n(39172),_=n(22874),w=n(14777),b=n(84473);const A=new s.Z,v=new s.Z,x=new s.Z;function O(t,e){const n=[],i=t.positions,o=t.corners,r=t.endPositions,a=new m.Z;let Z,h,f,y=0,_=0,w=0;for(h=0;h<i.length;h+=2)f=i[h].length-3,y+=f,w+=f/3*4,_+=i[h+1].length-3;for(y+=3,_+=3,h=0;h<o.length;h++){Z=o[h];const t=o[h].leftPositions;(0,d.Z)(t)?(f=t.length,y+=f,w+=f/3*2):(f=o[h].rightPositions.length,_+=f,w+=f/3*2)}const b=(0,d.Z)(r);let O;b&&(O=r[0].length-3,y+=O,_+=O,O/=3,w+=4*O);const P=y+_,T=new Float64Array(P);let E,S,I,N,M,L,R=0,C=P-1;const k=O/2,z=g.Z.createTypedArray(P/3,w+4);let D=0;if(z[D++]=R/3,z[D++]=(C-2)/3,b){n.push(R/3),L=A,M=v;const t=r[0];for(h=0;h<k;h++)L=s.Z.fromArray(t,3*(k-1-h),L),M=s.Z.fromArray(t,3*(k+h),M),l.Z.addAttribute(T,M,R),l.Z.addAttribute(T,L,void 0,C),S=R/3,N=S+1,E=(C-2)/3,I=E-1,z[D++]=E,z[D++]=I,z[D++]=S,z[D++]=N,R+=3,C-=3}let F=0,q=i[F++],U=i[F++];for(T.set(q,R),T.set(U,C-U.length+1),f=U.length-3,n.push(R/3,(C-2)/3),h=0;h<f;h+=3)S=R/3,N=S+1,E=(C-2)/3,I=E-1,z[D++]=E,z[D++]=I,z[D++]=S,z[D++]=N,R+=3,C-=3;for(h=0;h<o.length;h++){let t;Z=o[h];const r=Z.leftPositions,a=Z.rightPositions;let u,p=x;if((0,d.Z)(r)){for(C-=3,u=I,n.push(N),t=0;t<r.length/3;t++)p=s.Z.fromArray(r,3*t,p),z[D++]=u-t-1,z[D++]=u-t,l.Z.addAttribute(T,p,void 0,C),C-=3;n.push(u-Math.floor(r.length/6)),e===c.Z.BEVELED&&n.push((C-2)/3+1),R+=3}else{for(R+=3,u=N,n.push(I),t=0;t<a.length/3;t++)p=s.Z.fromArray(a,3*t,p),z[D++]=u+t,z[D++]=u+t+1,l.Z.addAttribute(T,p,R),R+=3;n.push(u+Math.floor(a.length/6)),e===c.Z.BEVELED&&n.push(R/3-1),C-=3}for(q=i[F++],U=i[F++],q.splice(0,3),U.splice(U.length-3,3),T.set(q,R),T.set(U,C-U.length+1),f=U.length-3,t=0;t<U.length;t+=3)N=R/3,S=N-1,I=(C-2)/3,E=I+1,z[D++]=E,z[D++]=I,z[D++]=S,z[D++]=N,R+=3,C-=3;R-=3,C+=3,n.push(R/3,(C-2)/3)}if(b){R+=3,C-=3,L=A,M=v;const t=r[1];for(h=0;h<k;h++)L=s.Z.fromArray(t,3*(O-h-1),L),M=s.Z.fromArray(t,3*h,M),l.Z.addAttribute(T,L,void 0,C),l.Z.addAttribute(T,M,R),N=R/3,S=N-1,I=(C-2)/3,E=I+1,z[D++]=E,z[D++]=I,z[D++]=S,z[D++]=N,R+=3,C-=3;n.push(R/3)}else n.push(R/3,(C-2)/3);return z[D++]=R/3,z[D++]=(C-2)/3,a.position=new p.Z({componentDatatype:u.Z.DOUBLE,componentsPerAttribute:3,values:T}),{attributes:a,indices:z,wallIndices:n}}function P(t){const e=(t=(0,Z.Z)(t,Z.Z.EMPTY_OBJECT)).positions,n=t.width;a.Z.typeOf.object("options.positions",e),a.Z.typeOf.number("options.width",n);const i=(0,Z.Z)(t.height,0),o=(0,Z.Z)(t.extrudedHeight,i);this._positions=e,this._ellipsoid=h.Z.clone((0,Z.Z)(t.ellipsoid,h.Z.WGS84)),this._width=n,this._height=Math.max(i,o),this._extrudedHeight=Math.min(i,o),this._cornerType=(0,Z.Z)(t.cornerType,c.Z.ROUNDED),this._granularity=(0,Z.Z)(t.granularity,_.Z.RADIANS_PER_DEGREE),this._offsetAttribute=t.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+e.length*s.Z.packedLength+h.Z.packedLength+6}P.pack=function(t,e,n){a.Z.typeOf.object("value",t),a.Z.typeOf.object("array",e),n=(0,Z.Z)(n,0);const i=t._positions,o=i.length;e[n++]=o;for(let t=0;t<o;++t,n+=s.Z.packedLength)s.Z.pack(i[t],e,n);return h.Z.pack(t._ellipsoid,e,n),n+=h.Z.packedLength,e[n++]=t._width,e[n++]=t._height,e[n++]=t._extrudedHeight,e[n++]=t._cornerType,e[n++]=t._granularity,e[n]=(0,Z.Z)(t._offsetAttribute,-1),e};const T=h.Z.clone(h.Z.UNIT_SPHERE),E={positions:void 0,ellipsoid:T,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};P.unpack=function(t,e,n){a.Z.typeOf.object("array",t),e=(0,Z.Z)(e,0);const i=t[e++],o=new Array(i);for(let n=0;n<i;++n,e+=s.Z.packedLength)o[n]=s.Z.unpack(t,e);const r=h.Z.unpack(t,e,T);e+=h.Z.packedLength;const u=t[e++],c=t[e++],l=t[e++],f=t[e++],p=t[e++],m=t[e];return(0,d.Z)(n)?(n._positions=o,n._ellipsoid=h.Z.clone(r,n._ellipsoid),n._width=u,n._height=c,n._extrudedHeight=l,n._cornerType=f,n._granularity=p,n._offsetAttribute=-1===m?void 0:m,n):(E.positions=o,E.width=u,E.height=c,E.extrudedHeight=l,E.cornerType=f,E.granularity=p,E.offsetAttribute=-1===m?void 0:m,new P(E))},P.createGeometry=function(t){let e=t._positions;const n=t._width,a=t._ellipsoid;e=function(t,e){for(let n=0;n<t.length;n++)t[n]=e.scaleToGeodeticSurface(t[n],t[n]);return t}(e,a);const c=(0,o.Z)(e,s.Z.equalsEpsilon);if(c.length<2||n<=0)return;const Z=t._height,h=t._extrudedHeight,m=!_.Z.equalsEpsilon(Z,h,0,_.Z.EPSILON2),A={ellipsoid:a,positions:c,width:n,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!1};let v;if(m)A.height=Z,A.extrudedHeight=h,A.offsetAttribute=t._offsetAttribute,v=function(t){const e=t.ellipsoid,n=O(l.Z.computePositions(t),t.cornerType),o=n.wallIndices,r=t.height,s=t.extrudedHeight,a=n.attributes,c=n.indices;let Z=a.position.values,h=Z.length,f=new Float64Array(h);f.set(Z);const m=new Float64Array(2*h);if(Z=w.Z.scaleToGeodeticHeight(Z,r,e),f=w.Z.scaleToGeodeticHeight(f,s,e),m.set(Z),m.set(f,h),a.position.values=m,h/=3,(0,d.Z)(t.offsetAttribute)){let e=new Uint8Array(2*h);if(t.offsetAttribute===y.Z.TOP)e=(0,i.Z)(e,1,0,h);else{const n=t.offsetAttribute===y.Z.NONE?0:1;e=(0,i.Z)(e,n)}a.applyOffset=new p.Z({componentDatatype:u.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let _;const b=c.length,A=g.Z.createTypedArray(m.length/3,2*(b+o.length));A.set(c);let v,x,P=b;for(_=0;_<b;_+=2){const t=c[_],e=c[_+1];A[P++]=t+h,A[P++]=e+h}for(_=0;_<o.length;_++)v=o[_],x=v+h,A[P++]=v,A[P++]=x;return{attributes:a,indices:A}}(A);else{if(v=O(l.Z.computePositions(A),A.cornerType),v.attributes.position.values=w.Z.scaleToGeodeticHeight(v.attributes.position.values,Z,a),(0,d.Z)(t._offsetAttribute)){const e=v.attributes.position.values.length,n=new Uint8Array(e/3),o=t._offsetAttribute===y.Z.NONE?0:1;(0,i.Z)(n,o),v.attributes.applyOffset=new p.Z({componentDatatype:u.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}}const x=v.attributes,P=r.Z.fromVertices(x.position.values,void 0,3);return new f.Z({attributes:x,indices:v.indices,primitiveType:b.Z.LINES,boundingSphere:P,offsetAttribute:t._offsetAttribute})};const S=P},78505:(t,e,n)=>{n.d(e,{Z:()=>l});var i=n(86919),o=n(17497),r=n(88779),s=n(54485);let a=0;const u={};function c(t,e){let n;o.Z.typeOf.string("html",t);const i=t;(0,s.Z)(u[i])?n=u[i]:(n=a++,u[i]=n),e=(0,r.Z)(e,!1),this._id=n,this._html=t,this._showOnScreen=e,this._element=void 0}Object.defineProperties(c.prototype,{html:{get:function(){return this._html}},id:{get:function(){return this._id}},showOnScreen:{get:function(){return this._showOnScreen},set:function(t){this._showOnScreen=t}},element:{get:function(){if(!(0,s.Z)(this._element)){const t=i.Z.sanitize(this._html),e=document.createElement("div");e._creditId=this._id,e.style.display="inline",e.innerHTML=t;const n=e.querySelectorAll("a");for(let t=0;t<n.length;t++)n[t].setAttribute("target","_blank");this._element=e}return this._element}}}),c.equals=function(t,e){return t===e||(0,s.Z)(t)&&(0,s.Z)(e)&&t._id===e._id&&t._showOnScreen===e._showOnScreen},c.prototype.equals=function(t){return c.equals(this,t)},c.getIonCredit=function(t){const e=(0,s.Z)(t.collapsible)&&!t.collapsible,n=new c(t.html,e);return n._isIon=-1!==n.html.indexOf("ion-credit.png"),n},c.clone=function(t){if((0,s.Z)(t))return new c(t.html,t.showOnScreen)};const l=c},89054:(t,e,n)=>{n.d(e,{Z:()=>a});var i=n(20176),o=n(39920);const r={};function s(t,e,n,i){const o=t,r=e/3,s=n/3,a=i,u=o*s,c=r*a,l=r*r,Z=s*s,d=o*s-l,h=o*a-r*s,f=r*a-Z,p=4*d*f-h*h;let m,y;if(p<0){let t,e,n;l*c>=u*Z?(t=o,e=d,n=-2*r*d+o*h):(t=a,e=f,n=-a*h+2*s*f);const i=-(n<0?-1:1)*Math.abs(t)*Math.sqrt(-p);y=-n+i;const g=y/2,_=g<0?-Math.pow(-g,1/3):Math.pow(g,1/3),w=y===i?-_:-e/_;return m=e<=0?_+w:-n/(_*_+w*w+e),l*c>=u*Z?[(m-r)/o]:[-a/(m+s)]}const g=d,_=-2*r*d+o*h,w=f,b=-a*h+2*s*f,A=Math.sqrt(p),v=Math.sqrt(3)/2;let x=Math.abs(Math.atan2(o*A,-_)/3);m=2*Math.sqrt(-g);let O=Math.cos(x);y=m*O;let P=m*(-O/2-v*Math.sin(x));const T=y+P>2*r?y-r:P-r,E=o,S=T/E;x=Math.abs(Math.atan2(a*A,-b)/3),m=2*Math.sqrt(-w),O=Math.cos(x),y=m*O,P=m*(-O/2-v*Math.sin(x));const I=-a,N=y+P<2*s?y+s:P+s,M=I/N,L=-T*N-E*I,R=(s*L-r*(T*I))/(-r*L+s*(E*N));return S<=R?S<=M?R<=M?[S,R,M]:[S,M,R]:[M,S,R]:S<=M?[R,S,M]:R<=M?[R,M,S]:[M,R,S]}r.computeDiscriminant=function(t,e,n,o){if("number"!=typeof t)throw new i.Z("a is a required number.");if("number"!=typeof e)throw new i.Z("b is a required number.");if("number"!=typeof n)throw new i.Z("c is a required number.");if("number"!=typeof o)throw new i.Z("d is a required number.");const r=e*e,s=n*n;return 18*t*e*n*o+r*s-27*(t*t)*(o*o)-4*(t*s*n+r*e*o)},r.computeRealRoots=function(t,e,n,r){if("number"!=typeof t)throw new i.Z("a is a required number.");if("number"!=typeof e)throw new i.Z("b is a required number.");if("number"!=typeof n)throw new i.Z("c is a required number.");if("number"!=typeof r)throw new i.Z("d is a required number.");let a,u;if(0===t)return o.Z.computeRealRoots(e,n,r);if(0===e){if(0===n){if(0===r)return[0,0,0];u=-r/t;const e=u<0?-Math.pow(-u,1/3):Math.pow(u,1/3);return[e,e,e]}return 0===r?(a=o.Z.computeRealRoots(t,0,n),0===a.Length?[0]:[a[0],0,a[1]]):s(t,0,n,r)}return 0===n?0===r?(u=-e/t,u<0?[u,0,0]:[0,0,u]):s(t,e,0,r):0===r?(a=o.Z.computeRealRoots(t,e,n),0===a.length?[0]:a[1]<=0?[a[0],a[1],0]:a[0]>=0?[0,a[0],a[1]]:[a[0],0,a[1]]):s(t,e,n,r)};const a=r},37337:(t,e,n)=>{n.d(e,{Z:()=>p});var i=n(93517),o=n(90868),r=n(88779),s=n(54485),a=n(20176),u=n(3169),c=n(30445);function l(t){this.planes=(0,r.Z)(t,[])}const Z=[new i.Z,new i.Z,new i.Z];i.Z.clone(i.Z.UNIT_X,Z[0]),i.Z.clone(i.Z.UNIT_Y,Z[1]),i.Z.clone(i.Z.UNIT_Z,Z[2]);const d=new i.Z,h=new i.Z,f=new c.Z(new i.Z(1,0,0),0);l.fromBoundingSphere=function(t,e){if(!(0,s.Z)(t))throw new a.Z("boundingSphere is required.");(0,s.Z)(e)||(e=new l);const n=Z.length,r=e.planes;r.length=2*n;const u=t.center,c=t.radius;let f=0;for(let t=0;t<n;++t){const e=Z[t];let n=r[f],a=r[f+1];(0,s.Z)(n)||(n=r[f]=new o.Z),(0,s.Z)(a)||(a=r[f+1]=new o.Z),i.Z.multiplyByScalar(e,-c,d),i.Z.add(u,d,d),n.x=e.x,n.y=e.y,n.z=e.z,n.w=-i.Z.dot(e,d),i.Z.multiplyByScalar(e,c,d),i.Z.add(u,d,d),a.x=-e.x,a.y=-e.y,a.z=-e.z,a.w=-i.Z.dot(i.Z.negate(e,h),d),f+=2}return e},l.prototype.computeVisibility=function(t){if(!(0,s.Z)(t))throw new a.Z("boundingVolume is required.");const e=this.planes;let n=!1;for(let i=0,o=e.length;i<o;++i){const o=t.intersectPlane(c.Z.fromCartesian4(e[i],f));if(o===u.Z.OUTSIDE)return u.Z.OUTSIDE;o===u.Z.INTERSECTING&&(n=!0)}return n?u.Z.INTERSECTING:u.Z.INSIDE},l.prototype.computeVisibilityWithPlaneMask=function(t,e){if(!(0,s.Z)(t))throw new a.Z("boundingVolume is required.");if(!(0,s.Z)(e))throw new a.Z("parentPlaneMask is required.");if(e===l.MASK_OUTSIDE||e===l.MASK_INSIDE)return e;let n=l.MASK_INSIDE;const i=this.planes;for(let o=0,r=i.length;o<r;++o){const r=o<31?1<<o:0;if(o<31&&0==(e&r))continue;const s=t.intersectPlane(c.Z.fromCartesian4(i[o],f));if(s===u.Z.OUTSIDE)return l.MASK_OUTSIDE;s===u.Z.INTERSECTING&&(n|=r)}return n},l.MASK_OUTSIDE=4294967295,l.MASK_INSIDE=0,l.MASK_INDETERMINATE=2147483647;const p=l},27653:(t,e,n)=>{n.d(e,{Z:()=>h});var i=n(17497),o=n(78505),r=n(88779),s=n(54485),a=n(99996),u=n(92893),c=n(96507),l=n(30646),Z=n(87264);function d(t){t=(0,r.Z)(t,r.Z.EMPTY_OBJECT),i.Z.defined("options.callback",t.callback),i.Z.defined("options.width",t.width),i.Z.defined("options.height",t.height),this._callback=t.callback,this._tilingScheme=t.tilingScheme,(0,s.Z)(this._tilingScheme)||(this._tilingScheme=new c.Z({ellipsoid:(0,r.Z)(t.ellipsoid,a.Z.WGS84)})),this._width=t.width,this._height=t.height;const e=Math.max(this._width,this._height);this._levelZeroMaximumGeometricError=Z.Z.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid,e,this._tilingScheme.getNumberOfXTilesAtLevel(0)),this._errorEvent=new u.Z;let n=t.credit;"string"==typeof n&&(n=new o.Z(n)),this._credit=n,this._readyPromise=Promise.resolve(!0)}Object.defineProperties(d.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){return this._credit}},tilingScheme:{get:function(){return this._tilingScheme}},ready:{get:function(){return!0}},readyPromise:{get:function(){return this._readyPromise}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},width:{get:function(){return this._width}},height:{get:function(){return this._height}}}),d.prototype.requestTileGeometry=function(t,e,n,i){const o=this._callback(t,e,n);if(!(0,s.Z)(o))return;const r=this._width,a=this._height;return Promise.resolve(o).then((function(t){let e=t;return Array.isArray(e)&&(e=new Float64Array(e)),new l.Z({buffer:e,width:r,height:a})}))},d.prototype.getLevelMaximumGeometricError=function(t){return this._levelZeroMaximumGeometricError/(1<<t)},d.prototype.getTileDataAvailable=function(t,e,n){},d.prototype.loadTileDataAvailability=function(t,e,n){};const h=d},78331:(t,e,n)=>{n.d(e,{Z:()=>S});var i=n(65730),o=n(52351),r=n(59015),s=n(93517),a=n(44990),u=n(67115),c=n(88779),l=n(54485),Z=n(20176),d=n(97845),h=n(94061),f=n(77683),p=n(97029),m=n(39172),y=n(22874),g=n(84473),_=n(25225);const w=new r.Z,b=new s.Z,A=new s.Z,v=new s.Z,x=new s.Z;function O(t){const e=(t=(0,c.Z)(t,c.Z.EMPTY_OBJECT)).length,n=t.topRadius,i=t.bottomRadius,o=(0,c.Z)(t.vertexFormat,_.Z.DEFAULT),r=(0,c.Z)(t.slices,128);if(!(0,l.Z)(e))throw new Z.Z("options.length must be defined.");if(!(0,l.Z)(n))throw new Z.Z("options.topRadius must be defined.");if(!(0,l.Z)(i))throw new Z.Z("options.bottomRadius must be defined.");if(r<3)throw new Z.Z("options.slices must be greater than or equal to 3.");if((0,l.Z)(t.offsetAttribute)&&t.offsetAttribute===p.Z.TOP)throw new Z.Z("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=e,this._topRadius=n,this._bottomRadius=i,this._vertexFormat=_.Z.clone(o),this._slices=r,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}O.packedLength=_.Z.packedLength+5,O.pack=function(t,e,n){if(!(0,l.Z)(t))throw new Z.Z("value is required");if(!(0,l.Z)(e))throw new Z.Z("array is required");return n=(0,c.Z)(n,0),_.Z.pack(t._vertexFormat,e,n),n+=_.Z.packedLength,e[n++]=t._length,e[n++]=t._topRadius,e[n++]=t._bottomRadius,e[n++]=t._slices,e[n]=(0,c.Z)(t._offsetAttribute,-1),e};const P=new _.Z,T={vertexFormat:P,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let E;O.unpack=function(t,e,n){if(!(0,l.Z)(t))throw new Z.Z("array is required");e=(0,c.Z)(e,0);const i=_.Z.unpack(t,e,P);e+=_.Z.packedLength;const o=t[e++],r=t[e++],s=t[e++],a=t[e++],u=t[e];return(0,l.Z)(n)?(n._vertexFormat=_.Z.clone(i,n._vertexFormat),n._length=o,n._topRadius=r,n._bottomRadius=s,n._slices=a,n._offsetAttribute=-1===u?void 0:u,n):(T.length=o,T.topRadius=r,T.bottomRadius=s,T.slices=a,T.offsetAttribute=-1===u?void 0:u,new O(T))},O.createGeometry=function(t){let e=t._length;const n=t._topRadius,c=t._bottomRadius,Z=t._vertexFormat,_=t._slices;if(e<=0||n<0||c<0||0===n&&0===c)return;const O=_+_,P=_+O,T=O+O,E=u.Z.computePositions(e,n,c,_,!0),S=Z.st?new Float32Array(2*T):void 0,I=Z.normal?new Float32Array(3*T):void 0,N=Z.tangent?new Float32Array(3*T):void 0,M=Z.bitangent?new Float32Array(3*T):void 0;let L;const R=Z.normal||Z.tangent||Z.bitangent;if(R){const t=Z.tangent||Z.bitangent;let i=0,o=0,r=0;const a=Math.atan2(c-n,e),u=b;u.z=Math.sin(a);const l=Math.cos(a);let d=v,h=A;for(L=0;L<_;L++){const e=L/_*y.Z.TWO_PI,n=l*Math.cos(e),a=l*Math.sin(e);R&&(u.x=n,u.y=a,t&&(d=s.Z.normalize(s.Z.cross(s.Z.UNIT_Z,u,d),d)),Z.normal&&(I[i++]=u.x,I[i++]=u.y,I[i++]=u.z,I[i++]=u.x,I[i++]=u.y,I[i++]=u.z),Z.tangent&&(N[o++]=d.x,N[o++]=d.y,N[o++]=d.z,N[o++]=d.x,N[o++]=d.y,N[o++]=d.z),Z.bitangent&&(h=s.Z.normalize(s.Z.cross(u,d,h),h),M[r++]=h.x,M[r++]=h.y,M[r++]=h.z,M[r++]=h.x,M[r++]=h.y,M[r++]=h.z))}for(L=0;L<_;L++)Z.normal&&(I[i++]=0,I[i++]=0,I[i++]=-1),Z.tangent&&(N[o++]=1,N[o++]=0,N[o++]=0),Z.bitangent&&(M[r++]=0,M[r++]=-1,M[r++]=0);for(L=0;L<_;L++)Z.normal&&(I[i++]=0,I[i++]=0,I[i++]=1),Z.tangent&&(N[o++]=1,N[o++]=0,N[o++]=0),Z.bitangent&&(M[r++]=0,M[r++]=1,M[r++]=0)}const C=12*_-12,k=m.Z.createTypedArray(T,C);let z=0,D=0;for(L=0;L<_-1;L++)k[z++]=D,k[z++]=D+2,k[z++]=D+3,k[z++]=D,k[z++]=D+3,k[z++]=D+1,D+=2;for(k[z++]=O-2,k[z++]=0,k[z++]=1,k[z++]=O-2,k[z++]=1,k[z++]=O-1,L=1;L<_-1;L++)k[z++]=O+L+1,k[z++]=O+L,k[z++]=O;for(L=1;L<_-1;L++)k[z++]=P,k[z++]=P+L,k[z++]=P+L+1;let F=0;if(Z.st){const t=Math.max(n,c);for(L=0;L<T;L++){const e=s.Z.fromArray(E,3*L,x);S[F++]=(e.x+t)/(2*t),S[F++]=(e.y+t)/(2*t)}}const q=new f.Z;Z.position&&(q.position=new h.Z({componentDatatype:a.Z.DOUBLE,componentsPerAttribute:3,values:E})),Z.normal&&(q.normal=new h.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:3,values:I})),Z.tangent&&(q.tangent=new h.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:3,values:N})),Z.bitangent&&(q.bitangent=new h.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:3,values:M})),Z.st&&(q.st=new h.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:2,values:S})),w.x=.5*e,w.y=Math.max(c,n);const U=new o.Z(s.Z.ZERO,r.Z.magnitude(w));if((0,l.Z)(t._offsetAttribute)){e=E.length;const n=new Uint8Array(e/3),o=t._offsetAttribute===p.Z.NONE?0:1;(0,i.Z)(n,o),q.applyOffset=new h.Z({componentDatatype:a.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new d.Z({attributes:q,indices:k,primitiveType:g.Z.TRIANGLES,boundingSphere:U,offsetAttribute:t._offsetAttribute})},O.getUnitCylinder=function(){return(0,l.Z)(E)||(E=O.createGeometry(new O({topRadius:1,bottomRadius:1,length:1,vertexFormat:_.Z.POSITION_ONLY}))),E};const S=O},67115:(t,e,n)=>{n.d(e,{Z:()=>r});var i=n(22874);const o={computePositions:function(t,e,n,o,r){const s=.5*t,a=-s,u=o+o,c=new Float64Array(3*(r?2*u:u));let l,Z=0,d=0;const h=r?3*u:0,f=r?3*(u+o):3*o;for(l=0;l<o;l++){const t=l/o*i.Z.TWO_PI,u=Math.cos(t),p=Math.sin(t),m=u*n,y=p*n,g=u*e,_=p*e;c[d+h]=m,c[d+h+1]=y,c[d+h+2]=a,c[d+f]=g,c[d+f+1]=_,c[d+f+2]=s,d+=3,r&&(c[Z++]=m,c[Z++]=y,c[Z++]=a,c[Z++]=g,c[Z++]=_,c[Z++]=s)}return c}},r=o},46423:(t,e,n)=>{n.d(e,{Z:()=>A});var i=n(65730),o=n(52351),r=n(59015),s=n(93517),a=n(17497),u=n(44990),c=n(67115),l=n(88779),Z=n(54485),d=n(20176),h=n(97845),f=n(94061),p=n(77683),m=n(97029),y=n(39172),g=n(84473);const _=new r.Z;function w(t){const e=(t=(0,l.Z)(t,l.Z.EMPTY_OBJECT)).length,n=t.topRadius,i=t.bottomRadius,o=(0,l.Z)(t.slices,128),r=Math.max((0,l.Z)(t.numberOfVerticalLines,16),0);if(a.Z.typeOf.number("options.positions",e),a.Z.typeOf.number("options.topRadius",n),a.Z.typeOf.number("options.bottomRadius",i),a.Z.typeOf.number.greaterThanOrEquals("options.slices",o,3),(0,Z.Z)(t.offsetAttribute)&&t.offsetAttribute===m.Z.TOP)throw new d.Z("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=e,this._topRadius=n,this._bottomRadius=i,this._slices=o,this._numberOfVerticalLines=r,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderOutlineGeometry"}w.packedLength=6,w.pack=function(t,e,n){return a.Z.typeOf.object("value",t),a.Z.defined("array",e),n=(0,l.Z)(n,0),e[n++]=t._length,e[n++]=t._topRadius,e[n++]=t._bottomRadius,e[n++]=t._slices,e[n++]=t._numberOfVerticalLines,e[n]=(0,l.Z)(t._offsetAttribute,-1),e};const b={length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};w.unpack=function(t,e,n){a.Z.defined("array",t),e=(0,l.Z)(e,0);const i=t[e++],o=t[e++],r=t[e++],s=t[e++],u=t[e++],c=t[e];return(0,Z.Z)(n)?(n._length=i,n._topRadius=o,n._bottomRadius=r,n._slices=s,n._numberOfVerticalLines=u,n._offsetAttribute=-1===c?void 0:c,n):(b.length=i,b.topRadius=o,b.bottomRadius=r,b.slices=s,b.numberOfVerticalLines=u,b.offsetAttribute=-1===c?void 0:c,new w(b))},w.createGeometry=function(t){let e=t._length;const n=t._topRadius,a=t._bottomRadius,l=t._slices,d=t._numberOfVerticalLines;if(e<=0||n<0||a<0||0===n&&0===a)return;const w=2*l,b=c.Z.computePositions(e,n,a,l,!1);let A,v=2*l;if(d>0){const t=Math.min(d,l);A=Math.round(l/t),v+=t}const x=y.Z.createTypedArray(w,2*v);let O,P=0;for(O=0;O<l-1;O++)x[P++]=O,x[P++]=O+1,x[P++]=O+l,x[P++]=O+1+l;if(x[P++]=l-1,x[P++]=0,x[P++]=l+l-1,x[P++]=l,d>0)for(O=0;O<l;O+=A)x[P++]=O,x[P++]=O+l;const T=new p.Z;T.position=new f.Z({componentDatatype:u.Z.DOUBLE,componentsPerAttribute:3,values:b}),_.x=.5*e,_.y=Math.max(a,n);const E=new o.Z(s.Z.ZERO,r.Z.magnitude(_));if((0,Z.Z)(t._offsetAttribute)){e=b.length;const n=new Uint8Array(e/3),o=t._offsetAttribute===m.Z.NONE?0:1;(0,i.Z)(n,o),T.applyOffset=new f.Z({componentDatatype:u.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new h.Z({attributes:T,indices:x,primitiveType:g.Z.LINES,boundingSphere:E,offsetAttribute:t._offsetAttribute})};const A=w},65759:(t,e,n)=>{function i(t){this.proxy=t}n.d(e,{Z:()=>o}),i.prototype.getURL=function(t){const e=-1===this.proxy.indexOf("?")?"?":"";return this.proxy+e+encodeURIComponent(t)};const o=i},20176:(t,e,n)=>{n.d(e,{Z:()=>r});var i=n(54485);function o(t){let e;this.name="DeveloperError",this.message=t;try{throw new Error}catch(t){e=t.stack}this.stack=e}(0,i.Z)(Object.create)&&(o.prototype=Object.create(Error.prototype),o.prototype.constructor=o),o.prototype.toString=function(){let t=`${this.name}: ${this.message}`;return(0,i.Z)(this.stack)&&(t+=`\n${this.stack.toString()}`),t},o.throwInstantiationError=function(){throw new o("This function defines an interface and should not be called directly.")};const r=o},51178:(t,e,n)=>{n.d(e,{Z:()=>a});var i=n(88779),o=n(54485),r=n(20176);function s(t,e){t=(0,i.Z)(t,0),this._near=t,e=(0,i.Z)(e,Number.MAX_VALUE),this._far=e}Object.defineProperties(s.prototype,{near:{get:function(){return this._near},set:function(t){this._near=t}},far:{get:function(){return this._far},set:function(t){this._far=t}}}),s.packedLength=2,s.pack=function(t,e,n){if(!(0,o.Z)(t))throw new r.Z("value is required");if(!(0,o.Z)(e))throw new r.Z("array is required");return n=(0,i.Z)(n,0),e[n++]=t.near,e[n]=t.far,e},s.unpack=function(t,e,n){if(!(0,o.Z)(t))throw new r.Z("array is required");return e=(0,i.Z)(e,0),(0,o.Z)(n)||(n=new s),n.near=t[e++],n.far=t[e],n},s.equals=function(t,e){return t===e||(0,o.Z)(t)&&(0,o.Z)(e)&&t.near===e.near&&t.far===e.far},s.clone=function(t,e){if((0,o.Z)(t))return(0,o.Z)(e)||(e=new s),e.near=t.near,e.far=t.far,e},s.prototype.clone=function(t){return s.clone(this,t)},s.prototype.equals=function(t){return s.equals(this,t)};const a=s},64493:(t,e,n)=>{n.d(e,{Z:()=>u});var i=n(44990),o=n(88779),r=n(54485),s=n(20176);function a(t,e){if(t=(0,o.Z)(t,0),(e=(0,o.Z)(e,Number.MAX_VALUE))<=t)throw new s.Z("far distance must be greater than near distance.");this.value=new Float32Array([t,e])}Object.defineProperties(a.prototype,{componentDatatype:{get:function(){return i.Z.FLOAT}},componentsPerAttribute:{get:function(){return 2}},normalize:{get:function(){return!1}}}),a.fromDistanceDisplayCondition=function(t){if(!(0,r.Z)(t))throw new s.Z("distanceDisplayCondition is required.");if(t.far<=t.near)throw new s.Z("distanceDisplayCondition.far distance must be greater than distanceDisplayCondition.near distance.");return new a(t.near,t.far)},a.toValue=function(t,e){if(!(0,r.Z)(t))throw new s.Z("distanceDisplayCondition is required.");return(0,r.Z)(e)?(e[0]=t.near,e[1]=t.far,e):new Float32Array([t.near,t.far])};const u=a},51331:(t,e,n)=>{n.d(e,{Z:()=>d});var i=n(22874),o=n(17497),r=n(54485);function s(t){o.Z.typeOf.object("options",t),o.Z.defined("options.comparator",t.comparator),(0,r.Z)(t.maximumLength)&&o.Z.typeOf.number.greaterThanOrEquals("options.maximumLength",t.maximumLength,0),this._comparator=t.comparator,this._maximumLength=t.maximumLength,this._array=(0,r.Z)(t.maximumLength)?new Array(t.maximumLength):[],this._length=0}function a(t,e,n){const i=t._array,o=i[e];i[e]=i[n],i[n]=o}function u(t,e,n){return t._comparator(t._array[e],t._array[n])<0}function c(t,e,n){return t._comparator(t._array[e],t._array[n])>0}function l(t,e){if(0===e)return;const n=Math.floor(i.Z.log2(e+1))%2==0,o=Math.floor((e-1)/2),r=u(t,e,o);for(r!==n&&(a(t,e,o),e=o);e>=3;){const n=Math.floor((e-3)/4);if(u(t,e,n)!==r)break;a(t,e,n),e=n}}function Z(t,e){const n=t._length,o=Math.floor(i.Z.log2(e+1))%2==0;let r;for(;(r=2*e+1)<n;){let i=r;const s=r+1;if(s<n){u(t,s,i)===o&&(i=s);const e=2*r+1,a=Math.max(Math.min(n-e,4),0);for(let n=0;n<a;n++){const r=e+n;u(t,r,i)===o&&(i=r)}}if(u(t,i,e)===o&&(a(t,i,e),i!==r&&i!==s)){const e=Math.floor((i-1)/2);c(t,i,e)===o&&a(t,i,e)}e=i}}Object.defineProperties(s.prototype,{length:{get:function(){return this._length}},maximumLength:{get:function(){return this._maximumLength},set:function(t){if((0,r.Z)(t)){for(o.Z.typeOf.number.greaterThanOrEquals("maximumLength",t,0);this._length>t;)this.removeMinimum();this._array.length=t}this._maximumLength=t}},internalArray:{get:function(){return this._array}},comparator:{get:function(){return this._comparator}}}),s.prototype.clone=function(){const t=this._maximumLength,e=this._comparator,n=this._array,i=this._length,o=new s({comparator:e,maximumLength:t});o._length=i;for(let t=0;t<i;t++)o._array[t]=n[t];return o},s.prototype.reset=function(){this._length=0;const t=this._maximumLength;if((0,r.Z)(t))for(let e=0;e<t;e++)this._array[e]=void 0;else this._array.length=0},s.prototype.resort=function(){const t=this._length;for(let e=0;e<t;e++)l(this,e)},s.prototype.insert=function(t){let e;const n=this._maximumLength;if((0,r.Z)(n)){if(0===n)return;if(this._length===n){const n=this._array[0];if(this._comparator(t,n)<=0)return t;e=this.removeMinimum()}}const i=this._length;return this._array[i]=t,this._length++,l(this,i),e},s.prototype.removeMinimum=function(){const t=this._length;if(0===t)return;this._length--;const e=this._array[0];return t>=2&&(this._array[0]=this._array[t-1],Z(this,0)),this._array[t-1]=void 0,e},s.prototype.removeMaximum=function(){const t=this._length;if(0===t)return;let e;if(this._length--,t<=2)e=this._array[t-1];else{const n=c(this,1,2)?1:2;e=this._array[n],this._array[n]=this._array[t-1],t>=4&&Z(this,n)}return this._array[t-1]=void 0,e},s.prototype.getMinimum=function(){if(0!==this._length)return this._array[0]},s.prototype.getMaximum=function(){const t=this._length;if(0!==t)return t<=2?this._array[t-1]:this._array[c(this,1,2)?1:2]};const d=s},65073:(t,e,n)=>{n.d(e,{Z:()=>a});var i=n(54485);function o(){this.head=void 0,this.tail=void 0,this._length=0}function r(t,e,n){this.item=t,this.previous=e,this.next=n}function s(t,e){(0,i.Z)(e.previous)&&(0,i.Z)(e.next)?(e.previous.next=e.next,e.next.previous=e.previous):(0,i.Z)(e.previous)?(e.previous.next=void 0,t.tail=e.previous):(0,i.Z)(e.next)?(e.next.previous=void 0,t.head=e.next):(t.head=void 0,t.tail=void 0),e.next=void 0,e.previous=void 0}Object.defineProperties(o.prototype,{length:{get:function(){return this._length}}}),o.prototype.add=function(t){const e=new r(t,this.tail,void 0);return(0,i.Z)(this.tail)?(this.tail.next=e,this.tail=e):(this.head=e,this.tail=e),++this._length,e},o.prototype.remove=function(t){(0,i.Z)(t)&&(s(this,t),--this._length)},o.prototype.splice=function(t,e){if(t===e)return;s(this,e);const n=t.next;t.next=e,this.tail===t?this.tail=e:n.previous=e,e.next=n,e.previous=t};const a=o},27647:(t,e,n)=>{n.d(e,{Z:()=>_});var i=n(17216),o=n(88779),r=n(54485),s=n(69074),a=n(97262),u=n(87218),c=n(67197),l=n(21514),Z=n(4230),d=n(33081);function h(t){if(t=(0,o.Z)(t,o.Z.EMPTY_OBJECT),this._dates=void 0,this._samples=void 0,this._dateColumn=-1,this._xPoleWanderRadiansColumn=-1,this._yPoleWanderRadiansColumn=-1,this._ut1MinusUtcSecondsColumn=-1,this._xCelestialPoleOffsetRadiansColumn=-1,this._yCelestialPoleOffsetRadiansColumn=-1,this._taiMinusUtcSecondsColumn=-1,this._columnCount=0,this._lastIndex=-1,this._downloadPromise=void 0,this._dataError=void 0,this._addNewLeapSeconds=(0,o.Z)(t.addNewLeapSeconds,!0),(0,r.Z)(t.data))p(this,t.data);else if((0,r.Z)(t.url)){const e=c.Z.createIfNeeded(t.url),n=this;this._downloadPromise=e.fetchJson().then((function(t){p(n,t)})).catch((function(){n._dataError=`An error occurred while retrieving the EOP data from the URL ${e.url}.`}))}else p(this,{columnNames:["dateIso8601","modifiedJulianDateUtc","xPoleWanderRadians","yPoleWanderRadians","ut1MinusUtcSeconds","lengthOfDayCorrectionSeconds","xCelestialPoleOffsetRadians","yCelestialPoleOffsetRadians","taiMinusUtcSeconds"],samples:[]})}function f(t,e){return a.Z.compare(t.julianDate,e)}function p(t,e){if(!(0,r.Z)(e.columnNames))return void(t._dataError="Error in loaded EOP data: The columnNames property is required.");if(!(0,r.Z)(e.samples))return void(t._dataError="Error in loaded EOP data: The samples property is required.");const n=e.columnNames.indexOf("modifiedJulianDateUtc"),o=e.columnNames.indexOf("xPoleWanderRadians"),s=e.columnNames.indexOf("yPoleWanderRadians"),c=e.columnNames.indexOf("ut1MinusUtcSeconds"),l=e.columnNames.indexOf("xCelestialPoleOffsetRadians"),h=e.columnNames.indexOf("yCelestialPoleOffsetRadians"),p=e.columnNames.indexOf("taiMinusUtcSeconds");if(n<0||o<0||s<0||c<0||l<0||h<0||p<0)return void(t._dataError="Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns");const m=t._samples=e.samples,y=t._dates=[];let g;t._dateColumn=n,t._xPoleWanderRadiansColumn=o,t._yPoleWanderRadiansColumn=s,t._ut1MinusUtcSecondsColumn=c,t._xCelestialPoleOffsetRadiansColumn=l,t._yCelestialPoleOffsetRadiansColumn=h,t._taiMinusUtcSecondsColumn=p,t._columnCount=e.columnNames.length,t._lastIndex=void 0;const _=t._addNewLeapSeconds;for(let e=0,o=m.length;e<o;e+=t._columnCount){const t=m[e+n],o=m[e+p],s=t+Z.Z.MODIFIED_JULIAN_DATE_DIFFERENCE,c=new a.Z(s,o,d.Z.TAI);if(y.push(c),_){if(o!==g&&(0,r.Z)(g)){const t=a.Z.leapSeconds,e=(0,i.Z)(t,c,f);if(e<0){const n=new u.Z(c,o);t.splice(~e,0,n)}}g=o}}}function m(t,e,n,i,o){const r=n*i;o.xPoleWander=e[r+t._xPoleWanderRadiansColumn],o.yPoleWander=e[r+t._yPoleWanderRadiansColumn],o.xPoleOffset=e[r+t._xCelestialPoleOffsetRadiansColumn],o.yPoleOffset=e[r+t._yCelestialPoleOffsetRadiansColumn],o.ut1MinusUtc=e[r+t._ut1MinusUtcSecondsColumn]}function y(t,e,n){return e+t*(n-e)}function g(t,e,n,i,o,r,s){const u=t._columnCount;if(r>e.length-1)return s.xPoleWander=0,s.yPoleWander=0,s.xPoleOffset=0,s.yPoleOffset=0,s.ut1MinusUtc=0,s;const c=e[o],l=e[r];if(c.equals(l)||i.equals(c))return m(t,n,o,u,s),s;if(i.equals(l))return m(t,n,r,u,s),s;const Z=a.Z.secondsDifference(i,c)/a.Z.secondsDifference(l,c),d=o*u,h=r*u;let f=n[d+t._ut1MinusUtcSecondsColumn],p=n[h+t._ut1MinusUtcSecondsColumn];const g=p-f;if(g>.5||g<-.5){const e=n[d+t._taiMinusUtcSecondsColumn],o=n[h+t._taiMinusUtcSecondsColumn];e!==o&&(l.equals(i)?f=p:p-=o-e)}return s.xPoleWander=y(Z,n[d+t._xPoleWanderRadiansColumn],n[h+t._xPoleWanderRadiansColumn]),s.yPoleWander=y(Z,n[d+t._yPoleWanderRadiansColumn],n[h+t._yPoleWanderRadiansColumn]),s.xPoleOffset=y(Z,n[d+t._xCelestialPoleOffsetRadiansColumn],n[h+t._xCelestialPoleOffsetRadiansColumn]),s.yPoleOffset=y(Z,n[d+t._yCelestialPoleOffsetRadiansColumn],n[h+t._yCelestialPoleOffsetRadiansColumn]),s.ut1MinusUtc=y(Z,f,p),s}h.NONE=Object.freeze({getPromiseToLoad:function(){return Promise.resolve()},compute:function(t,e){return(0,r.Z)(e)?(e.xPoleWander=0,e.yPoleWander=0,e.xPoleOffset=0,e.yPoleOffset=0,e.ut1MinusUtc=0):e=new s.Z(0,0,0,0,0),e}}),h.prototype.getPromiseToLoad=function(){return Promise.resolve(this._downloadPromise)},h.prototype.compute=function(t,e){if(!(0,r.Z)(this._samples)){if((0,r.Z)(this._dataError))throw new l.Z(this._dataError);return}if((0,r.Z)(e)||(e=new s.Z(0,0,0,0,0)),0===this._samples.length)return e.xPoleWander=0,e.yPoleWander=0,e.xPoleOffset=0,e.yPoleOffset=0,e.ut1MinusUtc=0,e;const n=this._dates,o=this._lastIndex;let u=0,c=0;if((0,r.Z)(o)){const i=n[o],s=n[o+1],l=a.Z.lessThanOrEquals(i,t),Z=!(0,r.Z)(s),d=Z||a.Z.greaterThanOrEquals(s,t);if(l&&d)return u=o,!Z&&s.equals(t)&&++u,c=u+1,g(this,n,this._samples,t,u,c,e),e}let Z=(0,i.Z)(n,t,a.Z.compare,this._dateColumn);return Z>=0?(Z<n.length-1&&n[Z+1].equals(t)&&++Z,u=Z,c=Z):(c=~Z,u=c-1,u<0&&(u=0)),this._lastIndex=u,g(this,n,this._samples,t,u,c,e),e};const _=h},69074:(t,e,n)=>{n.d(e,{Z:()=>i});const i=function(t,e,n,i,o){this.xPoleWander=t,this.yPoleWander=e,this.xPoleOffset=n,this.yPoleOffset=i,this.ut1MinusUtc=o}},45971:(t,e,n)=>{n.d(e,{Z:()=>r});var i=n(41638);const o={LINEAR_NONE:i.Z.Easing.Linear.None,QUADRATIC_IN:i.Z.Easing.Quadratic.In,QUADRATIC_OUT:i.Z.Easing.Quadratic.Out,QUADRATIC_IN_OUT:i.Z.Easing.Quadratic.InOut,CUBIC_IN:i.Z.Easing.Cubic.In,CUBIC_OUT:i.Z.Easing.Cubic.Out,CUBIC_IN_OUT:i.Z.Easing.Cubic.InOut,QUARTIC_IN:i.Z.Easing.Quartic.In,QUARTIC_OUT:i.Z.Easing.Quartic.Out,QUARTIC_IN_OUT:i.Z.Easing.Quartic.InOut,QUINTIC_IN:i.Z.Easing.Quintic.In,QUINTIC_OUT:i.Z.Easing.Quintic.Out,QUINTIC_IN_OUT:i.Z.Easing.Quintic.InOut,SINUSOIDAL_IN:i.Z.Easing.Sinusoidal.In,SINUSOIDAL_OUT:i.Z.Easing.Sinusoidal.Out,SINUSOIDAL_IN_OUT:i.Z.Easing.Sinusoidal.InOut,EXPONENTIAL_IN:i.Z.Easing.Exponential.In,EXPONENTIAL_OUT:i.Z.Easing.Exponential.Out,EXPONENTIAL_IN_OUT:i.Z.Easing.Exponential.InOut,CIRCULAR_IN:i.Z.Easing.Circular.In,CIRCULAR_OUT:i.Z.Easing.Circular.Out,CIRCULAR_IN_OUT:i.Z.Easing.Circular.InOut,ELASTIC_IN:i.Z.Easing.Elastic.In,ELASTIC_OUT:i.Z.Easing.Elastic.Out,ELASTIC_IN_OUT:i.Z.Easing.Elastic.InOut,BACK_IN:i.Z.Easing.Back.In,BACK_OUT:i.Z.Easing.Back.Out,BACK_IN_OUT:i.Z.Easing.Back.InOut,BOUNCE_IN:i.Z.Easing.Bounce.In,BOUNCE_OUT:i.Z.Easing.Bounce.Out,BOUNCE_IN_OUT:i.Z.Easing.Bounce.InOut},r=Object.freeze(o)},43309:(t,e,n)=>{n.d(e,{Z:()=>nt});var i=n(65730),o=n(52351),r=n(59015),s=n(93517),a=n(66866),u=n(17497),c=n(44990),l=n(88779),Z=n(54485),d=n(20176),h=n(9693),f=n(99996),p=n(64729),m=n(97845),y=n(94061),g=n(77683),_=n(78224),w=n(97029),b=n(45050),A=n(39172),v=n(22874),x=n(39109),O=n(84473),P=n(20291),T=n(34152),E=n(25225);const S=new s.Z,I=new s.Z,N=new s.Z,M=new s.Z,L=new r.Z,R=new x.Z,C=new x.Z,k=new P.Z,z=new s.Z,D=new s.Z,F=new s.Z,q=new a.Z,U=new s.Z,B=new r.Z,V=new r.Z;function G(t,e,n){const o=e.vertexFormat,a=e.center,u=e.semiMajorAxis,l=e.semiMinorAxis,d=e.ellipsoid,f=e.stRotation,m=n?t.length/3*2:t.length/3,_=e.shadowVolume,b=o.st?new Float32Array(2*m):void 0,A=o.normal?new Float32Array(3*m):void 0,v=o.tangent?new Float32Array(3*m):void 0,O=o.bitangent?new Float32Array(3*m):void 0,T=_?new Float32Array(3*m):void 0;let E=0,M=z,G=D,j=F;const W=new p.Z(d),H=W.project(d.cartesianToCartographic(a,q),U),Y=d.scaleToGeodeticSurface(a,S);d.geodeticSurfaceNormal(Y,Y);let Q=R,X=C;if(0!==f){let t=P.Z.fromAxisAngle(Y,f,k);Q=x.Z.fromQuaternion(t,Q),t=P.Z.fromAxisAngle(Y,-f,k),X=x.Z.fromQuaternion(t,X)}else Q=x.Z.clone(x.Z.IDENTITY,Q),X=x.Z.clone(x.Z.IDENTITY,X);const J=r.Z.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,B),$=r.Z.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,V);let K=t.length;const tt=n?K:0,et=tt/3*2;for(let e=0;e<K;e+=3){const i=e+1,r=e+2,a=s.Z.fromArray(t,e,S);if(o.st){const t=x.Z.multiplyByVector(Q,a,I),e=W.project(d.cartesianToCartographic(t,q),N);s.Z.subtract(e,H,e),L.x=(e.x+u)/(2*u),L.y=(e.y+l)/(2*l),J.x=Math.min(L.x,J.x),J.y=Math.min(L.y,J.y),$.x=Math.max(L.x,$.x),$.y=Math.max(L.y,$.y),n&&(b[E+et]=L.x,b[E+1+et]=L.y),b[E++]=L.x,b[E++]=L.y}(o.normal||o.tangent||o.bitangent||_)&&(M=d.geodeticSurfaceNormal(a,M),_&&(T[e+tt]=-M.x,T[i+tt]=-M.y,T[r+tt]=-M.z),(o.normal||o.tangent||o.bitangent)&&((o.tangent||o.bitangent)&&(G=s.Z.normalize(s.Z.cross(s.Z.UNIT_Z,M,G),G),x.Z.multiplyByVector(X,G,G)),o.normal&&(A[e]=M.x,A[i]=M.y,A[r]=M.z,n&&(A[e+tt]=-M.x,A[i+tt]=-M.y,A[r+tt]=-M.z)),o.tangent&&(v[e]=G.x,v[i]=G.y,v[r]=G.z,n&&(v[e+tt]=-G.x,v[i+tt]=-G.y,v[r+tt]=-G.z)),o.bitangent&&(j=s.Z.normalize(s.Z.cross(M,G,j),j),O[e]=j.x,O[i]=j.y,O[r]=j.z,n&&(O[e+tt]=j.x,O[i+tt]=j.y,O[r+tt]=j.z))))}if(o.st){K=b.length;for(let t=0;t<K;t+=2)b[t]=(b[t]-J.x)/($.x-J.x),b[t+1]=(b[t+1]-J.y)/($.y-J.y)}const nt=new g.Z;if(o.position){const i=h.Z.raisePositionsToHeight(t,e,n);nt.position=new y.Z({componentDatatype:c.Z.DOUBLE,componentsPerAttribute:3,values:i})}if(o.st&&(nt.st=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:2,values:b})),o.normal&&(nt.normal=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:A})),o.tangent&&(nt.tangent=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:v})),o.bitangent&&(nt.bitangent=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:O})),_&&(nt.extrudeDirection=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:T})),n&&(0,Z.Z)(e.offsetAttribute)){let t=new Uint8Array(m);if(e.offsetAttribute===w.Z.TOP)t=(0,i.Z)(t,1,0,m/2);else{const n=e.offsetAttribute===w.Z.NONE?0:1;t=(0,i.Z)(t,n)}nt.applyOffset=new y.Z({componentDatatype:c.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return nt}function j(t){const e=new Array(t*(t+1)*12-6);let n,i,o,r,s,a=0;for(n=0,o=1,r=0;r<3;r++)e[a++]=o++,e[a++]=n,e[a++]=o;for(r=2;r<t+1;++r){for(o=r*(r+1)-1,n=(r-1)*r-1,e[a++]=o++,e[a++]=n,e[a++]=o,i=2*r,s=0;s<i-1;++s)e[a++]=o,e[a++]=n++,e[a++]=n,e[a++]=o++,e[a++]=n,e[a++]=o;e[a++]=o++,e[a++]=n,e[a++]=o}for(i=2*t,++o,++n,r=0;r<i-1;++r)e[a++]=o,e[a++]=n++,e[a++]=n,e[a++]=o++,e[a++]=n,e[a++]=o;for(e[a++]=o,e[a++]=n++,e[a++]=n,e[a++]=o++,e[a++]=n++,e[a++]=n,++n,r=t-1;r>1;--r){for(e[a++]=n++,e[a++]=n,e[a++]=o,i=2*r,s=0;s<i-1;++s)e[a++]=o,e[a++]=n++,e[a++]=n,e[a++]=o++,e[a++]=n,e[a++]=o;e[a++]=n++,e[a++]=n++,e[a++]=o++}for(r=0;r<3;r++)e[a++]=n++,e[a++]=n,e[a++]=o;return e}let W=new s.Z;const H=new o.Z,Y=new o.Z;function Q(t){const e=t.center,n=t.ellipsoid,a=t.semiMajorAxis;let u=s.Z.multiplyByScalar(n.geodeticSurfaceNormal(e,S),t.height,S);H.center=s.Z.add(e,u,H.center),H.radius=a,u=s.Z.multiplyByScalar(n.geodeticSurfaceNormal(e,u),t.extrudedHeight,u),Y.center=s.Z.add(e,u,Y.center),Y.radius=a;const l=h.Z.computeEllipsePositions(t,!0,!0),d=l.positions,f=l.numPts,v=l.outerPositions,T=o.Z.union(H,Y),E=G(d,t,!0);let C=j(f);const W=C.length;C.length=2*W;const Q=d.length/3;for(let t=0;t<W;t+=3)C[t+W]=C[t+2]+Q,C[t+1+W]=C[t+1]+Q,C[t+2+W]=C[t]+Q;const X=A.Z.createTypedArray(2*Q/3,C),J=new m.Z({attributes:E,indices:X,primitiveType:O.Z.TRIANGLES}),$=function(t,e){const n=e.vertexFormat,o=e.center,a=e.semiMajorAxis,u=e.semiMinorAxis,l=e.ellipsoid,d=e.height,h=e.extrudedHeight,f=e.stRotation,m=t.length/3*2,_=new Float64Array(3*m),b=n.st?new Float32Array(2*m):void 0,A=n.normal?new Float32Array(3*m):void 0,v=n.tangent?new Float32Array(3*m):void 0,O=n.bitangent?new Float32Array(3*m):void 0,T=e.shadowVolume,E=T?new Float32Array(3*m):void 0;let C=0,G=z,j=D,W=F;const H=new p.Z(l),Y=H.project(l.cartesianToCartographic(o,q),U),Q=l.scaleToGeodeticSurface(o,S);l.geodeticSurfaceNormal(Q,Q);const X=P.Z.fromAxisAngle(Q,f,k),J=x.Z.fromQuaternion(X,R),$=r.Z.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,B),K=r.Z.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,V);let tt=t.length;const et=tt/3*2;for(let e=0;e<tt;e+=3){const i=e+1,o=e+2;let r,c=s.Z.fromArray(t,e,S);if(n.st){const t=x.Z.multiplyByVector(J,c,I),e=H.project(l.cartesianToCartographic(t,q),N);s.Z.subtract(e,Y,e),L.x=(e.x+a)/(2*a),L.y=(e.y+u)/(2*u),$.x=Math.min(L.x,$.x),$.y=Math.min(L.y,$.y),K.x=Math.max(L.x,K.x),K.y=Math.max(L.y,K.y),b[C+et]=L.x,b[C+1+et]=L.y,b[C++]=L.x,b[C++]=L.y}c=l.scaleToGeodeticSurface(c,c),r=s.Z.clone(c,I),G=l.geodeticSurfaceNormal(c,G),T&&(E[e+tt]=-G.x,E[i+tt]=-G.y,E[o+tt]=-G.z);let Z=s.Z.multiplyByScalar(G,d,M);if(c=s.Z.add(c,Z,c),Z=s.Z.multiplyByScalar(G,h,Z),r=s.Z.add(r,Z,r),n.position&&(_[e+tt]=r.x,_[i+tt]=r.y,_[o+tt]=r.z,_[e]=c.x,_[i]=c.y,_[o]=c.z),n.normal||n.tangent||n.bitangent){W=s.Z.clone(G,W);const a=s.Z.fromArray(t,(e+3)%tt,M);s.Z.subtract(a,c,a);const u=s.Z.subtract(r,c,N);G=s.Z.normalize(s.Z.cross(u,a,G),G),n.normal&&(A[e]=G.x,A[i]=G.y,A[o]=G.z,A[e+tt]=G.x,A[i+tt]=G.y,A[o+tt]=G.z),n.tangent&&(j=s.Z.normalize(s.Z.cross(W,G,j),j),v[e]=j.x,v[i]=j.y,v[o]=j.z,v[e+tt]=j.x,v[e+1+tt]=j.y,v[e+2+tt]=j.z),n.bitangent&&(O[e]=W.x,O[i]=W.y,O[o]=W.z,O[e+tt]=W.x,O[i+tt]=W.y,O[o+tt]=W.z)}}if(n.st){tt=b.length;for(let t=0;t<tt;t+=2)b[t]=(b[t]-$.x)/(K.x-$.x),b[t+1]=(b[t+1]-$.y)/(K.y-$.y)}const nt=new g.Z;if(n.position&&(nt.position=new y.Z({componentDatatype:c.Z.DOUBLE,componentsPerAttribute:3,values:_})),n.st&&(nt.st=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:2,values:b})),n.normal&&(nt.normal=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:A})),n.tangent&&(nt.tangent=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:v})),n.bitangent&&(nt.bitangent=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:O})),T&&(nt.extrudeDirection=new y.Z({componentDatatype:c.Z.FLOAT,componentsPerAttribute:3,values:E})),(0,Z.Z)(e.offsetAttribute)){let t=new Uint8Array(m);if(e.offsetAttribute===w.Z.TOP)t=(0,i.Z)(t,1,0,m/2);else{const n=e.offsetAttribute===w.Z.NONE?0:1;t=(0,i.Z)(t,n)}nt.applyOffset=new y.Z({componentDatatype:c.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return nt}(v,t);C=function(t){const e=t.length/3,n=A.Z.createTypedArray(e,6*e);let i=0;for(let t=0;t<e;t++){const o=t,r=t+e,s=(o+1)%e,a=s+e;n[i++]=o,n[i++]=r,n[i++]=s,n[i++]=s,n[i++]=r,n[i++]=a}return n}(v);const K=A.Z.createTypedArray(2*v.length/3,C),tt=new m.Z({attributes:$,indices:K,primitiveType:O.Z.TRIANGLES}),et=b.Z.combineInstances([new _.Z({geometry:J}),new _.Z({geometry:tt})]);return{boundingSphere:T,attributes:et[0].attributes,indices:et[0].indices}}function X(t,e,n,i,o,r,a){const u=h.Z.computeEllipsePositions({center:t,semiMajorAxis:e,semiMinorAxis:n,rotation:i,granularity:o},!1,!0).outerPositions,c=u.length/3,l=new Array(c);for(let t=0;t<c;++t)l[t]=s.Z.fromArray(u,3*t);const Z=T.Z.fromCartesianArray(l,r,a);return Z.width>v.Z.PI&&(Z.north=Z.north>0?v.Z.PI_OVER_TWO-v.Z.EPSILON7:Z.north,Z.south=Z.south<0?v.Z.EPSILON7-v.Z.PI_OVER_TWO:Z.south,Z.east=v.Z.PI,Z.west=-v.Z.PI),Z}function J(t){const e=(t=(0,l.Z)(t,l.Z.EMPTY_OBJECT)).center,n=(0,l.Z)(t.ellipsoid,f.Z.WGS84),i=t.semiMajorAxis,o=t.semiMinorAxis,r=(0,l.Z)(t.granularity,v.Z.RADIANS_PER_DEGREE),a=(0,l.Z)(t.vertexFormat,E.Z.DEFAULT);if(u.Z.defined("options.center",e),u.Z.typeOf.number("options.semiMajorAxis",i),u.Z.typeOf.number("options.semiMinorAxis",o),i<o)throw new d.Z("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(r<=0)throw new d.Z("granularity must be greater than zero.");const c=(0,l.Z)(t.height,0),Z=(0,l.Z)(t.extrudedHeight,c);this._center=s.Z.clone(e),this._semiMajorAxis=i,this._semiMinorAxis=o,this._ellipsoid=f.Z.clone(n),this._rotation=(0,l.Z)(t.rotation,0),this._stRotation=(0,l.Z)(t.stRotation,0),this._height=Math.max(Z,c),this._granularity=r,this._vertexFormat=E.Z.clone(a),this._extrudedHeight=Math.min(Z,c),this._shadowVolume=(0,l.Z)(t.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}J.packedLength=s.Z.packedLength+f.Z.packedLength+E.Z.packedLength+9,J.pack=function(t,e,n){return u.Z.defined("value",t),u.Z.defined("array",e),n=(0,l.Z)(n,0),s.Z.pack(t._center,e,n),n+=s.Z.packedLength,f.Z.pack(t._ellipsoid,e,n),n+=f.Z.packedLength,E.Z.pack(t._vertexFormat,e,n),n+=E.Z.packedLength,e[n++]=t._semiMajorAxis,e[n++]=t._semiMinorAxis,e[n++]=t._rotation,e[n++]=t._stRotation,e[n++]=t._height,e[n++]=t._granularity,e[n++]=t._extrudedHeight,e[n++]=t._shadowVolume?1:0,e[n]=(0,l.Z)(t._offsetAttribute,-1),e};const $=new s.Z,K=new f.Z,tt=new E.Z,et={center:$,ellipsoid:K,vertexFormat:tt,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};J.unpack=function(t,e,n){u.Z.defined("array",t),e=(0,l.Z)(e,0);const i=s.Z.unpack(t,e,$);e+=s.Z.packedLength;const o=f.Z.unpack(t,e,K);e+=f.Z.packedLength;const r=E.Z.unpack(t,e,tt);e+=E.Z.packedLength;const a=t[e++],c=t[e++],d=t[e++],h=t[e++],p=t[e++],m=t[e++],y=t[e++],g=1===t[e++],_=t[e];return(0,Z.Z)(n)?(n._center=s.Z.clone(i,n._center),n._ellipsoid=f.Z.clone(o,n._ellipsoid),n._vertexFormat=E.Z.clone(r,n._vertexFormat),n._semiMajorAxis=a,n._semiMinorAxis=c,n._rotation=d,n._stRotation=h,n._height=p,n._granularity=m,n._extrudedHeight=y,n._shadowVolume=g,n._offsetAttribute=-1===_?void 0:_,n):(et.height=p,et.extrudedHeight=y,et.granularity=m,et.stRotation=h,et.rotation=d,et.semiMajorAxis=a,et.semiMinorAxis=c,et.shadowVolume=g,et.offsetAttribute=-1===_?void 0:_,new J(et))},J.computeRectangle=function(t,e){const n=(t=(0,l.Z)(t,l.Z.EMPTY_OBJECT)).center,i=(0,l.Z)(t.ellipsoid,f.Z.WGS84),o=t.semiMajorAxis,r=t.semiMinorAxis,s=(0,l.Z)(t.granularity,v.Z.RADIANS_PER_DEGREE),a=(0,l.Z)(t.rotation,0);if(u.Z.defined("options.center",n),u.Z.typeOf.number("options.semiMajorAxis",o),u.Z.typeOf.number("options.semiMinorAxis",r),o<r)throw new d.Z("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(s<=0)throw new d.Z("granularity must be greater than zero.");return X(n,o,r,a,s,i,e)},J.createGeometry=function(t){if(t._semiMajorAxis<=0||t._semiMinorAxis<=0)return;const e=t._height,n=t._extrudedHeight,r=!v.Z.equalsEpsilon(e,n,0,v.Z.EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const a={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:e,granularity:t._granularity,vertexFormat:t._vertexFormat,stRotation:t._stRotation};let u;if(r)a.extrudedHeight=n,a.shadowVolume=t._shadowVolume,a.offsetAttribute=t._offsetAttribute,u=Q(a);else if(u=function(t){const e=t.center;W=s.Z.multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(e,W),t.height,W),W=s.Z.add(e,W,W);const n=new o.Z(W,t.semiMajorAxis),i=h.Z.computeEllipsePositions(t,!0,!1),r=i.positions,a=i.numPts,u=G(r,t,!1);let c=j(a);return c=A.Z.createTypedArray(r.length/3,c),{boundingSphere:n,attributes:u,indices:c}}(a),(0,Z.Z)(t._offsetAttribute)){const e=u.attributes.position.values.length,n=new Uint8Array(e/3),o=t._offsetAttribute===w.Z.NONE?0:1;(0,i.Z)(n,o),u.attributes.applyOffset=new y.Z({componentDatatype:c.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new m.Z({attributes:u.attributes,indices:u.indices,primitiveType:O.Z.TRIANGLES,boundingSphere:u.boundingSphere,offsetAttribute:t._offsetAttribute})},J.createShadowVolume=function(t,e,n){const i=t._granularity,o=t._ellipsoid,r=e(i,o),s=n(i,o);return new J({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:o,rotation:t._rotation,stRotation:t._stRotation,granularity:i,extrudedHeight:r,height:s,vertexFormat:E.Z.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(J.prototype,{rectangle:{get:function(){return(0,Z.Z)(this._rectangle)||(this._rectangle=X(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return(0,Z.Z)(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const n=h.Z.computeEllipsePositions({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,rotation:t._rotation,granularity:t._granularity},!1,!0).outerPositions,i=n.length/3,o=new Array(i);for(let t=0;t<i;++t)o[t]=s.Z.fromArray(n,3*t);const r=t._ellipsoid,a=t.rectangle;return m.Z._textureCoordinateRotationPoints(o,e,r,a)}(this)),this._textureCoordinateRotationPoints}}});const nt=J},9693:(t,e,n)=>{n.d(e,{Z:()=>w});var i=n(93517),o=n(22874),r=n(39109),s=n(20291);const a={},u=new i.Z,c=new i.Z,l=new s.Z,Z=new r.Z;function d(t,e,n,o,a,d,h,f,p,m){const y=t+e;i.Z.multiplyByScalar(o,Math.cos(y),u),i.Z.multiplyByScalar(n,Math.sin(y),c),i.Z.add(u,c,u);let g=Math.cos(t);g*=g;let _=Math.sin(t);_*=_;const w=d/Math.sqrt(h*g+a*_)/f;return s.Z.fromAxisAngle(u,w,l),r.Z.fromQuaternion(l,Z),r.Z.multiplyByVector(Z,p,m),i.Z.normalize(m,m),i.Z.multiplyByScalar(m,f,m),m}const h=new i.Z,f=new i.Z,p=new i.Z,m=new i.Z;a.raisePositionsToHeight=function(t,e,n){const o=e.ellipsoid,r=e.height,s=e.extrudedHeight,a=n?t.length/3*2:t.length/3,u=new Float64Array(3*a),c=t.length,l=n?c:0;for(let e=0;e<c;e+=3){const a=e+1,c=e+2,Z=i.Z.fromArray(t,e,h);o.scaleToGeodeticSurface(Z,Z);const d=i.Z.clone(Z,f),y=o.geodeticSurfaceNormal(Z,m),g=i.Z.multiplyByScalar(y,r,p);i.Z.add(Z,g,Z),n&&(i.Z.multiplyByScalar(y,s,g),i.Z.add(d,g,d),u[e+l]=d.x,u[a+l]=d.y,u[c+l]=d.z),u[e]=Z.x,u[a]=Z.y,u[c]=Z.z}return u};const y=new i.Z,g=new i.Z,_=new i.Z;a.computeEllipsePositions=function(t,e,n){const r=t.semiMinorAxis,s=t.semiMajorAxis,a=t.rotation,u=t.center,c=8*t.granularity,l=r*r,Z=s*s,m=s*r,w=i.Z.magnitude(u),b=i.Z.normalize(u,y);let A=i.Z.cross(i.Z.UNIT_Z,u,g);A=i.Z.normalize(A,A);const v=i.Z.cross(b,A,_);let x=1+Math.ceil(o.Z.PI_OVER_TWO/c);const O=o.Z.PI_OVER_TWO/(x-1);let P=o.Z.PI_OVER_TWO-x*O;P<0&&(x-=Math.ceil(Math.abs(P)/O));const T=e?new Array(3*(x*(x+2)*2)):void 0;let E=0,S=h,I=f;const N=4*x*3;let M=N-1,L=0;const R=n?new Array(N):void 0;let C,k,z,D,F;for(P=o.Z.PI_OVER_TWO,S=d(P,a,v,A,l,m,Z,w,b,S),e&&(T[E++]=S.x,T[E++]=S.y,T[E++]=S.z),n&&(R[M--]=S.z,R[M--]=S.y,R[M--]=S.x),P=o.Z.PI_OVER_TWO-O,C=1;C<x+1;++C){if(S=d(P,a,v,A,l,m,Z,w,b,S),I=d(Math.PI-P,a,v,A,l,m,Z,w,b,I),e){for(T[E++]=S.x,T[E++]=S.y,T[E++]=S.z,z=2*C+2,k=1;k<z-1;++k)D=k/(z-1),F=i.Z.lerp(S,I,D,p),T[E++]=F.x,T[E++]=F.y,T[E++]=F.z;T[E++]=I.x,T[E++]=I.y,T[E++]=I.z}n&&(R[M--]=S.z,R[M--]=S.y,R[M--]=S.x,R[L++]=I.x,R[L++]=I.y,R[L++]=I.z),P=o.Z.PI_OVER_TWO-(C+1)*O}for(C=x;C>1;--C){if(P=o.Z.PI_OVER_TWO-(C-1)*O,S=d(-P,a,v,A,l,m,Z,w,b,S),I=d(P+Math.PI,a,v,A,l,m,Z,w,b,I),e){for(T[E++]=S.x,T[E++]=S.y,T[E++]=S.z,z=2*(C-1)+2,k=1;k<z-1;++k)D=k/(z-1),F=i.Z.lerp(S,I,D,p),T[E++]=F.x,T[E++]=F.y,T[E++]=F.z;T[E++]=I.x,T[E++]=I.y,T[E++]=I.z}n&&(R[M--]=S.z,R[M--]=S.y,R[M--]=S.x,R[L++]=I.x,R[L++]=I.y,R[L++]=I.z)}P=o.Z.PI_OVER_TWO,S=d(-P,a,v,A,l,m,Z,w,b,S);const q={};return e&&(T[E++]=S.x,T[E++]=S.y,T[E++]=S.z,q.positions=T,q.numPts=x),n&&(R[M--]=S.z,R[M--]=S.y,R[M--]=S.x,q.outerPositions=R),q};const w=a},46620:(t,e,n)=>{n.d(e,{Z:()=>T});var i=n(65730),o=n(52351),r=n(93517),s=n(44990),a=n(88779),u=n(54485),c=n(20176),l=n(9693),Z=n(99996),d=n(97845),h=n(94061),f=n(77683),p=n(97029),m=n(39172),y=n(22874),g=n(84473);const _=new r.Z;let w=new r.Z;const b=new o.Z,A=new o.Z;function v(t){const e=(t=(0,a.Z)(t,a.Z.EMPTY_OBJECT)).center,n=(0,a.Z)(t.ellipsoid,Z.Z.WGS84),i=t.semiMajorAxis,o=t.semiMinorAxis,s=(0,a.Z)(t.granularity,y.Z.RADIANS_PER_DEGREE);if(!(0,u.Z)(e))throw new c.Z("center is required.");if(!(0,u.Z)(i))throw new c.Z("semiMajorAxis is required.");if(!(0,u.Z)(o))throw new c.Z("semiMinorAxis is required.");if(i<o)throw new c.Z("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(s<=0)throw new c.Z("granularity must be greater than zero.");const l=(0,a.Z)(t.height,0),d=(0,a.Z)(t.extrudedHeight,l);this._center=r.Z.clone(e),this._semiMajorAxis=i,this._semiMinorAxis=o,this._ellipsoid=Z.Z.clone(n),this._rotation=(0,a.Z)(t.rotation,0),this._height=Math.max(d,l),this._granularity=s,this._extrudedHeight=Math.min(d,l),this._numberOfVerticalLines=Math.max((0,a.Z)(t.numberOfVerticalLines,16),0),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}v.packedLength=r.Z.packedLength+Z.Z.packedLength+8,v.pack=function(t,e,n){if(!(0,u.Z)(t))throw new c.Z("value is required");if(!(0,u.Z)(e))throw new c.Z("array is required");return n=(0,a.Z)(n,0),r.Z.pack(t._center,e,n),n+=r.Z.packedLength,Z.Z.pack(t._ellipsoid,e,n),n+=Z.Z.packedLength,e[n++]=t._semiMajorAxis,e[n++]=t._semiMinorAxis,e[n++]=t._rotation,e[n++]=t._height,e[n++]=t._granularity,e[n++]=t._extrudedHeight,e[n++]=t._numberOfVerticalLines,e[n]=(0,a.Z)(t._offsetAttribute,-1),e};const x=new r.Z,O=new Z.Z,P={center:x,ellipsoid:O,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};v.unpack=function(t,e,n){if(!(0,u.Z)(t))throw new c.Z("array is required");e=(0,a.Z)(e,0);const i=r.Z.unpack(t,e,x);e+=r.Z.packedLength;const o=Z.Z.unpack(t,e,O);e+=Z.Z.packedLength;const s=t[e++],l=t[e++],d=t[e++],h=t[e++],f=t[e++],p=t[e++],m=t[e++],y=t[e];return(0,u.Z)(n)?(n._center=r.Z.clone(i,n._center),n._ellipsoid=Z.Z.clone(o,n._ellipsoid),n._semiMajorAxis=s,n._semiMinorAxis=l,n._rotation=d,n._height=h,n._granularity=f,n._extrudedHeight=p,n._numberOfVerticalLines=m,n._offsetAttribute=-1===y?void 0:y,n):(P.height=h,P.extrudedHeight=p,P.granularity=f,P.rotation=d,P.semiMajorAxis=s,P.semiMinorAxis=l,P.numberOfVerticalLines=m,P.offsetAttribute=-1===y?void 0:y,new v(P))},v.createGeometry=function(t){if(t._semiMajorAxis<=0||t._semiMinorAxis<=0)return;const e=t._height,n=t._extrudedHeight,c=!y.Z.equalsEpsilon(e,n,0,y.Z.EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const Z={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:e,granularity:t._granularity,numberOfVerticalLines:t._numberOfVerticalLines};let v;if(c)Z.extrudedHeight=n,Z.offsetAttribute=t._offsetAttribute,v=function(t){const e=t.center,n=t.ellipsoid,c=t.semiMajorAxis;let Z=r.Z.multiplyByScalar(n.geodeticSurfaceNormal(e,_),t.height,_);b.center=r.Z.add(e,Z,b.center),b.radius=c,Z=r.Z.multiplyByScalar(n.geodeticSurfaceNormal(e,Z),t.extrudedHeight,Z),A.center=r.Z.add(e,Z,A.center),A.radius=c;let d=l.Z.computeEllipsePositions(t,!1,!0).outerPositions;const g=new f.Z({position:new h.Z({componentDatatype:s.Z.DOUBLE,componentsPerAttribute:3,values:l.Z.raisePositionsToHeight(d,t,!0)})});d=g.position.values;const w=o.Z.union(b,A);let v=d.length/3;if((0,u.Z)(t.offsetAttribute)){let e=new Uint8Array(v);if(t.offsetAttribute===p.Z.TOP)e=(0,i.Z)(e,1,0,v/2);else{const n=t.offsetAttribute===p.Z.NONE?0:1;e=(0,i.Z)(e,n)}g.applyOffset=new h.Z({componentDatatype:s.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}let x=(0,a.Z)(t.numberOfVerticalLines,16);x=y.Z.clamp(x,0,v/2);const O=m.Z.createTypedArray(v,2*v+2*x);v/=2;let P,T,E=0;for(P=0;P<v;++P)O[E++]=P,O[E++]=(P+1)%v,O[E++]=P+v,O[E++]=(P+1)%v+v;if(x>0){const t=Math.min(x,v);T=Math.round(v/t);const e=Math.min(T*x,v);for(P=0;P<e;P+=T)O[E++]=P,O[E++]=P+v}return{boundingSphere:w,attributes:g,indices:O}}(Z);else if(v=function(t){const e=t.center;w=r.Z.multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(e,w),t.height,w),w=r.Z.add(e,w,w);const n=new o.Z(w,t.semiMajorAxis),i=l.Z.computeEllipsePositions(t,!1,!0).outerPositions,a=new f.Z({position:new h.Z({componentDatatype:s.Z.DOUBLE,componentsPerAttribute:3,values:l.Z.raisePositionsToHeight(i,t,!1)})}),u=i.length/3,c=m.Z.createTypedArray(u,2*u);let Z=0;for(let t=0;t<u;++t)c[Z++]=t,c[Z++]=(t+1)%u;return{boundingSphere:n,attributes:a,indices:c}}(Z),(0,u.Z)(t._offsetAttribute)){const e=v.attributes.position.values.length,n=new Uint8Array(e/3),o=t._offsetAttribute===p.Z.NONE?0:1;(0,i.Z)(n,o),v.attributes.applyOffset=new h.Z({componentDatatype:s.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new d.Z({attributes:v.attributes,indices:v.indices,primitiveType:g.Z.LINES,boundingSphere:v.boundingSphere,offsetAttribute:t._offsetAttribute})};const T=v},99996:(t,e,n)=>{n.d(e,{Z:()=>b});var i=n(93517),o=n(66866),r=n(17497),s=n(88779),a=n(54485),u=n(20176),c=n(22874),l=n(92565);function Z(t,e,n,o){e=(0,s.Z)(e,0),n=(0,s.Z)(n,0),o=(0,s.Z)(o,0),r.Z.typeOf.number.greaterThanOrEquals("x",e,0),r.Z.typeOf.number.greaterThanOrEquals("y",n,0),r.Z.typeOf.number.greaterThanOrEquals("z",o,0),t._radii=new i.Z(e,n,o),t._radiiSquared=new i.Z(e*e,n*n,o*o),t._radiiToTheFourth=new i.Z(e*e*e*e,n*n*n*n,o*o*o*o),t._oneOverRadii=new i.Z(0===e?0:1/e,0===n?0:1/n,0===o?0:1/o),t._oneOverRadiiSquared=new i.Z(0===e?0:1/(e*e),0===n?0:1/(n*n),0===o?0:1/(o*o)),t._minimumRadius=Math.min(e,n,o),t._maximumRadius=Math.max(e,n,o),t._centerToleranceSquared=c.Z.EPSILON1,0!==t._radiiSquared.z&&(t._squaredXOverSquaredZ=t._radiiSquared.x/t._radiiSquared.z)}function d(t,e,n){this._radii=void 0,this._radiiSquared=void 0,this._radiiToTheFourth=void 0,this._oneOverRadii=void 0,this._oneOverRadiiSquared=void 0,this._minimumRadius=void 0,this._maximumRadius=void 0,this._centerToleranceSquared=void 0,this._squaredXOverSquaredZ=void 0,Z(this,t,e,n)}Object.defineProperties(d.prototype,{radii:{get:function(){return this._radii}},radiiSquared:{get:function(){return this._radiiSquared}},radiiToTheFourth:{get:function(){return this._radiiToTheFourth}},oneOverRadii:{get:function(){return this._oneOverRadii}},oneOverRadiiSquared:{get:function(){return this._oneOverRadiiSquared}},minimumRadius:{get:function(){return this._minimumRadius}},maximumRadius:{get:function(){return this._maximumRadius}}}),d.clone=function(t,e){if(!(0,a.Z)(t))return;const n=t._radii;return(0,a.Z)(e)?(i.Z.clone(n,e._radii),i.Z.clone(t._radiiSquared,e._radiiSquared),i.Z.clone(t._radiiToTheFourth,e._radiiToTheFourth),i.Z.clone(t._oneOverRadii,e._oneOverRadii),i.Z.clone(t._oneOverRadiiSquared,e._oneOverRadiiSquared),e._minimumRadius=t._minimumRadius,e._maximumRadius=t._maximumRadius,e._centerToleranceSquared=t._centerToleranceSquared,e):new d(n.x,n.y,n.z)},d.fromCartesian3=function(t,e){return(0,a.Z)(e)||(e=new d),(0,a.Z)(t)?(Z(e,t.x,t.y,t.z),e):e},d.WGS84=Object.freeze(new d(6378137,6378137,6356752.314245179)),d.UNIT_SPHERE=Object.freeze(new d(1,1,1)),d.MOON=Object.freeze(new d(c.Z.LUNAR_RADIUS,c.Z.LUNAR_RADIUS,c.Z.LUNAR_RADIUS)),d.prototype.clone=function(t){return d.clone(this,t)},d.packedLength=i.Z.packedLength,d.pack=function(t,e,n){return r.Z.typeOf.object("value",t),r.Z.defined("array",e),n=(0,s.Z)(n,0),i.Z.pack(t._radii,e,n),e},d.unpack=function(t,e,n){r.Z.defined("array",t),e=(0,s.Z)(e,0);const o=i.Z.unpack(t,e);return d.fromCartesian3(o,n)},d.prototype.geocentricSurfaceNormal=i.Z.normalize,d.prototype.geodeticSurfaceNormalCartographic=function(t,e){r.Z.typeOf.object("cartographic",t);const n=t.longitude,o=t.latitude,s=Math.cos(o),u=s*Math.cos(n),c=s*Math.sin(n),l=Math.sin(o);return(0,a.Z)(e)||(e=new i.Z),e.x=u,e.y=c,e.z=l,i.Z.normalize(e,e)},d.prototype.geodeticSurfaceNormal=function(t,e){if(!i.Z.equalsEpsilon(t,i.Z.ZERO,c.Z.EPSILON14))return(0,a.Z)(e)||(e=new i.Z),e=i.Z.multiplyComponents(t,this._oneOverRadiiSquared,e),i.Z.normalize(e,e)};const h=new i.Z,f=new i.Z;d.prototype.cartographicToCartesian=function(t,e){const n=h,o=f;this.geodeticSurfaceNormalCartographic(t,n),i.Z.multiplyComponents(this._radiiSquared,n,o);const r=Math.sqrt(i.Z.dot(n,o));return i.Z.divideByScalar(o,r,o),i.Z.multiplyByScalar(n,t.height,n),(0,a.Z)(e)||(e=new i.Z),i.Z.add(o,n,e)},d.prototype.cartographicArrayToCartesianArray=function(t,e){r.Z.defined("cartographics",t);const n=t.length;(0,a.Z)(e)?e.length=n:e=new Array(n);for(let i=0;i<n;i++)e[i]=this.cartographicToCartesian(t[i],e[i]);return e};const p=new i.Z,m=new i.Z,y=new i.Z;d.prototype.cartesianToCartographic=function(t,e){const n=this.scaleToGeodeticSurface(t,m);if(!(0,a.Z)(n))return;const r=this.geodeticSurfaceNormal(n,p),s=i.Z.subtract(t,n,y),u=Math.atan2(r.y,r.x),l=Math.asin(r.z),Z=c.Z.sign(i.Z.dot(s,t))*i.Z.magnitude(s);return(0,a.Z)(e)?(e.longitude=u,e.latitude=l,e.height=Z,e):new o.Z(u,l,Z)},d.prototype.cartesianArrayToCartographicArray=function(t,e){r.Z.defined("cartesians",t);const n=t.length;(0,a.Z)(e)?e.length=n:e=new Array(n);for(let i=0;i<n;++i)e[i]=this.cartesianToCartographic(t[i],e[i]);return e},d.prototype.scaleToGeodeticSurface=function(t,e){return(0,l.Z)(t,this._oneOverRadii,this._oneOverRadiiSquared,this._centerToleranceSquared,e)},d.prototype.scaleToGeocentricSurface=function(t,e){r.Z.typeOf.object("cartesian",t),(0,a.Z)(e)||(e=new i.Z);const n=t.x,o=t.y,s=t.z,u=this._oneOverRadiiSquared,c=1/Math.sqrt(n*n*u.x+o*o*u.y+s*s*u.z);return i.Z.multiplyByScalar(t,c,e)},d.prototype.transformPositionToScaledSpace=function(t,e){return(0,a.Z)(e)||(e=new i.Z),i.Z.multiplyComponents(t,this._oneOverRadii,e)},d.prototype.transformPositionFromScaledSpace=function(t,e){return(0,a.Z)(e)||(e=new i.Z),i.Z.multiplyComponents(t,this._radii,e)},d.prototype.equals=function(t){return this===t||(0,a.Z)(t)&&i.Z.equals(this._radii,t._radii)},d.prototype.toString=function(){return this._radii.toString()},d.prototype.getSurfaceNormalIntersectionWithZAxis=function(t,e,n){if(r.Z.typeOf.object("position",t),!c.Z.equalsEpsilon(this._radii.x,this._radii.y,c.Z.EPSILON15))throw new u.Z("Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)");r.Z.typeOf.number.greaterThan("Ellipsoid.radii.z",this._radii.z,0),e=(0,s.Z)(e,0);const o=this._squaredXOverSquaredZ;if((0,a.Z)(n)||(n=new i.Z),n.x=0,n.y=0,n.z=t.z*(1-o),!(Math.abs(n.z)>=this._radii.z-e))return n};const g=[.14887433898163,.43339539412925,.67940956829902,.86506336668898,.97390652851717,0],_=[.29552422471475,.26926671930999,.21908636251598,.14945134915058,.066671344308684,0];function w(t,e,n){r.Z.typeOf.number("a",t),r.Z.typeOf.number("b",e),r.Z.typeOf.func("func",n);const i=.5*(e+t),o=.5*(e-t);let s=0;for(let t=0;t<5;t++){const e=o*g[t];s+=_[t]*(n(i+e)+n(i-e))}return s*=o,s}d.prototype.surfaceArea=function(t){r.Z.typeOf.object("rectangle",t);const e=t.west;let n=t.east;const i=t.south,o=t.north;for(;n<e;)n+=c.Z.TWO_PI;const s=this._radiiSquared,a=s.x,u=s.y,l=s.z,Z=a*u;return w(i,o,(function(t){const i=Math.cos(t),o=Math.sin(t);return Math.cos(t)*w(e,n,(function(t){const e=Math.cos(t),n=Math.sin(t);return Math.sqrt(Z*o*o+l*(u*e*e+a*n*n)*i*i)}))}))};const b=d},94025:(t,e,n)=>{n.d(e,{Z:()=>p});var i=n(93517),o=n(66866),r=n(17497),s=n(88779),a=n(54485),u=n(99996),c=n(22874);function l(t,e,n,i,o,r,s){const a=function(t,e){return t*e*(4+t*(4-3*e))/16}(t,n);return(1-a)*t*e*(i+a*o*(s+a*r*(2*s*s-1)))}const Z=new i.Z,d=new i.Z;function h(t,e,n,s){const a=i.Z.normalize(s.cartographicToCartesian(e,d),Z),u=i.Z.normalize(s.cartographicToCartesian(n,d),d);r.Z.typeOf.number.greaterThanOrEquals("value",Math.abs(Math.abs(i.Z.angleBetween(a,u))-Math.PI),.0125),function(t,e,n,i,o,r,s){const a=(e-n)/e,u=r-i,Z=Math.atan((1-a)*Math.tan(o)),d=Math.atan((1-a)*Math.tan(s)),h=Math.cos(Z),f=Math.sin(Z),p=Math.cos(d),m=Math.sin(d),y=h*p,g=h*m,_=f*m,w=f*p;let b,A,v,x,O,P=u,T=c.Z.TWO_PI,E=Math.cos(P),S=Math.sin(P);do{E=Math.cos(P),S=Math.sin(P);const t=g-w*E;let e;v=Math.sqrt(p*p*S*S+t*t),A=_+y*E,b=Math.atan2(v,A),0===v?(e=0,x=1):(e=y*S/v,x=1-e*e),T=P,O=A-2*_/x,isFinite(O)||(O=0),P=u+l(a,e,x,b,v,A,O)}while(Math.abs(P-T)>c.Z.EPSILON12);const I=x*(e*e-n*n)/(n*n),N=I*(256+I*(I*(74-47*I)-128))/1024,M=O*O,L=n*(1+I*(4096+I*(I*(320-175*I)-768))/16384)*(b-N*v*(O+N*(A*(2*M-1)-N*O*(4*v*v-3)*(4*M-3)/6)/4)),R=Math.atan2(p*S,g-w*E),C=Math.atan2(h*S,g*E-w);t._distance=L,t._startHeading=R,t._endHeading=C,t._uSquared=I}(t,s.maximumRadius,s.minimumRadius,e.longitude,e.latitude,n.longitude,n.latitude),t._start=o.Z.clone(e,t._start),t._end=o.Z.clone(n,t._end),t._start.height=0,t._end.height=0,function(t){const e=t._uSquared,n=t._ellipsoid.maximumRadius,i=t._ellipsoid.minimumRadius,o=(n-i)/n,r=Math.cos(t._startHeading),s=Math.sin(t._startHeading),a=(1-o)*Math.tan(t._start.latitude),u=1/Math.sqrt(1+a*a),c=u*a,l=Math.atan2(a,r),Z=u*s,d=Z*Z,h=1-d,f=Math.sqrt(h),p=e/4,m=p*p,y=m*p,g=m*m,_=1+p-3*m/4+5*y/4-175*g/64,w=1-p+15*m/8-35*y/8,b=1-3*p+35*m/4,A=1-5*p,v=_*l-w*Math.sin(2*l)*p/2-b*Math.sin(4*l)*m/16-A*Math.sin(6*l)*y/48-5*Math.sin(8*l)*g/512,x=t._constants;x.a=n,x.b=i,x.f=o,x.cosineHeading=r,x.sineHeading=s,x.tanU=a,x.cosineU=u,x.sineU=c,x.sigma=l,x.sineAlpha=Z,x.sineSquaredAlpha=d,x.cosineSquaredAlpha=h,x.cosineAlpha=f,x.u2Over4=p,x.u4Over16=m,x.u6Over64=y,x.u8Over256=g,x.a0=_,x.a1=w,x.a2=b,x.a3=A,x.distanceRatio=v}(t)}function f(t,e,n){const i=(0,s.Z)(n,u.Z.WGS84);this._ellipsoid=i,this._start=new o.Z,this._end=new o.Z,this._constants={},this._startHeading=void 0,this._endHeading=void 0,this._distance=void 0,this._uSquared=void 0,(0,a.Z)(t)&&(0,a.Z)(e)&&h(this,t,e,i)}Object.defineProperties(f.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return r.Z.defined("distance",this._distance),this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},startHeading:{get:function(){return r.Z.defined("distance",this._distance),this._startHeading}},endHeading:{get:function(){return r.Z.defined("distance",this._distance),this._endHeading}}}),f.prototype.setEndPoints=function(t,e){r.Z.defined("start",t),r.Z.defined("end",e),h(this,t,e,this._ellipsoid)},f.prototype.interpolateUsingFraction=function(t,e){return this.interpolateUsingSurfaceDistance(this._distance*t,e)},f.prototype.interpolateUsingSurfaceDistance=function(t,e){r.Z.defined("distance",this._distance);const n=this._constants,i=n.distanceRatio+t/n.b,s=Math.cos(2*i),u=Math.cos(4*i),c=Math.cos(6*i),Z=Math.sin(2*i),d=Math.sin(4*i),h=Math.sin(6*i),f=Math.sin(8*i),p=i*i,m=i*p,y=n.u8Over256,g=n.u2Over4,_=n.u6Over64,w=n.u4Over16;let b=2*m*y*s/3+i*(1-g+7*w/4-15*_/4+579*y/64-(w-15*_/4+187*y/16)*s-(5*_/4-115*y/16)*u-29*y*c/16)+(g/2-w+71*_/32-85*y/16)*Z+(5*w/16-5*_/4+383*y/96)*d-p*((_-11*y/2)*Z+5*y*d/2)+(29*_/96-29*y/16)*h+539*y*f/1536;const A=Math.asin(Math.sin(b)*n.cosineAlpha),v=Math.atan(n.a/n.b*Math.tan(A));b-=n.sigma;const x=Math.cos(2*n.sigma+b),O=Math.sin(b),P=Math.cos(b),T=n.cosineU*P,E=n.sineU*O,S=Math.atan2(O*n.sineHeading,T-E*n.cosineHeading)-l(n.f,n.sineAlpha,n.cosineSquaredAlpha,b,O,P,x);return(0,a.Z)(e)?(e.longitude=this._start.longitude+S,e.latitude=v,e.height=0,e):new o.Z(this._start.longitude+S,v,0)};const p=f},31161:(t,e,n)=>{n.d(e,{Z:()=>R});var i=n(65730),o=n(52351),r=n(59015),s=n(93517),a=n(44990),u=n(88779),c=n(54485),l=n(20176),Z=n(99996),d=n(97845),h=n(94061),f=n(77683),p=n(97029),m=n(39172),y=n(22874),g=n(84473),_=n(25225);const w=new s.Z,b=new s.Z,A=new s.Z,v=new s.Z,x=new s.Z,O=new s.Z(1,1,1),P=Math.cos,T=Math.sin;function E(t){t=(0,u.Z)(t,u.Z.EMPTY_OBJECT);const e=(0,u.Z)(t.radii,O),n=(0,u.Z)(t.innerRadii,e),i=(0,u.Z)(t.minimumClock,0),o=(0,u.Z)(t.maximumClock,y.Z.TWO_PI),r=(0,u.Z)(t.minimumCone,0),a=(0,u.Z)(t.maximumCone,y.Z.PI),c=Math.round((0,u.Z)(t.stackPartitions,64)),Z=Math.round((0,u.Z)(t.slicePartitions,64)),d=(0,u.Z)(t.vertexFormat,_.Z.DEFAULT);if(Z<3)throw new l.Z("options.slicePartitions cannot be less than three.");if(c<3)throw new l.Z("options.stackPartitions cannot be less than three.");this._radii=s.Z.clone(e),this._innerRadii=s.Z.clone(n),this._minimumClock=i,this._maximumClock=o,this._minimumCone=r,this._maximumCone=a,this._stackPartitions=c,this._slicePartitions=Z,this._vertexFormat=_.Z.clone(d),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}E.packedLength=2*s.Z.packedLength+_.Z.packedLength+7,E.pack=function(t,e,n){if(!(0,c.Z)(t))throw new l.Z("value is required");if(!(0,c.Z)(e))throw new l.Z("array is required");return n=(0,u.Z)(n,0),s.Z.pack(t._radii,e,n),n+=s.Z.packedLength,s.Z.pack(t._innerRadii,e,n),n+=s.Z.packedLength,_.Z.pack(t._vertexFormat,e,n),n+=_.Z.packedLength,e[n++]=t._minimumClock,e[n++]=t._maximumClock,e[n++]=t._minimumCone,e[n++]=t._maximumCone,e[n++]=t._stackPartitions,e[n++]=t._slicePartitions,e[n]=(0,u.Z)(t._offsetAttribute,-1),e};const S=new s.Z,I=new s.Z,N=new _.Z,M={radii:S,innerRadii:I,vertexFormat:N,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let L;E.unpack=function(t,e,n){if(!(0,c.Z)(t))throw new l.Z("array is required");e=(0,u.Z)(e,0);const i=s.Z.unpack(t,e,S);e+=s.Z.packedLength;const o=s.Z.unpack(t,e,I);e+=s.Z.packedLength;const r=_.Z.unpack(t,e,N);e+=_.Z.packedLength;const a=t[e++],Z=t[e++],d=t[e++],h=t[e++],f=t[e++],p=t[e++],m=t[e];return(0,c.Z)(n)?(n._radii=s.Z.clone(i,n._radii),n._innerRadii=s.Z.clone(o,n._innerRadii),n._vertexFormat=_.Z.clone(r,n._vertexFormat),n._minimumClock=a,n._maximumClock=Z,n._minimumCone=d,n._maximumCone=h,n._stackPartitions=f,n._slicePartitions=p,n._offsetAttribute=-1===m?void 0:m,n):(M.minimumClock=a,M.maximumClock=Z,M.minimumCone=d,M.maximumCone=h,M.stackPartitions=f,M.slicePartitions=p,M.offsetAttribute=-1===m?void 0:m,new E(M))},E.createGeometry=function(t){const e=t._radii;if(e.x<=0||e.y<=0||e.z<=0)return;const n=t._innerRadii;if(n.x<=0||n.y<=0||n.z<=0)return;const u=t._minimumClock,l=t._maximumClock,_=t._minimumCone,O=t._maximumCone,E=t._vertexFormat;let S,I,N=t._slicePartitions+1,M=t._stackPartitions+1;N=Math.round(N*Math.abs(l-u)/y.Z.TWO_PI),M=Math.round(M*Math.abs(O-_)/y.Z.PI),N<2&&(N=2),M<2&&(M=2);let L=0;const R=[_],C=[u];for(S=0;S<M;S++)R.push(_+S*(O-_)/(M-1));for(R.push(O),I=0;I<N;I++)C.push(u+I*(l-u)/(N-1));C.push(l);const k=R.length,z=C.length;let D=0,F=1;const q=n.x!==e.x||n.y!==e.y||n.z!==e.z;let U=!1,B=!1,V=!1;q&&(F=2,_>0&&(U=!0,D+=N-1),O<Math.PI&&(B=!0,D+=N-1),(l-u)%y.Z.TWO_PI?(V=!0,D+=2*(M-1)+1):D+=1);const G=z*k*F,j=new Float64Array(3*G),W=(0,i.Z)(new Array(G),!1),H=(0,i.Z)(new Array(G),!1),Y=N*M*F,Q=6*(Y+D+1-(N+M)*F),X=m.Z.createTypedArray(Y,Q),J=E.normal?new Float32Array(3*G):void 0,$=E.tangent?new Float32Array(3*G):void 0,K=E.bitangent?new Float32Array(3*G):void 0,tt=E.st?new Float32Array(2*G):void 0,et=new Array(k),nt=new Array(k);for(S=0;S<k;S++)et[S]=T(R[S]),nt[S]=P(R[S]);const it=new Array(z),ot=new Array(z);for(I=0;I<z;I++)ot[I]=P(C[I]),it[I]=T(C[I]);for(S=0;S<k;S++)for(I=0;I<z;I++)j[L++]=e.x*et[S]*ot[I],j[L++]=e.y*et[S]*it[I],j[L++]=e.z*nt[S];let rt,st,at,ut,ct=G/2;if(q)for(S=0;S<k;S++)for(I=0;I<z;I++)j[L++]=n.x*et[S]*ot[I],j[L++]=n.y*et[S]*it[I],j[L++]=n.z*nt[S],W[ct]=!0,S>0&&S!==k-1&&0!==I&&I!==z-1&&(H[ct]=!0),ct++;for(L=0,S=1;S<k-2;S++)for(rt=S*z,st=(S+1)*z,I=1;I<z-2;I++)X[L++]=st+I,X[L++]=st+I+1,X[L++]=rt+I+1,X[L++]=st+I,X[L++]=rt+I+1,X[L++]=rt+I;if(q){const t=k*z;for(S=1;S<k-2;S++)for(rt=t+S*z,st=t+(S+1)*z,I=1;I<z-2;I++)X[L++]=st+I,X[L++]=rt+I,X[L++]=rt+I+1,X[L++]=st+I,X[L++]=rt+I+1,X[L++]=st+I+1}if(q){if(U)for(ut=k*z,S=1;S<z-2;S++)X[L++]=S,X[L++]=S+1,X[L++]=ut+S+1,X[L++]=S,X[L++]=ut+S+1,X[L++]=ut+S;if(B)for(at=k*z-z,ut=k*z*F-z,S=1;S<z-2;S++)X[L++]=at+S+1,X[L++]=at+S,X[L++]=ut+S,X[L++]=at+S+1,X[L++]=ut+S,X[L++]=ut+S+1}if(V){for(S=1;S<k-2;S++)ut=z*k+z*S,at=z*S,X[L++]=ut,X[L++]=at+z,X[L++]=at,X[L++]=ut,X[L++]=ut+z,X[L++]=at+z;for(S=1;S<k-2;S++)ut=z*k+z*(S+1)-1,at=z*(S+1)-1,X[L++]=at+z,X[L++]=ut,X[L++]=at,X[L++]=at+z,X[L++]=ut+z,X[L++]=ut}const lt=new f.Z;E.position&&(lt.position=new h.Z({componentDatatype:a.Z.DOUBLE,componentsPerAttribute:3,values:j}));let Zt=0,dt=0,ht=0,ft=0;const pt=G/2;let mt;const yt=Z.Z.fromCartesian3(e),gt=Z.Z.fromCartesian3(n);if(E.st||E.normal||E.tangent||E.bitangent){for(S=0;S<G;S++){mt=W[S]?gt:yt;const t=s.Z.fromArray(j,3*S,w),e=mt.geodeticSurfaceNormal(t,b);if(H[S]&&s.Z.negate(e,e),E.st){const t=r.Z.negate(e,x);tt[Zt++]=Math.atan2(t.y,t.x)/y.Z.TWO_PI+.5,tt[Zt++]=Math.asin(e.z)/Math.PI+.5}if(E.normal&&(J[dt++]=e.x,J[dt++]=e.y,J[dt++]=e.z),E.tangent||E.bitangent){const t=A;let n,i=0;if(W[S]&&(i=pt),n=!U&&S>=i&&S<i+2*z?s.Z.UNIT_X:s.Z.UNIT_Z,s.Z.cross(n,e,t),s.Z.normalize(t,t),E.tangent&&($[ht++]=t.x,$[ht++]=t.y,$[ht++]=t.z),E.bitangent){const n=s.Z.cross(e,t,v);s.Z.normalize(n,n),K[ft++]=n.x,K[ft++]=n.y,K[ft++]=n.z}}}E.st&&(lt.st=new h.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:2,values:tt})),E.normal&&(lt.normal=new h.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:3,values:J})),E.tangent&&(lt.tangent=new h.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:3,values:$})),E.bitangent&&(lt.bitangent=new h.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:3,values:K}))}if((0,c.Z)(t._offsetAttribute)){const e=j.length,n=new Uint8Array(e/3),o=t._offsetAttribute===p.Z.NONE?0:1;(0,i.Z)(n,o),lt.applyOffset=new h.Z({componentDatatype:a.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new d.Z({attributes:lt,indices:X,primitiveType:g.Z.TRIANGLES,boundingSphere:o.Z.fromEllipsoid(yt),offsetAttribute:t._offsetAttribute})},E.getUnitEllipsoid=function(){return(0,c.Z)(L)||(L=E.createGeometry(new E({radii:new s.Z(1,1,1),vertexFormat:_.Z.POSITION_ONLY}))),L};const R=E},61695:(t,e,n)=>{n.d(e,{Z:()=>O});var i=n(65730),o=n(52351),r=n(93517),s=n(44990),a=n(88779),u=n(54485),c=n(20176),l=n(99996),Z=n(97845),d=n(94061),h=n(77683),f=n(97029),p=n(39172),m=n(22874),y=n(84473);const g=new r.Z(1,1,1),_=Math.cos,w=Math.sin;function b(t){t=(0,a.Z)(t,a.Z.EMPTY_OBJECT);const e=(0,a.Z)(t.radii,g),n=(0,a.Z)(t.innerRadii,e),i=(0,a.Z)(t.minimumClock,0),o=(0,a.Z)(t.maximumClock,m.Z.TWO_PI),s=(0,a.Z)(t.minimumCone,0),l=(0,a.Z)(t.maximumCone,m.Z.PI),Z=Math.round((0,a.Z)(t.stackPartitions,10)),d=Math.round((0,a.Z)(t.slicePartitions,8)),h=Math.round((0,a.Z)(t.subdivisions,128));if(Z<1)throw new c.Z("options.stackPartitions cannot be less than 1");if(d<0)throw new c.Z("options.slicePartitions cannot be less than 0");if(h<0)throw new c.Z("options.subdivisions must be greater than or equal to zero.");if((0,u.Z)(t.offsetAttribute)&&t.offsetAttribute===f.Z.TOP)throw new c.Z("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=r.Z.clone(e),this._innerRadii=r.Z.clone(n),this._minimumClock=i,this._maximumClock=o,this._minimumCone=s,this._maximumCone=l,this._stackPartitions=Z,this._slicePartitions=d,this._subdivisions=h,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}b.packedLength=2*r.Z.packedLength+8,b.pack=function(t,e,n){if(!(0,u.Z)(t))throw new c.Z("value is required");if(!(0,u.Z)(e))throw new c.Z("array is required");return n=(0,a.Z)(n,0),r.Z.pack(t._radii,e,n),n+=r.Z.packedLength,r.Z.pack(t._innerRadii,e,n),n+=r.Z.packedLength,e[n++]=t._minimumClock,e[n++]=t._maximumClock,e[n++]=t._minimumCone,e[n++]=t._maximumCone,e[n++]=t._stackPartitions,e[n++]=t._slicePartitions,e[n++]=t._subdivisions,e[n]=(0,a.Z)(t._offsetAttribute,-1),e};const A=new r.Z,v=new r.Z,x={radii:A,innerRadii:v,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};b.unpack=function(t,e,n){if(!(0,u.Z)(t))throw new c.Z("array is required");e=(0,a.Z)(e,0);const i=r.Z.unpack(t,e,A);e+=r.Z.packedLength;const o=r.Z.unpack(t,e,v);e+=r.Z.packedLength;const s=t[e++],l=t[e++],Z=t[e++],d=t[e++],h=t[e++],f=t[e++],p=t[e++],m=t[e];return(0,u.Z)(n)?(n._radii=r.Z.clone(i,n._radii),n._innerRadii=r.Z.clone(o,n._innerRadii),n._minimumClock=s,n._maximumClock=l,n._minimumCone=Z,n._maximumCone=d,n._stackPartitions=h,n._slicePartitions=f,n._subdivisions=p,n._offsetAttribute=-1===m?void 0:m,n):(x.minimumClock=s,x.maximumClock=l,x.minimumCone=Z,x.maximumCone=d,x.stackPartitions=h,x.slicePartitions=f,x.subdivisions=p,x.offsetAttribute=-1===m?void 0:m,new b(x))},b.createGeometry=function(t){const e=t._radii;if(e.x<=0||e.y<=0||e.z<=0)return;const n=t._innerRadii;if(n.x<=0||n.y<=0||n.z<=0)return;const r=t._minimumClock,a=t._maximumClock,c=t._minimumCone,g=t._maximumCone,b=t._subdivisions,A=l.Z.fromCartesian3(e);let v=t._slicePartitions+1,x=t._stackPartitions+1;v=Math.round(v*Math.abs(a-r)/m.Z.TWO_PI),x=Math.round(x*Math.abs(g-c)/m.Z.PI),v<2&&(v=2),x<2&&(x=2);let O=0,P=1;const T=n.x!==e.x||n.y!==e.y||n.z!==e.z;let E=!1,S=!1;T&&(P=2,c>0&&(E=!0,O+=v),g<Math.PI&&(S=!0,O+=v));const I=b*P*(x+v),N=new Float64Array(3*I),M=2*(I+O-(v+x)*P),L=p.Z.createTypedArray(I,M);let R,C,k,z,D=0;const F=new Array(x),q=new Array(x);for(R=0;R<x;R++)z=c+R*(g-c)/(x-1),F[R]=w(z),q[R]=_(z);const U=new Array(b),B=new Array(b);for(R=0;R<b;R++)k=r+R*(a-r)/(b-1),U[R]=w(k),B[R]=_(k);for(R=0;R<x;R++)for(C=0;C<b;C++)N[D++]=e.x*F[R]*B[C],N[D++]=e.y*F[R]*U[C],N[D++]=e.z*q[R];if(T)for(R=0;R<x;R++)for(C=0;C<b;C++)N[D++]=n.x*F[R]*B[C],N[D++]=n.y*F[R]*U[C],N[D++]=n.z*q[R];for(F.length=b,q.length=b,R=0;R<b;R++)z=c+R*(g-c)/(b-1),F[R]=w(z),q[R]=_(z);for(U.length=v,B.length=v,R=0;R<v;R++)k=r+R*(a-r)/(v-1),U[R]=w(k),B[R]=_(k);for(R=0;R<b;R++)for(C=0;C<v;C++)N[D++]=e.x*F[R]*B[C],N[D++]=e.y*F[R]*U[C],N[D++]=e.z*q[R];if(T)for(R=0;R<b;R++)for(C=0;C<v;C++)N[D++]=n.x*F[R]*B[C],N[D++]=n.y*F[R]*U[C],N[D++]=n.z*q[R];for(D=0,R=0;R<x*P;R++){const t=R*b;for(C=0;C<b-1;C++)L[D++]=t+C,L[D++]=t+C+1}let V=x*b*P;for(R=0;R<v;R++)for(C=0;C<b-1;C++)L[D++]=V+R+C*v,L[D++]=V+R+(C+1)*v;if(T)for(V=x*b*P+v*b,R=0;R<v;R++)for(C=0;C<b-1;C++)L[D++]=V+R+C*v,L[D++]=V+R+(C+1)*v;if(T){let t=x*b*P,e=t+b*v;if(E)for(R=0;R<v;R++)L[D++]=t+R,L[D++]=e+R;if(S)for(t+=b*v-v,e+=b*v-v,R=0;R<v;R++)L[D++]=t+R,L[D++]=e+R}const G=new h.Z({position:new d.Z({componentDatatype:s.Z.DOUBLE,componentsPerAttribute:3,values:N})});if((0,u.Z)(t._offsetAttribute)){const e=N.length,n=new Uint8Array(e/3),o=t._offsetAttribute===f.Z.NONE?0:1;(0,i.Z)(n,o),G.applyOffset=new d.Z({componentDatatype:s.Z.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new Z.Z({attributes:G,indices:L,primitiveType:y.Z.LINES,boundingSphere:o.Z.fromEllipsoid(A),offsetAttribute:t._offsetAttribute})};const O=b},48647:(t,e,n)=>{n.d(e,{Z:()=>g});var i=n(93517),o=n(66866),r=n(17497),s=n(88779),a=n(54485),u=n(20176),c=n(99996),l=n(22874);function Z(t,e,n){if(0===t)return e*n;const i=t*t,o=i*i,r=o*i,s=r*i,a=s*i,u=a*i,c=n;return e*((1-i/4-3*o/64-5*r/256-175*s/16384-441*a/65536-4851*u/1048576)*c-(3*i/8+3*o/32+45*r/1024+105*s/4096+2205*a/131072+6237*u/524288)*Math.sin(2*c)+(15*o/256+45*r/1024+525*s/16384+1575*a/65536+155925*u/8388608)*Math.sin(4*c)-(35*r/3072+175*s/12288+3675*a/262144+13475*u/1048576)*Math.sin(6*c)+(315*s/131072+2205*a/524288+43659*u/8388608)*Math.sin(8*c)-(693*a/1310720+6237*u/5242880)*Math.sin(10*c)+1001*u/8388608*Math.sin(12*c))}function d(t,e){if(0===t)return Math.log(Math.tan(.5*(l.Z.PI_OVER_TWO+e)));const n=t*Math.sin(e);return Math.log(Math.tan(.5*(l.Z.PI_OVER_TWO+e)))-t/2*Math.log((1+n)/(1-n))}const h=new i.Z,f=new i.Z;function p(t,e,n,s){const a=i.Z.normalize(s.cartographicToCartesian(e,f),h),u=i.Z.normalize(s.cartographicToCartesian(n,f),f);r.Z.typeOf.number.greaterThanOrEquals("value",Math.abs(Math.abs(i.Z.angleBetween(a,u))-Math.PI),.0125);const c=s.maximumRadius,p=s.minimumRadius,m=c*c,y=p*p;t._ellipticitySquared=(m-y)/m,t._ellipticity=Math.sqrt(t._ellipticitySquared),t._start=o.Z.clone(e,t._start),t._start.height=0,t._end=o.Z.clone(n,t._end),t._end.height=0,t._heading=function(t,e,n,i,o){const r=d(t._ellipticity,n),s=d(t._ellipticity,o);return Math.atan2(l.Z.negativePiToPi(i-e),s-r)}(t,e.longitude,e.latitude,n.longitude,n.latitude),t._distance=function(t,e,n,i,o,r,s){const a=t._heading,u=r-i;let c=0;if(l.Z.equalsEpsilon(Math.abs(a),l.Z.PI_OVER_TWO,l.Z.EPSILON8))if(e===n)c=e*Math.cos(o)*l.Z.negativePiToPi(u);else{const n=Math.sin(o);c=e*Math.cos(o)*l.Z.negativePiToPi(u)/Math.sqrt(1-t._ellipticitySquared*n*n)}else{const n=Z(t._ellipticity,e,o);c=(Z(t._ellipticity,e,s)-n)/Math.cos(a)}return Math.abs(c)}(t,s.maximumRadius,s.minimumRadius,e.longitude,e.latitude,n.longitude,n.latitude)}function m(t,e,n,i,r,s){if(0===n)return o.Z.clone(t,s);const u=r*r;let c,h,f;if(Math.abs(l.Z.PI_OVER_TWO-Math.abs(e))>l.Z.EPSILON8){h=function(t,e,n){const i=t/n;if(0===e)return i;const o=i*i,r=o*i,s=r*i,a=e*e,u=a*a,c=u*a,l=c*a,Z=l*a,d=Z*a,h=Math.sin(2*i),f=Math.cos(2*i),p=Math.sin(4*i),m=Math.cos(4*i),y=Math.sin(6*i),g=Math.cos(6*i),_=Math.sin(8*i),w=Math.cos(8*i),b=Math.sin(10*i);return i+i*a/4+7*i*u/64+15*i*c/256+579*i*l/16384+1515*i*Z/65536+16837*i*d/1048576+(3*i*u/16+45*i*c/256-i*(32*o-561)*l/4096-i*(232*o-1677)*Z/16384+i*(399985-90560*o+512*s)*d/5242880)*f+(21*i*c/256+483*i*l/4096-i*(224*o-1969)*Z/16384-i*(33152*o-112599)*d/1048576)*m+(151*i*l/4096+4681*i*Z/65536+1479*i*d/16384-453*r*d/32768)*g+(1097*i*Z/65536+42783*i*d/1048576)*w+8011*i*d/1048576*Math.cos(10*i)+(3*a/8+3*u/16+213*c/2048-3*o*c/64+255*l/4096-33*o*l/512+20861*Z/524288-33*o*Z/512+s*Z/1024+28273*d/1048576-471*o*d/8192+9*s*d/4096)*h+(21*u/256+21*c/256+533*l/8192-21*o*l/512+197*Z/4096-315*o*Z/4096+584039*d/16777216-12517*o*d/131072+7*s*d/2048)*p+(151*c/6144+151*l/4096+5019*Z/131072-453*o*Z/16384+26965*d/786432-8607*o*d/131072)*y+(1097*l/131072+1097*Z/65536+225797*d/10485760-1097*o*d/65536)*_+(8011*Z/2621440+8011*d/1048576)*b+293393*d/251658240*Math.sin(12*i)}(Z(r,i,t.latitude)+n*Math.cos(e),r,i);const o=d(r,t.latitude),s=d(r,h);f=Math.tan(e)*(s-o),c=l.Z.negativePiToPi(t.longitude+f)}else{let o;if(h=t.latitude,0===r)o=i*Math.cos(t.latitude);else{const e=Math.sin(t.latitude);o=i*Math.cos(t.latitude)/Math.sqrt(1-u*e*e)}f=n/o,c=e>0?l.Z.negativePiToPi(t.longitude+f):l.Z.negativePiToPi(t.longitude-f)}return(0,a.Z)(s)?(s.longitude=c,s.latitude=h,s.height=0,s):new o.Z(c,h,0)}function y(t,e,n){const i=(0,s.Z)(n,c.Z.WGS84);this._ellipsoid=i,this._start=new o.Z,this._end=new o.Z,this._heading=void 0,this._distance=void 0,this._ellipticity=void 0,this._ellipticitySquared=void 0,(0,a.Z)(t)&&(0,a.Z)(e)&&p(this,t,e,i)}Object.defineProperties(y.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},surfaceDistance:{get:function(){return r.Z.defined("distance",this._distance),this._distance}},start:{get:function(){return this._start}},end:{get:function(){return this._end}},heading:{get:function(){return r.Z.defined("distance",this._distance),this._heading}}}),y.fromStartHeadingDistance=function(t,e,n,i,o){r.Z.defined("start",t),r.Z.defined("heading",e),r.Z.defined("distance",n),r.Z.typeOf.number.greaterThan("distance",n,0);const u=(0,s.Z)(i,c.Z.WGS84),Z=u.maximumRadius,d=u.minimumRadius,h=Z*Z,f=d*d,p=Math.sqrt((h-f)/h),g=m(t,e=l.Z.negativePiToPi(e),n,u.maximumRadius,p);return!(0,a.Z)(o)||(0,a.Z)(i)&&!i.equals(o.ellipsoid)?new y(t,g,u):(o.setEndPoints(t,g),o)},y.prototype.setEndPoints=function(t,e){r.Z.defined("start",t),r.Z.defined("end",e),p(this,t,e,this._ellipsoid)},y.prototype.interpolateUsingFraction=function(t,e){return this.interpolateUsingSurfaceDistance(t*this._distance,e)},y.prototype.interpolateUsingSurfaceDistance=function(t,e){if(r.Z.typeOf.number("distance",t),!(0,a.Z)(this._distance)||0===this._distance)throw new u.Z("EllipsoidRhumbLine must have distinct start and end set.");return m(this._start,this._heading,t,this._ellipsoid.maximumRadius,this._ellipticity,e)},y.prototype.findIntersectionWithLongitude=function(t,e){if(r.Z.typeOf.number("intersectionLongitude",t),!(0,a.Z)(this._distance)||0===this._distance)throw new u.Z("EllipsoidRhumbLine must have distinct start and end set.");const n=this._ellipticity,i=this._heading,s=Math.abs(i),c=this._start;if(t=l.Z.negativePiToPi(t),l.Z.equalsEpsilon(Math.abs(t),Math.PI,l.Z.EPSILON14)&&(t=l.Z.sign(c.longitude)*Math.PI),(0,a.Z)(e)||(e=new o.Z),Math.abs(l.Z.PI_OVER_TWO-s)<=l.Z.EPSILON8)return e.longitude=t,e.latitude=c.latitude,e.height=0,e;if(l.Z.equalsEpsilon(Math.abs(l.Z.PI_OVER_TWO-s),l.Z.PI_OVER_TWO,l.Z.EPSILON8)){if(l.Z.equalsEpsilon(t,c.longitude,l.Z.EPSILON12))return;return e.longitude=t,e.latitude=l.Z.PI_OVER_TWO*l.Z.sign(l.Z.PI_OVER_TWO-i),e.height=0,e}const Z=c.latitude,d=n*Math.sin(Z),h=Math.tan(.5*(l.Z.PI_OVER_TWO+Z))*Math.exp((t-c.longitude)/Math.tan(i)),f=(1+d)/(1-d);let p,m=c.latitude;do{p=m;const t=n*Math.sin(p),e=(1+t)/(1-t);m=2*Math.atan(h*Math.pow(e/f,n/2))-l.Z.PI_OVER_TWO}while(!l.Z.equalsEpsilon(m,p,l.Z.EPSILON12));return e.longitude=t,e.latitude=m,e.height=0,e},y.prototype.findIntersectionWithLatitude=function(t,e){if(r.Z.typeOf.number("intersectionLatitude",t),!(0,a.Z)(this._distance)||0===this._distance)throw new u.Z("EllipsoidRhumbLine must have distinct start and end set.");const n=this._ellipticity,i=this._heading,s=this._start;if(l.Z.equalsEpsilon(Math.abs(i),l.Z.PI_OVER_TWO,l.Z.EPSILON8))return;const c=d(n,s.latitude),Z=d(n,t),h=Math.tan(i)*(Z-c),f=l.Z.negativePiToPi(s.longitude+h);return(0,a.Z)(e)?(e.longitude=f,e.latitude=t,e.height=0,e):new o.Z(f,t,0)};const g=y},60794:(t,e,n)=>{n.d(e,{Z:()=>v});var i=n(22099),o=n(59015),r=n(93517),s=n(90868),a=n(17497),u=n(88779),c=n(54485),l=n(20176),Z=n(99996),d=n(14090),h=n(71118),f=n(30445),p=n(43262),m=n(7004);const y=new s.Z;function g(t,e){if(a.Z.defined("origin",t),t=(e=(0,u.Z)(e,Z.Z.WGS84)).scaleToGeodeticSurface(t),!(0,c.Z)(t))throw new l.Z("origin must not be at the center of the ellipsoid.");const n=m.Z.eastNorthUpToFixedFrame(t,e);this._ellipsoid=e,this._origin=t,this._xAxis=r.Z.fromCartesian4(h.Z.getColumn(n,0,y)),this._yAxis=r.Z.fromCartesian4(h.Z.getColumn(n,1,y));const i=r.Z.fromCartesian4(h.Z.getColumn(n,2,y));this._plane=f.Z.fromPointNormal(t,i)}Object.defineProperties(g.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},origin:{get:function(){return this._origin}},plane:{get:function(){return this._plane}},xAxis:{get:function(){return this._xAxis}},yAxis:{get:function(){return this._yAxis}},zAxis:{get:function(){return this._plane.normal}}});const _=new i.Z;g.fromPoints=function(t,e){a.Z.defined("cartesians",t);return new g(i.Z.fromPoints(t,_).center,e)};const w=new p.Z,b=new r.Z;g.prototype.projectPointOntoPlane=function(t,e){a.Z.defined("cartesian",t);const n=w;n.origin=t,r.Z.normalize(t,n.direction);let i=d.Z.rayPlane(n,this._plane,b);if((0,c.Z)(i)||(r.Z.negate(n.direction,n.direction),i=d.Z.rayPlane(n,this._plane,b)),(0,c.Z)(i)){const t=r.Z.subtract(i,this._origin,i),n=r.Z.dot(this._xAxis,t),s=r.Z.dot(this._yAxis,t);return(0,c.Z)(e)?(e.x=n,e.y=s,e):new o.Z(n,s)}},g.prototype.projectPointsOntoPlane=function(t,e){a.Z.defined("cartesians",t),(0,c.Z)(e)||(e=[]);let n=0;const i=t.length;for(let o=0;o<i;o++){const i=this.projectPointOntoPlane(t[o],e[n]);(0,c.Z)(i)&&(e[n]=i,n++)}return e.length=n,e},g.prototype.projectPointToNearestOnPlane=function(t,e){a.Z.defined("cartesian",t),(0,c.Z)(e)||(e=new o.Z);const n=w;n.origin=t,r.Z.clone(this._plane.normal,n.direction);let i=d.Z.rayPlane(n,this._plane,b);(0,c.Z)(i)||(r.Z.negate(n.direction,n.direction),i=d.Z.rayPlane(n,this._plane,b));const s=r.Z.subtract(i,this._origin,i),u=r.Z.dot(this._xAxis,s),l=r.Z.dot(this._yAxis,s);return e.x=u,e.y=l,e},g.prototype.projectPointsToNearestOnPlane=function(t,e){a.Z.defined("cartesians",t),(0,c.Z)(e)||(e=[]);const n=t.length;e.length=n;for(let i=0;i<n;i++)e[i]=this.projectPointToNearestOnPlane(t[i],e[i]);return e};const A=new r.Z;g.prototype.projectPointOntoEllipsoid=function(t,e){a.Z.defined("cartesian",t),(0,c.Z)(e)||(e=new r.Z);const n=this._ellipsoid,i=this._origin,o=this._xAxis,s=this._yAxis,u=A;return r.Z.multiplyByScalar(o,t.x,u),e=r.Z.add(i,u,e),r.Z.multiplyByScalar(s,t.y,u),r.Z.add(e,u,e),n.scaleToGeocentricSurface(e,e),e},g.prototype.projectPointsOntoEllipsoid=function(t,e){a.Z.defined("cartesians",t);const n=t.length;(0,c.Z)(e)?e.length=n:e=new Array(n);for(let i=0;i<n;++i)e[i]=this.projectPointOntoEllipsoid(t[i],e[i]);return e};const v=g},19759:(t,e,n)=>{n.d(e,{Z:()=>Z});var i=n(88779),o=n(54485),r=n(99996),s=n(92893),a=n(96507),u=n(30646),c=n(87264);function l(t){t=(0,i.Z)(t,i.Z.EMPTY_OBJECT),this._tilingScheme=t.tilingScheme,(0,o.Z)(this._tilingScheme)||(this._tilingScheme=new a.Z({ellipsoid:(0,i.Z)(t.ellipsoid,r.Z.WGS84)})),this._levelZeroMaximumGeometricError=c.Z.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid,64,this._tilingScheme.getNumberOfXTilesAtLevel(0)),this._errorEvent=new s.Z,this._readyPromise=Promise.resolve(!0)}Object.defineProperties(l.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){}},tilingScheme:{get:function(){return this._tilingScheme}},ready:{get:function(){return!0}},readyPromise:{get:function(){return this._readyPromise}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){}}}),l.prototype.requestTileGeometry=function(t,e,n,i){return Promise.resolve(new u.Z({buffer:new Uint8Array(256),width:16,height:16}))},l.prototype.getLevelMaximumGeometricError=function(t){return this._levelZeroMaximumGeometricError/(1<<t)},l.prototype.getTileDataAvailable=function(t,e,n){},l.prototype.loadTileDataAvailability=function(t,e,n){};const Z=l},83674:(t,e,n)=>{n.d(e,{Z:()=>T});var i=n(52351),o=n(93517),r=n(17497),s=n(88779),a=n(54485),u=n(99996),c=n(34152);function l(t,e){r.Z.typeOf.object("ellipsoid",t),this._ellipsoid=t,this._cameraPosition=new o.Z,this._cameraPositionInScaledSpace=new o.Z,this._distanceToLimbInScaledSpaceSquared=0,(0,a.Z)(e)&&(this.cameraPosition=e)}Object.defineProperties(l.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},cameraPosition:{get:function(){return this._cameraPosition},set:function(t){const e=this._ellipsoid.transformPositionToScaledSpace(t,this._cameraPositionInScaledSpace),n=o.Z.magnitudeSquared(e)-1;o.Z.clone(t,this._cameraPosition),this._cameraPositionInScaledSpace=e,this._distanceToLimbInScaledSpaceSquared=n}}});const Z=new o.Z;l.prototype.isPointVisible=function(t){return w(this._ellipsoid.transformPositionToScaledSpace(t,Z),this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)},l.prototype.isScaledSpacePointVisible=function(t){return w(t,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};const d=new o.Z;l.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid=function(t,e){const n=this._ellipsoid;let i,o;return(0,a.Z)(e)&&e<0&&n.minimumRadius>-e?(o=d,o.x=this._cameraPosition.x/(n.radii.x+e),o.y=this._cameraPosition.y/(n.radii.y+e),o.z=this._cameraPosition.z/(n.radii.z+e),i=o.x*o.x+o.y*o.y+o.z*o.z-1):(o=this._cameraPositionInScaledSpace,i=this._distanceToLimbInScaledSpaceSquared),w(t,o,i)},l.prototype.computeHorizonCullingPoint=function(t,e,n){return y(this._ellipsoid,t,e,n)};const h=u.Z.clone(u.Z.UNIT_SPHERE);l.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid=function(t,e,n,i){return y(m(this._ellipsoid,n,h),t,e,i)},l.prototype.computeHorizonCullingPointFromVertices=function(t,e,n,i,o){return _(this._ellipsoid,t,e,n,i,o)},l.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid=function(t,e,n,i,o,r){return _(m(this._ellipsoid,o,h),t,e,n,i,r)};const f=[];l.prototype.computeHorizonCullingPointFromRectangle=function(t,e,n){r.Z.typeOf.object("rectangle",t);const s=c.Z.subsample(t,e,0,f),a=i.Z.fromPoints(s);if(!(o.Z.magnitude(a.center)<.1*e.minimumRadius))return this.computeHorizonCullingPoint(a.center,s,n)};const p=new o.Z;function m(t,e,n){if((0,a.Z)(e)&&e<0&&t.minimumRadius>-e){const i=o.Z.fromElements(t.radii.x+e,t.radii.y+e,t.radii.z+e,p);t=u.Z.fromCartesian3(i,n)}return t}function y(t,e,n,i){r.Z.typeOf.object("directionToPoint",e),r.Z.defined("positions",n),(0,a.Z)(i)||(i=new o.Z);const s=P(t,e);let u=0;for(let e=0,i=n.length;e<i;++e){const i=v(t,n[e],s);if(i<0)return;u=Math.max(u,i)}return x(s,u,i)}const g=new o.Z;function _(t,e,n,i,u,c){r.Z.typeOf.object("directionToPoint",e),r.Z.defined("vertices",n),r.Z.typeOf.number("stride",i),(0,a.Z)(c)||(c=new o.Z),i=(0,s.Z)(i,3),u=(0,s.Z)(u,o.Z.ZERO);const l=P(t,e);let Z=0;for(let e=0,o=n.length;e<o;e+=i){g.x=n[e]+u.x,g.y=n[e+1]+u.y,g.z=n[e+2]+u.z;const i=v(t,g,l);if(i<0)return;Z=Math.max(Z,i)}return x(l,Z,c)}function w(t,e,n){const i=e,r=n,s=o.Z.subtract(t,i,Z),a=-o.Z.dot(s,i);return!(r<0?a>0:a>r&&a*a/o.Z.magnitudeSquared(s)>r)}const b=new o.Z,A=new o.Z;function v(t,e,n){const i=t.transformPositionToScaledSpace(e,b);let r=o.Z.magnitudeSquared(i),s=Math.sqrt(r);const a=o.Z.divideByScalar(i,s,A);r=Math.max(1,r),s=Math.max(1,s);const u=1/s;return 1/(o.Z.dot(a,n)*u-o.Z.magnitude(o.Z.cross(a,n,a))*(Math.sqrt(r-1)*u))}function x(t,e,n){if(!(e<=0||e===1/0||e!=e))return o.Z.multiplyByScalar(t,e,n)}const O=new o.Z;function P(t,e){return o.Z.equals(e,o.Z.ZERO)?e:(t.transformPositionToScaledSpace(e,O),o.Z.normalize(O,O))}const T=l},88173:(t,e,n)=>{n.d(e,{Z:()=>c});var i=n(93517),o=n(17497),r=n(54485);function s(){this.high=i.Z.clone(i.Z.ZERO),this.low=i.Z.clone(i.Z.ZERO)}s.encode=function(t,e){let n;return o.Z.typeOf.number("value",t),(0,r.Z)(e)||(e={high:0,low:0}),t>=0?(n=65536*Math.floor(t/65536),e.high=n,e.low=t-n):(n=65536*Math.floor(-t/65536),e.high=-n,e.low=t+n),e};const a={high:0,low:0};s.fromCartesian=function(t,e){o.Z.typeOf.object("cartesian",t),(0,r.Z)(e)||(e=new s);const n=e.high,i=e.low;return s.encode(t.x,a),n.x=a.high,i.x=a.low,s.encode(t.y,a),n.y=a.high,i.y=a.low,s.encode(t.z,a),n.z=a.high,i.z=a.low,e};const u=new s;s.writeElements=function(t,e,n){o.Z.defined("cartesianArray",e),o.Z.typeOf.number("index",n),o.Z.typeOf.number.greaterThanOrEquals("index",n,0),s.fromCartesian(t,u);const i=u.high,r=u.low;e[n]=i.x,e[n+1]=i.y,e[n+2]=i.z,e[n+3]=r.x,e[n+4]=r.y,e[n+5]=r.z};const c=s},92893:(t,e,n)=>{n.d(e,{Z:()=>a});var i=n(17497),o=n(54485);function r(){this._listeners=[],this._scopes=[],this._toRemove=[],this._insideRaiseEvent=!1}function s(t,e){return e-t}Object.defineProperties(r.prototype,{numberOfListeners:{get:function(){return this._listeners.length-this._toRemove.length}}}),r.prototype.addEventListener=function(t,e){i.Z.typeOf.func("listener",t),this._listeners.push(t),this._scopes.push(e);const n=this;return function(){n.removeEventListener(t,e)}},r.prototype.removeEventListener=function(t,e){i.Z.typeOf.func("listener",t);const n=this._listeners,o=this._scopes;let r=-1;for(let i=0;i<n.length;i++)if(n[i]===t&&o[i]===e){r=i;break}return-1!==r&&(this._insideRaiseEvent?(this._toRemove.push(r),n[r]=void 0,o[r]=void 0):(n.splice(r,1),o.splice(r,1)),!0)},r.prototype.raiseEvent=function(){let t;this._insideRaiseEvent=!0;const e=this._listeners,n=this._scopes;let i=e.length;for(t=0;t<i;t++){const i=e[t];(0,o.Z)(i)&&e[t].apply(n[t],arguments)}const r=this._toRemove;if(i=r.length,i>0){for(r.sort(s),t=0;t<i;t++){const i=r[t];e.splice(i,1),n.splice(i,1)}r.length=0}this._insideRaiseEvent=!1};const a=r},18091:(t,e,n)=>{n.d(e,{Z:()=>s});var i=n(54485),o=n(20176);function r(){this._removalFunctions=[]}r.prototype.add=function(t,e,n){if(!(0,i.Z)(t))throw new o.Z("event is required");const r=t.addEventListener(e,n);this._removalFunctions.push(r);const s=this;return function(){r();const t=s._removalFunctions;t.splice(t.indexOf(r),1)}},r.prototype.removeAll=function(){const t=this._removalFunctions;for(let e=0,n=t.length;e<n;++e)t[e]();t.length=0};const s=r},86066:(t,e,n)=>{n.d(e,{Z:()=>i});const i={enableModelExperimental:!1}},54219:(t,e,n)=>{n.d(e,{Z:()=>i});const i=Object.freeze({NONE:0,HOLD:1,EXTRAPOLATE:2})},74834:(t,e,n)=>{n.d(e,{Z:()=>z});var i=n(88779),o=n(58587),r=n(54485),s=n(20176),a=n(83864);let u,c,l,Z,d,h,f,p,m,y,g,_,w,b,A,v,x,O;function P(t){const e=t.split(".");for(let t=0,n=e.length;t<n;++t)e[t]=parseInt(e[t],10);return e}function T(){if(!(0,r.Z)(c)&&(c=!1,!N())){const t=/ Chrome\/([\.0-9]+)/.exec(u.userAgent);null!==t&&(c=!0,l=P(t[1]))}return c}function E(){if(!(0,r.Z)(Z)&&(Z=!1,!T()&&!N()&&/ Safari\/[\.0-9]+/.test(u.userAgent))){const t=/ Version\/([\.0-9]+)/.exec(u.userAgent);null!==t&&(Z=!0,d=P(t[1]))}return Z}function S(){if(!(0,r.Z)(h)){h=!1;const t=/ AppleWebKit\/([\.0-9]+)(\+?)/.exec(u.userAgent);null!==t&&(h=!0,f=P(t[1]),f.isNightly=!!t[2])}return h}function I(){if(!(0,r.Z)(p)){let t;p=!1,"Microsoft Internet Explorer"===u.appName?(t=/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(u.userAgent),null!==t&&(p=!0,m=P(t[1]))):"Netscape"===u.appName&&(t=/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(u.userAgent),null!==t&&(p=!0,m=P(t[1])))}return p}function N(){if(!(0,r.Z)(y)){y=!1;const t=/ Edge\/([\.0-9]+)/.exec(u.userAgent);null!==t&&(y=!0,g=P(t[1]))}return y}function M(){if(!(0,r.Z)(_)){_=!1;const t=/Firefox\/([\.0-9]+)/.exec(u.userAgent);null!==t&&(_=!0,w=P(t[1]))}return _}function L(){if(!(0,r.Z)(O)){const t=document.createElement("canvas");t.setAttribute("style","image-rendering: -moz-crisp-edges;image-rendering: pixelated;");const e=t.style.imageRendering;O=(0,r.Z)(e)&&""!==e,O&&(x=e)}return O}function R(){if(!R.initialized)throw new s.Z("You must call FeatureDetection.supportsWebP.initialize and wait for the promise to resolve before calling FeatureDetection.supportsWebP");return R._result}u="undefined"!=typeof navigator?navigator:{},R._promise=void 0,R._result=void 0,R.initialize=function(){if((0,r.Z)(R._promise))return R._promise;const t=(0,o.Z)();if(R._promise=t.promise,N())return R._result=!1,t.resolve(R._result),t.promise;const e=new Image;return e.onload=function(){R._result=e.width>0&&e.height>0,t.resolve(R._result)},e.onerror=function(){R._result=!1,t.resolve(R._result)},e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.promise},Object.defineProperties(R,{initialized:{get:function(){return(0,r.Z)(R._result)}}});const C=[];"undefined"!=typeof ArrayBuffer&&(C.push(Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array),"undefined"!=typeof Uint8ClampedArray&&C.push(Uint8ClampedArray),"undefined"!=typeof Uint8ClampedArray&&C.push(Uint8ClampedArray),"undefined"!=typeof BigInt64Array&&C.push(BigInt64Array),"undefined"!=typeof BigUint64Array&&C.push(BigUint64Array));const k={isChrome:T,chromeVersion:function(){return T()&&l},isSafari:E,safariVersion:function(){return E()&&d},isWebkit:S,webkitVersion:function(){return S()&&f},isInternetExplorer:I,internetExplorerVersion:function(){return I()&&m},isEdge:N,edgeVersion:function(){return N()&&g},isFirefox:M,firefoxVersion:function(){return M()&&w},isWindows:function(){return(0,r.Z)(b)||(b=/Windows/i.test(u.appVersion)),b},isIPadOrIOS:function(){return(0,r.Z)(A)||(A="iPhone"===navigator.platform||"iPod"===navigator.platform||"iPad"===navigator.platform),A},hardwareConcurrency:(0,i.Z)(u.hardwareConcurrency,3),supportsPointerEvents:function(){return(0,r.Z)(v)||(v=!M()&&"undefined"!=typeof PointerEvent&&(!(0,r.Z)(u.pointerEnabled)||u.pointerEnabled)),v},supportsImageRenderingPixelated:L,supportsWebP:R,imageRenderingValue:function(){return L()?x:void 0},typedArrayTypes:C,supportsBasis:function(t){return k.supportsWebAssembly()&&t.context.supportsBasis},supportsFullscreen:function(){return a.Z.supportsFullscreen()},supportsTypedArrays:function(){return"undefined"!=typeof ArrayBuffer},supportsBigInt64Array:function(){return"undefined"!=typeof BigInt64Array},supportsBigUint64Array:function(){return"undefined"!=typeof BigUint64Array},supportsBigInt:function(){return"undefined"!=typeof BigInt},supportsWebWorkers:function(){return"undefined"!=typeof Worker},supportsWebAssembly:function(){return"undefined"!=typeof WebAssembly}},z=k},30796:(t,e,n)=>{n.d(e,{Z:()=>F});var i=n(52351),o=n(93517),r=n(90868),s=n(17497),a=n(44990),u=n(88779),c=n(54485),l=n(97845),Z=n(94061),d=n(77683),h=n(39109),f=n(71118),p=n(74408),m=n(84929),y=n(84473),g=n(20291),_=n(25225);function w(t){s.Z.typeOf.object("options",t),s.Z.typeOf.object("options.frustum",t.frustum),s.Z.typeOf.object("options.origin",t.origin),s.Z.typeOf.object("options.orientation",t.orientation);const e=t.frustum,n=t.orientation,i=t.origin,r=(0,u.Z)(t.vertexFormat,_.Z.DEFAULT),a=(0,u.Z)(t._drawNearPlane,!0);let c,l;e instanceof m.Z?(c=0,l=m.Z.packedLength):e instanceof p.Z&&(c=1,l=p.Z.packedLength),this._frustumType=c,this._frustum=e.clone(),this._origin=o.Z.clone(i),this._orientation=g.Z.clone(n),this._drawNearPlane=a,this._vertexFormat=r,this._workerName="createFrustumGeometry",this.packedLength=2+l+o.Z.packedLength+g.Z.packedLength+_.Z.packedLength}w.pack=function(t,e,n){s.Z.typeOf.object("value",t),s.Z.defined("array",e),n=(0,u.Z)(n,0);const i=t._frustumType,r=t._frustum;return e[n++]=i,0===i?(m.Z.pack(r,e,n),n+=m.Z.packedLength):(p.Z.pack(r,e,n),n+=p.Z.packedLength),o.Z.pack(t._origin,e,n),n+=o.Z.packedLength,g.Z.pack(t._orientation,e,n),n+=g.Z.packedLength,_.Z.pack(t._vertexFormat,e,n),e[n+=_.Z.packedLength]=t._drawNearPlane?1:0,e};const b=new m.Z,A=new p.Z,v=new g.Z,x=new o.Z,O=new _.Z;function P(t,e,n,i,o,r,s,a){const u=t/3*2;for(let o=0;o<4;++o)(0,c.Z)(e)&&(e[t]=r.x,e[t+1]=r.y,e[t+2]=r.z),(0,c.Z)(n)&&(n[t]=s.x,n[t+1]=s.y,n[t+2]=s.z),(0,c.Z)(i)&&(i[t]=a.x,i[t+1]=a.y,i[t+2]=a.z),t+=3;o[u]=0,o[u+1]=0,o[u+2]=1,o[u+3]=0,o[u+4]=1,o[u+5]=1,o[u+6]=0,o[u+7]=1}w.unpack=function(t,e,n){s.Z.defined("array",t),e=(0,u.Z)(e,0);const i=t[e++];let r;0===i?(r=m.Z.unpack(t,e,b),e+=m.Z.packedLength):(r=p.Z.unpack(t,e,A),e+=p.Z.packedLength);const a=o.Z.unpack(t,e,x);e+=o.Z.packedLength;const l=g.Z.unpack(t,e,v);e+=g.Z.packedLength;const Z=_.Z.unpack(t,e,O),d=1===t[e+=_.Z.packedLength];if(!(0,c.Z)(n))return new w({frustum:r,origin:a,orientation:l,vertexFormat:Z,_drawNearPlane:d});const h=i===n._frustumType?n._frustum:void 0;return n._frustum=r.clone(h),n._frustumType=i,n._origin=o.Z.clone(a,n._origin),n._orientation=g.Z.clone(l,n._orientation),n._vertexFormat=_.Z.clone(Z,n._vertexFormat),n._drawNearPlane=d,n};const T=new h.Z,E=new f.Z,S=new f.Z,I=new o.Z,N=new o.Z,M=new o.Z,L=new o.Z,R=new o.Z,C=new o.Z,k=new Array(3),z=new Array(4);z[0]=new r.Z(-1,-1,1,1),z[1]=new r.Z(1,-1,1,1),z[2]=new r.Z(1,1,1,1),z[3]=new r.Z(-1,1,1,1);const D=new Array(4);for(let t=0;t<4;++t)D[t]=new r.Z;w._computeNearFarPlanes=function(t,e,n,i,s,a,l,Z){const d=h.Z.fromQuaternion(e,T);let p=(0,u.Z)(a,I),m=(0,u.Z)(l,N),y=(0,u.Z)(Z,M);p=h.Z.getColumn(d,0,p),m=h.Z.getColumn(d,1,m),y=h.Z.getColumn(d,2,y),o.Z.normalize(p,p),o.Z.normalize(m,m),o.Z.normalize(y,y),o.Z.negate(p,p);const g=f.Z.computeView(t,y,m,p,E);let _,w;if(0===n){const t=i.projectionMatrix,e=f.Z.multiply(t,g,S);w=f.Z.inverse(e,S)}else _=f.Z.inverseTransformation(g,S);(0,c.Z)(w)?(k[0]=i.near,k[1]=i.far):(k[0]=0,k[1]=i.near,k[2]=i.far);for(let e=0;e<2;++e)for(let n=0;n<4;++n){let a=r.Z.clone(z[n],D[n]);if((0,c.Z)(w)){a=f.Z.multiplyByVector(w,a,a);const n=1/a.w;o.Z.multiplyByScalar(a,n,a),o.Z.subtract(a,t,a),o.Z.normalize(a,a);const i=o.Z.dot(y,a);o.Z.multiplyByScalar(a,k[e]/i,a),o.Z.add(a,t,a)}else{(0,c.Z)(i._offCenterFrustum)&&(i=i._offCenterFrustum);const t=k[e],n=k[e+1];a.x=.5*(a.x*(i.right-i.left)+i.left+i.right),a.y=.5*(a.y*(i.top-i.bottom)+i.bottom+i.top),a.z=.5*(a.z*(t-n)-t-n),a.w=1,f.Z.multiplyByVector(_,a,a)}s[12*e+3*n]=a.x,s[12*e+3*n+1]=a.y,s[12*e+3*n+2]=a.z}},w.createGeometry=function(t){const e=t._frustumType,n=t._frustum,r=t._origin,s=t._orientation,u=t._drawNearPlane,h=t._vertexFormat,f=u?6:5;let p=new Float64Array(72);w._computeNearFarPlanes(r,s,e,n,p);let m=24;p[m]=p[12],p[m+1]=p[13],p[m+2]=p[14],p[m+3]=p[0],p[m+4]=p[1],p[m+5]=p[2],p[m+6]=p[9],p[m+7]=p[10],p[m+8]=p[11],p[m+9]=p[21],p[m+10]=p[22],p[m+11]=p[23],m+=12,p[m]=p[15],p[m+1]=p[16],p[m+2]=p[17],p[m+3]=p[3],p[m+4]=p[4],p[m+5]=p[5],p[m+6]=p[0],p[m+7]=p[1],p[m+8]=p[2],p[m+9]=p[12],p[m+10]=p[13],p[m+11]=p[14],m+=12,p[m]=p[3],p[m+1]=p[4],p[m+2]=p[5],p[m+3]=p[15],p[m+4]=p[16],p[m+5]=p[17],p[m+6]=p[18],p[m+7]=p[19],p[m+8]=p[20],p[m+9]=p[6],p[m+10]=p[7],p[m+11]=p[8],m+=12,p[m]=p[6],p[m+1]=p[7],p[m+2]=p[8],p[m+3]=p[18],p[m+4]=p[19],p[m+5]=p[20],p[m+6]=p[21],p[m+7]=p[22],p[m+8]=p[23],p[m+9]=p[9],p[m+10]=p[10],p[m+11]=p[11],u||(p=p.subarray(12));const g=new d.Z({position:new Z.Z({componentDatatype:a.Z.DOUBLE,componentsPerAttribute:3,values:p})});if((0,c.Z)(h.normal)||(0,c.Z)(h.tangent)||(0,c.Z)(h.bitangent)||(0,c.Z)(h.st)){const t=(0,c.Z)(h.normal)?new Float32Array(12*f):void 0,e=(0,c.Z)(h.tangent)?new Float32Array(12*f):void 0,n=(0,c.Z)(h.bitangent)?new Float32Array(12*f):void 0,i=(0,c.Z)(h.st)?new Float32Array(8*f):void 0,r=I,s=N,l=M,d=o.Z.negate(r,L),p=o.Z.negate(s,R),y=o.Z.negate(l,C);m=0,u&&(P(m,t,e,n,i,y,r,s),m+=12),P(m,t,e,n,i,l,d,s),m+=12,P(m,t,e,n,i,d,y,s),m+=12,P(m,t,e,n,i,p,y,d),m+=12,P(m,t,e,n,i,r,l,s),m+=12,P(m,t,e,n,i,s,l,d),(0,c.Z)(t)&&(g.normal=new Z.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:3,values:t})),(0,c.Z)(e)&&(g.tangent=new Z.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:3,values:e})),(0,c.Z)(n)&&(g.bitangent=new Z.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:3,values:n})),(0,c.Z)(i)&&(g.st=new Z.Z({componentDatatype:a.Z.FLOAT,componentsPerAttribute:2,values:i}))}const _=new Uint16Array(6*f);for(let t=0;t<f;++t){const e=6*t,n=4*t;_[e]=n,_[e+1]=n+1,_[e+2]=n+2,_[e+3]=n,_[e+4]=n+2,_[e+5]=n+3}return new l.Z({attributes:g,indices:_,primitiveType:y.Z.TRIANGLES,boundingSphere:i.Z.fromVertices(p)})};const F=w},83211:(t,e,n)=>{n.d(e,{Z:()=>A});var i=n(52351),o=n(93517),r=n(17497),s=n(44990),a=n(88779),u=n(54485),c=n(30796),l=n(97845),Z=n(94061),d=n(77683),h=n(74408),f=n(84929),p=n(84473),m=n(20291);function y(t){r.Z.typeOf.object("options",t),r.Z.typeOf.object("options.frustum",t.frustum),r.Z.typeOf.object("options.origin",t.origin),r.Z.typeOf.object("options.orientation",t.orientation);const e=t.frustum,n=t.orientation,i=t.origin,s=(0,a.Z)(t._drawNearPlane,!0);let u,c;e instanceof f.Z?(u=0,c=f.Z.packedLength):e instanceof h.Z&&(u=1,c=h.Z.packedLength),this._frustumType=u,this._frustum=e.clone(),this._origin=o.Z.clone(i),this._orientation=m.Z.clone(n),this._drawNearPlane=s,this._workerName="createFrustumOutlineGeometry",this.packedLength=2+c+o.Z.packedLength+m.Z.packedLength}y.pack=function(t,e,n){r.Z.typeOf.object("value",t),r.Z.defined("array",e),n=(0,a.Z)(n,0);const i=t._frustumType,s=t._frustum;return e[n++]=i,0===i?(f.Z.pack(s,e,n),n+=f.Z.packedLength):(h.Z.pack(s,e,n),n+=h.Z.packedLength),o.Z.pack(t._origin,e,n),n+=o.Z.packedLength,m.Z.pack(t._orientation,e,n),e[n+=m.Z.packedLength]=t._drawNearPlane?1:0,e};const g=new f.Z,_=new h.Z,w=new m.Z,b=new o.Z;y.unpack=function(t,e,n){r.Z.defined("array",t),e=(0,a.Z)(e,0);const i=t[e++];let s;0===i?(s=f.Z.unpack(t,e,g),e+=f.Z.packedLength):(s=h.Z.unpack(t,e,_),e+=h.Z.packedLength);const c=o.Z.unpack(t,e,b);e+=o.Z.packedLength;const l=m.Z.unpack(t,e,w),Z=1===t[e+=m.Z.packedLength];if(!(0,u.Z)(n))return new y({frustum:s,origin:c,orientation:l,_drawNearPlane:Z});const d=i===n._frustumType?n._frustum:void 0;return n._frustum=s.clone(d),n._frustumType=i,n._origin=o.Z.clone(c,n._origin),n._orientation=m.Z.clone(l,n._orientation),n._drawNearPlane=Z,n},y.createGeometry=function(t){const e=t._frustumType,n=t._frustum,o=t._origin,r=t._orientation,a=t._drawNearPlane,u=new Float64Array(24);c.Z._computeNearFarPlanes(o,r,e,n,u);const h=new d.Z({position:new Z.Z({componentDatatype:s.Z.DOUBLE,componentsPerAttribute:3,values:u})});let f,m;const y=a?2:1,g=new Uint16Array(8*(y+1));let _=a?0:1;for(;_<2;++_)f=a?8*_:0,m=4*_,g[f]=m,g[f+1]=m+1,g[f+2]=m+1,g[f+3]=m+2,g[f+4]=m+2,g[f+5]=m+3,g[f+6]=m+3,g[f+7]=m;for(_=0;_<2;++_)f=8*(y+_),m=4*_,g[f]=m,g[f+1]=m+4,g[f+2]=m+1,g[f+3]=m+5,g[f+4]=m+2,g[f+5]=m+6,g[f+6]=m+3,g[f+7]=m+7;return new l.Z({attributes:h,indices:g,primitiveType:p.Z.LINES,boundingSphere:i.Z.fromVertices(u)})};const A=y},83864:(t,e,n)=>{n.d(e,{Z:()=>a});var i=n(54485);let o;const r={requestFullscreen:void 0,exitFullscreen:void 0,fullscreenEnabled:void 0,fullscreenElement:void 0,fullscreenchange:void 0,fullscreenerror:void 0},s={};Object.defineProperties(s,{element:{get:function(){if(s.supportsFullscreen())return document[r.fullscreenElement]}},changeEventName:{get:function(){if(s.supportsFullscreen())return r.fullscreenchange}},errorEventName:{get:function(){if(s.supportsFullscreen())return r.fullscreenerror}},enabled:{get:function(){if(s.supportsFullscreen())return document[r.fullscreenEnabled]}},fullscreen:{get:function(){if(s.supportsFullscreen())return null!==s.element}}}),s.supportsFullscreen=function(){if((0,i.Z)(o))return o;o=!1;const t=document.body;if("function"==typeof t.requestFullscreen)return r.requestFullscreen="requestFullscreen",r.exitFullscreen="exitFullscreen",r.fullscreenEnabled="fullscreenEnabled",r.fullscreenElement="fullscreenElement",r.fullscreenchange="fullscreenchange",r.fullscreenerror="fullscreenerror",o=!0,o;const e=["webkit","moz","o","ms","khtml"];let n;for(let i=0,s=e.length;i<s;++i){const s=e[i];n=`${s}RequestFullscreen`,"function"==typeof t[n]?(r.requestFullscreen=n,o=!0):(n=`${s}RequestFullScreen`,"function"==typeof t[n]&&(r.requestFullscreen=n,o=!0)),n=`${s}ExitFullscreen`,"function"==typeof document[n]?r.exitFullscreen=n:(n=`${s}CancelFullScreen`,"function"==typeof document[n]&&(r.exitFullscreen=n)),n=`${s}FullscreenEnabled`,void 0!==document[n]?r.fullscreenEnabled=n:(n=`${s}FullScreenEnabled`,void 0!==document[n]&&(r.fullscreenEnabled=n)),n=`${s}FullscreenElement`,void 0!==document[n]?r.fullscreenElement=n:(n=`${s}FullScreenElement`,void 0!==document[n]&&(r.fullscreenElement=n)),n=`${s}fullscreenchange`,void 0!==document[`on${n}`]&&("ms"===s&&(n="MSFullscreenChange"),r.fullscreenchange=n),n=`${s}fullscreenerror`,void 0!==document[`on${n}`]&&("ms"===s&&(n="MSFullscreenError"),r.fullscreenerror=n)}return o},s.requestFullscreen=function(t,e){s.supportsFullscreen()&&t[r.requestFullscreen]({vrDisplay:e})},s.exitFullscreen=function(){s.supportsFullscreen()&&document[r.exitFullscreen]()},s._names=r;const a=s},60178:(t,e,n)=>{n.d(e,{Z:()=>i});const i=Object.freeze({SEARCH:0,AUTOCOMPLETE:1})},61100:(t,e,n)=>{n.d(e,{Z:()=>r});var i=n(20176);function o(){}o.prototype.geocode=i.Z.throwInstantiationError;const r=o},64729:(t,e,n)=>{n.d(e,{Z:()=>l});var i=n(93517),o=n(66866),r=n(88779),s=n(54485),a=n(20176),u=n(99996);function c(t){this._ellipsoid=(0,r.Z)(t,u.Z.WGS84),this._semimajorAxis=this._ellipsoid.maximumRadius,this._oneOverSemimajorAxis=1/this._semimajorAxis}Object.defineProperties(c.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}}),c.prototype.project=function(t,e){const n=this._semimajorAxis,o=t.longitude*n,r=t.latitude*n,a=t.height;return(0,s.Z)(e)?(e.x=o,e.y=r,e.z=a,e):new i.Z(o,r,a)},c.prototype.unproject=function(t,e){if(!(0,s.Z)(t))throw new a.Z("cartesian is required");const n=this._oneOverSemimajorAxis,i=t.x*n,r=t.y*n,u=t.z;return(0,s.Z)(e)?(e.longitude=i,e.latitude=r,e.height=u,e):new o.Z(i,r,u)};const l=c},96507:(t,e,n)=>{n.d(e,{Z:()=>d});var i=n(59015),o=n(17497),r=n(88779),s=n(54485),a=n(99996),u=n(64729),c=n(22874),l=n(34152);function Z(t){t=(0,r.Z)(t,r.Z.EMPTY_OBJECT),this._ellipsoid=(0,r.Z)(t.ellipsoid,a.Z.WGS84),this._rectangle=(0,r.Z)(t.rectangle,l.Z.MAX_VALUE),this._projection=new u.Z(this._ellipsoid),this._numberOfLevelZeroTilesX=(0,r.Z)(t.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=(0,r.Z)(t.numberOfLevelZeroTilesY,1)}Object.defineProperties(Z.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),Z.prototype.getNumberOfXTilesAtLevel=function(t){return this._numberOfLevelZeroTilesX<<t},Z.prototype.getNumberOfYTilesAtLevel=function(t){return this._numberOfLevelZeroTilesY<<t},Z.prototype.rectangleToNativeRectangle=function(t,e){o.Z.defined("rectangle",t);const n=c.Z.toDegrees(t.west),i=c.Z.toDegrees(t.south),r=c.Z.toDegrees(t.east),a=c.Z.toDegrees(t.north);return(0,s.Z)(e)?(e.west=n,e.south=i,e.east=r,e.north=a,e):new l.Z(n,i,r,a)},Z.prototype.tileXYToNativeRectangle=function(t,e,n,i){const o=this.tileXYToRectangle(t,e,n,i);return o.west=c.Z.toDegrees(o.west),o.south=c.Z.toDegrees(o.south),o.east=c.Z.toDegrees(o.east),o.north=c.Z.toDegrees(o.north),o},Z.prototype.tileXYToRectangle=function(t,e,n,i){const o=this._rectangle,r=this.getNumberOfXTilesAtLevel(n),a=this.getNumberOfYTilesAtLevel(n),u=o.width/r,c=t*u+o.west,Z=(t+1)*u+o.west,d=o.height/a,h=o.north-e*d,f=o.north-(e+1)*d;return(0,s.Z)(i)||(i=new l.Z(c,f,Z,h)),i.west=c,i.south=f,i.east=Z,i.north=h,i},Z.prototype.positionToTileXY=function(t,e,n){const o=this._rectangle;if(!l.Z.contains(o,t))return;const r=this.getNumberOfXTilesAtLevel(e),a=this.getNumberOfYTilesAtLevel(e),u=o.width/r,Z=o.height/a;let d=t.longitude;o.east<o.west&&(d+=c.Z.TWO_PI);let h=(d-o.west)/u|0;h>=r&&(h=r-1);let f=(o.north-t.latitude)/Z|0;return f>=a&&(f=a-1),(0,s.Z)(n)?(n.x=h,n.y=f,n):new i.Z(h,f)};const d=Z},97845:(t,e,n)=>{n.d(e,{Z:()=>S});var i=n(59015),o=n(93517),r=n(66866),s=n(17497),a=n(88779),u=n(54485),c=n(20176),l=n(28702),Z=n(40734),d=n(39109),h=n(71118),f=n(84473),p=n(20291),m=n(34152),y=n(7004);function g(t){t=(0,a.Z)(t,a.Z.EMPTY_OBJECT),s.Z.typeOf.object("options.attributes",t.attributes),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=(0,a.Z)(t.primitiveType,f.Z.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=(0,a.Z)(t.geometryType,l.Z.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}g.computeNumberOfVertices=function(t){s.Z.typeOf.object("geometry",t);let e=-1;for(const n in t.attributes)if(t.attributes.hasOwnProperty(n)&&(0,u.Z)(t.attributes[n])&&(0,u.Z)(t.attributes[n].values)){const i=t.attributes[n],o=i.values.length/i.componentsPerAttribute;if(e!==o&&-1!==e)throw new c.Z("All attribute lists must have the same number of attributes.");e=o}return e};const _=new r.Z,w=new o.Z,b=new h.Z,A=[new r.Z,new r.Z,new r.Z],v=[new i.Z,new i.Z,new i.Z],x=[new i.Z,new i.Z,new i.Z],O=new o.Z,P=new p.Z,T=new h.Z,E=new Z.Z;g._textureCoordinateRotationPoints=function(t,e,n,s){let a;const u=m.Z.center(s,_),c=r.Z.toCartesian(u,n,w),l=y.Z.eastNorthUpToFixedFrame(c,n,b),f=h.Z.inverse(l,b),g=v,S=A;S[0].longitude=s.west,S[0].latitude=s.south,S[1].longitude=s.west,S[1].latitude=s.north,S[2].longitude=s.east,S[2].latitude=s.south;let I=O;for(a=0;a<3;a++)r.Z.toCartesian(S[a],n,I),I=h.Z.multiplyByPointAsVector(f,I,I),g[a].x=I.x,g[a].y=I.y;const N=p.Z.fromAxisAngle(o.Z.UNIT_Z,-e,P),M=d.Z.fromQuaternion(N,T),L=t.length;let R=Number.POSITIVE_INFINITY,C=Number.POSITIVE_INFINITY,k=Number.NEGATIVE_INFINITY,z=Number.NEGATIVE_INFINITY;for(a=0;a<L;a++)I=h.Z.multiplyByPointAsVector(f,t[a],I),I=d.Z.multiplyByVector(M,I,I),R=Math.min(R,I.x),C=Math.min(C,I.y),k=Math.max(k,I.x),z=Math.max(z,I.y);const D=Z.Z.fromRotation(e,E),F=x;F[0].x=R,F[0].y=C,F[1].x=R,F[1].y=z,F[2].x=k,F[2].y=C;const q=g[0],U=g[2].x-q.x,B=g[1].y-q.y;for(a=0;a<3;a++){const t=F[a];Z.Z.multiplyByVector(D,t,t),t.x=(t.x-q.x)/U,t.y=(t.y-q.y)/B}const V=F[0],G=F[1],j=F[2],W=new Array(6);return i.Z.pack(V,W),i.Z.pack(G,W,2),i.Z.pack(j,W,4),W};const S=g},94061:(t,e,n)=>{n.d(e,{Z:()=>s});var i=n(88779),o=n(54485),r=n(20176);const s=function(t){if(t=(0,i.Z)(t,i.Z.EMPTY_OBJECT),!(0,o.Z)(t.componentDatatype))throw new r.Z("options.componentDatatype is required.");if(!(0,o.Z)(t.componentsPerAttribute))throw new r.Z("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new r.Z("options.componentsPerAttribute must be between 1 and 4.");if(!(0,o.Z)(t.values))throw new r.Z("options.values is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=(0,i.Z)(t.normalize,!1),this.values=t.values}},77683:(t,e,n)=>{n.d(e,{Z:()=>o});var i=n(88779);const o=function(t){t=(0,i.Z)(t,i.Z.EMPTY_OBJECT),this.position=t.position,this.normal=t.normal,this.st=t.st,this.bitangent=t.bitangent,this.tangent=t.tangent,this.color=t.color}},62797:(t,e,n)=>{n.d(e,{Z:()=>r});var i=n(20176);function o(){i.Z.throwInstantiationError()}o.createGeometry=function(t){i.Z.throwInstantiationError()};const r=o},78224:(t,e,n)=>{n.d(e,{Z:()=>a});var i=n(88779),o=n(54485),r=n(20176),s=n(71118);const a=function(t){if(t=(0,i.Z)(t,i.Z.EMPTY_OBJECT),!(0,o.Z)(t.geometry))throw new r.Z("options.geometry is required.");this.geometry=t.geometry,this.modelMatrix=s.Z.clone((0,i.Z)(t.modelMatrix,s.Z.IDENTITY)),this.id=t.id,this.pickPrimitive=t.pickPrimitive,this.attributes=(0,i.Z)(t.attributes,{}),this.westHemisphereGeometry=void 0,this.eastHemisphereGeometry=void 0}},11188:(t,e,n)=>{n.d(e,{Z:()=>s});var i=n(88779),o=n(54485),r=n(20176);const s=function(t){if(t=(0,i.Z)(t,i.Z.EMPTY_OBJECT),!(0,o.Z)(t.componentDatatype))throw new r.Z("options.componentDatatype is required.");if(!(0,o.Z)(t.componentsPerAttribute))throw new r.Z("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new r.Z("options.componentsPerAttribute must be between 1 and 4.");if(!(0,o.Z)(t.value))throw new r.Z("options.value is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=(0,i.Z)(t.normalize,!1),this.value=t.value}},97029:(t,e,n)=>{n.d(e,{Z:()=>i});const i=Object.freeze({NONE:0,TOP:1,ALL:2})},45050:(t,e,n)=>{n.d(e,{Z:()=>Vt});var i=n(69310),o=n(83181),r=n(52351),s=n(59015),a=n(93517),u=n(90868),c=n(66866),l=n(44990),Z=n(88779),d=n(54485),h=n(20176),f=n(88173),p=n(64729),m=n(97845),y=n(94061),g=n(28702),_=n(39172),w=n(3169),b=n(14090),A=n(22874),v=n(39109),x=n(71118),O=n(30445),P=n(84473),T=n(12760);const E={};function S(t,e,n,i,o){t[e++]=n,t[e++]=i,t[e++]=i,t[e++]=o,t[e++]=o,t[e]=n}function I(t){const e={};for(const n in t)if(t.hasOwnProperty(n)&&(0,d.Z)(t[n])&&(0,d.Z)(t[n].values)){const i=t[n];e[n]=new y.Z({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return e}function N(t,e,n){for(const i in e)if(e.hasOwnProperty(i)&&(0,d.Z)(e[i])&&(0,d.Z)(e[i].values)){const o=e[i];for(let e=0;e<o.componentsPerAttribute;++e)t[i].values.push(o.values[n*o.componentsPerAttribute+e])}}E.toWireframe=function(t){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");const e=t.indices;if((0,d.Z)(e)){switch(t.primitiveType){case P.Z.TRIANGLES:t.indices=function(t){const e=t.length,n=e/3*6,i=_.Z.createTypedArray(e,n);let o=0;for(let n=0;n<e;n+=3,o+=6)S(i,o,t[n],t[n+1],t[n+2]);return i}(e);break;case P.Z.TRIANGLE_STRIP:t.indices=function(t){const e=t.length;if(e>=3){const n=6*(e-2),i=_.Z.createTypedArray(e,n);S(i,0,t[0],t[1],t[2]);let o=6;for(let n=3;n<e;++n,o+=6)S(i,o,t[n-1],t[n],t[n-2]);return i}return new Uint16Array}(e);break;case P.Z.TRIANGLE_FAN:t.indices=function(t){if(t.length>0){const e=t.length-1,n=6*(e-1),i=_.Z.createTypedArray(e,n),o=t[0];let r=0;for(let n=1;n<e;++n,r+=6)S(i,r,o,t[n],t[n+1]);return i}return new Uint16Array}(e);break;default:throw new h.Z("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}t.primitiveType=P.Z.LINES}return t},E.createLineSegmentsForVectors=function(t,e,n){if(e=(0,Z.Z)(e,"normal"),!(0,d.Z)(t))throw new h.Z("geometry is required.");if(!(0,d.Z)(t.attributes.position))throw new h.Z("geometry.attributes.position is required.");if(!(0,d.Z)(t.attributes[e]))throw new h.Z(`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${e}.`);n=(0,Z.Z)(n,1e4);const i=t.attributes.position.values,o=t.attributes[e].values,s=i.length,a=new Float64Array(2*s);let u,c=0;for(let t=0;t<s;t+=3)a[c++]=i[t],a[c++]=i[t+1],a[c++]=i[t+2],a[c++]=i[t]+o[t]*n,a[c++]=i[t+1]+o[t+1]*n,a[c++]=i[t+2]+o[t+2]*n;const f=t.boundingSphere;return(0,d.Z)(f)&&(u=new r.Z(f.center,f.radius+n)),new m.Z({attributes:{position:new y.Z({componentDatatype:l.Z.DOUBLE,componentsPerAttribute:3,values:a})},primitiveType:P.Z.LINES,boundingSphere:u})},E.createAttributeLocations=function(t){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");const e=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],n=t.attributes,i={};let o,r=0;const s=e.length;for(o=0;o<s;++o){const t=e[o];(0,d.Z)(n[t])&&(i[t]=r++)}for(const t in n)n.hasOwnProperty(t)&&!(0,d.Z)(i[t])&&(i[t]=r++);return i},E.reorderForPreVertexCache=function(t){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");const e=m.Z.computeNumberOfVertices(t),n=t.indices;if((0,d.Z)(n)){const i=new Int32Array(e);for(let t=0;t<e;t++)i[t]=-1;const o=n,r=o.length,s=_.Z.createTypedArray(e,r);let a,u=0,c=0,Z=0;for(;u<r;)a=i[o[u]],-1!==a?s[c]=a:(a=o[u],i[a]=Z,s[c]=Z,++Z),++u,++c;t.indices=s;const h=t.attributes;for(const t in h)if(h.hasOwnProperty(t)&&(0,d.Z)(h[t])&&(0,d.Z)(h[t].values)){const n=h[t],o=n.values;let r=0;const s=n.componentsPerAttribute,a=l.Z.createTypedArray(n.componentDatatype,Z*s);for(;r<e;){const t=i[r];if(-1!==t)for(let e=0;e<s;e++)a[s*t+e]=o[s*r+e];++r}n.values=a}}return t},E.reorderForPostVertexCache=function(t,e){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");const n=t.indices;if(t.primitiveType===P.Z.TRIANGLES&&(0,d.Z)(n)){const i=n.length;let o=0;for(let t=0;t<i;t++)n[t]>o&&(o=n[t]);t.indices=T.Z.tipsify({indices:n,maximumIndex:o,cacheSize:e})}return t},E.fitToUnsignedShortIndices=function(t){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");if((0,d.Z)(t.indices)&&t.primitiveType!==P.Z.TRIANGLES&&t.primitiveType!==P.Z.LINES&&t.primitiveType!==P.Z.POINTS)throw new h.Z("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");const e=[],n=m.Z.computeNumberOfVertices(t);if((0,d.Z)(t.indices)&&n>=A.Z.SIXTY_FOUR_KILOBYTES){let n=[],i=[],o=0,r=I(t.attributes);const s=t.indices,a=s.length;let u;t.primitiveType===P.Z.TRIANGLES?u=3:t.primitiveType===P.Z.LINES?u=2:t.primitiveType===P.Z.POINTS&&(u=1);for(let c=0;c<a;c+=u){for(let e=0;e<u;++e){const a=s[c+e];let u=n[a];(0,d.Z)(u)||(u=o++,n[a]=u,N(r,t.attributes,a)),i.push(u)}o+u>=A.Z.SIXTY_FOUR_KILOBYTES&&(e.push(new m.Z({attributes:r,indices:i,primitiveType:t.primitiveType,boundingSphere:t.boundingSphere,boundingSphereCV:t.boundingSphereCV})),n=[],i=[],o=0,r=I(t.attributes))}0!==i.length&&e.push(new m.Z({attributes:r,indices:i,primitiveType:t.primitiveType,boundingSphere:t.boundingSphere,boundingSphereCV:t.boundingSphereCV}))}else e.push(t);return e};const M=new a.Z,L=new c.Z;E.projectTo2D=function(t,e,n,i,o){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");if(!(0,d.Z)(e))throw new h.Z("attributeName is required.");if(!(0,d.Z)(n))throw new h.Z("attributeName3D is required.");if(!(0,d.Z)(i))throw new h.Z("attributeName2D is required.");if(!(0,d.Z)(t.attributes[e]))throw new h.Z(`geometry must have attribute matching the attributeName argument: ${e}.`);if(t.attributes[e].componentDatatype!==l.Z.DOUBLE)throw new h.Z("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const r=t.attributes[e],s=(o=(0,d.Z)(o)?o:new p.Z).ellipsoid,u=r.values,c=new Float64Array(u.length);let Z=0;for(let t=0;t<u.length;t+=3){const e=a.Z.fromArray(u,t,M),n=s.cartesianToCartographic(e,L);if(!(0,d.Z)(n))throw new h.Z(`Could not project point (${e.x}, ${e.y}, ${e.z}) to 2D.`);const i=o.project(n,M);c[Z++]=i.x,c[Z++]=i.y,c[Z++]=i.z}return t.attributes[n]=r,t.attributes[i]=new y.Z({componentDatatype:l.Z.DOUBLE,componentsPerAttribute:3,values:c}),delete t.attributes[e],t};const R={high:0,low:0};E.encodeAttribute=function(t,e,n,i){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");if(!(0,d.Z)(e))throw new h.Z("attributeName is required.");if(!(0,d.Z)(n))throw new h.Z("attributeHighName is required.");if(!(0,d.Z)(i))throw new h.Z("attributeLowName is required.");if(!(0,d.Z)(t.attributes[e]))throw new h.Z(`geometry must have attribute matching the attributeName argument: ${e}.`);if(t.attributes[e].componentDatatype!==l.Z.DOUBLE)throw new h.Z("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const o=t.attributes[e],r=o.values,s=r.length,a=new Float32Array(s),u=new Float32Array(s);for(let t=0;t<s;++t)f.Z.encode(r[t],R),a[t]=R.high,u[t]=R.low;const c=o.componentsPerAttribute;return t.attributes[n]=new y.Z({componentDatatype:l.Z.FLOAT,componentsPerAttribute:c,values:a}),t.attributes[i]=new y.Z({componentDatatype:l.Z.FLOAT,componentsPerAttribute:c,values:u}),delete t.attributes[e],t};let C=new a.Z;function k(t,e){if((0,d.Z)(e)){const n=e.values,i=n.length;for(let e=0;e<i;e+=3)a.Z.unpack(n,e,C),x.Z.multiplyByPoint(t,C,C),a.Z.pack(C,n,e)}}function z(t,e){if((0,d.Z)(e)){const n=e.values,i=n.length;for(let e=0;e<i;e+=3)a.Z.unpack(n,e,C),v.Z.multiplyByVector(t,C,C),C=a.Z.normalize(C,C),a.Z.pack(C,n,e)}}const D=new x.Z,F=new v.Z;E.transformToWorldCoordinates=function(t){if(!(0,d.Z)(t))throw new h.Z("instance is required.");const e=t.modelMatrix;if(x.Z.equals(e,x.Z.IDENTITY))return t;const n=t.geometry.attributes;k(e,n.position),k(e,n.prevPosition),k(e,n.nextPosition),((0,d.Z)(n.normal)||(0,d.Z)(n.tangent)||(0,d.Z)(n.bitangent))&&(x.Z.inverse(e,D),x.Z.transpose(D,D),x.Z.getMatrix3(D,F),z(F,n.normal),z(F,n.tangent),z(F,n.bitangent));const i=t.geometry.boundingSphere;return(0,d.Z)(i)&&(t.geometry.boundingSphere=r.Z.transform(i,e,i)),t.modelMatrix=x.Z.clone(x.Z.IDENTITY),t};const q=new a.Z;function U(t,e){const n=t.length;let i,o,s,u;const c=t[0].modelMatrix,Z=(0,d.Z)(t[0][e].indices),f=t[0][e].primitiveType;for(o=1;o<n;++o){if(!x.Z.equals(t[o].modelMatrix,c))throw new h.Z("All instances must have the same modelMatrix.");if((0,d.Z)(t[o][e].indices)!==Z)throw new h.Z("All instance geometries must have an indices or not have one.");if(t[o][e].primitiveType!==f)throw new h.Z("All instance geometries must have the same primitiveType.")}const p=function(t,e){const n=t.length,i={},o=t[0][e].attributes;let r;for(r in o)if(o.hasOwnProperty(r)&&(0,d.Z)(o[r])&&(0,d.Z)(o[r].values)){const s=o[r];let a=s.values.length,u=!0;for(let i=1;i<n;++i){const n=t[i][e].attributes[r];if(!(0,d.Z)(n)||s.componentDatatype!==n.componentDatatype||s.componentsPerAttribute!==n.componentsPerAttribute||s.normalize!==n.normalize){u=!1;break}a+=n.values.length}u&&(i[r]=new y.Z({componentDatatype:s.componentDatatype,componentsPerAttribute:s.componentsPerAttribute,normalize:s.normalize,values:l.Z.createTypedArray(s.componentDatatype,a)}))}return i}(t,e);let g,w,b,A;for(i in p)if(p.hasOwnProperty(i))for(g=p[i].values,u=0,o=0;o<n;++o)for(w=t[o][e].attributes[i].values,b=w.length,s=0;s<b;++s)g[u++]=w[s];if(Z){let i=0;for(o=0;o<n;++o)i+=t[o][e].indices.length;const r=m.Z.computeNumberOfVertices(new m.Z({attributes:p,primitiveType:P.Z.POINTS})),s=_.Z.createTypedArray(r,i);let a=0,c=0;for(o=0;o<n;++o){const n=t[o][e].indices,i=n.length;for(u=0;u<i;++u)s[a++]=c+n[u];c+=m.Z.computeNumberOfVertices(t[o][e])}A=s}let v,O=new a.Z,T=0;for(o=0;o<n;++o){if(v=t[o][e].boundingSphere,!(0,d.Z)(v)){O=void 0;break}a.Z.add(v.center,O,O)}if((0,d.Z)(O))for(a.Z.divideByScalar(O,n,O),o=0;o<n;++o){v=t[o][e].boundingSphere;const n=a.Z.magnitude(a.Z.subtract(v.center,O,q))+v.radius;n>T&&(T=n)}return new m.Z({attributes:p,indices:A,primitiveType:f,boundingSphere:(0,d.Z)(O)?new r.Z(O,T):void 0})}E.combineInstances=function(t){if(!(0,d.Z)(t)||t.length<1)throw new h.Z("instances is required and must have length greater than zero.");const e=[],n=[],i=t.length;for(let o=0;o<i;++o){const i=t[o];(0,d.Z)(i.geometry)?e.push(i):(0,d.Z)(i.westHemisphereGeometry)&&(0,d.Z)(i.eastHemisphereGeometry)&&n.push(i)}const o=[];return e.length>0&&o.push(U(e,"geometry")),n.length>0&&(o.push(U(n,"westHemisphereGeometry")),o.push(U(n,"eastHemisphereGeometry"))),o};const B=new a.Z,V=new a.Z,G=new a.Z,j=new a.Z;E.computeNormal=function(t){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");if(!(0,d.Z)(t.attributes.position)||!(0,d.Z)(t.attributes.position.values))throw new h.Z("geometry.attributes.position.values is required.");if(!(0,d.Z)(t.indices))throw new h.Z("geometry.indices is required.");if(t.indices.length<2||t.indices.length%3!=0)throw new h.Z("geometry.indices length must be greater than 0 and be a multiple of 3.");if(t.primitiveType!==P.Z.TRIANGLES)throw new h.Z("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const e=t.indices,n=t.attributes,i=n.position.values,o=n.position.values.length/3,r=e.length,s=new Array(o),u=new Array(r/3),c=new Array(r);let Z;for(Z=0;Z<o;Z++)s[Z]={indexOffset:0,count:0,currentCount:0};let f=0;for(Z=0;Z<r;Z+=3){const t=e[Z],n=e[Z+1],o=e[Z+2],r=3*t,c=3*n,l=3*o;V.x=i[r],V.y=i[r+1],V.z=i[r+2],G.x=i[c],G.y=i[c+1],G.z=i[c+2],j.x=i[l],j.y=i[l+1],j.z=i[l+2],s[t].count++,s[n].count++,s[o].count++,a.Z.subtract(G,V,G),a.Z.subtract(j,V,j),u[f]=a.Z.cross(G,j,new a.Z),f++}let p,m=0;for(Z=0;Z<o;Z++)s[Z].indexOffset+=m,m+=s[Z].count;for(f=0,Z=0;Z<r;Z+=3){p=s[e[Z]];let t=p.indexOffset+p.currentCount;c[t]=f,p.currentCount++,p=s[e[Z+1]],t=p.indexOffset+p.currentCount,c[t]=f,p.currentCount++,p=s[e[Z+2]],t=p.indexOffset+p.currentCount,c[t]=f,p.currentCount++,f++}const g=new Float32Array(3*o);for(Z=0;Z<o;Z++){const t=3*Z;if(p=s[Z],a.Z.clone(a.Z.ZERO,B),p.count>0){for(f=0;f<p.count;f++)a.Z.add(B,u[c[p.indexOffset+f]],B);a.Z.equalsEpsilon(a.Z.ZERO,B,A.Z.EPSILON10)&&a.Z.clone(u[c[p.indexOffset]],B)}a.Z.equalsEpsilon(a.Z.ZERO,B,A.Z.EPSILON10)&&(B.z=1),a.Z.normalize(B,B),g[t]=B.x,g[t+1]=B.y,g[t+2]=B.z}return t.attributes.normal=new y.Z({componentDatatype:l.Z.FLOAT,componentsPerAttribute:3,values:g}),t};const W=new a.Z,H=new a.Z,Y=new a.Z;E.computeTangentAndBitangent=function(t){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");const e=t.attributes,n=t.indices;if(!(0,d.Z)(e.position)||!(0,d.Z)(e.position.values))throw new h.Z("geometry.attributes.position.values is required.");if(!(0,d.Z)(e.normal)||!(0,d.Z)(e.normal.values))throw new h.Z("geometry.attributes.normal.values is required.");if(!(0,d.Z)(e.st)||!(0,d.Z)(e.st.values))throw new h.Z("geometry.attributes.st.values is required.");if(!(0,d.Z)(n))throw new h.Z("geometry.indices is required.");if(n.length<2||n.length%3!=0)throw new h.Z("geometry.indices length must be greater than 0 and be a multiple of 3.");if(t.primitiveType!==P.Z.TRIANGLES)throw new h.Z("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const i=t.attributes.position.values,o=t.attributes.normal.values,r=t.attributes.st.values,s=t.attributes.position.values.length/3,u=n.length,c=new Array(3*s);let Z,f,p,m;for(Z=0;Z<c.length;Z++)c[Z]=0;for(Z=0;Z<u;Z+=3){const t=n[Z],e=n[Z+1],o=n[Z+2];f=3*t,p=3*e,m=3*o;const s=2*t,a=2*e,u=2*o,l=i[f],d=i[f+1],h=i[f+2],y=r[s],g=r[s+1],_=r[a+1]-g,w=r[u+1]-g,b=1/((r[a]-y)*w-(r[u]-y)*_),A=(w*(i[p]-l)-_*(i[m]-l))*b,v=(w*(i[p+1]-d)-_*(i[m+1]-d))*b,x=(w*(i[p+2]-h)-_*(i[m+2]-h))*b;c[f]+=A,c[f+1]+=v,c[f+2]+=x,c[p]+=A,c[p+1]+=v,c[p+2]+=x,c[m]+=A,c[m+1]+=v,c[m+2]+=x}const g=new Float32Array(3*s),_=new Float32Array(3*s);for(Z=0;Z<s;Z++){f=3*Z,p=f+1,m=f+2;const t=a.Z.fromArray(o,f,W),e=a.Z.fromArray(c,f,Y),n=a.Z.dot(t,e);a.Z.multiplyByScalar(t,n,H),a.Z.normalize(a.Z.subtract(e,H,e),e),g[f]=e.x,g[p]=e.y,g[m]=e.z,a.Z.normalize(a.Z.cross(t,e,e),e),_[f]=e.x,_[p]=e.y,_[m]=e.z}return t.attributes.tangent=new y.Z({componentDatatype:l.Z.FLOAT,componentsPerAttribute:3,values:g}),t.attributes.bitangent=new y.Z({componentDatatype:l.Z.FLOAT,componentsPerAttribute:3,values:_}),t};const Q=new s.Z,X=new a.Z,J=new a.Z,$=new a.Z;let K=new s.Z;function tt(t){switch(t.primitiveType){case P.Z.TRIANGLE_FAN:return function(t){const e=m.Z.computeNumberOfVertices(t);if(e<3)throw new h.Z("The number of vertices must be at least three.");const n=_.Z.createTypedArray(e,3*(e-2));n[0]=1,n[1]=0,n[2]=2;let i=3;for(let t=3;t<e;++t)n[i++]=t-1,n[i++]=0,n[i++]=t;return t.indices=n,t.primitiveType=P.Z.TRIANGLES,t}(t);case P.Z.TRIANGLE_STRIP:return function(t){const e=m.Z.computeNumberOfVertices(t);if(e<3)throw new h.Z("The number of vertices must be at least 3.");const n=_.Z.createTypedArray(e,3*(e-2));n[0]=0,n[1]=1,n[2]=2,e>3&&(n[3]=0,n[4]=2,n[5]=3);let i=6;for(let t=3;t<e-1;t+=2)n[i++]=t,n[i++]=t-1,n[i++]=t+1,t+2<e&&(n[i++]=t,n[i++]=t+1,n[i++]=t+2);return t.indices=n,t.primitiveType=P.Z.TRIANGLES,t}(t);case P.Z.TRIANGLES:return function(t){if((0,d.Z)(t.indices))return t;const e=m.Z.computeNumberOfVertices(t);if(e<3)throw new h.Z("The number of vertices must be at least three.");if(e%3!=0)throw new h.Z("The number of vertices must be a multiple of three.");const n=_.Z.createTypedArray(e,e);for(let t=0;t<e;++t)n[t]=t;return t.indices=n,t}(t);case P.Z.LINE_STRIP:return function(t){const e=m.Z.computeNumberOfVertices(t);if(e<2)throw new h.Z("The number of vertices must be at least two.");const n=_.Z.createTypedArray(e,2*(e-1));n[0]=0,n[1]=1;let i=2;for(let t=2;t<e;++t)n[i++]=t-1,n[i++]=t;return t.indices=n,t.primitiveType=P.Z.LINES,t}(t);case P.Z.LINE_LOOP:return function(t){const e=m.Z.computeNumberOfVertices(t);if(e<2)throw new h.Z("The number of vertices must be at least two.");const n=_.Z.createTypedArray(e,2*e);n[0]=0,n[1]=1;let i=2;for(let t=2;t<e;++t)n[i++]=t-1,n[i++]=t;return n[i++]=e-1,n[i]=0,t.indices=n,t.primitiveType=P.Z.LINES,t}(t);case P.Z.LINES:return function(t){if((0,d.Z)(t.indices))return t;const e=m.Z.computeNumberOfVertices(t);if(e<2)throw new h.Z("The number of vertices must be at least two.");if(e%2!=0)throw new h.Z("The number of vertices must be a multiple of 2.");const n=_.Z.createTypedArray(e,e);for(let t=0;t<e;++t)n[t]=t;return t.indices=n,t}(t)}return t}function et(t,e){Math.abs(t.y)<A.Z.EPSILON6&&(t.y=e?-A.Z.EPSILON6:A.Z.EPSILON6)}E.compressVertices=function(t){if(!(0,d.Z)(t))throw new h.Z("geometry is required.");const e=t.attributes.extrudeDirection;let n,o;if((0,d.Z)(e)){const r=e.values;o=r.length/3;const s=new Float32Array(2*o);let u=0;for(n=0;n<o;++n)a.Z.fromArray(r,3*n,X),a.Z.equals(X,a.Z.ZERO)?u+=2:(K=i.Z.octEncodeInRange(X,65535,K),s[u++]=K.x,s[u++]=K.y);return t.attributes.compressedAttributes=new y.Z({componentDatatype:l.Z.FLOAT,componentsPerAttribute:2,values:s}),delete t.attributes.extrudeDirection,t}const r=t.attributes.normal,u=t.attributes.st,c=(0,d.Z)(r),Z=(0,d.Z)(u);if(!c&&!Z)return t;const f=t.attributes.tangent,p=t.attributes.bitangent,m=(0,d.Z)(f),g=(0,d.Z)(p);let _,w,b,A;c&&(_=r.values),Z&&(w=u.values),m&&(b=f.values),g&&(A=p.values);o=(c?_.length:w.length)/(c?3:2);let v=o,x=Z&&c?2:1;x+=m||g?1:0,v*=x;const O=new Float32Array(v);let P=0;for(n=0;n<o;++n){Z&&(s.Z.fromArray(w,2*n,Q),O[P++]=i.Z.compressTextureCoordinates(Q));const t=3*n;c&&(0,d.Z)(b)&&(0,d.Z)(A)?(a.Z.fromArray(_,t,X),a.Z.fromArray(b,t,J),a.Z.fromArray(A,t,$),i.Z.octPack(X,J,$,Q),O[P++]=Q.x,O[P++]=Q.y):(c&&(a.Z.fromArray(_,t,X),O[P++]=i.Z.octEncodeFloat(X)),m&&(a.Z.fromArray(b,t,X),O[P++]=i.Z.octEncodeFloat(X)),g&&(a.Z.fromArray(A,t,X),O[P++]=i.Z.octEncodeFloat(X)))}return t.attributes.compressedAttributes=new y.Z({componentDatatype:l.Z.FLOAT,componentsPerAttribute:x,values:O}),c&&delete t.attributes.normal,Z&&delete t.attributes.st,g&&delete t.attributes.bitangent,m&&delete t.attributes.tangent,t};const nt=new a.Z;function it(t,e,n,i){a.Z.add(t,a.Z.multiplyByScalar(a.Z.subtract(e,t,nt),t.y/(t.y-e.y),nt),n),a.Z.clone(n,i),et(n,!0),et(i,!1)}const ot=new a.Z,rt=new a.Z,st=new a.Z,at=new a.Z,ut={positions:new Array(7),indices:new Array(9)};function ct(t,e,n){if(t.x>=0||e.x>=0||n.x>=0)return;!function(t,e,n){if(0!==t.y&&0!==e.y&&0!==n.y)return et(t,t.y<0),et(e,e.y<0),void et(n,n.y<0);const i=Math.abs(t.y),o=Math.abs(e.y),r=Math.abs(n.y);let s;s=i>o?i>r?A.Z.sign(t.y):A.Z.sign(n.y):o>r?A.Z.sign(e.y):A.Z.sign(n.y);const a=s<0;et(t,a),et(e,a),et(n,a)}(t,e,n);const i=t.y<0,o=e.y<0,r=n.y<0;let s=0;s+=i?1:0,s+=o?1:0,s+=r?1:0;const a=ut.indices;1===s?(a[1]=3,a[2]=4,a[5]=6,a[7]=6,a[8]=5,i?(it(t,e,ot,st),it(t,n,rt,at),a[0]=0,a[3]=1,a[4]=2,a[6]=1):o?(it(e,n,ot,st),it(e,t,rt,at),a[0]=1,a[3]=2,a[4]=0,a[6]=2):r&&(it(n,t,ot,st),it(n,e,rt,at),a[0]=2,a[3]=0,a[4]=1,a[6]=0)):2===s&&(a[2]=4,a[4]=4,a[5]=3,a[7]=5,a[8]=6,i?o?r||(it(n,t,ot,st),it(n,e,rt,at),a[0]=0,a[1]=1,a[3]=0,a[6]=2):(it(e,n,ot,st),it(e,t,rt,at),a[0]=2,a[1]=0,a[3]=2,a[6]=1):(it(t,e,ot,st),it(t,n,rt,at),a[0]=1,a[1]=2,a[3]=1,a[6]=0));const u=ut.positions;return u[0]=t,u[1]=e,u[2]=n,u.length=3,1!==s&&2!==s||(u[3]=ot,u[4]=rt,u[5]=st,u[6]=at,u.length=7),ut}function lt(t,e){const n=t.attributes;if(0===n.position.values.length)return;for(const t in n)if(n.hasOwnProperty(t)&&(0,d.Z)(n[t])&&(0,d.Z)(n[t].values)){const e=n[t];e.values=l.Z.createTypedArray(e.componentDatatype,e.values)}const i=m.Z.computeNumberOfVertices(t);return t.indices=_.Z.createTypedArray(i,t.indices),e&&(t.boundingSphere=r.Z.fromVertices(n.position.values)),t}function Zt(t){const e=t.attributes,n={};for(const t in e)if(e.hasOwnProperty(t)&&(0,d.Z)(e[t])&&(0,d.Z)(e[t].values)){const i=e[t];n[t]=new y.Z({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new m.Z({attributes:n,indices:[],primitiveType:t.primitiveType})}function dt(t,e,n){const i=(0,d.Z)(t.geometry.boundingSphere);e=lt(e,i),n=lt(n,i),(0,d.Z)(n)&&!(0,d.Z)(e)?t.geometry=n:!(0,d.Z)(n)&&(0,d.Z)(e)?t.geometry=e:(t.westHemisphereGeometry=e,t.eastHemisphereGeometry=n,t.geometry=void 0)}function ht(t,e){const n=new t,i=new t,o=new t;return function(r,s,a,u,c,l,Z,d){const h=t.fromArray(c,r*e,n),f=t.fromArray(c,s*e,i),p=t.fromArray(c,a*e,o);t.multiplyByScalar(h,u.x,h),t.multiplyByScalar(f,u.y,f),t.multiplyByScalar(p,u.z,p);const m=t.add(h,f,h);t.add(m,p,m),d&&t.normalize(m,m),t.pack(m,l,Z*e)}}const ft=ht(u.Z,4),pt=ht(a.Z,3),mt=ht(s.Z,2),yt=new a.Z,gt=new a.Z,_t=new a.Z,wt=new a.Z;function bt(t,e,n,i,r,s,u,c,l,Z,h,f,p,m,y,g){if(!((0,d.Z)(s)||(0,d.Z)(u)||(0,d.Z)(c)||(0,d.Z)(l)||(0,d.Z)(Z)||0!==m))return;const _=a.Z.fromArray(r,3*t,yt),w=a.Z.fromArray(r,3*e,gt),b=a.Z.fromArray(r,3*n,_t),v=(0,o.Z)(i,_,w,b,wt);if((0,d.Z)(v)){if((0,d.Z)(s)&&pt(t,e,n,v,s,f.normal.values,g,!0),(0,d.Z)(Z)){const i=a.Z.fromArray(Z,3*t,yt),o=a.Z.fromArray(Z,3*e,gt),r=a.Z.fromArray(Z,3*n,_t);let s;a.Z.multiplyByScalar(i,v.x,i),a.Z.multiplyByScalar(o,v.y,o),a.Z.multiplyByScalar(r,v.z,r),a.Z.equals(i,a.Z.ZERO)&&a.Z.equals(o,a.Z.ZERO)&&a.Z.equals(r,a.Z.ZERO)?(s=yt,s.x=0,s.y=0,s.z=0):(s=a.Z.add(i,o,i),a.Z.add(s,r,s),a.Z.normalize(s,s)),a.Z.pack(s,f.extrudeDirection.values,3*g)}if((0,d.Z)(h)&&function(t,e,n,i,o,r,s){const a=o[t]*i.x,u=o[e]*i.y,c=o[n]*i.z;r[s]=a+u+c>A.Z.EPSILON6?1:0}(t,e,n,v,h,f.applyOffset.values,g),(0,d.Z)(u)&&pt(t,e,n,v,u,f.tangent.values,g,!0),(0,d.Z)(c)&&pt(t,e,n,v,c,f.bitangent.values,g,!0),(0,d.Z)(l)&&mt(t,e,n,v,l,f.st.values,g),m>0)for(let i=0;i<m;i++){const o=p[i];At(t,e,n,v,g,y[o],f[o])}}}function At(t,e,n,i,o,r,s){const a=r.componentsPerAttribute,u=r.values,c=s.values;switch(a){case 4:ft(t,e,n,i,u,c,o,!1);break;case 3:pt(t,e,n,i,u,c,o,!1);break;case 2:mt(t,e,n,i,u,c,o,!1);break;default:c[o]=u[t]*i.x+u[e]*i.y+u[n]*i.z}}function vt(t,e,n,i,o,r){const s=t.position.values.length/3;if(-1!==o){const a=i[o],u=n[a];return-1===u?(n[a]=s,t.position.values.push(r.x,r.y,r.z),e.push(s),s):(e.push(u),u)}return t.position.values.push(r.x,r.y,r.z),e.push(s),s}const xt={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function Ot(t){const e=t.geometry,n=e.attributes,i=n.position.values,o=(0,d.Z)(n.normal)?n.normal.values:void 0,r=(0,d.Z)(n.bitangent)?n.bitangent.values:void 0,s=(0,d.Z)(n.tangent)?n.tangent.values:void 0,u=(0,d.Z)(n.st)?n.st.values:void 0,c=(0,d.Z)(n.extrudeDirection)?n.extrudeDirection.values:void 0,l=(0,d.Z)(n.applyOffset)?n.applyOffset.values:void 0,Z=e.indices,h=[];for(const t in n)n.hasOwnProperty(t)&&!xt[t]&&(0,d.Z)(n[t])&&h.push(t);const f=h.length,p=Zt(e),m=Zt(e);let y,g,_,w,b;const A=[];A.length=i.length/3;const v=[];for(v.length=i.length/3,b=0;b<A.length;++b)A[b]=-1,v[b]=-1;const x=Z.length;for(b=0;b<x;b+=3){const t=Z[b],e=Z[b+1],x=Z[b+2];let O=a.Z.fromArray(i,3*t),P=a.Z.fromArray(i,3*e),T=a.Z.fromArray(i,3*x);const E=ct(O,P,T);if((0,d.Z)(E)&&E.positions.length>3){const a=E.positions,d=E.indices,O=d.length;for(let P=0;P<O;++P){const O=d[P],T=a[O];T.y<0?(y=m.attributes,g=m.indices,_=A):(y=p.attributes,g=p.indices,_=v),w=vt(y,g,_,Z,O<3?b+O:-1,T),bt(t,e,x,T,i,o,s,r,u,c,l,y,h,f,n,w)}}else(0,d.Z)(E)&&(O=E.positions[0],P=E.positions[1],T=E.positions[2]),O.y<0?(y=m.attributes,g=m.indices,_=A):(y=p.attributes,g=p.indices,_=v),w=vt(y,g,_,Z,b,O),bt(t,e,x,O,i,o,s,r,u,c,l,y,h,f,n,w),w=vt(y,g,_,Z,b+1,P),bt(t,e,x,P,i,o,s,r,u,c,l,y,h,f,n,w),w=vt(y,g,_,Z,b+2,T),bt(t,e,x,T,i,o,s,r,u,c,l,y,h,f,n,w)}dt(t,m,p)}const Pt=O.Z.fromPointNormal(a.Z.ZERO,a.Z.UNIT_Y),Tt=new a.Z,Et=new a.Z;function St(t,e,n,i,o,r,s){if(!(0,d.Z)(s))return;const u=a.Z.fromArray(i,3*t,yt);a.Z.equalsEpsilon(u,n,A.Z.EPSILON10)?r.applyOffset.values[o]=s[t]:r.applyOffset.values[o]=s[e]}function It(t){const e=t.geometry,n=e.attributes,i=n.position.values,o=(0,d.Z)(n.applyOffset)?n.applyOffset.values:void 0,r=e.indices,s=Zt(e),u=Zt(e);let c;const l=r.length,Z=[];Z.length=i.length/3;const h=[];for(h.length=i.length/3,c=0;c<Z.length;++c)Z[c]=-1,h[c]=-1;for(c=0;c<l;c+=2){const t=r[c],e=r[c+1],n=a.Z.fromArray(i,3*t,yt),l=a.Z.fromArray(i,3*e,gt);let f;Math.abs(n.y)<A.Z.EPSILON6&&(n.y<0?n.y=-A.Z.EPSILON6:n.y=A.Z.EPSILON6),Math.abs(l.y)<A.Z.EPSILON6&&(l.y<0?l.y=-A.Z.EPSILON6:l.y=A.Z.EPSILON6);let p=s.attributes,m=s.indices,y=h,g=u.attributes,_=u.indices,w=Z;const v=b.Z.lineSegmentPlane(n,l,Pt,_t);if((0,d.Z)(v)){const d=a.Z.multiplyByScalar(a.Z.UNIT_Y,5*A.Z.EPSILON9,Tt);n.y<0&&(a.Z.negate(d,d),p=u.attributes,m=u.indices,y=Z,g=s.attributes,_=s.indices,w=h);const b=a.Z.add(v,d,Et);f=vt(p,m,y,r,c,n),St(t,e,n,i,f,p,o),f=vt(p,m,y,r,-1,b),St(t,e,b,i,f,p,o),a.Z.negate(d,d),a.Z.add(v,d,b),f=vt(g,_,w,r,-1,b),St(t,e,b,i,f,g,o),f=vt(g,_,w,r,c+1,l),St(t,e,l,i,f,g,o)}else{let a,d,p;n.y<0?(a=u.attributes,d=u.indices,p=Z):(a=s.attributes,d=s.indices,p=h),f=vt(a,d,p,r,c,n),St(t,e,n,i,f,a,o),f=vt(a,d,p,r,c+1,l),St(t,e,l,i,f,a,o)}}dt(t,u,s)}const Nt=new s.Z,Mt=new s.Z,Lt=new a.Z,Rt=new a.Z,Ct=new a.Z,kt=new a.Z,zt=new a.Z,Dt=new a.Z,Ft=new u.Z;function qt(t){const e=t.attributes,n=e.position.values,i=e.prevPosition.values,o=e.nextPosition.values,r=n.length;for(let t=0;t<r;t+=3){const e=a.Z.unpack(n,t,Lt);if(e.x>0)continue;const s=a.Z.unpack(i,t,Rt);(e.y<0&&s.y>0||e.y>0&&s.y<0)&&(t-3>0?(i[t]=n[t-3],i[t+1]=n[t-2],i[t+2]=n[t-1]):a.Z.pack(e,i,t));const u=a.Z.unpack(o,t,Ct);(e.y<0&&u.y>0||e.y>0&&u.y<0)&&(t+3<r?(o[t]=n[t+3],o[t+1]=n[t+4],o[t+2]=n[t+5]):a.Z.pack(e,o,t))}}const Ut=5*A.Z.EPSILON9,Bt=A.Z.EPSILON6;E.splitLongitude=function(t){if(!(0,d.Z)(t))throw new h.Z("instance is required.");const e=t.geometry,n=e.boundingSphere;if((0,d.Z)(n)){if(n.center.x-n.radius>0||r.Z.intersectPlane(n,O.Z.ORIGIN_ZX_PLANE)!==w.Z.INTERSECTING)return t}if(e.geometryType!==g.Z.NONE)switch(e.geometryType){case g.Z.POLYLINES:!function(t){const e=t.geometry,n=e.attributes,i=n.position.values,o=n.prevPosition.values,r=n.nextPosition.values,c=n.expandAndWidth.values,l=(0,d.Z)(n.st)?n.st.values:void 0,Z=(0,d.Z)(n.color)?n.color.values:void 0,h=Zt(e),f=Zt(e);let p,m,y,g=!1;const _=i.length/3;for(p=0;p<_;p+=4){const t=p,e=p+2,n=a.Z.fromArray(i,3*t,Lt),_=a.Z.fromArray(i,3*e,Rt);if(Math.abs(n.y)<Bt)for(n.y=Bt*(_.y<0?-1:1),i[3*p+1]=n.y,i[3*(p+1)+1]=n.y,m=3*t;m<3*t+12;m+=3)o[m]=i[3*p],o[m+1]=i[3*p+1],o[m+2]=i[3*p+2];if(Math.abs(_.y)<Bt)for(_.y=Bt*(n.y<0?-1:1),i[3*(p+2)+1]=_.y,i[3*(p+3)+1]=_.y,m=3*t;m<3*t+12;m+=3)r[m]=i[3*(p+2)],r[m+1]=i[3*(p+2)+1],r[m+2]=i[3*(p+2)+2];let w=h.attributes,v=h.indices,x=f.attributes,O=f.indices;const P=b.Z.lineSegmentPlane(n,_,Pt,kt);if((0,d.Z)(P)){g=!0;const i=a.Z.multiplyByScalar(a.Z.UNIT_Y,Ut,zt);n.y<0&&(a.Z.negate(i,i),w=f.attributes,v=f.indices,x=h.attributes,O=h.indices);const b=a.Z.add(P,i,Dt);w.position.values.push(n.x,n.y,n.z,n.x,n.y,n.z),w.position.values.push(b.x,b.y,b.z),w.position.values.push(b.x,b.y,b.z),w.prevPosition.values.push(o[3*t],o[3*t+1],o[3*t+2]),w.prevPosition.values.push(o[3*t+3],o[3*t+4],o[3*t+5]),w.prevPosition.values.push(n.x,n.y,n.z,n.x,n.y,n.z),w.nextPosition.values.push(b.x,b.y,b.z),w.nextPosition.values.push(b.x,b.y,b.z),w.nextPosition.values.push(b.x,b.y,b.z),w.nextPosition.values.push(b.x,b.y,b.z),a.Z.negate(i,i),a.Z.add(P,i,b),x.position.values.push(b.x,b.y,b.z),x.position.values.push(b.x,b.y,b.z),x.position.values.push(_.x,_.y,_.z,_.x,_.y,_.z),x.prevPosition.values.push(b.x,b.y,b.z),x.prevPosition.values.push(b.x,b.y,b.z),x.prevPosition.values.push(b.x,b.y,b.z),x.prevPosition.values.push(b.x,b.y,b.z),x.nextPosition.values.push(_.x,_.y,_.z,_.x,_.y,_.z),x.nextPosition.values.push(r[3*e],r[3*e+1],r[3*e+2]),x.nextPosition.values.push(r[3*e+3],r[3*e+4],r[3*e+5]);const T=s.Z.fromArray(c,2*t,Nt),E=Math.abs(T.y);w.expandAndWidth.values.push(-1,E,1,E),w.expandAndWidth.values.push(-1,-E,1,-E),x.expandAndWidth.values.push(-1,E,1,E),x.expandAndWidth.values.push(-1,-E,1,-E);let S=a.Z.magnitudeSquared(a.Z.subtract(P,n,Ct));if(S/=a.Z.magnitudeSquared(a.Z.subtract(_,n,Ct)),(0,d.Z)(Z)){const n=u.Z.fromArray(Z,4*t,Ft),i=u.Z.fromArray(Z,4*e,Ft),o=A.Z.lerp(n.x,i.x,S),r=A.Z.lerp(n.y,i.y,S),s=A.Z.lerp(n.z,i.z,S),a=A.Z.lerp(n.w,i.w,S);for(m=4*t;m<4*t+8;++m)w.color.values.push(Z[m]);for(w.color.values.push(o,r,s,a),w.color.values.push(o,r,s,a),x.color.values.push(o,r,s,a),x.color.values.push(o,r,s,a),m=4*e;m<4*e+8;++m)x.color.values.push(Z[m])}if((0,d.Z)(l)){const n=s.Z.fromArray(l,2*t,Nt),i=s.Z.fromArray(l,2*(p+3),Mt),o=A.Z.lerp(n.x,i.x,S);for(m=2*t;m<2*t+4;++m)w.st.values.push(l[m]);for(w.st.values.push(o,n.y),w.st.values.push(o,i.y),x.st.values.push(o,n.y),x.st.values.push(o,i.y),m=2*e;m<2*e+4;++m)x.st.values.push(l[m])}y=w.position.values.length/3-4,v.push(y,y+2,y+1),v.push(y+1,y+2,y+3),y=x.position.values.length/3-4,O.push(y,y+2,y+1),O.push(y+1,y+2,y+3)}else{let t,e;for(n.y<0?(t=f.attributes,e=f.indices):(t=h.attributes,e=h.indices),t.position.values.push(n.x,n.y,n.z),t.position.values.push(n.x,n.y,n.z),t.position.values.push(_.x,_.y,_.z),t.position.values.push(_.x,_.y,_.z),m=3*p;m<3*p+12;++m)t.prevPosition.values.push(o[m]),t.nextPosition.values.push(r[m]);for(m=2*p;m<2*p+8;++m)t.expandAndWidth.values.push(c[m]),(0,d.Z)(l)&&t.st.values.push(l[m]);if((0,d.Z)(Z))for(m=4*p;m<4*p+16;++m)t.color.values.push(Z[m]);y=t.position.values.length/3-4,e.push(y,y+2,y+1),e.push(y+1,y+2,y+3)}}g&&(qt(f),qt(h)),dt(t,f,h)}(t);break;case g.Z.TRIANGLES:Ot(t);break;case g.Z.LINES:It(t)}else tt(e),e.primitiveType===P.Z.TRIANGLES?Ot(t):e.primitiveType===P.Z.LINES&&It(t);return t};const Vt=E},28702:(t,e,n)=>{n.d(e,{Z:()=>i});const i=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3})}}]);