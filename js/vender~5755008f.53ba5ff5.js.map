{"version":3,"file":"js/vender~5755008f.53ba5ff5.js","mappings":"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","sources":["webpack:///../../../node_modules/cesium/Source/Scene/Model.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/PointCloudAttenuationPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/PrimitiveRenderResources.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/SceneMode2DPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/SelectedFeatureIdPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/SkinningPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/StyleCommandsNeeded.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/TextureManager.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/TextureUniform.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/UniformType.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/VaryingType.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/WireframePipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/buildDrawCommand.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelInstance.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelInstanceCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelLoadResources.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelMaterial.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelMesh.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelNode.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelOutlineLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelUtility.js","webpack:///../../../node_modules/cesium/Source/Scene/Moon.js","webpack:///../../../node_modules/cesium/Source/Scene/Multiple3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/NeverTileDiscardPolicy.js","webpack:///../../../node_modules/cesium/Source/Scene/OIT.js","webpack:///../../../node_modules/cesium/Source/Scene/OctahedralProjectedCubeMap.js","webpack:///../../../node_modules/cesium/Source/Scene/OpenStreetMapImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/OrderedGroundPrimitiveCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/Particle.js","webpack:///../../../node_modules/cesium/Source/Scene/ParticleBurst.js","webpack:///../../../node_modules/cesium/Source/Scene/ParticleEmitter.js","webpack:///../../../node_modules/cesium/Source/Scene/ParticleSystem.js","webpack:///../../../node_modules/cesium/Source/Scene/PerInstanceColorAppearance.js","webpack:///../../../node_modules/cesium/Source/Scene/PerformanceDisplay.js","webpack:///../../../node_modules/cesium/Source/Scene/PickDepth.js","webpack:///../../../node_modules/cesium/Source/Scene/PickDepthFramebuffer.js","webpack:///../../../node_modules/cesium/Source/Scene/PickFramebuffer.js","webpack:///../../../node_modules/cesium/Source/Scene/Picking.js","webpack:///../../../node_modules/cesium/Source/Scene/PntsParser.js"],"sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport getAbsoluteUri from \"../Core/getAbsoluteUri.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport getMagic from \"../Core/getMagic.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport ImageBasedLighting from \"./ImageBasedLighting.js\";\nimport loadImageFromTypedArray from \"../Core/loadImageFromTypedArray.js\";\nimport loadKTX2 from \"../Core/loadKTX2.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Resource from \"../Core/Resource.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport addDefaults from \"./GltfPipeline/addDefaults.js\";\nimport addPipelineExtras from \"./GltfPipeline/addPipelineExtras.js\";\nimport ForEach from \"./GltfPipeline/ForEach.js\";\nimport getAccessorByteStride from \"./GltfPipeline/getAccessorByteStride.js\";\nimport usesExtension from \"./GltfPipeline/usesExtension.js\";\nimport numberOfComponentsForType from \"./GltfPipeline/numberOfComponentsForType.js\";\nimport parseGlb from \"./GltfPipeline/parseGlb.js\";\nimport updateVersion from \"./GltfPipeline/updateVersion.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport ColorBlendMode from \"./ColorBlendMode.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport JobType from \"./JobType.js\";\nimport ModelAnimationCache from \"./ModelAnimationCache.js\";\nimport ModelAnimationCollection from \"./ModelAnimationCollection.js\";\nimport ModelLoadResources from \"./ModelLoadResources.js\";\nimport ModelMaterial from \"./ModelMaterial.js\";\nimport ModelMesh from \"./ModelMesh.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelOutlineLoader from \"./ModelOutlineLoader.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport OctahedralProjectedCubeMap from \"./OctahedralProjectedCubeMap.js\";\nimport processModelMaterialsCommon from \"./processModelMaterialsCommon.js\";\nimport processPbrMaterials from \"./processPbrMaterials.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport SplitDirection from \"./SplitDirection.js\";\nimport Splitter from \"./Splitter.js\";\nimport StencilConstants from \"./StencilConstants.js\";\n\nconst boundingSphereCartesian3Scratch = new Cartesian3();\n\nconst ModelState = ModelUtility.ModelState;\n\n// glTF MIME types discussed in https://github.com/KhronosGroup/glTF/issues/412 and https://github.com/KhronosGroup/glTF/issues/943\nconst defaultModelAccept =\n  \"model/gltf-binary,model/gltf+json;q=0.8,application/json;q=0.2,*/*;q=0.01\";\n\nconst articulationEpsilon = CesiumMath.EPSILON16;\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction setCachedGltf(model, cachedGltf) {\n  model._cachedGltf = cachedGltf;\n}\n\n// glTF JSON can be big given embedded geometry, textures, and animations, so we\n// cache it across all models using the same url/cache-key.  This also reduces the\n// slight overhead in assigning defaults to missing values.\n//\n// Note that this is a global cache, compared to renderer resources, which\n// are cached per context.\nfunction CachedGltf(options) {\n  this._gltf = options.gltf;\n  this.ready = options.ready;\n  this.modelsToLoad = [];\n  this.count = 0;\n}\n\nObject.defineProperties(CachedGltf.prototype, {\n  gltf: {\n    set: function (value) {\n      this._gltf = value;\n    },\n\n    get: function () {\n      return this._gltf;\n    },\n  },\n});\n\nCachedGltf.prototype.makeReady = function (gltfJson) {\n  this.gltf = gltfJson;\n\n  const models = this.modelsToLoad;\n  const length = models.length;\n  for (let i = 0; i < length; ++i) {\n    const m = models[i];\n    if (!m.isDestroyed()) {\n      setCachedGltf(m, this);\n    }\n  }\n  this.modelsToLoad = undefined;\n  this.ready = true;\n};\n\nconst gltfCache = {};\nconst uriToGuid = {};\n///////////////////////////////////////////////////////////////////////////\n\n/**\n * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.\n * <p>\n * Cesium includes support for geometry and materials, glTF animations, and glTF skinning.\n * In addition, individual glTF nodes are pickable with {@link Scene#pick} and animatable\n * with {@link Model#getNode}.  glTF cameras and lights are not currently supported.\n * </p>\n * <p>\n * An external glTF asset is created with {@link Model.fromGltf}.  glTF JSON can also be\n * created at runtime and passed to this constructor function.  In either case, the\n * {@link Model#readyPromise} is resolved when the model is ready to render, i.e.,\n * when the external binary, image, and shader files are downloaded and the WebGL\n * resources are created.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_basisu|KHR_texture_basisu}\n * </li>\n * </ul>\n * </p>\n * <p>\n * Note: for models with compressed textures using the KHR_texture_basisu extension, we recommend power of 2 textures in both dimensions\n * for maximum compatibility. This is because some samplers require power of 2 textures ({@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL|Using textures in WebGL})\n * and KHR_texture_basisu requires multiple of 4 dimensions ({@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_basisu/README.md#additional-requirements|KHR_texture_basisu additional requirements}).\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @alias Model\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models. Deprecated in CesiumJS 1.94, will be removed in CesiumJS 1.95.\n * @param {Cartesian3} [options.lightColor] The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n * @param {ImageBasedLighting} [options.imageBasedLighting] The properties for managing image-based lighting on this model.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n * @param {Boolean} [options.showCreditsOnScreen=false] Whether to display the credits of this model on screen.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the material's doubleSided property; when false, back face culling is disabled. Back faces are not culled if {@link Model#color} is translucent or {@link Model#silhouetteSize} is greater than 0.0.\n * @param {Boolean} [options.showOutline=true] Whether to display the outline for models using the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. When true, outlines are displayed. When false, outlines are not displayed.\n * @param {SplitDirection} [options.splitDirection=SplitDirection.NONE] The {@link SplitDirection} split to apply to this model.\n *\n *\n * @see Model.fromGltf\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=3D%20Models.html|Cesium Sandcastle Models Demo}\n */\nfunction Model(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const cacheKey = options.cacheKey;\n  this._cacheKey = cacheKey;\n  this._cachedGltf = undefined;\n  this._releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n\n  let cachedGltf;\n  if (\n    defined(cacheKey) &&\n    defined(gltfCache[cacheKey]) &&\n    gltfCache[cacheKey].ready\n  ) {\n    // glTF JSON is in cache and ready\n    cachedGltf = gltfCache[cacheKey];\n    ++cachedGltf.count;\n  } else {\n    // glTF was explicitly provided, e.g., when a user uses the Model constructor directly\n    let gltf = options.gltf;\n\n    if (defined(gltf)) {\n      if (gltf instanceof ArrayBuffer) {\n        gltf = new Uint8Array(gltf);\n      }\n\n      if (gltf instanceof Uint8Array) {\n        // Binary glTF\n        const parsedGltf = parseGlb(gltf);\n\n        cachedGltf = new CachedGltf({\n          gltf: parsedGltf,\n          ready: true,\n        });\n      } else {\n        // Normal glTF (JSON)\n        cachedGltf = new CachedGltf({\n          gltf: options.gltf,\n          ready: true,\n        });\n      }\n\n      cachedGltf.count = 1;\n\n      if (defined(cacheKey)) {\n        gltfCache[cacheKey] = cachedGltf;\n      }\n    }\n  }\n  setCachedGltf(this, cachedGltf);\n\n  const basePath = defaultValue(options.basePath, \"\");\n  this._resource = Resource.createIfNeeded(basePath);\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n\n  this._credit = credit;\n\n  // List of credits to be added from the Resource if it is an IonResource\n  this._resourceCredits = [];\n\n  // List of credits to be added from the glTF\n  this._gltfCredits = [];\n\n  this._showCreditsOnScreen = defaultValue(options.showCreditsOnScreen, false);\n\n  /**\n   * Determines if the model primitive will be shown.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The silhouette color.\n   *\n   * @type {Color}\n   *\n   * @default Color.RED\n   */\n  this.silhouetteColor = defaultValue(options.silhouetteColor, Color.RED);\n  this._silhouetteColor = new Color();\n  this._silhouetteColorPreviousAlpha = 1.0;\n  this._normalAttributeName = undefined;\n\n  /**\n   * The size of the silhouette in pixels.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n  this.silhouetteSize = defaultValue(options.silhouetteSize, 0.0);\n\n  /**\n   * The 4x4 transformation matrix that transforms the model from model to world coordinates.\n   * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   *\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n  this._clampedModelMatrix = undefined;\n\n  /**\n   * A uniform scale applied to this model before the {@link Model#modelMatrix}.\n   * Values greater than <code>1.0</code> increase the size of the model; values\n   * less than <code>1.0</code> decrease.\n   *\n   * @type {Number}\n   *\n   * @default 1.0\n   */\n  this.scale = defaultValue(options.scale, 1.0);\n  this._scale = this.scale;\n\n  /**\n   * The approximate minimum pixel size of the model regardless of zoom.\n   * This can be used to ensure that a model is visible even when the viewer\n   * zooms out.  When <code>0.0</code>, no minimum size is enforced.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n  this.minimumPixelSize = defaultValue(options.minimumPixelSize, 0.0);\n  this._minimumPixelSize = this.minimumPixelSize;\n\n  /**\n   * The maximum scale size for a model. This can be used to give\n   * an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model\n   * is never an unreasonable scale.\n   *\n   * @type {Number}\n   */\n  this.maximumScale = options.maximumScale;\n  this._maximumScale = this.maximumScale;\n\n  /**\n   * User-defined object returned when the model is picked.\n   *\n   * @type Object\n   *\n   * @default undefined\n   *\n   * @see Scene#pick\n   */\n  this.id = options.id;\n  this._id = options.id;\n\n  /**\n   * Returns the height reference of the model\n   *\n   * @type {HeightReference}\n   *\n   * @default HeightReference.NONE\n   */\n  this.heightReference = defaultValue(\n    options.heightReference,\n    HeightReference.NONE\n  );\n  this._heightReference = this.heightReference;\n  this._heightChanged = false;\n  this._removeUpdateHeightCallback = undefined;\n  const scene = options.scene;\n  this._scene = scene;\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._terrainProviderChangedCallback = scene.terrainProviderChanged.addEventListener(\n      function () {\n        this._heightChanged = true;\n      },\n      this\n    );\n  }\n\n  /**\n   * Used for picking primitives that wrap a model.\n   *\n   * @private\n   */\n  this._pickObject = options.pickObject;\n  this._allowPicking = defaultValue(options.allowPicking, true);\n\n  this._ready = false;\n  this._readyPromise = defer();\n\n  /**\n   * The currently playing glTF animations.\n   *\n   * @type {ModelAnimationCollection}\n   */\n  this.activeAnimations = new ModelAnimationCollection(this);\n\n  /**\n   * Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n   *\n   * @type {Boolean}\n   */\n  this.clampAnimations = defaultValue(options.clampAnimations, true);\n\n  this._defaultTexture = undefined;\n  this._incrementallyLoadTextures = defaultValue(\n    options.incrementallyLoadTextures,\n    true\n  );\n  this._asynchronous = defaultValue(options.asynchronous, true);\n\n  /**\n   * Determines whether the model casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.ENABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n\n  /**\n   * A color that blends with the model's rendered color.\n   *\n   * @type {Color}\n   *\n   * @default Color.WHITE\n   */\n  this.color = Color.clone(defaultValue(options.color, Color.WHITE));\n  this._colorPreviousAlpha = 1.0;\n\n  /**\n   * Defines how the color blends with the model.\n   *\n   * @type {ColorBlendMode}\n   *\n   * @default ColorBlendMode.HIGHLIGHT\n   */\n  this.colorBlendMode = defaultValue(\n    options.colorBlendMode,\n    ColorBlendMode.HIGHLIGHT\n  );\n\n  /**\n   * Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>.\n   * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with\n   * any value in-between resulting in a mix of the two.\n   *\n   * @type {Number}\n   *\n   * @default 0.5\n   */\n  this.colorBlendAmount = defaultValue(options.colorBlendAmount, 0.5);\n\n  this._colorShadingEnabled = false;\n\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes;\n  // Used for checking if shaders need to be regenerated due to clipping plane changes.\n  this._clippingPlanesState = 0;\n\n  // If defined, use this matrix to transform miscellaneous properties like\n  // clipping planes and IBL instead of the modelMatrix. This is so that when\n  // models are part of a tileset these properties get transformed relative to\n  // a common reference (such as the root).\n  this.referenceMatrix = undefined;\n\n  /**\n   * Whether to cull back-facing geometry. When true, back face culling is\n   * determined by the material's doubleSided property; when false, back face\n   * culling is disabled. Back faces are not culled if {@link Model#color} is\n   * translucent or {@link Model#silhouetteSize} is greater than 0.0.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.backFaceCulling = defaultValue(options.backFaceCulling, true);\n\n  /**\n   * Whether to display the outline for models using the\n   * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension.\n   * When true, outlines are displayed. When false, outlines are not displayed.\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  this.showOutline = defaultValue(options.showOutline, true);\n\n  /**\n   * The {@link SplitDirection} to apply to this model.\n   *\n   * @type {SplitDirection}\n   * @default {@link SplitDirection.NONE}\n   */\n  this.splitDirection = defaultValue(\n    options.splitDirection,\n    SplitDirection.NONE\n  );\n  this._splittingEnabled = false;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds\n   * to one draw command.  A glTF mesh has an array of primitives, often of length one.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n  this._debugShowBoundingVolume = false;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the model in wireframe.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n\n  this._distanceDisplayCondition = options.distanceDisplayCondition;\n\n  // Undocumented options\n  this._addBatchIdToGeneratedShaders = options.addBatchIdToGeneratedShaders;\n  this._precreatedAttributes = options.precreatedAttributes;\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._ignoreCommands = defaultValue(options.ignoreCommands, false);\n  this._requestType = options.requestType;\n  this._upAxis = defaultValue(options.upAxis, Axis.Y);\n  this._gltfForwardAxis = Axis.Z;\n  this._forwardAxis = options.forwardAxis;\n\n  /**\n   * @private\n   * @readonly\n   */\n  this.cull = defaultValue(options.cull, true);\n\n  /**\n   * @private\n   * @readonly\n   */\n  this.opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n\n  this._computedModelMatrix = new Matrix4(); // Derived from modelMatrix and scale\n  this._clippingPlanesMatrix = Matrix4.clone(Matrix4.IDENTITY); // Derived from reference matrix and the current view matrix\n  this._iblReferenceFrameMatrix = Matrix3.clone(Matrix3.IDENTITY); // Derived from reference matrix and the current view matrix\n  this._initialRadius = undefined; // Radius without model's scale property, model-matrix scale, animations, or skins\n  this._boundingSphere = undefined;\n  this._scaledBoundingSphere = new BoundingSphere();\n  this._state = ModelState.NEEDS_LOAD;\n  this._loadResources = undefined;\n\n  this._mode = undefined;\n\n  this._perNodeShowDirty = false; // true when the Cesium API was used to change a node's show property\n  this._cesiumAnimationsDirty = false; // true when the Cesium API, not a glTF animation, changed a node transform\n  this._dirty = false; // true when the model was transformed this frame\n  this._maxDirtyNumber = 0; // Used in place of a dirty boolean flag to avoid an extra graph traversal\n\n  this._runtime = {\n    animations: undefined,\n    articulationsByName: undefined,\n    articulationsByStageKey: undefined,\n    stagesByKey: undefined,\n    rootNodes: undefined,\n    nodes: undefined, // Indexed with the node's index\n    nodesByName: undefined, // Indexed with name property in the node\n    skinnedNodes: undefined,\n    meshesByName: undefined, // Indexed with the name property in the mesh\n    materialsByName: undefined, // Indexed with the name property in the material\n    materialsById: undefined, // Indexed with the material's index\n  };\n\n  this._uniformMaps = {}; // Not cached since it can be targeted by glTF animation\n  this._extensionsUsed = undefined; // Cached used glTF extensions\n  this._extensionsRequired = undefined; // Cached required glTF extensions\n  this._quantizedUniforms = {}; // Quantized uniforms for each program for WEB3D_quantized_attributes\n  this._programPrimitives = {};\n  this._rendererResources = {\n    // Cached between models with the same url/cache-key\n    buffers: {},\n    vertexArrays: {},\n    programs: {},\n    sourceShaders: {},\n    silhouettePrograms: {},\n    textures: {},\n    samplers: {},\n    renderStates: {},\n  };\n  this._cachedRendererResources = undefined;\n  this._loadRendererResourcesFromCache = false;\n\n  if (options.dequantizeInShader) {\n    deprecationWarning(\n      \"Model.dequantizeInShader\",\n      \"The Model dequantizeInShader constructor parameter was deprecated in CesiumJS 1.94 and will be removed in 1.95\"\n    );\n  }\n\n  this._dequantizeInShader = defaultValue(options.dequantizeInShader, true);\n  this._decodedData = {};\n\n  this._cachedGeometryByteLength = 0;\n  this._cachedTexturesByteLength = 0;\n  this._geometryByteLength = 0;\n  this._texturesByteLength = 0;\n  this._trianglesLength = 0;\n  this._pointsLength = 0;\n\n  // Hold references for shader reconstruction.\n  // Hold these separately because _cachedGltf may get released (this.releaseGltfJson)\n  this._sourceTechniques = {};\n  this._sourcePrograms = {};\n  this._quantizedVertexShaders = {};\n\n  this._nodeCommands = [];\n  this._pickIds = [];\n\n  // CESIUM_RTC extension\n  this._rtcCenter = undefined; // reference to either 3D or 2D\n  this._rtcCenterEye = undefined; // in eye coordinates\n  this._rtcCenter3D = undefined; // in world coordinates\n  this._rtcCenter2D = undefined; // in projected world coordinates\n\n  this._sourceVersion = undefined;\n  this._sourceKHRTechniquesWebGL = undefined;\n\n  this._lightColor = Cartesian3.clone(options.lightColor);\n\n  if (defined(options.imageBasedLighting)) {\n    this._imageBasedLighting = options.imageBasedLighting;\n    this._shouldDestroyImageBasedLighting = false;\n  } else {\n    this._imageBasedLighting = new ImageBasedLighting();\n    this._shouldDestroyImageBasedLighting = true;\n  }\n\n  this._shouldRegenerateShaders = false;\n}\n\nObject.defineProperties(Model.prototype, {\n  /**\n   * The object for the glTF JSON, including properties with default values omitted\n   * from the JSON provided to this model.\n   *\n   * @deprecated\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  gltf: {\n    get: function () {\n      deprecationWarning(\n        \"Model.gltf\",\n        \"Model.gltf getter was deprecated in CesiumJS 1.94 and will be removed in 1.95\"\n      );\n\n      return this.gltfInternal;\n    },\n  },\n\n  /**\n   * See https://github.com/CesiumGS/cesium/pull/10415#issuecomment-1143600984\n   * @private\n   */\n  gltfInternal: {\n    get: function () {\n      return defined(this._cachedGltf) ? this._cachedGltf.gltf : undefined;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the glTF JSON is not stored with the model once the model is\n   * loaded (when {@link Model#ready} is <code>true</code>).  This saves memory when\n   * geometry, textures, and animations are embedded in the .gltf file.\n   * This is especially useful for cases like 3D buildings, where each .gltf model is unique\n   * and caching the glTF JSON is not effective.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   *\n   * @private\n   */\n  releaseGltfJson: {\n    get: function () {\n      return this._releaseGltfJson;\n    },\n  },\n\n  /**\n   * The key identifying this model in the model cache for glTF JSON, renderer resources, and animations.\n   * Caching saves memory and improves loading speed when several models with the same url are created.\n   * <p>\n   * This key is automatically generated when the model is created with {@link Model.fromGltf}.  If the model\n   * is created directly from glTF JSON using the {@link Model} constructor, this key can be manually\n   * provided; otherwise, the model will not be changed.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n\n  /**\n   * The base path that paths in the glTF JSON are relative to.  The base\n   * path is the same path as the path containing the .gltf file\n   * minus the .gltf file, when binary, image, and shader files are\n   * in the same directory as the .gltf.  When this is <code>''</code>,\n   * the app's base path is used.\n   *\n   * @deprecated\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @default ''\n   */\n  basePath: {\n    get: function () {\n      deprecationWarning(\n        \"model.basePath\",\n        \"Model.basePath getter is deprecated in CesiumJS 1.94. It will be removed in CesiumJS 1.95\"\n      );\n      return this.basePathInternal;\n    },\n  },\n\n  /**\n   * See https://github.com/CesiumGS/cesium/pull/10415#issuecomment-1143600984\n   * @private\n   */\n  basePathInternal: {\n    get: function () {\n      return this._resource.url;\n    },\n  },\n\n  /**\n   * The model's bounding sphere in its local coordinate system.  This does not take into\n   * account glTF animations and skins nor does it take into account {@link Model#minimumPixelSize}.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @default undefined\n   *\n   * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n   *\n   * @example\n   * // Center in WGS84 coordinates\n   * const center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());\n   */\n  boundingSphere: {\n    get: function () {\n      deprecationWarning(\n        \"model.boundingSphere\",\n        \"Model.boundingSphere currently returns results in model space. In CesiumJS 1.95, model.boundingSphere will be changed to return results in world space. The calling code will no longer need to multiply the bounding sphere by the model matrix\"\n      );\n      return this.boundingSphereInternal;\n    },\n  },\n\n  /*\n   * See https://github.com/CesiumGS/cesium/pull/10415#issuecomment-1143600984\n   * @private\n   */\n  boundingSphereInternal: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (this._state !== ModelState.LOADED) {\n        throw new DeveloperError(\n          \"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      let modelMatrix = this.modelMatrix;\n      if (\n        this.heightReference !== HeightReference.NONE &&\n        this._clampedModelMatrix\n      ) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      const nonUniformScale = Matrix4.getScale(\n        modelMatrix,\n        boundingSphereCartesian3Scratch\n      );\n      const scale = defined(this.maximumScale)\n        ? Math.min(this.maximumScale, this.scale)\n        : this.scale;\n      Cartesian3.multiplyByScalar(nonUniformScale, scale, nonUniformScale);\n\n      const scaledBoundingSphere = this._scaledBoundingSphere;\n      scaledBoundingSphere.center = Cartesian3.multiplyComponents(\n        this._boundingSphere.center,\n        nonUniformScale,\n        scaledBoundingSphere.center\n      );\n      scaledBoundingSphere.radius =\n        Cartesian3.maximumComponent(nonUniformScale) * this._initialRadius;\n\n      if (defined(this._rtcCenter)) {\n        Cartesian3.add(\n          this._rtcCenter,\n          scaledBoundingSphere.center,\n          scaledBoundingSphere.center\n        );\n      }\n\n      return scaledBoundingSphere;\n    },\n  },\n\n  /**\n   * When <code>true</code>, this model is ready to render, i.e., the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.  This is set to\n   * <code>true</code> right before {@link Model#readyPromise} is resolved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.\n   * <p>\n   * This promise is resolved at the end of the frame before the first frame the model is rendered in.\n   * </p>\n   *\n   * @memberof Model.prototype\n   * @type {Promise.<Model>}\n   * @readonly\n   *\n   * @example\n   * // Play all animations at half-speed when the model is ready to render\n   * Promise.resolve(model.readyPromise).then(function(model) {\n   *   model.activeAnimations.addAll({\n   *     multiplier : 0.5\n   *   });\n   * }).catch(function(error){\n   *   window.alert(error);\n   * });\n   *\n   * @see Model#ready\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Determines if model WebGL resource creation will be spread out over several frames or\n   * block until completion once all glTF files are loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n\n  /**\n   * Determine if textures may continue to stream in after the model is loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  incrementallyLoadTextures: {\n    get: function () {\n      return this._incrementallyLoadTextures;\n    },\n  },\n\n  /**\n   * Return the number of pending texture loads.\n   *\n   * @deprecated\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pendingTextureLoads: {\n    get: function () {\n      deprecationWarning(\n        \"Model.pendingTextureLoads\",\n        \"The Model.pendingTextureLoads getter was deprecated in CesiumJS 1.94 and will be removed in CesiumJS 1.95\"\n      );\n\n      return this.pendingTextureLoadsInternal;\n    },\n  },\n\n  /**\n   * See https://github.com/CesiumGS/cesium/pull/10415#issuecomment-1143600984\n   * @private\n   */\n  pendingTextureLoadsInternal: {\n    get: function () {\n      return defined(this._loadResources)\n        ? this._loadResources.pendingTextureLoads\n        : 0;\n    },\n  },\n\n  /**\n   * Returns true if the model was transformed this frame\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  dirty: {\n    get: function () {\n      return this._dirty;\n    },\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this model will be displayed.\n   * @memberof Model.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      }\n      //>>includeEnd('debug');\n      this._distanceDisplayCondition = DistanceDisplayCondition.clone(\n        value,\n        this._distanceDisplayCondition\n      );\n    },\n  },\n\n  extensionsUsed: {\n    get: function () {\n      if (!defined(this._extensionsUsed)) {\n        this._extensionsUsed = ModelUtility.getUsedExtensions(\n          this.gltfInternal\n        );\n      }\n      return this._extensionsUsed;\n    },\n  },\n\n  extensionsRequired: {\n    get: function () {\n      if (!defined(this._extensionsRequired)) {\n        this._extensionsRequired = ModelUtility.getRequiredExtensions(\n          this.gltfInternal\n        );\n      }\n      return this._extensionsRequired;\n    },\n  },\n\n  /**\n   * Gets the model's up-axis.\n   * By default models are y-up according to the glTF spec, however geo-referenced models will typically be z-up.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Y\n   * @readonly\n   *\n   * @private\n   */\n  upAxis: {\n    get: function () {\n      return this._upAxis;\n    },\n  },\n\n  /**\n   * Gets the model's forward axis.\n   * By default, glTF 2.0 models are z-forward according to the glTF spec, however older\n   * glTF (1.0, 0.8) models used x-forward.  Note that only Axis.X and Axis.Z are supported.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Z\n   * @readonly\n   *\n   * @private\n   */\n  forwardAxis: {\n    get: function () {\n      if (defined(this._forwardAxis)) {\n        return this._forwardAxis;\n      }\n      return this._gltfForwardAxis;\n    },\n  },\n\n  /**\n   * Gets the model's triangle count.\n   *\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the model's point count.\n   *\n   * @private\n   */\n  pointsLength: {\n    get: function () {\n      return this._pointsLength;\n    },\n  },\n\n  /**\n   * Gets the model's geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's texture memory in bytes.\n   *\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return this._texturesByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's cached geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  cachedGeometryByteLength: {\n    get: function () {\n      return this._cachedGeometryByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's cached texture memory in bytes.\n   *\n   * @private\n   */\n  cachedTexturesByteLength: {\n    get: function () {\n      return this._cachedTexturesByteLength;\n    },\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      if (value === this._clippingPlanes) {\n        return;\n      }\n      // Handle destroying, checking of unknown, checking for existing ownership\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickIds: {\n    get: function () {\n      return this._pickIds;\n    },\n  },\n\n  /**\n   * The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n   * <p>\n   * For example, disabling additional light sources by setting\n   * <code>model.imageBasedLighting.imageBasedLightingFactor = new Cesium.Cartesian2(0.0, 0.0)</code>\n   * will make the model much darker. Here, increasing the intensity of the light source will make the model brighter.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    },\n    set: function (value) {\n      const lightColor = this._lightColor;\n      if (value === lightColor || Cartesian3.equals(value, lightColor)) {\n        return;\n      }\n      this._shouldRegenerateShaders =\n        this._shouldRegenerateShaders ||\n        (defined(lightColor) && !defined(value)) ||\n        (defined(value) && !defined(lightColor));\n      this._lightColor = Cartesian3.clone(value, lightColor);\n    },\n  },\n\n  /**\n   * The properties for managing image-based lighting on this model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {ImageBasedLighting}\n   */\n  imageBasedLighting: {\n    get: function () {\n      return this._imageBasedLighting;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLighting\", this._imageBasedLighting);\n      //>>includeEnd('debug');\n\n      if (value !== this._imageBasedLighting) {\n        if (\n          this._shouldDestroyImageBasedLighting &&\n          !this._imageBasedLighting.isDestroyed()\n        ) {\n          this._imageBasedLighting.destroy();\n        }\n        this._imageBasedLighting = value;\n        this._shouldDestroyImageBasedLighting = false;\n        this._shouldRegenerateShaders = true;\n      }\n    },\n  },\n\n  /**\n   * Gets the credit that will be displayed for the model\n   * @memberof Model.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets or sets whether the credits of the model will be displayed on the screen\n   * @memberof Model.prototype\n   * @type {Boolean}\n   */\n  showCreditsOnScreen: {\n    get: function () {\n      return this._showCreditsOnScreen;\n    },\n    set: function (value) {\n      if (this._showCreditsOnScreen !== value) {\n        if (defined(this._credit)) {\n          this._credit.showOnScreen = value;\n        }\n\n        const resourceCreditsLength = this._resourceCredits.length;\n        for (let i = 0; i < resourceCreditsLength; i++) {\n          this._resourceCredits[i].showOnScreen = value;\n        }\n\n        const gltfCreditsLength = this._gltfCredits.length;\n        for (let i = 0; i < gltfCreditsLength; i++) {\n          this._gltfCredits[i].showOnScreen = value;\n        }\n      }\n\n      this._showCreditsOnScreen = value;\n    },\n  },\n});\n\nfunction silhouetteSupported(context) {\n  return context.stencilBuffer;\n}\n\nfunction isColorShadingEnabled(model) {\n  return (\n    !Color.equals(model.color, Color.WHITE) ||\n    model.colorBlendMode !== ColorBlendMode.HIGHLIGHT\n  );\n}\n\nfunction isClippingEnabled(model) {\n  const clippingPlanes = model._clippingPlanes;\n  return (\n    defined(clippingPlanes) &&\n    clippingPlanes.enabled &&\n    clippingPlanes.length !== 0\n  );\n}\n\n/**\n * Determines if silhouettes are supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if silhouettes are supported; otherwise, returns <code>false</code>\n */\nModel.silhouetteSupported = function (scene) {\n  return silhouetteSupported(scene.context);\n};\n\nfunction containsGltfMagic(uint8Array) {\n  const magic = getMagic(uint8Array);\n  return magic === \"glTF\";\n}\n\n/**\n * <p>\n * Creates a model from a glTF asset.  When the model is ready to render, i.e., when the external binary, image,\n * and shader files are downloaded and the WebGL resources are created, the {@link Model#readyPromise} is resolved.\n * </p>\n * <p>\n * The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the .glb extension.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_basisu/README.md|KHR_texture_basisu}\n * </li>\n * </ul>\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url to the .gltf file.\n * @param {Resource|String} [options.basePath] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale for the model.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models. Deprecated in CesiumJS 1.94, will be removed in CesiumJS 1.95.\n * @param {Cartesian3} [options.lightColor] The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n * @param {ImageBasedLighting} [options.imageBasedLighting] The properties for managing image-based lighting for this tileset.\n * @param {Credit|String} [options.credit] A credit for the model, which is displayed on the canvas.\n * @param {Boolean} [options.showCreditsOnScreen=false] Whether to display the credits of this model on screen.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the material's doubleSided property; when false, back face culling is disabled. Back faces are not culled if {@link Model#color} is translucent or {@link Model#silhouetteSize} is greater than 0.0.\n * @param {Boolean} [options.showOutline=true] Whether to display the outline for models using the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. When true, outlines are displayed. When false, outlines are not displayed.\n * @returns {Model} The newly created model.\n *\n * @example\n * // Example 1. Create a model from a glTF asset\n * const model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf'\n * }));\n *\n * @example\n * // Example 2. Create model and provide all properties and events\n * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n * const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n *\n * const model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf',\n *   show : true,                     // default\n *   modelMatrix : modelMatrix,\n *   scale : 2.0,                     // double size\n *   minimumPixelSize : 128,          // never smaller than 128 pixels\n *   maximumScale: 20000,             // never larger than 20000 * model size (overrides minimumPixelSize)\n *   allowPicking : false,            // not pickable\n *   debugShowBoundingVolume : false, // default\n *   debugWireframe : false\n * }));\n *\n * model.readyPromise.then(function(model) {\n *   // Play all animations when the model is ready to render\n *   model.activeAnimations.addAll();\n * });\n */\nModel.fromGltf = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.url)) {\n    throw new DeveloperError(\"options.url is required\");\n  }\n  //>>includeEnd('debug');\n\n  const url = options.url;\n  options = clone(options);\n\n  // Create resource for the model file\n  const modelResource = Resource.createIfNeeded(url);\n\n  // Setup basePath to get dependent files\n  const basePath = defaultValue(options.basePath, modelResource.clone());\n  const resource = Resource.createIfNeeded(basePath);\n\n  // If no cache key is provided, use a GUID.\n  // Check using a URI to GUID dictionary that we have not already added this model.\n  let cacheKey = defaultValue(\n    options.cacheKey,\n    uriToGuid[getAbsoluteUri(modelResource.url)]\n  );\n  if (!defined(cacheKey)) {\n    cacheKey = createGuid();\n    uriToGuid[getAbsoluteUri(modelResource.url)] = cacheKey;\n  }\n\n  if (defined(options.basePath) && !defined(options.cacheKey)) {\n    cacheKey += resource.url;\n  }\n  options.cacheKey = cacheKey;\n  options.basePath = resource;\n\n  const model = new Model(options);\n\n  let cachedGltf = gltfCache[cacheKey];\n  if (!defined(cachedGltf)) {\n    cachedGltf = new CachedGltf({\n      ready: false,\n    });\n    cachedGltf.count = 1;\n    cachedGltf.modelsToLoad.push(model);\n    setCachedGltf(model, cachedGltf);\n    gltfCache[cacheKey] = cachedGltf;\n\n    // Add Accept header if we need it\n    if (!defined(modelResource.headers.Accept)) {\n      modelResource.headers.Accept = defaultModelAccept;\n    }\n\n    modelResource\n      .fetchArrayBuffer()\n      .then(function (arrayBuffer) {\n        const array = new Uint8Array(arrayBuffer);\n        if (containsGltfMagic(array)) {\n          // Load binary glTF\n          const parsedGltf = parseGlb(array);\n          cachedGltf.makeReady(parsedGltf);\n        } else {\n          // Load text (JSON) glTF\n          const json = getJsonFromTypedArray(array);\n          cachedGltf.makeReady(json);\n        }\n\n        const resourceCredits = model._resourceCredits;\n        const credits = modelResource.credits;\n        if (defined(credits)) {\n          const length = credits.length;\n          for (let i = 0; i < length; i++) {\n            resourceCredits.push(credits[i]);\n          }\n        }\n      })\n      .catch(\n        ModelUtility.getFailedLoadFunction(model, \"model\", modelResource.url)\n      );\n  } else if (!cachedGltf.ready) {\n    // Cache hit but the fetchArrayBuffer() or fetchText() request is still pending\n    ++cachedGltf.count;\n    cachedGltf.modelsToLoad.push(model);\n  }\n  // else if the cached glTF is defined and ready, the\n  // model constructor will pick it up using the cache key.\n\n  return model;\n};\n\n/**\n * For the unit tests to verify model caching.\n *\n * @private\n */\nModel._gltfCache = gltfCache;\n\nfunction getRuntime(model, runtimeName, name) {\n  //>>includeStart('debug', pragmas.debug);\n  if (model._state !== ModelState.LOADED) {\n    throw new DeveloperError(\n      \"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\"\n    );\n  }\n\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return model._runtime[runtimeName][name];\n}\n\n/**\n * Returns the glTF node with the given <code>name</code> property.  This is used to\n * modify a node's transform for animation outside of glTF animations.\n *\n * @param {String} name The glTF name of the node.\n * @returns {ModelNode} The node or <code>undefined</code> if no node with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @example\n * // Apply non-uniform scale to node LOD3sp\n * const node = model.getNode('LOD3sp');\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n */\nModel.prototype.getNode = function (name) {\n  const node = getRuntime(this, \"nodesByName\", name);\n  return defined(node) ? node.publicNode : undefined;\n};\n\n/**\n * Returns the glTF mesh with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the mesh.\n *\n * @returns {ModelMesh} The mesh or <code>undefined</code> if no mesh with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\nModel.prototype.getMesh = function (name) {\n  return getRuntime(this, \"meshesByName\", name);\n};\n\n/**\n * Returns the glTF material with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the material.\n * @returns {ModelMaterial} The material or <code>undefined</code> if no material with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\nModel.prototype.getMaterial = function (name) {\n  return getRuntime(this, \"materialsByName\", name);\n};\n\n/**\n * Sets the current value of an articulation stage.  After setting one or multiple stage values, call\n * Model.applyArticulations() to cause the node matrices to be recalculated.\n *\n * @param {String} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {Number} value The numeric value of this stage of the articulation.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @see Model#applyArticulations\n */\nModel.prototype.setArticulationStage = function (articulationStageKey, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  const stage = getRuntime(this, \"stagesByKey\", articulationStageKey);\n  const articulation = getRuntime(\n    this,\n    \"articulationsByStageKey\",\n    articulationStageKey\n  );\n  if (defined(stage) && defined(articulation)) {\n    value = CesiumMath.clamp(value, stage.minimumValue, stage.maximumValue);\n    if (\n      !CesiumMath.equalsEpsilon(stage.currentValue, value, articulationEpsilon)\n    ) {\n      stage.currentValue = value;\n      articulation.isDirty = true;\n    }\n  }\n};\n\nconst scratchArticulationCartesian = new Cartesian3();\nconst scratchArticulationRotation = new Matrix3();\n\n/**\n * Modifies a Matrix4 by applying a transformation for a given value of a stage.  Note this is different usage\n * from the typical <code>result</code> parameter, in that the incoming value of <code>result</code> is\n * meaningful.  Various stages of an articulation can be multiplied together, so their\n * transformations are all merged into a composite Matrix4 representing them all.\n *\n * @param {object} stage The stage of an articulation that is being evaluated.\n * @param {Matrix4} result The matrix to be modified.\n * @returns {Matrix4} A matrix transformed as requested by the articulation stage.\n *\n * @private\n */\nfunction applyArticulationStageMatrix(stage, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"stage\", stage);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  const value = stage.currentValue;\n  const cartesian = scratchArticulationCartesian;\n  let rotation;\n  switch (stage.type) {\n    case \"xRotate\":\n      rotation = Matrix3.fromRotationX(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation\n      );\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case \"yRotate\":\n      rotation = Matrix3.fromRotationY(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation\n      );\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case \"zRotate\":\n      rotation = Matrix3.fromRotationZ(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation\n      );\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case \"xTranslate\":\n      cartesian.x = value;\n      cartesian.y = 0.0;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case \"yTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = value;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case \"zTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = 0.0;\n      cartesian.z = value;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case \"xScale\":\n      cartesian.x = value;\n      cartesian.y = 1.0;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case \"yScale\":\n      cartesian.x = 1.0;\n      cartesian.y = value;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case \"zScale\":\n      cartesian.x = 1.0;\n      cartesian.y = 1.0;\n      cartesian.z = value;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case \"uniformScale\":\n      Matrix4.multiplyByUniformScale(result, value, result);\n      break;\n    default:\n      break;\n  }\n  return result;\n}\n\nconst scratchApplyArticulationTransform = new Matrix4();\n\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\nModel.prototype.applyArticulations = function () {\n  const articulationsByName = this._runtime.articulationsByName;\n  for (const articulationName in articulationsByName) {\n    if (articulationsByName.hasOwnProperty(articulationName)) {\n      const articulation = articulationsByName[articulationName];\n      if (articulation.isDirty) {\n        articulation.isDirty = false;\n        const numNodes = articulation.nodes.length;\n        for (let n = 0; n < numNodes; ++n) {\n          const node = articulation.nodes[n];\n          let transform = Matrix4.clone(\n            node.originalMatrix,\n            scratchApplyArticulationTransform\n          );\n\n          const numStages = articulation.stages.length;\n          for (let s = 0; s < numStages; ++s) {\n            const stage = articulation.stages[s];\n            transform = applyArticulationStageMatrix(stage, transform);\n          }\n          node.matrix = transform;\n        }\n      }\n    }\n  }\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction addBuffersToLoadResources(model) {\n  const gltf = model.gltfInternal;\n  const loadResources = model._loadResources;\n  ForEach.buffer(gltf, function (buffer, id) {\n    loadResources.buffers[id] = buffer.extras._pipeline.source;\n  });\n}\n\nfunction bufferLoad(model, id) {\n  return function (arrayBuffer) {\n    const loadResources = model._loadResources;\n    const buffer = new Uint8Array(arrayBuffer);\n    --loadResources.pendingBufferLoads;\n    model.gltfInternal.buffers[id].extras._pipeline.source = buffer;\n  };\n}\n\nfunction parseBufferViews(model) {\n  const bufferViews = model.gltfInternal.bufferViews;\n  const vertexBuffersToCreate = model._loadResources.vertexBuffersToCreate;\n\n  // Only ARRAY_BUFFER here.  ELEMENT_ARRAY_BUFFER created below.\n  ForEach.bufferView(model.gltfInternal, function (bufferView, id) {\n    if (bufferView.target === WebGLConstants.ARRAY_BUFFER) {\n      vertexBuffersToCreate.enqueue(id);\n    }\n  });\n\n  const indexBuffersToCreate = model._loadResources.indexBuffersToCreate;\n  const indexBufferIds = {};\n\n  // The Cesium Renderer requires knowing the datatype for an index buffer\n  // at creation type, which is not part of the glTF bufferview so loop\n  // through glTF accessors to create the bufferview's index buffer.\n  ForEach.accessor(model.gltfInternal, function (accessor) {\n    const bufferViewId = accessor.bufferView;\n    if (!defined(bufferViewId)) {\n      return;\n    }\n\n    const bufferView = bufferViews[bufferViewId];\n    if (\n      bufferView.target === WebGLConstants.ELEMENT_ARRAY_BUFFER &&\n      !defined(indexBufferIds[bufferViewId])\n    ) {\n      indexBufferIds[bufferViewId] = true;\n      indexBuffersToCreate.enqueue({\n        id: bufferViewId,\n        componentType: accessor.componentType,\n      });\n    }\n  });\n}\n\nfunction parseTechniques(model) {\n  // retain references to gltf techniques\n  const gltf = model.gltfInternal;\n  if (!usesExtension(gltf, \"KHR_techniques_webgl\")) {\n    return;\n  }\n\n  const sourcePrograms = model._sourcePrograms;\n  const sourceTechniques = model._sourceTechniques;\n  const programs = gltf.extensions.KHR_techniques_webgl.programs;\n\n  ForEach.technique(gltf, function (technique, techniqueId) {\n    sourceTechniques[techniqueId] = clone(technique);\n\n    const programId = technique.program;\n    if (!defined(sourcePrograms[programId])) {\n      sourcePrograms[programId] = clone(programs[programId]);\n    }\n  });\n}\n\nfunction shaderLoad(model, type, id) {\n  return function (source) {\n    const loadResources = model._loadResources;\n    loadResources.shaders[id] = {\n      source: source,\n      type: type,\n      bufferView: undefined,\n    };\n    --loadResources.pendingShaderLoads;\n    model._rendererResources.sourceShaders[id] = source;\n  };\n}\n\nfunction parseShaders(model) {\n  const gltf = model.gltfInternal;\n  const buffers = gltf.buffers;\n  const bufferViews = gltf.bufferViews;\n  const sourceShaders = model._rendererResources.sourceShaders;\n  ForEach.shader(gltf, function (shader, id) {\n    // Shader references either uri (external or base64-encoded) or bufferView\n    if (defined(shader.bufferView)) {\n      const bufferViewId = shader.bufferView;\n      const bufferView = bufferViews[bufferViewId];\n      const bufferId = bufferView.buffer;\n      const buffer = buffers[bufferId];\n      const source = getStringFromTypedArray(\n        buffer.extras._pipeline.source,\n        bufferView.byteOffset,\n        bufferView.byteLength\n      );\n      sourceShaders[id] = source;\n    } else if (defined(shader.extras._pipeline.source)) {\n      sourceShaders[id] = shader.extras._pipeline.source;\n    } else {\n      ++model._loadResources.pendingShaderLoads;\n\n      const shaderResource = model._resource.getDerivedResource({\n        url: shader.uri,\n      });\n\n      shaderResource\n        .fetchText()\n        .then(shaderLoad(model, shader.type, id))\n        .catch(\n          ModelUtility.getFailedLoadFunction(\n            model,\n            \"shader\",\n            shaderResource.url\n          )\n        );\n    }\n  });\n}\n\nfunction parsePrograms(model) {\n  const sourceTechniques = model._sourceTechniques;\n  for (const techniqueId in sourceTechniques) {\n    if (sourceTechniques.hasOwnProperty(techniqueId)) {\n      const technique = sourceTechniques[techniqueId];\n      model._loadResources.programsToCreate.enqueue({\n        programId: technique.program,\n        techniqueId: techniqueId,\n      });\n    }\n  }\n}\n\nfunction parseArticulations(model) {\n  const articulationsByName = {};\n  const articulationsByStageKey = {};\n  const runtimeStagesByKey = {};\n\n  model._runtime.articulationsByName = articulationsByName;\n  model._runtime.articulationsByStageKey = articulationsByStageKey;\n  model._runtime.stagesByKey = runtimeStagesByKey;\n\n  const gltf = model.gltfInternal;\n  if (\n    !usesExtension(gltf, \"AGI_articulations\") ||\n    !defined(gltf.extensions) ||\n    !defined(gltf.extensions.AGI_articulations)\n  ) {\n    return;\n  }\n\n  const gltfArticulations = gltf.extensions.AGI_articulations.articulations;\n  if (!defined(gltfArticulations)) {\n    return;\n  }\n\n  const numArticulations = gltfArticulations.length;\n  for (let i = 0; i < numArticulations; ++i) {\n    const articulation = clone(gltfArticulations[i]);\n    articulation.nodes = [];\n    articulation.isDirty = true;\n    articulationsByName[articulation.name] = articulation;\n\n    const numStages = articulation.stages.length;\n    for (let s = 0; s < numStages; ++s) {\n      const stage = articulation.stages[s];\n      stage.currentValue = stage.initialValue;\n\n      const stageKey = `${articulation.name} ${stage.name}`;\n      articulationsByStageKey[stageKey] = articulation;\n      runtimeStagesByKey[stageKey] = stage;\n    }\n  }\n}\n\nfunction imageLoad(model, textureId) {\n  return function (image) {\n    const loadResources = model._loadResources;\n    --loadResources.pendingTextureLoads;\n\n    // Images transcoded from KTX2 can contain multiple mip levels:\n    // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n    let mipLevels;\n    if (Array.isArray(image)) {\n      // highest detail mip should be level 0\n      mipLevels = image.slice(1, image.length).map(function (mipLevel) {\n        return mipLevel.bufferView;\n      });\n      image = image[0];\n    }\n\n    loadResources.texturesToCreate.enqueue({\n      id: textureId,\n      image: image,\n      bufferView: image.bufferView,\n      width: image.width,\n      height: image.height,\n      internalFormat: image.internalFormat,\n      mipLevels: mipLevels,\n    });\n  };\n}\n\nconst ktx2Regex = /(^data:image\\/ktx2)|(\\.ktx2$)/i;\n\nfunction parseTextures(model, context, supportsWebP) {\n  const gltf = model.gltfInternal;\n  const images = gltf.images;\n  let uri;\n  ForEach.texture(gltf, function (texture, id) {\n    let imageId = texture.source;\n\n    if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.EXT_texture_webp) &&\n      supportsWebP\n    ) {\n      imageId = texture.extensions.EXT_texture_webp.source;\n    } else if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.KHR_texture_basisu) &&\n      context.supportsBasis\n    ) {\n      imageId = texture.extensions.KHR_texture_basisu.source;\n    }\n\n    const gltfImage = images[imageId];\n\n    const bufferViewId = gltfImage.bufferView;\n    const mimeType = gltfImage.mimeType;\n    uri = gltfImage.uri;\n\n    // Image references either uri (external or base64-encoded) or bufferView\n    if (defined(bufferViewId)) {\n      model._loadResources.texturesToCreateFromBufferView.enqueue({\n        id: id,\n        image: undefined,\n        bufferView: bufferViewId,\n        mimeType: mimeType,\n      });\n    } else {\n      ++model._loadResources.pendingTextureLoads;\n\n      const imageResource = model._resource.getDerivedResource({\n        url: uri,\n      });\n\n      let promise;\n      if (ktx2Regex.test(uri)) {\n        promise = loadKTX2(imageResource);\n      } else {\n        promise = imageResource.fetchImage({\n          skipColorSpaceConversion: true,\n          preferImageBitmap: true,\n        });\n      }\n      promise\n        .then(imageLoad(model, id, imageId))\n        .catch(\n          ModelUtility.getFailedLoadFunction(model, \"image\", imageResource.url)\n        );\n    }\n  });\n}\n\nconst scratchArticulationStageInitialTransform = new Matrix4();\n\nfunction parseNodes(model) {\n  const runtimeNodes = {};\n  const runtimeNodesByName = {};\n  const skinnedNodes = [];\n\n  const skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  const articulationsByName = model._runtime.articulationsByName;\n\n  ForEach.node(model.gltfInternal, function (node, id) {\n    const runtimeNode = {\n      // Animation targets\n      matrix: undefined,\n      translation: undefined,\n      rotation: undefined,\n      scale: undefined,\n\n      // Per-node show inherited from parent\n      computedShow: true,\n\n      // Computed transforms\n      transformToRoot: new Matrix4(),\n      computedMatrix: new Matrix4(),\n      dirtyNumber: 0, // The frame this node was made dirty by an animation; for graph traversal\n\n      // Rendering\n      commands: [], // empty for transform, light, and camera nodes\n\n      // Skinned node\n      inverseBindMatrices: undefined, // undefined when node is not skinned\n      bindShapeMatrix: undefined, // undefined when node is not skinned or identity\n      joints: [], // empty when node is not skinned\n      computedJointMatrices: [], // empty when node is not skinned\n\n      // Joint node\n      jointName: node.jointName, // undefined when node is not a joint\n\n      weights: [],\n\n      // Graph pointers\n      children: [], // empty for leaf nodes\n      parents: [], // empty for root nodes\n\n      // Publicly-accessible ModelNode instance to modify animation targets\n      publicNode: undefined,\n    };\n    runtimeNode.publicNode = new ModelNode(\n      model,\n      node,\n      runtimeNode,\n      id,\n      ModelUtility.getTransform(node)\n    );\n\n    runtimeNodes[id] = runtimeNode;\n    runtimeNodesByName[node.name] = runtimeNode;\n\n    if (defined(node.skin)) {\n      skinnedNodesIds.push(id);\n      skinnedNodes.push(runtimeNode);\n    }\n\n    if (\n      defined(node.extensions) &&\n      defined(node.extensions.AGI_articulations)\n    ) {\n      const articulationName =\n        node.extensions.AGI_articulations.articulationName;\n      if (defined(articulationName)) {\n        let transform = Matrix4.clone(\n          runtimeNode.publicNode.originalMatrix,\n          scratchArticulationStageInitialTransform\n        );\n        const articulation = articulationsByName[articulationName];\n        articulation.nodes.push(runtimeNode.publicNode);\n\n        const numStages = articulation.stages.length;\n        for (let s = 0; s < numStages; ++s) {\n          const stage = articulation.stages[s];\n          transform = applyArticulationStageMatrix(stage, transform);\n        }\n        runtimeNode.publicNode.matrix = transform;\n      }\n    }\n  });\n\n  model._runtime.nodes = runtimeNodes;\n  model._runtime.nodesByName = runtimeNodesByName;\n  model._runtime.skinnedNodes = skinnedNodes;\n}\n\nfunction parseMaterials(model) {\n  const gltf = model.gltfInternal;\n  const techniques = model._sourceTechniques;\n\n  const runtimeMaterialsByName = {};\n  const runtimeMaterialsById = {};\n  const uniformMaps = model._uniformMaps;\n\n  ForEach.material(gltf, function (material, materialId) {\n    // Allocated now so ModelMaterial can keep a reference to it.\n    uniformMaps[materialId] = {\n      uniformMap: undefined,\n      values: undefined,\n      jointMatrixUniformName: undefined,\n      morphWeightsUniformName: undefined,\n    };\n\n    const modelMaterial = new ModelMaterial(model, material, materialId);\n\n    if (\n      defined(material.extensions) &&\n      defined(material.extensions.KHR_techniques_webgl)\n    ) {\n      const techniqueId = material.extensions.KHR_techniques_webgl.technique;\n      modelMaterial._technique = techniqueId;\n      modelMaterial._program = techniques[techniqueId].program;\n\n      ForEach.materialValue(material, function (value, uniformName) {\n        if (!defined(modelMaterial._values)) {\n          modelMaterial._values = {};\n        }\n\n        modelMaterial._values[uniformName] = clone(value);\n      });\n    }\n\n    runtimeMaterialsByName[material.name] = modelMaterial;\n    runtimeMaterialsById[materialId] = modelMaterial;\n  });\n\n  model._runtime.materialsByName = runtimeMaterialsByName;\n  model._runtime.materialsById = runtimeMaterialsById;\n}\n\nfunction parseMeshes(model) {\n  const runtimeMeshesByName = {};\n  const runtimeMaterialsById = model._runtime.materialsById;\n\n  ForEach.mesh(model.gltfInternal, function (mesh, meshId) {\n    runtimeMeshesByName[mesh.name] = new ModelMesh(\n      mesh,\n      runtimeMaterialsById,\n      meshId\n    );\n    if (\n      defined(model.extensionsUsed.WEB3D_quantized_attributes) ||\n      model._dequantizeInShader\n    ) {\n      // Cache primitives according to their program\n      ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n        const programId = getProgramForPrimitive(model, primitive);\n        let programPrimitives = model._programPrimitives[programId];\n        if (!defined(programPrimitives)) {\n          programPrimitives = {};\n          model._programPrimitives[programId] = programPrimitives;\n        }\n        programPrimitives[`${meshId}.primitive.${primitiveId}`] = primitive;\n      });\n    }\n  });\n\n  model._runtime.meshesByName = runtimeMeshesByName;\n}\n\nfunction parseCredits(model) {\n  const asset = model.gltfInternal.asset;\n  const copyright = asset.copyright;\n  if (!defined(copyright)) {\n    return;\n  }\n\n  const showOnScreen = model._showCreditsOnScreen;\n  const credits = copyright.split(\";\").map(function (string) {\n    return new Credit(string.trim(), showOnScreen);\n  });\n\n  model._gltfCredits = credits;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nconst CreateVertexBufferJob = function () {\n  this.id = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateVertexBufferJob.prototype.set = function (id, model, context) {\n  this.id = id;\n  this.model = model;\n  this.context = context;\n};\n\nCreateVertexBufferJob.prototype.execute = function () {\n  createVertexBuffer(this.id, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createVertexBuffer(bufferViewId, model, context) {\n  const loadResources = model._loadResources;\n  const bufferViews = model.gltfInternal.bufferViews;\n  let bufferView = bufferViews[bufferViewId];\n\n  // Use bufferView created at runtime\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  const vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  vertexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = vertexBuffer;\n  model._geometryByteLength += vertexBuffer.sizeInBytes;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nconst CreateIndexBufferJob = function () {\n  this.id = undefined;\n  this.componentType = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateIndexBufferJob.prototype.set = function (\n  id,\n  componentType,\n  model,\n  context\n) {\n  this.id = id;\n  this.componentType = componentType;\n  this.model = model;\n  this.context = context;\n};\n\nCreateIndexBufferJob.prototype.execute = function () {\n  createIndexBuffer(this.id, this.componentType, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createIndexBuffer(bufferViewId, componentType, model, context) {\n  const loadResources = model._loadResources;\n  const bufferViews = model.gltfInternal.bufferViews;\n  let bufferView = bufferViews[bufferViewId];\n\n  // Use bufferView created at runtime\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  const indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: componentType,\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = indexBuffer;\n  model._geometryByteLength += indexBuffer.sizeInBytes;\n}\n\nconst scratchVertexBufferJob = new CreateVertexBufferJob();\nconst scratchIndexBufferJob = new CreateIndexBufferJob();\n\nfunction createBuffers(model, frameState) {\n  const loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  const context = frameState.context;\n  const vertexBuffersToCreate = loadResources.vertexBuffersToCreate;\n  const indexBuffersToCreate = loadResources.indexBuffersToCreate;\n  let i;\n\n  if (model.asynchronous) {\n    while (vertexBuffersToCreate.length > 0) {\n      scratchVertexBufferJob.set(vertexBuffersToCreate.peek(), model, context);\n      if (\n        !frameState.jobScheduler.execute(scratchVertexBufferJob, JobType.BUFFER)\n      ) {\n        break;\n      }\n      vertexBuffersToCreate.dequeue();\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.peek();\n      scratchIndexBufferJob.set(i.id, i.componentType, model, context);\n      if (\n        !frameState.jobScheduler.execute(scratchIndexBufferJob, JobType.BUFFER)\n      ) {\n        break;\n      }\n      indexBuffersToCreate.dequeue();\n    }\n  } else {\n    while (vertexBuffersToCreate.length > 0) {\n      createVertexBuffer(vertexBuffersToCreate.dequeue(), model, context);\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.dequeue();\n      createIndexBuffer(i.id, i.componentType, model, context);\n    }\n  }\n}\n\nfunction getProgramForPrimitive(model, primitive) {\n  const material = model._runtime.materialsById[primitive.material];\n  if (!defined(material)) {\n    return;\n  }\n\n  return material._program;\n}\n\nfunction modifyShaderForQuantizedAttributes(shader, programName, model) {\n  let primitive;\n  const primitives = model._programPrimitives[programName];\n\n  // If no primitives were cached for this program, there's no need to modify the shader\n  if (!defined(primitives)) {\n    return shader;\n  }\n\n  let primitiveId;\n  for (primitiveId in primitives) {\n    if (primitives.hasOwnProperty(primitiveId)) {\n      primitive = primitives[primitiveId];\n      if (getProgramForPrimitive(model, primitive) === programName) {\n        break;\n      }\n    }\n  }\n\n  // This is not needed after the program is processed, free the memory\n  model._programPrimitives[programName] = undefined;\n\n  let result;\n  if (model.extensionsUsed.WEB3D_quantized_attributes) {\n    result = ModelUtility.modifyShaderForQuantizedAttributes(\n      model.gltfInternal,\n      primitive,\n      shader\n    );\n    model._quantizedUniforms[programName] = result.uniforms;\n  } else {\n    const decodedData = model._decodedData[primitiveId];\n    if (defined(decodedData)) {\n      result = ModelUtility.modifyShaderForDracoQuantizedAttributes(\n        model.gltfInternal,\n        primitive,\n        shader,\n        decodedData.attributes\n      );\n    } else {\n      return shader;\n    }\n  }\n\n  return result.shader;\n}\n\nfunction modifyShaderForColor(shader) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_blend_main\");\n  shader +=\n    \"uniform vec4 gltf_color; \\n\" +\n    \"uniform float gltf_colorBlend; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gltf_blend_main(); \\n\" +\n    \"    gl_FragColor.rgb = mix(gl_FragColor.rgb, gltf_color.rgb, gltf_colorBlend); \\n\" +\n    \"    float highlight = ceil(gltf_colorBlend); \\n\" +\n    \"    gl_FragColor.rgb *= mix(gltf_color.rgb, vec3(1.0), highlight); \\n\" +\n    \"    gl_FragColor.a *= gltf_color.a; \\n\" +\n    \"} \\n\";\n\n  return shader;\n}\n\nfunction modifyShader(shader, programName, callback) {\n  if (defined(callback)) {\n    shader = callback(shader, programName);\n  }\n  return shader;\n}\n\nconst CreateProgramJob = function () {\n  this.programToCreate = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateProgramJob.prototype.set = function (programToCreate, model, context) {\n  this.programToCreate = programToCreate;\n  this.model = model;\n  this.context = context;\n};\n\nCreateProgramJob.prototype.execute = function () {\n  createProgram(this.programToCreate, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\n// When building programs for the first time, do not include modifiers for clipping planes and color\n// since this is the version of the program that will be cached for use with other Models.\nfunction createProgram(programToCreate, model, context) {\n  const programId = programToCreate.programId;\n  const techniqueId = programToCreate.techniqueId;\n  const program = model._sourcePrograms[programId];\n  const shaders = model._rendererResources.sourceShaders;\n\n  let vs = shaders[program.vertexShader];\n  const fs = shaders[program.fragmentShader];\n\n  const quantizedVertexShaders = model._quantizedVertexShaders;\n\n  if (\n    model.extensionsUsed.WEB3D_quantized_attributes ||\n    model._dequantizeInShader\n  ) {\n    let quantizedVS = quantizedVertexShaders[programId];\n    if (!defined(quantizedVS)) {\n      quantizedVS = modifyShaderForQuantizedAttributes(vs, programId, model);\n      quantizedVertexShaders[programId] = quantizedVS;\n    }\n    vs = quantizedVS;\n  }\n\n  const drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  let drawFS = modifyShader(fs, programId, model._fragmentShaderLoaded);\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = `uniform vec4 czm_pickColor;\\n${drawFS}`;\n  }\n\n  const imageBasedLighting = model._imageBasedLighting;\n  const useIBL = imageBasedLighting.enabled;\n  if (useIBL) {\n    drawFS = `#define USE_IBL_LIGHTING \\n\\n${drawFS}`;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = `#define USE_CUSTOM_LIGHT_COLOR \\n\\n${drawFS}`;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS =\n      `${drawFS}\\n` +\n      `void main() { \\n` +\n      `    non_gamma_corrected_main(); \\n` +\n      `    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n` +\n      `} \\n`;\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    const useSHC = imageBasedLighting.useSphericalHarmonicCoefficients;\n    const useSEM = imageBasedLighting.useSpecularEnvironmentMaps;\n    const addMatrix = useSHC || useSEM || useIBL;\n    if (addMatrix) {\n      drawFS = `uniform mat3 gltf_iblReferenceFrameMatrix; \\n${drawFS}`;\n    }\n\n    if (defined(imageBasedLighting.sphericalHarmonicCoefficients)) {\n      drawFS = `${\n        \"#define DIFFUSE_IBL \\n\" +\n        \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" +\n        \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\"\n      }${drawFS}`;\n    } else if (imageBasedLighting.useDefaultSphericalHarmonics) {\n      drawFS = `#define DIFFUSE_IBL \\n${drawFS}`;\n    }\n\n    if (\n      defined(imageBasedLighting.specularEnvironmentMapAtlas) &&\n      imageBasedLighting.specularEnvironmentMapAtlas.ready\n    ) {\n      drawFS = `${\n        \"#define SPECULAR_IBL \\n\" +\n        \"#define CUSTOM_SPECULAR_IBL \\n\" +\n        \"uniform sampler2D gltf_specularMap; \\n\" +\n        \"uniform vec2 gltf_specularMapSize; \\n\" +\n        \"uniform float gltf_maxSpecularLOD; \\n\"\n      }${drawFS}`;\n    } else if (imageBasedLighting.useDefaultSpecularMaps) {\n      drawFS = `#define SPECULAR_IBL \\n${drawFS}`;\n    }\n  }\n\n  if (defined(imageBasedLighting.luminanceAtZenith)) {\n    drawFS = `${\n      \"#define USE_SUN_LUMINANCE \\n\" + \"uniform float gltf_luminanceAtZenith;\\n\"\n    }${drawFS}`;\n  }\n\n  createAttributesAndProgram(\n    programId,\n    techniqueId,\n    drawFS,\n    drawVS,\n    model,\n    context\n  );\n}\n\nfunction recreateProgram(programToCreate, model, context) {\n  const programId = programToCreate.programId;\n  const techniqueId = programToCreate.techniqueId;\n  const program = model._sourcePrograms[programId];\n  const shaders = model._rendererResources.sourceShaders;\n\n  const quantizedVertexShaders = model._quantizedVertexShaders;\n\n  const clippingPlaneCollection = model.clippingPlanes;\n  const addClippingPlaneCode = isClippingEnabled(model);\n\n  let vs = shaders[program.vertexShader];\n  const fs = shaders[program.fragmentShader];\n\n  if (\n    model.extensionsUsed.WEB3D_quantized_attributes ||\n    model._dequantizeInShader\n  ) {\n    vs = quantizedVertexShaders[programId];\n  }\n\n  let finalFS = fs;\n  if (isColorShadingEnabled(model)) {\n    finalFS = Model._modifyShaderForColor(finalFS);\n  }\n  if (addClippingPlaneCode) {\n    finalFS = modifyShaderForClippingPlanes(\n      finalFS,\n      clippingPlaneCollection,\n      context\n    );\n  }\n\n  if (model.splitDirection !== SplitDirection.NONE) {\n    finalFS = Splitter.modifyFragmentShader(finalFS);\n  }\n\n  const drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  let drawFS = modifyShader(finalFS, programId, model._fragmentShaderLoaded);\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = `uniform vec4 czm_pickColor;\\n${drawFS}`;\n  }\n\n  const imageBasedLighting = model._imageBasedLighting;\n  const useIBL = imageBasedLighting.enabled;\n  if (useIBL) {\n    drawFS = `#define USE_IBL_LIGHTING \\n\\n${drawFS}`;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = `#define USE_CUSTOM_LIGHT_COLOR \\n\\n${drawFS}`;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS =\n      `${drawFS}\\n` +\n      `void main() { \\n` +\n      `    non_gamma_corrected_main(); \\n` +\n      `    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n` +\n      `} \\n`;\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    const useSHC = imageBasedLighting.useSphericalHarmonicCoefficients;\n    const useSEM = imageBasedLighting.useSpecularEnvironmentMaps;\n    const addMatrix = useSHC || useSEM || useIBL;\n    if (addMatrix) {\n      drawFS = `uniform mat3 gltf_iblReferenceFrameMatrix; \\n${drawFS}`;\n    }\n\n    if (defined(imageBasedLighting.sphericalHarmonicCoefficients)) {\n      drawFS = `${\n        \"#define DIFFUSE_IBL \\n\" +\n        \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" +\n        \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\"\n      }${drawFS}`;\n    } else if (imageBasedLighting.useDefaultSphericalHarmonics) {\n      drawFS = `#define DIFFUSE_IBL \\n${drawFS}`;\n    }\n\n    if (\n      defined(imageBasedLighting.specularEnvironmentMapAtlas) &&\n      imageBasedLighting.specularEnvironmentMapAtlas.ready\n    ) {\n      drawFS = `${\n        \"#define SPECULAR_IBL \\n\" +\n        \"#define CUSTOM_SPECULAR_IBL \\n\" +\n        \"uniform sampler2D gltf_specularMap; \\n\" +\n        \"uniform vec2 gltf_specularMapSize; \\n\" +\n        \"uniform float gltf_maxSpecularLOD; \\n\"\n      }${drawFS}`;\n    } else if (imageBasedLighting.useDefaultSpecularMaps) {\n      drawFS = `#define SPECULAR_IBL \\n${drawFS}`;\n    }\n  }\n\n  if (defined(imageBasedLighting.luminanceAtZenith)) {\n    drawFS = `${\n      \"#define USE_SUN_LUMINANCE \\n\" + \"uniform float gltf_luminanceAtZenith;\\n\"\n    }${drawFS}`;\n  }\n\n  createAttributesAndProgram(\n    programId,\n    techniqueId,\n    drawFS,\n    drawVS,\n    model,\n    context\n  );\n}\n\nfunction createAttributesAndProgram(\n  programId,\n  techniqueId,\n  drawFS,\n  drawVS,\n  model,\n  context\n) {\n  const technique = model._sourceTechniques[techniqueId];\n  const attributeLocations = ModelUtility.createAttributeLocations(\n    technique,\n    model._precreatedAttributes\n  );\n\n  model._rendererResources.programs[programId] = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: drawVS,\n    fragmentShaderSource: drawFS,\n    attributeLocations: attributeLocations,\n  });\n}\n\nconst scratchCreateProgramJob = new CreateProgramJob();\n\nfunction createPrograms(model, frameState) {\n  const loadResources = model._loadResources;\n  const programsToCreate = loadResources.programsToCreate;\n\n  if (loadResources.pendingShaderLoads !== 0) {\n    return;\n  }\n\n  // PERFORMANCE_IDEA: this could be more fine-grained by looking\n  // at the shader's bufferView's to determine the buffer dependencies.\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  const context = frameState.context;\n\n  if (model.asynchronous) {\n    while (programsToCreate.length > 0) {\n      scratchCreateProgramJob.set(programsToCreate.peek(), model, context);\n      if (\n        !frameState.jobScheduler.execute(\n          scratchCreateProgramJob,\n          JobType.PROGRAM\n        )\n      ) {\n        break;\n      }\n      programsToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded programs this frame\n    while (programsToCreate.length > 0) {\n      createProgram(programsToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getOnImageCreatedFromTypedArray(loadResources, gltfTexture) {\n  return function (image) {\n    loadResources.texturesToCreate.enqueue({\n      id: gltfTexture.id,\n      image: image,\n      bufferView: undefined,\n    });\n\n    --loadResources.pendingBufferViewToImage;\n  };\n}\n\nfunction loadTexturesFromBufferViews(model) {\n  const loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  while (loadResources.texturesToCreateFromBufferView.length > 0) {\n    const gltfTexture = loadResources.texturesToCreateFromBufferView.dequeue();\n\n    const gltf = model.gltfInternal;\n    const bufferView = gltf.bufferViews[gltfTexture.bufferView];\n    const imageId = gltf.textures[gltfTexture.id].source;\n\n    const onerror = ModelUtility.getFailedLoadFunction(\n      model,\n      \"image\",\n      `id: ${gltfTexture.id}, bufferView: ${gltfTexture.bufferView}`\n    );\n\n    if (gltfTexture.mimeType === \"image/ktx2\") {\n      // Need to make a copy of the embedded KTX2 buffer otherwise the underlying\n      // ArrayBuffer may be accessed on both the worker and the main thread and\n      // throw an error like \"Cannot perform Construct on a detached ArrayBuffer\".\n      // Look into SharedArrayBuffer at some point to get around this.\n      const ktxBuffer = new Uint8Array(loadResources.getBuffer(bufferView));\n      loadKTX2(ktxBuffer)\n        .then(imageLoad(model, gltfTexture.id, imageId))\n        .catch(onerror);\n      ++model._loadResources.pendingTextureLoads;\n    } else {\n      const onload = getOnImageCreatedFromTypedArray(\n        loadResources,\n        gltfTexture\n      );\n      loadImageFromTypedArray({\n        uint8Array: loadResources.getBuffer(bufferView),\n        format: gltfTexture.mimeType,\n        flipY: false,\n        skipColorSpaceConversion: true,\n      })\n        .then(onload)\n        .catch(onerror);\n      ++loadResources.pendingBufferViewToImage;\n    }\n  }\n}\n\nfunction createSamplers(model) {\n  const loadResources = model._loadResources;\n  if (loadResources.createSamplers) {\n    loadResources.createSamplers = false;\n\n    const rendererSamplers = model._rendererResources.samplers;\n    ForEach.sampler(model.gltfInternal, function (sampler, samplerId) {\n      rendererSamplers[samplerId] = new Sampler({\n        wrapS: sampler.wrapS,\n        wrapT: sampler.wrapT,\n        minificationFilter: sampler.minFilter,\n        magnificationFilter: sampler.magFilter,\n      });\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nconst CreateTextureJob = function () {\n  this.gltfTexture = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateTextureJob.prototype.set = function (gltfTexture, model, context) {\n  this.gltfTexture = gltfTexture;\n  this.model = model;\n  this.context = context;\n};\n\nCreateTextureJob.prototype.execute = function () {\n  createTexture(this.gltfTexture, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createTexture(gltfTexture, model, context) {\n  const textures = model.gltfInternal.textures;\n  const texture = textures[gltfTexture.id];\n\n  const rendererSamplers = model._rendererResources.samplers;\n  let sampler = rendererSamplers[texture.sampler];\n  if (!defined(sampler)) {\n    sampler = new Sampler({\n      wrapS: TextureWrap.REPEAT,\n      wrapT: TextureWrap.REPEAT,\n    });\n  }\n\n  let usesTextureTransform = false;\n  const materials = model.gltfInternal.materials;\n  const materialsLength = materials.length;\n  for (let i = 0; i < materialsLength; ++i) {\n    const material = materials[i];\n    if (\n      defined(material.extensions) &&\n      defined(material.extensions.KHR_techniques_webgl)\n    ) {\n      const values = material.extensions.KHR_techniques_webgl.values;\n      for (const valueName in values) {\n        if (\n          values.hasOwnProperty(valueName) &&\n          valueName.indexOf(\"Texture\") !== -1\n        ) {\n          const value = values[valueName];\n          if (\n            value.index === gltfTexture.id &&\n            defined(value.extensions) &&\n            defined(value.extensions.KHR_texture_transform)\n          ) {\n            usesTextureTransform = true;\n            break;\n          }\n        }\n      }\n    }\n    if (usesTextureTransform) {\n      break;\n    }\n  }\n\n  const wrapS = sampler.wrapS;\n  const wrapT = sampler.wrapT;\n  let minFilter = sampler.minificationFilter;\n\n  if (\n    usesTextureTransform &&\n    minFilter !== TextureMinificationFilter.LINEAR &&\n    minFilter !== TextureMinificationFilter.NEAREST\n  ) {\n    if (\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n    ) {\n      minFilter = TextureMinificationFilter.NEAREST;\n    } else {\n      minFilter = TextureMinificationFilter.LINEAR;\n    }\n\n    sampler = new Sampler({\n      wrapS: sampler.wrapS,\n      wrapT: sampler.wrapT,\n      minificationFilter: minFilter,\n      magnificationFilter: sampler.magnificationFilter,\n    });\n  }\n\n  const internalFormat = gltfTexture.internalFormat;\n\n  const mipmap =\n    !(\n      defined(internalFormat) && PixelFormat.isCompressedFormat(internalFormat)\n    ) &&\n    (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR ||\n      minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR);\n  const requiresNpot =\n    mipmap ||\n    wrapS === TextureWrap.REPEAT ||\n    wrapS === TextureWrap.MIRRORED_REPEAT ||\n    wrapT === TextureWrap.REPEAT ||\n    wrapT === TextureWrap.MIRRORED_REPEAT;\n  let npot;\n  let tx;\n  let source = gltfTexture.image;\n\n  if (defined(internalFormat)) {\n    npot =\n      !CesiumMath.isPowerOfTwo(gltfTexture.width) ||\n      !CesiumMath.isPowerOfTwo(gltfTexture.height);\n\n    // Warning to encourage power of 2 texture dimensions with KHR_texture_basisu\n    if (\n      !context.webgl2 &&\n      PixelFormat.isCompressedFormat(internalFormat) &&\n      npot &&\n      requiresNpot\n    ) {\n      console.warn(\n        \"Compressed texture uses REPEAT or MIRRORED_REPEAT texture wrap mode and dimensions are not powers of two. The texture may be rendered incorrectly. See the Model.js constructor documentation for more information.\"\n      );\n    }\n\n    let minificationFilter = sampler.minificationFilter;\n    if (\n      !defined(gltfTexture.mipLevels) &&\n      (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n        minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR)\n    ) {\n      minificationFilter = TextureMinificationFilter.NEAREST;\n    } else if (\n      !defined(gltfTexture.mipLevels) &&\n      (minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST ||\n        minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR)\n    ) {\n      minificationFilter = TextureMinificationFilter.LINEAR;\n    }\n    sampler = new Sampler({\n      wrapS: sampler.wrapS,\n      wrapT: sampler.wrapT,\n      minificationFilter: minificationFilter,\n      magnificationFilter: sampler.magnificationFilter,\n    });\n\n    tx = new Texture({\n      context: context,\n      source: {\n        arrayBufferView: gltfTexture.bufferView,\n        mipLevels: gltfTexture.mipLevels,\n      },\n      width: gltfTexture.width,\n      height: gltfTexture.height,\n      pixelFormat: internalFormat,\n      sampler: sampler,\n    });\n  } else if (defined(source)) {\n    npot =\n      !CesiumMath.isPowerOfTwo(source.width) ||\n      !CesiumMath.isPowerOfTwo(source.height);\n    if (requiresNpot && npot) {\n      // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = CesiumMath.nextPowerOfTwo(source.width);\n      canvas.height = CesiumMath.nextPowerOfTwo(source.height);\n      const canvasContext = canvas.getContext(\"2d\");\n      canvasContext.drawImage(\n        source,\n        0,\n        0,\n        source.width,\n        source.height,\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      );\n      source = canvas;\n    }\n\n    tx = new Texture({\n      context: context,\n      source: source,\n      pixelFormat: texture.internalFormat,\n      pixelDatatype: texture.type,\n      sampler: sampler,\n      flipY: false,\n      skipColorSpaceConversion: true,\n    });\n    // GLTF_SPEC: Support TEXTURE_CUBE_MAP.  https://github.com/KhronosGroup/glTF/issues/40\n    if (mipmap) {\n      tx.generateMipmap();\n    }\n  }\n  if (defined(tx)) {\n    model._rendererResources.textures[gltfTexture.id] = tx;\n    model._texturesByteLength += tx.sizeInBytes;\n  }\n}\n\nconst scratchCreateTextureJob = new CreateTextureJob();\n\nfunction createTextures(model, frameState) {\n  const context = frameState.context;\n  const texturesToCreate = model._loadResources.texturesToCreate;\n\n  if (model.asynchronous) {\n    while (texturesToCreate.length > 0) {\n      scratchCreateTextureJob.set(texturesToCreate.peek(), model, context);\n      if (\n        !frameState.jobScheduler.execute(\n          scratchCreateTextureJob,\n          JobType.TEXTURE\n        )\n      ) {\n        break;\n      }\n      texturesToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded textures this frame\n    while (texturesToCreate.length > 0) {\n      createTexture(texturesToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getAttributeLocations(model, primitive) {\n  const techniques = model._sourceTechniques;\n\n  // Retrieve the compiled shader program to assign index values to attributes\n  const attributeLocations = {};\n\n  let location;\n  let index;\n  const material = model._runtime.materialsById[primitive.material];\n  if (!defined(material)) {\n    return attributeLocations;\n  }\n\n  const technique = techniques[material._technique];\n  if (!defined(technique)) {\n    return attributeLocations;\n  }\n\n  const attributes = technique.attributes;\n  const program = model._rendererResources.programs[technique.program];\n  const programAttributeLocations = program._attributeLocations;\n\n  for (location in programAttributeLocations) {\n    if (programAttributeLocations.hasOwnProperty(location)) {\n      const attribute = attributes[location];\n      if (defined(attribute)) {\n        index = programAttributeLocations[location];\n        attributeLocations[attribute.semantic] = index;\n      }\n    }\n  }\n\n  // Add pre-created attributes.\n  const precreatedAttributes = model._precreatedAttributes;\n  if (defined(precreatedAttributes)) {\n    for (location in precreatedAttributes) {\n      if (precreatedAttributes.hasOwnProperty(location)) {\n        index = programAttributeLocations[location];\n        attributeLocations[location] = index;\n      }\n    }\n  }\n\n  return attributeLocations;\n}\n\nfunction createJoints(model, runtimeSkins) {\n  const gltf = model.gltfInternal;\n  const skins = gltf.skins;\n  const nodes = gltf.nodes;\n  const runtimeNodes = model._runtime.nodes;\n\n  const skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  const length = skinnedNodesIds.length;\n  for (let j = 0; j < length; ++j) {\n    const id = skinnedNodesIds[j];\n    const skinnedNode = runtimeNodes[id];\n    const node = nodes[id];\n\n    const runtimeSkin = runtimeSkins[node.skin];\n    skinnedNode.inverseBindMatrices = runtimeSkin.inverseBindMatrices;\n    skinnedNode.bindShapeMatrix = runtimeSkin.bindShapeMatrix;\n\n    const gltfJoints = skins[node.skin].joints;\n    const jointsLength = gltfJoints.length;\n    for (let i = 0; i < jointsLength; ++i) {\n      const nodeId = gltfJoints[i];\n      const jointNode = runtimeNodes[nodeId];\n      skinnedNode.joints.push(jointNode);\n    }\n  }\n}\n\nfunction createSkins(model) {\n  const loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  if (!loadResources.createSkins) {\n    return;\n  }\n  loadResources.createSkins = false;\n\n  const gltf = model.gltfInternal;\n  const accessors = gltf.accessors;\n  const runtimeSkins = {};\n\n  ForEach.skin(gltf, function (skin, id) {\n    const accessor = accessors[skin.inverseBindMatrices];\n\n    let bindShapeMatrix;\n    if (!Matrix4.equals(skin.bindShapeMatrix, Matrix4.IDENTITY)) {\n      bindShapeMatrix = Matrix4.clone(skin.bindShapeMatrix);\n    }\n\n    runtimeSkins[id] = {\n      inverseBindMatrices: ModelAnimationCache.getSkinInverseBindMatrices(\n        model,\n        accessor\n      ),\n      bindShapeMatrix: bindShapeMatrix, // not used when undefined\n    };\n  });\n\n  createJoints(model, runtimeSkins);\n}\n\nfunction getChannelEvaluator(model, runtimeNode, targetPath, spline) {\n  return function (localAnimationTime) {\n    if (defined(spline)) {\n      localAnimationTime = model.clampAnimations\n        ? spline.clampTime(localAnimationTime)\n        : spline.wrapTime(localAnimationTime);\n      runtimeNode[targetPath] = spline.evaluate(\n        localAnimationTime,\n        runtimeNode[targetPath]\n      );\n      runtimeNode.dirtyNumber = model._maxDirtyNumber;\n    }\n  };\n}\n\nfunction createRuntimeAnimations(model) {\n  const loadResources = model._loadResources;\n\n  if (!loadResources.finishedPendingBufferLoads()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeAnimations) {\n    return;\n  }\n  loadResources.createRuntimeAnimations = false;\n\n  model._runtime.animations = [];\n\n  const runtimeNodes = model._runtime.nodes;\n  const accessors = model.gltfInternal.accessors;\n\n  ForEach.animation(model.gltfInternal, function (animation, i) {\n    const channels = animation.channels;\n    const samplers = animation.samplers;\n\n    // Find start and stop time for the entire animation\n    let startTime = Number.MAX_VALUE;\n    let stopTime = -Number.MAX_VALUE;\n\n    const channelsLength = channels.length;\n    const channelEvaluators = new Array(channelsLength);\n\n    for (let j = 0; j < channelsLength; ++j) {\n      const channel = channels[j];\n      const target = channel.target;\n      const path = target.path;\n      const sampler = samplers[channel.sampler];\n      const input = ModelAnimationCache.getAnimationParameterValues(\n        model,\n        accessors[sampler.input]\n      );\n      const output = ModelAnimationCache.getAnimationParameterValues(\n        model,\n        accessors[sampler.output]\n      );\n\n      startTime = Math.min(startTime, input[0]);\n      stopTime = Math.max(stopTime, input[input.length - 1]);\n\n      const spline = ModelAnimationCache.getAnimationSpline(\n        model,\n        i,\n        animation,\n        channel.sampler,\n        sampler,\n        input,\n        path,\n        output\n      );\n\n      channelEvaluators[j] = getChannelEvaluator(\n        model,\n        runtimeNodes[target.node],\n        target.path,\n        spline\n      );\n    }\n\n    model._runtime.animations[i] = {\n      name: animation.name,\n      startTime: startTime,\n      stopTime: stopTime,\n      channelEvaluators: channelEvaluators,\n    };\n  });\n}\n\nfunction createVertexArrays(model, context) {\n  const loadResources = model._loadResources;\n  if (\n    !loadResources.finishedBuffersCreation() ||\n    !loadResources.finishedProgramCreation() ||\n    !loadResources.createVertexArrays\n  ) {\n    return;\n  }\n  loadResources.createVertexArrays = false;\n\n  const rendererBuffers = model._rendererResources.buffers;\n  const rendererVertexArrays = model._rendererResources.vertexArrays;\n  const gltf = model.gltfInternal;\n  const accessors = gltf.accessors;\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      const attributes = [];\n      let attributeLocation;\n      const attributeLocations = getAttributeLocations(model, primitive);\n      const decodedData =\n        model._decodedData[`${meshId}.primitive.${primitiveId}`];\n      ForEach.meshPrimitiveAttribute(primitive, function (\n        accessorId,\n        attributeName\n      ) {\n        // Skip if the attribute is not used by the material, e.g., because the asset\n        // was exported with an attribute that wasn't used and the asset wasn't optimized.\n        attributeLocation = attributeLocations[attributeName];\n        if (defined(attributeLocation)) {\n          // Use attributes of previously decoded draco geometry\n          if (defined(decodedData)) {\n            const decodedAttributes = decodedData.attributes;\n            if (decodedAttributes.hasOwnProperty(attributeName)) {\n              const decodedAttribute = decodedAttributes[attributeName];\n              attributes.push({\n                index: attributeLocation,\n                vertexBuffer: rendererBuffers[decodedAttribute.bufferView],\n                componentsPerAttribute: decodedAttribute.componentsPerAttribute,\n                componentDatatype: decodedAttribute.componentDatatype,\n                normalize: decodedAttribute.normalized,\n                offsetInBytes: decodedAttribute.byteOffset,\n                strideInBytes: decodedAttribute.byteStride,\n              });\n\n              return;\n            }\n          }\n\n          const a = accessors[accessorId];\n          const normalize = defined(a.normalized) && a.normalized;\n          attributes.push({\n            index: attributeLocation,\n            vertexBuffer: rendererBuffers[a.bufferView],\n            componentsPerAttribute: numberOfComponentsForType(a.type),\n            componentDatatype: a.componentType,\n            normalize: normalize,\n            offsetInBytes: a.byteOffset,\n            strideInBytes: getAccessorByteStride(gltf, a),\n          });\n        }\n      });\n\n      // Add pre-created attributes\n      let attribute;\n      let attributeName;\n      const precreatedAttributes = model._precreatedAttributes;\n      if (defined(precreatedAttributes)) {\n        for (attributeName in precreatedAttributes) {\n          if (precreatedAttributes.hasOwnProperty(attributeName)) {\n            attributeLocation = attributeLocations[attributeName];\n            if (defined(attributeLocation)) {\n              attribute = precreatedAttributes[attributeName];\n              attribute.index = attributeLocation;\n              attributes.push(attribute);\n            }\n          }\n        }\n      }\n\n      let indexBuffer;\n      if (defined(primitive.indices)) {\n        const accessor = accessors[primitive.indices];\n        let bufferView = accessor.bufferView;\n\n        // Use buffer of previously decoded draco geometry\n        if (defined(decodedData)) {\n          bufferView = decodedData.bufferView;\n        }\n\n        indexBuffer = rendererBuffers[bufferView];\n      }\n      rendererVertexArrays[\n        `${meshId}.primitive.${primitiveId}`\n      ] = new VertexArray({\n        context: context,\n        attributes: attributes,\n        indexBuffer: indexBuffer,\n      });\n    });\n  });\n}\n\nfunction createRenderStates(model) {\n  const loadResources = model._loadResources;\n  if (loadResources.createRenderStates) {\n    loadResources.createRenderStates = false;\n\n    ForEach.material(model.gltfInternal, function (material, materialId) {\n      createRenderStateForMaterial(model, material, materialId);\n    });\n  }\n}\n\nfunction createRenderStateForMaterial(model, material, materialId) {\n  const rendererRenderStates = model._rendererResources.renderStates;\n\n  let blendEquationSeparate = [\n    WebGLConstants.FUNC_ADD,\n    WebGLConstants.FUNC_ADD,\n  ];\n  let blendFuncSeparate = [\n    WebGLConstants.ONE,\n    WebGLConstants.ONE_MINUS_SRC_ALPHA,\n    WebGLConstants.ONE,\n    WebGLConstants.ONE_MINUS_SRC_ALPHA,\n  ];\n\n  if (defined(material.extensions) && defined(material.extensions.KHR_blend)) {\n    blendEquationSeparate = material.extensions.KHR_blend.blendEquation;\n    blendFuncSeparate = material.extensions.KHR_blend.blendFactors;\n  }\n\n  const enableCulling = !material.doubleSided;\n  const blendingEnabled = material.alphaMode === \"BLEND\";\n  rendererRenderStates[materialId] = RenderState.fromCache({\n    cull: {\n      enabled: enableCulling,\n    },\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: !blendingEnabled,\n    blending: {\n      enabled: blendingEnabled,\n      equationRgb: blendEquationSeparate[0],\n      equationAlpha: blendEquationSeparate[1],\n      functionSourceRgb: blendFuncSeparate[0],\n      functionDestinationRgb: blendFuncSeparate[1],\n      functionSourceAlpha: blendFuncSeparate[2],\n      functionDestinationAlpha: blendFuncSeparate[3],\n    },\n  });\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nconst gltfUniformsFromNode = {\n  MODEL: function (uniformState, model, runtimeNode) {\n    return function () {\n      return runtimeNode.computedMatrix;\n    };\n  },\n  VIEW: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.view;\n    };\n  },\n  PROJECTION: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.projection;\n    };\n  },\n  MODELVIEW: function (uniformState, model, runtimeNode) {\n    const mv = new Matrix4();\n    return function () {\n      return Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mv\n      );\n    };\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model, runtimeNode) {\n    // CESIUM_RTC extension\n    const mvRtc = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mvRtc\n      );\n      return Matrix4.setTranslation(mvRtc, model._rtcCenterEye, mvRtc);\n    };\n  },\n  MODELVIEWPROJECTION: function (uniformState, model, runtimeNode) {\n    const mvp = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mvp\n      );\n      return Matrix4.multiply(uniformState._projection, mvp, mvp);\n    };\n  },\n  MODELINVERSE: function (uniformState, model, runtimeNode) {\n    const mInverse = new Matrix4();\n    return function () {\n      return Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n    };\n  },\n  VIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseView;\n    };\n  },\n  PROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.inverseProjection;\n    };\n  },\n  MODELVIEWINVERSE: function (uniformState, model, runtimeNode) {\n    const mv = new Matrix4();\n    const mvInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mv\n      );\n      return Matrix4.inverse(mv, mvInverse);\n    };\n  },\n  MODELVIEWPROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    const mvp = new Matrix4();\n    const mvpInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mvp\n      );\n      Matrix4.multiply(uniformState._projection, mvp, mvp);\n      return Matrix4.inverse(mvp, mvpInverse);\n    };\n  },\n  MODELINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    const mInverse = new Matrix4();\n    const mInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n      Matrix4.getMatrix3(mInverse, mInverseTranspose);\n      return Matrix3.transpose(mInverseTranspose, mInverseTranspose);\n    };\n  },\n  MODELVIEWINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    const mv = new Matrix4();\n    const mvInverse = new Matrix4();\n    const mvInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mv\n      );\n      Matrix4.inverse(mv, mvInverse);\n      Matrix4.getMatrix3(mvInverse, mvInverseTranspose);\n      return Matrix3.transpose(mvInverseTranspose, mvInverseTranspose);\n    };\n  },\n  VIEWPORT: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.viewportCartesian4;\n    };\n  },\n};\n\nfunction getUniformFunctionFromSource(source, model, semantic, uniformState) {\n  const runtimeNode = model._runtime.nodes[source];\n  return gltfUniformsFromNode[semantic](uniformState, model, runtimeNode);\n}\n\nfunction createUniformsForMaterial(\n  model,\n  material,\n  technique,\n  instanceValues,\n  context,\n  textures,\n  defaultTexture\n) {\n  const uniformMap = {};\n  const uniformValues = {};\n  let jointMatrixUniformName;\n  let morphWeightsUniformName;\n\n  ForEach.techniqueUniform(technique, function (uniform, uniformName) {\n    // GLTF_SPEC: This does not take into account uniform arrays,\n    // indicated by uniforms with a count property.\n    //\n    // https://github.com/KhronosGroup/glTF/issues/258\n\n    // GLTF_SPEC: In this implementation, material parameters with a\n    // semantic or targeted via a source (for animation) are not\n    // targetable for material animations.  Is this too strict?\n    //\n    // https://github.com/KhronosGroup/glTF/issues/142\n\n    let uv;\n    if (defined(instanceValues) && defined(instanceValues[uniformName])) {\n      // Parameter overrides by the instance technique\n      uv = ModelUtility.createUniformFunction(\n        uniform.type,\n        instanceValues[uniformName],\n        textures,\n        defaultTexture\n      );\n      uniformMap[uniformName] = uv.func;\n      uniformValues[uniformName] = uv;\n    } else if (defined(uniform.node)) {\n      uniformMap[uniformName] = getUniformFunctionFromSource(\n        uniform.node,\n        model,\n        uniform.semantic,\n        context.uniformState\n      );\n    } else if (defined(uniform.semantic)) {\n      if (uniform.semantic === \"JOINTMATRIX\") {\n        jointMatrixUniformName = uniformName;\n      } else if (uniform.semantic === \"MORPHWEIGHTS\") {\n        morphWeightsUniformName = uniformName;\n      } else if (uniform.semantic === \"ALPHACUTOFF\") {\n        // The material's alphaCutoff value uses a uniform with semantic ALPHACUTOFF.\n        // A uniform with this semantic will ignore the instance or default values.\n        const alphaMode = material.alphaMode;\n        if (defined(alphaMode) && alphaMode === \"MASK\") {\n          const alphaCutoffValue = defaultValue(material.alphaCutoff, 0.5);\n          uv = ModelUtility.createUniformFunction(\n            uniform.type,\n            alphaCutoffValue,\n            textures,\n            defaultTexture\n          );\n          uniformMap[uniformName] = uv.func;\n          uniformValues[uniformName] = uv;\n        }\n      } else {\n        // Map glTF semantic to Cesium automatic uniform\n        uniformMap[uniformName] = ModelUtility.getGltfSemanticUniforms()[\n          uniform.semantic\n        ](context.uniformState, model);\n      }\n    } else if (defined(uniform.value)) {\n      // Technique value that isn't overridden by a material\n      const uv2 = ModelUtility.createUniformFunction(\n        uniform.type,\n        uniform.value,\n        textures,\n        defaultTexture\n      );\n      uniformMap[uniformName] = uv2.func;\n      uniformValues[uniformName] = uv2;\n    }\n  });\n\n  return {\n    map: uniformMap,\n    values: uniformValues,\n    jointMatrixUniformName: jointMatrixUniformName,\n    morphWeightsUniformName: morphWeightsUniformName,\n  };\n}\n\nfunction createUniformMaps(model, context) {\n  const loadResources = model._loadResources;\n\n  if (!loadResources.finishedProgramCreation()) {\n    return;\n  }\n\n  if (!loadResources.createUniformMaps) {\n    return;\n  }\n  loadResources.createUniformMaps = false;\n\n  const gltf = model.gltfInternal;\n  const techniques = model._sourceTechniques;\n  const uniformMaps = model._uniformMaps;\n\n  const textures = model._rendererResources.textures;\n  const defaultTexture = model._defaultTexture;\n\n  ForEach.material(gltf, function (material, materialId) {\n    const modelMaterial = model._runtime.materialsById[materialId];\n    const technique = techniques[modelMaterial._technique];\n    const instanceValues = modelMaterial._values;\n\n    const uniforms = createUniformsForMaterial(\n      model,\n      material,\n      technique,\n      instanceValues,\n      context,\n      textures,\n      defaultTexture\n    );\n\n    const u = uniformMaps[materialId];\n    u.uniformMap = uniforms.map; // uniform name -> function for the renderer\n    u.values = uniforms.values; // material parameter name -> ModelMaterial for modifying the parameter at runtime\n    u.jointMatrixUniformName = uniforms.jointMatrixUniformName;\n    u.morphWeightsUniformName = uniforms.morphWeightsUniformName;\n\n    if (defined(technique.attributes.a_outlineCoordinates)) {\n      const outlineTexture = ModelOutlineLoader.createTexture(model, context);\n      u.uniformMap.u_outlineTexture = function () {\n        return outlineTexture;\n      };\n    }\n  });\n}\n\nfunction createUniformsForDracoQuantizedAttributes(decodedData) {\n  return ModelUtility.createUniformsForDracoQuantizedAttributes(\n    decodedData.attributes\n  );\n}\n\nfunction createUniformsForQuantizedAttributes(model, primitive) {\n  const programId = getProgramForPrimitive(model, primitive);\n  const quantizedUniforms = model._quantizedUniforms[programId];\n  return ModelUtility.createUniformsForQuantizedAttributes(\n    model.gltfInternal,\n    primitive,\n    quantizedUniforms\n  );\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createJointMatricesFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.computedJointMatrices;\n  };\n}\n\nfunction createMorphWeightsFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.weights;\n  };\n}\n\nfunction createSilhouetteColorFunction(model) {\n  return function () {\n    return model.silhouetteColor;\n  };\n}\n\nfunction createSilhouetteSizeFunction(model) {\n  return function () {\n    return model.silhouetteSize;\n  };\n}\n\nfunction createColorFunction(model) {\n  return function () {\n    return model.color;\n  };\n}\n\nfunction createClippingPlanesMatrixFunction(model) {\n  return function () {\n    return model._clippingPlanesMatrix;\n  };\n}\n\nfunction createIBLReferenceFrameMatrixFunction(model) {\n  return function () {\n    return model._iblReferenceFrameMatrix;\n  };\n}\n\nfunction createClippingPlanesFunction(model) {\n  return function () {\n    const clippingPlanes = model.clippingPlanes;\n    return !defined(clippingPlanes) || !clippingPlanes.enabled\n      ? model._defaultTexture\n      : clippingPlanes.texture;\n  };\n}\n\nfunction createClippingPlanesEdgeStyleFunction(model) {\n  return function () {\n    const clippingPlanes = model.clippingPlanes;\n    if (!defined(clippingPlanes)) {\n      return Color.WHITE.withAlpha(0.0);\n    }\n\n    const style = Color.clone(clippingPlanes.edgeColor);\n    style.alpha = clippingPlanes.edgeWidth;\n    return style;\n  };\n}\n\nfunction createColorBlendFunction(model) {\n  return function () {\n    return ColorBlendMode.getColorBlend(\n      model.colorBlendMode,\n      model.colorBlendAmount\n    );\n  };\n}\n\nfunction createIBLFactorFunction(model) {\n  return function () {\n    return model._imageBasedLighting.imageBasedLightingFactor;\n  };\n}\n\nfunction createLightColorFunction(model) {\n  return function () {\n    return model._lightColor;\n  };\n}\n\nfunction createLuminanceAtZenithFunction(model) {\n  return function () {\n    return model._imageBasedLighting.luminanceAtZenith;\n  };\n}\n\nfunction createSphericalHarmonicCoefficientsFunction(model) {\n  return function () {\n    return model._imageBasedLighting.sphericalHarmonicCoefficients;\n  };\n}\n\nfunction createSpecularEnvironmentMapFunction(model) {\n  return function () {\n    return model._imageBasedLighting.specularEnvironmentMapAtlas.texture;\n  };\n}\n\nfunction createSpecularEnvironmentMapSizeFunction(model) {\n  return function () {\n    return model._imageBasedLighting.specularEnvironmentMapAtlas.texture\n      .dimensions;\n  };\n}\n\nfunction createSpecularEnvironmentMapLOD(model) {\n  return function () {\n    return model._imageBasedLighting.specularEnvironmentMapAtlas\n      .maximumMipmapLevel;\n  };\n}\n\nfunction triangleCountFromPrimitiveIndices(primitive, indicesCount) {\n  switch (primitive.mode) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n    default:\n      return 0;\n  }\n}\n\nfunction createCommand(model, gltfNode, runtimeNode, context, scene3DOnly) {\n  const nodeCommands = model._nodeCommands;\n  const pickIds = model._pickIds;\n  const allowPicking = model.allowPicking;\n  const runtimeMeshesByName = model._runtime.meshesByName;\n\n  const resources = model._rendererResources;\n  const rendererVertexArrays = resources.vertexArrays;\n  const rendererPrograms = resources.programs;\n  const rendererRenderStates = resources.renderStates;\n  const uniformMaps = model._uniformMaps;\n\n  const gltf = model.gltfInternal;\n  const accessors = gltf.accessors;\n  const gltfMeshes = gltf.meshes;\n\n  const id = gltfNode.mesh;\n  const mesh = gltfMeshes[id];\n\n  const primitives = mesh.primitives;\n  const length = primitives.length;\n\n  // The glTF node hierarchy is a DAG so a node can have more than one\n  // parent, so a node may already have commands.  If so, append more\n  // since they will have a different model matrix.\n\n  for (let i = 0; i < length; ++i) {\n    const primitive = primitives[i];\n    const ix = accessors[primitive.indices];\n    const material = model._runtime.materialsById[primitive.material];\n    const programId = material._program;\n    const decodedData = model._decodedData[`${id}.primitive.${i}`];\n\n    let boundingSphere;\n    const positionAccessor = primitive.attributes.POSITION;\n    if (defined(positionAccessor)) {\n      const minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n      boundingSphere = BoundingSphere.fromCornerPoints(\n        Cartesian3.fromArray(minMax.min),\n        Cartesian3.fromArray(minMax.max)\n      );\n    }\n\n    const vertexArray = rendererVertexArrays[`${id}.primitive.${i}`];\n    let offset;\n    let count;\n\n    // Use indices of the previously decoded Draco geometry.\n    if (defined(decodedData)) {\n      count = decodedData.numberOfIndices;\n      offset = 0;\n    } else if (defined(ix)) {\n      count = ix.count;\n      offset = ix.byteOffset / IndexDatatype.getSizeInBytes(ix.componentType); // glTF has offset in bytes.  Cesium has offsets in indices\n    } else {\n      const positions = accessors[primitive.attributes.POSITION];\n      count = positions.count;\n      offset = 0;\n    }\n\n    // Update model triangle count using number of indices\n    model._trianglesLength += triangleCountFromPrimitiveIndices(\n      primitive,\n      count\n    );\n\n    if (primitive.mode === PrimitiveType.POINTS) {\n      model._pointsLength += count;\n    }\n\n    const um = uniformMaps[primitive.material];\n    let uniformMap = um.uniformMap;\n    if (defined(um.jointMatrixUniformName)) {\n      const jointUniformMap = {};\n      jointUniformMap[um.jointMatrixUniformName] = createJointMatricesFunction(\n        runtimeNode\n      );\n\n      uniformMap = combine(uniformMap, jointUniformMap);\n    }\n    if (defined(um.morphWeightsUniformName)) {\n      const morphWeightsUniformMap = {};\n      morphWeightsUniformMap[\n        um.morphWeightsUniformName\n      ] = createMorphWeightsFunction(runtimeNode);\n\n      uniformMap = combine(uniformMap, morphWeightsUniformMap);\n    }\n\n    uniformMap = combine(uniformMap, {\n      gltf_color: createColorFunction(model),\n      gltf_colorBlend: createColorBlendFunction(model),\n      gltf_clippingPlanes: createClippingPlanesFunction(model),\n      gltf_clippingPlanesEdgeStyle: createClippingPlanesEdgeStyleFunction(\n        model\n      ),\n      gltf_clippingPlanesMatrix: createClippingPlanesMatrixFunction(model),\n      gltf_iblReferenceFrameMatrix: createIBLReferenceFrameMatrixFunction(\n        model\n      ),\n      gltf_iblFactor: createIBLFactorFunction(model),\n      gltf_lightColor: createLightColorFunction(model),\n      gltf_sphericalHarmonicCoefficients: createSphericalHarmonicCoefficientsFunction(\n        model\n      ),\n      gltf_specularMap: createSpecularEnvironmentMapFunction(model),\n      gltf_specularMapSize: createSpecularEnvironmentMapSizeFunction(model),\n      gltf_maxSpecularLOD: createSpecularEnvironmentMapLOD(model),\n      gltf_luminanceAtZenith: createLuminanceAtZenithFunction(model),\n    });\n\n    Splitter.addUniforms(model, uniformMap);\n\n    // Allow callback to modify the uniformMap\n    if (defined(model._uniformMapLoaded)) {\n      uniformMap = model._uniformMapLoaded(uniformMap, programId, runtimeNode);\n    }\n\n    // Add uniforms for decoding quantized attributes if used\n    let quantizedUniformMap = {};\n    if (model.extensionsUsed.WEB3D_quantized_attributes) {\n      quantizedUniformMap = createUniformsForQuantizedAttributes(\n        model,\n        primitive\n      );\n    } else if (model._dequantizeInShader && defined(decodedData)) {\n      quantizedUniformMap = createUniformsForDracoQuantizedAttributes(\n        decodedData\n      );\n    }\n    uniformMap = combine(uniformMap, quantizedUniformMap);\n\n    const rs = rendererRenderStates[primitive.material];\n    const isTranslucent = rs.blending.enabled;\n\n    let owner = model._pickObject;\n    if (!defined(owner)) {\n      owner = {\n        primitive: model,\n        id: model.id,\n        node: runtimeNode.publicNode,\n        mesh: runtimeMeshesByName[mesh.name],\n      };\n    }\n\n    const castShadows = ShadowMode.castShadows(model._shadows);\n    const receiveShadows = ShadowMode.receiveShadows(model._shadows);\n\n    let pickId;\n    if (allowPicking && !defined(model._uniformMapLoaded)) {\n      pickId = context.createPickId(owner);\n      pickIds.push(pickId);\n      const pickUniforms = {\n        czm_pickColor: createPickColorFunction(pickId.color),\n      };\n      uniformMap = combine(uniformMap, pickUniforms);\n    }\n\n    if (allowPicking) {\n      if (defined(model._pickIdLoaded) && defined(model._uniformMapLoaded)) {\n        pickId = model._pickIdLoaded();\n      } else {\n        pickId = \"czm_pickColor\";\n      }\n    }\n\n    const command = new DrawCommand({\n      boundingVolume: new BoundingSphere(), // updated in update()\n      cull: model.cull,\n      modelMatrix: new Matrix4(), // computed in update()\n      primitiveType: primitive.mode,\n      vertexArray: vertexArray,\n      count: count,\n      offset: offset,\n      shaderProgram: rendererPrograms[programId],\n      castShadows: castShadows,\n      receiveShadows: receiveShadows,\n      uniformMap: uniformMap,\n      renderState: rs,\n      owner: owner,\n      pass: isTranslucent ? Pass.TRANSLUCENT : model.opaquePass,\n      pickId: pickId,\n    });\n\n    let command2D;\n    if (!scene3DOnly) {\n      command2D = DrawCommand.shallowClone(command);\n      command2D.boundingVolume = new BoundingSphere(); // updated in update()\n      command2D.modelMatrix = new Matrix4(); // updated in update()\n    }\n\n    const nodeCommand = {\n      show: true,\n      boundingSphere: boundingSphere,\n      command: command,\n      command2D: command2D,\n      // Generated on demand when silhouette size is greater than 0.0 and silhouette alpha is greater than 0.0\n      silhouetteModelCommand: undefined,\n      silhouetteModelCommand2D: undefined,\n      silhouetteColorCommand: undefined,\n      silhouetteColorCommand2D: undefined,\n      // Generated on demand when color alpha is less than 1.0\n      translucentCommand: undefined,\n      translucentCommand2D: undefined,\n      // Generated on demand when back face culling is false\n      disableCullingCommand: undefined,\n      disableCullingCommand2D: undefined,\n      // For updating node commands on shader reconstruction\n      programId: programId,\n    };\n    runtimeNode.commands.push(nodeCommand);\n    nodeCommands.push(nodeCommand);\n  }\n}\n\nfunction createRuntimeNodes(model, context, scene3DOnly) {\n  const loadResources = model._loadResources;\n\n  if (!loadResources.finishedEverythingButTextureCreation()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeNodes) {\n    return;\n  }\n  loadResources.createRuntimeNodes = false;\n\n  const rootNodes = [];\n  const runtimeNodes = model._runtime.nodes;\n\n  const gltf = model.gltfInternal;\n  const nodes = gltf.nodes;\n\n  const scene = gltf.scenes[gltf.scene];\n  const sceneNodes = scene.nodes;\n  const length = sceneNodes.length;\n\n  const stack = [];\n  const seen = {};\n\n  for (let i = 0; i < length; ++i) {\n    stack.push({\n      parentRuntimeNode: undefined,\n      gltfNode: nodes[sceneNodes[i]],\n      id: sceneNodes[i],\n    });\n\n    while (stack.length > 0) {\n      const n = stack.pop();\n      seen[n.id] = true;\n      const parentRuntimeNode = n.parentRuntimeNode;\n      const gltfNode = n.gltfNode;\n\n      // Node hierarchy is a DAG so a node can have more than one parent so it may already exist\n      const runtimeNode = runtimeNodes[n.id];\n      if (runtimeNode.parents.length === 0) {\n        if (defined(gltfNode.matrix)) {\n          runtimeNode.matrix = Matrix4.fromColumnMajorArray(gltfNode.matrix);\n        } else {\n          // TRS converted to Cesium types\n          const rotation = gltfNode.rotation;\n          runtimeNode.translation = Cartesian3.fromArray(gltfNode.translation);\n          runtimeNode.rotation = Quaternion.unpack(rotation);\n          runtimeNode.scale = Cartesian3.fromArray(gltfNode.scale);\n        }\n      }\n\n      if (defined(parentRuntimeNode)) {\n        parentRuntimeNode.children.push(runtimeNode);\n        runtimeNode.parents.push(parentRuntimeNode);\n      } else {\n        rootNodes.push(runtimeNode);\n      }\n\n      if (defined(gltfNode.mesh)) {\n        createCommand(model, gltfNode, runtimeNode, context, scene3DOnly);\n      }\n\n      const children = gltfNode.children;\n      if (defined(children)) {\n        const childrenLength = children.length;\n        for (let j = 0; j < childrenLength; j++) {\n          const childId = children[j];\n          if (!seen[childId]) {\n            stack.push({\n              parentRuntimeNode: runtimeNode,\n              gltfNode: nodes[childId],\n              id: children[j],\n            });\n          }\n        }\n      }\n    }\n  }\n\n  model._runtime.rootNodes = rootNodes;\n  model._runtime.nodes = runtimeNodes;\n}\n\nfunction getGeometryByteLength(buffers) {\n  let memory = 0;\n  for (const id in buffers) {\n    if (buffers.hasOwnProperty(id)) {\n      memory += buffers[id].sizeInBytes;\n    }\n  }\n  return memory;\n}\n\nfunction getTexturesByteLength(textures) {\n  let memory = 0;\n  for (const id in textures) {\n    if (textures.hasOwnProperty(id)) {\n      memory += textures[id].sizeInBytes;\n    }\n  }\n  return memory;\n}\n\nfunction createResources(model, frameState) {\n  const context = frameState.context;\n  const scene3DOnly = frameState.scene3DOnly;\n  const quantizedVertexShaders = model._quantizedVertexShaders;\n  const techniques = model._sourceTechniques;\n  const programs = model._sourcePrograms;\n\n  const resources = model._rendererResources;\n  let shaders = resources.sourceShaders;\n  if (model._loadRendererResourcesFromCache) {\n    shaders = resources.sourceShaders =\n      model._cachedRendererResources.sourceShaders;\n  }\n\n  for (const techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      const programId = techniques[techniqueId].program;\n      const program = programs[programId];\n      let shader = shaders[program.vertexShader];\n\n      ModelUtility.checkSupportedGlExtensions(program.glExtensions, context);\n\n      if (\n        model.extensionsUsed.WEB3D_quantized_attributes ||\n        model._dequantizeInShader\n      ) {\n        let quantizedVS = quantizedVertexShaders[programId];\n        if (!defined(quantizedVS)) {\n          quantizedVS = modifyShaderForQuantizedAttributes(\n            shader,\n            programId,\n            model\n          );\n          quantizedVertexShaders[programId] = quantizedVS;\n        }\n        shader = quantizedVS;\n      }\n\n      shader = modifyShader(shader, programId, model._vertexShaderLoaded);\n    }\n  }\n\n  if (model._loadRendererResourcesFromCache) {\n    const cachedResources = model._cachedRendererResources;\n\n    resources.buffers = cachedResources.buffers;\n    resources.vertexArrays = cachedResources.vertexArrays;\n    resources.programs = cachedResources.programs;\n    resources.silhouettePrograms = cachedResources.silhouettePrograms;\n    resources.textures = cachedResources.textures;\n    resources.samplers = cachedResources.samplers;\n    resources.renderStates = cachedResources.renderStates;\n\n    // Vertex arrays are unique to this model, create instead of using the cache.\n    if (defined(model._precreatedAttributes)) {\n      createVertexArrays(model, context);\n    }\n\n    model._cachedGeometryByteLength += getGeometryByteLength(\n      cachedResources.buffers\n    );\n    model._cachedTexturesByteLength += getTexturesByteLength(\n      cachedResources.textures\n    );\n  } else {\n    createBuffers(model, frameState); // using glTF bufferViews\n    createPrograms(model, frameState);\n    createSamplers(model, context);\n    loadTexturesFromBufferViews(model);\n    createTextures(model, frameState);\n  }\n\n  createSkins(model);\n  createRuntimeAnimations(model);\n\n  if (!model._loadRendererResourcesFromCache) {\n    createVertexArrays(model, context); // using glTF meshes\n    createRenderStates(model); // using glTF materials/techniques/states\n    // Long-term, we might not cache render states if they could change\n    // due to an animation, e.g., a uniform going from opaque to transparent.\n    // Could use copy-on-write if it is worth it.  Probably overkill.\n  }\n\n  createUniformMaps(model, context); // using glTF materials/techniques\n  createRuntimeNodes(model, context, scene3DOnly); // using glTF scene\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction getNodeMatrix(node, result) {\n  const publicNode = node.publicNode;\n  const publicMatrix = publicNode.matrix;\n\n  if (publicNode.useMatrix && defined(publicMatrix)) {\n    // Public matrix overrides original glTF matrix and glTF animations\n    Matrix4.clone(publicMatrix, result);\n  } else if (defined(node.matrix)) {\n    Matrix4.clone(node.matrix, result);\n  } else {\n    Matrix4.fromTranslationQuaternionRotationScale(\n      node.translation,\n      node.rotation,\n      node.scale,\n      result\n    );\n    // Keep matrix returned by the node in-sync if the node is targeted by an animation.  Only TRS nodes can be targeted.\n    publicNode.setMatrix(result);\n  }\n}\n\nconst scratchNodeStack = [];\nconst scratchComputedTranslation = new Cartesian4();\nconst scratchComputedMatrixIn2D = new Matrix4();\n\nfunction updateNodeHierarchyModelMatrix(\n  model,\n  modelTransformChanged,\n  justLoaded,\n  projection\n) {\n  const maxDirtyNumber = model._maxDirtyNumber;\n\n  const rootNodes = model._runtime.rootNodes;\n  const length = rootNodes.length;\n\n  const nodeStack = scratchNodeStack;\n  let computedModelMatrix = model._computedModelMatrix;\n\n  if (model._mode !== SceneMode.SCENE3D && !model._ignoreCommands) {\n    const translation = Matrix4.getColumn(\n      computedModelMatrix,\n      3,\n      scratchComputedTranslation\n    );\n    if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n      computedModelMatrix = Transforms.basisTo2D(\n        projection,\n        computedModelMatrix,\n        scratchComputedMatrixIn2D\n      );\n      model._rtcCenter = model._rtcCenter3D;\n    } else {\n      const center = model.boundingSphereInternal.center;\n      const to2D = Transforms.wgs84To2DModelMatrix(\n        projection,\n        center,\n        scratchComputedMatrixIn2D\n      );\n      computedModelMatrix = Matrix4.multiply(\n        to2D,\n        computedModelMatrix,\n        scratchComputedMatrixIn2D\n      );\n\n      if (defined(model._rtcCenter)) {\n        Matrix4.setTranslation(\n          computedModelMatrix,\n          Cartesian4.UNIT_W,\n          computedModelMatrix\n        );\n        model._rtcCenter = model._rtcCenter2D;\n      }\n    }\n  }\n\n  for (let i = 0; i < length; ++i) {\n    let n = rootNodes[i];\n\n    getNodeMatrix(n, n.transformToRoot);\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      const transformToRoot = n.transformToRoot;\n      const commands = n.commands;\n\n      if (\n        n.dirtyNumber === maxDirtyNumber ||\n        modelTransformChanged ||\n        justLoaded\n      ) {\n        const nodeMatrix = Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          transformToRoot,\n          n.computedMatrix\n        );\n        const commandsLength = commands.length;\n        if (commandsLength > 0) {\n          // Node has meshes, which has primitives.  Update their commands.\n          for (let j = 0; j < commandsLength; ++j) {\n            const primitiveCommand = commands[j];\n            let command = primitiveCommand.command;\n            Matrix4.clone(nodeMatrix, command.modelMatrix);\n\n            // PERFORMANCE_IDEA: Can use transformWithoutScale if no node up to the root has scale (including animation)\n            BoundingSphere.transform(\n              primitiveCommand.boundingSphere,\n              command.modelMatrix,\n              command.boundingVolume\n            );\n\n            if (defined(model._rtcCenter)) {\n              Cartesian3.add(\n                model._rtcCenter,\n                command.boundingVolume.center,\n                command.boundingVolume.center\n              );\n            }\n\n            // If the model crosses the IDL in 2D, it will be drawn in one viewport, but part of it\n            // will be clipped by the viewport. We create a second command that translates the model\n            // model matrix to the opposite side of the map so the part that was clipped in one viewport\n            // is drawn in the other.\n            command = primitiveCommand.command2D;\n            if (defined(command) && model._mode === SceneMode.SCENE2D) {\n              Matrix4.clone(nodeMatrix, command.modelMatrix);\n              command.modelMatrix[13] -=\n                CesiumMath.sign(command.modelMatrix[13]) *\n                2.0 *\n                CesiumMath.PI *\n                projection.ellipsoid.maximumRadius;\n              BoundingSphere.transform(\n                primitiveCommand.boundingSphere,\n                command.modelMatrix,\n                command.boundingVolume\n              );\n            }\n          }\n        }\n      }\n\n      const children = n.children;\n      if (defined(children)) {\n        const childrenLength = children.length;\n        for (let k = 0; k < childrenLength; ++k) {\n          const child = children[k];\n\n          // A node's transform needs to be updated if\n          // - It was targeted for animation this frame, or\n          // - Any of its ancestors were targeted for animation this frame\n\n          // PERFORMANCE_IDEA: if a child has multiple parents and only one of the parents\n          // is dirty, all the subtrees for each child instance will be dirty; we probably\n          // won't see this in the wild often.\n          child.dirtyNumber = Math.max(child.dirtyNumber, n.dirtyNumber);\n\n          if (child.dirtyNumber === maxDirtyNumber || justLoaded) {\n            // Don't check for modelTransformChanged since if only the model's model matrix changed,\n            // we do not need to rebuild the local transform-to-root, only the final\n            // [model's-model-matrix][transform-to-root] above.\n            getNodeMatrix(child, child.transformToRoot);\n            Matrix4.multiplyTransformation(\n              transformToRoot,\n              child.transformToRoot,\n              child.transformToRoot\n            );\n          }\n\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n\n  ++model._maxDirtyNumber;\n}\n\nlet scratchObjectSpace = new Matrix4();\n\nfunction applySkins(model) {\n  const skinnedNodes = model._runtime.skinnedNodes;\n  const length = skinnedNodes.length;\n\n  for (let i = 0; i < length; ++i) {\n    const node = skinnedNodes[i];\n\n    scratchObjectSpace = Matrix4.inverseTransformation(\n      node.transformToRoot,\n      scratchObjectSpace\n    );\n\n    const computedJointMatrices = node.computedJointMatrices;\n    const joints = node.joints;\n    const bindShapeMatrix = node.bindShapeMatrix;\n    const inverseBindMatrices = node.inverseBindMatrices;\n    const inverseBindMatricesLength = inverseBindMatrices.length;\n\n    for (let m = 0; m < inverseBindMatricesLength; ++m) {\n      // [joint-matrix] = [node-to-root^-1][joint-to-root][inverse-bind][bind-shape]\n      if (!defined(computedJointMatrices[m])) {\n        computedJointMatrices[m] = new Matrix4();\n      }\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(\n        scratchObjectSpace,\n        joints[m].transformToRoot,\n        computedJointMatrices[m]\n      );\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(\n        computedJointMatrices[m],\n        inverseBindMatrices[m],\n        computedJointMatrices[m]\n      );\n      if (defined(bindShapeMatrix)) {\n        // NOTE: bindShapeMatrix is glTF 1.0 only, removed in glTF 2.0.\n        computedJointMatrices[m] = Matrix4.multiplyTransformation(\n          computedJointMatrices[m],\n          bindShapeMatrix,\n          computedJointMatrices[m]\n        );\n      }\n    }\n  }\n}\n\nfunction updatePerNodeShow(model) {\n  // Totally not worth it, but we could optimize this:\n  // http://help.agi.com/AGIComponents/html/BlogDeletionInBoundingVolumeHierarchies.htm\n\n  const rootNodes = model._runtime.rootNodes;\n  const length = rootNodes.length;\n\n  const nodeStack = scratchNodeStack;\n\n  for (let i = 0; i < length; ++i) {\n    let n = rootNodes[i];\n    n.computedShow = n.publicNode.show;\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      const show = n.computedShow;\n\n      const nodeCommands = n.commands;\n      const nodeCommandsLength = nodeCommands.length;\n      for (let j = 0; j < nodeCommandsLength; ++j) {\n        nodeCommands[j].show = show;\n      }\n      // if commandsLength is zero, the node has a light or camera\n\n      const children = n.children;\n      if (defined(children)) {\n        const childrenLength = children.length;\n        for (let k = 0; k < childrenLength; ++k) {\n          const child = children[k];\n          // Parent needs to be shown for child to be shown.\n          child.computedShow = show && child.publicNode.show;\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n}\n\nfunction updatePickIds(model, context) {\n  const id = model.id;\n  if (model._id !== id) {\n    model._id = id;\n\n    const pickIds = model._pickIds;\n    const length = pickIds.length;\n    for (let i = 0; i < length; ++i) {\n      pickIds[i].object.id = id;\n    }\n  }\n}\n\nfunction updateWireframe(model) {\n  if (model._debugWireframe !== model.debugWireframe) {\n    model._debugWireframe = model.debugWireframe;\n\n    // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n    const primitiveType = model.debugWireframe\n      ? PrimitiveType.LINES\n      : PrimitiveType.TRIANGLES;\n    const nodeCommands = model._nodeCommands;\n    const length = nodeCommands.length;\n\n    for (let i = 0; i < length; ++i) {\n      nodeCommands[i].command.primitiveType = primitiveType;\n    }\n  }\n}\n\nfunction updateShowBoundingVolume(model) {\n  if (model.debugShowBoundingVolume !== model._debugShowBoundingVolume) {\n    model._debugShowBoundingVolume = model.debugShowBoundingVolume;\n\n    const debugShowBoundingVolume = model.debugShowBoundingVolume;\n    const nodeCommands = model._nodeCommands;\n    const length = nodeCommands.length;\n\n    for (let i = 0; i < length; ++i) {\n      nodeCommands[i].command.debugShowBoundingVolume = debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction updateShadows(model) {\n  if (model.shadows !== model._shadows) {\n    model._shadows = model.shadows;\n\n    const castShadows = ShadowMode.castShadows(model.shadows);\n    const receiveShadows = ShadowMode.receiveShadows(model.shadows);\n    const nodeCommands = model._nodeCommands;\n    const length = nodeCommands.length;\n\n    for (let i = 0; i < length; i++) {\n      const nodeCommand = nodeCommands[i];\n      nodeCommand.command.castShadows = castShadows;\n      nodeCommand.command.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nfunction getTranslucentRenderState(model, renderState) {\n  const rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n\n  if (model.opaquePass === Pass.CESIUM_3D_TILE) {\n    rs.stencilTest = StencilConstants.setCesium3DTileBit();\n    rs.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  }\n\n  return RenderState.fromCache(rs);\n}\n\nfunction deriveTranslucentCommand(model, command) {\n  const translucentCommand = DrawCommand.shallowClone(command);\n  translucentCommand.pass = Pass.TRANSLUCENT;\n  translucentCommand.renderState = getTranslucentRenderState(\n    model,\n    command.renderState\n  );\n  return translucentCommand;\n}\n\nfunction updateColor(model, frameState, forceDerive) {\n  // Generate translucent commands when the blend color has an alpha in the range (0.0, 1.0) exclusive\n  const scene3DOnly = frameState.scene3DOnly;\n  const alpha = model.color.alpha;\n  if (alpha > 0.0 && alpha < 1.0) {\n    const nodeCommands = model._nodeCommands;\n    const length = nodeCommands.length;\n    if (\n      length > 0 &&\n      (!defined(nodeCommands[0].translucentCommand) || forceDerive)\n    ) {\n      for (let i = 0; i < length; ++i) {\n        const nodeCommand = nodeCommands[i];\n        const command = nodeCommand.command;\n        nodeCommand.translucentCommand = deriveTranslucentCommand(\n          model,\n          command\n        );\n        if (!scene3DOnly) {\n          const command2D = nodeCommand.command2D;\n          nodeCommand.translucentCommand2D = deriveTranslucentCommand(\n            model,\n            command2D\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction getDisableCullingRenderState(renderState) {\n  const rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  return RenderState.fromCache(rs);\n}\n\nfunction deriveDisableCullingCommand(command) {\n  const disableCullingCommand = DrawCommand.shallowClone(command);\n  disableCullingCommand.renderState = getDisableCullingRenderState(\n    command.renderState\n  );\n  return disableCullingCommand;\n}\n\nfunction updateBackFaceCulling(model, frameState, forceDerive) {\n  const scene3DOnly = frameState.scene3DOnly;\n  const backFaceCulling = model.backFaceCulling;\n  if (!backFaceCulling) {\n    const nodeCommands = model._nodeCommands;\n    const length = nodeCommands.length;\n    if (\n      length > 0 &&\n      (!defined(nodeCommands[0].disableCullingCommand) || forceDerive)\n    ) {\n      for (let i = 0; i < length; ++i) {\n        const nodeCommand = nodeCommands[i];\n        const command = nodeCommand.command;\n        nodeCommand.disableCullingCommand = deriveDisableCullingCommand(\n          command\n        );\n        if (!scene3DOnly) {\n          const command2D = nodeCommand.command2D;\n          nodeCommand.disableCullingCommand2D = deriveDisableCullingCommand(\n            command2D\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction getProgramId(model, program) {\n  const programs = model._rendererResources.programs;\n  for (const id in programs) {\n    if (programs.hasOwnProperty(id)) {\n      if (programs[id] === program) {\n        return id;\n      }\n    }\n  }\n}\n\nfunction createSilhouetteProgram(model, program, frameState) {\n  let vs = program.vertexShaderSource.sources[0];\n  const attributeLocations = program._attributeLocations;\n  const normalAttributeName = model._normalAttributeName;\n\n  // Modified from http://forum.unity3d.com/threads/toon-outline-but-with-diffuse-surface.24668/\n  vs = ShaderSource.replaceMain(vs, \"gltf_silhouette_main\");\n  vs +=\n    `${\n      \"uniform float gltf_silhouetteSize; \\n\" +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    gltf_silhouette_main(); \\n\" +\n      \"    vec3 n = normalize(czm_normal3D * \"\n    }${normalAttributeName}); \\n` +\n    `    n.x *= czm_projection[0][0]; \\n` +\n    `    n.y *= czm_projection[1][1]; \\n` +\n    `    vec4 clip = gl_Position; \\n` +\n    `    clip.xy += n.xy * clip.w * gltf_silhouetteSize * czm_pixelRatio / czm_viewport.z; \\n` +\n    `    gl_Position = clip; \\n` +\n    `}`;\n\n  const fs =\n    \"uniform vec4 gltf_silhouetteColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gl_FragColor = czm_gammaCorrect(gltf_silhouetteColor); \\n\" +\n    \"}\";\n\n  return ShaderProgram.fromCache({\n    context: frameState.context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction hasSilhouette(model, frameState) {\n  return (\n    silhouetteSupported(frameState.context) &&\n    model.silhouetteSize > 0.0 &&\n    model.silhouetteColor.alpha > 0.0 &&\n    defined(model._normalAttributeName)\n  );\n}\n\nfunction hasTranslucentCommands(model) {\n  const nodeCommands = model._nodeCommands;\n  const length = nodeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    const nodeCommand = nodeCommands[i];\n    const command = nodeCommand.command;\n    if (command.pass === Pass.TRANSLUCENT) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isTranslucent(model) {\n  return model.color.alpha > 0.0 && model.color.alpha < 1.0;\n}\n\nfunction isInvisible(model) {\n  return model.color.alpha === 0.0;\n}\n\nfunction alphaDirty(currAlpha, prevAlpha) {\n  // Returns whether the alpha state has changed between invisible, translucent, or opaque\n  return (\n    Math.floor(currAlpha) !== Math.floor(prevAlpha) ||\n    Math.ceil(currAlpha) !== Math.ceil(prevAlpha)\n  );\n}\n\nlet silhouettesLength = 0;\n\nfunction createSilhouetteCommands(model, frameState) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  const stencilReference = ++silhouettesLength % 255;\n\n  // If the model is translucent the silhouette needs to be in the translucent pass.\n  // Otherwise the silhouette would be rendered before the model.\n  const silhouetteTranslucent =\n    hasTranslucentCommands(model) ||\n    isTranslucent(model) ||\n    model.silhouetteColor.alpha < 1.0;\n  const silhouettePrograms = model._rendererResources.silhouettePrograms;\n  const scene3DOnly = frameState.scene3DOnly;\n  const nodeCommands = model._nodeCommands;\n  const length = nodeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    const nodeCommand = nodeCommands[i];\n    const command = nodeCommand.command;\n\n    // Create model command\n    const modelCommand = isTranslucent(model)\n      ? nodeCommand.translucentCommand\n      : command;\n    const silhouetteModelCommand = DrawCommand.shallowClone(modelCommand);\n    let renderState = clone(modelCommand.renderState);\n\n    // Write the reference value into the stencil buffer.\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.ALWAYS,\n      backFunction: WebGLConstants.ALWAYS,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE,\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE,\n      },\n    };\n\n    if (isInvisible(model)) {\n      // When the model is invisible disable color and depth writes but still write into the stencil buffer\n      renderState.colorMask = {\n        red: false,\n        green: false,\n        blue: false,\n        alpha: false,\n      };\n      renderState.depthMask = false;\n    }\n    renderState = RenderState.fromCache(renderState);\n    silhouetteModelCommand.renderState = renderState;\n    nodeCommand.silhouetteModelCommand = silhouetteModelCommand;\n\n    // Create color command\n    const silhouetteColorCommand = DrawCommand.shallowClone(command);\n    renderState = clone(command.renderState, true);\n    renderState.depthTest.enabled = true;\n    renderState.cull.enabled = false;\n    if (silhouetteTranslucent) {\n      silhouetteColorCommand.pass = Pass.TRANSLUCENT;\n      renderState.depthMask = false;\n      renderState.blending = BlendingState.ALPHA_BLEND;\n    }\n\n    // Only render silhouette if the value in the stencil buffer equals the reference\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.NOTEQUAL,\n      backFunction: WebGLConstants.NOTEQUAL,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP,\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP,\n      },\n    };\n    renderState = RenderState.fromCache(renderState);\n\n    // If the silhouette program has already been cached use it\n    const program = command.shaderProgram;\n    const id = getProgramId(model, program);\n    let silhouetteProgram = silhouettePrograms[id];\n    if (!defined(silhouetteProgram)) {\n      silhouetteProgram = createSilhouetteProgram(model, program, frameState);\n      silhouettePrograms[id] = silhouetteProgram;\n    }\n\n    const silhouetteUniformMap = combine(command.uniformMap, {\n      gltf_silhouetteColor: createSilhouetteColorFunction(model),\n      gltf_silhouetteSize: createSilhouetteSizeFunction(model),\n    });\n\n    silhouetteColorCommand.renderState = renderState;\n    silhouetteColorCommand.shaderProgram = silhouetteProgram;\n    silhouetteColorCommand.uniformMap = silhouetteUniformMap;\n    silhouetteColorCommand.castShadows = false;\n    silhouetteColorCommand.receiveShadows = false;\n    nodeCommand.silhouetteColorCommand = silhouetteColorCommand;\n\n    if (!scene3DOnly) {\n      const command2D = nodeCommand.command2D;\n      const silhouetteModelCommand2D = DrawCommand.shallowClone(\n        silhouetteModelCommand\n      );\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteModelCommand2D = silhouetteModelCommand2D;\n\n      const silhouetteColorCommand2D = DrawCommand.shallowClone(\n        silhouetteColorCommand\n      );\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteColorCommand2D = silhouetteColorCommand2D;\n    }\n  }\n}\n\nfunction modifyShaderForClippingPlanes(\n  shader,\n  clippingPlaneCollection,\n  context\n) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_clip_main\");\n  shader += `${Model._getClippingFunction(clippingPlaneCollection, context)}\\n`;\n  shader += `${\n    \"uniform highp sampler2D gltf_clippingPlanes; \\n\" +\n    \"uniform mat4 gltf_clippingPlanesMatrix; \\n\" +\n    \"uniform vec4 gltf_clippingPlanesEdgeStyle; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gltf_clip_main(); \\n\"\n  }${getClipAndStyleCode(\n    \"gltf_clippingPlanes\",\n    \"gltf_clippingPlanesMatrix\",\n    \"gltf_clippingPlanesEdgeStyle\"\n  )}} \\n`;\n  return shader;\n}\n\nfunction updateSilhouette(model, frameState, force) {\n  // Generate silhouette commands when the silhouette size is greater than 0.0 and the alpha is greater than 0.0\n  // There are two silhouette commands:\n  //     1. silhouetteModelCommand : render model normally while enabling stencil mask\n  //     2. silhouetteColorCommand : render enlarged model with a solid color while enabling stencil tests\n  if (!hasSilhouette(model, frameState)) {\n    return;\n  }\n\n  const nodeCommands = model._nodeCommands;\n  const dirty =\n    nodeCommands.length > 0 &&\n    (alphaDirty(model.color.alpha, model._colorPreviousAlpha) ||\n      alphaDirty(\n        model.silhouetteColor.alpha,\n        model._silhouetteColorPreviousAlpha\n      ) ||\n      !defined(nodeCommands[0].silhouetteModelCommand));\n\n  model._colorPreviousAlpha = model.color.alpha;\n  model._silhouetteColorPreviousAlpha = model.silhouetteColor.alpha;\n\n  if (dirty || force) {\n    createSilhouetteCommands(model, frameState);\n  }\n}\n\nfunction updateClippingPlanes(model, frameState) {\n  const clippingPlanes = model._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.owner === model) {\n    if (clippingPlanes.enabled) {\n      clippingPlanes.update(frameState);\n    }\n  }\n}\n\nconst scratchBoundingSphere = new BoundingSphere();\n\nfunction scaleInPixels(positionWC, radius, frameState) {\n  scratchBoundingSphere.center = positionWC;\n  scratchBoundingSphere.radius = radius;\n  return frameState.camera.getPixelSize(\n    scratchBoundingSphere,\n    frameState.context.drawingBufferWidth,\n    frameState.context.drawingBufferHeight\n  );\n}\n\nconst scratchPosition = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n\nfunction getScale(model, frameState) {\n  let scale = model.scale;\n\n  if (model.minimumPixelSize !== 0.0) {\n    // Compute size of bounding sphere in pixels\n    const context = frameState.context;\n    const maxPixelSize = Math.max(\n      context.drawingBufferWidth,\n      context.drawingBufferHeight\n    );\n    const m = defined(model._clampedModelMatrix)\n      ? model._clampedModelMatrix\n      : model.modelMatrix;\n    scratchPosition.x = m[12];\n    scratchPosition.y = m[13];\n    scratchPosition.z = m[14];\n\n    if (defined(model._rtcCenter)) {\n      Cartesian3.add(model._rtcCenter, scratchPosition, scratchPosition);\n    }\n\n    if (model._mode !== SceneMode.SCENE3D) {\n      const projection = frameState.mapProjection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        scratchPosition,\n        scratchCartographic\n      );\n      projection.project(cartographic, scratchPosition);\n      Cartesian3.fromElements(\n        scratchPosition.z,\n        scratchPosition.x,\n        scratchPosition.y,\n        scratchPosition\n      );\n    }\n\n    const radius = model.boundingSphereInternal.radius;\n    const metersPerPixel = scaleInPixels(scratchPosition, radius, frameState);\n\n    // metersPerPixel is always > 0.0\n    const pixelsPerMeter = 1.0 / metersPerPixel;\n    const diameterInPixels = Math.min(\n      pixelsPerMeter * (2.0 * radius),\n      maxPixelSize\n    );\n\n    // Maintain model's minimum pixel size\n    if (diameterInPixels < model.minimumPixelSize) {\n      scale =\n        (model.minimumPixelSize * metersPerPixel) /\n        (2.0 * model._initialRadius);\n    }\n  }\n\n  return defined(model.maximumScale)\n    ? Math.min(model.maximumScale, scale)\n    : scale;\n}\n\nfunction releaseCachedGltf(model) {\n  if (\n    defined(model._cacheKey) &&\n    defined(model._cachedGltf) &&\n    --model._cachedGltf.count === 0\n  ) {\n    delete gltfCache[model._cacheKey];\n  }\n  model._cachedGltf = undefined;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction CachedRendererResources(context, cacheKey) {\n  this.buffers = undefined;\n  this.vertexArrays = undefined;\n  this.programs = undefined;\n  this.sourceShaders = undefined;\n  this.silhouettePrograms = undefined;\n  this.textures = undefined;\n  this.samplers = undefined;\n  this.renderStates = undefined;\n  this.ready = false;\n\n  this.context = context;\n  this.cacheKey = cacheKey;\n  this.count = 0;\n}\n\nfunction destroy(property) {\n  for (const name in property) {\n    if (property.hasOwnProperty(name)) {\n      property[name].destroy();\n    }\n  }\n}\n\nfunction destroyCachedRendererResources(resources) {\n  destroy(resources.buffers);\n  destroy(resources.vertexArrays);\n  destroy(resources.programs);\n  destroy(resources.silhouettePrograms);\n  destroy(resources.textures);\n}\n\nCachedRendererResources.prototype.release = function () {\n  if (--this.count === 0) {\n    if (defined(this.cacheKey)) {\n      // Remove if this was cached\n      delete this.context.cache.modelRendererResourceCache[this.cacheKey];\n    }\n    destroyCachedRendererResources(this);\n    return destroyObject(this);\n  }\n\n  return undefined;\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction getUpdateHeightCallback(model, ellipsoid, cartoPosition) {\n  return function (clampedPosition) {\n    if (model.heightReference === HeightReference.RELATIVE_TO_GROUND) {\n      const clampedCart = ellipsoid.cartesianToCartographic(\n        clampedPosition,\n        scratchCartographic\n      );\n      clampedCart.height += cartoPosition.height;\n      ellipsoid.cartographicToCartesian(clampedCart, clampedPosition);\n    }\n\n    const clampedModelMatrix = model._clampedModelMatrix;\n\n    // Modify clamped model matrix to use new height\n    Matrix4.clone(model.modelMatrix, clampedModelMatrix);\n    clampedModelMatrix[12] = clampedPosition.x;\n    clampedModelMatrix[13] = clampedPosition.y;\n    clampedModelMatrix[14] = clampedPosition.z;\n\n    model._heightChanged = true;\n  };\n}\n\nfunction updateClamping(model) {\n  if (defined(model._removeUpdateHeightCallback)) {\n    model._removeUpdateHeightCallback();\n    model._removeUpdateHeightCallback = undefined;\n  }\n\n  const scene = model._scene;\n  if (\n    !defined(scene) ||\n    !defined(scene.globe) ||\n    model.heightReference === HeightReference.NONE\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (model.heightReference !== HeightReference.NONE) {\n      throw new DeveloperError(\n        \"Height reference is not supported without a scene and globe.\"\n      );\n    }\n    //>>includeEnd('debug');\n    model._clampedModelMatrix = undefined;\n    return;\n  }\n\n  const globe = scene.globe;\n  const ellipsoid = globe.ellipsoid;\n\n  // Compute cartographic position so we don't recompute every update\n  const modelMatrix = model.modelMatrix;\n  scratchPosition.x = modelMatrix[12];\n  scratchPosition.y = modelMatrix[13];\n  scratchPosition.z = modelMatrix[14];\n  const cartoPosition = ellipsoid.cartesianToCartographic(scratchPosition);\n\n  if (!defined(model._clampedModelMatrix)) {\n    model._clampedModelMatrix = Matrix4.clone(modelMatrix, new Matrix4());\n  }\n\n  // Install callback to handle updating of terrain tiles\n  const surface = globe._surface;\n  model._removeUpdateHeightCallback = surface.updateHeight(\n    cartoPosition,\n    getUpdateHeightCallback(model, ellipsoid, cartoPosition)\n  );\n\n  // Set the correct height now\n  const height = globe.getHeight(cartoPosition);\n  if (defined(height)) {\n    // Get callback with cartoPosition being the non-clamped position\n    const cb = getUpdateHeightCallback(model, ellipsoid, cartoPosition);\n\n    // Compute the clamped cartesian and call updateHeight callback\n    Cartographic.clone(cartoPosition, scratchCartographic);\n    scratchCartographic.height = height;\n    ellipsoid.cartographicToCartesian(scratchCartographic, scratchPosition);\n    cb(scratchPosition);\n  }\n}\n\nconst scratchDisplayConditionCartesian = new Cartesian3();\nconst scratchDistanceDisplayConditionCartographic = new Cartographic();\n\nfunction distanceDisplayConditionVisible(model, frameState) {\n  let distance2;\n  const ddc = model.distanceDisplayCondition;\n  const nearSquared = ddc.near * ddc.near;\n  const farSquared = ddc.far * ddc.far;\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    const frustum2DWidth =\n      frameState.camera.frustum.right - frameState.camera.frustum.left;\n    distance2 = frustum2DWidth * 0.5;\n    distance2 = distance2 * distance2;\n  } else {\n    // Distance to center of primitive's reference frame\n    let position = Matrix4.getTranslation(\n      model.modelMatrix,\n      scratchDisplayConditionCartesian\n    );\n    if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n      const projection = frameState.mapProjection;\n      const ellipsoid = projection.ellipsoid;\n      const cartographic = ellipsoid.cartesianToCartographic(\n        position,\n        scratchDistanceDisplayConditionCartographic\n      );\n      position = projection.project(cartographic, position);\n      Cartesian3.fromElements(position.z, position.x, position.y, position);\n    }\n    distance2 = Cartesian3.distanceSquared(\n      position,\n      frameState.camera.positionWC\n    );\n  }\n\n  return distance2 >= nearSquared && distance2 <= farSquared;\n}\n\nconst scratchIBLReferenceFrameMatrix4 = new Matrix4();\nconst scratchIBLReferenceFrameMatrix3 = new Matrix3();\nconst scratchClippingPlanesMatrix = new Matrix4();\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Failed to load external reference.\n */\nModel.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!FeatureDetection.supportsWebP.initialized) {\n    FeatureDetection.supportsWebP.initialize();\n    return;\n  }\n\n  const context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  const supportsWebP = FeatureDetection.supportsWebP();\n\n  if (this._state === ModelState.NEEDS_LOAD && defined(this.gltfInternal)) {\n    // Use renderer resources from cache instead of loading/creating them?\n    let cachedRendererResources;\n    const cacheKey = this.cacheKey;\n    if (defined(cacheKey)) {\n      // cache key given? this model will pull from or contribute to context level cache\n      context.cache.modelRendererResourceCache = defaultValue(\n        context.cache.modelRendererResourceCache,\n        {}\n      );\n      const modelCaches = context.cache.modelRendererResourceCache;\n\n      cachedRendererResources = modelCaches[this.cacheKey];\n      if (defined(cachedRendererResources)) {\n        if (!cachedRendererResources.ready) {\n          // Cached resources for the model are not loaded yet.  We'll\n          // try again every frame until they are.\n          return;\n        }\n\n        ++cachedRendererResources.count;\n        this._loadRendererResourcesFromCache = true;\n      } else {\n        cachedRendererResources = new CachedRendererResources(\n          context,\n          cacheKey\n        );\n        cachedRendererResources.count = 1;\n        modelCaches[this.cacheKey] = cachedRendererResources;\n      }\n      this._cachedRendererResources = cachedRendererResources;\n    } else {\n      // cache key not given? this model doesn't care about context level cache at all. Cache is here to simplify freeing on destroy.\n      cachedRendererResources = new CachedRendererResources(context);\n      cachedRendererResources.count = 1;\n      this._cachedRendererResources = cachedRendererResources;\n    }\n\n    this._state = ModelState.LOADING;\n    if (this._state !== ModelState.FAILED) {\n      const extensions = this.gltfInternal.extensions;\n      if (defined(extensions) && defined(extensions.CESIUM_RTC)) {\n        const center = Cartesian3.fromArray(extensions.CESIUM_RTC.center);\n        if (!Cartesian3.equals(center, Cartesian3.ZERO)) {\n          this._rtcCenter3D = center;\n\n          const projection = frameState.mapProjection;\n          const ellipsoid = projection.ellipsoid;\n          const cartographic = ellipsoid.cartesianToCartographic(\n            this._rtcCenter3D\n          );\n          const projectedCart = projection.project(cartographic);\n          Cartesian3.fromElements(\n            projectedCart.z,\n            projectedCart.x,\n            projectedCart.y,\n            projectedCart\n          );\n          this._rtcCenter2D = projectedCart;\n\n          this._rtcCenterEye = new Cartesian3();\n          this._rtcCenter = this._rtcCenter3D;\n        }\n      }\n\n      addPipelineExtras(this.gltfInternal);\n\n      this._loadResources = new ModelLoadResources();\n      if (!this._loadRendererResourcesFromCache) {\n        // Buffers are required to updateVersion\n        ModelUtility.parseBuffers(this, bufferLoad);\n      }\n    }\n  }\n\n  const loadResources = this._loadResources;\n  const incrementallyLoadTextures = this._incrementallyLoadTextures;\n  let justLoaded = false;\n\n  if (this._state === ModelState.LOADING) {\n    // Transition from LOADING -> LOADED once resources are downloaded and created.\n    // Textures may continue to stream in while in the LOADED state.\n    if (loadResources.pendingBufferLoads === 0) {\n      if (!loadResources.initialized) {\n        frameState.brdfLutGenerator.update(frameState);\n\n        ModelUtility.checkSupportedExtensions(\n          this.extensionsRequired,\n          supportsWebP\n        );\n        ModelUtility.updateForwardAxis(this);\n\n        // glTF pipeline updates, not needed if loading from cache\n        if (!defined(this.gltfInternal.extras.sourceVersion)) {\n          const gltf = this.gltfInternal;\n          // Add the original version so it remains cached\n          const sourceVersion = ModelUtility.getAssetVersion(gltf);\n          const sourceKHRTechniquesWebGL = defined(\n            ModelUtility.getUsedExtensions(gltf).KHR_techniques_webgl\n          );\n\n          if (sourceVersion !== \"2.0\") {\n            deprecationWarning(\n              \"gltf-1.0\",\n              \"glTF 1.0 assets were deprecated in CesiumJS 1.94. They will be removed in 1.95. Please convert any glTF 1.0 assets to glTF 2.0.\"\n            );\n          }\n\n          if (sourceKHRTechniquesWebGL) {\n            deprecationWarning(\n              \"KHR_techniques_webgl\",\n              \"Support for glTF 1.0 techniques and the KHR_techniques_webgl glTF extension were deprecated in CesiumJS 1.94. It will be removed in 1.95. If custom GLSL shaders are needed, use CustomShader instead.\"\n            );\n          }\n\n          gltf.extras.sourceVersion = sourceVersion;\n          gltf.extras.sourceKHRTechniquesWebGL = sourceKHRTechniquesWebGL;\n\n          this._sourceVersion = sourceVersion;\n          this._sourceKHRTechniquesWebGL = sourceKHRTechniquesWebGL;\n\n          updateVersion(gltf);\n          addDefaults(gltf);\n\n          const options = {\n            addBatchIdToGeneratedShaders: this._addBatchIdToGeneratedShaders,\n          };\n\n          processModelMaterialsCommon(gltf, options);\n          processPbrMaterials(gltf, options);\n        }\n\n        this._sourceVersion = this.gltfInternal.extras.sourceVersion;\n        this._sourceKHRTechniquesWebGL = this.gltfInternal.extras.sourceKHRTechniquesWebGL;\n\n        // Skip dequantizing in the shader if not encoded\n        this._dequantizeInShader =\n          this._dequantizeInShader && DracoLoader.hasExtension(this);\n\n        // We do this after to make sure that the ids don't change\n        addBuffersToLoadResources(this);\n        parseArticulations(this);\n        parseTechniques(this);\n        if (!this._loadRendererResourcesFromCache) {\n          parseBufferViews(this);\n          parseShaders(this);\n          parsePrograms(this);\n          parseTextures(this, context, supportsWebP);\n        }\n        parseMaterials(this);\n        parseMeshes(this);\n        parseNodes(this);\n        parseCredits(this);\n\n        // Start draco decoding\n        DracoLoader.parse(this, context);\n\n        loadResources.initialized = true;\n      }\n\n      if (!loadResources.finishedDecoding()) {\n        DracoLoader.decodeModel(this, context).catch(\n          ModelUtility.getFailedLoadFunction(\n            this,\n            \"model\",\n            this.basePathInternal\n          )\n        );\n      }\n\n      if (loadResources.finishedDecoding() && !loadResources.resourcesParsed) {\n        this._boundingSphere = ModelUtility.computeBoundingSphere(this);\n        this._initialRadius = this._boundingSphere.radius;\n\n        DracoLoader.cacheDataForModel(this);\n\n        loadResources.resourcesParsed = true;\n      }\n\n      if (\n        loadResources.resourcesParsed &&\n        loadResources.pendingShaderLoads === 0\n      ) {\n        if (this.showOutline) {\n          ModelOutlineLoader.outlinePrimitives(this);\n        }\n        createResources(this, frameState);\n      }\n    }\n\n    if (\n      loadResources.finished() ||\n      (incrementallyLoadTextures &&\n        loadResources.finishedEverythingButTextureCreation())\n    ) {\n      this._state = ModelState.LOADED;\n      justLoaded = true;\n    }\n  }\n\n  // Incrementally stream textures.\n  if (defined(loadResources) && this._state === ModelState.LOADED) {\n    if (incrementallyLoadTextures && !justLoaded) {\n      createResources(this, frameState);\n    }\n\n    if (loadResources.finished()) {\n      this._loadResources = undefined; // Clear CPU memory since WebGL resources were created.\n\n      const resources = this._rendererResources;\n      const cachedResources = this._cachedRendererResources;\n\n      cachedResources.buffers = resources.buffers;\n      cachedResources.vertexArrays = resources.vertexArrays;\n      cachedResources.programs = resources.programs;\n      cachedResources.sourceShaders = resources.sourceShaders;\n      cachedResources.silhouettePrograms = resources.silhouettePrograms;\n      cachedResources.textures = resources.textures;\n      cachedResources.samplers = resources.samplers;\n      cachedResources.renderStates = resources.renderStates;\n      cachedResources.ready = true;\n\n      // The normal attribute name is required for silhouettes, so get it before the gltf JSON is released\n      this._normalAttributeName = ModelUtility.getAttributeOrUniformBySemantic(\n        this.gltfInternal,\n        \"NORMAL\"\n      );\n\n      // Vertex arrays are unique to this model, do not store in cache.\n      if (defined(this._precreatedAttributes)) {\n        cachedResources.vertexArrays = {};\n      }\n\n      if (this.releaseGltfJson) {\n        releaseCachedGltf(this);\n      }\n    }\n  }\n\n  const silhouette = hasSilhouette(this, frameState);\n  const translucent = isTranslucent(this);\n  const invisible = isInvisible(this);\n  const backFaceCulling = this.backFaceCulling;\n  const displayConditionPassed = defined(this.distanceDisplayCondition)\n    ? distanceDisplayConditionVisible(this, frameState)\n    : true;\n  const show =\n    this.show &&\n    displayConditionPassed &&\n    this.scale !== 0.0 &&\n    (!invisible || silhouette);\n\n  this._imageBasedLighting.update(frameState);\n\n  if ((show && this._state === ModelState.LOADED) || justLoaded) {\n    const animated =\n      this.activeAnimations.update(frameState) || this._cesiumAnimationsDirty;\n    this._cesiumAnimationsDirty = false;\n    this._dirty = false;\n    let modelMatrix = this.modelMatrix;\n\n    const modeChanged = frameState.mode !== this._mode;\n    this._mode = frameState.mode;\n\n    // Model's model matrix needs to be updated\n    const modelTransformChanged =\n      !Matrix4.equals(this._modelMatrix, modelMatrix) ||\n      this._scale !== this.scale ||\n      this._minimumPixelSize !== this.minimumPixelSize ||\n      this.minimumPixelSize !== 0.0 || // Minimum pixel size changed or is enabled\n      this._maximumScale !== this.maximumScale ||\n      this._heightReference !== this.heightReference ||\n      this._heightChanged ||\n      modeChanged;\n\n    if (modelTransformChanged || justLoaded) {\n      Matrix4.clone(modelMatrix, this._modelMatrix);\n\n      updateClamping(this);\n\n      if (defined(this._clampedModelMatrix)) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      this._scale = this.scale;\n      this._minimumPixelSize = this.minimumPixelSize;\n      this._maximumScale = this.maximumScale;\n      this._heightReference = this.heightReference;\n      this._heightChanged = false;\n\n      const scale = getScale(this, frameState);\n      const computedModelMatrix = this._computedModelMatrix;\n      Matrix4.multiplyByUniformScale(modelMatrix, scale, computedModelMatrix);\n      if (this._upAxis === Axis.Y) {\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.Y_UP_TO_Z_UP,\n          computedModelMatrix\n        );\n      } else if (this._upAxis === Axis.X) {\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.X_UP_TO_Z_UP,\n          computedModelMatrix\n        );\n      }\n      if (this.forwardAxis === Axis.Z) {\n        // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.Z_UP_TO_X_UP,\n          computedModelMatrix\n        );\n      }\n    }\n\n    // Update modelMatrix throughout the graph as needed\n    if (animated || modelTransformChanged || justLoaded) {\n      updateNodeHierarchyModelMatrix(\n        this,\n        modelTransformChanged,\n        justLoaded,\n        frameState.mapProjection\n      );\n      this._dirty = true;\n\n      if (animated || justLoaded) {\n        // Apply skins if animation changed any node transforms\n        applySkins(this);\n      }\n    }\n\n    if (this._perNodeShowDirty) {\n      this._perNodeShowDirty = false;\n      updatePerNodeShow(this);\n    }\n    updatePickIds(this, context);\n    updateWireframe(this);\n    updateShowBoundingVolume(this);\n    updateShadows(this);\n    updateClippingPlanes(this, frameState);\n\n    // Regenerate shaders if ClippingPlaneCollection state changed or it was removed\n    const clippingPlanes = this._clippingPlanes;\n    let currentClippingPlanesState = 0;\n\n    // If defined, use the reference matrix to transform miscellaneous properties like\n    // clipping planes and IBL instead of the modelMatrix. This is so that when\n    // models are part of a tileset these properties get transformed relative to\n    // a common reference (such as the root).\n    const referenceMatrix = defaultValue(this.referenceMatrix, modelMatrix);\n\n    if (\n      this._imageBasedLighting.useSphericalHarmonicCoefficients ||\n      this._imageBasedLighting.useSpecularEnvironmentMaps\n    ) {\n      let iblReferenceFrameMatrix3 = scratchIBLReferenceFrameMatrix3;\n      let iblReferenceFrameMatrix4 = scratchIBLReferenceFrameMatrix4;\n\n      iblReferenceFrameMatrix4 = Matrix4.multiply(\n        context.uniformState.view3D,\n        referenceMatrix,\n        iblReferenceFrameMatrix4\n      );\n      iblReferenceFrameMatrix3 = Matrix4.getMatrix3(\n        iblReferenceFrameMatrix4,\n        iblReferenceFrameMatrix3\n      );\n      iblReferenceFrameMatrix3 = Matrix3.getRotation(\n        iblReferenceFrameMatrix3,\n        iblReferenceFrameMatrix3\n      );\n      this._iblReferenceFrameMatrix = Matrix3.transpose(\n        iblReferenceFrameMatrix3,\n        this._iblReferenceFrameMatrix\n      );\n    }\n\n    this._shouldRegenerateShaders =\n      this._shouldRegenerateShaders ||\n      this._imageBasedLighting.shouldRegenerateShaders;\n\n    if (isClippingEnabled(this)) {\n      let clippingPlanesMatrix = scratchClippingPlanesMatrix;\n      clippingPlanesMatrix = Matrix4.multiply(\n        context.uniformState.view3D,\n        referenceMatrix,\n        clippingPlanesMatrix\n      );\n      clippingPlanesMatrix = Matrix4.multiply(\n        clippingPlanesMatrix,\n        clippingPlanes.modelMatrix,\n        clippingPlanesMatrix\n      );\n      this._clippingPlanesMatrix = Matrix4.inverseTranspose(\n        clippingPlanesMatrix,\n        this._clippingPlanesMatrix\n      );\n      currentClippingPlanesState = clippingPlanes.clippingPlanesState;\n    }\n\n    this._shouldRegenerateShaders =\n      this._shouldRegenerateShaders ||\n      this._clippingPlanesState !== currentClippingPlanesState;\n    this._clippingPlanesState = currentClippingPlanesState;\n\n    // Regenerate shaders if color shading changed from last update\n    const currentlyColorShadingEnabled = isColorShadingEnabled(this);\n    if (currentlyColorShadingEnabled !== this._colorShadingEnabled) {\n      this._colorShadingEnabled = currentlyColorShadingEnabled;\n      this._shouldRegenerateShaders = true;\n    }\n\n    // Regenerate shaders if splitting was enabled/disabled from last update\n    const splittingEnabled = this.splitDirection !== SplitDirection.NONE;\n    if (this._splittingEnabled !== splittingEnabled) {\n      this._splittingEnabled = splittingEnabled;\n      this._shouldRegenerateShaders = true;\n    }\n\n    if (this._shouldRegenerateShaders) {\n      regenerateShaders(this, frameState);\n    } else {\n      updateColor(this, frameState, false);\n      updateBackFaceCulling(this, frameState, false);\n      updateSilhouette(this, frameState, false);\n    }\n  }\n\n  if (justLoaded) {\n    // Called after modelMatrix update.\n    const model = this;\n    frameState.afterRender.push(function () {\n      model._ready = true;\n      model._readyPromise.resolve(model);\n    });\n    return;\n  }\n\n  // We don't check show at the top of the function since we\n  // want to be able to progressively load models when they are not shown,\n  // and then have them visible immediately when show is set to true.\n  if (show && !this._ignoreCommands) {\n    // PERFORMANCE_IDEA: This is terrible\n    const commandList = frameState.commandList;\n    const passes = frameState.passes;\n    const nodeCommands = this._nodeCommands;\n    const length = nodeCommands.length;\n    let i;\n    let nc;\n\n    const idl2D =\n      frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n    let boundingVolume;\n\n    if (passes.render || (passes.pick && this.allowPicking)) {\n      for (i = 0; i < length; ++i) {\n        nc = nodeCommands[i];\n        if (nc.show) {\n          let command = nc.command;\n          if (silhouette) {\n            command = nc.silhouetteModelCommand;\n          } else if (translucent) {\n            command = nc.translucentCommand;\n          } else if (!backFaceCulling) {\n            command = nc.disableCullingCommand;\n          }\n          commandList.push(command);\n          boundingVolume = nc.command.boundingVolume;\n          const left = boundingVolume.center.y - boundingVolume.radius;\n          const right = boundingVolume.center.y + boundingVolume.radius;\n          const overIdl =\n            (left < idl2D && right > idl2D) ||\n            (left < -idl2D && right > -idl2D);\n          if (frameState.mode === SceneMode.SCENE2D && overIdl) {\n            let command2D = nc.command2D;\n            if (silhouette) {\n              command2D = nc.silhouetteModelCommand2D;\n            } else if (translucent) {\n              command2D = nc.translucentCommand2D;\n            } else if (!backFaceCulling) {\n              command2D = nc.disableCullingCommand2D;\n            }\n            commandList.push(command2D);\n          }\n        }\n      }\n\n      if (silhouette && !passes.pick) {\n        // Render second silhouette pass\n        for (i = 0; i < length; ++i) {\n          nc = nodeCommands[i];\n          if (nc.show) {\n            commandList.push(nc.silhouetteColorCommand);\n            boundingVolume = nc.command.boundingVolume;\n            const left = boundingVolume.center.y - boundingVolume.radius;\n            const right = boundingVolume.center.y + boundingVolume.radius;\n            const overIdl =\n              (left < idl2D && right > idl2D) ||\n              (left < -idl2D && right > -idl2D);\n            if (frameState.mode === SceneMode.SCENE2D && overIdl) {\n              commandList.push(nc.silhouetteColorCommand2D);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  const credit = this._credit;\n  if (defined(credit)) {\n    frameState.creditDisplay.addCredit(credit);\n  }\n\n  const resourceCredits = this._resourceCredits;\n  const resourceCreditsLength = resourceCredits.length;\n  for (let c = 0; c < resourceCreditsLength; c++) {\n    frameState.creditDisplay.addCredit(resourceCredits[c]);\n  }\n\n  const gltfCredits = this._gltfCredits;\n  const gltfCreditsLength = gltfCredits.length;\n  for (let c = 0; c < gltfCreditsLength; c++) {\n    frameState.creditDisplay.addCredit(gltfCredits[c]);\n  }\n};\n\nfunction destroyIfNotCached(rendererResources, cachedRendererResources) {\n  if (rendererResources.programs !== cachedRendererResources.programs) {\n    destroy(rendererResources.programs);\n  }\n  if (\n    rendererResources.silhouettePrograms !==\n    cachedRendererResources.silhouettePrograms\n  ) {\n    destroy(rendererResources.silhouettePrograms);\n  }\n}\n\n// Run from update iff:\n// - everything is loaded\n// - clipping planes state change OR color state set\n// Run this from destructor after removing color state and clipping plane state\nfunction regenerateShaders(model, frameState) {\n  // In regards to _cachedRendererResources:\n  // Fair to assume that this is data that should just never get modified due to clipping planes, model color, or splitting.\n  // So if clipping planes, model color, or splitting are active:\n  // - delink _rendererResources.*programs and create new dictionaries.\n  // - do NOT destroy any programs - might be used by copies of the model or by might be needed in the future if clipping planes/model color is deactivated\n\n  // If clipping planes, model color, and splitting inactive:\n  // - destroy _rendererResources.*programs\n  // - relink _rendererResources.*programs to _cachedRendererResources\n\n  // In both cases, need to mark commands as dirty, re-run derived commands (elsewhere)\n\n  const rendererResources = model._rendererResources;\n  const cachedRendererResources = model._cachedRendererResources;\n  destroyIfNotCached(rendererResources, cachedRendererResources);\n\n  let programId;\n  if (\n    isClippingEnabled(model) ||\n    isColorShadingEnabled(model) ||\n    model.splitDirection !== SplitDirection.NONE ||\n    model._shouldRegenerateShaders\n  ) {\n    model._shouldRegenerateShaders = false;\n\n    rendererResources.programs = {};\n    rendererResources.silhouettePrograms = {};\n\n    const visitedPrograms = {};\n    const techniques = model._sourceTechniques;\n    let technique;\n\n    for (const techniqueId in techniques) {\n      if (techniques.hasOwnProperty(techniqueId)) {\n        technique = techniques[techniqueId];\n        programId = technique.program;\n        if (!visitedPrograms[programId]) {\n          visitedPrograms[programId] = true;\n          recreateProgram(\n            {\n              programId: programId,\n              techniqueId: techniqueId,\n            },\n            model,\n            frameState.context\n          );\n        }\n      }\n    }\n  } else {\n    rendererResources.programs = cachedRendererResources.programs;\n    rendererResources.silhouettePrograms =\n      cachedRendererResources.silhouettePrograms;\n  }\n\n  // Fix all the commands, marking them as dirty so everything that derives will re-derive\n  const rendererPrograms = rendererResources.programs;\n\n  const nodeCommands = model._nodeCommands;\n  const commandCount = nodeCommands.length;\n  for (let i = 0; i < commandCount; ++i) {\n    const nodeCommand = nodeCommands[i];\n    programId = nodeCommand.programId;\n\n    const renderProgram = rendererPrograms[programId];\n    nodeCommand.command.shaderProgram = renderProgram;\n    if (defined(nodeCommand.command2D)) {\n      nodeCommand.command2D.shaderProgram = renderProgram;\n    }\n  }\n\n  // Force update silhouette commands/shaders\n  updateColor(model, frameState, true);\n  updateBackFaceCulling(model, frameState, true);\n  updateSilhouette(model, frameState, true);\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Model#destroy\n */\nModel.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * model = model && model.destroy();\n *\n * @see Model#isDestroyed\n */\nModel.prototype.destroy = function () {\n  // Vertex arrays are unique to this model, destroy here.\n  if (defined(this._precreatedAttributes)) {\n    destroy(this._rendererResources.vertexArrays);\n  }\n\n  if (defined(this._removeUpdateHeightCallback)) {\n    this._removeUpdateHeightCallback();\n    this._removeUpdateHeightCallback = undefined;\n  }\n\n  if (defined(this._terrainProviderChangedCallback)) {\n    this._terrainProviderChangedCallback();\n    this._terrainProviderChangedCallback = undefined;\n  }\n\n  // Shaders modified for clipping and for color don't get cached, so destroy these manually\n  if (defined(this._cachedRendererResources)) {\n    destroyIfNotCached(this._rendererResources, this._cachedRendererResources);\n  }\n\n  this._rendererResources = undefined;\n  this._cachedRendererResources =\n    this._cachedRendererResources && this._cachedRendererResources.release();\n  DracoLoader.destroyCachedDataForModel(this);\n\n  const pickIds = this._pickIds;\n  const length = pickIds.length;\n  for (let i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  releaseCachedGltf(this);\n  this._quantizedVertexShaders = undefined;\n\n  // Only destroy the ClippingPlaneCollection if this is the owner - if this model is part of a Cesium3DTileset,\n  // _clippingPlanes references a ClippingPlaneCollection that this model does not own.\n  const clippingPlaneCollection = this._clippingPlanes;\n  if (\n    defined(clippingPlaneCollection) &&\n    !clippingPlaneCollection.isDestroyed() &&\n    clippingPlaneCollection.owner === this\n  ) {\n    clippingPlaneCollection.destroy();\n  }\n  this._clippingPlanes = undefined;\n\n  if (\n    this._shouldDestroyImageBasedLighting &&\n    !this._imageBasedLighting.isDestroyed()\n  ) {\n    this._imageBasedLighting.destroy();\n  }\n\n  this._imageBasedLighting = undefined;\n\n  return destroyObject(this);\n};\n\n// exposed for testing\nModel._getClippingFunction = getClippingFunction;\nModel._modifyShaderForColor = modifyShaderForColor;\nexport default Model;\n","import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../../Core/OrthographicFrustum.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport PointCloudAttenuationStageVS from \"../../Shaders/ModelExperimental/PointCloudAttenuationStageVS.js\";\nimport Cesium3DTileRefine from \"../Cesium3DTileRefine.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelExperimentalType from \"./ModelExperimentalType.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\n\n/**\n * Stage to handle point cloud attenuation. This stage assumes that either\n * tileset.pointCloudShading.attenuation (3D Tiles) or\n * model.pointCloudShading.attenuation (individual model) is true\n *\n * @namespace PointCloudAttenuationPipelineStage\n *\n * @private\n */\nconst PointCloudAttenuationPipelineStage = {};\nPointCloudAttenuationPipelineStage.name = \"PointCloudAttenuationPipelineStage\"; // Helps with debugging\n\nconst scratchAttenuationUniform = new Cartesian3();\n\n/**\n * This stage does the following:\n * <ul>\n *  <li>Add vertex shader code to compute attenuation and update gl_PointSize</li>\n *  <li>Updates the uniform map to pass in the point cloud attenuation parameters</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive\n * @param {ModelComponents.primitive} primitive The primitive\n * @param {FrameState} frameState The frame state\n *\n * @private\n */\nPointCloudAttenuationPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addVertexLines([PointCloudAttenuationStageVS]);\n  shaderBuilder.addDefine(\n    \"USE_POINT_CLOUD_ATTENUATION\",\n    undefined,\n    ShaderDestination.VERTEX\n  );\n\n  const model = renderResources.model;\n  const pointCloudShading = model.pointCloudShading;\n\n  let content;\n  let is3DTiles;\n  let usesAddRefinement;\n  if (ModelExperimentalType.is3DTiles(model.type)) {\n    is3DTiles = true;\n    content = model.content;\n    usesAddRefinement = content.tile.refine === Cesium3DTileRefine.ADD;\n  }\n\n  shaderBuilder.addUniform(\n    \"vec3\",\n    \"model_pointCloudAttenuation\",\n    ShaderDestination.VERTEX\n  );\n  renderResources.uniformMap.model_pointCloudAttenuation = function () {\n    const scratch = scratchAttenuationUniform;\n\n    // attenuation.x = pointSize\n    let defaultPointSize = 1.0;\n    if (is3DTiles) {\n      defaultPointSize = usesAddRefinement\n        ? 5.0\n        : content.tileset.maximumScreenSpaceError;\n    }\n    scratch.x = defaultValue(\n      pointCloudShading.maximumAttenuation,\n      defaultPointSize\n    );\n    scratch.x *= frameState.pixelRatio;\n\n    // attenuation.y = geometricError\n    const geometricError = getGeometricError(\n      renderResources,\n      primitive,\n      pointCloudShading,\n      content\n    );\n    scratch.y = geometricError * pointCloudShading.geometricErrorScale;\n\n    const context = frameState.context;\n    const frustum = frameState.camera.frustum;\n    let depthMultiplier;\n\n    // Attenuation is maximumAttenuation in 2D/ortho\n    if (\n      frameState.mode === SceneMode.SCENE2D ||\n      frustum instanceof OrthographicFrustum\n    ) {\n      depthMultiplier = Number.POSITIVE_INFINITY;\n    } else {\n      depthMultiplier =\n        context.drawingBufferHeight / frameState.camera.frustum.sseDenominator;\n    }\n\n    // attenuation.z = depth multiplier\n    scratch.z = depthMultiplier;\n\n    return scratch;\n  };\n};\n\nconst scratchDimensions = new Cartesian3();\nfunction getGeometricError(\n  renderResources,\n  primitive,\n  pointCloudShading,\n  content\n) {\n  if (defined(content)) {\n    const geometricError = content.tile.geometricError;\n\n    if (geometricError > 0) {\n      return geometricError;\n    }\n  }\n\n  if (defined(pointCloudShading.baseResolution)) {\n    return pointCloudShading.baseResolution;\n  }\n\n  const positionAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION\n  );\n  const pointsLength = positionAttribute.count;\n\n  // Estimate the geometric error\n  const nodeTransform = renderResources.runtimeNode.transform;\n  let dimensions = Cartesian3.subtract(\n    positionAttribute.max,\n    positionAttribute.min,\n    scratchDimensions\n  );\n  // dimensions is a vector, as it is a subtraction between two points\n  dimensions = Matrix4.multiplyByPointAsVector(\n    nodeTransform,\n    dimensions,\n    scratchDimensions\n  );\n  const volume = dimensions.x * dimensions.y * dimensions.z;\n  const geometricErrorEstimate = CesiumMath.cbrt(volume / pointsLength);\n  return geometricErrorEstimate;\n}\n\nexport default PointCloudAttenuationPipelineStage;\n","import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport BlendingState from \"../BlendingState.js\";\nimport DepthFunction from \"../DepthFunction.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport ModelLightingOptions from \"./ModelLightingOptions.js\";\n\n/**\n * Each node may have many mesh primitives. Most model pipeline stages operate\n * at the primitive level. Again, properties are inherited from the parent.\n *\n * @param {NodeRenderResources} nodeRenderResources The node resources to inherit from\n * @param {ModelExperimentalPrimitive} runtimePrimitive The primitive.\n *\n * @private\n */\nexport default function PrimitiveRenderResources(\n  nodeRenderResources,\n  runtimePrimitive\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"nodeRenderResources\", nodeRenderResources);\n  Check.typeOf.object(\"runtimePrimitive\", runtimePrimitive);\n  //>>includeEnd('debug');\n\n  // Properties inherited from NodeRenderResources.\n  /**\n   * A reference to the model. Inherited from the node render resources.\n   *\n   * @type {ModelExperimental}\n   * @readonly\n   *\n   * @private\n   */\n  this.model = nodeRenderResources.model;\n  /**\n   * A reference to the runtime node. Inherited from the node render resources.\n   *\n   * @type {ModelExperimentalNode}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimeNode = nodeRenderResources.runtimeNode;\n  /**\n   * The vertex attributes. This is shallow cloned from the node render\n   * resources as the primitive will add additional properties.\n   *\n   * @type {Object[]}\n   *\n   * @private\n   */\n  this.attributes = nodeRenderResources.attributes.slice();\n\n  /**\n   * The index to give to the next vertex attribute added to the attributes array. POSITION\n   * takes index 0. Inherited from the node render resources.\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  this.attributeIndex = nodeRenderResources.attributeIndex;\n\n  /**\n   * The set index to assign to feature ID vertex attribute(s) created from the offset/repeat in the feature ID attribute.\n   * Inherited from the node render resources.\n   *\n   * @type {Number}\n   *\n   * @private\n   */\n  this.featureIdVertexAttributeSetIndex =\n    nodeRenderResources.featureIdVertexAttributeSetIndex;\n\n  /**\n   * Whether or not this primitive has a property table for storing metadata.\n   * When present, picking and styling can use this\n   *\n   * @type {Boolean}\n   * @default false\n   * @readonly\n   *\n   * @private\n   */\n  this.hasPropertyTable = false;\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values. Inherited from the node render resources.\n   *\n   * @type {Object.<String, Function>}\n   * @readonly\n   *\n   * @private\n   */\n  this.uniformMap = clone(nodeRenderResources.uniformMap);\n\n  /**\n   * Options for configuring the alpha stage such as pass and alpha mode. Inherited from the node\n   * render resources.\n   *\n   * @type {ModelAlphaOptions}\n   * @readonly\n   *\n   * @private\n   */\n  this.alphaOptions = clone(nodeRenderResources.alphaOptions);\n\n  /**\n   * An object used to build a shader incrementally. This is cloned from the\n   * node render resources because each primitive can compute a different shader.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = nodeRenderResources.shaderBuilder.clone();\n\n  /**\n   * The number of instances. Default is 0, if instancing is not used. Inherited from the node render resources.\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  this.instanceCount = nodeRenderResources.instanceCount;\n\n  /**\n   * A reference to the runtime primitive\n   *\n   * @type {ModelExperimentalPrimitive}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimePrimitive = runtimePrimitive;\n\n  /**\n   * The primitive associated with the render resources.\n   *\n   * @type {ModelComponents.Primitive}\n   * @readonly\n   *\n   * @private\n   */\n  const primitive = runtimePrimitive.primitive;\n\n  // other properties\n  /**\n   * The number of indices in the primitive. The interpretation of this\n   * depends on the primitive type.\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  this.count = defined(primitive.indices)\n    ? primitive.indices.count\n    : ModelExperimentalUtility.getAttributeBySemantic(primitive, \"POSITION\")\n        .count;\n\n  /**\n   * The indices for this primitive\n   *\n   * @type {ModelComponents.Indices}\n   * @readonly\n   *\n   * @private\n   */\n  this.indices = primitive.indices;\n\n  /**\n   * Additional index buffer for wireframe mode (if enabled)\n   *\n   * @type {Buffer}\n   * @readonly\n   *\n   * @private\n   */\n  this.wireframeIndexBuffer = undefined;\n\n  /**\n   * The primitive type such as TRIANGLES or POINTS\n   *\n   * @type {PrimitiveType}\n   * @readonly\n   *\n   * @private\n   */\n  this.primitiveType = primitive.primitiveType;\n\n  const positionMinMax = ModelExperimentalUtility.getPositionMinMax(\n    primitive,\n    nodeRenderResources.instancingTranslationMin,\n    nodeRenderResources.instancingTranslationMax\n  );\n\n  /**\n   * The minimum position value for this primitive.\n   *\n   * @type {Cartesian3}\n   * @readonly\n   *\n   * @private\n   */\n  this.positionMin = Cartesian3.clone(positionMinMax.min, new Cartesian3());\n\n  /**\n   * The maximum position value for this primitive.\n   *\n   * @type {Cartesian3}\n   * @readonly\n   *\n   * @private\n   */\n  this.positionMax = Cartesian3.clone(positionMinMax.max, new Cartesian3());\n\n  /**\n   * The bounding sphere that contains all the vertices in this primitive.\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @private\n   */\n  this.boundingSphere = BoundingSphere.fromCornerPoints(\n    this.positionMin,\n    this.positionMax,\n    new BoundingSphere()\n  );\n\n  /**\n   * Options for configuring the lighting stage such as selecting between\n   * unlit and PBR shading.\n   *\n   * @type {ModelLightingOptions}\n   * @readonly\n   *\n   * @private\n   */\n  this.lightingOptions = new ModelLightingOptions();\n\n  /**\n   * The shader variable to use for picking.\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @private\n   */\n  this.pickId = undefined;\n\n  /**\n   * An object storing options for creating a {@link RenderState}.\n   * the pipeline stages simply set the options, the render state is created\n   * when the {@link DrawCommand} is constructed.\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @private\n   */\n  this.renderStateOptions = combine(nodeRenderResources.renderStateOptions, {\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    blending: BlendingState.DISABLED,\n  });\n\n  /**\n   * An enum describing the types of draw commands needed, based on the style.\n   *\n   * @type {StyleCommandsNeeded}\n   * @readonly\n   *\n   * @private\n   */\n  this.styleCommandsNeeded = undefined;\n}\n","import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport clone from \"../../Core/clone.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport SceneTransforms from \"../SceneTransforms.js\";\n\nconst scratchModelMatrix = new Matrix4();\n\n/**\n * The scene mode 2D stage generates resources for rendering a primitive in 2D / CV mode.\n *\n * @namespace SceneMode2DPipelineStage\n *\n * @private\n */\nconst SceneMode2DPipelineStage = {};\nSceneMode2DPipelineStage.name = \"SceneMode2DPipelineStage\"; // Helps with debugging\n\n/**\n * This pipeline stage processes the position attribute of a primitive and adds the relevant\n * define and uniform matrix to the shader. It also generates new resources for the primitive\n * in 2D. These resources persist in the runtime primitive so that the typed array used to\n * store the positional data can be freed.\n *\n * This stage must go before the GeometryPipelineStage in the primitive pipeline.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> creates a vertex buffer for the positions of the primitive projected to 2D\n *  <li> creates the bounding sphere for the primitive in 2D\n *  <li> adds a flag to the shader to use 2D positions\n *  <li> adds a uniform for the view model matrix in 2D\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\n\nSceneMode2DPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const runtimePrimitive = renderResources.runtimePrimitive;\n\n  const model = renderResources.model;\n  const modelMatrix = model.sceneGraph.computedModelMatrix;\n  const nodeComputedTransform = renderResources.runtimeNode.computedTransform;\n  const computedModelMatrix = Matrix4.multiplyTransformation(\n    modelMatrix,\n    nodeComputedTransform,\n    scratchModelMatrix\n  );\n\n  const boundingSphere2D = computeBoundingSphere2D(\n    renderResources,\n    computedModelMatrix,\n    frameState\n  );\n\n  runtimePrimitive.boundingSphere2D = boundingSphere2D;\n\n  const positionAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION\n  );\n\n  // If the typed array of the position attribute exists, then\n  // the positions haven't been projected to 2D yet.\n  if (defined(positionAttribute.typedArray)) {\n    const buffer2D = createPositionBufferFor2D(\n      positionAttribute,\n      computedModelMatrix,\n      boundingSphere2D,\n      frameState\n    );\n\n    runtimePrimitive.positionBuffer2D = buffer2D;\n    model._modelResources.push(buffer2D);\n\n    // Unload the typed array. This is just a pointer to the array in\n    // the vertex buffer loader, so if the typed array is shared by\n    // multiple primitives (i.e. multiple instances of the same mesh),\n    // this will not affect the other primitives.\n    positionAttribute.typedArray = undefined;\n  }\n\n  shaderBuilder.addDefine(\n    \"USE_2D_POSITIONS\",\n    undefined,\n    ShaderDestination.VERTEX\n  );\n\n  shaderBuilder.addUniform(\"mat4\", \"u_modelView2D\", ShaderDestination.VERTEX);\n\n  const modelMatrix2D = Matrix4.fromTranslation(\n    boundingSphere2D.center,\n    new Matrix4()\n  );\n  const modelView = new Matrix4();\n\n  const context = frameState.context;\n  const uniformMap = {\n    u_modelView2D: function () {\n      return Matrix4.multiplyTransformation(\n        context.uniformState.view,\n        modelMatrix2D,\n        modelView\n      );\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nconst scratchProjectedMin = new Cartesian3();\nconst scratchProjectedMax = new Cartesian3();\n\nfunction computeBoundingSphere2D(renderResources, modelMatrix, frameState) {\n  // Compute the bounding sphere in 2D.\n  const transformedPositionMin = Matrix4.multiplyByPoint(\n    modelMatrix,\n    renderResources.positionMin,\n    scratchProjectedMin\n  );\n\n  const projectedMin = SceneTransforms.computeActualWgs84Position(\n    frameState,\n    transformedPositionMin,\n    transformedPositionMin\n  );\n\n  const transformedPositionMax = Matrix4.multiplyByPoint(\n    modelMatrix,\n    renderResources.positionMax,\n    scratchProjectedMax\n  );\n\n  const projectedMax = SceneTransforms.computeActualWgs84Position(\n    frameState,\n    transformedPositionMax,\n    transformedPositionMax\n  );\n\n  return BoundingSphere.fromCornerPoints(\n    projectedMin,\n    projectedMax,\n    new BoundingSphere()\n  );\n}\n\nconst scratchPosition = new Cartesian3();\n\nfunction dequantizePositionsTypedArray(typedArray, quantization) {\n  // Draco compression is normally handled in the dequantization stage\n  // in the shader, but it must be decoded here in order to project\n  // the positions to 2D / CV.\n  const length = typedArray.length;\n  const dequantizedArray = new Float32Array(length);\n  const quantizedVolumeOffset = quantization.quantizedVolumeOffset;\n  const quantizedVolumeStepSize = quantization.quantizedVolumeStepSize;\n  for (let i = 0; i < length; i += 3) {\n    const initialPosition = Cartesian3.fromArray(\n      typedArray,\n      i,\n      scratchPosition\n    );\n    const scaledPosition = Cartesian3.multiplyComponents(\n      initialPosition,\n      quantizedVolumeStepSize,\n      initialPosition\n    );\n    const dequantizedPosition = Cartesian3.add(\n      scaledPosition,\n      quantizedVolumeOffset,\n      scaledPosition\n    );\n\n    dequantizedArray[i] = dequantizedPosition.x;\n    dequantizedArray[i + 1] = dequantizedPosition.y;\n    dequantizedArray[i + 2] = dequantizedPosition.z;\n  }\n\n  return dequantizedArray;\n}\n\nfunction createPositionsTypedArrayFor2D(\n  attribute,\n  modelMatrix,\n  referencePoint,\n  frameState\n) {\n  const typedArray = attribute.typedArray.slice();\n  let result;\n  if (defined(attribute.quantization)) {\n    // Dequantize the positions if necessary.\n    result = dequantizePositionsTypedArray(\n      attribute.typedArray,\n      attribute.quantization\n    );\n  } else {\n    result = new Float32Array(\n      typedArray.buffer,\n      typedArray.byteOffset,\n      typedArray.byteLength / Float32Array.BYTES_PER_ELEMENT\n    );\n  }\n\n  const startIndex = attribute.byteOffset / Float32Array.BYTES_PER_ELEMENT;\n  const length = result.length;\n  const stride = defined(attribute.byteStride)\n    ? attribute.byteStride / Float32Array.BYTES_PER_ELEMENT\n    : 3;\n\n  for (let i = startIndex; i < length; i += stride) {\n    const initialPosition = Cartesian3.fromArray(result, i, scratchPosition);\n    if (\n      isNaN(initialPosition.x) ||\n      isNaN(initialPosition.y) ||\n      isNaN(initialPosition.z)\n    ) {\n      continue;\n    }\n\n    const transformedPosition = Matrix4.multiplyByPoint(\n      modelMatrix,\n      initialPosition,\n      initialPosition\n    );\n\n    const projectedPosition = SceneTransforms.computeActualWgs84Position(\n      frameState,\n      transformedPosition,\n      transformedPosition\n    );\n\n    const relativePosition = Cartesian3.subtract(\n      projectedPosition,\n      referencePoint,\n      projectedPosition\n    );\n\n    result[i] = relativePosition.x;\n    result[i + 1] = relativePosition.y;\n    result[i + 2] = relativePosition.z;\n  }\n\n  return result;\n}\n\nfunction createPositionBufferFor2D(\n  positionAttribute,\n  modelMatrix,\n  boundingSphere2D,\n  frameState\n) {\n  // Force the scene mode to be CV. In 2D, projected positions will have\n  // an x-coordinate of 0, which eliminates the height data that is\n  // necessary for rendering in CV mode.\n  const frameStateCV = clone(frameState);\n  frameStateCV.mode = SceneMode.COLUMBUS_VIEW;\n\n  // To prevent jitter, the positions are defined relative to a common\n  // reference point. For convenience, this is the center of the\n  // primitive's bounding sphere in 2D.\n  const referencePoint = boundingSphere2D.center;\n  const projectedPositions = createPositionsTypedArrayFor2D(\n    positionAttribute,\n    modelMatrix,\n    referencePoint,\n    frameStateCV\n  );\n\n  // Put the resulting data in a GPU buffer.\n  const buffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: projectedPositions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  buffer.vertexArrayDestroyable = false;\n\n  return buffer;\n}\n\nexport default SceneMode2DPipelineStage;\n","import defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SelectedFeatureIdStageCommon from \"../../Shaders/ModelExperimental/SelectedFeatureIdStageCommon.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\n\n/**\n * The selected feature ID pipeline stage is responsible for handling the\n * set of feature IDs selected for styling/picking.\n *\n * @namespace SelectedFeatureIdPipelineStage\n * @private\n */\nconst SelectedFeatureIdPipelineStage = {};\nSelectedFeatureIdPipelineStage.name = \"SelectedFeatureIdPipelineStage\"; // Helps with debugging\n\nSelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE = \"SelectedFeature\";\nSelectedFeatureIdPipelineStage.STRUCT_NAME_SELECTED_FEATURE = \"SelectedFeature\";\nSelectedFeatureIdPipelineStage.FUNCTION_ID_FEATURE_VARYINGS_VS =\n  \"updateFeatureStructVS\";\nSelectedFeatureIdPipelineStage.FUNCTION_ID_FEATURE_VARYINGS_FS =\n  \"updateFeatureStructFS\";\nSelectedFeatureIdPipelineStage.FUNCTION_SIGNATURE_UPDATE_FEATURE =\n  \"void updateFeatureStruct(inout SelectedFeature feature)\";\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>sets the defines for the feature ID attribute to use for styling/picking</li>\n *  <li>adds fields to the SelectedFeature struct in the shader</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nSelectedFeatureIdPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  renderResources.hasPropertyTable = true;\n\n  const model = renderResources.model;\n  const node = renderResources.runtimeNode.node;\n  const selectedFeatureIds = getSelectedFeatureIds(model, node, primitive);\n  const shaderDestination = selectedFeatureIds.shaderDestination;\n\n  shaderBuilder.addDefine(\n    \"HAS_SELECTED_FEATURE_ID\",\n    undefined,\n    shaderDestination\n  );\n\n  // Add a define to insert the variable to use.\n  // Example: #define SELECTED_FEATURE_ID featureId_1\n  // This corresponds to featureIds.featureId_1\n  shaderBuilder.addDefine(\n    \"SELECTED_FEATURE_ID\",\n    selectedFeatureIds.variableName,\n    shaderDestination\n  );\n\n  // Add a define to the shader to distinguish feature ID attributes from\n  // textures. This is needed for determining where to filter features\n  // by pass type.\n  shaderBuilder.addDefine(\n    selectedFeatureIds.featureIdDefine,\n    undefined,\n    shaderDestination\n  );\n\n  updateFeatureStruct(shaderBuilder);\n\n  const nullFeatureId = selectedFeatureIds.featureIds.nullFeatureId;\n  const uniformMap = renderResources.uniformMap;\n  if (defined(nullFeatureId)) {\n    shaderBuilder.addDefine(\n      \"HAS_NULL_FEATURE_ID\",\n      undefined,\n      shaderDestination\n    );\n    shaderBuilder.addUniform(\"int\", \"model_nullFeatureId\", shaderDestination);\n    uniformMap.model_nullFeatureId = function () {\n      return nullFeatureId;\n    };\n  }\n\n  if (selectedFeatureIds.shaderDestination === ShaderDestination.BOTH) {\n    shaderBuilder.addVertexLines([SelectedFeatureIdStageCommon]);\n  }\n  shaderBuilder.addFragmentLines([SelectedFeatureIdStageCommon]);\n};\n\nfunction getFeatureIdDefine(featureIds) {\n  if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n    return \"HAS_SELECTED_FEATURE_ID_TEXTURE\";\n  }\n\n  return \"HAS_SELECTED_FEATURE_ID_ATTRIBUTE\";\n}\n\nfunction getShaderDestination(featureIds) {\n  // Feature ID textures are only supported in the fragment shader.\n  if (featureIds instanceof ModelComponents.FeatureIdTexture) {\n    return ShaderDestination.FRAGMENT;\n  }\n\n  return ShaderDestination.BOTH;\n}\n\nfunction getSelectedFeatureIds(model, node, primitive) {\n  let variableName;\n  let featureIds;\n  // Check instances first, as this is the most specific type of\n  // feature ID\n  if (defined(node.instances)) {\n    featureIds = ModelExperimentalUtility.getFeatureIdsByLabel(\n      node.instances.featureIds,\n      model.instanceFeatureIdLabel\n    );\n\n    if (defined(featureIds)) {\n      // Either label could be used here, but prefer label as it may be more\n      // meaningful when debugging\n      variableName = defaultValue(featureIds.label, featureIds.positionalLabel);\n      return {\n        featureIds: featureIds,\n        variableName: variableName,\n        shaderDestination: getShaderDestination(featureIds),\n        featureIdDefine: getFeatureIdDefine(featureIds),\n      };\n    }\n  }\n\n  featureIds = ModelExperimentalUtility.getFeatureIdsByLabel(\n    primitive.featureIds,\n    model.featureIdLabel\n  );\n  // again, prefer label for being more descriptive\n  variableName = defaultValue(featureIds.label, featureIds.positionalLabel);\n  return {\n    featureIds: featureIds,\n    variableName: variableName,\n    shaderDestination: getShaderDestination(featureIds),\n    featureIdDefine: getFeatureIdDefine(featureIds),\n  };\n}\n\n/**\n * Populate the \"SelectedFeature\" struct in the shaders that holds information about the \"active\" (used for picking/styling) feature.\n * The struct is always added to the shader by the GeometryPipelineStage (required for compilation). The SelectedFeature struct looks\n * as follows:\n *\n * struct SelectedFeature {\n *   int id;\n *   vec2 st;\n *   vec4 color;\n * }\n *\n * @private\n */\nfunction updateFeatureStruct(shaderBuilder) {\n  shaderBuilder.addStructField(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    \"int\",\n    \"id\"\n  );\n\n  shaderBuilder.addStructField(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    \"vec2\",\n    \"st\"\n  );\n\n  shaderBuilder.addStructField(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    \"vec4\",\n    \"color\"\n  );\n}\n\nexport default SelectedFeatureIdPipelineStage;\n","import combine from \"../../Core/combine.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport SkinningStageVS from \"../../Shaders/ModelExperimental/SkinningStageVS.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The skinning pipeline stage processes the joint matrices of a skinned primitive.\n *\n * @namespace SkinningPipelineStage\n *\n * @private\n */\n\nconst SkinningPipelineStage = {};\nSkinningPipelineStage.name = \"SkinningPipelineStage\"; // Helps with debugging\n\nSkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX = \"getSkinningMatrix\";\nSkinningPipelineStage.FUNCTION_SIGNATURE_GET_SKINNING_MATRIX =\n  \"mat4 getSkinningMatrix()\";\n\n/**\n * This pipeline stage processes the joint matrices of a skinned primitive, adding\n * the relevant functions and uniforms to the shaders. The joint and weight attributes\n * themselves are processed in the geometry pipeline stage.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds the uniform declaration for the joint matrices in the vertex shader</li>\n *  <li> adds the function to compute the skinning matrix in the vertex shader</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @private\n */\nSkinningPipelineStage.process = function (renderResources, primitive) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\"HAS_SKINNING\", undefined, ShaderDestination.VERTEX);\n  addGetSkinningMatrixFunction(shaderBuilder, primitive);\n\n  const runtimeNode = renderResources.runtimeNode;\n  const jointMatrices = runtimeNode.computedJointMatrices;\n\n  shaderBuilder.addUniform(\n    \"mat4\",\n    `u_jointMatrices[${jointMatrices.length}]`,\n    ShaderDestination.VERTEX\n  );\n\n  shaderBuilder.addVertexLines([SkinningStageVS]);\n\n  const uniformMap = {\n    u_jointMatrices: function () {\n      return runtimeNode.computedJointMatrices;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nfunction getMaximumAttributeSetIndex(primitive) {\n  let setIndex = -1;\n  const attributes = primitive.attributes;\n  const length = attributes.length;\n  for (let i = 0; i < length; i++) {\n    const attribute = attributes[i];\n    const isJointsOrWeights =\n      attribute.semantic === VertexAttributeSemantic.JOINTS ||\n      attribute.semantic === VertexAttributeSemantic.WEIGHTS;\n\n    if (!isJointsOrWeights) {\n      continue;\n    }\n\n    setIndex = Math.max(setIndex, attribute.setIndex);\n  }\n\n  return setIndex;\n}\n\nfunction addGetSkinningMatrixFunction(shaderBuilder, primitive) {\n  shaderBuilder.addFunction(\n    SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n    SkinningPipelineStage.FUNCTION_SIGNATURE_GET_SKINNING_MATRIX,\n    ShaderDestination.VERTEX\n  );\n\n  const initialLine = \"mat4 skinnedMatrix = mat4(0);\";\n  shaderBuilder.addFunctionLines(\n    SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n    [initialLine]\n  );\n\n  let setIndex;\n  let componentIndex;\n  const componentStrings = [\"x\", \"y\", \"z\", \"w\"];\n  const maximumSetIndex = getMaximumAttributeSetIndex(primitive);\n  for (setIndex = 0; setIndex <= maximumSetIndex; setIndex++) {\n    for (componentIndex = 0; componentIndex <= 3; componentIndex++) {\n      const component = componentStrings[componentIndex];\n      // Example: skinnedMatrix += a_weights_0.x * u_jointMatrices[int(a_joints_0.x)];\n      const line = `skinnedMatrix += a_weights_${setIndex}.${component} * u_jointMatrices[int(a_joints_${setIndex}.${component})];`;\n      shaderBuilder.addFunctionLines(\n        SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n        [line]\n      );\n    }\n  }\n\n  const returnLine = \"return skinnedMatrix;\";\n  shaderBuilder.addFunctionLines(\n    SkinningPipelineStage.FUNCTION_ID_GET_SKINNING_MATRIX,\n    [returnLine]\n  );\n}\n\nexport default SkinningPipelineStage;\n","/**\n * An enum describing what commands (opaque) are required by a Cesium3DTileStyle.\n *\n * @private\n */\nconst StyleCommandsNeeded = {\n  ALL_OPAQUE: 0,\n  ALL_TRANSLUCENT: 1,\n  OPAQUE_AND_TRANSLUCENT: 2,\n};\n\n/**\n * @private\n */\nStyleCommandsNeeded.getStyleCommandsNeeded = function (\n  featuresLength,\n  translucentFeaturesLength\n) {\n  if (translucentFeaturesLength === 0) {\n    return StyleCommandsNeeded.ALL_OPAQUE;\n  } else if (translucentFeaturesLength === featuresLength) {\n    return StyleCommandsNeeded.ALL_TRANSLUCENT;\n  }\n  return StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT;\n};\n\nexport default Object.freeze(StyleCommandsNeeded);\n","import defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport Texture from \"../../Renderer/Texture.js\";\n\n/**\n * An object to manage loading textures\n *\n * @alias TextureManager\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function TextureManager() {\n  this._defaultTexture = undefined;\n  this._textures = {};\n  this._loadedImages = [];\n\n  // Keep track of the last time update() was called to avoid\n  // calling update() twice.\n  this._lastUpdatedFrame = -1;\n}\n\n/**\n * Get one of the loaded textures\n * @param {String} textureId The unique ID of the texture loaded by {@link TextureManager#loadTexture2D}\n * @return {Texture} The texture or <code>undefined</code> if no texture exists\n */\nTextureManager.prototype.getTexture = function (textureId) {\n  return this._textures[textureId];\n};\n\nfunction fetchTexture2D(textureManager, textureId, textureUniform) {\n  textureUniform.resource\n    .fetchImage()\n    .then(function (image) {\n      textureManager._loadedImages.push({\n        id: textureId,\n        image: image,\n        textureUniform: textureUniform,\n      });\n    })\n    .catch(function () {\n      const texture = textureManager._textures[textureId];\n      if (defined(texture) && texture !== textureManager._defaultTexture) {\n        texture.destroy();\n      }\n\n      textureManager._textures[textureId] = textureManager._defaultTexture;\n    });\n}\n\n/**\n * Load a texture 2D asynchronously. Note that {@link TextureManager#update}\n * must be called in the render loop to finish processing the textures.\n *\n * @param {String} textureId A unique ID to identify this texture.\n * @param {TextureUniform} textureUniform A description of the texture\n *\n * @private\n */\nTextureManager.prototype.loadTexture2D = function (textureId, textureUniform) {\n  if (defined(textureUniform.typedArray)) {\n    this._loadedImages.push({\n      id: textureId,\n      textureUniform: textureUniform,\n    });\n  } else {\n    fetchTexture2D(this, textureId, textureUniform);\n  }\n};\n\nfunction createTexture(textureManager, loadedImage, context) {\n  const id = loadedImage.id;\n  const textureUniform = loadedImage.textureUniform;\n\n  const typedArray = textureUniform.typedArray;\n  const sampler = textureUniform.sampler;\n\n  let texture;\n  if (defined(typedArray)) {\n    texture = new Texture({\n      context: context,\n      pixelFormat: textureUniform.pixelFormat,\n      pixelDatatype: textureUniform.pixelDatatype,\n      source: {\n        arrayBufferView: typedArray,\n        width: textureUniform.width,\n        height: textureUniform.height,\n      },\n      sampler: sampler,\n      flipY: false,\n    });\n  } else {\n    texture = new Texture({\n      context: context,\n      source: loadedImage.image,\n      sampler: sampler,\n    });\n  }\n\n  // Destroy the old texture once the new one is loaded for more seamless\n  // transitions between values\n  const oldTexture = textureManager._textures[id];\n  if (defined(oldTexture) && oldTexture !== context.defaultTexture) {\n    oldTexture.destroy();\n  }\n  textureManager._textures[id] = texture;\n}\n\nTextureManager.prototype.update = function (frameState) {\n  // update only needs to be called once a frame.\n  if (frameState.frameNumber === this._lastUpdatedFrame) {\n    return;\n  }\n  this._lastUpdatedFrame = frameState.frameNumber;\n\n  const context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  // If any images were loaded since the last frame, create Textures\n  // for them and store in the uniform dictionary\n  const loadedImages = this._loadedImages;\n  for (let i = 0; i < loadedImages.length; i++) {\n    const loadedImage = loadedImages[i];\n    createTexture(this, loadedImage, context);\n  }\n  loadedImages.length = 0;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureManager#destroy\n * @private\n */\nTextureManager.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * textureManager = textureManager && textureManager.destroy();\n *\n * @see TextureManager#isDestroyed\n * @private\n */\nTextureManager.prototype.destroy = function () {\n  const textures = this._textures;\n  for (const texture in textures) {\n    if (textures.hasOwnProperty(texture)) {\n      const instance = textures[texture];\n      if (instance !== this._defaultTexture) {\n        instance.destroy();\n      }\n    }\n  }\n  return destroyObject(this);\n};\n","import defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Resource from \"../../Core/Resource.js\";\nimport PixelFormat from \"../../Core/PixelFormat.js\";\nimport PixelDatatype from \"../../Renderer/PixelDatatype.js\";\nimport Sampler from \"../../Renderer/Sampler.js\";\nimport TextureWrap from \"../../Renderer/TextureWrap.js\";\n\n/**\n * A simple struct that serves as a value of a <code>sampler2D</code>-valued\n * uniform. This is used with {@link CustomShader} and {@link TextureManager}\n *\n * @param {Object} options An object with the following properties:\n * @param {Uint8Array} [options.typedArray] A typed array storing the contents of a texture. Values are stored in row-major order. Since WebGL uses a y-up convention for textures, rows are listed from bottom to top.\n * @param {Number} [options.width] The width of the image. Required when options.typedArray is present\n * @param {Number} [options.height] The height of the image. Required when options.typedArray is present.\n * @param {String|Resource} [options.url] A URL string or resource pointing to a texture image.\n * @param {Boolean} [options.repeat=true] When defined, the texture sampler will be set to wrap in both directions\n * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] When options.typedArray is defined, this is used to determine the pixel format of the texture\n * @param {PixelDatatype} [options.pixelDatatype=PixelDatatype.UNSIGNED_BYTE] When options.typedArray is defined, this is the data type of pixel values in the typed array.\n * @param {TextureMinificationFilter} [options.minificationFilter=TextureMinificationFilter.LINEAR] The minification filter of the texture sampler.\n * @param {TextureMagnificationFilter} [options.magnificationFilter=TextureMagnificationFilter.LINEAR] The magnification filter of the texture sampler.\n * @param {Number} [options.maximumAnisotropy=1.0] The maximum anisotropy of the texture sampler\n *\n * @alias TextureUniform\n * @constructor\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function TextureUniform(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  const hasTypedArray = defined(options.typedArray);\n  const hasUrl = defined(options.url);\n  if (hasTypedArray === hasUrl) {\n    throw new DeveloperError(\n      \"exactly one of options.typedArray, options.url must be defined\"\n    );\n  }\n  if (hasTypedArray && (!defined(options.width) || !defined(options.height))) {\n    throw new DeveloperError(\n      \"options.width and options.height are required when options.typedArray is defined\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this.typedArray = options.typedArray;\n  this.width = options.width;\n  this.height = options.height;\n  this.pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);\n  this.pixelDatatype = defaultValue(\n    options.pixelDatatype,\n    PixelDatatype.UNSIGNED_BYTE\n  );\n\n  let resource = options.url;\n  if (typeof resource === \"string\") {\n    resource = Resource.createIfNeeded(resource);\n  }\n  this.resource = resource;\n\n  const repeat = defaultValue(options.repeat, true);\n  const wrap = repeat ? TextureWrap.REPEAT : TextureWrap.CLAMP_TO_EDGE;\n  this.sampler = new Sampler({\n    wrapS: wrap,\n    wrapT: wrap,\n    minificationFilter: options.minificationFilter,\n    magnificationFilter: options.magnificationFilter,\n    maximumAnisotropy: options.maximumAnisotropy,\n  });\n}\n","/**\n * An enum of the basic GLSL uniform types. These can be used with\n * {@link CustomShader} to declare user-defined uniforms.\n *\n * @enum {String}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst UniformType = {\n  /**\n   * A single floating point value.\n   *\n   * @type {String}\n   * @constant\n   */\n  FLOAT: \"float\",\n  /**\n   * A vector of 2 floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC2: \"vec2\",\n  /**\n   * A vector of 3 floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC3: \"vec3\",\n  /**\n   * A vector of 4 floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC4: \"vec4\",\n  /**\n   * A single integer value\n   *\n   * @type {String}\n   * @constant\n   */\n  INT: \"int\",\n  /**\n   * A vector of 2 integer values.\n   *\n   * @type {String}\n   * @constant\n   */\n  INT_VEC2: \"ivec2\",\n  /**\n   * A vector of 3 integer values.\n   *\n   * @type {String}\n   * @constant\n   */\n  INT_VEC3: \"ivec3\",\n  /**\n   * A vector of 4 integer values.\n   *\n   * @type {String}\n   * @constant\n   */\n  INT_VEC4: \"ivec4\",\n  /**\n   * A single boolean value.\n   *\n   * @type {String}\n   * @constant\n   */\n  BOOL: \"bool\",\n  /**\n   * A vector of 2 boolean values.\n   *\n   * @type {String}\n   * @constant\n   */\n  BOOL_VEC2: \"bvec2\",\n  /**\n   * A vector of 3 boolean values.\n   *\n   * @type {String}\n   * @constant\n   */\n  BOOL_VEC3: \"bvec3\",\n  /**\n   * A vector of 4 boolean values.\n   *\n   * @type {String}\n   * @constant\n   */\n  BOOL_VEC4: \"bvec4\",\n  /**\n   * A 2x2 matrix of floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT2: \"mat2\",\n  /**\n   * A 3x3 matrix of floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT3: \"mat2\",\n  /**\n   * A 3x3 matrix of floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT4: \"mat4\",\n  /**\n   * A 2D sampled texture.\n   * @type {String}\n   * @constant\n   */\n  SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n};\n\nexport default Object.freeze(UniformType);\n","/**\n * An enum for the GLSL varying types. These can be used for declaring varyings\n * in {@link CustomShader}\n *\n * @enum {String}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst VaryingType = {\n  /**\n   * A single floating point value.\n   *\n   * @type {String}\n   * @constant\n   */\n  FLOAT: \"float\",\n  /**\n   * A vector of 2 floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC2: \"vec2\",\n  /**\n   * A vector of 3 floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC3: \"vec3\",\n  /**\n   * A vector of 4 floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC4: \"vec4\",\n  /**\n   * A 2x2 matrix of floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT2: \"mat2\",\n  /**\n   * A 3x3 matrix of floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT3: \"mat2\",\n  /**\n   * A 3x3 matrix of floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT4: \"mat4\",\n};\n\nexport default Object.freeze(VaryingType);\n","import Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport defined from \"../../Core/defined.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport WireframeIndexGenerator from \"../../Core/WireframeIndexGenerator.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\n\n/**\n * The wireframe pipeline stage generates a new index buffer for rendering the\n * structure of the mesh with gl.LINES.\n *\n * @namespace WireframePipelineStage\n * @private\n */\nconst WireframePipelineStage = {};\nWireframePipelineStage.name = \"WireframePipelineStage\"; // Helps with debugging\n\n/**\n * Process a primitive. This modifies the render resources as follows:\n * <ul>\n *   <li>Adds a separate index buffer for wireframe indices</li>\n *   <li>Updates the primitive type and count for rendering with gl.LINES</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this node\n * @param {ModelComponents.primitive} primitive The primitive\n * @param {FrameState} frameState The frame state\n */\nWireframePipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const wireframeIndexBuffer = createWireframeIndexBuffer(\n    primitive,\n    renderResources.indices,\n    frameState\n  );\n  renderResources.model._resources.push(wireframeIndexBuffer);\n  renderResources.wireframeIndexBuffer = wireframeIndexBuffer;\n\n  // Update render resources so we render LINES with the correct index count\n  const originalPrimitiveType = renderResources.primitiveType;\n  const originalCount = renderResources.count;\n  renderResources.primitiveType = PrimitiveType.LINES;\n  renderResources.count = WireframeIndexGenerator.getWireframeIndicesCount(\n    originalPrimitiveType,\n    originalCount\n  );\n};\n\nfunction createWireframeIndexBuffer(primitive, indices, frameState) {\n  const positionAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION\n  );\n  const vertexCount = positionAttribute.count;\n\n  let originalIndices;\n  if (defined(indices)) {\n    const indicesBuffer = indices.buffer;\n    const indicesCount = indices.count;\n    if (defined(indicesBuffer) && frameState.context.webgl2) {\n      const useUint8Array = indicesBuffer.sizeInBytes === indicesCount;\n      originalIndices = useUint8Array\n        ? new Uint8Array(indicesCount)\n        : IndexDatatype.createTypedArray(vertexCount, indicesCount);\n\n      indicesBuffer.getBufferData(originalIndices);\n    } else {\n      originalIndices = indices.typedArray;\n    }\n  }\n\n  const primitiveType = primitive.primitiveType;\n  const wireframeIndices = WireframeIndexGenerator.createWireframeIndices(\n    primitiveType,\n    vertexCount,\n    originalIndices\n  );\n  const indexDatatype = IndexDatatype.fromSizeInBytes(\n    wireframeIndices.BYTES_PER_ELEMENT\n  );\n\n  return Buffer.createIndexBuffer({\n    context: frameState.context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n}\n\nexport default WireframePipelineStage;\n","import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport clone from \"../../Core/clone.js\";\nimport defined from \"../../Core/defined.js\";\nimport DrawCommand from \"../../Renderer/DrawCommand.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelExperimentalDrawCommand from \"./ModelExperimentalDrawCommand.js\";\nimport ModelExperimentalFS from \"../../Shaders/ModelExperimental/ModelExperimentalFS.js\";\nimport ModelExperimentalVS from \"../../Shaders/ModelExperimental/ModelExperimentalVS.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShadowMode from \"../ShadowMode.js\";\nimport StencilConstants from \"../StencilConstants.js\";\nimport VertexArray from \"../../Renderer/VertexArray.js\";\n\n/**\n * Builds the {@link ModelExperimentalDrawCommand} for a {@link ModelExperimentalPrimitive}\n * using its render resources.\n *\n * @param {PrimitiveRenderResources} primitiveRenderResources The render resources for a primitive.\n * @param {FrameState} frameState The frame state for creating GPU resources.\n *\n * @returns {ModelExperimentalDrawCommand} The generated ModelExperimentalDrawCommand.\n *\n * @private\n */\nexport default function buildDrawCommand(primitiveRenderResources, frameState) {\n  const shaderBuilder = primitiveRenderResources.shaderBuilder;\n  shaderBuilder.addVertexLines([ModelExperimentalVS]);\n  shaderBuilder.addFragmentLines([ModelExperimentalFS]);\n\n  const model = primitiveRenderResources.model;\n  const context = frameState.context;\n\n  const indexBuffer = getIndexBuffer(primitiveRenderResources, frameState);\n\n  const vertexArray = new VertexArray({\n    context: context,\n    indexBuffer: indexBuffer,\n    attributes: primitiveRenderResources.attributes,\n  });\n\n  model._resources.push(vertexArray);\n\n  const shaderProgram = shaderBuilder.buildShaderProgram(frameState.context);\n  model._resources.push(shaderProgram);\n\n  const pass = primitiveRenderResources.alphaOptions.pass;\n  const sceneGraph = model.sceneGraph;\n\n  const modelMatrix = Matrix4.multiplyTransformation(\n    sceneGraph.computedModelMatrix,\n    primitiveRenderResources.runtimeNode.computedTransform,\n    new Matrix4()\n  );\n\n  let boundingSphere;\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    !frameState.scene3DOnly &&\n    model._projectTo2D\n  ) {\n    const runtimePrimitive = primitiveRenderResources.runtimePrimitive;\n    boundingSphere = runtimePrimitive.boundingSphere2D;\n  } else {\n    boundingSphere = BoundingSphere.transform(\n      primitiveRenderResources.boundingSphere,\n      modelMatrix,\n      primitiveRenderResources.boundingSphere\n    );\n  }\n\n  // Initialize render state with default values\n  let renderState = clone(\n    RenderState.fromCache(primitiveRenderResources.renderStateOptions),\n    true\n  );\n\n  if (model.opaquePass === Pass.CESIUM_3D_TILE) {\n    // Set stencil values for classification on 3D Tiles\n    renderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    renderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  }\n\n  renderState.cull.face = ModelExperimentalUtility.getCullFace(\n    modelMatrix,\n    primitiveRenderResources.primitiveType\n  );\n  renderState = RenderState.fromCache(renderState);\n\n  const count = primitiveRenderResources.count;\n\n  const command = new DrawCommand({\n    boundingVolume: boundingSphere,\n    modelMatrix: modelMatrix,\n    uniformMap: primitiveRenderResources.uniformMap,\n    renderState: renderState,\n    vertexArray: vertexArray,\n    shaderProgram: shaderProgram,\n    cull: model.cull,\n    pass: pass,\n    count: count,\n    pickId: primitiveRenderResources.pickId,\n    instanceCount: primitiveRenderResources.instanceCount,\n    primitiveType: primitiveRenderResources.primitiveType,\n    debugShowBoundingVolume: model.debugShowBoundingVolume,\n    castShadows: ShadowMode.castShadows(model.shadows),\n    receiveShadows: ShadowMode.receiveShadows(model.shadows),\n  });\n\n  return new ModelExperimentalDrawCommand({\n    primitiveRenderResources: primitiveRenderResources,\n    command: command,\n  });\n}\n\n/**\n * @private\n */\nfunction getIndexBuffer(primitiveRenderResources, frameState) {\n  const wireframeIndexBuffer = primitiveRenderResources.wireframeIndexBuffer;\n  if (defined(wireframeIndexBuffer)) {\n    return wireframeIndexBuffer;\n  }\n\n  const indices = primitiveRenderResources.indices;\n  if (!defined(indices)) {\n    return undefined;\n  }\n\n  if (defined(indices.buffer)) {\n    return indices.buffer;\n  }\n\n  const typedArray = indices.typedArray;\n  const indexDatatype = IndexDatatype.fromSizeInBytes(\n    typedArray.BYTES_PER_ELEMENT\n  );\n\n  return Buffer.createIndexBuffer({\n    context: frameState.context,\n    typedArray: typedArray,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n}\n","import Matrix4 from \"../Core/Matrix4.js\";\n\n/**\n * @private\n */\nfunction ModelInstance(collection, modelMatrix, instanceId) {\n  this.primitive = collection;\n  this._modelMatrix = Matrix4.clone(modelMatrix);\n  this._instanceId = instanceId;\n}\n\nObject.defineProperties(ModelInstance.prototype, {\n  instanceId: {\n    get: function () {\n      return this._instanceId;\n    },\n  },\n  model: {\n    get: function () {\n      return this.primitive._model;\n    },\n  },\n  modelMatrix: {\n    get: function () {\n      return Matrix4.clone(this._modelMatrix);\n    },\n    set: function (value) {\n      Matrix4.clone(value, this._modelMatrix);\n      this.primitive.expandBoundingSphere(this._modelMatrix);\n      this.primitive._dirty = true;\n    },\n  },\n});\nexport default ModelInstance;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport ImageBasedLighting from \"./ImageBasedLighting.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ForEach from \"./GltfPipeline/ForEach.js\";\nimport Model from \"./Model.js\";\nimport ModelInstance from \"./ModelInstance.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport SplitDirection from \"./SplitDirection.js\";\n\nconst LoadState = {\n  NEEDS_LOAD: 0,\n  LOADING: 1,\n  LOADED: 2,\n  FAILED: 3,\n};\n\n/**\n * A 3D model instance collection. All instances reference the same underlying model, but have unique\n * per-instance properties like model matrix, pick id, etc.\n *\n * Instances are rendered relative-to-center and for best results instances should be positioned close to one another.\n * Otherwise there may be precision issues if, for example, instances are placed on opposite sides of the globe.\n *\n * @alias ModelInstanceCollection\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Object[]} [options.instances] An array of instances, where each instance contains a modelMatrix and optional batchId when options.batchTable is defined.\n * @param {Cesium3DTileBatchTable} [options.batchTable] The batch table of the instanced 3D Tile.\n * @param {Resource|String} [options.url] The url to the .gltf file.\n * @param {Object} [options.requestType] The request type, used for request prioritization\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.dynamic=false] Hint if instance model matrices will be updated frequently.\n * @param {Boolean} [options.show=true] Determines if the collection will be shown.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each instance is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the collection casts or receives shadows from light sources.\n * @param {Cartesian3} [options.lightColor] The light color when shading models. When <code>undefined</code> the scene's light color is used instead.\n * @param {ImageBasedLighting} [options.imageBasedLighting] The properties for managing image-based lighting for this tileset.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the glTF material's doubleSided property; when false, back face culling is disabled.\n * @param {Boolean} [options.showCreditsOnScreen=false] Whether to display the credits of this model on screen.\n * @param {SplitDirection} [options.splitDirection=SplitDirection.NONE] The {@link SplitDirection} split to apply to this collection.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for the collection.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the instances in wireframe.\n * @exception {DeveloperError} Must specify either <options.gltf> or <options.url>, but not both.\n * @exception {DeveloperError} Shader program cannot be optimized for instancing. Parameters cannot have any of the following semantics: MODEL, MODELINVERSE, MODELVIEWINVERSE, MODELVIEWPROJECTIONINVERSE, MODELINVERSETRANSPOSE.\n *\n * @private\n */\nfunction ModelInstanceCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.gltf) && !defined(options.url)) {\n    throw new DeveloperError(\"Either options.gltf or options.url is required.\");\n  }\n\n  if (defined(options.gltf) && defined(options.url)) {\n    throw new DeveloperError(\n      \"Cannot pass in both options.gltf and options.url.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this.show = defaultValue(options.show, true);\n\n  this._instancingSupported = false;\n  this._dynamic = defaultValue(options.dynamic, false);\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._ready = false;\n  this._readyPromise = defer();\n  this._state = LoadState.NEEDS_LOAD;\n  this._dirty = false;\n\n  // Undocumented options\n  this._cull = defaultValue(options.cull, true);\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n\n  this._instances = createInstances(this, options.instances);\n\n  // When the model instance collection is backed by an i3dm tile,\n  // use its batch table resources to modify the shaders, attributes, and uniform maps.\n  this._batchTable = options.batchTable;\n\n  this._model = undefined;\n  this._vertexBufferTypedArray = undefined; // Hold onto the vertex buffer contents when dynamic is true\n  this._vertexBuffer = undefined;\n  this._batchIdBuffer = undefined;\n  this._instancedUniformsByProgram = undefined;\n\n  this._drawCommands = [];\n  this._modelCommands = undefined;\n\n  this._renderStates = undefined;\n  this._disableCullingRenderStates = undefined;\n\n  this._boundingSphere = createBoundingSphere(this);\n  this._center = Cartesian3.clone(this._boundingSphere.center);\n  this._rtcTransform = new Matrix4();\n  this._rtcModelView = new Matrix4(); // Holds onto uniform\n\n  this._mode = undefined;\n\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n\n  // Passed on to Model\n  this._url = Resource.createIfNeeded(options.url);\n  this._requestType = options.requestType;\n  this._gltf = options.gltf;\n  this._basePath = Resource.createIfNeeded(options.basePath);\n  this._asynchronous = options.asynchronous;\n  this._incrementallyLoadTextures = options.incrementallyLoadTextures;\n  this._upAxis = options.upAxis; // Undocumented option\n  this._forwardAxis = options.forwardAxis; // Undocumented option\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n\n  this._pickIdLoaded = options.pickIdLoaded;\n\n  /**\n   * The {@link SplitDirection} to apply to this collection.\n   *\n   * @type {SplitDirection}\n   * @default {@link SplitDirection.NONE}\n   */\n  this.splitDirection = defaultValue(\n    options.splitDirection,\n    SplitDirection.NONE\n  );\n\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n  this._debugShowBoundingVolume = false;\n\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n\n  if (defined(options.imageBasedLighting)) {\n    this._imageBasedLighting = options.imageBasedLighting;\n    this._shouldDestroyImageBasedLighting = false;\n  } else {\n    this._imageBasedLighting = new ImageBasedLighting();\n    this._shouldDestroyImageBasedLighting = true;\n  }\n\n  this.backFaceCulling = defaultValue(options.backFaceCulling, true);\n  this._backFaceCulling = this.backFaceCulling;\n  this.showCreditsOnScreen = defaultValue(options.showCreditsOnScreen, false);\n}\n\nObject.defineProperties(ModelInstanceCollection.prototype, {\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n  length: {\n    get: function () {\n      return this._instances.length;\n    },\n  },\n  activeAnimations: {\n    get: function () {\n      return this._model.activeAnimations;\n    },\n  },\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n  imageBasedLighting: {\n    get: function () {\n      return this._imageBasedLighting;\n    },\n    set: function (value) {\n      if (value !== this._imageBasedLighting) {\n        if (\n          this._shouldDestroyImageBasedLighting &&\n          !this._imageBasedLighting.isDestroyed()\n        ) {\n          this._imageBasedLighting.destroy();\n        }\n        this._imageBasedLighting = value;\n        this._shouldDestroyImageBasedLighting = false;\n      }\n    },\n  },\n});\n\nfunction createInstances(collection, instancesOptions) {\n  instancesOptions = defaultValue(instancesOptions, []);\n  const length = instancesOptions.length;\n  const instances = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    const instanceOptions = instancesOptions[i];\n    const modelMatrix = instanceOptions.modelMatrix;\n    const instanceId = defaultValue(instanceOptions.batchId, i);\n    instances[i] = new ModelInstance(collection, modelMatrix, instanceId);\n  }\n  return instances;\n}\n\nfunction createBoundingSphere(collection) {\n  const instancesLength = collection.length;\n  const points = new Array(instancesLength);\n  for (let i = 0; i < instancesLength; ++i) {\n    points[i] = Matrix4.getTranslation(\n      collection._instances[i]._modelMatrix,\n      new Cartesian3()\n    );\n  }\n\n  return BoundingSphere.fromPoints(points);\n}\n\nconst scratchCartesian = new Cartesian3();\nconst scratchMatrix = new Matrix4();\n\nModelInstanceCollection.prototype.expandBoundingSphere = function (\n  instanceModelMatrix\n) {\n  const translation = Matrix4.getTranslation(\n    instanceModelMatrix,\n    scratchCartesian\n  );\n  BoundingSphere.expand(\n    this._boundingSphere,\n    translation,\n    this._boundingSphere\n  );\n};\n\nfunction getCheckUniformSemanticFunction(\n  modelSemantics,\n  supportedSemantics,\n  programId,\n  uniformMap\n) {\n  return function (uniform, uniformName) {\n    const semantic = uniform.semantic;\n    if (defined(semantic) && modelSemantics.indexOf(semantic) > -1) {\n      if (supportedSemantics.indexOf(semantic) > -1) {\n        uniformMap[uniformName] = semantic;\n      } else {\n        throw new RuntimeError(\n          `${\n            \"Shader program cannot be optimized for instancing. \" + 'Uniform \"'\n          }${uniformName}\" in program \"${programId}\" uses unsupported semantic \"${semantic}\"`\n        );\n      }\n    }\n  };\n}\n\nfunction getInstancedUniforms(collection, programId) {\n  if (defined(collection._instancedUniformsByProgram)) {\n    return collection._instancedUniformsByProgram[programId];\n  }\n\n  const instancedUniformsByProgram = {};\n  collection._instancedUniformsByProgram = instancedUniformsByProgram;\n\n  // When using CESIUM_RTC_MODELVIEW the CESIUM_RTC center is ignored. Instances are always rendered relative-to-center.\n  const modelSemantics = [\n    \"MODEL\",\n    \"MODELVIEW\",\n    \"CESIUM_RTC_MODELVIEW\",\n    \"MODELVIEWPROJECTION\",\n    \"MODELINVERSE\",\n    \"MODELVIEWINVERSE\",\n    \"MODELVIEWPROJECTIONINVERSE\",\n    \"MODELINVERSETRANSPOSE\",\n    \"MODELVIEWINVERSETRANSPOSE\",\n  ];\n  const supportedSemantics = [\n    \"MODELVIEW\",\n    \"CESIUM_RTC_MODELVIEW\",\n    \"MODELVIEWPROJECTION\",\n    \"MODELVIEWINVERSETRANSPOSE\",\n  ];\n\n  const techniques = collection._model._sourceTechniques;\n  for (const techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      const technique = techniques[techniqueId];\n      const program = technique.program;\n\n      // Different techniques may share the same program, skip if already processed.\n      // This assumes techniques that share a program do not declare different semantics for the same uniforms.\n      if (!defined(instancedUniformsByProgram[program])) {\n        const uniformMap = {};\n        instancedUniformsByProgram[program] = uniformMap;\n        ForEach.techniqueUniform(\n          technique,\n          getCheckUniformSemanticFunction(\n            modelSemantics,\n            supportedSemantics,\n            programId,\n            uniformMap\n          )\n        );\n      }\n    }\n  }\n\n  return instancedUniformsByProgram[programId];\n}\n\nfunction getVertexShaderCallback(collection) {\n  return function (vs, programId) {\n    const instancedUniforms = getInstancedUniforms(collection, programId);\n    const usesBatchTable = defined(collection._batchTable);\n\n    let renamedSource = ShaderSource.replaceMain(vs, \"czm_instancing_main\");\n\n    let globalVarsHeader = \"\";\n    let globalVarsMain = \"\";\n    for (const uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        const semantic = instancedUniforms[uniform];\n        let varName;\n        if (semantic === \"MODELVIEW\" || semantic === \"CESIUM_RTC_MODELVIEW\") {\n          varName = \"czm_instanced_modelView\";\n        } else if (semantic === \"MODELVIEWPROJECTION\") {\n          varName = \"czm_instanced_modelViewProjection\";\n          globalVarsHeader += \"mat4 czm_instanced_modelViewProjection;\\n\";\n          globalVarsMain +=\n            \"czm_instanced_modelViewProjection = czm_projection * czm_instanced_modelView;\\n\";\n        } else if (semantic === \"MODELVIEWINVERSETRANSPOSE\") {\n          varName = \"czm_instanced_modelViewInverseTranspose\";\n          globalVarsHeader += \"mat3 czm_instanced_modelViewInverseTranspose;\\n\";\n          globalVarsMain +=\n            \"czm_instanced_modelViewInverseTranspose = mat3(czm_instanced_modelView);\\n\";\n        }\n\n        // Remove the uniform declaration\n        let regex = new RegExp(`uniform.*${uniform}.*`);\n        renamedSource = renamedSource.replace(regex, \"\");\n\n        // Replace all occurrences of the uniform with the global variable\n        regex = new RegExp(`${uniform}\\\\b`, \"g\");\n        renamedSource = renamedSource.replace(regex, varName);\n      }\n    }\n\n    // czm_instanced_model is the model matrix of the instance relative to center\n    // czm_instanced_modifiedModelView is the transform from the center to view\n    // czm_instanced_nodeTransform is the local offset of the node within the model\n    const uniforms =\n      \"uniform mat4 czm_instanced_modifiedModelView;\\n\" +\n      \"uniform mat4 czm_instanced_nodeTransform;\\n\";\n\n    let batchIdAttribute;\n    let pickAttribute;\n    let pickVarying;\n\n    if (usesBatchTable) {\n      batchIdAttribute = \"attribute float a_batchId;\\n\";\n      pickAttribute = \"\";\n      pickVarying = \"\";\n    } else {\n      batchIdAttribute = \"\";\n      pickAttribute =\n        \"attribute vec4 pickColor;\\n\" + \"varying vec4 v_pickColor;\\n\";\n      pickVarying = \"    v_pickColor = pickColor;\\n\";\n    }\n\n    let instancedSource =\n      `${uniforms + globalVarsHeader}mat4 czm_instanced_modelView;\\n` +\n      `attribute vec4 czm_modelMatrixRow0;\\n` +\n      `attribute vec4 czm_modelMatrixRow1;\\n` +\n      `attribute vec4 czm_modelMatrixRow2;\\n${batchIdAttribute}${pickAttribute}${renamedSource}void main()\\n` +\n      `{\\n` +\n      `    mat4 czm_instanced_model = mat4(czm_modelMatrixRow0.x, czm_modelMatrixRow1.x, czm_modelMatrixRow2.x, 0.0, czm_modelMatrixRow0.y, czm_modelMatrixRow1.y, czm_modelMatrixRow2.y, 0.0, czm_modelMatrixRow0.z, czm_modelMatrixRow1.z, czm_modelMatrixRow2.z, 0.0, czm_modelMatrixRow0.w, czm_modelMatrixRow1.w, czm_modelMatrixRow2.w, 1.0);\\n` +\n      `    czm_instanced_modelView = czm_instanced_modifiedModelView * czm_instanced_model * czm_instanced_nodeTransform;\\n${globalVarsMain}    czm_instancing_main();\\n${pickVarying}}\\n`;\n\n    if (usesBatchTable) {\n      const gltf = collection._model.gltfInternal;\n      const diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      instancedSource = collection._batchTable.getVertexShaderCallback(\n        true,\n        \"a_batchId\",\n        diffuseAttributeOrUniformName\n      )(instancedSource);\n    }\n\n    return instancedSource;\n  };\n}\n\nfunction getFragmentShaderCallback(collection) {\n  return function (fs, programId) {\n    const batchTable = collection._batchTable;\n    if (defined(batchTable)) {\n      const gltf = collection._model.gltfInternal;\n      const diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      fs = batchTable.getFragmentShaderCallback(\n        true,\n        diffuseAttributeOrUniformName,\n        false\n      )(fs);\n    } else {\n      fs = `varying vec4 v_pickColor;\\n${fs}`;\n    }\n    return fs;\n  };\n}\n\nfunction createModifiedModelView(collection, context) {\n  return function () {\n    return Matrix4.multiply(\n      context.uniformState.view,\n      collection._rtcTransform,\n      collection._rtcModelView\n    );\n  };\n}\n\nfunction createNodeTransformFunction(node) {\n  return function () {\n    return node.computedMatrix;\n  };\n}\n\nfunction getUniformMapCallback(collection, context) {\n  return function (uniformMap, programId, node) {\n    uniformMap = clone(uniformMap);\n    uniformMap.czm_instanced_modifiedModelView = createModifiedModelView(\n      collection,\n      context\n    );\n    uniformMap.czm_instanced_nodeTransform = createNodeTransformFunction(node);\n\n    // Remove instanced uniforms from the uniform map\n    const instancedUniforms = getInstancedUniforms(collection, programId);\n    for (const uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        delete uniformMap[uniform];\n      }\n    }\n\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexShaderNonInstancedCallback(collection) {\n  return function (vs, programId) {\n    if (defined(collection._batchTable)) {\n      const gltf = collection._model.gltfInternal;\n      const diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      vs = collection._batchTable.getVertexShaderCallback(\n        true,\n        \"a_batchId\",\n        diffuseAttributeOrUniformName\n      )(vs);\n      // Treat a_batchId as a uniform rather than a vertex attribute\n      vs = `uniform float a_batchId\\n;${vs}`;\n    }\n    return vs;\n  };\n}\n\nfunction getFragmentShaderNonInstancedCallback(collection) {\n  return function (fs, programId) {\n    const batchTable = collection._batchTable;\n    if (defined(batchTable)) {\n      const gltf = collection._model.gltfInternal;\n      const diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      fs = batchTable.getFragmentShaderCallback(\n        true,\n        diffuseAttributeOrUniformName,\n        false\n      )(fs);\n    } else {\n      fs = `uniform vec4 czm_pickColor;\\n${fs}`;\n    }\n    return fs;\n  };\n}\n\nfunction getUniformMapNonInstancedCallback(collection) {\n  return function (uniformMap) {\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexBufferTypedArray(collection) {\n  const instances = collection._instances;\n  const instancesLength = collection.length;\n  const collectionCenter = collection._center;\n  const vertexSizeInFloats = 12;\n\n  let bufferData = collection._vertexBufferTypedArray;\n  if (!defined(bufferData)) {\n    bufferData = new Float32Array(instancesLength * vertexSizeInFloats);\n  }\n  if (collection._dynamic) {\n    // Hold onto the buffer data so we don't have to allocate new memory every frame.\n    collection._vertexBufferTypedArray = bufferData;\n  }\n\n  for (let i = 0; i < instancesLength; ++i) {\n    const modelMatrix = instances[i]._modelMatrix;\n\n    // Instance matrix is relative to center\n    const instanceMatrix = Matrix4.clone(modelMatrix, scratchMatrix);\n    instanceMatrix[12] -= collectionCenter.x;\n    instanceMatrix[13] -= collectionCenter.y;\n    instanceMatrix[14] -= collectionCenter.z;\n\n    const offset = i * vertexSizeInFloats;\n\n    // First three rows of the model matrix\n    bufferData[offset + 0] = instanceMatrix[0];\n    bufferData[offset + 1] = instanceMatrix[4];\n    bufferData[offset + 2] = instanceMatrix[8];\n    bufferData[offset + 3] = instanceMatrix[12];\n    bufferData[offset + 4] = instanceMatrix[1];\n    bufferData[offset + 5] = instanceMatrix[5];\n    bufferData[offset + 6] = instanceMatrix[9];\n    bufferData[offset + 7] = instanceMatrix[13];\n    bufferData[offset + 8] = instanceMatrix[2];\n    bufferData[offset + 9] = instanceMatrix[6];\n    bufferData[offset + 10] = instanceMatrix[10];\n    bufferData[offset + 11] = instanceMatrix[14];\n  }\n\n  return bufferData;\n}\n\nfunction createVertexBuffer(collection, context) {\n  let i;\n  const instances = collection._instances;\n  const instancesLength = collection.length;\n  const dynamic = collection._dynamic;\n  const usesBatchTable = defined(collection._batchTable);\n\n  if (usesBatchTable) {\n    const batchIdBufferData = new Uint16Array(instancesLength);\n    for (i = 0; i < instancesLength; ++i) {\n      batchIdBufferData[i] = instances[i]._instanceId;\n    }\n    collection._batchIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIdBufferData,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n  }\n\n  if (!usesBatchTable) {\n    const pickIdBuffer = new Uint8Array(instancesLength * 4);\n    for (i = 0; i < instancesLength; ++i) {\n      const pickId = collection._pickIds[i];\n      const pickColor = pickId.color;\n      const offset = i * 4;\n      pickIdBuffer[offset] = Color.floatToByte(pickColor.red);\n      pickIdBuffer[offset + 1] = Color.floatToByte(pickColor.green);\n      pickIdBuffer[offset + 2] = Color.floatToByte(pickColor.blue);\n      pickIdBuffer[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n    collection._pickIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: pickIdBuffer,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n  }\n\n  const vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n  collection._vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: vertexBufferTypedArray,\n    usage: dynamic ? BufferUsage.STREAM_DRAW : BufferUsage.STATIC_DRAW,\n  });\n}\n\nfunction updateVertexBuffer(collection) {\n  const vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n  collection._vertexBuffer.copyFromArrayView(vertexBufferTypedArray);\n}\n\nfunction createPickIds(collection, context) {\n  // PERFORMANCE_IDEA: we could skip the pick buffer completely by allocating\n  // a continuous range of pickIds and then converting the base pickId + batchId\n  // to RGBA in the shader.  The only consider is precision issues, which might\n  // not be an issue in WebGL 2.\n  const instances = collection._instances;\n  const instancesLength = instances.length;\n  const pickIds = new Array(instancesLength);\n  for (let i = 0; i < instancesLength; ++i) {\n    pickIds[i] = context.createPickId(instances[i]);\n  }\n  return pickIds;\n}\n\nfunction createModel(collection, context) {\n  const instancingSupported = collection._instancingSupported;\n  const usesBatchTable = defined(collection._batchTable);\n  const allowPicking = collection._allowPicking;\n\n  const modelOptions = {\n    url: collection._url,\n    requestType: collection._requestType,\n    gltf: collection._gltf,\n    basePath: collection._basePath,\n    shadows: collection._shadows,\n    cacheKey: undefined,\n    asynchronous: collection._asynchronous,\n    allowPicking: allowPicking,\n    incrementallyLoadTextures: collection._incrementallyLoadTextures,\n    upAxis: collection._upAxis,\n    forwardAxis: collection._forwardAxis,\n    precreatedAttributes: undefined,\n    vertexShaderLoaded: undefined,\n    fragmentShaderLoaded: undefined,\n    uniformMapLoaded: undefined,\n    pickIdLoaded: collection._pickIdLoaded,\n    ignoreCommands: true,\n    opaquePass: collection._opaquePass,\n    imageBasedLighting: collection._imageBasedLighting,\n    showOutline: collection.showOutline,\n    showCreditsOnScreen: collection.showCreditsOnScreen,\n  };\n\n  if (!usesBatchTable) {\n    collection._pickIds = createPickIds(collection, context);\n  }\n\n  if (instancingSupported) {\n    createVertexBuffer(collection, context);\n\n    const vertexSizeInFloats = 12;\n    const componentSizeInBytes = ComponentDatatype.getSizeInBytes(\n      ComponentDatatype.FLOAT\n    );\n\n    const instancedAttributes = {\n      czm_modelMatrixRow0: {\n        index: 0, // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1,\n      },\n      czm_modelMatrixRow1: {\n        index: 0, // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 4,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1,\n      },\n      czm_modelMatrixRow2: {\n        index: 0, // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 8,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1,\n      },\n    };\n\n    // When using a batch table, add a batch id attribute\n    if (usesBatchTable) {\n      instancedAttributes.a_batchId = {\n        index: 0, // updated in Model\n        vertexBuffer: collection._batchIdBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1,\n      };\n    }\n\n    if (!usesBatchTable) {\n      instancedAttributes.pickColor = {\n        index: 0, // updated in Model\n        vertexBuffer: collection._pickIdBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1,\n      };\n    }\n\n    modelOptions.precreatedAttributes = instancedAttributes;\n    modelOptions.vertexShaderLoaded = getVertexShaderCallback(collection);\n    modelOptions.fragmentShaderLoaded = getFragmentShaderCallback(collection);\n    modelOptions.uniformMapLoaded = getUniformMapCallback(collection, context);\n\n    if (defined(collection._url)) {\n      modelOptions.cacheKey = `${collection._url.getUrlComponent()}#instanced`;\n    }\n  } else {\n    modelOptions.vertexShaderLoaded = getVertexShaderNonInstancedCallback(\n      collection\n    );\n    modelOptions.fragmentShaderLoaded = getFragmentShaderNonInstancedCallback(\n      collection\n    );\n    modelOptions.uniformMapLoaded = getUniformMapNonInstancedCallback(\n      collection,\n      context\n    );\n  }\n\n  if (defined(collection._url)) {\n    collection._model = Model.fromGltf(modelOptions);\n  } else {\n    collection._model = new Model(modelOptions);\n  }\n}\n\nfunction updateWireframe(collection, force) {\n  if (collection._debugWireframe !== collection.debugWireframe || force) {\n    collection._debugWireframe = collection.debugWireframe;\n\n    // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n    const primitiveType = collection.debugWireframe\n      ? PrimitiveType.LINES\n      : PrimitiveType.TRIANGLES;\n    const commands = collection._drawCommands;\n    const length = commands.length;\n    for (let i = 0; i < length; ++i) {\n      commands[i].primitiveType = primitiveType;\n    }\n  }\n}\n\nfunction getDisableCullingRenderState(renderState) {\n  const rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  return RenderState.fromCache(rs);\n}\n\nfunction updateBackFaceCulling(collection, force) {\n  if (collection._backFaceCulling !== collection.backFaceCulling || force) {\n    collection._backFaceCulling = collection.backFaceCulling;\n\n    const commands = collection._drawCommands;\n    const length = commands.length;\n    let i;\n\n    if (!defined(collection._disableCullingRenderStates)) {\n      collection._disableCullingRenderStates = new Array(length);\n      collection._renderStates = new Array(length);\n      for (i = 0; i < length; ++i) {\n        const renderState = commands[i].renderState;\n        const derivedRenderState = getDisableCullingRenderState(renderState);\n        collection._disableCullingRenderStates[i] = derivedRenderState;\n        collection._renderStates[i] = renderState;\n      }\n    }\n\n    for (i = 0; i < length; ++i) {\n      commands[i].renderState = collection._backFaceCulling\n        ? collection._renderStates[i]\n        : collection._disableCullingRenderStates[i];\n    }\n  }\n}\n\nfunction updateShowBoundingVolume(collection, force) {\n  if (\n    collection.debugShowBoundingVolume !==\n      collection._debugShowBoundingVolume ||\n    force\n  ) {\n    collection._debugShowBoundingVolume = collection.debugShowBoundingVolume;\n\n    const commands = collection._drawCommands;\n    const length = commands.length;\n    for (let i = 0; i < length; ++i) {\n      commands[i].debugShowBoundingVolume = collection.debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction createCommands(collection, drawCommands) {\n  const commandsLength = drawCommands.length;\n  const instancesLength = collection.length;\n  const boundingSphere = collection._boundingSphere;\n  const cull = collection._cull;\n\n  for (let i = 0; i < commandsLength; ++i) {\n    const drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n    drawCommand.instanceCount = instancesLength;\n    drawCommand.boundingVolume = boundingSphere;\n    drawCommand.cull = cull;\n    if (defined(collection._batchTable)) {\n      drawCommand.pickId = collection._batchTable.getPickId();\n    } else {\n      drawCommand.pickId = \"v_pickColor\";\n    }\n    collection._drawCommands.push(drawCommand);\n  }\n}\n\nfunction createBatchIdFunction(batchId) {\n  return function () {\n    return batchId;\n  };\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createCommandsNonInstanced(collection, drawCommands) {\n  // When instancing is disabled, create commands for every instance.\n  const instances = collection._instances;\n  const commandsLength = drawCommands.length;\n  const instancesLength = collection.length;\n  const batchTable = collection._batchTable;\n  const usesBatchTable = defined(batchTable);\n  const cull = collection._cull;\n\n  for (let i = 0; i < commandsLength; ++i) {\n    for (let j = 0; j < instancesLength; ++j) {\n      const drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n      drawCommand.modelMatrix = new Matrix4(); // Updated in updateCommandsNonInstanced\n      drawCommand.boundingVolume = new BoundingSphere(); // Updated in updateCommandsNonInstanced\n      drawCommand.cull = cull;\n      drawCommand.uniformMap = clone(drawCommand.uniformMap);\n      if (usesBatchTable) {\n        drawCommand.uniformMap.a_batchId = createBatchIdFunction(\n          instances[j]._instanceId\n        );\n      } else {\n        const pickId = collection._pickIds[j];\n        drawCommand.uniformMap.czm_pickColor = createPickColorFunction(\n          pickId.color\n        );\n      }\n      collection._drawCommands.push(drawCommand);\n    }\n  }\n}\n\nfunction updateCommandsNonInstanced(collection) {\n  const modelCommands = collection._modelCommands;\n  const commandsLength = modelCommands.length;\n  const instancesLength = collection.length;\n  const collectionTransform = collection._rtcTransform;\n  const collectionCenter = collection._center;\n\n  for (let i = 0; i < commandsLength; ++i) {\n    const modelCommand = modelCommands[i];\n    for (let j = 0; j < instancesLength; ++j) {\n      const commandIndex = i * instancesLength + j;\n      const drawCommand = collection._drawCommands[commandIndex];\n      let instanceMatrix = Matrix4.clone(\n        collection._instances[j]._modelMatrix,\n        scratchMatrix\n      );\n      instanceMatrix[12] -= collectionCenter.x;\n      instanceMatrix[13] -= collectionCenter.y;\n      instanceMatrix[14] -= collectionCenter.z;\n      instanceMatrix = Matrix4.multiply(\n        collectionTransform,\n        instanceMatrix,\n        scratchMatrix\n      );\n      const nodeMatrix = modelCommand.modelMatrix;\n      const modelMatrix = drawCommand.modelMatrix;\n      Matrix4.multiply(instanceMatrix, nodeMatrix, modelMatrix);\n\n      const nodeBoundingSphere = modelCommand.boundingVolume;\n      const boundingSphere = drawCommand.boundingVolume;\n      BoundingSphere.transform(\n        nodeBoundingSphere,\n        instanceMatrix,\n        boundingSphere\n      );\n    }\n  }\n}\n\nfunction getModelCommands(model) {\n  const nodeCommands = model._nodeCommands;\n  const length = nodeCommands.length;\n\n  const drawCommands = [];\n\n  for (let i = 0; i < length; ++i) {\n    const nc = nodeCommands[i];\n    if (nc.show) {\n      drawCommands.push(nc.command);\n    }\n  }\n\n  return drawCommands;\n}\n\nfunction commandsDirty(model) {\n  const nodeCommands = model._nodeCommands;\n  const length = nodeCommands.length;\n\n  let commandsDirty = false;\n\n  for (let i = 0; i < length; i++) {\n    const nc = nodeCommands[i];\n    if (nc.command.dirty) {\n      nc.command.dirty = false;\n      commandsDirty = true;\n    }\n  }\n  return commandsDirty;\n}\n\nfunction generateModelCommands(modelInstanceCollection, instancingSupported) {\n  modelInstanceCollection._drawCommands = [];\n\n  const modelCommands = getModelCommands(modelInstanceCollection._model);\n  if (instancingSupported) {\n    createCommands(modelInstanceCollection, modelCommands);\n  } else {\n    createCommandsNonInstanced(modelInstanceCollection, modelCommands);\n    updateCommandsNonInstanced(modelInstanceCollection);\n  }\n}\n\nfunction updateShadows(collection, force) {\n  if (collection.shadows !== collection._shadows || force) {\n    collection._shadows = collection.shadows;\n\n    const castShadows = ShadowMode.castShadows(collection.shadows);\n    const receiveShadows = ShadowMode.receiveShadows(collection.shadows);\n\n    const drawCommands = collection._drawCommands;\n    const length = drawCommands.length;\n    for (let i = 0; i < length; ++i) {\n      const drawCommand = drawCommands[i];\n      drawCommand.castShadows = castShadows;\n      drawCommand.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nModelInstanceCollection.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!this.show) {\n    return;\n  }\n\n  if (this.length === 0) {\n    return;\n  }\n\n  const context = frameState.context;\n\n  if (this._state === LoadState.NEEDS_LOAD) {\n    this._state = LoadState.LOADING;\n    this._instancingSupported = context.instancedArrays;\n    createModel(this, context);\n    const that = this;\n    this._model.readyPromise.catch(function (error) {\n      that._state = LoadState.FAILED;\n      that._readyPromise.reject(error);\n    });\n  }\n\n  const instancingSupported = this._instancingSupported;\n  const model = this._model;\n\n  model.imageBasedLighting = this._imageBasedLighting;\n  model.showCreditsOnScreen = this.showCreditsOnScreen;\n  model.splitDirection = this.splitDirection;\n\n  model.update(frameState);\n\n  if (model.ready && this._state === LoadState.LOADING) {\n    this._state = LoadState.LOADED;\n    this._ready = true;\n\n    // Expand bounding volume to fit the radius of the loaded model including the model's offset from the center\n    const modelRadius =\n      model.boundingSphereInternal.radius +\n      Cartesian3.magnitude(model.boundingSphereInternal.center);\n    this._boundingSphere.radius += modelRadius;\n    this._modelCommands = getModelCommands(model);\n\n    generateModelCommands(this, instancingSupported);\n\n    this._readyPromise.resolve(this);\n    return;\n  }\n\n  if (this._state !== LoadState.LOADED) {\n    return;\n  }\n\n  const modeChanged = frameState.mode !== this._mode;\n  const modelMatrix = this.modelMatrix;\n  const modelMatrixChanged = !Matrix4.equals(this._modelMatrix, modelMatrix);\n\n  if (modeChanged || modelMatrixChanged) {\n    this._mode = frameState.mode;\n    Matrix4.clone(modelMatrix, this._modelMatrix);\n    let rtcTransform = Matrix4.multiplyByTranslation(\n      this._modelMatrix,\n      this._center,\n      this._rtcTransform\n    );\n    if (this._mode !== SceneMode.SCENE3D) {\n      rtcTransform = Transforms.basisTo2D(\n        frameState.mapProjection,\n        rtcTransform,\n        rtcTransform\n      );\n    }\n    Matrix4.getTranslation(rtcTransform, this._boundingSphere.center);\n  }\n\n  if (instancingSupported && this._dirty) {\n    // If at least one instance has moved assume the collection is now dynamic\n    this._dynamic = true;\n    this._dirty = false;\n\n    // PERFORMANCE_IDEA: only update dirty sub-sections instead of the whole collection\n    updateVertexBuffer(this);\n  }\n\n  // If the model was set to rebuild shaders during update, rebuild instanced commands.\n  const modelCommandsDirty = commandsDirty(model);\n  if (modelCommandsDirty) {\n    generateModelCommands(this, instancingSupported);\n  }\n\n  // If any node changes due to an animation, update the commands. This could be inefficient if the model is\n  // composed of many nodes and only one changes, however it is probably fine in the general use case.\n  // Only applies when instancing is disabled. The instanced shader automatically handles node transformations.\n  if (\n    !instancingSupported &&\n    (model.dirty || this._dirty || modeChanged || modelMatrixChanged)\n  ) {\n    updateCommandsNonInstanced(this);\n  }\n\n  updateShadows(this, modelCommandsDirty);\n  updateWireframe(this, modelCommandsDirty);\n  updateBackFaceCulling(this, modelCommandsDirty);\n  updateShowBoundingVolume(this, modelCommandsDirty);\n\n  const passes = frameState.passes;\n  if (!passes.render && !passes.pick) {\n    return;\n  }\n\n  const commandList = frameState.commandList;\n  const commands = this._drawCommands;\n  const commandsLength = commands.length;\n\n  for (let i = 0; i < commandsLength; ++i) {\n    commandList.push(commands[i]);\n  }\n};\n\nModelInstanceCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\nModelInstanceCollection.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n\n  const pickIds = this._pickIds;\n  if (defined(pickIds)) {\n    const length = pickIds.length;\n    for (let i = 0; i < length; ++i) {\n      pickIds[i].destroy();\n    }\n  }\n\n  if (\n    this._shouldDestroyImageBasedLighting &&\n    !this._imageBasedLighting.isDestroyed()\n  ) {\n    this._imageBasedLighting.destroy();\n  }\n  this._imageBasedLighting = undefined;\n\n  return destroyObject(this);\n};\nexport default ModelInstanceCollection;\n","import Queue from \"../Core/Queue.js\";\n\n/**\n * @private\n */\nfunction ModelLoadResources() {\n  this.initialized = false;\n  this.resourcesParsed = false;\n\n  this.vertexBuffersToCreate = new Queue();\n  this.indexBuffersToCreate = new Queue();\n  this.buffers = {};\n  this.pendingBufferLoads = 0;\n\n  this.programsToCreate = new Queue();\n  this.shaders = {};\n  this.pendingShaderLoads = 0;\n\n  this.texturesToCreate = new Queue();\n  this.pendingTextureLoads = 0;\n\n  this.texturesToCreateFromBufferView = new Queue();\n  this.pendingBufferViewToImage = 0;\n\n  this.createSamplers = true;\n  this.createSkins = true;\n  this.createRuntimeAnimations = true;\n  this.createVertexArrays = true;\n  this.createRenderStates = true;\n  this.createUniformMaps = true;\n  this.createRuntimeNodes = true;\n\n  this.createdBufferViews = {};\n  this.primitivesToDecode = new Queue();\n  this.activeDecodingTasks = 0;\n  this.pendingDecodingCache = false;\n\n  this.skinnedNodesIds = [];\n}\n\n/**\n * This function differs from the normal subarray function\n * because it takes offset and length, rather than begin and end.\n * @private\n */\nfunction getSubarray(array, offset, length) {\n  return array.subarray(offset, offset + length);\n}\n\nModelLoadResources.prototype.getBuffer = function (bufferView) {\n  return getSubarray(\n    this.buffers[bufferView.buffer],\n    bufferView.byteOffset,\n    bufferView.byteLength\n  );\n};\n\nModelLoadResources.prototype.finishedPendingBufferLoads = function () {\n  return this.pendingBufferLoads === 0;\n};\n\nModelLoadResources.prototype.finishedBuffersCreation = function () {\n  return (\n    this.pendingBufferLoads === 0 &&\n    this.vertexBuffersToCreate.length === 0 &&\n    this.indexBuffersToCreate.length === 0\n  );\n};\n\nModelLoadResources.prototype.finishedProgramCreation = function () {\n  return this.pendingShaderLoads === 0 && this.programsToCreate.length === 0;\n};\n\nModelLoadResources.prototype.finishedTextureCreation = function () {\n  const finishedPendingLoads = this.pendingTextureLoads === 0;\n  const finishedResourceCreation =\n    this.texturesToCreate.length === 0 &&\n    this.texturesToCreateFromBufferView.length === 0;\n\n  return finishedPendingLoads && finishedResourceCreation;\n};\n\nModelLoadResources.prototype.finishedEverythingButTextureCreation = function () {\n  const finishedPendingLoads =\n    this.pendingBufferLoads === 0 && this.pendingShaderLoads === 0;\n  const finishedResourceCreation =\n    this.vertexBuffersToCreate.length === 0 &&\n    this.indexBuffersToCreate.length === 0 &&\n    this.programsToCreate.length === 0 &&\n    this.pendingBufferViewToImage === 0;\n\n  return (\n    this.finishedDecoding() && finishedPendingLoads && finishedResourceCreation\n  );\n};\n\nModelLoadResources.prototype.finishedDecoding = function () {\n  return (\n    this.primitivesToDecode.length === 0 &&\n    this.activeDecodingTasks === 0 &&\n    !this.pendingDecodingCache\n  );\n};\n\nModelLoadResources.prototype.finished = function () {\n  return (\n    this.finishedDecoding() &&\n    this.finishedTextureCreation() &&\n    this.finishedEverythingButTextureCreation()\n  );\n};\nexport default ModelLoadResources;\n","import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * A model's material with modifiable parameters.  A glTF material\n * contains parameters defined by the material's technique with values\n * defined by the technique and potentially overridden by the material.\n * This class allows changing these values at runtime.\n * <p>\n * Use {@link Model#getMaterial} to create an instance.\n * </p>\n *\n * @alias ModelMaterial\n * @internalConstructor\n * @class\n *\n * @see Model#getMaterial\n */\nfunction ModelMaterial(model, material, id) {\n  this._name = material.name;\n  this._id = id;\n  this._uniformMap = model._uniformMaps[id];\n\n  this._technique = undefined;\n  this._program = undefined;\n  this._values = undefined;\n}\n\nObject.defineProperties(ModelMaterial.prototype, {\n  /**\n   * The value of the <code>name</code> property of this material.\n   *\n   * @memberof ModelMaterial.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The index of the material.\n   *\n   * @memberof ModelMaterial.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n});\n\n/**\n * Assigns a value to a material parameter.  The type for <code>value</code>\n * depends on the glTF type of the parameter.  It will be a floating-point\n * number, Cartesian, or matrix.\n *\n * @param {String} name The name of the parameter.\n * @param {*} [value] The value to assign to the parameter.\n *\n * @exception {DeveloperError} name must match a parameter name in the material's technique that is targetable and not optimized out.\n *\n * @example\n * material.setValue('diffuse', new Cesium.Cartesian4(1.0, 0.0, 0.0, 1.0));  // vec4\n * material.setValue('shininess', 256.0); // scalar\n */\nModelMaterial.prototype.setValue = function (name, value) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const uniformName = `u_${name}`;\n  const v = this._uniformMap.values[uniformName];\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(v)) {\n    throw new DeveloperError(\n      \"name must match a parameter name in the material's technique that is targetable and not optimized out.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  v.value = v.clone(value, v.value);\n};\n\n/**\n * Returns the value of the parameter with the given <code>name</code>.  The type of the\n * returned object depends on the glTF type of the parameter.  It will be a floating-point\n * number, Cartesian, or matrix.\n *\n * @param {String} name The name of the parameter.\n * @returns {*} The value of the parameter or <code>undefined</code> if the parameter does not exist.\n */\nModelMaterial.prototype.getValue = function (name) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const uniformName = `u_${name}`;\n  const v = this._uniformMap.values[uniformName];\n\n  if (!defined(v)) {\n    return undefined;\n  }\n\n  return v.value;\n};\nexport default ModelMaterial;\n","/**\n * A model's mesh and its materials.\n * <p>\n * Use {@link Model#getMesh} to create an instance.\n * </p>\n *\n * @alias ModelMesh\n * @internalConstructor\n * @class\n *\n * @see Model#getMesh\n */\nfunction ModelMesh(mesh, runtimeMaterialsById, id) {\n  const materials = [];\n  const primitives = mesh.primitives;\n  const length = primitives.length;\n  for (let i = 0; i < length; ++i) {\n    const p = primitives[i];\n    materials[i] = runtimeMaterialsById[p.material];\n  }\n\n  this._name = mesh.name;\n  this._materials = materials;\n  this._id = id;\n}\n\nObject.defineProperties(ModelMesh.prototype, {\n  /**\n   * The value of the <code>name</code> property of this mesh.\n   *\n   * @memberof ModelMesh.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The index of the mesh.\n   *\n   * @memberof ModelMesh.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * An array of {@link ModelMaterial} instances indexed by the mesh's\n   * primitive indices.\n   *\n   * @memberof ModelMesh.prototype\n   *\n   * @type {ModelMaterial[]}\n   * @readonly\n   */\n  materials: {\n    get: function () {\n      return this._materials;\n    },\n  },\n});\nexport default ModelMesh;\n","import Matrix4 from \"../Core/Matrix4.js\";\n\n/**\n * A model node with a transform for user-defined animations.  A glTF asset can\n * contain animations that target a node's transform.  This class allows\n * changing a node's transform externally so animation can be driven by another\n * source, not just an animation in the glTF asset.\n * <p>\n * Use {@link Model#getNode} to create an instance.\n * </p>\n *\n * @alias ModelNode\n * @internalConstructor\n * @class\n *\n * @example\n * const node = model.getNode('LOD3sp');\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n *\n * @see Model#getNode\n */\nfunction ModelNode(model, node, runtimeNode, id, matrix) {\n  this._model = model;\n  this._runtimeNode = runtimeNode;\n  this._name = node.name;\n  this._id = id;\n\n  /**\n   * @private\n   */\n  this.useMatrix = false;\n\n  this._show = true;\n  this._matrix = Matrix4.clone(matrix);\n  this._originalMatrix = Matrix4.clone(matrix);\n}\n\nObject.defineProperties(ModelNode.prototype, {\n  /**\n   * The value of the <code>name</code> property of this node.\n   *\n   * @memberof ModelNode.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The index of the node.\n   *\n   * @memberof ModelNode.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * Determines if this node and its children will be shown.\n   *\n   * @memberof ModelNode.prototype\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      if (this._show !== value) {\n        this._show = value;\n        this._model._perNodeShowDirty = true;\n      }\n    },\n  },\n\n  /**\n   * The node's 4x4 matrix transform from its local coordinates to\n   * its parent's.\n   * <p>\n   * For changes to take effect, this property must be assigned to;\n   * setting individual elements of the matrix will not work.\n   * </p>\n   *\n   * @memberof ModelNode.prototype\n   * @type {Matrix4}\n   */\n  matrix: {\n    get: function () {\n      return this._matrix;\n    },\n    set: function (value) {\n      this._matrix = Matrix4.clone(value, this._matrix);\n      this.useMatrix = true;\n\n      const model = this._model;\n      model._cesiumAnimationsDirty = true;\n      this._runtimeNode.dirtyNumber = model._maxDirtyNumber;\n    },\n  },\n\n  /**\n   * Gets the node's original 4x4 matrix transform from its local coordinates to\n   * its parent's, without any node transformations or articulations applied.\n   *\n   * @memberof ModelNode.prototype\n   * @type {Matrix4}\n   */\n  originalMatrix: {\n    get: function () {\n      return this._originalMatrix;\n    },\n  },\n});\n\n/**\n * @private\n */\nModelNode.prototype.setMatrix = function (matrix) {\n  // Update matrix but do not set the dirty flag since this is used internally\n  // to keep the matrix in-sync during a glTF animation.\n  Matrix4.clone(matrix, this._matrix);\n};\nexport default ModelNode;\n","import defined from \"../Core/defined.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport ForEach from \"./GltfPipeline/ForEach.js\";\n\n// glTF does not allow an index value of 65535 because this is the primitive\n// restart value in some APIs.\nconst MAX_GLTF_UINT16_INDEX = 65534;\n\n/**\n * Creates face outlines for glTF primitives with the `CESIUM_primitive_outline` extension.\n * @private\n */\nfunction ModelOutlineLoader() {}\n\n/**\n * Returns true if the model uses or requires CESIUM_primitive_outline.\n * @private\n */\nModelOutlineLoader.hasExtension = function (model) {\n  return (\n    defined(model.extensionsRequired.CESIUM_primitive_outline) ||\n    defined(model.extensionsUsed.CESIUM_primitive_outline)\n  );\n};\n\n/**\n * Arranges to outline any primitives with the CESIUM_primitive_outline extension.\n * It is expected that all buffer data is loaded and available in\n * `extras._pipeline.source` before this function is called, and that vertex\n * and index WebGL buffers are not yet created.\n * @private\n */\nModelOutlineLoader.outlinePrimitives = function (model) {\n  if (!ModelOutlineLoader.hasExtension(model)) {\n    return;\n  }\n\n  const gltf = model.gltfInternal;\n\n  // Assumption: A single bufferView contains a single zero-indexed range of vertices.\n  // No trickery with using large accessor byteOffsets to store multiple zero-based\n  // ranges of vertices in a single bufferView. Use separate bufferViews for that,\n  // you monster.\n  // Note that interleaved vertex attributes (e.g. position0, normal0, uv0,\n  // position1, normal1, uv1, ...) _are_ supported and should not be confused with\n  // the above.\n\n  const vertexNumberingScopes = [];\n\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      if (!defined(primitive.extensions)) {\n        return;\n      }\n\n      const outlineData = primitive.extensions.CESIUM_primitive_outline;\n      if (!defined(outlineData)) {\n        return;\n      }\n\n      const vertexNumberingScope = getVertexNumberingScope(model, primitive);\n      if (vertexNumberingScope === undefined) {\n        return;\n      }\n\n      if (vertexNumberingScopes.indexOf(vertexNumberingScope) < 0) {\n        vertexNumberingScopes.push(vertexNumberingScope);\n      }\n\n      // Add the outline to this primitive\n      addOutline(\n        model,\n        meshId,\n        primitiveId,\n        outlineData.indices,\n        vertexNumberingScope\n      );\n    });\n  });\n\n  // Update all relevant bufferViews to include the duplicate vertices that are\n  // needed for outlining.\n  for (let i = 0; i < vertexNumberingScopes.length; ++i) {\n    updateBufferViewsWithNewVertices(\n      model,\n      vertexNumberingScopes[i].bufferViews\n    );\n  }\n\n  // Remove data not referenced by any bufferViews anymore.\n  compactBuffers(model);\n};\n\nModelOutlineLoader.createTexture = function (model, context) {\n  let cache = context.cache.modelOutliningCache;\n  if (!defined(cache)) {\n    cache = context.cache.modelOutliningCache = {};\n  }\n\n  if (defined(cache.outlineTexture)) {\n    return cache.outlineTexture;\n  }\n\n  const maxSize = Math.min(4096, ContextLimits.maximumTextureSize);\n\n  let size = maxSize;\n  const levelZero = createTexture(size);\n\n  const mipLevels = [];\n\n  while (size > 1) {\n    size >>= 1;\n    mipLevels.push(createTexture(size));\n  }\n\n  const texture = new Texture({\n    context: context,\n    source: {\n      arrayBufferView: levelZero,\n      mipLevels: mipLevels,\n    },\n    width: maxSize,\n    height: 1,\n    pixelFormat: PixelFormat.LUMINANCE,\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    }),\n  });\n\n  cache.outlineTexture = texture;\n\n  return texture;\n};\n\nfunction addOutline(\n  model,\n  meshId,\n  primitiveId,\n  edgeIndicesAccessorId,\n  vertexNumberingScope\n) {\n  const vertexCopies = vertexNumberingScope.vertexCopies;\n  const extraVertices = vertexNumberingScope.extraVertices;\n  const outlineCoordinates = vertexNumberingScope.outlineCoordinates;\n\n  const gltf = model.gltfInternal;\n  const mesh = gltf.meshes[meshId];\n  const primitive = mesh.primitives[primitiveId];\n  const accessors = gltf.accessors;\n  const bufferViews = gltf.bufferViews;\n\n  // Find the number of vertices in this primitive by looking at\n  // the first attribute. Others are required to be the same.\n  let numVertices;\n  for (const semantic in primitive.attributes) {\n    if (primitive.attributes.hasOwnProperty(semantic)) {\n      const attributeId = primitive.attributes[semantic];\n      const accessor = accessors[attributeId];\n      if (defined(accessor)) {\n        numVertices = accessor.count;\n        break;\n      }\n    }\n  }\n\n  if (!defined(numVertices)) {\n    return undefined;\n  }\n\n  const triangleIndexAccessorGltf = accessors[primitive.indices];\n  const triangleIndexBufferViewGltf =\n    bufferViews[triangleIndexAccessorGltf.bufferView];\n  const edgeIndexAccessorGltf = accessors[edgeIndicesAccessorId];\n  const edgeIndexBufferViewGltf = bufferViews[edgeIndexAccessorGltf.bufferView];\n\n  const loadResources = model._loadResources;\n  const triangleIndexBufferView = loadResources.getBuffer(\n    triangleIndexBufferViewGltf\n  );\n  const edgeIndexBufferView = loadResources.getBuffer(edgeIndexBufferViewGltf);\n\n  let triangleIndices =\n    triangleIndexAccessorGltf.componentType === 5123\n      ? new Uint16Array(\n          triangleIndexBufferView.buffer,\n          triangleIndexBufferView.byteOffset +\n            triangleIndexAccessorGltf.byteOffset,\n          triangleIndexAccessorGltf.count\n        )\n      : new Uint32Array(\n          triangleIndexBufferView.buffer,\n          triangleIndexBufferView.byteOffset +\n            triangleIndexAccessorGltf.byteOffset,\n          triangleIndexAccessorGltf.count\n        );\n  const edgeIndices =\n    edgeIndexAccessorGltf.componentType === 5123\n      ? new Uint16Array(\n          edgeIndexBufferView.buffer,\n          edgeIndexBufferView.byteOffset + edgeIndexAccessorGltf.byteOffset,\n          edgeIndexAccessorGltf.count\n        )\n      : new Uint32Array(\n          edgeIndexBufferView.buffer,\n          edgeIndexBufferView.byteOffset + edgeIndexAccessorGltf.byteOffset,\n          edgeIndexAccessorGltf.count\n        );\n\n  // Make a hash table for quick lookups of whether an edge exists between two\n  // vertices. The hash is a sparse array indexed by\n  //   `smallerVertexIndex * totalNumberOfVertices + biggerVertexIndex`\n  // A value of 1 indicates an edge exists between the two vertex indices; any\n  // other value indicates that it does not. We store the\n  // `edgeSmallMultipler` - that is, the number of vertices in the equation\n  // above - at index 0 for easy access to it later.\n\n  const edgeSmallMultiplier = numVertices;\n\n  const edges = [edgeSmallMultiplier];\n  let i;\n  for (i = 0; i < edgeIndices.length; i += 2) {\n    const a = edgeIndices[i];\n    const b = edgeIndices[i + 1];\n    const small = Math.min(a, b);\n    const big = Math.max(a, b);\n    edges[small * edgeSmallMultiplier + big] = 1;\n  }\n\n  // For each triangle, adjust vertex data so that the correct edges are outlined.\n  for (i = 0; i < triangleIndices.length; i += 3) {\n    let i0 = triangleIndices[i];\n    let i1 = triangleIndices[i + 1];\n    let i2 = triangleIndices[i + 2];\n\n    const all = false; // set this to true to draw a full wireframe.\n    const has01 = all || isHighlighted(edges, i0, i1);\n    const has12 = all || isHighlighted(edges, i1, i2);\n    const has20 = all || isHighlighted(edges, i2, i0);\n\n    let unmatchableVertexIndex = matchAndStoreCoordinates(\n      outlineCoordinates,\n      i0,\n      i1,\n      i2,\n      has01,\n      has12,\n      has20\n    );\n    while (unmatchableVertexIndex >= 0) {\n      // Copy the unmatchable index and try again.\n      let copy;\n      if (unmatchableVertexIndex === i0) {\n        copy = vertexCopies[i0];\n      } else if (unmatchableVertexIndex === i1) {\n        copy = vertexCopies[i1];\n      } else {\n        copy = vertexCopies[i2];\n      }\n\n      if (copy === undefined) {\n        copy = numVertices + extraVertices.length;\n\n        let original = unmatchableVertexIndex;\n        while (original >= numVertices) {\n          original = extraVertices[original - numVertices];\n        }\n        extraVertices.push(original);\n        vertexCopies[unmatchableVertexIndex] = copy;\n      }\n\n      if (\n        copy > MAX_GLTF_UINT16_INDEX &&\n        triangleIndices instanceof Uint16Array\n      ) {\n        // We outgrew a 16-bit index buffer, switch to 32-bit.\n        triangleIndices = new Uint32Array(triangleIndices);\n        triangleIndexAccessorGltf.componentType = 5125; // UNSIGNED_INT\n        triangleIndexBufferViewGltf.buffer =\n          gltf.buffers.push({\n            byteLength: triangleIndices.byteLength,\n            extras: {\n              _pipeline: {\n                source: triangleIndices.buffer,\n              },\n            },\n          }) - 1;\n        triangleIndexBufferViewGltf.byteLength = triangleIndices.byteLength;\n        triangleIndexBufferViewGltf.byteOffset = 0;\n        model._loadResources.buffers[\n          triangleIndexBufferViewGltf.buffer\n        ] = new Uint8Array(\n          triangleIndices.buffer,\n          0,\n          triangleIndices.byteLength\n        );\n\n        // The index componentType is also squirreled away in ModelLoadResources.\n        // Hackily update it, or else we'll end up creating the wrong type\n        // of index buffer later.\n        loadResources.indexBuffersToCreate._array.forEach(function (toCreate) {\n          if (toCreate.id === triangleIndexAccessorGltf.bufferView) {\n            toCreate.componentType = triangleIndexAccessorGltf.componentType;\n          }\n        });\n      }\n\n      if (unmatchableVertexIndex === i0) {\n        i0 = copy;\n        triangleIndices[i] = copy;\n      } else if (unmatchableVertexIndex === i1) {\n        i1 = copy;\n        triangleIndices[i + 1] = copy;\n      } else {\n        i2 = copy;\n        triangleIndices[i + 2] = copy;\n      }\n\n      if (defined(triangleIndexAccessorGltf.max)) {\n        triangleIndexAccessorGltf.max[0] = Math.max(\n          triangleIndexAccessorGltf.max[0],\n          copy\n        );\n      }\n\n      unmatchableVertexIndex = matchAndStoreCoordinates(\n        outlineCoordinates,\n        i0,\n        i1,\n        i2,\n        has01,\n        has12,\n        has20\n      );\n    }\n  }\n}\n\n// Each vertex has three coordinates, a, b, and c.\n// a is the coordinate that applies to edge 2-0 for the vertex.\n// b is the coordinate that applies to edge 0-1 for the vertex.\n// c is the coordinate that applies to edge 1-2 for the vertex.\n\n// A single triangle with all edges highlighted:\n//\n//                 | a | b | c |\n//                 | 1 | 1 | 0 |\n//                       0\n//                      / \\\n//                     /   \\\n//           edge 0-1 /     \\ edge 2-0\n//                   /       \\\n//                  /         \\\n// | a | b | c |   1-----------2   | a | b | c |\n// | 0 | 1 | 1 |     edge 1-2      | 1 | 0 | 1 |\n//\n// There are 6 possible orderings of coordinates a, b, and c:\n// 0 - abc\n// 1 - acb\n// 2 - bac\n// 3 - bca\n// 4 - cab\n// 5 - cba\n\n// All vertices must use the _same ordering_ for the edges to be rendered\n// correctly. So we compute a bitmask for each vertex, where the bit at\n// each position indicates whether that ordering works (i.e. doesn't\n// conflict with already-assigned coordinates) for that vertex.\n\n// Then we can find an ordering that works for all three vertices with a\n// bitwise AND.\n\nfunction computeOrderMask(outlineCoordinates, vertexIndex, a, b, c) {\n  const startIndex = vertexIndex * 3;\n  const first = outlineCoordinates[startIndex];\n  const second = outlineCoordinates[startIndex + 1];\n  const third = outlineCoordinates[startIndex + 2];\n\n  if (first === undefined) {\n    // If one coordinate is undefined, they all are, and all orderings are fine.\n    return 63; // 0b111111;\n  }\n\n  return (\n    ((first === a && second === b && third === c) << 0) +\n    ((first === a && second === c && third === b) << 1) +\n    ((first === b && second === a && third === c) << 2) +\n    ((first === b && second === c && third === a) << 3) +\n    ((first === c && second === a && third === b) << 4) +\n    ((first === c && second === b && third === a) << 5)\n  );\n}\n\n// popcount for integers 0-63, inclusive.\n// i.e. how many 1s are in the binary representation of the integer.\nfunction popcount0to63(value) {\n  return (\n    (value & 1) +\n    ((value >> 1) & 1) +\n    ((value >> 2) & 1) +\n    ((value >> 3) & 1) +\n    ((value >> 4) & 1) +\n    ((value >> 5) & 1)\n  );\n}\n\nfunction matchAndStoreCoordinates(\n  outlineCoordinates,\n  i0,\n  i1,\n  i2,\n  has01,\n  has12,\n  has20\n) {\n  const a0 = has20 ? 1.0 : 0.0;\n  const b0 = has01 ? 1.0 : 0.0;\n  const c0 = 0.0;\n\n  const i0Mask = computeOrderMask(outlineCoordinates, i0, a0, b0, c0);\n  if (i0Mask === 0) {\n    return i0;\n  }\n\n  const a1 = 0.0;\n  const b1 = has01 ? 1.0 : 0.0;\n  const c1 = has12 ? 1.0 : 0.0;\n\n  const i1Mask = computeOrderMask(outlineCoordinates, i1, a1, b1, c1);\n  if (i1Mask === 0) {\n    return i1;\n  }\n\n  const a2 = has20 ? 1.0 : 0.0;\n  const b2 = 0.0;\n  const c2 = has12 ? 1.0 : 0.0;\n\n  const i2Mask = computeOrderMask(outlineCoordinates, i2, a2, b2, c2);\n  if (i2Mask === 0) {\n    return i2;\n  }\n\n  const workingOrders = i0Mask & i1Mask & i2Mask;\n\n  let a, b, c;\n\n  if (workingOrders & (1 << 0)) {\n    // 0 - abc\n    a = 0;\n    b = 1;\n    c = 2;\n  } else if (workingOrders & (1 << 1)) {\n    // 1 - acb\n    a = 0;\n    c = 1;\n    b = 2;\n  } else if (workingOrders & (1 << 2)) {\n    // 2 - bac\n    b = 0;\n    a = 1;\n    c = 2;\n  } else if (workingOrders & (1 << 3)) {\n    // 3 - bca\n    b = 0;\n    c = 1;\n    a = 2;\n  } else if (workingOrders & (1 << 4)) {\n    // 4 - cab\n    c = 0;\n    a = 1;\n    b = 2;\n  } else if (workingOrders & (1 << 5)) {\n    // 5 - cba\n    c = 0;\n    b = 1;\n    a = 2;\n  } else {\n    // No ordering works.\n    // Report the most constrained vertex as unmatched so we copy that one.\n    const i0Popcount = popcount0to63(i0Mask);\n    const i1Popcount = popcount0to63(i1Mask);\n    const i2Popcount = popcount0to63(i2Mask);\n    if (i0Popcount < i1Popcount && i0Popcount < i2Popcount) {\n      return i0;\n    } else if (i1Popcount < i2Popcount) {\n      return i1;\n    }\n    return i2;\n  }\n\n  const i0Start = i0 * 3;\n  outlineCoordinates[i0Start + a] = a0;\n  outlineCoordinates[i0Start + b] = b0;\n  outlineCoordinates[i0Start + c] = c0;\n\n  const i1Start = i1 * 3;\n  outlineCoordinates[i1Start + a] = a1;\n  outlineCoordinates[i1Start + b] = b1;\n  outlineCoordinates[i1Start + c] = c1;\n\n  const i2Start = i2 * 3;\n  outlineCoordinates[i2Start + a] = a2;\n  outlineCoordinates[i2Start + b] = b2;\n  outlineCoordinates[i2Start + c] = c2;\n\n  return -1;\n}\n\nfunction isHighlighted(edges, i0, i1) {\n  const edgeSmallMultiplier = edges[0];\n  const index = Math.min(i0, i1) * edgeSmallMultiplier + Math.max(i0, i1);\n\n  // If i0 and i1 are both 0, then our index will be 0 and we'll end up\n  // accessing the edgeSmallMultiplier that we've sneakily squirreled away\n  // in index 0. But it makes no sense to have an edge between vertex 0 and\n  // itself, so for any edgeSmallMultiplier other than 1 we'll return the\n  // correct answer: false. If edgeSmallMultiplier is 1, that means there is\n  // only a single vertex, so no danger of forming a meaningful triangle\n  // with that.\n  return edges[index] === 1;\n}\n\nfunction createTexture(size) {\n  const texture = new Uint8Array(size);\n  texture[size - 1] = 192;\n  if (size === 8) {\n    texture[size - 1] = 96;\n  } else if (size === 4) {\n    texture[size - 1] = 48;\n  } else if (size === 2) {\n    texture[size - 1] = 24;\n  } else if (size === 1) {\n    texture[size - 1] = 12;\n  }\n  return texture;\n}\n\nfunction updateBufferViewsWithNewVertices(model, bufferViews) {\n  const gltf = model.gltfInternal;\n  const loadResources = model._loadResources;\n\n  let i, j;\n  for (i = 0; i < bufferViews.length; ++i) {\n    const bufferView = bufferViews[i];\n    const vertexNumberingScope =\n      bufferView.extras._pipeline.vertexNumberingScope;\n\n    // Let the temporary data be garbage collected.\n    bufferView.extras._pipeline.vertexNumberingScope = undefined;\n\n    const newVertices = vertexNumberingScope.extraVertices;\n\n    const sourceData = loadResources.getBuffer(bufferView);\n    const byteStride = bufferView.byteStride || 4;\n    const newVerticesLength = newVertices.length;\n    const destData = new Uint8Array(\n      sourceData.byteLength + newVerticesLength * byteStride\n    );\n\n    // Copy the original vertices\n    destData.set(sourceData);\n\n    // Copy the vertices added for outlining\n    for (j = 0; j < newVerticesLength; ++j) {\n      const sourceIndex = newVertices[j] * byteStride;\n      const destIndex = sourceData.length + j * byteStride;\n      for (let k = 0; k < byteStride; ++k) {\n        destData[destIndex + k] = destData[sourceIndex + k];\n      }\n    }\n\n    // This bufferView is an independent buffer now. Update the model accordingly.\n    bufferView.byteOffset = 0;\n    bufferView.byteLength = destData.byteLength;\n\n    const bufferId =\n      gltf.buffers.push({\n        byteLength: destData.byteLength,\n        extras: {\n          _pipeline: {\n            source: destData.buffer,\n          },\n        },\n      }) - 1;\n\n    bufferView.buffer = bufferId;\n    loadResources.buffers[bufferId] = destData;\n\n    // Update the accessors to reflect the added vertices.\n    const accessors = vertexNumberingScope.accessors;\n    for (j = 0; j < accessors.length; ++j) {\n      const accessorId = accessors[j];\n      gltf.accessors[accessorId].count += newVerticesLength;\n    }\n\n    if (!vertexNumberingScope.createdOutlines) {\n      // Create the buffers, views, and accessors for the outline texture coordinates.\n      const outlineCoordinates = vertexNumberingScope.outlineCoordinates;\n      const outlineCoordinateBuffer = new Float32Array(outlineCoordinates);\n      const bufferIndex =\n        model.gltfInternal.buffers.push({\n          byteLength: outlineCoordinateBuffer.byteLength,\n          extras: {\n            _pipeline: {\n              source: outlineCoordinateBuffer.buffer,\n            },\n          },\n        }) - 1;\n      loadResources.buffers[bufferIndex] = new Uint8Array(\n        outlineCoordinateBuffer.buffer,\n        0,\n        outlineCoordinateBuffer.byteLength\n      );\n\n      const bufferViewIndex =\n        model.gltfInternal.bufferViews.push({\n          buffer: bufferIndex,\n          byteLength: outlineCoordinateBuffer.byteLength,\n          byteOffset: 0,\n          byteStride: 3 * Float32Array.BYTES_PER_ELEMENT,\n          target: 34962,\n        }) - 1;\n\n      const accessorIndex =\n        model.gltfInternal.accessors.push({\n          bufferView: bufferViewIndex,\n          byteOffset: 0,\n          componentType: 5126,\n          count: outlineCoordinateBuffer.length / 3,\n          type: \"VEC3\",\n          min: [0.0, 0.0, 0.0],\n          max: [1.0, 1.0, 1.0],\n        }) - 1;\n\n      const primitives = vertexNumberingScope.primitives;\n      for (j = 0; j < primitives.length; ++j) {\n        primitives[j].attributes._OUTLINE_COORDINATES = accessorIndex;\n      }\n\n      loadResources.vertexBuffersToCreate.enqueue(bufferViewIndex);\n\n      vertexNumberingScope.createdOutlines = true;\n    }\n  }\n}\n\nfunction compactBuffers(model) {\n  const gltf = model.gltfInternal;\n  const loadResources = model._loadResources;\n\n  let i;\n  for (i = 0; i < gltf.buffers.length; ++i) {\n    const buffer = gltf.buffers[i];\n    const bufferViewsUsingThisBuffer = gltf.bufferViews.filter(\n      usesBuffer.bind(undefined, i)\n    );\n    const newLength = bufferViewsUsingThisBuffer.reduce(function (\n      previous,\n      current\n    ) {\n      return previous + current.byteLength;\n    },\n    0);\n    if (newLength === buffer.byteLength) {\n      continue;\n    }\n\n    const newBuffer = new Uint8Array(newLength);\n    let offset = 0;\n    for (let j = 0; j < bufferViewsUsingThisBuffer.length; ++j) {\n      const bufferView = bufferViewsUsingThisBuffer[j];\n      const sourceData = loadResources.getBuffer(bufferView);\n      newBuffer.set(sourceData, offset);\n\n      bufferView.byteOffset = offset;\n      offset += sourceData.byteLength;\n    }\n\n    loadResources.buffers[i] = newBuffer;\n    buffer.extras._pipeline.source = newBuffer.buffer;\n    buffer.byteLength = newLength;\n  }\n}\n\nfunction usesBuffer(bufferId, bufferView) {\n  return bufferView.buffer === bufferId;\n}\n\nfunction getVertexNumberingScope(model, primitive) {\n  const attributes = primitive.attributes;\n  if (attributes === undefined) {\n    return undefined;\n  }\n\n  const gltf = model.gltfInternal;\n\n  let vertexNumberingScope;\n\n  // Initialize common details for all bufferViews used by this primitive's vertices.\n  // All bufferViews used by this primitive must use a common vertex numbering scheme.\n  for (const semantic in attributes) {\n    if (!attributes.hasOwnProperty(semantic)) {\n      continue;\n    }\n\n    const accessorId = attributes[semantic];\n    const accessor = gltf.accessors[accessorId];\n    const bufferViewId = accessor.bufferView;\n    const bufferView = gltf.bufferViews[bufferViewId];\n\n    if (!defined(bufferView.extras)) {\n      bufferView.extras = {};\n    }\n    if (!defined(bufferView.extras._pipeline)) {\n      bufferView.extras._pipeline = {};\n    }\n\n    if (!defined(bufferView.extras._pipeline.vertexNumberingScope)) {\n      bufferView.extras._pipeline.vertexNumberingScope = vertexNumberingScope || {\n        // Each element in this array is:\n        // a) undefined, if the vertex at this index has no copies\n        // b) the index of the copy.\n        vertexCopies: [],\n\n        // Extra vertices appended after the ones originally included in the model.\n        // Each element is the index of the vertex that this one is a copy of.\n        extraVertices: [],\n\n        // The texture coordinates used for outlining, three floats per vertex.\n        outlineCoordinates: [],\n\n        // The IDs of accessors that use this vertex numbering.\n        accessors: [],\n\n        // The IDs of bufferViews that use this vertex numbering.\n        bufferViews: [],\n\n        // The primitives that use this vertex numbering.\n        primitives: [],\n\n        // True if the buffer for the outlines has already been created.\n        createdOutlines: false,\n      };\n    } else if (\n      vertexNumberingScope !== undefined &&\n      bufferView.extras._pipeline.vertexNumberingScope !== vertexNumberingScope\n    ) {\n      // Conflicting vertex numbering, let's give up.\n      return undefined;\n    }\n\n    vertexNumberingScope = bufferView.extras._pipeline.vertexNumberingScope;\n\n    if (vertexNumberingScope.bufferViews.indexOf(bufferView) < 0) {\n      vertexNumberingScope.bufferViews.push(bufferView);\n    }\n\n    if (vertexNumberingScope.accessors.indexOf(accessorId) < 0) {\n      vertexNumberingScope.accessors.push(accessorId);\n    }\n  }\n\n  vertexNumberingScope.primitives.push(primitive);\n\n  return vertexNumberingScope;\n}\n\nexport default ModelOutlineLoader;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport addToArray from \"./GltfPipeline/addToArray.js\";\nimport ForEach from \"./GltfPipeline/ForEach.js\";\nimport usesExtension from \"./GltfPipeline/usesExtension.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Axis from \"./Axis.js\";\n\n/**\n * @private\n */\nconst ModelUtility = {};\n\n/**\n * Updates the model's forward axis if the model is not a 2.0 model.\n *\n * @param {Object} model The model to update.\n */\nModelUtility.updateForwardAxis = function (model) {\n  const cachedSourceVersion = model.gltfInternal.extras.sourceVersion;\n\n  if (\n    (defined(cachedSourceVersion) && cachedSourceVersion !== \"2.0\") ||\n    ModelUtility.getAssetVersion(model.gltfInternal) !== \"2.0\"\n  ) {\n    model._gltfForwardAxis = Axis.X;\n  }\n};\n\n/**\n *  Gets the string representing the glTF asset version.\n *\n *  @param {Object} gltf A javascript object containing a glTF asset.\n *  @returns {String} The glTF asset version string.\n */\nModelUtility.getAssetVersion = function (gltf) {\n  // In glTF 1.0 it was valid to omit the version number.\n  if (!defined(gltf.asset) || !defined(gltf.asset.version)) {\n    return \"1.0\";\n  }\n\n  return gltf.asset.version;\n};\n\n/**\n * Splits primitive materials with values incompatible for generating techniques.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset with modified materials.\n */\nModelUtility.splitIncompatibleMaterials = function (gltf) {\n  const accessors = gltf.accessors;\n  const materials = gltf.materials;\n  const primitiveInfoByMaterial = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      let materialIndex = primitive.material;\n      const material = materials[materialIndex];\n\n      const jointAccessorId = primitive.attributes.JOINTS_0;\n      let componentType;\n      let accessorType;\n      if (defined(jointAccessorId)) {\n        const jointAccessor = accessors[jointAccessorId];\n        componentType = jointAccessor.componentType;\n        accessorType = jointAccessor.type;\n      }\n      const isSkinned = defined(jointAccessorId) && accessorType === \"VEC4\";\n      const hasVertexColors = defined(primitive.attributes.COLOR_0);\n      const hasMorphTargets = defined(primitive.targets);\n      const hasNormals = defined(primitive.attributes.NORMAL);\n      const hasTangents = defined(primitive.attributes.TANGENT);\n      const hasTexCoords = defined(primitive.attributes.TEXCOORD_0);\n      const hasTexCoord1 =\n        hasTexCoords && defined(primitive.attributes.TEXCOORD_1);\n      const hasOutline =\n        defined(primitive.extensions) &&\n        defined(primitive.extensions.CESIUM_primitive_outline);\n\n      const primitiveInfo = primitiveInfoByMaterial[materialIndex];\n      if (!defined(primitiveInfo)) {\n        primitiveInfoByMaterial[materialIndex] = {\n          skinning: {\n            skinned: isSkinned,\n            componentType: componentType,\n          },\n          hasVertexColors: hasVertexColors,\n          hasMorphTargets: hasMorphTargets,\n          hasNormals: hasNormals,\n          hasTangents: hasTangents,\n          hasTexCoords: hasTexCoords,\n          hasTexCoord1: hasTexCoord1,\n          hasOutline: hasOutline,\n        };\n      } else if (\n        primitiveInfo.skinning.skinned !== isSkinned ||\n        primitiveInfo.hasVertexColors !== hasVertexColors ||\n        primitiveInfo.hasMorphTargets !== hasMorphTargets ||\n        primitiveInfo.hasNormals !== hasNormals ||\n        primitiveInfo.hasTangents !== hasTangents ||\n        primitiveInfo.hasTexCoords !== hasTexCoords ||\n        primitiveInfo.hasTexCoord1 !== hasTexCoord1 ||\n        primitiveInfo.hasOutline !== hasOutline\n      ) {\n        // This primitive uses the same material as another one that either:\n        // * Isn't skinned\n        // * Uses a different type to store joints and weights\n        // * Doesn't have vertex colors, morph targets, normals, tangents, or texCoords\n        // * Doesn't have a CESIUM_primitive_outline extension.\n        const clonedMaterial = clone(material, true);\n        // Split this off as a separate material\n        materialIndex = addToArray(materials, clonedMaterial);\n        primitive.material = materialIndex;\n        primitiveInfoByMaterial[materialIndex] = {\n          skinning: {\n            skinned: isSkinned,\n            componentType: componentType,\n          },\n          hasVertexColors: hasVertexColors,\n          hasMorphTargets: hasMorphTargets,\n          hasNormals: hasNormals,\n          hasTangents: hasTangents,\n          hasTexCoords: hasTexCoords,\n          hasTexCoord1: hasTexCoord1,\n          hasOutline: hasOutline,\n        };\n      }\n    });\n  });\n\n  return primitiveInfoByMaterial;\n};\n\nModelUtility.getShaderVariable = function (type) {\n  if (type === \"SCALAR\") {\n    return \"float\";\n  }\n  return type.toLowerCase();\n};\n\nModelUtility.ModelState = {\n  NEEDS_LOAD: 0,\n  LOADING: 1,\n  LOADED: 2, // Renderable, but textures can still be pending when incrementallyLoadTextures is true.\n  FAILED: 3,\n};\n\nModelUtility.getFailedLoadFunction = function (model, type, path) {\n  return function (error) {\n    model._state = ModelUtility.ModelState.FAILED;\n    let message = `Failed to load ${type}: ${path}`;\n    if (defined(error)) {\n      message += `\\n${error.message}`;\n    }\n    model._readyPromise.reject(new RuntimeError(message));\n  };\n};\n\nModelUtility.parseBuffers = function (model, bufferLoad) {\n  const loadResources = model._loadResources;\n\n  ForEach.buffer(model.gltfInternal, function (buffer, bufferViewId) {\n    if (defined(buffer.extras._pipeline.source)) {\n      loadResources.buffers[bufferViewId] = buffer.extras._pipeline.source;\n    } else if (defined(bufferLoad)) {\n      const bufferResource = model._resource.getDerivedResource({\n        url: buffer.uri,\n      });\n      ++loadResources.pendingBufferLoads;\n      bufferResource\n        .fetchArrayBuffer()\n        .then(bufferLoad(model, bufferViewId))\n        .catch(\n          ModelUtility.getFailedLoadFunction(\n            model,\n            \"buffer\",\n            bufferResource.url\n          )\n        );\n    }\n  });\n};\n\nconst aMinScratch = new Cartesian3();\nconst aMaxScratch = new Cartesian3();\n\nModelUtility.computeBoundingSphere = function (model) {\n  const gltf = model.gltfInternal;\n  const gltfNodes = gltf.nodes;\n  const gltfMeshes = gltf.meshes;\n  const rootNodes = gltf.scenes[gltf.scene].nodes;\n  const rootNodesLength = rootNodes.length;\n\n  const nodeStack = [];\n\n  const min = new Cartesian3(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE\n  );\n  const max = new Cartesian3(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE\n  );\n\n  for (let i = 0; i < rootNodesLength; ++i) {\n    let n = gltfNodes[rootNodes[i]];\n    n._transformToRoot = ModelUtility.getTransform(n);\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      const transformToRoot = n._transformToRoot;\n\n      const meshId = n.mesh;\n      if (defined(meshId)) {\n        const mesh = gltfMeshes[meshId];\n        const primitives = mesh.primitives;\n        const primitivesLength = primitives.length;\n        for (let m = 0; m < primitivesLength; ++m) {\n          const positionAccessor = primitives[m].attributes.POSITION;\n          if (defined(positionAccessor)) {\n            const minMax = ModelUtility.getAccessorMinMax(\n              gltf,\n              positionAccessor\n            );\n            if (defined(minMax.min) && defined(minMax.max)) {\n              const aMin = Cartesian3.fromArray(minMax.min, 0, aMinScratch);\n              const aMax = Cartesian3.fromArray(minMax.max, 0, aMaxScratch);\n\n              Matrix4.multiplyByPoint(transformToRoot, aMin, aMin);\n              Matrix4.multiplyByPoint(transformToRoot, aMax, aMax);\n              Cartesian3.minimumByComponent(min, aMin, min);\n              Cartesian3.maximumByComponent(max, aMax, max);\n            }\n          }\n        }\n      }\n\n      const children = n.children;\n      if (defined(children)) {\n        const childrenLength = children.length;\n        for (let k = 0; k < childrenLength; ++k) {\n          const child = gltfNodes[children[k]];\n          child._transformToRoot = ModelUtility.getTransform(child);\n          Matrix4.multiplyTransformation(\n            transformToRoot,\n            child._transformToRoot,\n            child._transformToRoot\n          );\n          nodeStack.push(child);\n        }\n      }\n      delete n._transformToRoot;\n    }\n  }\n\n  const boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n  if (model.forwardAxis === Axis.Z) {\n    // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n    BoundingSphere.transformWithoutScale(\n      boundingSphere,\n      Axis.Z_UP_TO_X_UP,\n      boundingSphere\n    );\n  }\n  if (model._upAxis === Axis.Y) {\n    BoundingSphere.transformWithoutScale(\n      boundingSphere,\n      Axis.Y_UP_TO_Z_UP,\n      boundingSphere\n    );\n  } else if (model._upAxis === Axis.X) {\n    BoundingSphere.transformWithoutScale(\n      boundingSphere,\n      Axis.X_UP_TO_Z_UP,\n      boundingSphere\n    );\n  }\n  return boundingSphere;\n};\n\nfunction techniqueAttributeForSemantic(technique, semantic) {\n  return ForEach.techniqueAttribute(technique, function (\n    attribute,\n    attributeName\n  ) {\n    if (attribute.semantic === semantic) {\n      return attributeName;\n    }\n  });\n}\n\nfunction ensureSemanticExistenceForPrimitive(gltf, primitive) {\n  const accessors = gltf.accessors;\n  const materials = gltf.materials;\n  const techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n\n  const techniques = techniquesWebgl.techniques;\n  const programs = techniquesWebgl.programs;\n  const shaders = techniquesWebgl.shaders;\n  const targets = primitive.targets;\n\n  const attributes = primitive.attributes;\n  for (const target in targets) {\n    if (targets.hasOwnProperty(target)) {\n      const targetAttributes = targets[target];\n      for (const attribute in targetAttributes) {\n        if (attribute !== \"extras\") {\n          attributes[`${attribute}_${target}`] = targetAttributes[attribute];\n        }\n      }\n    }\n  }\n\n  const material = materials[primitive.material];\n  const technique =\n    techniques[material.extensions.KHR_techniques_webgl.technique];\n  const program = programs[technique.program];\n  const vertexShader = shaders[program.vertexShader];\n\n  for (const semantic in attributes) {\n    if (attributes.hasOwnProperty(semantic)) {\n      if (!defined(techniqueAttributeForSemantic(technique, semantic))) {\n        const accessorId = attributes[semantic];\n        const accessor = accessors[accessorId];\n        let lowerCase = semantic.toLowerCase();\n        if (lowerCase.charAt(0) === \"_\") {\n          lowerCase = lowerCase.slice(1);\n        }\n        const attributeName = `a_${lowerCase}`;\n        technique.attributes[attributeName] = {\n          semantic: semantic,\n          type: accessor.componentType,\n        };\n        const pipelineExtras = vertexShader.extras._pipeline;\n        let shaderText = pipelineExtras.source;\n        shaderText = `attribute ${ModelUtility.getShaderVariable(\n          accessor.type\n        )} ${attributeName};\\n${shaderText}`;\n        pipelineExtras.source = shaderText;\n      }\n    }\n  }\n}\n\n/**\n * Ensures all attributes present on the primitive are present in the technique and\n * vertex shader.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset, including any additional attributes.\n */\nModelUtility.ensureSemanticExistence = function (gltf) {\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ensureSemanticExistenceForPrimitive(gltf, primitive);\n    });\n  });\n\n  return gltf;\n};\n\n/**\n * Creates attribute location for all attributes required by a technique.\n *\n * @param {Object} technique A glTF KHR_techniques_webgl technique object.\n * @param {Object} precreatedAttributes A dictionary object of pre-created attributes for which to also create locations.\n * @returns {Object} A dictionary object containing attribute names and their locations.\n */\nModelUtility.createAttributeLocations = function (\n  technique,\n  precreatedAttributes\n) {\n  const attributeLocations = {};\n  let hasIndex0 = false;\n  let i = 1;\n\n  ForEach.techniqueAttribute(technique, function (attribute, attributeName) {\n    // Set the position attribute to the 0th index. In some WebGL implementations the shader\n    // will not work correctly if the 0th attribute is not active. For example, some glTF models\n    // list the normal attribute first but derived shaders like the cast-shadows shader do not use\n    // the normal attribute.\n    if (/pos/i.test(attributeName) && !hasIndex0) {\n      attributeLocations[attributeName] = 0;\n      hasIndex0 = true;\n    } else {\n      attributeLocations[attributeName] = i++;\n    }\n  });\n\n  if (defined(precreatedAttributes)) {\n    for (const attributeName in precreatedAttributes) {\n      if (precreatedAttributes.hasOwnProperty(attributeName)) {\n        attributeLocations[attributeName] = i++;\n      }\n    }\n  }\n\n  return attributeLocations;\n};\n\nModelUtility.getAccessorMinMax = function (gltf, accessorId) {\n  const accessor = gltf.accessors[accessorId];\n  const extensions = accessor.extensions;\n  let accessorMin = accessor.min;\n  let accessorMax = accessor.max;\n  // If this accessor is quantized, we should use the decoded min and max\n  if (defined(extensions)) {\n    const quantizedAttributes = extensions.WEB3D_quantized_attributes;\n    if (defined(quantizedAttributes)) {\n      accessorMin = quantizedAttributes.decodedMin;\n      accessorMax = quantizedAttributes.decodedMax;\n    }\n  }\n  return {\n    min: accessorMin,\n    max: accessorMax,\n  };\n};\n\nfunction getTechniqueAttributeOrUniformFunction(\n  gltf,\n  technique,\n  semantic,\n  ignoreNodes\n) {\n  if (usesExtension(gltf, \"KHR_techniques_webgl\")) {\n    return function (attributeOrUniform, attributeOrUniformName) {\n      if (\n        attributeOrUniform.semantic === semantic &&\n        (!ignoreNodes || !defined(attributeOrUniform.node))\n      ) {\n        return attributeOrUniformName;\n      }\n    };\n  }\n\n  return function (parameterName, attributeOrUniformName) {\n    const attributeOrUniform = technique.parameters[parameterName];\n    if (\n      attributeOrUniform.semantic === semantic &&\n      (!ignoreNodes || !defined(attributeOrUniform.node))\n    ) {\n      return attributeOrUniformName;\n    }\n  };\n}\n\nModelUtility.getAttributeOrUniformBySemantic = function (\n  gltf,\n  semantic,\n  programId,\n  ignoreNodes\n) {\n  return ForEach.technique(gltf, function (technique) {\n    if (defined(programId) && technique.program !== programId) {\n      return;\n    }\n\n    const value = ForEach.techniqueAttribute(\n      technique,\n      getTechniqueAttributeOrUniformFunction(\n        gltf,\n        technique,\n        semantic,\n        ignoreNodes\n      )\n    );\n\n    if (defined(value)) {\n      return value;\n    }\n\n    return ForEach.techniqueUniform(\n      technique,\n      getTechniqueAttributeOrUniformFunction(\n        gltf,\n        technique,\n        semantic,\n        ignoreNodes\n      )\n    );\n  });\n};\n\nModelUtility.getDiffuseAttributeOrUniform = function (gltf, programId) {\n  let diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(\n    gltf,\n    \"COLOR_0\",\n    programId\n  );\n  if (!defined(diffuseUniformName)) {\n    diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(\n      gltf,\n      \"_3DTILESDIFFUSE\",\n      programId\n    );\n  }\n  return diffuseUniformName;\n};\n\nconst nodeTranslationScratch = new Cartesian3();\nconst nodeQuaternionScratch = new Quaternion();\nconst nodeScaleScratch = new Cartesian3();\n\nModelUtility.getTransform = function (node, result) {\n  if (defined(node.matrix)) {\n    return Matrix4.fromColumnMajorArray(node.matrix, result);\n  }\n\n  return Matrix4.fromTranslationQuaternionRotationScale(\n    Cartesian3.fromArray(node.translation, 0, nodeTranslationScratch),\n    Quaternion.unpack(node.rotation, 0, nodeQuaternionScratch),\n    Cartesian3.fromArray(node.scale, 0, nodeScaleScratch),\n    result\n  );\n};\n\nModelUtility.getUsedExtensions = function (gltf) {\n  const extensionsUsed = gltf.extensionsUsed;\n  const cachedExtensionsUsed = {};\n\n  if (defined(extensionsUsed)) {\n    const extensionsUsedLength = extensionsUsed.length;\n    for (let i = 0; i < extensionsUsedLength; i++) {\n      const extension = extensionsUsed[i];\n      cachedExtensionsUsed[extension] = true;\n    }\n  }\n  return cachedExtensionsUsed;\n};\n\nModelUtility.getRequiredExtensions = function (gltf) {\n  const extensionsRequired = gltf.extensionsRequired;\n  const cachedExtensionsRequired = {};\n\n  if (defined(extensionsRequired)) {\n    const extensionsRequiredLength = extensionsRequired.length;\n    for (let i = 0; i < extensionsRequiredLength; i++) {\n      const extension = extensionsRequired[i];\n      cachedExtensionsRequired[extension] = true;\n    }\n  }\n\n  return cachedExtensionsRequired;\n};\n\nModelUtility.supportedExtensions = {\n  AGI_articulations: true,\n  CESIUM_RTC: true,\n  EXT_texture_webp: true,\n  KHR_blend: true,\n  KHR_binary_glTF: true,\n  KHR_texture_basisu: true,\n  KHR_draco_mesh_compression: true,\n  KHR_materials_common: true,\n  KHR_techniques_webgl: true,\n  KHR_materials_unlit: true,\n  KHR_materials_pbrSpecularGlossiness: true,\n  KHR_texture_transform: true,\n  WEB3D_quantized_attributes: true,\n};\n\nModelUtility.checkSupportedExtensions = function (\n  extensionsRequired,\n  browserSupportsWebp\n) {\n  for (const extension in extensionsRequired) {\n    if (extensionsRequired.hasOwnProperty(extension)) {\n      if (!ModelUtility.supportedExtensions[extension]) {\n        throw new RuntimeError(`Unsupported glTF Extension: ${extension}`);\n      }\n\n      if (extension === \"EXT_texture_webp\" && browserSupportsWebp === false) {\n        throw new RuntimeError(\n          \"Loaded model requires WebP but browser does not support it.\"\n        );\n      }\n    }\n  }\n};\n\nModelUtility.checkSupportedGlExtensions = function (extensionsUsed, context) {\n  if (defined(extensionsUsed)) {\n    const glExtensionsUsedLength = extensionsUsed.length;\n    for (let i = 0; i < glExtensionsUsedLength; i++) {\n      const extension = extensionsUsed[i];\n      if (extension !== \"OES_element_index_uint\") {\n        throw new RuntimeError(`Unsupported WebGL Extension: ${extension}`);\n      } else if (!context.elementIndexUint) {\n        throw new RuntimeError(\n          \"OES_element_index_uint WebGL extension is not enabled.\"\n        );\n      }\n    }\n  }\n};\n\nfunction replaceAllButFirstInString(string, find, replace) {\n  // Limit search to strings that are not a subset of other tokens.\n  find += \"(?!\\\\w)\";\n  find = new RegExp(find, \"g\");\n\n  const index = string.search(find);\n  return string.replace(find, function (match, offset) {\n    return index === offset ? match : replace;\n  });\n}\n\nfunction getQuantizedAttributes(gltf, accessorId) {\n  const accessor = gltf.accessors[accessorId];\n  const extensions = accessor.extensions;\n  if (defined(extensions)) {\n    return extensions.WEB3D_quantized_attributes;\n  }\n  return undefined;\n}\n\nfunction getAttributeVariableName(gltf, primitive, attributeSemantic) {\n  const materialId = primitive.material;\n  const material = gltf.materials[materialId];\n\n  if (\n    !usesExtension(gltf, \"KHR_techniques_webgl\") ||\n    !defined(material.extensions) ||\n    !defined(material.extensions.KHR_techniques_webgl)\n  ) {\n    return;\n  }\n\n  const techniqueId = material.extensions.KHR_techniques_webgl.technique;\n  const techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n  const technique = techniquesWebgl.techniques[techniqueId];\n  return ForEach.techniqueAttribute(technique, function (\n    attribute,\n    attributeName\n  ) {\n    const semantic = attribute.semantic;\n    if (semantic === attributeSemantic) {\n      return attributeName;\n    }\n  });\n}\n\nModelUtility.modifyShaderForDracoQuantizedAttributes = function (\n  gltf,\n  primitive,\n  shader,\n  decodedAttributes\n) {\n  const quantizedUniforms = {};\n  for (let attributeSemantic in decodedAttributes) {\n    if (decodedAttributes.hasOwnProperty(attributeSemantic)) {\n      const attribute = decodedAttributes[attributeSemantic];\n      const quantization = attribute.quantization;\n      if (!defined(quantization)) {\n        continue;\n      }\n\n      const attributeVarName = getAttributeVariableName(\n        gltf,\n        primitive,\n        attributeSemantic\n      );\n\n      if (attributeSemantic.charAt(0) === \"_\") {\n        attributeSemantic = attributeSemantic.substring(1);\n      }\n      const decodeUniformVarName = `gltf_u_dec_${attributeSemantic.toLowerCase()}`;\n\n      if (!defined(quantizedUniforms[decodeUniformVarName])) {\n        const newMain = `gltf_decoded_${attributeSemantic}`;\n        const decodedAttributeVarName = attributeVarName.replace(\n          \"a_\",\n          \"gltf_a_dec_\"\n        );\n        const size = attribute.componentsPerAttribute;\n\n        // replace usages of the original attribute with the decoded version, but not the declaration\n        shader = replaceAllButFirstInString(\n          shader,\n          attributeVarName,\n          decodedAttributeVarName\n        );\n\n        // declare decoded attribute\n        let variableType;\n        if (quantization.octEncoded) {\n          variableType = \"vec3\";\n        } else if (size > 1) {\n          variableType = `vec${size}`;\n        } else {\n          variableType = \"float\";\n        }\n        shader = `${variableType} ${decodedAttributeVarName};\\n${shader}`;\n\n        // The gltf 2.0 COLOR_0 vertex attribute can be VEC4 or VEC3\n        const vec3Color = size === 3 && attributeSemantic === \"COLOR_0\";\n        if (vec3Color) {\n          shader = replaceAllButFirstInString(\n            shader,\n            decodedAttributeVarName,\n            `vec4(${decodedAttributeVarName}, 1.0)`\n          );\n        }\n\n        // splice decode function into the shader\n        let decode = \"\";\n        if (quantization.octEncoded) {\n          const decodeUniformVarNameRangeConstant = `${decodeUniformVarName}_rangeConstant`;\n          shader = `uniform float ${decodeUniformVarNameRangeConstant};\\n${shader}`;\n          decode =\n            `${\n              \"\\n\" +\n              \"void main() {\\n\" +\n              // Draco oct-encoding decodes to zxy order\n              \"    \"\n            }${decodedAttributeVarName} = czm_octDecode(${attributeVarName}.xy, ${decodeUniformVarNameRangeConstant}).zxy;\\n` +\n            `    ${newMain}();\\n` +\n            `}\\n`;\n        } else {\n          const decodeUniformVarNameNormConstant = `${decodeUniformVarName}_normConstant`;\n          const decodeUniformVarNameMin = `${decodeUniformVarName}_min`;\n          shader =\n            `uniform float ${decodeUniformVarNameNormConstant};\\n` +\n            `uniform ${variableType} ${decodeUniformVarNameMin};\\n${shader}`;\n          const attributeVarAccess = vec3Color ? \".xyz\" : \"\";\n          decode =\n            `${\n              \"\\n\" + \"void main() {\\n\" + \"    \"\n            }${decodedAttributeVarName} = ${decodeUniformVarNameMin} + ${attributeVarName}${attributeVarAccess} * ${decodeUniformVarNameNormConstant};\\n` +\n            `    ${newMain}();\\n` +\n            `}\\n`;\n        }\n\n        shader = ShaderSource.replaceMain(shader, newMain);\n        shader += decode;\n      }\n    }\n  }\n  return {\n    shader: shader,\n  };\n};\n\nModelUtility.modifyShaderForQuantizedAttributes = function (\n  gltf,\n  primitive,\n  shader\n) {\n  const quantizedUniforms = {};\n  const attributes = primitive.attributes;\n  for (let attributeSemantic in attributes) {\n    if (attributes.hasOwnProperty(attributeSemantic)) {\n      const attributeVarName = getAttributeVariableName(\n        gltf,\n        primitive,\n        attributeSemantic\n      );\n      const accessorId = primitive.attributes[attributeSemantic];\n\n      if (attributeSemantic.charAt(0) === \"_\") {\n        attributeSemantic = attributeSemantic.substring(1);\n      }\n      const decodeUniformVarName = `gltf_u_dec_${attributeSemantic.toLowerCase()}`;\n\n      const decodeUniformVarNameScale = `${decodeUniformVarName}_scale`;\n      const decodeUniformVarNameTranslate = `${decodeUniformVarName}_translate`;\n      if (\n        !defined(quantizedUniforms[decodeUniformVarName]) &&\n        !defined(quantizedUniforms[decodeUniformVarNameScale])\n      ) {\n        const quantizedAttributes = getQuantizedAttributes(gltf, accessorId);\n        if (defined(quantizedAttributes)) {\n          const decodeMatrix = quantizedAttributes.decodeMatrix;\n          const newMain = `gltf_decoded_${attributeSemantic}`;\n          const decodedAttributeVarName = attributeVarName.replace(\n            \"a_\",\n            \"gltf_a_dec_\"\n          );\n          const size = Math.floor(Math.sqrt(decodeMatrix.length));\n\n          // replace usages of the original attribute with the decoded version, but not the declaration\n          shader = replaceAllButFirstInString(\n            shader,\n            attributeVarName,\n            decodedAttributeVarName\n          );\n          // declare decoded attribute\n          let variableType;\n          if (size > 2) {\n            variableType = `vec${size - 1}`;\n          } else {\n            variableType = \"float\";\n          }\n          shader = `${variableType} ${decodedAttributeVarName};\\n${shader}`;\n          // splice decode function into the shader - attributes are pre-multiplied with the decode matrix\n          // uniform in the shader (32-bit floating point)\n          let decode = \"\";\n          if (size === 5) {\n            // separate scale and translate since glsl doesn't have mat5\n            shader = `uniform mat4 ${decodeUniformVarNameScale};\\n${shader}`;\n            shader = `uniform vec4 ${decodeUniformVarNameTranslate};\\n${shader}`;\n            decode =\n              `${\n                \"\\n\" + \"void main() {\\n\" + \"    \"\n              }${decodedAttributeVarName} = ${decodeUniformVarNameScale} * ${attributeVarName} + ${decodeUniformVarNameTranslate};\\n` +\n              `    ${newMain}();\\n` +\n              `}\\n`;\n\n            quantizedUniforms[decodeUniformVarNameScale] = { mat: 4 };\n            quantizedUniforms[decodeUniformVarNameTranslate] = { vec: 4 };\n          } else {\n            shader = `uniform mat${size} ${decodeUniformVarName};\\n${shader}`;\n            decode =\n              `${\n                \"\\n\" + \"void main() {\\n\" + \"    \"\n              }${decodedAttributeVarName} = ${variableType}(${decodeUniformVarName} * vec${size}(${attributeVarName},1.0));\\n` +\n              `    ${newMain}();\\n` +\n              `}\\n`;\n\n            quantizedUniforms[decodeUniformVarName] = { mat: size };\n          }\n          shader = ShaderSource.replaceMain(shader, newMain);\n          shader += decode;\n        }\n      }\n    }\n  }\n  return {\n    shader: shader,\n    uniforms: quantizedUniforms,\n  };\n};\n\nfunction getScalarUniformFunction(value) {\n  const that = {\n    value: value,\n    clone: function (source, result) {\n      return source;\n    },\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getVec2UniformFunction(value) {\n  const that = {\n    value: Cartesian2.fromArray(value),\n    clone: Cartesian2.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getVec3UniformFunction(value) {\n  const that = {\n    value: Cartesian3.fromArray(value),\n    clone: Cartesian3.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getVec4UniformFunction(value) {\n  const that = {\n    value: Cartesian4.fromArray(value),\n    clone: Cartesian4.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getMat2UniformFunction(value) {\n  const that = {\n    value: Matrix2.fromColumnMajorArray(value),\n    clone: Matrix2.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getMat3UniformFunction(value) {\n  const that = {\n    value: Matrix3.fromColumnMajorArray(value),\n    clone: Matrix3.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getMat4UniformFunction(value) {\n  const that = {\n    value: Matrix4.fromColumnMajorArray(value),\n    clone: Matrix4.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction DelayLoadedTextureUniform(value, textures, defaultTexture) {\n  this._value = undefined;\n  this._textureId = value.index;\n  this._textures = textures;\n  this._defaultTexture = defaultTexture;\n}\n\nObject.defineProperties(DelayLoadedTextureUniform.prototype, {\n  value: {\n    get: function () {\n      // Use the default texture (1x1 white) until the model's texture is loaded\n      if (!defined(this._value)) {\n        const texture = this._textures[this._textureId];\n        if (defined(texture)) {\n          this._value = texture;\n        } else {\n          return this._defaultTexture;\n        }\n      }\n\n      return this._value;\n    },\n    set: function (value) {\n      this._value = value;\n    },\n  },\n});\n\nDelayLoadedTextureUniform.prototype.clone = function (source) {\n  return source;\n};\n\nDelayLoadedTextureUniform.prototype.func = undefined;\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction getTextureUniformFunction(value, textures, defaultTexture) {\n  const uniform = new DelayLoadedTextureUniform(\n    value,\n    textures,\n    defaultTexture\n  );\n  // Define function here to access closure since 'this' can't be\n  // used when the Renderer sets uniforms.\n  uniform.func = function () {\n    return uniform.value;\n  };\n  return uniform;\n}\n\nconst gltfUniformFunctions = {};\ngltfUniformFunctions[WebGLConstants.FLOAT] = getScalarUniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[WebGLConstants.INT] = getScalarUniformFunction;\ngltfUniformFunctions[WebGLConstants.INT_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[WebGLConstants.INT_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[WebGLConstants.INT_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL] = getScalarUniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[WebGLConstants.BOOL_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_MAT2] = getMat2UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_MAT3] = getMat3UniformFunction;\ngltfUniformFunctions[WebGLConstants.FLOAT_MAT4] = getMat4UniformFunction;\ngltfUniformFunctions[WebGLConstants.SAMPLER_2D] = getTextureUniformFunction;\n// GLTF_SPEC: Support SAMPLER_CUBE. https://github.com/KhronosGroup/glTF/issues/40\n\nModelUtility.createUniformFunction = function (\n  type,\n  value,\n  textures,\n  defaultTexture\n) {\n  return gltfUniformFunctions[type](value, textures, defaultTexture);\n};\n\nfunction scaleFromMatrix5Array(matrix) {\n  return [\n    matrix[0],\n    matrix[1],\n    matrix[2],\n    matrix[3],\n    matrix[5],\n    matrix[6],\n    matrix[7],\n    matrix[8],\n    matrix[10],\n    matrix[11],\n    matrix[12],\n    matrix[13],\n    matrix[15],\n    matrix[16],\n    matrix[17],\n    matrix[18],\n  ];\n}\n\nfunction translateFromMatrix5Array(matrix) {\n  return [matrix[20], matrix[21], matrix[22], matrix[23]];\n}\n\nModelUtility.createUniformsForDracoQuantizedAttributes = function (\n  decodedAttributes\n) {\n  const uniformMap = {};\n  for (let attribute in decodedAttributes) {\n    if (decodedAttributes.hasOwnProperty(attribute)) {\n      const decodedData = decodedAttributes[attribute];\n      const quantization = decodedData.quantization;\n\n      if (!defined(quantization)) {\n        continue;\n      }\n\n      if (attribute.charAt(0) === \"_\") {\n        attribute = attribute.substring(1);\n      }\n\n      const uniformVarName = `gltf_u_dec_${attribute.toLowerCase()}`;\n\n      if (quantization.octEncoded) {\n        const uniformVarNameRangeConstant = `${uniformVarName}_rangeConstant`;\n        const rangeConstant = (1 << quantization.quantizationBits) - 1.0;\n        uniformMap[uniformVarNameRangeConstant] = getScalarUniformFunction(\n          rangeConstant\n        ).func;\n        continue;\n      }\n\n      const uniformVarNameNormConstant = `${uniformVarName}_normConstant`;\n      const normConstant =\n        quantization.range / (1 << quantization.quantizationBits);\n      uniformMap[uniformVarNameNormConstant] = getScalarUniformFunction(\n        normConstant\n      ).func;\n\n      const uniformVarNameMin = `${uniformVarName}_min`;\n      switch (decodedData.componentsPerAttribute) {\n        case 1:\n          uniformMap[uniformVarNameMin] = getScalarUniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n        case 2:\n          uniformMap[uniformVarNameMin] = getVec2UniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n        case 3:\n          uniformMap[uniformVarNameMin] = getVec3UniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n        case 4:\n          uniformMap[uniformVarNameMin] = getVec4UniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n      }\n    }\n  }\n\n  return uniformMap;\n};\n\nModelUtility.createUniformsForQuantizedAttributes = function (\n  gltf,\n  primitive,\n  quantizedUniforms\n) {\n  const accessors = gltf.accessors;\n  const setUniforms = {};\n  const uniformMap = {};\n\n  const attributes = primitive.attributes;\n  for (let attribute in attributes) {\n    if (attributes.hasOwnProperty(attribute)) {\n      const accessorId = attributes[attribute];\n      const a = accessors[accessorId];\n      const extensions = a.extensions;\n\n      if (attribute.charAt(0) === \"_\") {\n        attribute = attribute.substring(1);\n      }\n\n      if (defined(extensions)) {\n        const quantizedAttributes = extensions.WEB3D_quantized_attributes;\n        if (defined(quantizedAttributes)) {\n          const decodeMatrix = quantizedAttributes.decodeMatrix;\n          const uniformVariable = `gltf_u_dec_${attribute.toLowerCase()}`;\n          let uniformVariableScale;\n          let uniformVariableTranslate;\n          switch (a.type) {\n            case AttributeType.SCALAR:\n              uniformMap[uniformVariable] = getMat2UniformFunction(\n                decodeMatrix\n              ).func;\n              setUniforms[uniformVariable] = true;\n              break;\n            case AttributeType.VEC2:\n              uniformMap[uniformVariable] = getMat3UniformFunction(\n                decodeMatrix\n              ).func;\n              setUniforms[uniformVariable] = true;\n              break;\n            case AttributeType.VEC3:\n              uniformMap[uniformVariable] = getMat4UniformFunction(\n                decodeMatrix\n              ).func;\n              setUniforms[uniformVariable] = true;\n              break;\n            case AttributeType.VEC4:\n              // VEC4 attributes are split into scale and translate because there is no mat5 in GLSL\n              uniformVariableScale = `${uniformVariable}_scale`;\n              uniformVariableTranslate = `${uniformVariable}_translate`;\n              uniformMap[uniformVariableScale] = getMat4UniformFunction(\n                scaleFromMatrix5Array(decodeMatrix)\n              ).func;\n              uniformMap[uniformVariableTranslate] = getVec4UniformFunction(\n                translateFromMatrix5Array(decodeMatrix)\n              ).func;\n              setUniforms[uniformVariableScale] = true;\n              setUniforms[uniformVariableTranslate] = true;\n              break;\n          }\n        }\n      }\n    }\n  }\n\n  // If there are any unset quantized uniforms in this program, they should be set to the identity\n  for (const quantizedUniform in quantizedUniforms) {\n    if (quantizedUniforms.hasOwnProperty(quantizedUniform)) {\n      if (!setUniforms[quantizedUniform]) {\n        const properties = quantizedUniforms[quantizedUniform];\n        if (defined(properties.mat)) {\n          if (properties.mat === 2) {\n            uniformMap[quantizedUniform] = getMat2UniformFunction(\n              Matrix2.IDENTITY\n            ).func;\n          } else if (properties.mat === 3) {\n            uniformMap[quantizedUniform] = getMat3UniformFunction(\n              Matrix3.IDENTITY\n            ).func;\n          } else if (properties.mat === 4) {\n            uniformMap[quantizedUniform] = getMat4UniformFunction(\n              Matrix4.IDENTITY\n            ).func;\n          }\n        }\n        if (defined(properties.vec)) {\n          if (properties.vec === 4) {\n            uniformMap[quantizedUniform] = getVec4UniformFunction([\n              0,\n              0,\n              0,\n              0,\n            ]).func;\n          }\n        }\n      }\n    }\n  }\n  return uniformMap;\n};\n\n// This doesn't support LOCAL, which we could add if it is ever used.\nconst scratchTranslationRtc = new Cartesian3();\nconst gltfSemanticUniforms = {\n  MODEL: function (uniformState, model) {\n    return function () {\n      return uniformState.model;\n    };\n  },\n  VIEW: function (uniformState, model) {\n    return function () {\n      return uniformState.view;\n    };\n  },\n  PROJECTION: function (uniformState, model) {\n    return function () {\n      return uniformState.projection;\n    };\n  },\n  MODELVIEW: function (uniformState, model) {\n    return function () {\n      return uniformState.modelView;\n    };\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model) {\n    // CESIUM_RTC extension\n    const mvRtc = new Matrix4();\n    return function () {\n      if (defined(model._rtcCenter)) {\n        Matrix4.getTranslation(uniformState.model, scratchTranslationRtc);\n        Cartesian3.add(\n          scratchTranslationRtc,\n          model._rtcCenter,\n          scratchTranslationRtc\n        );\n        Matrix4.multiplyByPoint(\n          uniformState.view,\n          scratchTranslationRtc,\n          scratchTranslationRtc\n        );\n        return Matrix4.setTranslation(\n          uniformState.modelView,\n          scratchTranslationRtc,\n          mvRtc\n        );\n      }\n      return uniformState.modelView;\n    };\n  },\n  MODELVIEWPROJECTION: function (uniformState, model) {\n    return function () {\n      return uniformState.modelViewProjection;\n    };\n  },\n  MODELINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModel;\n    };\n  },\n  VIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseView;\n    };\n  },\n  PROJECTIONINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseProjection;\n    };\n  },\n  MODELVIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModelView;\n    };\n  },\n  MODELVIEWPROJECTIONINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModelViewProjection;\n    };\n  },\n  MODELINVERSETRANSPOSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseTransposeModel;\n    };\n  },\n  MODELVIEWINVERSETRANSPOSE: function (uniformState, model) {\n    return function () {\n      return uniformState.normal;\n    };\n  },\n  VIEWPORT: function (uniformState, model) {\n    return function () {\n      return uniformState.viewportCartesian4;\n    };\n  },\n  // JOINTMATRIX created in createCommand()\n};\n\nModelUtility.getGltfSemanticUniforms = function () {\n  return gltfSemanticUniforms;\n};\nexport default ModelUtility;\n","import buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport IauOrientationAxes from \"../Core/IauOrientationAxes.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Simon1994PlanetaryPositions from \"../Core/Simon1994PlanetaryPositions.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport EllipsoidPrimitive from \"./EllipsoidPrimitive.js\";\nimport Material from \"./Material.js\";\n\n/**\n * Draws the Moon in 3D.\n * @alias Moon\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.show=true] Determines whether the moon will be rendered.\n * @param {String} [options.textureUrl=buildModuleUrl('Assets/Textures/moonSmall.jpg')] The moon texture.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.MOON] The moon ellipsoid.\n * @param {Boolean} [options.onlySunLighting=true] Use the sun as the only light source.\n *\n *\n * @example\n * scene.moon = new Cesium.Moon();\n *\n * @see Scene#moon\n */\nfunction Moon(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  let url = options.textureUrl;\n  if (!defined(url)) {\n    url = buildModuleUrl(\"Assets/Textures/moonSmall.jpg\");\n  }\n\n  /**\n   * Determines if the moon will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The moon texture.\n   * @type {String}\n   * @default buildModuleUrl('Assets/Textures/moonSmall.jpg')\n   */\n  this.textureUrl = url;\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.MOON);\n\n  /**\n   * Use the sun as the only light source.\n   * @type {Boolean}\n   * @default true\n   */\n  this.onlySunLighting = defaultValue(options.onlySunLighting, true);\n\n  this._ellipsoidPrimitive = new EllipsoidPrimitive({\n    radii: this.ellipsoid.radii,\n    material: Material.fromType(Material.ImageType),\n    depthTestEnabled: false,\n    _owner: this,\n  });\n  this._ellipsoidPrimitive.material.translucent = false;\n\n  this._axes = new IauOrientationAxes();\n}\n\nObject.defineProperties(Moon.prototype, {\n  /**\n   * Get the ellipsoid that defines the shape of the moon.\n   *\n   * @memberof Moon.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   *\n   * @default {@link Ellipsoid.MOON}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\nconst icrfToFixed = new Matrix3();\nconst rotationScratch = new Matrix3();\nconst translationScratch = new Cartesian3();\nconst scratchCommandList = [];\n\n/**\n * @private\n */\nMoon.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  const ellipsoidPrimitive = this._ellipsoidPrimitive;\n  ellipsoidPrimitive.material.uniforms.image = this.textureUrl;\n  ellipsoidPrimitive.onlySunLighting = this.onlySunLighting;\n\n  const date = frameState.time;\n  if (!defined(Transforms.computeIcrfToFixedMatrix(date, icrfToFixed))) {\n    Transforms.computeTemeToPseudoFixedMatrix(date, icrfToFixed);\n  }\n\n  const rotation = this._axes.evaluate(date, rotationScratch);\n  Matrix3.transpose(rotation, rotation);\n  Matrix3.multiply(icrfToFixed, rotation, rotation);\n\n  const translation = Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(\n    date,\n    translationScratch\n  );\n  Matrix3.multiplyByVector(icrfToFixed, translation, translation);\n\n  Matrix4.fromRotationTranslation(\n    rotation,\n    translation,\n    ellipsoidPrimitive.modelMatrix\n  );\n\n  const savedCommandList = frameState.commandList;\n  frameState.commandList = scratchCommandList;\n  scratchCommandList.length = 0;\n  ellipsoidPrimitive.update(frameState);\n  frameState.commandList = savedCommandList;\n  return scratchCommandList.length === 1 ? scratchCommandList[0] : undefined;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Moon#destroy\n */\nMoon.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * moon = moon && moon.destroy();\n *\n * @see Moon#isDestroyed\n */\nMoon.prototype.destroy = function () {\n  this._ellipsoidPrimitive =\n    this._ellipsoidPrimitive && this._ellipsoidPrimitive.destroy();\n  return destroyObject(this);\n};\nexport default Moon;\n","import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestScheduler from \"../Core/RequestScheduler.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DContentGroup from \"./Cesium3DContentGroup.js\";\nimport Cesium3DTileContentType from \"./Cesium3DTileContentType.js\";\nimport Cesium3DTileContentFactory from \"./Cesium3DTileContentFactory.js\";\nimport findContentMetadata from \"./findContentMetadata.js\";\nimport findGroupMetadata from \"./findGroupMetadata.js\";\nimport preprocess3DTileContent from \"./preprocess3DTileContent.js\";\n\n/**\n * A collection of contents for tiles that have multiple contents, either via the tile JSON (3D Tiles 1.1) or the <code>3DTILES_multiple_contents</code> extension.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_multiple_contents|3DTILES_multiple_contents extension}\n *\n * @alias Multiple3DTileContent\n * @constructor\n *\n * @param {Cesium3DTileset} tileset The tileset this content belongs to\n * @param {Cesium3DTile} tile The content this content belongs to\n * @param {Resource} tilesetResource The resource that points to the tileset. This will be used to derive each inner content's resource.\n * @param {Object} contentsJson Either the tile JSON containing the contents array (3D Tiles 1.1), or <code>3DTILES_multiple_contents</code> extension JSON\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function Multiple3DTileContent(\n  tileset,\n  tile,\n  tilesetResource,\n  contentsJson\n) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._tilesetResource = tilesetResource;\n  this._contents = [];\n\n  // An older version of 3DTILES_multiple_contents used \"content\" instead of \"contents\"\n  const contentHeaders = defined(contentsJson.contents)\n    ? contentsJson.contents\n    : contentsJson.content;\n\n  this._innerContentHeaders = contentHeaders;\n  this._requestsInFlight = 0;\n\n  // How many times cancelPendingRequests() has been called. This is\n  // used to help short-circuit computations after a tile was canceled.\n  this._cancelCount = 0;\n\n  const contentCount = this._innerContentHeaders.length;\n  this._arrayFetchPromises = new Array(contentCount);\n  this._requests = new Array(contentCount);\n\n  this._innerContentResources = new Array(contentCount);\n  this._serverKeys = new Array(contentCount);\n\n  for (let i = 0; i < contentCount; i++) {\n    const contentResource = tilesetResource.getDerivedResource({\n      url: contentHeaders[i].uri,\n    });\n\n    const serverKey = RequestScheduler.getServerKey(\n      contentResource.getUrlComponent()\n    );\n\n    this._innerContentResources[i] = contentResource;\n    this._serverKeys[i] = serverKey;\n  }\n\n  // undefined until the first time requests are scheduled\n  this._contentsFetchedPromise = undefined;\n}\n\nObject.defineProperties(Multiple3DTileContent.prototype, {\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code> checks if any of the inner contents have dirty featurePropertiesDirty.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {Boolean}\n   *\n   * @private\n   */\n  featurePropertiesDirty: {\n    get: function () {\n      const contents = this._contents;\n      const length = contents.length;\n      for (let i = 0; i < length; ++i) {\n        if (contents[i].featurePropertiesDirty) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    set: function (value) {\n      const contents = this._contents;\n      const length = contents.length;\n      for (let i = 0; i < length; ++i) {\n        contents[i].featurePropertiesDirty = value;\n      }\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>featuresLength</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  featuresLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead, call <code>pointsLength</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  pointsLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>trianglesLength</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>geometryByteLength</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.   <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>texturesByteLength</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n   * always returns <code>0</code>.  Instead call <code>batchTableByteLength</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  batchTableByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return this._contents;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      const readyPromises = this._contents.map(function (content) {\n        return content.readyPromise;\n      });\n\n      const that = this;\n      return Promise.all(readyPromises).then(function () {\n        return that;\n      });\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   * Unlike other content types, <code>Multiple3DTileContent</code> does not\n   * have a single URL, so this returns undefined.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  url: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>undefined</code>.  Instead call <code>metadata</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return undefined;\n    },\n    set: function () {\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(\"Multiple3DTileContent cannot have metadata\");\n      //>>includeEnd('debug');\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>undefined</code>.  Instead call <code>batchTable</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  batchTable: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Multiple3DTileContent</code>\n   * always returns <code>undefined</code>.  Instead call <code>group</code> for a specific inner content.\n   * @memberof Multiple3DTileContent.prototype\n   * @private\n   */\n  group: {\n    get: function () {\n      return undefined;\n    },\n    set: function () {\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(\n        \"Multiple3DTileContent cannot have group metadata\"\n      );\n      //>>includeEnd('debug');\n    },\n  },\n\n  /**\n   * Get an array of the inner content URLs, regardless of whether they've\n   * been fetched or not. This is intended for use with\n   * {@link Cesium3DTileset#debugShowUrl}.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {String[]}\n   * @readonly\n   * @private\n   */\n  innerContentUrls: {\n    get: function () {\n      return this._innerContentHeaders.map(function (contentHeader) {\n        return contentHeader.uri;\n      });\n    },\n  },\n\n  /**\n   * A promise that resolves when all of the inner contents have been fetched.\n   * This promise is undefined until the first frame where all array buffer\n   * requests have been scheduled.\n   * @memberof Multiple3DTileContent.prototype\n   *\n   * @type {Promise}\n   * @private\n   */\n  contentsFetchedPromise: {\n    get: function () {\n      return this._contentsFetchedPromise;\n    },\n  },\n});\n\nfunction updatePendingRequests(multipleContents, deltaRequestCount) {\n  multipleContents._requestsInFlight += deltaRequestCount;\n  multipleContents.tileset.statistics.numberOfPendingRequests += deltaRequestCount;\n}\n\nfunction cancelPendingRequests(multipleContents, originalContentState) {\n  multipleContents._cancelCount++;\n\n  // reset the tile's content state to try again later.\n  multipleContents._tile._contentState = originalContentState;\n\n  multipleContents.tileset.statistics.numberOfPendingRequests -=\n    multipleContents._requestsInFlight;\n  multipleContents._requestsInFlight = 0;\n\n  // Discard the request promises.\n  const contentCount = multipleContents._innerContentHeaders.length;\n  multipleContents._arrayFetchPromises = new Array(contentCount);\n}\n\n/**\n * Request the inner contents of this <code>Multiple3DTileContent</code>. This must be called once a frame until\n * {@link Multiple3DTileContent#contentsFetchedPromise} is defined. This promise\n * becomes available as soon as all requests are scheduled.\n * <p>\n * This method also updates the tile statistics' pending request count if the\n * requests are successfully scheduled.\n * </p>\n *\n * @return {Number} The number of attempted requests that were unable to be scheduled.\n * @private\n */\nMultiple3DTileContent.prototype.requestInnerContents = function () {\n  // It's possible for these promises to leak content array buffers if the\n  // camera moves before they all are scheduled. To prevent this leak, check\n  // if we can schedule all the requests at once. If not, no requests are\n  // scheduled\n  if (!canScheduleAllRequests(this._serverKeys)) {\n    return this._serverKeys.length;\n  }\n\n  const contentHeaders = this._innerContentHeaders;\n  updatePendingRequests(this, contentHeaders.length);\n\n  for (let i = 0; i < contentHeaders.length; i++) {\n    // The cancel count is needed to avoid a race condition where a content\n    // is canceled multiple times.\n    this._arrayFetchPromises[i] = requestInnerContent(\n      this,\n      i,\n      this._cancelCount,\n      this._tile._contentState\n    );\n  }\n\n  this._contentsFetchedPromise = createInnerContents(this);\n\n  return 0;\n};\n\n/**\n * Check if all requests for inner contents can be scheduled at once. This is slower, but it avoids a potential memory leak.\n * @param {String[]} serverKeys The server keys for all of the inner contents\n * @return {Boolean} True if the request scheduler has enough open slots for all inner contents\n * @private\n */\nfunction canScheduleAllRequests(serverKeys) {\n  const requestCountsByServer = {};\n  for (let i = 0; i < serverKeys.length; i++) {\n    const serverKey = serverKeys[i];\n    if (defined(requestCountsByServer[serverKey])) {\n      requestCountsByServer[serverKey]++;\n    } else {\n      requestCountsByServer[serverKey] = 1;\n    }\n  }\n\n  for (const key in requestCountsByServer) {\n    if (\n      requestCountsByServer.hasOwnProperty(key) &&\n      !RequestScheduler.serverHasOpenSlots(key, requestCountsByServer[key])\n    ) {\n      return false;\n    }\n  }\n  return RequestScheduler.heapHasOpenSlots(serverKeys.length);\n}\n\nfunction requestInnerContent(\n  multipleContents,\n  index,\n  originalCancelCount,\n  originalContentState\n) {\n  // it is important to clone here. The fetchArrayBuffer() below here uses\n  // throttling, but other uses of the resources do not.\n  const contentResource = multipleContents._innerContentResources[\n    index\n  ].clone();\n  const tile = multipleContents.tile;\n\n  // Always create a new request. If the tile gets canceled, this\n  // avoids getting stuck in the canceled state.\n  const priorityFunction = function () {\n    return tile._priority;\n  };\n  const serverKey = multipleContents._serverKeys[index];\n  const request = new Request({\n    throttle: true,\n    throttleByServer: true,\n    type: RequestType.TILES3D,\n    priorityFunction: priorityFunction,\n    serverKey: serverKey,\n  });\n  contentResource.request = request;\n  multipleContents._requests[index] = request;\n\n  return contentResource\n    .fetchArrayBuffer()\n    .then(function (arrayBuffer) {\n      // Short circuit if another inner content was canceled.\n      if (originalCancelCount < multipleContents._cancelCount) {\n        return undefined;\n      }\n\n      updatePendingRequests(multipleContents, -1);\n      return arrayBuffer;\n    })\n    .catch(function (error) {\n      // Short circuit if another inner content was canceled.\n      if (originalCancelCount < multipleContents._cancelCount) {\n        return undefined;\n      }\n\n      if (contentResource.request.state === RequestState.CANCELLED) {\n        cancelPendingRequests(multipleContents, originalContentState);\n        return undefined;\n      }\n\n      updatePendingRequests(multipleContents, -1);\n      handleInnerContentFailed(multipleContents, index, error);\n    });\n}\n\nfunction createInnerContents(multipleContents) {\n  const originalCancelCount = multipleContents._cancelCount;\n  return Promise.all(multipleContents._arrayFetchPromises).then(function (\n    arrayBuffers\n  ) {\n    if (originalCancelCount < multipleContents._cancelCount) {\n      return undefined;\n    }\n\n    const contents = arrayBuffers.map(function (arrayBuffer, i) {\n      if (!defined(arrayBuffer)) {\n        // Content was not fetched. The error was handled in\n        // the fetch promise\n        return undefined;\n      }\n\n      return createInnerContent(multipleContents, arrayBuffer, i);\n    });\n\n    multipleContents._contents = contents.filter(defined);\n  });\n}\n\nfunction createInnerContent(multipleContents, arrayBuffer, index) {\n  const preprocessed = preprocess3DTileContent(arrayBuffer);\n\n  if (preprocessed.contentType === Cesium3DTileContentType.EXTERNAL_TILESET) {\n    const error = new RuntimeError(\n      \"External tilesets are disallowed inside multiple contents\"\n    );\n\n    return handleInnerContentFailed(multipleContents, index, error);\n  }\n\n  multipleContents._disableSkipLevelOfDetail =\n    multipleContents._disableSkipLevelOfDetail ||\n    preprocessed.contentType === Cesium3DTileContentType.GEOMETRY ||\n    preprocessed.contentType === Cesium3DTileContentType.VECTOR;\n\n  const tileset = multipleContents._tileset;\n  const resource = multipleContents._innerContentResources[index];\n  const tile = multipleContents._tile;\n\n  let content;\n  const contentFactory = Cesium3DTileContentFactory[preprocessed.contentType];\n  if (defined(preprocessed.binaryPayload)) {\n    content = contentFactory(\n      tileset,\n      tile,\n      resource,\n      preprocessed.binaryPayload.buffer,\n      0\n    );\n  } else {\n    // JSON formats\n    content = contentFactory(tileset, tile, resource, preprocessed.jsonPayload);\n  }\n\n  const contentHeader = multipleContents._innerContentHeaders[index];\n\n  if (tile.hasImplicitContentMetadata) {\n    const subtree = tile.implicitSubtree;\n    const coordinates = tile.implicitCoordinates;\n    content.metadata = subtree.getContentMetadataView(coordinates, index);\n  } else if (!tile.hasImplicitContent) {\n    content.metadata = findContentMetadata(tileset, contentHeader);\n  }\n\n  const groupMetadata = findGroupMetadata(tileset, contentHeader);\n  if (defined(groupMetadata)) {\n    content.group = new Cesium3DContentGroup({\n      metadata: groupMetadata,\n    });\n  }\n  return content;\n}\n\nfunction handleInnerContentFailed(multipleContents, index, error) {\n  const tileset = multipleContents._tileset;\n  const url = multipleContents._innerContentResources[index].url;\n  const message = defined(error.message) ? error.message : error.toString();\n  if (tileset.tileFailed.numberOfListeners > 0) {\n    tileset.tileFailed.raiseEvent({\n      url: url,\n      message: message,\n    });\n  } else {\n    console.log(`A content failed to load: ${url}`);\n    console.log(`Error: ${message}`);\n  }\n}\n\n/**\n * Cancel all requests for inner contents. This is called by the tile\n * when a tile goes out of view.\n *\n * @private\n */\nMultiple3DTileContent.prototype.cancelRequests = function () {\n  for (let i = 0; i < this._requests.length; i++) {\n    const request = this._requests[i];\n    if (defined(request)) {\n      request.cancel();\n    }\n  }\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n * always returns <code>false</code>.  Instead call <code>hasProperty</code> for a specific inner content\n * @private\n */\nMultiple3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return false;\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Multiple3DTileContent</code>\n * always returns <code>undefined</code>.  Instead call <code>getFeature</code> for a specific inner content\n * @private\n */\nMultiple3DTileContent.prototype.getFeature = function (batchId) {\n  return undefined;\n};\n\nMultiple3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].applyDebugSettings(enabled, color);\n  }\n};\n\nMultiple3DTileContent.prototype.applyStyle = function (style) {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].applyStyle(style);\n  }\n};\n\nMultiple3DTileContent.prototype.update = function (tileset, frameState) {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].update(tileset, frameState);\n  }\n};\n\nMultiple3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nMultiple3DTileContent.prototype.destroy = function () {\n  const contents = this._contents;\n  const length = contents.length;\n  for (let i = 0; i < length; ++i) {\n    contents[i].destroy();\n  }\n  return destroyObject(this);\n};\n","/**\n * A {@link TileDiscardPolicy} specifying that tile images should never be discard.\n *\n * @alias NeverTileDiscardPolicy\n * @constructor\n *\n * @see DiscardMissingTileImagePolicy\n */\nfunction NeverTileDiscardPolicy(options) {}\n\n/**\n * Determines if the discard policy is ready to process images.\n * @returns {Boolean} True if the discard policy is ready to process images; otherwise, false.\n */\nNeverTileDiscardPolicy.prototype.isReady = function () {\n  return true;\n};\n\n/**\n * Given a tile image, decide whether to discard that image.\n *\n * @param {HTMLImageElement} image An image to test.\n * @returns {Boolean} True if the image should be discarded; otherwise, false.\n */\nNeverTileDiscardPolicy.prototype.shouldDiscardImage = function (image) {\n  return false;\n};\nexport default NeverTileDiscardPolicy;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport AdjustTranslucentFS from \"../Shaders/AdjustTranslucentFS.js\";\nimport CompositeOITFS from \"../Shaders/CompositeOITFS.js\";\nimport BlendEquation from \"./BlendEquation.js\";\nimport BlendFunction from \"./BlendFunction.js\";\n\n/**\n * @private\n */\nfunction OIT(context) {\n  this._numSamples = 1;\n  // We support multipass for the Chrome D3D9 backend and ES 2.0 on mobile.\n  this._translucentMultipassSupport = false;\n  this._translucentMRTSupport = false;\n\n  const extensionsSupported =\n    context.colorBufferFloat && context.depthTexture && context.floatBlend;\n  this._translucentMRTSupport = context.drawBuffers && extensionsSupported;\n  this._translucentMultipassSupport =\n    !this._translucentMRTSupport && extensionsSupported;\n\n  this._opaqueFBO = undefined;\n  this._opaqueTexture = undefined;\n  this._depthStencilTexture = undefined;\n\n  this._accumulationTexture = undefined;\n\n  this._translucentFBO = new FramebufferManager({\n    colorAttachmentsLength: this._translucentMRTSupport ? 2 : 1,\n    createColorAttachments: false,\n    createDepthAttachments: false,\n    depth: true,\n  });\n  this._alphaFBO = new FramebufferManager({\n    createColorAttachments: false,\n    createDepthAttachments: false,\n    depth: true,\n  });\n\n  this._adjustTranslucentFBO = new FramebufferManager({\n    colorAttachmentsLength: this._translucentMRTSupport ? 2 : 1,\n    createColorAttachments: false,\n  });\n  this._adjustAlphaFBO = new FramebufferManager({\n    createColorAttachments: false,\n  });\n\n  this._opaqueClearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    owner: this,\n  });\n  this._translucentMRTClearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 1.0),\n    owner: this,\n  });\n  this._translucentMultipassClearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    owner: this,\n  });\n  this._alphaClearCommand = new ClearCommand({\n    color: new Color(1.0, 1.0, 1.0, 1.0),\n    owner: this,\n  });\n\n  this._translucentRenderStateCache = {};\n  this._alphaRenderStateCache = {};\n\n  this._compositeCommand = undefined;\n  this._adjustTranslucentCommand = undefined;\n  this._adjustAlphaCommand = undefined;\n\n  this._viewport = new BoundingRectangle();\n  this._rs = undefined;\n\n  this._useScissorTest = false;\n  this._scissorRectangle = undefined;\n\n  this._useHDR = false;\n}\n\nfunction destroyTextures(oit) {\n  oit._accumulationTexture =\n    oit._accumulationTexture &&\n    !oit._accumulationTexture.isDestroyed() &&\n    oit._accumulationTexture.destroy();\n  oit._revealageTexture =\n    oit._revealageTexture &&\n    !oit._revealageTexture.isDestroyed() &&\n    oit._revealageTexture.destroy();\n}\n\nfunction destroyFramebuffers(oit) {\n  oit._translucentFBO.destroy();\n  oit._alphaFBO.destroy();\n  oit._adjustTranslucentFBO.destroy();\n  oit._adjustAlphaFBO.destroy();\n}\n\nfunction destroyResources(oit) {\n  destroyTextures(oit);\n  destroyFramebuffers(oit);\n}\n\nfunction updateTextures(oit, context, width, height) {\n  destroyTextures(oit);\n\n  oit._accumulationTexture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.FLOAT,\n  });\n\n  // Use zeroed arraybuffer instead of null to initialize texture\n  // to workaround Firefox. Only needed for the second color attachment.\n  const source = new Float32Array(width * height * 4);\n  oit._revealageTexture = new Texture({\n    context: context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.FLOAT,\n    source: {\n      arrayBufferView: source,\n      width: width,\n      height: height,\n    },\n    flipY: false,\n  });\n}\n\nfunction updateFramebuffers(oit, context) {\n  destroyFramebuffers(oit);\n\n  const completeFBO = WebGLConstants.FRAMEBUFFER_COMPLETE;\n  let supported = true;\n\n  const width = oit._accumulationTexture.width;\n  const height = oit._accumulationTexture.height;\n\n  // if MRT is supported, attempt to make an FBO with multiple color attachments\n  if (oit._translucentMRTSupport) {\n    oit._translucentFBO.setColorTexture(oit._accumulationTexture, 0);\n    oit._translucentFBO.setColorTexture(oit._revealageTexture, 1);\n    oit._translucentFBO.setDepthStencilTexture(oit._depthStencilTexture);\n    oit._translucentFBO.update(context, width, height);\n\n    oit._adjustTranslucentFBO.setColorTexture(oit._accumulationTexture, 0);\n    oit._adjustTranslucentFBO.setColorTexture(oit._revealageTexture, 1);\n    oit._adjustTranslucentFBO.update(context, width, height);\n\n    if (\n      oit._translucentFBO.status !== completeFBO ||\n      oit._adjustTranslucentFBO.status !== completeFBO\n    ) {\n      destroyFramebuffers(oit);\n      oit._translucentMRTSupport = false;\n    }\n  }\n\n  // either MRT isn't supported or FBO creation failed, attempt multipass\n  if (!oit._translucentMRTSupport) {\n    oit._translucentFBO.setColorTexture(oit._accumulationTexture);\n    oit._translucentFBO.setDepthStencilTexture(oit._depthStencilTexture);\n    oit._translucentFBO.update(context, width, height);\n\n    oit._alphaFBO.setColorTexture(oit._revealageTexture);\n    oit._alphaFBO.setDepthStencilTexture(oit._depthStencilTexture);\n    oit._alphaFBO.update(context, width, height);\n\n    oit._adjustTranslucentFBO.setColorTexture(oit._accumulationTexture);\n    oit._adjustTranslucentFBO.update(context, width, height);\n\n    oit._adjustAlphaFBO.setColorTexture(oit._revealageTexture);\n    oit._adjustAlphaFBO.update(context, width, height);\n\n    const translucentComplete = oit._translucentFBO.status === completeFBO;\n    const alphaComplete = oit._alphaFBO.status === completeFBO;\n    const adjustTranslucentComplete =\n      oit._adjustTranslucentFBO.status === completeFBO;\n    const adjustAlphaComplete = oit._adjustAlphaFBO.status === completeFBO;\n    if (\n      !translucentComplete ||\n      !alphaComplete ||\n      !adjustTranslucentComplete ||\n      !adjustAlphaComplete\n    ) {\n      destroyResources(oit);\n      oit._translucentMultipassSupport = false;\n      supported = false;\n    }\n  }\n\n  return supported;\n}\n\nOIT.prototype.update = function (\n  context,\n  passState,\n  framebuffer,\n  useHDR,\n  numSamples\n) {\n  if (!this.isSupported()) {\n    return;\n  }\n\n  this._opaqueFBO = framebuffer;\n  this._opaqueTexture = framebuffer.getColorTexture(0);\n  this._depthStencilTexture = framebuffer.getDepthStencilTexture();\n\n  const width = this._opaqueTexture.width;\n  const height = this._opaqueTexture.height;\n\n  const accumulationTexture = this._accumulationTexture;\n  const textureChanged =\n    !defined(accumulationTexture) ||\n    accumulationTexture.width !== width ||\n    accumulationTexture.height !== height ||\n    useHDR !== this._useHDR;\n  const samplesChanged = this._numSamples !== numSamples;\n\n  if (textureChanged || samplesChanged) {\n    this._numSamples = numSamples;\n    updateTextures(this, context, width, height);\n  }\n\n  if (\n    !defined(this._translucentFBO.framebuffer) ||\n    textureChanged ||\n    samplesChanged\n  ) {\n    if (!updateFramebuffers(this, context)) {\n      // framebuffer creation failed\n      return;\n    }\n  }\n\n  this._useHDR = useHDR;\n\n  const that = this;\n  let fs;\n  let uniformMap;\n\n  if (!defined(this._compositeCommand)) {\n    fs = new ShaderSource({\n      sources: [CompositeOITFS],\n    });\n    if (this._translucentMRTSupport) {\n      fs.defines.push(\"MRT\");\n    }\n\n    uniformMap = {\n      u_opaque: function () {\n        return that._opaqueTexture;\n      },\n      u_accumulation: function () {\n        return that._accumulationTexture;\n      },\n      u_revealage: function () {\n        return that._revealageTexture;\n      },\n    };\n    this._compositeCommand = context.createViewportQuadCommand(fs, {\n      uniformMap: uniformMap,\n      owner: this,\n    });\n  }\n\n  if (!defined(this._adjustTranslucentCommand)) {\n    if (this._translucentMRTSupport) {\n      fs = new ShaderSource({\n        defines: [\"MRT\"],\n        sources: [AdjustTranslucentFS],\n      });\n\n      uniformMap = {\n        u_bgColor: function () {\n          return that._translucentMRTClearCommand.color;\n        },\n        u_depthTexture: function () {\n          return that._depthStencilTexture;\n        },\n      };\n\n      this._adjustTranslucentCommand = context.createViewportQuadCommand(fs, {\n        uniformMap: uniformMap,\n        owner: this,\n      });\n    } else if (this._translucentMultipassSupport) {\n      fs = new ShaderSource({\n        sources: [AdjustTranslucentFS],\n      });\n\n      uniformMap = {\n        u_bgColor: function () {\n          return that._translucentMultipassClearCommand.color;\n        },\n        u_depthTexture: function () {\n          return that._depthStencilTexture;\n        },\n      };\n\n      this._adjustTranslucentCommand = context.createViewportQuadCommand(fs, {\n        uniformMap: uniformMap,\n        owner: this,\n      });\n\n      uniformMap = {\n        u_bgColor: function () {\n          return that._alphaClearCommand.color;\n        },\n        u_depthTexture: function () {\n          return that._depthStencilTexture;\n        },\n      };\n\n      this._adjustAlphaCommand = context.createViewportQuadCommand(fs, {\n        uniformMap: uniformMap,\n        owner: this,\n      });\n    }\n  }\n\n  this._viewport.width = width;\n  this._viewport.height = height;\n\n  const useScissorTest = !BoundingRectangle.equals(\n    this._viewport,\n    passState.viewport\n  );\n  let updateScissor = useScissorTest !== this._useScissorTest;\n  this._useScissorTest = useScissorTest;\n\n  if (!BoundingRectangle.equals(this._scissorRectangle, passState.viewport)) {\n    this._scissorRectangle = BoundingRectangle.clone(\n      passState.viewport,\n      this._scissorRectangle\n    );\n    updateScissor = true;\n  }\n\n  if (\n    !defined(this._rs) ||\n    !BoundingRectangle.equals(this._viewport, this._rs.viewport) ||\n    updateScissor\n  ) {\n    this._rs = RenderState.fromCache({\n      viewport: this._viewport,\n      scissorTest: {\n        enabled: this._useScissorTest,\n        rectangle: this._scissorRectangle,\n      },\n    });\n  }\n\n  if (defined(this._compositeCommand)) {\n    this._compositeCommand.renderState = this._rs;\n  }\n\n  if (this._adjustTranslucentCommand) {\n    this._adjustTranslucentCommand.renderState = this._rs;\n  }\n\n  if (defined(this._adjustAlphaCommand)) {\n    this._adjustAlphaCommand.renderState = this._rs;\n  }\n};\n\nconst translucentMRTBlend = {\n  enabled: true,\n  color: new Color(0.0, 0.0, 0.0, 0.0),\n  equationRgb: BlendEquation.ADD,\n  equationAlpha: BlendEquation.ADD,\n  functionSourceRgb: BlendFunction.ONE,\n  functionDestinationRgb: BlendFunction.ONE,\n  functionSourceAlpha: BlendFunction.ZERO,\n  functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n};\n\nconst translucentColorBlend = {\n  enabled: true,\n  color: new Color(0.0, 0.0, 0.0, 0.0),\n  equationRgb: BlendEquation.ADD,\n  equationAlpha: BlendEquation.ADD,\n  functionSourceRgb: BlendFunction.ONE,\n  functionDestinationRgb: BlendFunction.ONE,\n  functionSourceAlpha: BlendFunction.ONE,\n  functionDestinationAlpha: BlendFunction.ONE,\n};\n\nconst translucentAlphaBlend = {\n  enabled: true,\n  color: new Color(0.0, 0.0, 0.0, 0.0),\n  equationRgb: BlendEquation.ADD,\n  equationAlpha: BlendEquation.ADD,\n  functionSourceRgb: BlendFunction.ZERO,\n  functionDestinationRgb: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n  functionSourceAlpha: BlendFunction.ZERO,\n  functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA,\n};\n\nfunction getTranslucentRenderState(\n  context,\n  translucentBlending,\n  cache,\n  renderState\n) {\n  let translucentState = cache[renderState.id];\n  if (!defined(translucentState)) {\n    const rs = RenderState.getState(renderState);\n    rs.depthMask = false;\n    rs.blending = translucentBlending;\n\n    translucentState = RenderState.fromCache(rs);\n    cache[renderState.id] = translucentState;\n  }\n\n  return translucentState;\n}\n\nfunction getTranslucentMRTRenderState(oit, context, renderState) {\n  return getTranslucentRenderState(\n    context,\n    translucentMRTBlend,\n    oit._translucentRenderStateCache,\n    renderState\n  );\n}\n\nfunction getTranslucentColorRenderState(oit, context, renderState) {\n  return getTranslucentRenderState(\n    context,\n    translucentColorBlend,\n    oit._translucentRenderStateCache,\n    renderState\n  );\n}\n\nfunction getTranslucentAlphaRenderState(oit, context, renderState) {\n  return getTranslucentRenderState(\n    context,\n    translucentAlphaBlend,\n    oit._alphaRenderStateCache,\n    renderState\n  );\n}\n\nconst mrtShaderSource =\n  \"    vec3 Ci = czm_gl_FragColor.rgb * czm_gl_FragColor.a;\\n\" +\n  \"    float ai = czm_gl_FragColor.a;\\n\" +\n  \"    float wzi = czm_alphaWeight(ai);\\n\" +\n  \"    gl_FragData[0] = vec4(Ci * wzi, ai);\\n\" +\n  \"    gl_FragData[1] = vec4(ai * wzi);\\n\";\n\nconst colorShaderSource =\n  \"    vec3 Ci = czm_gl_FragColor.rgb * czm_gl_FragColor.a;\\n\" +\n  \"    float ai = czm_gl_FragColor.a;\\n\" +\n  \"    float wzi = czm_alphaWeight(ai);\\n\" +\n  \"    gl_FragColor = vec4(Ci, ai) * wzi;\\n\";\n\nconst alphaShaderSource =\n  \"    float ai = czm_gl_FragColor.a;\\n\" + \"    gl_FragColor = vec4(ai);\\n\";\n\nfunction getTranslucentShaderProgram(context, shaderProgram, keyword, source) {\n  let shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    keyword\n  );\n  if (!defined(shader)) {\n    const attributeLocations = shaderProgram._attributeLocations;\n\n    const fs = shaderProgram.fragmentShaderSource.clone();\n\n    fs.sources = fs.sources.map(function (source) {\n      source = ShaderSource.replaceMain(source, \"czm_translucent_main\");\n      source = source.replace(/gl_FragColor/g, \"czm_gl_FragColor\");\n      source = source.replace(/\\bdiscard\\b/g, \"czm_discard = true\");\n      source = source.replace(/czm_phong/g, \"czm_translucentPhong\");\n      return source;\n    });\n\n    // Discarding the fragment in main is a workaround for ANGLE D3D9\n    // shader compilation errors.\n\n    fs.sources.splice(\n      0,\n      0,\n      `${\n        source.indexOf(\"gl_FragData\") !== -1\n          ? \"#extension GL_EXT_draw_buffers : enable \\n\"\n          : \"\"\n      }vec4 czm_gl_FragColor;\\n` + `bool czm_discard = false;\\n`\n    );\n\n    fs.sources.push(\n      `${\n        \"void main()\\n\" +\n        \"{\\n\" +\n        \"    czm_translucent_main();\\n\" +\n        \"    if (czm_discard)\\n\" +\n        \"    {\\n\" +\n        \"        discard;\\n\" +\n        \"    }\\n\"\n      }${source}}\\n`\n    );\n\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      keyword,\n      {\n        vertexShaderSource: shaderProgram.vertexShaderSource,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nfunction getTranslucentMRTShaderProgram(context, shaderProgram) {\n  return getTranslucentShaderProgram(\n    context,\n    shaderProgram,\n    \"translucentMRT\",\n    mrtShaderSource\n  );\n}\n\nfunction getTranslucentColorShaderProgram(context, shaderProgram) {\n  return getTranslucentShaderProgram(\n    context,\n    shaderProgram,\n    \"translucentMultipass\",\n    colorShaderSource\n  );\n}\n\nfunction getTranslucentAlphaShaderProgram(context, shaderProgram) {\n  return getTranslucentShaderProgram(\n    context,\n    shaderProgram,\n    \"alphaMultipass\",\n    alphaShaderSource\n  );\n}\n\nOIT.prototype.createDerivedCommands = function (command, context, result) {\n  if (!defined(result)) {\n    result = {};\n  }\n\n  if (this._translucentMRTSupport) {\n    let translucentShader;\n    let translucentRenderState;\n    if (defined(result.translucentCommand)) {\n      translucentShader = result.translucentCommand.shaderProgram;\n      translucentRenderState = result.translucentCommand.renderState;\n    }\n\n    result.translucentCommand = DrawCommand.shallowClone(\n      command,\n      result.translucentCommand\n    );\n\n    if (\n      !defined(translucentShader) ||\n      result.shaderProgramId !== command.shaderProgram.id\n    ) {\n      result.translucentCommand.shaderProgram = getTranslucentMRTShaderProgram(\n        context,\n        command.shaderProgram\n      );\n      result.translucentCommand.renderState = getTranslucentMRTRenderState(\n        this,\n        context,\n        command.renderState\n      );\n      result.shaderProgramId = command.shaderProgram.id;\n    } else {\n      result.translucentCommand.shaderProgram = translucentShader;\n      result.translucentCommand.renderState = translucentRenderState;\n    }\n  } else {\n    let colorShader;\n    let colorRenderState;\n    let alphaShader;\n    let alphaRenderState;\n    if (defined(result.translucentCommand)) {\n      colorShader = result.translucentCommand.shaderProgram;\n      colorRenderState = result.translucentCommand.renderState;\n      alphaShader = result.alphaCommand.shaderProgram;\n      alphaRenderState = result.alphaCommand.renderState;\n    }\n\n    result.translucentCommand = DrawCommand.shallowClone(\n      command,\n      result.translucentCommand\n    );\n    result.alphaCommand = DrawCommand.shallowClone(\n      command,\n      result.alphaCommand\n    );\n\n    if (\n      !defined(colorShader) ||\n      result.shaderProgramId !== command.shaderProgram.id\n    ) {\n      result.translucentCommand.shaderProgram = getTranslucentColorShaderProgram(\n        context,\n        command.shaderProgram\n      );\n      result.translucentCommand.renderState = getTranslucentColorRenderState(\n        this,\n        context,\n        command.renderState\n      );\n      result.alphaCommand.shaderProgram = getTranslucentAlphaShaderProgram(\n        context,\n        command.shaderProgram\n      );\n      result.alphaCommand.renderState = getTranslucentAlphaRenderState(\n        this,\n        context,\n        command.renderState\n      );\n      result.shaderProgramId = command.shaderProgram.id;\n    } else {\n      result.translucentCommand.shaderProgram = colorShader;\n      result.translucentCommand.renderState = colorRenderState;\n      result.alphaCommand.shaderProgram = alphaShader;\n      result.alphaCommand.renderState = alphaRenderState;\n    }\n  }\n\n  return result;\n};\n\nfunction executeTranslucentCommandsSortedMultipass(\n  oit,\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification\n) {\n  let command;\n  let derivedCommand;\n  let j;\n\n  const context = scene.context;\n  const useLogDepth = scene.frameState.useLogDepth;\n  const useHdr = scene._hdr;\n  const framebuffer = passState.framebuffer;\n  const length = commands.length;\n\n  const lightShadowsEnabled = scene.frameState.shadowState.lightShadowsEnabled;\n\n  passState.framebuffer = oit._adjustTranslucentFBO.framebuffer;\n  oit._adjustTranslucentCommand.execute(context, passState);\n  passState.framebuffer = oit._adjustAlphaFBO.framebuffer;\n  oit._adjustAlphaCommand.execute(context, passState);\n\n  const debugFramebuffer = oit._opaqueFBO.framebuffer;\n  passState.framebuffer = oit._translucentFBO.framebuffer;\n\n  for (j = 0; j < length; ++j) {\n    command = commands[j];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n    command = useHdr ? command.derivedCommands.hdr.command : command;\n    derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.translucentCommand\n        : command.derivedCommands.oit.translucentCommand;\n    executeFunction(\n      derivedCommand,\n      scene,\n      context,\n      passState,\n      debugFramebuffer\n    );\n  }\n\n  if (defined(invertClassification)) {\n    command = invertClassification.unclassifiedCommand;\n    derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.translucentCommand\n        : command.derivedCommands.oit.translucentCommand;\n    executeFunction(\n      derivedCommand,\n      scene,\n      context,\n      passState,\n      debugFramebuffer\n    );\n  }\n\n  passState.framebuffer = oit._alphaFBO.framebuffer;\n\n  for (j = 0; j < length; ++j) {\n    command = commands[j];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n    command = useHdr ? command.derivedCommands.hdr.command : command;\n    derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.alphaCommand\n        : command.derivedCommands.oit.alphaCommand;\n    executeFunction(\n      derivedCommand,\n      scene,\n      context,\n      passState,\n      debugFramebuffer\n    );\n  }\n\n  if (defined(invertClassification)) {\n    command = invertClassification.unclassifiedCommand;\n    derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.alphaCommand\n        : command.derivedCommands.oit.alphaCommand;\n    executeFunction(\n      derivedCommand,\n      scene,\n      context,\n      passState,\n      debugFramebuffer\n    );\n  }\n\n  passState.framebuffer = framebuffer;\n}\n\nfunction executeTranslucentCommandsSortedMRT(\n  oit,\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification\n) {\n  const context = scene.context;\n  const useLogDepth = scene.frameState.useLogDepth;\n  const useHdr = scene._hdr;\n  const framebuffer = passState.framebuffer;\n  const length = commands.length;\n\n  const lightShadowsEnabled = scene.frameState.shadowState.lightShadowsEnabled;\n\n  passState.framebuffer = oit._adjustTranslucentFBO.framebuffer;\n  oit._adjustTranslucentCommand.execute(context, passState);\n\n  const debugFramebuffer = oit._opaqueFBO.framebuffer;\n  passState.framebuffer = oit._translucentFBO.framebuffer;\n\n  let command;\n  let derivedCommand;\n\n  for (let j = 0; j < length; ++j) {\n    command = commands[j];\n    command = useLogDepth ? command.derivedCommands.logDepth.command : command;\n    command = useHdr ? command.derivedCommands.hdr.command : command;\n    derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.translucentCommand\n        : command.derivedCommands.oit.translucentCommand;\n    executeFunction(\n      derivedCommand,\n      scene,\n      context,\n      passState,\n      debugFramebuffer\n    );\n  }\n\n  if (defined(invertClassification)) {\n    command = invertClassification.unclassifiedCommand;\n    derivedCommand =\n      lightShadowsEnabled && command.receiveShadows\n        ? command.derivedCommands.oit.shadows.translucentCommand\n        : command.derivedCommands.oit.translucentCommand;\n    executeFunction(\n      derivedCommand,\n      scene,\n      context,\n      passState,\n      debugFramebuffer\n    );\n  }\n\n  passState.framebuffer = framebuffer;\n}\n\nOIT.prototype.executeCommands = function (\n  scene,\n  executeFunction,\n  passState,\n  commands,\n  invertClassification\n) {\n  if (this._translucentMRTSupport) {\n    executeTranslucentCommandsSortedMRT(\n      this,\n      scene,\n      executeFunction,\n      passState,\n      commands,\n      invertClassification\n    );\n    return;\n  }\n\n  executeTranslucentCommandsSortedMultipass(\n    this,\n    scene,\n    executeFunction,\n    passState,\n    commands,\n    invertClassification\n  );\n};\n\nOIT.prototype.execute = function (context, passState) {\n  this._compositeCommand.execute(context, passState);\n};\n\nOIT.prototype.clear = function (context, passState, clearColor) {\n  const framebuffer = passState.framebuffer;\n\n  passState.framebuffer = this._opaqueFBO.framebuffer;\n  Color.clone(clearColor, this._opaqueClearCommand.color);\n  this._opaqueClearCommand.execute(context, passState);\n\n  passState.framebuffer = this._translucentFBO.framebuffer;\n  const translucentClearCommand = this._translucentMRTSupport\n    ? this._translucentMRTClearCommand\n    : this._translucentMultipassClearCommand;\n  translucentClearCommand.execute(context, passState);\n\n  if (this._translucentMultipassSupport) {\n    passState.framebuffer = this._alphaFBO.framebuffer;\n    this._alphaClearCommand.execute(context, passState);\n  }\n\n  passState.framebuffer = framebuffer;\n};\n\nOIT.prototype.isSupported = function () {\n  return this._translucentMRTSupport || this._translucentMultipassSupport;\n};\n\nOIT.prototype.isDestroyed = function () {\n  return false;\n};\n\nOIT.prototype.destroy = function () {\n  destroyResources(this);\n\n  if (defined(this._compositeCommand)) {\n    this._compositeCommand.shaderProgram =\n      this._compositeCommand.shaderProgram &&\n      this._compositeCommand.shaderProgram.destroy();\n  }\n\n  if (defined(this._adjustTranslucentCommand)) {\n    this._adjustTranslucentCommand.shaderProgram =\n      this._adjustTranslucentCommand.shaderProgram &&\n      this._adjustTranslucentCommand.shaderProgram.destroy();\n  }\n\n  if (defined(this._adjustAlphaCommand)) {\n    this._adjustAlphaCommand.shaderProgram =\n      this._adjustAlphaCommand.shaderProgram &&\n      this._adjustAlphaCommand.shaderProgram.destroy();\n  }\n\n  return destroyObject(this);\n};\nexport default OIT;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport loadKTX2 from \"../Core/loadKTX2.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport OctahedralProjectionAtlasFS from \"../Shaders/OctahedralProjectionAtlasFS.js\";\nimport OctahedralProjectionFS from \"../Shaders/OctahedralProjectionFS.js\";\nimport OctahedralProjectionVS from \"../Shaders/OctahedralProjectionVS.js\";\n\n/**\n * Packs all mip levels of a cube map into a 2D texture atlas.\n *\n * Octahedral projection is a way of putting the cube maps onto a 2D texture\n * with minimal distortion and easy look up.\n * See Chapter 16 of WebGL Insights \"HDR Image-Based Lighting on the Web\" by Jeff Russell\n * and \"Octahedron Environment Maps\" for reference.\n *\n * @private\n */\nfunction OctahedralProjectedCubeMap(url) {\n  this._url = url;\n\n  this._cubeMapBuffers = undefined;\n  this._cubeMaps = undefined;\n  this._texture = undefined;\n  this._mipTextures = undefined;\n  this._va = undefined;\n  this._sp = undefined;\n\n  this._maximumMipmapLevel = undefined;\n\n  this._loading = false;\n  this._ready = false;\n  this._readyPromise = defer();\n}\n\nObject.defineProperties(OctahedralProjectedCubeMap.prototype, {\n  /**\n   * The url to the KTX2 file containing the specular environment map and convoluted mipmaps.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._url;\n    },\n  },\n  /**\n   * A texture containing all the packed convolutions.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {Texture}\n   * @readonly\n   */\n  texture: {\n    get: function () {\n      return this._texture;\n    },\n  },\n  /**\n   * The maximum number of mip levels.\n   * @memberOf OctahedralProjectedCubeMap.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumMipmapLevel: {\n    get: function () {\n      return this._maximumMipmapLevel;\n    },\n  },\n  /**\n   * Determines if the texture atlas is complete and ready to use.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n  /**\n   * Gets a promise that resolves when the texture atlas is ready to use.\n   * @memberof OctahedralProjectedCubeMap.prototype\n   * @type {Promise<void>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\nOctahedralProjectedCubeMap.isSupported = function (context) {\n  return (\n    (context.colorBufferHalfFloat && context.halfFloatingPointTexture) ||\n    (context.floatingPointTexture && context.colorBufferFloat)\n  );\n};\n\n// These vertices are based on figure 1 from \"Octahedron Environment Maps\".\nconst v1 = new Cartesian3(1.0, 0.0, 0.0);\nconst v2 = new Cartesian3(0.0, 0.0, 1.0);\nconst v3 = new Cartesian3(-1.0, 0.0, 0.0);\nconst v4 = new Cartesian3(0.0, 0.0, -1.0);\nconst v5 = new Cartesian3(0.0, 1.0, 0.0);\nconst v6 = new Cartesian3(0.0, -1.0, 0.0);\n\n// top left, left, top, center, right, top right, bottom, bottom left, bottom right\nconst cubeMapCoordinates = [v5, v3, v2, v6, v1, v5, v4, v5, v5];\nconst length = cubeMapCoordinates.length;\nconst flatCubeMapCoordinates = new Float32Array(length * 3);\n\nlet offset = 0;\nfor (let i = 0; i < length; ++i, offset += 3) {\n  Cartesian3.pack(cubeMapCoordinates[i], flatCubeMapCoordinates, offset);\n}\n\nconst flatPositions = new Float32Array([\n  -1.0,\n  1.0, // top left\n  -1.0,\n  0.0, // left\n  0.0,\n  1.0, // top\n  0.0,\n  0.0, // center\n  1.0,\n  0.0, // right\n  1.0,\n  1.0, // top right\n  0.0,\n  -1.0, // bottom\n  -1.0,\n  -1.0, // bottom left\n  1.0,\n  -1.0, // bottom right\n]);\nconst indices = new Uint16Array([\n  0,\n  1,\n  2, // top left, left, top,\n  2,\n  3,\n  1, // top, center, left,\n  7,\n  6,\n  1, // bottom left, bottom, left,\n  3,\n  6,\n  1, // center, bottom, left,\n  2,\n  5,\n  4, // top, top right, right,\n  3,\n  4,\n  2, // center, right, top,\n  4,\n  8,\n  6, // right, bottom right, bottom,\n  3,\n  4,\n  6, //center, right, bottom\n]);\n\nfunction createVertexArray(context) {\n  const positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: flatPositions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const cubeMapCoordinatesBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: flatCubeMapCoordinates,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: indices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n  });\n\n  const attributes = [\n    {\n      index: 0,\n      vertexBuffer: positionBuffer,\n      componentsPerAttribute: 2,\n      componentDatatype: ComponentDatatype.FLOAT,\n    },\n    {\n      index: 1,\n      vertexBuffer: cubeMapCoordinatesBuffer,\n      componentsPerAttribute: 3,\n      componentDatatype: ComponentDatatype.FLOAT,\n    },\n  ];\n  return new VertexArray({\n    context: context,\n    attributes: attributes,\n    indexBuffer: indexBuffer,\n  });\n}\n\nfunction createUniformTexture(texture) {\n  return function () {\n    return texture;\n  };\n}\n\nfunction cleanupResources(map) {\n  map._va = map._va && map._va.destroy();\n  map._sp = map._sp && map._sp.destroy();\n\n  let i;\n  let length;\n\n  const cubeMaps = map._cubeMaps;\n  if (defined(cubeMaps)) {\n    length = cubeMaps.length;\n    for (i = 0; i < length; ++i) {\n      cubeMaps[i].destroy();\n    }\n  }\n  const mipTextures = map._mipTextures;\n  if (defined(mipTextures)) {\n    length = mipTextures.length;\n    for (i = 0; i < length; ++i) {\n      mipTextures[i].destroy();\n    }\n  }\n\n  map._va = undefined;\n  map._sp = undefined;\n  map._cubeMaps = undefined;\n  map._cubeMapBuffers = undefined;\n  map._mipTextures = undefined;\n}\n\n/**\n * Creates compute commands to generate octahedral projections of each cube map\n * and then renders them to an atlas.\n * <p>\n * Only needs to be called twice. The first call queues the compute commands to generate the atlas.\n * The second call cleans up unused resources. Every call afterwards is a no-op.\n * </p>\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nOctahedralProjectedCubeMap.prototype.update = function (frameState) {\n  const context = frameState.context;\n\n  if (!OctahedralProjectedCubeMap.isSupported(context)) {\n    return;\n  }\n\n  if (defined(this._texture) && defined(this._va)) {\n    cleanupResources(this);\n  }\n  if (defined(this._texture)) {\n    return;\n  }\n\n  if (!defined(this._texture) && !this._loading) {\n    const cachedTexture = context.textureCache.getTexture(this._url);\n    if (defined(cachedTexture)) {\n      cleanupResources(this);\n      this._texture = cachedTexture;\n      this._maximumMipmapLevel = this._texture.maximumMipmapLevel;\n      this._ready = true;\n      this._readyPromise.resolve();\n      return;\n    }\n  }\n\n  const cubeMapBuffers = this._cubeMapBuffers;\n  if (!defined(cubeMapBuffers) && !this._loading) {\n    const that = this;\n    loadKTX2(this._url)\n      .then(function (buffers) {\n        that._cubeMapBuffers = buffers;\n        that._loading = false;\n      })\n      .catch(function (e) {\n        that._readyPromise.reject(e);\n      });\n    this._loading = true;\n  }\n  if (!defined(this._cubeMapBuffers)) {\n    return;\n  }\n\n  const defines = [];\n  // Datatype is defined if it is a normalized type (i.e. ..._UNORM, ..._SFLOAT)\n  let pixelDatatype = cubeMapBuffers[0].positiveX.pixelDatatype;\n  if (!defined(pixelDatatype)) {\n    pixelDatatype = context.halfFloatingPointTexture\n      ? PixelDatatype.HALF_FLOAT\n      : PixelDatatype.FLOAT;\n  } else {\n    defines.push(\"RGBA_NORMALIZED\");\n  }\n  const pixelFormat = PixelFormat.RGBA;\n\n  const fs = new ShaderSource({\n    defines: defines,\n    sources: [OctahedralProjectionFS],\n  });\n\n  this._va = createVertexArray(context);\n  this._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: OctahedralProjectionVS,\n    fragmentShaderSource: fs,\n    attributeLocations: {\n      position: 0,\n      cubeMapCoordinates: 1,\n    },\n  });\n\n  // We only need up to 6 mip levels to avoid artifacts.\n  const length = Math.min(cubeMapBuffers.length, 6);\n  this._maximumMipmapLevel = length - 1;\n  const cubeMaps = (this._cubeMaps = new Array(length));\n  const mipTextures = (this._mipTextures = new Array(length));\n  const originalSize = cubeMapBuffers[0].positiveX.width * 2.0;\n  const uniformMap = {\n    originalSize: function () {\n      return originalSize;\n    },\n  };\n\n  // First we project each cubemap onto a flat octahedron, and write that to a texture.\n  for (let i = 0; i < length; ++i) {\n    // Swap +Y/-Y faces since the octahedral projection expects this order.\n    const positiveY = cubeMapBuffers[i].positiveY;\n    cubeMapBuffers[i].positiveY = cubeMapBuffers[i].negativeY;\n    cubeMapBuffers[i].negativeY = positiveY;\n\n    const cubeMap = (cubeMaps[i] = new CubeMap({\n      context: context,\n      source: cubeMapBuffers[i],\n      pixelDatatype: pixelDatatype,\n    }));\n    const size = cubeMaps[i].width * 2;\n\n    const mipTexture = (mipTextures[i] = new Texture({\n      context: context,\n      width: size,\n      height: size,\n      pixelDatatype: pixelDatatype,\n      pixelFormat: pixelFormat,\n    }));\n\n    const command = new ComputeCommand({\n      vertexArray: this._va,\n      shaderProgram: this._sp,\n      uniformMap: {\n        cubeMap: createUniformTexture(cubeMap),\n      },\n      outputTexture: mipTexture,\n      persists: true,\n      owner: this,\n    });\n    frameState.commandList.push(command);\n\n    uniformMap[`texture${i}`] = createUniformTexture(mipTexture);\n  }\n\n  this._texture = new Texture({\n    context: context,\n    width: originalSize * 1.5 + 2.0, // We add a 1 pixel border to avoid linear sampling artifacts.\n    height: originalSize,\n    pixelDatatype: pixelDatatype,\n    pixelFormat: pixelFormat,\n  });\n\n  this._texture.maximumMipmapLevel = this._maximumMipmapLevel;\n  context.textureCache.addTexture(this._url, this._texture);\n\n  const atlasCommand = new ComputeCommand({\n    fragmentShaderSource: OctahedralProjectionAtlasFS,\n    uniformMap: uniformMap,\n    outputTexture: this._texture,\n    persists: false,\n    owner: this,\n  });\n  frameState.commandList.push(atlasCommand);\n\n  this._ready = true;\n  this._readyPromise.resolve();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see OctahedralProjectedCubeMap#destroy\n */\nOctahedralProjectedCubeMap.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see OctahedralProjectedCubeMap#isDestroyed\n */\nOctahedralProjectedCubeMap.prototype.destroy = function () {\n  cleanupResources(this);\n  this._texture = this._texture && this._texture.destroy();\n  return destroyObject(this);\n};\nexport default OctahedralProjectedCubeMap;\n","import Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\n\nconst defaultCredit = new Credit(\n  \"MapQuest, Open Street Map and contributors, CC-BY-SA\"\n);\n\n/**\n * @typedef {Object} OpenStreetMapImageryProvider.ConstructorOptions\n *\n * Initialization options for the OpenStreetMapImageryProvider constructor\n *\n * @property {String} [url='https://a.tile.openstreetmap.org'] The OpenStreetMap server url.\n * @property {String} [fileExtension='png'] The file extension for images on the server.\n * @property {Rectangle} [rectangle=Rectangle.MAX_VALUE] The rectangle of the layer.\n * @property {Number} [minimumLevel=0] The minimum level-of-detail supported by the imagery provider.\n * @property {Number} [maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @property {Credit|String} [credit='MapQuest, Open Street Map and contributors, CC-BY-SA'] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * An imagery provider that provides tiled imagery hosted by OpenStreetMap\n * or another provider of Slippy tiles.  The default url connects to OpenStreetMap's volunteer-run\n * servers, so you must conform to their\n * {@link http://wiki.openstreetmap.org/wiki/Tile_usage_policy|Tile Usage Policy}.\n *\n * @alias OpenStreetMapImageryProvider\n * @constructor\n * @extends UrlTemplateImageryProvider\n *\n * @param {OpenStreetMapImageryProvider.ConstructorOptions} options Object describing initialization options\n * @exception {DeveloperError} The rectangle and minimumLevel indicate that there are more than four tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see SingleTileImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n *\n * @example\n * const osm = new Cesium.OpenStreetMapImageryProvider({\n *     url : 'https://a.tile.openstreetmap.org/'\n * });\n *\n * @see {@link http://wiki.openstreetmap.org/wiki/Main_Page|OpenStreetMap Wiki}\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nfunction OpenStreetMapImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const resource = Resource.createIfNeeded(\n    defaultValue(options.url, \"https://a.tile.openstreetmap.org/\")\n  );\n  resource.appendForwardSlash();\n  resource.url += `{z}/{x}/{y}.${defaultValue(options.fileExtension, \"png\")}`;\n\n  const tilingScheme = new WebMercatorTilingScheme({\n    ellipsoid: options.ellipsoid,\n  });\n\n  const tileWidth = 256;\n  const tileHeight = 256;\n\n  const minimumLevel = defaultValue(options.minimumLevel, 0);\n  const maximumLevel = options.maximumLevel;\n\n  const rectangle = defaultValue(options.rectangle, tilingScheme.rectangle);\n\n  // Check the number of tiles at the minimum level.  If it's more than four,\n  // throw an exception, because starting at the higher minimum\n  // level will cause too many tiles to be downloaded and rendered.\n  const swTile = tilingScheme.positionToTileXY(\n    Rectangle.southwest(rectangle),\n    minimumLevel\n  );\n  const neTile = tilingScheme.positionToTileXY(\n    Rectangle.northeast(rectangle),\n    minimumLevel\n  );\n  const tileCount =\n    (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);\n  //>>includeStart('debug', pragmas.debug);\n  if (tileCount > 4) {\n    throw new DeveloperError(\n      `The rectangle and minimumLevel indicate that there are ${tileCount} tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.`\n    );\n  }\n  //>>includeEnd('debug');\n\n  let credit = defaultValue(options.credit, defaultCredit);\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n\n  UrlTemplateImageryProvider.call(this, {\n    url: resource,\n    credit: credit,\n    tilingScheme: tilingScheme,\n    tileWidth: tileWidth,\n    tileHeight: tileHeight,\n    minimumLevel: minimumLevel,\n    maximumLevel: maximumLevel,\n    rectangle: rectangle,\n  });\n}\n\nif (defined(Object.create)) {\n  OpenStreetMapImageryProvider.prototype = Object.create(\n    UrlTemplateImageryProvider.prototype\n  );\n  OpenStreetMapImageryProvider.prototype.constructor = OpenStreetMapImageryProvider;\n}\n\nexport default OpenStreetMapImageryProvider;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport PrimitiveCollection from \"./PrimitiveCollection.js\";\n\n/**\n * A primitive collection for helping maintain the order or ground primitives based on a z-index\n *\n * @private\n */\nfunction OrderedGroundPrimitiveCollection() {\n  this._length = 0;\n  this._collections = {};\n  this._collectionsArray = [];\n\n  this.show = true;\n}\n\nObject.defineProperties(OrderedGroundPrimitiveCollection.prototype, {\n  /**\n   * Gets the number of primitives in the collection.\n   *\n   * @memberof OrderedGroundPrimitiveCollection.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n});\n\n/**\n * Adds a primitive to the collection.\n *\n * @param {GroundPrimitive} primitive The primitive to add.\n * @param {Number} [zIndex = 0] The index of the primitive\n * @returns {GroundPrimitive} The primitive added to the collection.\n */\nOrderedGroundPrimitiveCollection.prototype.add = function (primitive, zIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"primitive\", primitive);\n  if (defined(zIndex)) {\n    Check.typeOf.number(\"zIndex\", zIndex);\n  }\n  //>>includeEnd('debug');\n\n  zIndex = defaultValue(zIndex, 0);\n  let collection = this._collections[zIndex];\n  if (!defined(collection)) {\n    collection = new PrimitiveCollection({ destroyPrimitives: false });\n    collection._zIndex = zIndex;\n    this._collections[zIndex] = collection;\n    const array = this._collectionsArray;\n    let i = 0;\n    while (i < array.length && array[i]._zIndex < zIndex) {\n      i++;\n    }\n    array.splice(i, 0, collection);\n  }\n\n  collection.add(primitive);\n  this._length++;\n  primitive._zIndex = zIndex;\n\n  return primitive;\n};\n\n/**\n * Adjusts the z-index\n * @param {GroundPrimitive} primitive\n * @param {Number} zIndex\n */\nOrderedGroundPrimitiveCollection.prototype.set = function (primitive, zIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"primitive\", primitive);\n  Check.typeOf.number(\"zIndex\", zIndex);\n  //>>includeEnd('debug');\n\n  if (zIndex === primitive._zIndex) {\n    return primitive;\n  }\n\n  this.remove(primitive, true);\n  this.add(primitive, zIndex);\n\n  return primitive;\n};\n\n/**\n * Removes a primitive from the collection.\n *\n * @param {Object} primitive The primitive to remove.\n * @param {Boolean} [doNotDestroy = false]\n * @returns {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n */\nOrderedGroundPrimitiveCollection.prototype.remove = function (\n  primitive,\n  doNotDestroy\n) {\n  if (this.contains(primitive)) {\n    const index = primitive._zIndex;\n    const collection = this._collections[index];\n    let result;\n    if (doNotDestroy) {\n      result = collection.remove(primitive);\n    } else {\n      result = collection.removeAndDestroy(primitive);\n    }\n\n    if (result) {\n      this._length--;\n    }\n\n    if (collection.length === 0) {\n      this._collectionsArray.splice(\n        this._collectionsArray.indexOf(collection),\n        1\n      );\n      this._collections[index] = undefined;\n      collection.destroy();\n    }\n\n    return result;\n  }\n\n  return false;\n};\n\n/**\n * Removes all primitives in the collection.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see OrderedGroundPrimitiveCollection#destroyPrimitives\n */\nOrderedGroundPrimitiveCollection.prototype.removeAll = function () {\n  const collections = this._collectionsArray;\n  for (let i = 0; i < collections.length; i++) {\n    const collection = collections[i];\n    collection.destroyPrimitives = true;\n    collection.destroy();\n  }\n\n  this._collections = {};\n  this._collectionsArray = [];\n  this._length = 0;\n};\n\n/**\n * Determines if this collection contains a primitive.\n *\n * @param {Object} primitive The primitive to check for.\n * @returns {Boolean} <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n */\nOrderedGroundPrimitiveCollection.prototype.contains = function (primitive) {\n  if (!defined(primitive)) {\n    return false;\n  }\n  const collection = this._collections[primitive._zIndex];\n  return defined(collection) && collection.contains(primitive);\n};\n\n/**\n * @private\n */\nOrderedGroundPrimitiveCollection.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  const collections = this._collectionsArray;\n  for (let i = 0; i < collections.length; i++) {\n    collections[i].update(frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see OrderedGroundPrimitiveCollection#destroy\n */\nOrderedGroundPrimitiveCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this\n * collection allows for deterministic release of WebGL resources, instead of relying on the garbage\n * collector to destroy this collection.\n * <br /><br />\n * Since destroying a collection destroys all the contained primitives, only destroy a collection\n * when you are sure no other code is still using any of the contained primitives.\n * <br /><br />\n * Once this collection is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * primitives = primitives && primitives.destroy();\n *\n * @see OrderedGroundPrimitiveCollection#isDestroyed\n */\nOrderedGroundPrimitiveCollection.prototype.destroy = function () {\n  this.removeAll();\n  return destroyObject(this);\n};\nexport default OrderedGroundPrimitiveCollection;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\n\nconst defaultSize = new Cartesian2(1.0, 1.0);\n\n/**\n * A particle emitted by a {@link ParticleSystem}.\n *\n * @alias Particle\n * @constructor\n *\n * @param {Object} options An object with the following properties:\n * @param {Number} [options.mass=1.0] The mass of the particle in kilograms.\n * @param {Cartesian3} [options.position=Cartesian3.ZERO] The initial position of the particle in world coordinates.\n * @param {Cartesian3} [options.velocity=Cartesian3.ZERO] The velocity vector of the particle in world coordinates.\n * @param {Number} [options.life=Number.MAX_VALUE] The life of the particle in seconds.\n * @param {Object} [options.image] The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.\n * @param {Color} [options.startColor=Color.WHITE] The color of a particle when it is born.\n * @param {Color} [options.endColor=Color.WHITE] The color of a particle when it dies.\n * @param {Number} [options.startScale=1.0] The scale of the particle when it is born.\n * @param {Number} [options.endScale=1.0] The scale of the particle when it dies.\n * @param {Cartesian2} [options.imageSize=new Cartesian2(1.0, 1.0)] The dimensions, width by height, to scale the particle image in pixels.\n */\nfunction Particle(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The mass of the particle in kilograms.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.mass = defaultValue(options.mass, 1.0);\n  /**\n   * The positon of the particle in world coordinates.\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   */\n  this.position = Cartesian3.clone(\n    defaultValue(options.position, Cartesian3.ZERO)\n  );\n  /**\n   * The velocity of the particle in world coordinates.\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   */\n  this.velocity = Cartesian3.clone(\n    defaultValue(options.velocity, Cartesian3.ZERO)\n  );\n  /**\n   * The life of the particle in seconds.\n   * @type {Number}\n   * @default Number.MAX_VALUE\n   */\n  this.life = defaultValue(options.life, Number.MAX_VALUE);\n  /**\n   * The image to use for the particle.\n   * @type {Object}\n   * @default undefined\n   */\n  this.image = options.image;\n  /**\n   * The color of the particle when it is born.\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  this.startColor = Color.clone(defaultValue(options.startColor, Color.WHITE));\n  /**\n   * The color of the particle when it dies.\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  this.endColor = Color.clone(defaultValue(options.endColor, Color.WHITE));\n  /**\n   * the scale of the particle when it is born.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.startScale = defaultValue(options.startScale, 1.0);\n  /**\n   * The scale of the particle when it dies.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.endScale = defaultValue(options.endScale, 1.0);\n  /**\n   * The dimensions, width by height, to scale the particle image in pixels.\n   * @type {Cartesian2}\n   * @default new Cartesian(1.0, 1.0)\n   */\n  this.imageSize = Cartesian2.clone(\n    defaultValue(options.imageSize, defaultSize)\n  );\n\n  this._age = 0.0;\n  this._normalizedAge = 0.0;\n\n  // used by ParticleSystem\n  this._billboard = undefined;\n}\n\nObject.defineProperties(Particle.prototype, {\n  /**\n   * Gets the age of the particle in seconds.\n   * @memberof Particle.prototype\n   * @type {Number}\n   */\n  age: {\n    get: function () {\n      return this._age;\n    },\n  },\n  /**\n   * Gets the age normalized to a value in the range [0.0, 1.0].\n   * @memberof Particle.prototype\n   * @type {Number}\n   */\n  normalizedAge: {\n    get: function () {\n      return this._normalizedAge;\n    },\n  },\n});\n\nconst deltaScratch = new Cartesian3();\n\n/**\n * @private\n */\nParticle.prototype.update = function (dt, particleUpdateFunction) {\n  // Apply the velocity\n  Cartesian3.multiplyByScalar(this.velocity, dt, deltaScratch);\n  Cartesian3.add(this.position, deltaScratch, this.position);\n\n  // Update any forces.\n  if (defined(particleUpdateFunction)) {\n    particleUpdateFunction(this, dt);\n  }\n\n  // Age the particle\n  this._age += dt;\n\n  // Compute the normalized age.\n  if (this.life === Number.MAX_VALUE) {\n    this._normalizedAge = 0.0;\n  } else {\n    this._normalizedAge = this._age / this.life;\n  }\n\n  // If this particle is older than it's lifespan then die.\n  return this._age <= this.life;\n};\nexport default Particle;\n","import defaultValue from \"../Core/defaultValue.js\";\n\n/**\n * Represents a burst of {@link Particle}s from a {@link ParticleSystem} at a given time in the systems lifetime.\n *\n * @alias ParticleBurst\n * @constructor\n *\n * @param {Object} [options] An object with the following properties:\n * @param {Number} [options.time=0.0] The time in seconds after the beginning of the particle system's lifetime that the burst will occur.\n * @param {Number} [options.minimum=0.0] The minimum number of particles emmitted in the burst.\n * @param {Number} [options.maximum=50.0] The maximum number of particles emitted in the burst.\n */\nfunction ParticleBurst(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The time in seconds after the beginning of the particle system's lifetime that the burst will occur.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.time = defaultValue(options.time, 0.0);\n  /**\n   * The minimum number of particles emitted.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.minimum = defaultValue(options.minimum, 0.0);\n  /**\n   * The maximum number of particles emitted.\n   * @type {Number}\n   * @default 50.0\n   */\n  this.maximum = defaultValue(options.maximum, 50.0);\n\n  this._complete = false;\n}\n\nObject.defineProperties(ParticleBurst.prototype, {\n  /**\n   * <code>true</code> if the burst has been completed; <code>false</code> otherwise.\n   * @memberof ParticleBurst.prototype\n   * @type {Boolean}\n   */\n  complete: {\n    get: function () {\n      return this._complete;\n    },\n  },\n});\nexport default ParticleBurst;\n","import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * <p>\n * An object that initializes a {@link Particle} from a {@link ParticleSystem}.\n * </p>\n * <p>\n * This type describes an interface and is not intended to be instantiated directly.\n * </p>\n *\n * @alias ParticleEmitter\n * @constructor\n *\n * @see BoxEmitter\n * @see CircleEmitter\n * @see ConeEmitter\n * @see SphereEmitter\n */\nfunction ParticleEmitter(options) {\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    \"This type should not be instantiated directly.  Instead, use BoxEmitter, CircleEmitter, ConeEmitter or SphereEmitter.\"\n  );\n  //>>includeEnd('debug');\n}\n\n/**\n * Initializes the given {Particle} by setting it's position and velocity.\n *\n * @private\n * @param {Particle} The particle to initialize\n */\nParticleEmitter.prototype.emit = function (particle) {\n  DeveloperError.throwInstantiationError();\n};\nexport default ParticleEmitter;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport BillboardCollection from \"./BillboardCollection.js\";\nimport CircleEmitter from \"./CircleEmitter.js\";\nimport Particle from \"./Particle.js\";\n\nconst defaultImageSize = new Cartesian2(1.0, 1.0);\n\n/**\n * A ParticleSystem manages the updating and display of a collection of particles.\n *\n * @alias ParticleSystem\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.show=true] Whether to display the particle system.\n * @param {ParticleSystem.updateCallback} [options.updateCallback] The callback function to be called each frame to update a particle.\n * @param {ParticleEmitter} [options.emitter=new CircleEmitter(0.5)] The particle emitter for this system.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the particle system from model to world coordinates.\n * @param {Matrix4} [options.emitterModelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the particle system emitter within the particle systems local coordinate system.\n * @param {Number} [options.emissionRate=5] The number of particles to emit per second.\n * @param {ParticleBurst[]} [options.bursts] An array of {@link ParticleBurst}, emitting bursts of particles at periodic times.\n * @param {Boolean} [options.loop=true] Whether the particle system should loop its bursts when it is complete.\n * @param {Number} [options.scale=1.0] Sets the scale to apply to the image of the particle for the duration of its particleLife.\n * @param {Number} [options.startScale] The initial scale to apply to the image of the particle at the beginning of its life.\n * @param {Number} [options.endScale] The final scale to apply to the image of the particle at the end of its life.\n * @param {Color} [options.color=Color.WHITE] Sets the color of a particle for the duration of its particleLife.\n * @param {Color} [options.startColor] The color of the particle at the beginning of its life.\n * @param {Color} [options.endColor] The color of the particle at the end of its life.\n * @param {Object} [options.image] The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.\n * @param {Cartesian2} [options.imageSize=new Cartesian2(1.0, 1.0)] If set, overrides the minimumImageSize and maximumImageSize inputs that scale the particle image's dimensions in pixels.\n * @param {Cartesian2} [options.minimumImageSize] Sets the minimum bound, width by height, above which to randomly scale the particle image's dimensions in pixels.\n * @param {Cartesian2} [options.maximumImageSize] Sets the maximum bound, width by height, below which to randomly scale the particle image's dimensions in pixels.\n * @param {Boolean} [options.sizeInMeters] Sets if the size of particles is in meters or pixels. <code>true</code> to size the particles in meters; otherwise, the size is in pixels.\n * @param {Number} [options.speed=1.0] If set, overrides the minimumSpeed and maximumSpeed inputs with this value.\n * @param {Number} [options.minimumSpeed] Sets the minimum bound in meters per second above which a particle's actual speed will be randomly chosen.\n * @param {Number} [options.maximumSpeed] Sets the maximum bound in meters per second below which a particle's actual speed will be randomly chosen.\n * @param {Number} [options.lifetime=Number.MAX_VALUE] How long the particle system will emit particles, in seconds.\n * @param {Number} [options.particleLife=5.0] If set, overrides the minimumParticleLife and maximumParticleLife inputs with this value.\n * @param {Number} [options.minimumParticleLife] Sets the minimum bound in seconds for the possible duration of a particle's life above which a particle's actual life will be randomly chosen.\n * @param {Number} [options.maximumParticleLife] Sets the maximum bound in seconds for the possible duration of a particle's life below which a particle's actual life will be randomly chosen.\n * @param {Number} [options.mass=1.0] Sets the minimum and maximum mass of particles in kilograms.\n * @param {Number} [options.minimumMass] Sets the minimum bound for the mass of a particle in kilograms. A particle's actual mass will be chosen as a random amount above this value.\n * @param {Number} [options.maximumMass] Sets the maximum mass of particles in kilograms. A particle's actual mass will be chosen as a random amount below this value.\n * @demo {@link https://cesium.com/learn/cesiumjs-learn/cesiumjs-particle-systems/|Particle Systems Tutorial}\n * @demo {@link https://sandcastle.cesium.com/?src=Particle%20System.html&label=Showcases|Particle Systems Tutorial Demo}\n * @demo {@link https://sandcastle.cesium.com/?src=Particle%20System%20Fireworks.html&label=Showcases|Particle Systems Fireworks Demo}\n */\nfunction ParticleSystem(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * Whether to display the particle system.\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * An array of force callbacks. The callback is passed a {@link Particle} and the difference from the last time\n   * @type {ParticleSystem.updateCallback}\n   * @default undefined\n   */\n  this.updateCallback = options.updateCallback;\n\n  /**\n   * Whether the particle system should loop it's bursts when it is complete.\n   * @type {Boolean}\n   * @default true\n   */\n  this.loop = defaultValue(options.loop, true);\n\n  /**\n   * The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.\n   * @type {Object}\n   * @default undefined\n   */\n  this.image = defaultValue(options.image, undefined);\n\n  let emitter = options.emitter;\n  if (!defined(emitter)) {\n    emitter = new CircleEmitter(0.5);\n  }\n  this._emitter = emitter;\n\n  this._bursts = options.bursts;\n\n  this._modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._emitterModelMatrix = Matrix4.clone(\n    defaultValue(options.emitterModelMatrix, Matrix4.IDENTITY)\n  );\n  this._matrixDirty = true;\n  this._combinedMatrix = new Matrix4();\n\n  this._startColor = Color.clone(\n    defaultValue(options.color, defaultValue(options.startColor, Color.WHITE))\n  );\n  this._endColor = Color.clone(\n    defaultValue(options.color, defaultValue(options.endColor, Color.WHITE))\n  );\n\n  this._startScale = defaultValue(\n    options.scale,\n    defaultValue(options.startScale, 1.0)\n  );\n  this._endScale = defaultValue(\n    options.scale,\n    defaultValue(options.endScale, 1.0)\n  );\n\n  this._emissionRate = defaultValue(options.emissionRate, 5.0);\n\n  this._minimumSpeed = defaultValue(\n    options.speed,\n    defaultValue(options.minimumSpeed, 1.0)\n  );\n  this._maximumSpeed = defaultValue(\n    options.speed,\n    defaultValue(options.maximumSpeed, 1.0)\n  );\n\n  this._minimumParticleLife = defaultValue(\n    options.particleLife,\n    defaultValue(options.minimumParticleLife, 5.0)\n  );\n  this._maximumParticleLife = defaultValue(\n    options.particleLife,\n    defaultValue(options.maximumParticleLife, 5.0)\n  );\n\n  this._minimumMass = defaultValue(\n    options.mass,\n    defaultValue(options.minimumMass, 1.0)\n  );\n  this._maximumMass = defaultValue(\n    options.mass,\n    defaultValue(options.maximumMass, 1.0)\n  );\n\n  this._minimumImageSize = Cartesian2.clone(\n    defaultValue(\n      options.imageSize,\n      defaultValue(options.minimumImageSize, defaultImageSize)\n    )\n  );\n  this._maximumImageSize = Cartesian2.clone(\n    defaultValue(\n      options.imageSize,\n      defaultValue(options.maximumImageSize, defaultImageSize)\n    )\n  );\n\n  this._sizeInMeters = defaultValue(options.sizeInMeters, false);\n\n  this._lifetime = defaultValue(options.lifetime, Number.MAX_VALUE);\n\n  this._billboardCollection = undefined;\n  this._particles = [];\n\n  // An array of available particles that we can reuse instead of allocating new.\n  this._particlePool = [];\n\n  this._previousTime = undefined;\n  this._currentTime = 0.0;\n  this._carryOver = 0.0;\n\n  this._complete = new Event();\n  this._isComplete = false;\n\n  this._updateParticlePool = true;\n  this._particleEstimate = 0;\n}\n\nObject.defineProperties(ParticleSystem.prototype, {\n  /**\n   * The particle emitter for this\n   * @memberof ParticleSystem.prototype\n   * @type {ParticleEmitter}\n   * @default CircleEmitter\n   */\n  emitter: {\n    get: function () {\n      return this._emitter;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n      this._emitter = value;\n    },\n  },\n  /**\n   * An array of {@link ParticleBurst}, emitting bursts of particles at periodic times.\n   * @memberof ParticleSystem.prototype\n   * @type {ParticleBurst[]}\n   * @default undefined\n   */\n  bursts: {\n    get: function () {\n      return this._bursts;\n    },\n    set: function (value) {\n      this._bursts = value;\n      this._updateParticlePool = true;\n    },\n  },\n  /**\n   * The 4x4 transformation matrix that transforms the particle system from model to world coordinates.\n   * @memberof ParticleSystem.prototype\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n      this._matrixDirty =\n        this._matrixDirty || !Matrix4.equals(this._modelMatrix, value);\n      Matrix4.clone(value, this._modelMatrix);\n    },\n  },\n  /**\n   * The 4x4 transformation matrix that transforms the particle system emitter within the particle systems local coordinate system.\n   * @memberof ParticleSystem.prototype\n   * @type {Matrix4}\n   * @default Matrix4.IDENTITY\n   */\n  emitterModelMatrix: {\n    get: function () {\n      return this._emitterModelMatrix;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n      this._matrixDirty =\n        this._matrixDirty || !Matrix4.equals(this._emitterModelMatrix, value);\n      Matrix4.clone(value, this._emitterModelMatrix);\n    },\n  },\n  /**\n   * The color of the particle at the beginning of its life.\n   * @memberof ParticleSystem.prototype\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  startColor: {\n    get: function () {\n      return this._startColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n      Color.clone(value, this._startColor);\n    },\n  },\n  /**\n   * The color of the particle at the end of its life.\n   * @memberof ParticleSystem.prototype\n   * @type {Color}\n   * @default Color.WHITE\n   */\n  endColor: {\n    get: function () {\n      return this._endColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n      Color.clone(value, this._endColor);\n    },\n  },\n  /**\n   * The initial scale to apply to the image of the particle at the beginning of its life.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  startScale: {\n    get: function () {\n      return this._startScale;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._startScale = value;\n    },\n  },\n  /**\n   * The final scale to apply to the image of the particle at the end of its life.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  endScale: {\n    get: function () {\n      return this._endScale;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._endScale = value;\n    },\n  },\n  /**\n   * The number of particles to emit per second.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default 5\n   */\n  emissionRate: {\n    get: function () {\n      return this._emissionRate;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._emissionRate = value;\n      this._updateParticlePool = true;\n    },\n  },\n  /**\n   * Sets the minimum bound in meters per second above which a particle's actual speed will be randomly chosen.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  minimumSpeed: {\n    get: function () {\n      return this._minimumSpeed;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._minimumSpeed = value;\n    },\n  },\n  /**\n   * Sets the maximum bound in meters per second below which a particle's actual speed will be randomly chosen.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  maximumSpeed: {\n    get: function () {\n      return this._maximumSpeed;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._maximumSpeed = value;\n    },\n  },\n  /**\n   * Sets the minimum bound in seconds for the possible duration of a particle's life above which a particle's actual life will be randomly chosen.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default 5.0\n   */\n  minimumParticleLife: {\n    get: function () {\n      return this._minimumParticleLife;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._minimumParticleLife = value;\n    },\n  },\n  /**\n   * Sets the maximum bound in seconds for the possible duration of a particle's life below which a particle's actual life will be randomly chosen.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default 5.0\n   */\n  maximumParticleLife: {\n    get: function () {\n      return this._maximumParticleLife;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._maximumParticleLife = value;\n      this._updateParticlePool = true;\n    },\n  },\n  /**\n   * Sets the minimum mass of particles in kilograms.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  minimumMass: {\n    get: function () {\n      return this._minimumMass;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._minimumMass = value;\n    },\n  },\n  /**\n   * Sets the maximum mass of particles in kilograms.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  maximumMass: {\n    get: function () {\n      return this._maximumMass;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._maximumMass = value;\n    },\n  },\n  /**\n   * Sets the minimum bound, width by height, above which to randomly scale the particle image's dimensions in pixels.\n   * @memberof ParticleSystem.prototype\n   * @type {Cartesian2}\n   * @default new Cartesian2(1.0, 1.0)\n   */\n  minimumImageSize: {\n    get: function () {\n      return this._minimumImageSize;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      Check.typeOf.number.greaterThanOrEquals(\"value.x\", value.x, 0.0);\n      Check.typeOf.number.greaterThanOrEquals(\"value.y\", value.y, 0.0);\n      //>>includeEnd('debug');\n      this._minimumImageSize = value;\n    },\n  },\n  /**\n   * Sets the maximum bound, width by height, below which to randomly scale the particle image's dimensions in pixels.\n   * @memberof ParticleSystem.prototype\n   * @type {Cartesian2}\n   * @default new Cartesian2(1.0, 1.0)\n   */\n  maximumImageSize: {\n    get: function () {\n      return this._maximumImageSize;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"value\", value);\n      Check.typeOf.number.greaterThanOrEquals(\"value.x\", value.x, 0.0);\n      Check.typeOf.number.greaterThanOrEquals(\"value.y\", value.y, 0.0);\n      //>>includeEnd('debug');\n      this._maximumImageSize = value;\n    },\n  },\n  /**\n   * Gets or sets if the particle size is in meters or pixels. <code>true</code> to size particles in meters; otherwise, the size is in pixels.\n   * @memberof ParticleSystem.prototype\n   * @type {Boolean}\n   * @default false\n   */\n  sizeInMeters: {\n    get: function () {\n      return this._sizeInMeters;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"value\", value);\n      //>>includeEnd('debug');\n      this._sizeInMeters = value;\n    },\n  },\n  /**\n   * How long the particle system will emit particles, in seconds.\n   * @memberof ParticleSystem.prototype\n   * @type {Number}\n   * @default Number.MAX_VALUE\n   */\n  lifetime: {\n    get: function () {\n      return this._lifetime;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"value\", value, 0.0);\n      //>>includeEnd('debug');\n      this._lifetime = value;\n    },\n  },\n  /**\n   * Fires an event when the particle system has reached the end of its lifetime.\n   * @memberof ParticleSystem.prototype\n   * @type {Event}\n   */\n  complete: {\n    get: function () {\n      return this._complete;\n    },\n  },\n  /**\n   * When <code>true</code>, the particle system has reached the end of its lifetime; <code>false</code> otherwise.\n   * @memberof ParticleSystem.prototype\n   * @type {Boolean}\n   */\n  isComplete: {\n    get: function () {\n      return this._isComplete;\n    },\n  },\n});\n\nfunction updateParticlePool(system) {\n  const emissionRate = system._emissionRate;\n  const life = system._maximumParticleLife;\n\n  let burstAmount = 0;\n  const bursts = system._bursts;\n  if (defined(bursts)) {\n    const length = bursts.length;\n    for (let i = 0; i < length; ++i) {\n      burstAmount += bursts[i].maximum;\n    }\n  }\n\n  const billboardCollection = system._billboardCollection;\n  const image = system.image;\n\n  const particleEstimate = Math.ceil(emissionRate * life + burstAmount);\n  const particles = system._particles;\n  const particlePool = system._particlePool;\n  const numToAdd = Math.max(\n    particleEstimate - particles.length - particlePool.length,\n    0\n  );\n\n  for (let j = 0; j < numToAdd; ++j) {\n    const particle = new Particle();\n    particle._billboard = billboardCollection.add({\n      image: image,\n    });\n    particlePool.push(particle);\n  }\n\n  system._particleEstimate = particleEstimate;\n}\n\nfunction getOrCreateParticle(system) {\n  // Try to reuse an existing particle from the pool.\n  let particle = system._particlePool.pop();\n  if (!defined(particle)) {\n    // Create a new one\n    particle = new Particle();\n  }\n  return particle;\n}\n\nfunction addParticleToPool(system, particle) {\n  system._particlePool.push(particle);\n}\n\nfunction freeParticlePool(system) {\n  const particles = system._particles;\n  const particlePool = system._particlePool;\n  const billboardCollection = system._billboardCollection;\n\n  const numParticles = particles.length;\n  const numInPool = particlePool.length;\n  const estimate = system._particleEstimate;\n\n  const start = numInPool - Math.max(estimate - numParticles - numInPool, 0);\n  for (let i = start; i < numInPool; ++i) {\n    const p = particlePool[i];\n    billboardCollection.remove(p._billboard);\n  }\n  particlePool.length = start;\n}\n\nfunction removeBillboard(particle) {\n  if (defined(particle._billboard)) {\n    particle._billboard.show = false;\n  }\n}\n\nfunction updateBillboard(system, particle) {\n  let billboard = particle._billboard;\n  if (!defined(billboard)) {\n    billboard = particle._billboard = system._billboardCollection.add({\n      image: particle.image,\n    });\n  }\n  billboard.width = particle.imageSize.x;\n  billboard.height = particle.imageSize.y;\n  billboard.position = particle.position;\n  billboard.sizeInMeters = system.sizeInMeters;\n  billboard.show = true;\n\n  // Update the color\n  const r = CesiumMath.lerp(\n    particle.startColor.red,\n    particle.endColor.red,\n    particle.normalizedAge\n  );\n  const g = CesiumMath.lerp(\n    particle.startColor.green,\n    particle.endColor.green,\n    particle.normalizedAge\n  );\n  const b = CesiumMath.lerp(\n    particle.startColor.blue,\n    particle.endColor.blue,\n    particle.normalizedAge\n  );\n  const a = CesiumMath.lerp(\n    particle.startColor.alpha,\n    particle.endColor.alpha,\n    particle.normalizedAge\n  );\n  billboard.color = new Color(r, g, b, a);\n\n  // Update the scale\n  billboard.scale = CesiumMath.lerp(\n    particle.startScale,\n    particle.endScale,\n    particle.normalizedAge\n  );\n}\n\nfunction addParticle(system, particle) {\n  particle.startColor = Color.clone(system._startColor, particle.startColor);\n  particle.endColor = Color.clone(system._endColor, particle.endColor);\n  particle.startScale = system._startScale;\n  particle.endScale = system._endScale;\n  particle.image = system.image;\n  particle.life = CesiumMath.randomBetween(\n    system._minimumParticleLife,\n    system._maximumParticleLife\n  );\n  particle.mass = CesiumMath.randomBetween(\n    system._minimumMass,\n    system._maximumMass\n  );\n  particle.imageSize.x = CesiumMath.randomBetween(\n    system._minimumImageSize.x,\n    system._maximumImageSize.x\n  );\n  particle.imageSize.y = CesiumMath.randomBetween(\n    system._minimumImageSize.y,\n    system._maximumImageSize.y\n  );\n\n  // Reset the normalizedAge and age in case the particle was reused.\n  particle._normalizedAge = 0.0;\n  particle._age = 0.0;\n\n  const speed = CesiumMath.randomBetween(\n    system._minimumSpeed,\n    system._maximumSpeed\n  );\n  Cartesian3.multiplyByScalar(particle.velocity, speed, particle.velocity);\n\n  system._particles.push(particle);\n}\n\nfunction calculateNumberToEmit(system, dt) {\n  // This emitter is finished if it exceeds it's lifetime.\n  if (system._isComplete) {\n    return 0;\n  }\n\n  dt = CesiumMath.mod(dt, system._lifetime);\n\n  // Compute the number of particles to emit based on the emissionRate.\n  const v = dt * system._emissionRate;\n  let numToEmit = Math.floor(v);\n  system._carryOver += v - numToEmit;\n  if (system._carryOver > 1.0) {\n    numToEmit++;\n    system._carryOver -= 1.0;\n  }\n\n  // Apply any bursts\n  if (defined(system.bursts)) {\n    const length = system.bursts.length;\n    for (let i = 0; i < length; i++) {\n      const burst = system.bursts[i];\n      const currentTime = system._currentTime;\n      if (defined(burst) && !burst._complete && currentTime > burst.time) {\n        numToEmit += CesiumMath.randomBetween(burst.minimum, burst.maximum);\n        burst._complete = true;\n      }\n    }\n  }\n\n  return numToEmit;\n}\n\nconst rotatedVelocityScratch = new Cartesian3();\n\n/**\n * @private\n */\nParticleSystem.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (!defined(this._billboardCollection)) {\n    this._billboardCollection = new BillboardCollection();\n  }\n\n  if (this._updateParticlePool) {\n    updateParticlePool(this);\n    this._updateParticlePool = false;\n  }\n\n  // Compute the frame time\n  let dt = 0.0;\n  if (this._previousTime) {\n    dt = JulianDate.secondsDifference(frameState.time, this._previousTime);\n  }\n\n  if (dt < 0.0) {\n    dt = 0.0;\n  }\n\n  const particles = this._particles;\n  const emitter = this._emitter;\n  const updateCallback = this.updateCallback;\n\n  let i;\n  let particle;\n\n  // update particles and remove dead particles\n  let length = particles.length;\n  for (i = 0; i < length; ++i) {\n    particle = particles[i];\n    if (!particle.update(dt, updateCallback)) {\n      removeBillboard(particle);\n      // Add the particle back to the pool so it can be reused.\n      addParticleToPool(this, particle);\n      particles[i] = particles[length - 1];\n      --i;\n      --length;\n    } else {\n      updateBillboard(this, particle);\n    }\n  }\n  particles.length = length;\n\n  const numToEmit = calculateNumberToEmit(this, dt);\n\n  if (numToEmit > 0 && defined(emitter)) {\n    // Compute the final model matrix by combining the particle systems model matrix and the emitter matrix.\n    if (this._matrixDirty) {\n      this._combinedMatrix = Matrix4.multiply(\n        this.modelMatrix,\n        this.emitterModelMatrix,\n        this._combinedMatrix\n      );\n      this._matrixDirty = false;\n    }\n\n    const combinedMatrix = this._combinedMatrix;\n\n    for (i = 0; i < numToEmit; i++) {\n      // Create a new particle.\n      particle = getOrCreateParticle(this);\n\n      // Let the emitter initialize the particle.\n      this._emitter.emit(particle);\n\n      //For the velocity we need to add it to the original position and then multiply by point.\n      Cartesian3.add(\n        particle.position,\n        particle.velocity,\n        rotatedVelocityScratch\n      );\n      Matrix4.multiplyByPoint(\n        combinedMatrix,\n        rotatedVelocityScratch,\n        rotatedVelocityScratch\n      );\n\n      // Change the position to be in world coordinates\n      particle.position = Matrix4.multiplyByPoint(\n        combinedMatrix,\n        particle.position,\n        particle.position\n      );\n\n      // Orient the velocity in world space as well.\n      Cartesian3.subtract(\n        rotatedVelocityScratch,\n        particle.position,\n        particle.velocity\n      );\n      Cartesian3.normalize(particle.velocity, particle.velocity);\n\n      // Add the particle to the system.\n      addParticle(this, particle);\n      updateBillboard(this, particle);\n    }\n  }\n\n  this._billboardCollection.update(frameState);\n  this._previousTime = JulianDate.clone(frameState.time, this._previousTime);\n  this._currentTime += dt;\n\n  if (\n    this._lifetime !== Number.MAX_VALUE &&\n    this._currentTime > this._lifetime\n  ) {\n    if (this.loop) {\n      this._currentTime = CesiumMath.mod(this._currentTime, this._lifetime);\n      if (this.bursts) {\n        const burstLength = this.bursts.length;\n        // Reset any bursts\n        for (i = 0; i < burstLength; i++) {\n          this.bursts[i]._complete = false;\n        }\n      }\n    } else {\n      this._isComplete = true;\n      this._complete.raiseEvent(this);\n    }\n  }\n\n  // free particles in the pool and release billboard GPU memory\n  if (frameState.frameNumber % 120 === 0) {\n    freeParticlePool(this);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ParticleSystem#destroy\n */\nParticleSystem.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see ParticleSystem#isDestroyed\n */\nParticleSystem.prototype.destroy = function () {\n  this._billboardCollection =\n    this._billboardCollection && this._billboardCollection.destroy();\n  return destroyObject(this);\n};\n\n/**\n * A function used to modify attributes of the particle at each time step. This can include force modifications,\n * color, sizing, etc.\n *\n * @callback ParticleSystem.updateCallback\n *\n * @param {Particle} particle The particle being updated.\n * @param {Number} dt The time in seconds since the last update.\n *\n * @example\n * function applyGravity(particle, dt) {\n *    const position = particle.position;\n *    const gravityVector = Cesium.Cartesian3.normalize(position, new Cesium.Cartesian3());\n *    Cesium.Cartesian3.multiplyByScalar(gravityVector, GRAVITATIONAL_CONSTANT * dt, gravityVector);\n *    particle.velocity = Cesium.Cartesian3.add(particle.velocity, gravityVector, particle.velocity);\n * }\n */\nexport default ParticleSystem;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport PerInstanceColorAppearanceFS from \"../Shaders/Appearances/PerInstanceColorAppearanceFS.js\";\nimport PerInstanceColorAppearanceVS from \"../Shaders/Appearances/PerInstanceColorAppearanceVS.js\";\nimport PerInstanceFlatColorAppearanceFS from \"../Shaders/Appearances/PerInstanceFlatColorAppearanceFS.js\";\nimport PerInstanceFlatColorAppearanceVS from \"../Shaders/Appearances/PerInstanceFlatColorAppearanceVS.js\";\nimport Appearance from \"./Appearance.js\";\n\n/**\n * An appearance for {@link GeometryInstance} instances with color attributes.\n * This allows several geometry instances, each with a different color, to\n * be drawn with the same {@link Primitive} as shown in the second example below.\n *\n * @alias PerInstanceColorAppearance\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.\n * @param {Boolean} [options.faceForward=!options.closed] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.\n * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link PerInstanceColorAppearance#renderState} has alpha blending enabled.\n * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link PerInstanceColorAppearance#renderState} has backface culling enabled.\n * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n * @param {Object} [options.renderState] Optional render state to override the default render state.\n *\n * @example\n * // A solid white line segment\n * const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.SimplePolylineGeometry({\n *       positions : Cesium.Cartesian3.fromDegreesArray([\n *         0.0, 0.0,\n *         5.0, 0.0\n *       ])\n *     }),\n *     attributes : {\n *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))\n *     }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance({\n *     flat : true,\n *     translucent : false\n *   })\n * });\n *\n * // Two rectangles in a primitive, each with a different color\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0)\n *   }),\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 0.5)\n *   }\n * });\n *\n * const anotherInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 40.0, 10.0, 50.0)\n *   }),\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 0.0, 1.0, 0.5)\n *   }\n * });\n *\n * const rectanglePrimitive = new Cesium.Primitive({\n *   geometryInstances : [instance, anotherInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * });\n */\nfunction PerInstanceColorAppearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const translucent = defaultValue(options.translucent, true);\n  const closed = defaultValue(options.closed, false);\n  const flat = defaultValue(options.flat, false);\n  const vs = flat\n    ? PerInstanceFlatColorAppearanceVS\n    : PerInstanceColorAppearanceVS;\n  const fs = flat\n    ? PerInstanceFlatColorAppearanceFS\n    : PerInstanceColorAppearanceFS;\n  const vertexFormat = flat\n    ? PerInstanceColorAppearance.FLAT_VERTEX_FORMAT\n    : PerInstanceColorAppearance.VERTEX_FORMAT;\n\n  /**\n   * This property is part of the {@link Appearance} interface, but is not\n   * used by {@link PerInstanceColorAppearance} since a fully custom fragment shader is used.\n   *\n   * @type Material\n   *\n   * @default undefined\n   */\n  this.material = undefined;\n\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent so\n   * {@link PerInstanceColorAppearance#renderState} has alpha blending enabled.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.translucent = translucent;\n\n  this._vertexShaderSource = defaultValue(options.vertexShaderSource, vs);\n  this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, fs);\n  this._renderState = Appearance.getDefaultRenderState(\n    translucent,\n    closed,\n    options.renderState\n  );\n  this._closed = closed;\n\n  // Non-derived members\n\n  this._vertexFormat = vertexFormat;\n  this._flat = flat;\n  this._faceForward = defaultValue(options.faceForward, !closed);\n}\n\nObject.defineProperties(PerInstanceColorAppearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof PerInstanceColorAppearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    },\n  },\n\n  /**\n   * The GLSL source code for the fragment shader.\n   *\n   * @memberof PerInstanceColorAppearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   * <p>\n   * The render state can be explicitly defined when constructing a {@link PerInstanceColorAppearance}\n   * instance, or it is set implicitly via {@link PerInstanceColorAppearance#translucent}\n   * and {@link PerInstanceColorAppearance#closed}.\n   * </p>\n   *\n   * @memberof PerInstanceColorAppearance.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be closed so\n   * {@link PerInstanceColorAppearance#renderState} has backface culling enabled.\n   * If the viewer enters the geometry, it will not be visible.\n   *\n   * @memberof PerInstanceColorAppearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    },\n  },\n\n  /**\n   * The {@link VertexFormat} that this appearance instance is compatible with.\n   * A geometry can have more vertex attributes and still be compatible - at a\n   * potential performance cost - but it can't have less.\n   *\n   * @memberof PerInstanceColorAppearance.prototype\n   *\n   * @type VertexFormat\n   * @readonly\n   */\n  vertexFormat: {\n    get: function () {\n      return this._vertexFormat;\n    },\n  },\n\n  /**\n   * When <code>true</code>, flat shading is used in the fragment shader,\n   * which means lighting is not taking into account.\n   *\n   * @memberof PerInstanceColorAppearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  flat: {\n    get: function () {\n      return this._flat;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the fragment shader flips the surface normal\n   * as needed to ensure that the normal faces the viewer to avoid\n   * dark spots.  This is useful when both sides of a geometry should be\n   * shaded like {@link WallGeometry}.\n   *\n   * @memberof PerInstanceColorAppearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  faceForward: {\n    get: function () {\n      return this._faceForward;\n    },\n  },\n});\n\n/**\n * The {@link VertexFormat} that all {@link PerInstanceColorAppearance} instances\n * are compatible with.  This requires only <code>position</code> and <code>normal</code>\n * attributes.\n *\n * @type VertexFormat\n *\n * @constant\n */\nPerInstanceColorAppearance.VERTEX_FORMAT = VertexFormat.POSITION_AND_NORMAL;\n\n/**\n * The {@link VertexFormat} that all {@link PerInstanceColorAppearance} instances\n * are compatible with when {@link PerInstanceColorAppearance#flat} is <code>true</code>.\n * This requires only a <code>position</code> attribute.\n *\n * @type VertexFormat\n *\n * @constant\n */\nPerInstanceColorAppearance.FLAT_VERTEX_FORMAT = VertexFormat.POSITION_ONLY;\n\n/**\n * Procedurally creates the full GLSL fragment shader source.  For {@link PerInstanceColorAppearance},\n * this is derived from {@link PerInstanceColorAppearance#fragmentShaderSource}, {@link PerInstanceColorAppearance#flat},\n * and {@link PerInstanceColorAppearance#faceForward}.\n *\n * @function\n *\n * @returns {String} The full GLSL fragment shader source.\n */\nPerInstanceColorAppearance.prototype.getFragmentShaderSource =\n  Appearance.prototype.getFragmentShaderSource;\n\n/**\n * Determines if the geometry is translucent based on {@link PerInstanceColorAppearance#translucent}.\n *\n * @function\n *\n * @returns {Boolean} <code>true</code> if the appearance is translucent.\n */\nPerInstanceColorAppearance.prototype.isTranslucent =\n  Appearance.prototype.isTranslucent;\n\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @function\n *\n * @returns {Object} The render state.\n */\nPerInstanceColorAppearance.prototype.getRenderState =\n  Appearance.prototype.getRenderState;\nexport default PerInstanceColorAppearance;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport getElement from \"../Widgets/getElement.js\";\n\n/**\n * @private\n */\nfunction PerformanceDisplay(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const container = getElement(options.container);\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(container)) {\n    throw new DeveloperError(\"container is required\");\n  }\n  //>>includeEnd('debug');\n\n  this._container = container;\n\n  const display = document.createElement(\"div\");\n  display.className = \"cesium-performanceDisplay\";\n  const fpsElement = document.createElement(\"div\");\n  fpsElement.className = \"cesium-performanceDisplay-fps\";\n  this._fpsText = document.createTextNode(\"\");\n  fpsElement.appendChild(this._fpsText);\n  const msElement = document.createElement(\"div\");\n  msElement.className = \"cesium-performanceDisplay-ms\";\n  this._msText = document.createTextNode(\"\");\n  msElement.appendChild(this._msText);\n  display.appendChild(msElement);\n  display.appendChild(fpsElement);\n  this._container.appendChild(display);\n\n  this._lastFpsSampleTime = getTimestamp();\n  this._lastMsSampleTime = getTimestamp();\n  this._fpsFrameCount = 0;\n  this._msFrameCount = 0;\n\n  this._throttled = false;\n  const throttledElement = document.createElement(\"div\");\n  throttledElement.className = \"cesium-performanceDisplay-throttled\";\n  this._throttledText = document.createTextNode(\"\");\n  throttledElement.appendChild(this._throttledText);\n  display.appendChild(throttledElement);\n}\n\nObject.defineProperties(PerformanceDisplay.prototype, {\n  /**\n   * The display should indicate the FPS is being throttled.\n   * @memberof PerformanceDisplay.prototype\n   *\n   * @type {Boolean}\n   */\n  throttled: {\n    get: function () {\n      return this._throttled;\n    },\n    set: function (value) {\n      if (this._throttled === value) {\n        return;\n      }\n\n      if (value) {\n        this._throttledText.nodeValue = \"(throttled)\";\n      } else {\n        this._throttledText.nodeValue = \"\";\n      }\n\n      this._throttled = value;\n    },\n  },\n});\n\n/**\n * Update the display.  This function should only be called once per frame, because\n * each call records a frame in the internal buffer and redraws the display.\n *\n * @param {Boolean} [renderedThisFrame=true] If provided, the FPS count will only update and display if true.\n */\nPerformanceDisplay.prototype.update = function (renderedThisFrame) {\n  const time = getTimestamp();\n  const updateDisplay = defaultValue(renderedThisFrame, true);\n\n  this._fpsFrameCount++;\n  const fpsElapsedTime = time - this._lastFpsSampleTime;\n  if (fpsElapsedTime > 1000) {\n    let fps = \"N/A\";\n    if (updateDisplay) {\n      fps = ((this._fpsFrameCount * 1000) / fpsElapsedTime) | 0;\n    }\n\n    this._fpsText.nodeValue = `${fps} FPS`;\n    this._lastFpsSampleTime = time;\n    this._fpsFrameCount = 0;\n  }\n\n  this._msFrameCount++;\n  const msElapsedTime = time - this._lastMsSampleTime;\n  if (msElapsedTime > 200) {\n    let ms = \"N/A\";\n    if (updateDisplay) {\n      ms = (msElapsedTime / this._msFrameCount).toFixed(2);\n    }\n\n    this._msText.nodeValue = `${ms} MS`;\n    this._lastMsSampleTime = time;\n    this._msFrameCount = 0;\n  }\n};\n\n/**\n * Destroys the WebGL resources held by this object.\n */\nPerformanceDisplay.prototype.destroy = function () {\n  return destroyObject(this);\n};\nexport default PerformanceDisplay;\n","import Cartesian4 from \"../Core/Cartesian4.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\n\n/**\n * @private\n */\nfunction PickDepth() {\n  this._framebuffer = new FramebufferManager();\n\n  this._textureToCopy = undefined;\n  this._copyDepthCommand = undefined;\n}\n\nObject.defineProperties(PickDepth.prototype, {\n  framebuffer: {\n    get: function () {\n      return this._framebuffer.framebuffer;\n    },\n  },\n});\n\nfunction updateFramebuffers(pickDepth, context, depthTexture) {\n  const width = depthTexture.width;\n  const height = depthTexture.height;\n  pickDepth._framebuffer.update(context, width, height);\n}\n\nfunction updateCopyCommands(pickDepth, context, depthTexture) {\n  if (!defined(pickDepth._copyDepthCommand)) {\n    const fs =\n      \"uniform highp sampler2D u_texture;\\n\" +\n      \"varying vec2 v_textureCoordinates;\\n\" +\n      \"void main()\\n\" +\n      \"{\\n\" +\n      \"    gl_FragColor = czm_packDepth(texture2D(u_texture, v_textureCoordinates).r);\\n\" +\n      \"}\\n\";\n    pickDepth._copyDepthCommand = context.createViewportQuadCommand(fs, {\n      renderState: RenderState.fromCache(),\n      uniformMap: {\n        u_texture: function () {\n          return pickDepth._textureToCopy;\n        },\n      },\n      owner: pickDepth,\n    });\n  }\n\n  pickDepth._textureToCopy = depthTexture;\n  pickDepth._copyDepthCommand.framebuffer = pickDepth.framebuffer;\n}\n\nPickDepth.prototype.update = function (context, depthTexture) {\n  updateFramebuffers(this, context, depthTexture);\n  updateCopyCommands(this, context, depthTexture);\n};\n\nconst scratchPackedDepth = new Cartesian4();\nconst packedDepthScale = new Cartesian4(\n  1.0,\n  1.0 / 255.0,\n  1.0 / 65025.0,\n  1.0 / 16581375.0\n);\n\nPickDepth.prototype.getDepth = function (context, x, y) {\n  // If this function is called before the framebuffer is created, the depth is undefined.\n  if (!defined(this.framebuffer)) {\n    return undefined;\n  }\n\n  const pixels = context.readPixels({\n    x: x,\n    y: y,\n    width: 1,\n    height: 1,\n    framebuffer: this.framebuffer,\n  });\n\n  const packedDepth = Cartesian4.unpack(pixels, 0, scratchPackedDepth);\n  Cartesian4.divideByScalar(packedDepth, 255.0, packedDepth);\n  return Cartesian4.dot(packedDepth, packedDepthScale);\n};\n\nPickDepth.prototype.executeCopyDepth = function (context, passState) {\n  this._copyDepthCommand.execute(context, passState);\n};\n\nPickDepth.prototype.isDestroyed = function () {\n  return false;\n};\n\nPickDepth.prototype.destroy = function () {\n  this._framebuffer.destroy();\n  if (defined(this._copyDepthCommand)) {\n    this._copyDepthCommand.shaderProgram =\n      defined(this._copyDepthCommand.shaderProgram) &&\n      this._copyDepthCommand.shaderProgram.destroy();\n  }\n\n  return destroyObject(this);\n};\nexport default PickDepth;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PassState from \"../Renderer/PassState.js\";\n\n/**\n * @private\n */\nfunction PickDepthFramebuffer() {\n  this._framebuffer = new FramebufferManager({\n    color: false,\n    depthStencil: true,\n    supportsDepthTexture: true,\n  });\n  this._passState = undefined;\n}\n\nObject.defineProperties(PickDepthFramebuffer.prototype, {\n  framebuffer: {\n    get: function () {\n      return this._framebuffer.framebuffer;\n    },\n  },\n});\n\nfunction destroyResources(pickDepth) {\n  pickDepth._framebuffer.destroy();\n}\n\nfunction createResources(pickDepth, context) {\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n\n  pickDepth._framebuffer.update(context, width, height);\n\n  const passState = new PassState(context);\n  passState.blendingEnabled = false;\n  passState.scissorTest = {\n    enabled: true,\n    rectangle: new BoundingRectangle(),\n  };\n  passState.viewport = new BoundingRectangle();\n  pickDepth._passState = passState;\n}\n\nPickDepthFramebuffer.prototype.update = function (\n  context,\n  drawingBufferPosition,\n  viewport\n) {\n  const width = viewport.width;\n  const height = viewport.height;\n\n  if (this._framebuffer.isDirty(width, height)) {\n    createResources(this, context);\n  }\n\n  const framebuffer = this.framebuffer;\n  const passState = this._passState;\n  passState.framebuffer = framebuffer;\n  passState.viewport.width = width;\n  passState.viewport.height = height;\n  passState.scissorTest.rectangle.x = drawingBufferPosition.x;\n  passState.scissorTest.rectangle.y = height - drawingBufferPosition.y;\n  passState.scissorTest.rectangle.width = 1;\n  passState.scissorTest.rectangle.height = 1;\n\n  return passState;\n};\n\nPickDepthFramebuffer.prototype.isDestroyed = function () {\n  return false;\n};\n\nPickDepthFramebuffer.prototype.destroy = function () {\n  destroyResources(this);\n  return destroyObject(this);\n};\nexport default PickDepthFramebuffer;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PassState from \"../Renderer/PassState.js\";\n\n/**\n * @private\n */\nfunction PickFramebuffer(context) {\n  // Override per-command states\n  const passState = new PassState(context);\n  passState.blendingEnabled = false;\n  passState.scissorTest = {\n    enabled: true,\n    rectangle: new BoundingRectangle(),\n  };\n  passState.viewport = new BoundingRectangle();\n\n  this._context = context;\n  this._fb = new FramebufferManager({\n    depthStencil: true,\n  });\n  this._passState = passState;\n  this._width = 0;\n  this._height = 0;\n}\nPickFramebuffer.prototype.begin = function (screenSpaceRectangle, viewport) {\n  const context = this._context;\n  const width = viewport.width;\n  const height = viewport.height;\n\n  BoundingRectangle.clone(\n    screenSpaceRectangle,\n    this._passState.scissorTest.rectangle\n  );\n\n  // Create or recreate renderbuffers and framebuffer used for picking\n  this._width = width;\n  this._height = height;\n  this._fb.update(context, width, height);\n  this._passState.framebuffer = this._fb.framebuffer;\n\n  this._passState.viewport.width = width;\n  this._passState.viewport.height = height;\n\n  return this._passState;\n};\n\nconst colorScratch = new Color();\n\nPickFramebuffer.prototype.end = function (screenSpaceRectangle) {\n  const width = defaultValue(screenSpaceRectangle.width, 1.0);\n  const height = defaultValue(screenSpaceRectangle.height, 1.0);\n\n  const context = this._context;\n  const pixels = context.readPixels({\n    x: screenSpaceRectangle.x,\n    y: screenSpaceRectangle.y,\n    width: width,\n    height: height,\n    framebuffer: this._fb.framebuffer,\n  });\n\n  const max = Math.max(width, height);\n  const length = max * max;\n  const halfWidth = Math.floor(width * 0.5);\n  const halfHeight = Math.floor(height * 0.5);\n\n  let x = 0;\n  let y = 0;\n  let dx = 0;\n  let dy = -1;\n\n  // Spiral around the center pixel, this is a workaround until\n  // we can access the depth buffer on all browsers.\n\n  // The region does not have to square and the dimensions do not have to be odd, but\n  // loop iterations would be wasted. Prefer square regions where the size is odd.\n  for (let i = 0; i < length; ++i) {\n    if (\n      -halfWidth <= x &&\n      x <= halfWidth &&\n      -halfHeight <= y &&\n      y <= halfHeight\n    ) {\n      const index = 4 * ((halfHeight - y) * width + x + halfWidth);\n\n      colorScratch.red = Color.byteToFloat(pixels[index]);\n      colorScratch.green = Color.byteToFloat(pixels[index + 1]);\n      colorScratch.blue = Color.byteToFloat(pixels[index + 2]);\n      colorScratch.alpha = Color.byteToFloat(pixels[index + 3]);\n\n      const object = context.getObjectByPickColor(colorScratch);\n      if (defined(object)) {\n        return object;\n      }\n    }\n\n    // if (top right || bottom left corners) || (top left corner) || (bottom right corner + (1, 0))\n    // change spiral direction\n    if (x === y || (x < 0 && -x === y) || (x > 0 && x === 1 - y)) {\n      const temp = dx;\n      dx = -dy;\n      dy = temp;\n    }\n\n    x += dx;\n    y += dy;\n  }\n\n  return undefined;\n};\n\nPickFramebuffer.prototype.isDestroyed = function () {\n  return false;\n};\n\nPickFramebuffer.prototype.destroy = function () {\n  this._fb.destroy();\n  return destroyObject(this);\n};\nexport default PickFramebuffer;\n","import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport PerspectiveOffCenterFrustum from \"../Core/PerspectiveOffCenterFrustum.js\";\nimport Ray from \"../Core/Ray.js\";\nimport ShowGeometryInstanceAttribute from \"../Core/ShowGeometryInstanceAttribute.js\";\nimport Camera from \"./Camera.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport Cesium3DTilePass from \"./Cesium3DTilePass.js\";\nimport Cesium3DTilePassState from \"./Cesium3DTilePassState.js\";\nimport PickDepth from \"./PickDepth.js\";\nimport PrimitiveCollection from \"./PrimitiveCollection.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport View from \"./View.js\";\n\nconst offscreenDefaultWidth = 0.1;\n\nconst mostDetailedPreloadTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PRELOAD,\n});\n\nconst mostDetailedPickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.MOST_DETAILED_PICK,\n});\n\nconst pickTilesetPassState = new Cesium3DTilePassState({\n  pass: Cesium3DTilePass.PICK,\n});\n\n/**\n * @private\n */\nfunction Picking(scene) {\n  this._mostDetailedRayPicks = [];\n  this.pickRenderStateCache = {};\n  this._pickPositionCache = {};\n  this._pickPositionCacheDirty = false;\n\n  const pickOffscreenViewport = new BoundingRectangle(0, 0, 1, 1);\n  const pickOffscreenCamera = new Camera(scene);\n  pickOffscreenCamera.frustum = new OrthographicFrustum({\n    width: offscreenDefaultWidth,\n    aspectRatio: 1.0,\n    near: 0.1,\n  });\n\n  this._pickOffscreenView = new View(\n    scene,\n    pickOffscreenCamera,\n    pickOffscreenViewport\n  );\n}\n\nPicking.prototype.update = function () {\n  this._pickPositionCacheDirty = true;\n};\n\nPicking.prototype.getPickDepth = function (scene, index) {\n  const pickDepths = scene.view.pickDepths;\n  let pickDepth = pickDepths[index];\n  if (!defined(pickDepth)) {\n    pickDepth = new PickDepth();\n    pickDepths[index] = pickDepth;\n  }\n  return pickDepth;\n};\n\nconst scratchOrthoPickingFrustum = new OrthographicOffCenterFrustum();\nconst scratchOrthoOrigin = new Cartesian3();\nconst scratchOrthoDirection = new Cartesian3();\nconst scratchOrthoPixelSize = new Cartesian2();\nconst scratchOrthoPickVolumeMatrix4 = new Matrix4();\n\nfunction getPickOrthographicCullingVolume(\n  scene,\n  drawingBufferPosition,\n  width,\n  height,\n  viewport\n) {\n  const camera = scene.camera;\n  let frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  let x = (2.0 * (drawingBufferPosition.x - viewport.x)) / viewport.width - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  let y =\n    (2.0 * (viewport.height - drawingBufferPosition.y - viewport.y)) /\n      viewport.height -\n    1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n\n  const transform = Matrix4.clone(\n    camera.transform,\n    scratchOrthoPickVolumeMatrix4\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  const origin = Cartesian3.clone(camera.position, scratchOrthoOrigin);\n  Cartesian3.multiplyByScalar(camera.right, x, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchOrthoDirection);\n  Cartesian3.add(scratchOrthoDirection, origin, origin);\n\n  camera._setTransform(transform);\n\n  if (scene.mode === SceneMode.SCENE2D) {\n    Cartesian3.fromElements(origin.z, origin.x, origin.y, origin);\n  }\n\n  const pixelSize = frustum.getPixelDimensions(\n    viewport.width,\n    viewport.height,\n    1.0,\n    1.0,\n    scratchOrthoPixelSize\n  );\n\n  const ortho = scratchOrthoPickingFrustum;\n  ortho.right = pixelSize.x * 0.5;\n  ortho.left = -ortho.right;\n  ortho.top = pixelSize.y * 0.5;\n  ortho.bottom = -ortho.top;\n  ortho.near = frustum.near;\n  ortho.far = frustum.far;\n\n  return ortho.computeCullingVolume(origin, camera.directionWC, camera.upWC);\n}\n\nconst scratchPerspPickingFrustum = new PerspectiveOffCenterFrustum();\nconst scratchPerspPixelSize = new Cartesian2();\n\nfunction getPickPerspectiveCullingVolume(\n  scene,\n  drawingBufferPosition,\n  width,\n  height,\n  viewport\n) {\n  const camera = scene.camera;\n  const frustum = camera.frustum;\n  const near = frustum.near;\n\n  const tanPhi = Math.tan(frustum.fovy * 0.5);\n  const tanTheta = frustum.aspectRatio * tanPhi;\n\n  const x =\n    (2.0 * (drawingBufferPosition.x - viewport.x)) / viewport.width - 1.0;\n  const y =\n    (2.0 * (viewport.height - drawingBufferPosition.y - viewport.y)) /\n      viewport.height -\n    1.0;\n\n  const xDir = x * near * tanTheta;\n  const yDir = y * near * tanPhi;\n\n  const pixelSize = frustum.getPixelDimensions(\n    viewport.width,\n    viewport.height,\n    1.0,\n    1.0,\n    scratchPerspPixelSize\n  );\n  const pickWidth = pixelSize.x * width * 0.5;\n  const pickHeight = pixelSize.y * height * 0.5;\n\n  const offCenter = scratchPerspPickingFrustum;\n  offCenter.top = yDir + pickHeight;\n  offCenter.bottom = yDir - pickHeight;\n  offCenter.right = xDir + pickWidth;\n  offCenter.left = xDir - pickWidth;\n  offCenter.near = near;\n  offCenter.far = frustum.far;\n\n  return offCenter.computeCullingVolume(\n    camera.positionWC,\n    camera.directionWC,\n    camera.upWC\n  );\n}\n\nfunction getPickCullingVolume(\n  scene,\n  drawingBufferPosition,\n  width,\n  height,\n  viewport\n) {\n  const frustum = scene.camera.frustum;\n  if (\n    frustum instanceof OrthographicFrustum ||\n    frustum instanceof OrthographicOffCenterFrustum\n  ) {\n    return getPickOrthographicCullingVolume(\n      scene,\n      drawingBufferPosition,\n      width,\n      height,\n      viewport\n    );\n  }\n\n  return getPickPerspectiveCullingVolume(\n    scene,\n    drawingBufferPosition,\n    width,\n    height,\n    viewport\n  );\n}\n\n// pick rectangle width and height, assumed odd\nlet scratchRectangleWidth = 3.0;\nlet scratchRectangleHeight = 3.0;\nlet scratchRectangle = new BoundingRectangle(\n  0.0,\n  0.0,\n  scratchRectangleWidth,\n  scratchRectangleHeight\n);\nconst scratchPosition = new Cartesian2();\nconst scratchColorZero = new Color(0.0, 0.0, 0.0, 0.0);\n\nPicking.prototype.pick = function (scene, windowPosition, width, height) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is undefined.\");\n  }\n  //>>includeEnd('debug');\n\n  scratchRectangleWidth = defaultValue(width, 3.0);\n  scratchRectangleHeight = defaultValue(height, scratchRectangleWidth);\n\n  const context = scene.context;\n  const us = context.uniformState;\n  const frameState = scene.frameState;\n\n  const view = scene.defaultView;\n  scene.view = view;\n\n  const viewport = view.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  let passState = view.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(\n    scene,\n    windowPosition,\n    scratchPosition\n  );\n\n  scene.jobScheduler.disableThisFrame();\n\n  scene.updateFrameState();\n  frameState.cullingVolume = getPickCullingVolume(\n    scene,\n    drawingBufferPosition,\n    scratchRectangleWidth,\n    scratchRectangleHeight,\n    viewport\n  );\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.tilesetPassState = pickTilesetPassState;\n\n  us.update(frameState);\n\n  scene.updateEnvironment();\n\n  scratchRectangle.x =\n    drawingBufferPosition.x - (scratchRectangleWidth - 1.0) * 0.5;\n  scratchRectangle.y =\n    scene.drawingBufferHeight -\n    drawingBufferPosition.y -\n    (scratchRectangleHeight - 1.0) * 0.5;\n  scratchRectangle.width = scratchRectangleWidth;\n  scratchRectangle.height = scratchRectangleHeight;\n  passState = view.pickFramebuffer.begin(scratchRectangle, view.viewport);\n\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  const object = view.pickFramebuffer.end(scratchRectangle);\n  context.endFrame();\n  return object;\n};\n\nfunction renderTranslucentDepthForPick(scene, drawingBufferPosition) {\n  // PERFORMANCE_IDEA: render translucent only and merge with the previous frame\n  const context = scene.context;\n  const frameState = scene.frameState;\n  const environmentState = scene.environmentState;\n\n  const view = scene.defaultView;\n  scene.view = view;\n\n  const viewport = view.viewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = context.drawingBufferWidth;\n  viewport.height = context.drawingBufferHeight;\n\n  let passState = view.passState;\n  passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);\n\n  scene.clearPasses(frameState.passes);\n  frameState.passes.pick = true;\n  frameState.passes.depth = true;\n  frameState.cullingVolume = getPickCullingVolume(\n    scene,\n    drawingBufferPosition,\n    1,\n    1,\n    viewport\n  );\n  frameState.tilesetPassState = pickTilesetPassState;\n\n  scene.updateEnvironment();\n  environmentState.renderTranslucentDepthForPick = true;\n  passState = view.pickDepthFramebuffer.update(\n    context,\n    drawingBufferPosition,\n    viewport\n  );\n\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  context.endFrame();\n}\n\nconst scratchPerspectiveFrustum = new PerspectiveFrustum();\nconst scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();\nconst scratchOrthographicFrustum = new OrthographicFrustum();\nconst scratchOrthographicOffCenterFrustum = new OrthographicOffCenterFrustum();\n\nPicking.prototype.pickPositionWorldCoordinates = function (\n  scene,\n  windowPosition,\n  result\n) {\n  if (!scene.useDepthPicking) {\n    return undefined;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is undefined.\");\n  }\n  if (!scene.context.depthTexture) {\n    throw new DeveloperError(\n      \"Picking from the depth buffer is not supported. Check pickPositionSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const cacheKey = windowPosition.toString();\n\n  if (this._pickPositionCacheDirty) {\n    this._pickPositionCache = {};\n    this._pickPositionCacheDirty = false;\n  } else if (this._pickPositionCache.hasOwnProperty(cacheKey)) {\n    return Cartesian3.clone(this._pickPositionCache[cacheKey], result);\n  }\n\n  const frameState = scene.frameState;\n  const context = scene.context;\n  const uniformState = context.uniformState;\n\n  const view = scene.defaultView;\n  scene.view = view;\n\n  const drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(\n    scene,\n    windowPosition,\n    scratchPosition\n  );\n  if (scene.pickTranslucentDepth) {\n    renderTranslucentDepthForPick(scene, drawingBufferPosition);\n  } else {\n    scene.updateFrameState();\n    uniformState.update(frameState);\n    scene.updateEnvironment();\n  }\n  drawingBufferPosition.y = scene.drawingBufferHeight - drawingBufferPosition.y;\n\n  const camera = scene.camera;\n\n  // Create a working frustum from the original camera frustum.\n  let frustum;\n  if (defined(camera.frustum.fov)) {\n    frustum = camera.frustum.clone(scratchPerspectiveFrustum);\n  } else if (defined(camera.frustum.infiniteProjectionMatrix)) {\n    frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);\n  } else if (defined(camera.frustum.width)) {\n    frustum = camera.frustum.clone(scratchOrthographicFrustum);\n  } else {\n    frustum = camera.frustum.clone(scratchOrthographicOffCenterFrustum);\n  }\n\n  const frustumCommandsList = view.frustumCommandsList;\n  const numFrustums = frustumCommandsList.length;\n  for (let i = 0; i < numFrustums; ++i) {\n    const pickDepth = this.getPickDepth(scene, i);\n    const depth = pickDepth.getDepth(\n      context,\n      drawingBufferPosition.x,\n      drawingBufferPosition.y\n    );\n    if (!defined(depth)) {\n      continue;\n    }\n    if (depth > 0.0 && depth < 1.0) {\n      const renderedFrustum = frustumCommandsList[i];\n      let height2D;\n      if (scene.mode === SceneMode.SCENE2D) {\n        height2D = camera.position.z;\n        camera.position.z = height2D - renderedFrustum.near + 1.0;\n        frustum.far = Math.max(1.0, renderedFrustum.far - renderedFrustum.near);\n        frustum.near = 1.0;\n        uniformState.update(frameState);\n        uniformState.updateFrustum(frustum);\n      } else {\n        frustum.near =\n          renderedFrustum.near *\n          (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        frustum.far = renderedFrustum.far;\n        uniformState.updateFrustum(frustum);\n      }\n\n      result = SceneTransforms.drawingBufferToWgs84Coordinates(\n        scene,\n        drawingBufferPosition,\n        depth,\n        result\n      );\n\n      if (scene.mode === SceneMode.SCENE2D) {\n        camera.position.z = height2D;\n        uniformState.update(frameState);\n      }\n\n      this._pickPositionCache[cacheKey] = Cartesian3.clone(result);\n      return result;\n    }\n  }\n\n  this._pickPositionCache[cacheKey] = undefined;\n  return undefined;\n};\n\nconst scratchPickPositionCartographic = new Cartographic();\n\nPicking.prototype.pickPosition = function (scene, windowPosition, result) {\n  result = this.pickPositionWorldCoordinates(scene, windowPosition, result);\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    Cartesian3.fromElements(result.y, result.z, result.x, result);\n\n    const projection = scene.mapProjection;\n    const ellipsoid = projection.ellipsoid;\n\n    const cart = projection.unproject(result, scratchPickPositionCartographic);\n    ellipsoid.cartographicToCartesian(cart, result);\n  }\n\n  return result;\n};\n\nfunction drillPick(limit, pickCallback) {\n  // PERFORMANCE_IDEA: This function calls each primitive's update for each pass. Instead\n  // we could update the primitive once, and then just execute their commands for each pass,\n  // and cull commands for picked primitives.  e.g., base on the command's owner.\n  let i;\n  let attributes;\n  const result = [];\n  const pickedPrimitives = [];\n  const pickedAttributes = [];\n  const pickedFeatures = [];\n  if (!defined(limit)) {\n    limit = Number.MAX_VALUE;\n  }\n\n  let pickedResult = pickCallback();\n  while (defined(pickedResult)) {\n    const object = pickedResult.object;\n    const position = pickedResult.position;\n    const exclude = pickedResult.exclude;\n\n    if (defined(position) && !defined(object)) {\n      result.push(pickedResult);\n      break;\n    }\n\n    if (!defined(object) || !defined(object.primitive)) {\n      break;\n    }\n\n    if (!exclude) {\n      result.push(pickedResult);\n      if (0 >= --limit) {\n        break;\n      }\n    }\n\n    const primitive = object.primitive;\n    let hasShowAttribute = false;\n\n    // If the picked object has a show attribute, use it.\n    if (typeof primitive.getGeometryInstanceAttributes === \"function\") {\n      if (defined(object.id)) {\n        attributes = primitive.getGeometryInstanceAttributes(object.id);\n        if (defined(attributes) && defined(attributes.show)) {\n          hasShowAttribute = true;\n          attributes.show = ShowGeometryInstanceAttribute.toValue(\n            false,\n            attributes.show\n          );\n          pickedAttributes.push(attributes);\n        }\n      }\n    }\n\n    if (object instanceof Cesium3DTileFeature) {\n      hasShowAttribute = true;\n      object.show = false;\n      pickedFeatures.push(object);\n    }\n\n    // Otherwise, hide the entire primitive\n    if (!hasShowAttribute) {\n      primitive.show = false;\n      pickedPrimitives.push(primitive);\n    }\n\n    pickedResult = pickCallback();\n  }\n\n  // Unhide everything we hid while drill picking\n  for (i = 0; i < pickedPrimitives.length; ++i) {\n    pickedPrimitives[i].show = true;\n  }\n\n  for (i = 0; i < pickedAttributes.length; ++i) {\n    attributes = pickedAttributes[i];\n    attributes.show = ShowGeometryInstanceAttribute.toValue(\n      true,\n      attributes.show\n    );\n  }\n\n  for (i = 0; i < pickedFeatures.length; ++i) {\n    pickedFeatures[i].show = true;\n  }\n\n  return result;\n}\n\nPicking.prototype.drillPick = function (\n  scene,\n  windowPosition,\n  limit,\n  width,\n  height\n) {\n  const that = this;\n  const pickCallback = function () {\n    const object = that.pick(scene, windowPosition, width, height);\n    if (defined(object)) {\n      return {\n        object: object,\n        position: undefined,\n        exclude: false,\n      };\n    }\n  };\n  const objects = drillPick(limit, pickCallback);\n  return objects.map(function (element) {\n    return element.object;\n  });\n};\n\nconst scratchRight = new Cartesian3();\nconst scratchUp = new Cartesian3();\n\nfunction MostDetailedRayPick(ray, width, tilesets) {\n  this.ray = ray;\n  this.width = width;\n  this.tilesets = tilesets;\n  this.ready = false;\n  this.deferred = defer();\n  this.promise = this.deferred.promise;\n}\n\nfunction updateOffscreenCameraFromRay(picking, ray, width, camera) {\n  const direction = ray.direction;\n  const orthogonalAxis = Cartesian3.mostOrthogonalAxis(direction, scratchRight);\n  const right = Cartesian3.cross(direction, orthogonalAxis, scratchRight);\n  const up = Cartesian3.cross(direction, right, scratchUp);\n\n  camera.position = ray.origin;\n  camera.direction = direction;\n  camera.up = up;\n  camera.right = right;\n\n  camera.frustum.width = defaultValue(width, offscreenDefaultWidth);\n  return camera.frustum.computeCullingVolume(\n    camera.positionWC,\n    camera.directionWC,\n    camera.upWC\n  );\n}\n\nfunction updateMostDetailedRayPick(picking, scene, rayPick) {\n  const frameState = scene.frameState;\n\n  const ray = rayPick.ray;\n  const width = rayPick.width;\n  const tilesets = rayPick.tilesets;\n\n  const camera = picking._pickOffscreenView.camera;\n  const cullingVolume = updateOffscreenCameraFromRay(\n    picking,\n    ray,\n    width,\n    camera\n  );\n\n  const tilesetPassState = mostDetailedPreloadTilesetPassState;\n  tilesetPassState.camera = camera;\n  tilesetPassState.cullingVolume = cullingVolume;\n\n  let ready = true;\n  const tilesetsLength = tilesets.length;\n  for (let i = 0; i < tilesetsLength; ++i) {\n    const tileset = tilesets[i];\n    if (tileset.show && scene.primitives.contains(tileset)) {\n      // Only update tilesets that are still contained in the scene's primitive collection and are still visible\n      // Update tilesets continually until all tilesets are ready. This way tiles are never removed from the cache.\n      tileset.updateForPass(frameState, tilesetPassState);\n      ready = ready && tilesetPassState.ready;\n    }\n  }\n\n  if (ready) {\n    rayPick.deferred.resolve();\n  }\n\n  return ready;\n}\n\nPicking.prototype.updateMostDetailedRayPicks = function (scene) {\n  // Modifies array during iteration\n  const rayPicks = this._mostDetailedRayPicks;\n  for (let i = 0; i < rayPicks.length; ++i) {\n    if (updateMostDetailedRayPick(this, scene, rayPicks[i])) {\n      rayPicks.splice(i--, 1);\n    }\n  }\n};\n\nfunction getTilesets(primitives, objectsToExclude, tilesets) {\n  const length = primitives.length;\n  for (let i = 0; i < length; ++i) {\n    const primitive = primitives.get(i);\n    if (primitive.show) {\n      if (defined(primitive.isCesium3DTileset)) {\n        if (\n          !defined(objectsToExclude) ||\n          objectsToExclude.indexOf(primitive) === -1\n        ) {\n          tilesets.push(primitive);\n        }\n      } else if (primitive instanceof PrimitiveCollection) {\n        getTilesets(primitive, objectsToExclude, tilesets);\n      }\n    }\n  }\n}\n\nfunction launchMostDetailedRayPick(\n  picking,\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n  callback\n) {\n  const tilesets = [];\n  getTilesets(scene.primitives, objectsToExclude, tilesets);\n  if (tilesets.length === 0) {\n    return Promise.resolve(callback());\n  }\n\n  const rayPick = new MostDetailedRayPick(ray, width, tilesets);\n  picking._mostDetailedRayPicks.push(rayPick);\n  return rayPick.promise.then(function () {\n    return callback();\n  });\n}\n\nfunction isExcluded(object, objectsToExclude) {\n  if (\n    !defined(object) ||\n    !defined(objectsToExclude) ||\n    objectsToExclude.length === 0\n  ) {\n    return false;\n  }\n  return (\n    objectsToExclude.indexOf(object) > -1 ||\n    objectsToExclude.indexOf(object.primitive) > -1 ||\n    objectsToExclude.indexOf(object.id) > -1\n  );\n}\n\nfunction getRayIntersection(\n  picking,\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed\n) {\n  const context = scene.context;\n  const uniformState = context.uniformState;\n  const frameState = scene.frameState;\n\n  const view = picking._pickOffscreenView;\n  scene.view = view;\n\n  updateOffscreenCameraFromRay(picking, ray, width, view.camera);\n\n  scratchRectangle = BoundingRectangle.clone(view.viewport, scratchRectangle);\n\n  const passState = view.pickFramebuffer.begin(scratchRectangle, view.viewport);\n\n  scene.jobScheduler.disableThisFrame();\n\n  scene.updateFrameState();\n  frameState.invertClassification = false;\n  frameState.passes.pick = true;\n  frameState.passes.offscreen = true;\n\n  if (mostDetailed) {\n    frameState.tilesetPassState = mostDetailedPickTilesetPassState;\n  } else {\n    frameState.tilesetPassState = pickTilesetPassState;\n  }\n\n  uniformState.update(frameState);\n\n  scene.updateEnvironment();\n  scene.updateAndExecuteCommands(passState, scratchColorZero);\n  scene.resolveFramebuffers(passState);\n\n  let position;\n  const object = view.pickFramebuffer.end(scratchRectangle);\n\n  if (scene.context.depthTexture) {\n    const numFrustums = view.frustumCommandsList.length;\n    for (let i = 0; i < numFrustums; ++i) {\n      const pickDepth = picking.getPickDepth(scene, i);\n      const depth = pickDepth.getDepth(context, 0, 0);\n      if (!defined(depth)) {\n        continue;\n      }\n      if (depth > 0.0 && depth < 1.0) {\n        const renderedFrustum = view.frustumCommandsList[i];\n        const near =\n          renderedFrustum.near *\n          (i !== 0 ? scene.opaqueFrustumNearOffset : 1.0);\n        const far = renderedFrustum.far;\n        const distance = near + depth * (far - near);\n        position = Ray.getPoint(ray, distance);\n        break;\n      }\n    }\n  }\n\n  scene.view = scene.defaultView;\n  context.endFrame();\n\n  if (defined(object) || defined(position)) {\n    return {\n      object: object,\n      position: position,\n      exclude:\n        (!defined(position) && requirePosition) ||\n        isExcluded(object, objectsToExclude),\n    };\n  }\n}\n\nfunction getRayIntersections(\n  picking,\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed\n) {\n  const pickCallback = function () {\n    return getRayIntersection(\n      picking,\n      scene,\n      ray,\n      objectsToExclude,\n      width,\n      requirePosition,\n      mostDetailed\n    );\n  };\n  return drillPick(limit, pickCallback);\n}\n\nfunction pickFromRay(\n  picking,\n  scene,\n  ray,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed\n) {\n  const results = getRayIntersections(\n    picking,\n    scene,\n    ray,\n    1,\n    objectsToExclude,\n    width,\n    requirePosition,\n    mostDetailed\n  );\n  if (results.length > 0) {\n    return results[0];\n  }\n}\n\nfunction drillPickFromRay(\n  picking,\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width,\n  requirePosition,\n  mostDetailed\n) {\n  return getRayIntersections(\n    picking,\n    scene,\n    ray,\n    limit,\n    objectsToExclude,\n    width,\n    requirePosition,\n    mostDetailed\n  );\n}\n\nfunction deferPromiseUntilPostRender(scene, promise) {\n  // Resolve promise after scene's postRender in case entities are created when the promise resolves.\n  // Entities can't be created between viewer._onTick and viewer._postRender.\n  const deferred = defer();\n  promise\n    .then(function (result) {\n      const removeCallback = scene.postRender.addEventListener(function () {\n        deferred.resolve(result);\n        removeCallback();\n      });\n      scene.requestRender();\n    })\n    .catch(function (error) {\n      deferred.reject(error);\n    });\n  return deferred.promise;\n}\n\nPicking.prototype.pickFromRay = function (scene, ray, objectsToExclude, width) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return pickFromRay(this, scene, ray, objectsToExclude, width, false, false);\n};\n\nPicking.prototype.drillPickFromRay = function (\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return drillPickFromRay(\n    this,\n    scene,\n    ray,\n    limit,\n    objectsToExclude,\n    width,\n    false,\n    false\n  );\n};\n\nPicking.prototype.pickFromRayMostDetailed = function (\n  scene,\n  ray,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  return deferPromiseUntilPostRender(\n    scene,\n    launchMostDetailedRayPick(\n      that,\n      scene,\n      ray,\n      objectsToExclude,\n      width,\n      function () {\n        return pickFromRay(\n          that,\n          scene,\n          ray,\n          objectsToExclude,\n          width,\n          false,\n          true\n        );\n      }\n    )\n  );\n};\n\nPicking.prototype.drillPickFromRayMostDetailed = function (\n  scene,\n  ray,\n  limit,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"ray\", ray);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"Ray intersections are only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const that = this;\n  ray = Ray.clone(ray);\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  return deferPromiseUntilPostRender(\n    scene,\n    launchMostDetailedRayPick(\n      that,\n      scene,\n      ray,\n      objectsToExclude,\n      width,\n      function () {\n        return drillPickFromRay(\n          that,\n          scene,\n          ray,\n          limit,\n          objectsToExclude,\n          width,\n          false,\n          true\n        );\n      }\n    )\n  );\n};\n\nconst scratchSurfacePosition = new Cartesian3();\nconst scratchSurfaceNormal = new Cartesian3();\nconst scratchSurfaceRay = new Ray();\nconst scratchCartographic = new Cartographic();\n\nfunction getRayForSampleHeight(scene, cartographic) {\n  const globe = scene.globe;\n  const ellipsoid = defined(globe)\n    ? globe.ellipsoid\n    : scene.mapProjection.ellipsoid;\n  const height = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  const surfaceNormal = ellipsoid.geodeticSurfaceNormalCartographic(\n    cartographic,\n    scratchSurfaceNormal\n  );\n  const surfacePosition = Cartographic.toCartesian(\n    cartographic,\n    ellipsoid,\n    scratchSurfacePosition\n  );\n  const surfaceRay = scratchSurfaceRay;\n  surfaceRay.origin = surfacePosition;\n  surfaceRay.direction = surfaceNormal;\n  const ray = new Ray();\n  Ray.getPoint(surfaceRay, height, ray.origin);\n  Cartesian3.negate(surfaceNormal, ray.direction);\n  return ray;\n}\n\nfunction getRayForClampToHeight(scene, cartesian) {\n  const globe = scene.globe;\n  const ellipsoid = defined(globe)\n    ? globe.ellipsoid\n    : scene.mapProjection.ellipsoid;\n  const cartographic = Cartographic.fromCartesian(\n    cartesian,\n    ellipsoid,\n    scratchCartographic\n  );\n  return getRayForSampleHeight(scene, cartographic);\n}\n\nfunction getHeightFromCartesian(scene, cartesian) {\n  const globe = scene.globe;\n  const ellipsoid = defined(globe)\n    ? globe.ellipsoid\n    : scene.mapProjection.ellipsoid;\n  const cartographic = Cartographic.fromCartesian(\n    cartesian,\n    ellipsoid,\n    scratchCartographic\n  );\n  return cartographic.height;\n}\n\nfunction sampleHeightMostDetailed(\n  picking,\n  scene,\n  cartographic,\n  objectsToExclude,\n  width\n) {\n  const ray = getRayForSampleHeight(scene, cartographic);\n  return launchMostDetailedRayPick(\n    picking,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    function () {\n      const pickResult = pickFromRay(\n        picking,\n        scene,\n        ray,\n        objectsToExclude,\n        width,\n        true,\n        true\n      );\n      if (defined(pickResult)) {\n        return getHeightFromCartesian(scene, pickResult.position);\n      }\n    }\n  );\n}\n\nfunction clampToHeightMostDetailed(\n  picking,\n  scene,\n  cartesian,\n  objectsToExclude,\n  width,\n  result\n) {\n  const ray = getRayForClampToHeight(scene, cartesian);\n  return launchMostDetailedRayPick(\n    picking,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    function () {\n      const pickResult = pickFromRay(\n        picking,\n        scene,\n        ray,\n        objectsToExclude,\n        width,\n        true,\n        true\n      );\n      if (defined(pickResult)) {\n        return Cartesian3.clone(pickResult.position, result);\n      }\n    }\n  );\n}\n\nPicking.prototype.sampleHeight = function (\n  scene,\n  position,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"position\", position);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"sampleHeight is only supported in 3D mode.\");\n  }\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\n      \"sampleHeight requires depth texture support. Check sampleHeightSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ray = getRayForSampleHeight(scene, position);\n  const pickResult = pickFromRay(\n    this,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    true,\n    false\n  );\n  if (defined(pickResult)) {\n    return getHeightFromCartesian(scene, pickResult.position);\n  }\n};\n\nPicking.prototype.clampToHeight = function (\n  scene,\n  cartesian,\n  objectsToExclude,\n  width,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\"clampToHeight is only supported in 3D mode.\");\n  }\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\n      \"clampToHeight requires depth texture support. Check clampToHeightSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ray = getRayForClampToHeight(scene, cartesian);\n  const pickResult = pickFromRay(\n    this,\n    scene,\n    ray,\n    objectsToExclude,\n    width,\n    true,\n    false\n  );\n  if (defined(pickResult)) {\n    return Cartesian3.clone(pickResult.position, result);\n  }\n};\n\nPicking.prototype.sampleHeightMostDetailed = function (\n  scene,\n  positions,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"positions\", positions);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"sampleHeightMostDetailed is only supported in 3D mode.\"\n    );\n  }\n  if (!scene.sampleHeightSupported) {\n    throw new DeveloperError(\n      \"sampleHeightMostDetailed requires depth texture support. Check sampleHeightSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  const length = positions.length;\n  const promises = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    promises[i] = sampleHeightMostDetailed(\n      this,\n      scene,\n      positions[i],\n      objectsToExclude,\n      width\n    );\n  }\n  return deferPromiseUntilPostRender(\n    scene,\n    Promise.all(promises).then(function (heights) {\n      const length = heights.length;\n      for (let i = 0; i < length; ++i) {\n        positions[i].height = heights[i];\n      }\n      return positions;\n    })\n  );\n};\n\nPicking.prototype.clampToHeightMostDetailed = function (\n  scene,\n  cartesians,\n  objectsToExclude,\n  width\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  if (scene.mode !== SceneMode.SCENE3D) {\n    throw new DeveloperError(\n      \"clampToHeightMostDetailed is only supported in 3D mode.\"\n    );\n  }\n  if (!scene.clampToHeightSupported) {\n    throw new DeveloperError(\n      \"clampToHeightMostDetailed requires depth texture support. Check clampToHeightSupported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  objectsToExclude = defined(objectsToExclude)\n    ? objectsToExclude.slice()\n    : objectsToExclude;\n  const length = cartesians.length;\n  const promises = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    promises[i] = clampToHeightMostDetailed(\n      this,\n      scene,\n      cartesians[i],\n      objectsToExclude,\n      width,\n      cartesians[i]\n    );\n  }\n  return deferPromiseUntilPostRender(\n    scene,\n    Promise.all(promises).then(function (clampedCartesians) {\n      const length = clampedCartesians.length;\n      for (let i = 0; i < length; ++i) {\n        cartesians[i] = clampedCartesians[i];\n      }\n      return cartesians;\n    })\n  );\n};\n\nPicking.prototype.destroy = function () {\n  this._pickOffscreenView =\n    this._pickOffscreenView && this._pickOffscreenView.destroy();\n};\nexport default Picking;\n","import arraySlice from \"../Core/arraySlice.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\n\n/**\n * Handles parsing of a Point Cloud\n *\n * @namespace PntsParser\n * @private\n */\nconst PntsParser = {};\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\n/**\n * Parses the contents of a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud|Point Cloud}.\n *\n * @private\n *\n * @param {*} arrayBuffer The array buffer containing the pnts\n * @param {*} [byteOffset=0] The byte offset of the beginning of the pnts in the array buffer\n * @returns {Object} An object containing a parsed representation of the point cloud\n */\nPntsParser.parse = function (arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Point Cloud tile version 1 is supported.  Version ${version} is not.`\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  // Skip byteLength\n  byteOffset += sizeOfUint32;\n\n  const featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\"\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const featureTableJson = getJsonFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJsonByteLength\n  );\n  byteOffset += featureTableJsonByteLength;\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  // Get the batch table JSON and binary\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // Has a batch table JSON\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJsonByteLength\n    );\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength\n      );\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary\n  );\n\n  const pointsLength = featureTable.getGlobalProperty(\"POINTS_LENGTH\");\n  featureTable.featuresLength = pointsLength;\n\n  if (!defined(pointsLength)) {\n    throw new RuntimeError(\n      \"Feature table global property: POINTS_LENGTH must be defined\"\n    );\n  }\n\n  let rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n  if (defined(rtcCenter)) {\n    rtcCenter = Cartesian3.unpack(rtcCenter);\n  }\n\n  // Start with the draco compressed properties and add in uncompressed\n  // properties.\n  const parsedContent = parseDracoProperties(featureTable, batchTableJson);\n  parsedContent.rtcCenter = rtcCenter;\n  parsedContent.pointsLength = pointsLength;\n\n  if (!parsedContent.hasPositions) {\n    const positions = parsePositions(featureTable);\n    parsedContent.positions = positions;\n    parsedContent.hasPositions =\n      parsedContent.hasPositions || defined(positions);\n  }\n\n  if (!parsedContent.hasPositions) {\n    throw new RuntimeError(\n      \"Either POSITION or POSITION_QUANTIZED must be defined.\"\n    );\n  }\n\n  if (!parsedContent.hasNormals) {\n    const normals = parseNormals(featureTable);\n    parsedContent.normals = normals;\n    parsedContent.hasNormals = parsedContent.hasNormals || defined(normals);\n  }\n\n  if (!parsedContent.hasColors) {\n    const colors = parseColors(featureTable);\n    parsedContent.colors = colors;\n    parsedContent.hasColors = parsedContent.hasColors || defined(colors);\n    parsedContent.hasConstantColor = defined(parsedContent.constantColor);\n    parsedContent.isTranslucent = defined(colors) && colors.isTranslucent;\n  }\n\n  if (!parsedContent.hasBatchIds) {\n    const batchIds = parseBatchIds(featureTable);\n    parsedContent.batchIds = batchIds;\n    parsedContent.hasBatchIds = parsedContent.hasBatchIds || defined(batchIds);\n  }\n\n  if (parsedContent.hasBatchIds) {\n    const batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!defined(batchLength)) {\n      throw new RuntimeError(\n        \"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\"\n      );\n    }\n    parsedContent.batchLength = batchLength;\n  }\n\n  if (defined(batchTableBinary)) {\n    // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n    batchTableBinary = new Uint8Array(batchTableBinary);\n    parsedContent.batchTableJson = batchTableJson;\n    parsedContent.batchTableBinary = batchTableBinary;\n  }\n\n  return parsedContent;\n};\n\nfunction parseDracoProperties(featureTable, batchTableJson) {\n  const featureTableJson = featureTable.json;\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const featureTableDraco = defined(featureTableJson.extensions)\n    ? featureTableJson.extensions[\"3DTILES_draco_point_compression\"]\n    : undefined;\n  const batchTableDraco =\n    defined(batchTableJson) && defined(batchTableJson.extensions)\n      ? batchTableJson.extensions[\"3DTILES_draco_point_compression\"]\n      : undefined;\n\n  if (defined(batchTableDraco)) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  let hasPositions;\n  let hasColors;\n  let hasNormals;\n  let hasBatchIds;\n  let isTranslucent;\n  if (defined(featureTableDraco)) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (\n      !defined(dracoFeatureTableProperties) ||\n      !defined(dracoByteOffset) ||\n      !defined(dracoByteLength)\n    ) {\n      throw new RuntimeError(\n        \"Draco properties, byteOffset, and byteLength must be defined\"\n      );\n    }\n    dracoBuffer = arraySlice(\n      featureTable.buffer,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    hasPositions = defined(dracoFeatureTableProperties.POSITION);\n    hasColors =\n      defined(dracoFeatureTableProperties.RGB) ||\n      defined(dracoFeatureTableProperties.RGBA);\n    hasNormals = defined(dracoFeatureTableProperties.NORMAL);\n    hasBatchIds = defined(dracoFeatureTableProperties.BATCH_ID);\n    isTranslucent = defined(dracoFeatureTableProperties.RGBA);\n  }\n\n  let draco;\n  if (defined(dracoBuffer)) {\n    draco = {\n      buffer: dracoBuffer,\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      properties: combine(\n        dracoFeatureTableProperties,\n        dracoBatchTableProperties\n      ),\n      dequantizeInShader: true,\n    };\n  }\n\n  return {\n    draco: draco,\n    hasPositions: hasPositions,\n    hasColors: hasColors,\n    isTranslucent: isTranslucent,\n    hasNormals: hasNormals,\n    hasBatchIds: hasBatchIds,\n  };\n}\n\nfunction parsePositions(featureTable) {\n  const featureTableJson = featureTable.json;\n\n  let positions;\n  if (defined(featureTableJson.POSITION)) {\n    positions = featureTable.getPropertyArray(\n      \"POSITION\",\n      ComponentDatatype.FLOAT,\n      3\n    );\n\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n    };\n  } else if (defined(featureTableJson.POSITION_QUANTIZED)) {\n    positions = featureTable.getPropertyArray(\n      \"POSITION_QUANTIZED\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      3\n    );\n\n    const quantizedVolumeScale = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_SCALE\",\n      ComponentDatatype.FLOAT,\n      3\n    );\n    if (!defined(quantizedVolumeScale)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\"\n      );\n    }\n    const quantizedRange = (1 << 16) - 1;\n\n    const quantizedVolumeOffset = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_OFFSET\",\n      ComponentDatatype.FLOAT,\n      3\n    );\n    if (!defined(quantizedVolumeOffset)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\"\n      );\n    }\n\n    return {\n      name: VertexAttributeSemantic.POSITION,\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: positions,\n      isQuantized: true,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      quantizedRange: quantizedRange,\n      quantizedVolumeOffset: Cartesian3.unpack(quantizedVolumeOffset),\n      quantizedVolumeScale: Cartesian3.unpack(quantizedVolumeScale),\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n      quantizedType: AttributeType.VEC3,\n    };\n  }\n}\n\nfunction parseColors(featureTable) {\n  const featureTableJson = featureTable.json;\n\n  let colors;\n  if (defined(featureTableJson.RGBA)) {\n    colors = featureTable.getPropertyArray(\n      \"RGBA\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      4\n    );\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC4,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: true,\n    };\n  } else if (defined(featureTableJson.RGB)) {\n    colors = featureTable.getPropertyArray(\n      \"RGB\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      3\n    );\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC3,\n      normalized: true,\n      isRGB565: false,\n      isTranslucent: false,\n    };\n  } else if (defined(featureTableJson.RGB565)) {\n    colors = featureTable.getPropertyArray(\n      \"RGB565\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1\n    );\n    return {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: colors,\n      // These settings are for the ModelExperimental implementation\n      // which decodes on the CPU and uploads a VEC3 of float colors.\n      // PointCloud does the decoding on the GPU so uploads a\n      // UNSIGNED_SHORT instead.\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      normalized: false,\n      isRGB565: true,\n      isTranslucent: false,\n    };\n  } else if (defined(featureTableJson.CONSTANT_RGBA)) {\n    const constantRGBA = featureTable.getGlobalProperty(\n      \"CONSTANT_RGBA\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      4\n    );\n\n    const alpha = constantRGBA[3];\n    const constantColor = Color.fromBytes(\n      constantRGBA[0],\n      constantRGBA[1],\n      constantRGBA[2],\n      alpha\n    );\n\n    const isTranslucent = alpha < 255;\n    return {\n      name: VertexAttributeSemantic.COLOR,\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      constantColor: constantColor,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC4,\n      isQuantized: false,\n      isTranslucent: isTranslucent,\n    };\n  }\n\n  return undefined;\n}\n\nfunction parseNormals(featureTable) {\n  const featureTableJson = featureTable.json;\n  let normals;\n  if (defined(featureTableJson.NORMAL)) {\n    normals = featureTable.getPropertyArray(\n      \"NORMAL\",\n      ComponentDatatype.FLOAT,\n      3\n    );\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: false,\n      octEncodedZXY: false,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n    };\n  } else if (defined(featureTableJson.NORMAL_OCT16P)) {\n    normals = featureTable.getPropertyArray(\n      \"NORMAL_OCT16P\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      2\n    );\n    const quantizationBits = 8;\n    return {\n      name: VertexAttributeSemantic.NORMAL,\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: normals,\n      octEncoded: true,\n      octEncodedZXY: false,\n      quantizedRange: (1 << quantizationBits) - 1,\n      quantizedType: AttributeType.VEC2,\n      quantizedComponentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n    };\n  }\n\n  return undefined;\n}\n\nfunction parseBatchIds(featureTable) {\n  const featureTableJson = featureTable.json;\n  if (defined(featureTableJson.BATCH_ID)) {\n    const batchIds = featureTable.getPropertyArray(\n      \"BATCH_ID\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1\n    );\n    return {\n      name: VertexAttributeSemantic.FEATURE_ID,\n      semantic: VertexAttributeSemantic.FEATURE_ID,\n      setIndex: 0,\n      typedArray: batchIds,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      type: AttributeType.SCALAR,\n    };\n  }\n\n  return undefined;\n}\n\nexport default PntsParser;\n"],"names":["boundingSphereCartesian3Scratch","ModelState","articulationEpsilon","setCachedGltf","model","cachedGltf","_cachedGltf","CachedGltf","options","this","_gltf","gltf","ready","modelsToLoad","count","Object","defineProperties","prototype","set","value","get","makeReady","gltfJson","models","length","i","m","isDestroyed","undefined","gltfCache","uriToGuid","Model","cacheKey","_cacheKey","_releaseGltfJson","releaseGltfJson","ArrayBuffer","Uint8Array","basePath","_resource","credit","_credit","_resourceCredits","_gltfCredits","_showCreditsOnScreen","showCreditsOnScreen","show","silhouetteColor","_silhouetteColor","_silhouetteColorPreviousAlpha","_normalAttributeName","silhouetteSize","modelMatrix","_modelMatrix","_clampedModelMatrix","scale","_scale","minimumPixelSize","_minimumPixelSize","maximumScale","_maximumScale","id","_id","heightReference","_heightReference","_heightChanged","_removeUpdateHeightCallback","scene","_scene","terrainProviderChanged","_terrainProviderChangedCallback","addEventListener","_pickObject","pickObject","_allowPicking","allowPicking","_ready","_readyPromise","activeAnimations","clampAnimations","_defaultTexture","_incrementallyLoadTextures","incrementallyLoadTextures","_asynchronous","asynchronous","shadows","_shadows","color","_colorPreviousAlpha","colorBlendMode","colorBlendAmount","_colorShadingEnabled","_clippingPlanes","clippingPlanes","_clippingPlanesState","referenceMatrix","backFaceCulling","showOutline","splitDirection","_splittingEnabled","debugShowBoundingVolume","_debugShowBoundingVolume","debugWireframe","_debugWireframe","_distanceDisplayCondition","distanceDisplayCondition","_addBatchIdToGeneratedShaders","addBatchIdToGeneratedShaders","_precreatedAttributes","precreatedAttributes","_vertexShaderLoaded","vertexShaderLoaded","_fragmentShaderLoaded","fragmentShaderLoaded","_uniformMapLoaded","uniformMapLoaded","_pickIdLoaded","pickIdLoaded","_ignoreCommands","ignoreCommands","_requestType","requestType","_upAxis","upAxis","_gltfForwardAxis","_forwardAxis","forwardAxis","cull","opaquePass","_computedModelMatrix","_clippingPlanesMatrix","_iblReferenceFrameMatrix","_initialRadius","_boundingSphere","_scaledBoundingSphere","_state","NEEDS_LOAD","_loadResources","_mode","_perNodeShowDirty","_cesiumAnimationsDirty","_dirty","_maxDirtyNumber","_runtime","animations","articulationsByName","articulationsByStageKey","stagesByKey","rootNodes","nodes","nodesByName","skinnedNodes","meshesByName","materialsByName","materialsById","_uniformMaps","_extensionsUsed","_extensionsRequired","_quantizedUniforms","_programPrimitives","_rendererResources","buffers","vertexArrays","programs","sourceShaders","silhouettePrograms","textures","samplers","renderStates","_cachedRendererResources","_loadRendererResourcesFromCache","dequantizeInShader","_dequantizeInShader","_decodedData","_cachedGeometryByteLength","_cachedTexturesByteLength","_geometryByteLength","_texturesByteLength","_trianglesLength","_pointsLength","_sourceTechniques","_sourcePrograms","_quantizedVertexShaders","_nodeCommands","_pickIds","_rtcCenter","_rtcCenterEye","_rtcCenter3D","_rtcCenter2D","_sourceVersion","_sourceKHRTechniquesWebGL","_lightColor","lightColor","imageBasedLighting","_imageBasedLighting","_shouldDestroyImageBasedLighting","_shouldRegenerateShaders","silhouetteSupported","context","stencilBuffer","isColorShadingEnabled","isClippingEnabled","enabled","getRuntime","runtimeName","name","LOADED","gltfInternal","basePathInternal","url","boundingSphere","boundingSphereInternal","nonUniformScale","Math","min","scaledBoundingSphere","center","radius","readyPromise","promise","pendingTextureLoads","pendingTextureLoadsInternal","dirty","far","near","extensionsUsed","extensionsRequired","trianglesLength","pointsLength","geometryByteLength","texturesByteLength","cachedGeometryByteLength","cachedTexturesByteLength","pickIds","destroy","showOnScreen","resourceCreditsLength","gltfCreditsLength","fromGltf","modelResource","clone","resource","push","headers","Accept","fetchArrayBuffer","then","arrayBuffer","array","uint8Array","parsedGltf","json","resourceCredits","credits","catch","_gltfCache","getNode","node","publicNode","getMesh","getMaterial","setArticulationStage","articulationStageKey","stage","articulation","minimumValue","maximumValue","currentValue","isDirty","scratchArticulationCartesian","scratchArticulationRotation","applyArticulationStageMatrix","result","cartesian","rotation","type","x","y","z","scratchApplyArticulationTransform","bufferLoad","loadResources","buffer","pendingBufferLoads","extras","_pipeline","source","imageLoad","textureId","image","mipLevels","Array","isArray","slice","map","mipLevel","bufferView","texturesToCreate","enqueue","width","height","internalFormat","applyArticulations","articulationName","hasOwnProperty","numNodes","n","transform","originalMatrix","numStages","stages","s","matrix","ktx2Regex","scratchArticulationStageInitialTransform","CreateVertexBufferJob","createVertexBuffer","bufferViewId","bufferViews","createdBufferViews","vertexBuffer","typedArray","getBuffer","usage","vertexArrayDestroyable","sizeInBytes","execute","CreateIndexBufferJob","componentType","createIndexBuffer","indexBuffer","indexDatatype","scratchVertexBufferJob","scratchIndexBufferJob","getProgramForPrimitive","primitive","material","_program","modifyShaderForQuantizedAttributes","shader","programName","primitives","primitiveId","WEB3D_quantized_attributes","uniforms","decodedData","attributes","modifyShader","callback","CreateProgramJob","programToCreate","createProgram","programId","techniqueId","program","shaders","vs","vertexShader","fs","fragmentShader","quantizedVertexShaders","quantizedVS","drawVS","drawFS","useIBL","useSHC","useSphericalHarmonicCoefficients","useSEM","useSpecularEnvironmentMaps","sphericalHarmonicCoefficients","useDefaultSphericalHarmonics","specularEnvironmentMapAtlas","useDefaultSpecularMaps","luminanceAtZenith","createAttributesAndProgram","recreateProgram","clippingPlaneCollection","addClippingPlaneCode","finalFS","_modifyShaderForColor","_getClippingFunction","modifyShaderForClippingPlanes","technique","attributeLocations","vertexShaderSource","fragmentShaderSource","scratchCreateProgramJob","getOnImageCreatedFromTypedArray","gltfTexture","pendingBufferViewToImage","CreateTextureJob","createTexture","texture","sampler","wrapS","wrapT","usesTextureTransform","materials","materialsLength","extensions","KHR_techniques_webgl","values","valueName","indexOf","index","KHR_texture_transform","minFilter","minificationFilter","magnificationFilter","mipmap","requiresNpot","npot","tx","webgl2","arrayBufferView","pixelFormat","canvas","document","createElement","getContext","drawImage","pixelDatatype","flipY","skipColorSpaceConversion","generateMipmap","scratchCreateTextureJob","getChannelEvaluator","runtimeNode","targetPath","spline","localAnimationTime","clampTime","wrapTime","evaluate","dirtyNumber","createVertexArrays","finishedBuffersCreation","finishedProgramCreation","rendererBuffers","rendererVertexArrays","accessors","mesh","meshId","attributeLocation","techniques","location","_technique","programAttributeLocations","_attributeLocations","attribute","semantic","getAttributeLocations","attributeName","accessorId","decodedAttributes","decodedAttribute","componentsPerAttribute","componentDatatype","normalize","normalized","offsetInBytes","byteOffset","strideInBytes","byteStride","a","indices","createRenderStates","materialId","rendererRenderStates","blendEquationSeparate","blendFuncSeparate","KHR_blend","blendEquation","blendFactors","enableCulling","doubleSided","blendingEnabled","alphaMode","depthTest","func","depthMask","blending","equationRgb","equationAlpha","functionSourceRgb","functionDestinationRgb","functionSourceAlpha","functionDestinationAlpha","createRenderStateForMaterial","gltfUniformsFromNode","MODEL","uniformState","computedMatrix","VIEW","view","PROJECTION","projection","MODELVIEW","mv","CESIUM_RTC_MODELVIEW","mvRtc","MODELVIEWPROJECTION","mvp","_projection","MODELINVERSE","mInverse","VIEWINVERSE","inverseView","PROJECTIONINVERSE","inverseProjection","MODELVIEWINVERSE","mvInverse","MODELVIEWPROJECTIONINVERSE","mvpInverse","MODELINVERSETRANSPOSE","mInverseTranspose","MODELVIEWINVERSETRANSPOSE","mvInverseTranspose","VIEWPORT","viewportCartesian4","createUniformsForMaterial","instanceValues","defaultTexture","uniformMap","uniformValues","jointMatrixUniformName","morphWeightsUniformName","uniform","uniformName","uv","getUniformFunctionFromSource","alphaCutoffValue","alphaCutoff","uv2","createUniformsForDracoQuantizedAttributes","createUniformsForQuantizedAttributes","quantizedUniforms","createPickColorFunction","createJointMatricesFunction","computedJointMatrices","createMorphWeightsFunction","weights","createSilhouetteColorFunction","createSilhouetteSizeFunction","createColorFunction","createClippingPlanesMatrixFunction","createIBLReferenceFrameMatrixFunction","createClippingPlanesFunction","createClippingPlanesEdgeStyleFunction","style","edgeColor","alpha","edgeWidth","createColorBlendFunction","createIBLFactorFunction","imageBasedLightingFactor","createLightColorFunction","createLuminanceAtZenithFunction","createSphericalHarmonicCoefficientsFunction","createSpecularEnvironmentMapFunction","createSpecularEnvironmentMapSizeFunction","dimensions","createSpecularEnvironmentMapLOD","maximumMipmapLevel","triangleCountFromPrimitiveIndices","indicesCount","mode","max","createCommand","gltfNode","scene3DOnly","nodeCommands","runtimeMeshesByName","resources","rendererPrograms","uniformMaps","gltfMeshes","meshes","ix","positionAccessor","POSITION","minMax","vertexArray","offset","numberOfIndices","um","jointUniformMap","morphWeightsUniformMap","gltf_color","gltf_colorBlend","gltf_clippingPlanes","gltf_clippingPlanesEdgeStyle","gltf_clippingPlanesMatrix","gltf_iblReferenceFrameMatrix","gltf_iblFactor","gltf_lightColor","gltf_sphericalHarmonicCoefficients","gltf_specularMap","gltf_specularMapSize","gltf_maxSpecularLOD","gltf_luminanceAtZenith","quantizedUniformMap","rs","isTranslucent","owner","castShadows","receiveShadows","pickId","createPickId","pickUniforms","czm_pickColor","command","boundingVolume","primitiveType","shaderProgram","renderState","pass","command2D","nodeCommand","silhouetteModelCommand","silhouetteModelCommand2D","silhouetteColorCommand","silhouetteColorCommand2D","translucentCommand","translucentCommand2D","disableCullingCommand","disableCullingCommand2D","commands","createResources","frameState","glExtensions","cachedResources","memory","getGeometryByteLength","getTexturesByteLength","vertexBuffersToCreate","indexBuffersToCreate","peek","jobScheduler","dequeue","createBuffers","programsToCreate","pendingShaderLoads","createPrograms","createSamplers","rendererSamplers","samplerId","magFilter","texturesToCreateFromBufferView","onerror","mimeType","ktxBuffer","onload","format","loadTexturesFromBufferViews","createTextures","createSkins","runtimeSkins","skin","accessor","inverseBindMatrices","bindShapeMatrix","skins","runtimeNodes","skinnedNodesIds","j","skinnedNode","runtimeSkin","gltfJoints","joints","jointsLength","jointNode","createJoints","finishedPendingBufferLoads","createRuntimeAnimations","animation","channels","startTime","Number","MAX_VALUE","stopTime","channelsLength","channelEvaluators","channel","target","path","input","output","createUniformMaps","modelMaterial","_values","u","a_outlineCoordinates","outlineTexture","u_outlineTexture","finishedEverythingButTextureCreation","createRuntimeNodes","sceneNodes","scenes","stack","seen","parentRuntimeNode","pop","parents","translation","children","childrenLength","childId","getNodeMatrix","publicMatrix","useMatrix","setMatrix","scratchNodeStack","scratchComputedTranslation","scratchComputedMatrixIn2D","scratchObjectSpace","deriveTranslucentCommand","stencilTest","stencilMask","getTranslucentRenderState","updateColor","forceDerive","deriveDisableCullingCommand","getDisableCullingRenderState","updateBackFaceCulling","getProgramId","createSilhouetteProgram","sources","normalAttributeName","hasSilhouette","isInvisible","alphaDirty","currAlpha","prevAlpha","floor","ceil","silhouettesLength","createSilhouetteCommands","stencilReference","silhouetteTranslucent","hasTranslucentCommands","modelCommand","frontFunction","backFunction","reference","mask","frontOperation","fail","zFail","zPass","backOperation","colorMask","red","green","blue","silhouetteProgram","silhouetteUniformMap","gltf_silhouetteColor","gltf_silhouetteSize","updateSilhouette","force","scratchBoundingSphere","scratchPosition","scratchCartographic","getScale","maxPixelSize","drawingBufferWidth","drawingBufferHeight","mapProjection","cartographic","ellipsoid","cartesianToCartographic","project","metersPerPixel","positionWC","camera","getPixelSize","scaleInPixels","pixelsPerMeter","releaseCachedGltf","CachedRendererResources","property","getUpdateHeightCallback","cartoPosition","clampedPosition","clampedCart","cartographicToCartesian","clampedModelMatrix","release","cache","modelRendererResourceCache","scratchDisplayConditionCartesian","scratchDistanceDisplayConditionCartographic","scratchIBLReferenceFrameMatrix4","scratchIBLReferenceFrameMatrix3","scratchClippingPlanesMatrix","destroyIfNotCached","rendererResources","cachedRendererResources","update","supportsWebP","modelCaches","LOADING","FAILED","CESIUM_RTC","projectedCart","justLoaded","initialized","brdfLutGenerator","sourceVersion","sourceKHRTechniquesWebGL","addBuffersToLoadResources","runtimeStagesByKey","AGI_articulations","gltfArticulations","articulations","numArticulations","initialValue","stageKey","parseArticulations","sourcePrograms","sourceTechniques","parseTechniques","indexBufferIds","parseBufferViews","bufferId","byteLength","shaderResource","getDerivedResource","uri","fetchText","shaderLoad","parseShaders","parsePrograms","images","imageId","EXT_texture_webp","KHR_texture_basisu","supportsBasis","gltfImage","imageResource","test","fetchImage","preferImageBitmap","parseTextures","runtimeMaterialsByName","runtimeMaterialsById","parseMaterials","programPrimitives","parseMeshes","runtimeNodesByName","computedShow","transformToRoot","jointName","parseNodes","copyright","asset","split","string","trim","parseCredits","finishedDecoding","resourcesParsed","finished","silhouette","translucent","invisible","displayConditionPassed","distance2","ddc","nearSquared","farSquared","frustum","right","left","position","distanceDisplayConditionVisible","animated","modeChanged","modelTransformChanged","globe","surface","_surface","updateHeight","getHeight","cb","updateClamping","computedModelMatrix","maxDirtyNumber","nodeStack","to2D","nodeMatrix","commandsLength","primitiveCommand","maximumRadius","k","child","updateNodeHierarchyModelMatrix","inverseBindMatricesLength","applySkins","nodeCommandsLength","updatePerNodeShow","object","updatePickIds","updateWireframe","updateShowBoundingVolume","updateShadows","updateClippingPlanes","currentClippingPlanesState","iblReferenceFrameMatrix3","iblReferenceFrameMatrix4","view3D","shouldRegenerateShaders","clippingPlanesMatrix","clippingPlanesState","currentlyColorShadingEnabled","splittingEnabled","visitedPrograms","commandCount","renderProgram","regenerateShaders","afterRender","resolve","commandList","passes","nc","idl2D","render","pick","overIdl","creditDisplay","addCredit","c","gltfCredits","PointCloudAttenuationPipelineStage","scratchAttenuationUniform","process","renderResources","shaderBuilder","addVertexLines","addDefine","pointCloudShading","content","is3DTiles","usesAddRefinement","tile","refine","addUniform","model_pointCloudAttenuation","scratch","defaultPointSize","tileset","maximumScreenSpaceError","maximumAttenuation","pixelRatio","geometricError","baseResolution","positionAttribute","nodeTransform","scratchDimensions","volume","getGeometricError","geometricErrorScale","depthMultiplier","POSITIVE_INFINITY","sseDenominator","PrimitiveRenderResources","nodeRenderResources","runtimePrimitive","attributeIndex","featureIdVertexAttributeSetIndex","hasPropertyTable","alphaOptions","instanceCount","wireframeIndexBuffer","positionMinMax","instancingTranslationMin","instancingTranslationMax","positionMin","positionMax","lightingOptions","renderStateOptions","styleCommandsNeeded","scratchModelMatrix","SceneMode2DPipelineStage","sceneGraph","nodeComputedTransform","computedTransform","boundingSphere2D","transformedPositionMin","scratchProjectedMin","projectedMin","transformedPositionMax","scratchProjectedMax","projectedMax","computeBoundingSphere2D","buffer2D","frameStateCV","referencePoint","projectedPositions","quantization","dequantizedArray","Float32Array","quantizedVolumeOffset","quantizedVolumeStepSize","initialPosition","scaledPosition","dequantizedPosition","dequantizePositionsTypedArray","BYTES_PER_ELEMENT","startIndex","stride","isNaN","transformedPosition","projectedPosition","relativePosition","createPositionsTypedArrayFor2D","createPositionBufferFor2D","positionBuffer2D","_modelResources","modelMatrix2D","modelView","u_modelView2D","SelectedFeatureIdPipelineStage","getFeatureIdDefine","featureIds","getShaderDestination","STRUCT_ID_SELECTED_FEATURE","STRUCT_NAME_SELECTED_FEATURE","FUNCTION_ID_FEATURE_VARYINGS_VS","FUNCTION_ID_FEATURE_VARYINGS_FS","FUNCTION_SIGNATURE_UPDATE_FEATURE","selectedFeatureIds","variableName","instances","instanceFeatureIdLabel","label","positionalLabel","shaderDestination","featureIdDefine","featureIdLabel","getSelectedFeatureIds","addStructField","updateFeatureStruct","nullFeatureId","model_nullFeatureId","addFragmentLines","SkinningPipelineStage","FUNCTION_ID_GET_SKINNING_MATRIX","FUNCTION_SIGNATURE_GET_SKINNING_MATRIX","addFunction","initialLine","setIndex","componentIndex","addFunctionLines","componentStrings","maximumSetIndex","getMaximumAttributeSetIndex","component","line","returnLine","addGetSkinningMatrixFunction","jointMatrices","u_jointMatrices","StyleCommandsNeeded","ALL_OPAQUE","ALL_TRANSLUCENT","OPAQUE_AND_TRANSLUCENT","featuresLength","translucentFeaturesLength","freeze","TextureManager","_textures","_loadedImages","_lastUpdatedFrame","textureManager","loadedImage","textureUniform","oldTexture","getTexture","loadTexture2D","fetchTexture2D","frameNumber","loadedImages","instance","TextureUniform","hasTypedArray","wrap","repeat","maximumAnisotropy","FLOAT","VEC2","VEC3","VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","MAT2","MAT3","MAT4","SAMPLER_2D","SAMPLER_CUBE","WireframePipelineStage","vertexCount","originalIndices","indicesBuffer","getBufferData","wireframeIndices","createWireframeIndexBuffer","_resources","originalPrimitiveType","originalCount","buildDrawCommand","primitiveRenderResources","getIndexBuffer","buildShaderProgram","_projectTo2D","face","ModelInstance","collection","instanceId","_instanceId","_model","expandBoundingSphere","LoadState","ModelInstanceCollection","_instancingSupported","_dynamic","dynamic","_cull","_opaquePass","_instances","instancesOptions","instanceOptions","batchId","createInstances","_batchTable","batchTable","_vertexBufferTypedArray","_vertexBuffer","_batchIdBuffer","_instancedUniformsByProgram","_drawCommands","_modelCommands","_renderStates","_disableCullingRenderStates","instancesLength","points","createBoundingSphere","_center","_rtcTransform","_rtcModelView","_url","_basePath","_backFaceCulling","scratchCartesian","scratchMatrix","getCheckUniformSemanticFunction","modelSemantics","supportedSemantics","getInstancedUniforms","instancedUniformsByProgram","getUniformMapCallback","czm_instanced_modifiedModelView","createModifiedModelView","czm_instanced_nodeTransform","createNodeTransformFunction","instancedUniforms","getVertexBufferTypedArray","collectionCenter","bufferData","instanceMatrix","createModel","instancingSupported","usesBatchTable","modelOptions","createPickIds","batchIdBufferData","Uint16Array","pickIdBuffer","pickColor","_pickIdBuffer","vertexBufferTypedArray","vertexSizeInFloats","componentSizeInBytes","instancedAttributes","czm_modelMatrixRow0","instanceDivisor","czm_modelMatrixRow1","czm_modelMatrixRow2","a_batchId","batchIdAttribute","pickAttribute","pickVarying","renamedSource","globalVarsHeader","globalVarsMain","varName","regex","RegExp","replace","instancedSource","diffuseAttributeOrUniformName","getVertexShaderCallback","getFragmentShaderCallback","getUrlComponent","getVertexShaderNonInstancedCallback","getFragmentShaderNonInstancedCallback","getUniformMapNonInstancedCallback","createBatchIdFunction","updateCommandsNonInstanced","modelCommands","collectionTransform","commandIndex","drawCommand","nodeBoundingSphere","getModelCommands","drawCommands","generateModelCommands","modelInstanceCollection","getPickId","createCommands","createCommandsNonInstanced","instanceModelMatrix","instancedArrays","that","error","reject","modelRadius","modelMatrixChanged","rtcTransform","copyFromArrayView","updateVertexBuffer","modelCommandsDirty","commandsDirty","derivedRenderState","ModelLoadResources","primitivesToDecode","activeDecodingTasks","pendingDecodingCache","subarray","finishedTextureCreation","finishedPendingLoads","finishedResourceCreation","ModelMaterial","_name","_uniformMap","setValue","v","getValue","ModelMesh","p","_materials","ModelNode","_runtimeNode","_show","_matrix","_originalMatrix","ModelOutlineLoader","computeOrderMask","outlineCoordinates","vertexIndex","b","first","second","third","popcount0to63","matchAndStoreCoordinates","i0","i1","i2","has01","has12","has20","a0","b0","i0Mask","b1","c1","i1Mask","a2","c2","i2Mask","workingOrders","i0Popcount","i1Popcount","i2Popcount","i0Start","i1Start","i2Start","isHighlighted","edges","edgeSmallMultiplier","size","updateBufferViewsWithNewVertices","vertexNumberingScope","newVertices","extraVertices","sourceData","newVerticesLength","destData","sourceIndex","destIndex","createdOutlines","outlineCoordinateBuffer","bufferIndex","bufferViewIndex","accessorIndex","_OUTLINE_COORDINATES","usesBuffer","hasExtension","CESIUM_primitive_outline","outlinePrimitives","vertexNumberingScopes","outlineData","vertexCopies","getVertexNumberingScope","edgeIndicesAccessorId","numVertices","triangleIndexAccessorGltf","triangleIndexBufferViewGltf","edgeIndexAccessorGltf","edgeIndexBufferViewGltf","triangleIndexBufferView","edgeIndexBufferView","triangleIndices","Uint32Array","edgeIndices","all","unmatchableVertexIndex","copy","original","_array","forEach","toCreate","addOutline","bufferViewsUsingThisBuffer","filter","bind","newLength","reduce","previous","current","newBuffer","compactBuffers","modelOutliningCache","maxSize","levelZero","ModelUtility","cachedSourceVersion","getAssetVersion","version","primitiveInfoByMaterial","materialIndex","jointAccessorId","JOINTS_0","accessorType","jointAccessor","isSkinned","hasVertexColors","COLOR_0","hasMorphTargets","targets","hasNormals","NORMAL","hasTangents","TANGENT","hasTexCoords","TEXCOORD_0","hasTexCoord1","TEXCOORD_1","hasOutline","primitiveInfo","skinning","skinned","clonedMaterial","toLowerCase","message","bufferResource","getFailedLoadFunction","aMinScratch","aMaxScratch","techniqueAttributeForSemantic","getTechniqueAttributeOrUniformFunction","ignoreNodes","attributeOrUniform","attributeOrUniformName","parameterName","parameters","computeBoundingSphere","gltfNodes","rootNodesLength","_transformToRoot","getTransform","primitivesLength","getAccessorMinMax","aMin","aMax","ensureSemanticExistence","techniquesWebgl","targetAttributes","lowerCase","charAt","pipelineExtras","shaderText","getShaderVariable","ensureSemanticExistenceForPrimitive","createAttributeLocations","hasIndex0","accessorMin","accessorMax","quantizedAttributes","decodedMin","decodedMax","getAttributeOrUniformBySemantic","getDiffuseAttributeOrUniform","diffuseUniformName","nodeTranslationScratch","nodeQuaternionScratch","nodeScaleScratch","replaceAllButFirstInString","find","search","match","getQuantizedAttributes","getAttributeVariableName","attributeSemantic","getScalarUniformFunction","getVec2UniformFunction","getVec3UniformFunction","getVec4UniformFunction","getMat2UniformFunction","getMat3UniformFunction","getMat4UniformFunction","DelayLoadedTextureUniform","_value","_textureId","getUsedExtensions","cachedExtensionsUsed","extensionsUsedLength","getRequiredExtensions","cachedExtensionsRequired","extensionsRequiredLength","supportedExtensions","KHR_binary_glTF","KHR_draco_mesh_compression","KHR_materials_common","KHR_materials_unlit","KHR_materials_pbrSpecularGlossiness","checkSupportedExtensions","browserSupportsWebp","extension","checkSupportedGlExtensions","glExtensionsUsedLength","elementIndexUint","modifyShaderForDracoQuantizedAttributes","attributeVarName","substring","decodeUniformVarName","newMain","decodedAttributeVarName","variableType","octEncoded","vec3Color","decode","decodeUniformVarNameRangeConstant","decodeUniformVarNameNormConstant","decodeUniformVarNameMin","decodeUniformVarNameScale","decodeUniformVarNameTranslate","decodeMatrix","sqrt","mat","vec","gltfUniformFunctions","translateFromMatrix5Array","createUniformFunction","uniformVarName","uniformVarNameRangeConstant","rangeConstant","quantizationBits","uniformVarNameNormConstant","normConstant","range","uniformVarNameMin","minValues","setUniforms","uniformVariable","uniformVariableScale","uniformVariableTranslate","quantizedUniform","properties","scratchTranslationRtc","gltfSemanticUniforms","modelViewProjection","inverseModel","inverseModelView","inverseModelViewProjection","inverseTransposeModel","normal","getGltfSemanticUniforms","Moon","textureUrl","_ellipsoid","onlySunLighting","_ellipsoidPrimitive","radii","depthTestEnabled","_owner","_axes","icrfToFixed","rotationScratch","translationScratch","scratchCommandList","ellipsoidPrimitive","date","time","savedCommandList","Multiple3DTileContent","tilesetResource","contentsJson","_tileset","_tile","_tilesetResource","_contents","contentHeaders","contents","_innerContentHeaders","_requestsInFlight","_cancelCount","contentCount","_arrayFetchPromises","_requests","_innerContentResources","_serverKeys","contentResource","serverKey","_contentsFetchedPromise","updatePendingRequests","multipleContents","deltaRequestCount","statistics","numberOfPendingRequests","requestInnerContent","originalCancelCount","originalContentState","request","throttle","throttleByServer","priorityFunction","_priority","state","handleInnerContentFailed","_contentState","cancelPendingRequests","toString","tileFailed","numberOfListeners","raiseEvent","featurePropertiesDirty","batchTableByteLength","innerContents","readyPromises","Promise","metadata","group","innerContentUrls","contentHeader","contentsFetchedPromise","requestInnerContents","serverKeys","requestCountsByServer","key","canScheduleAllRequests","arrayBuffers","preprocessed","contentType","_disableSkipLevelOfDetail","contentFactory","binaryPayload","jsonPayload","hasImplicitContentMetadata","subtree","implicitSubtree","coordinates","implicitCoordinates","getContentMetadataView","hasImplicitContent","groupMetadata","createInnerContent","createInnerContents","cancelRequests","cancel","hasProperty","getFeature","applyDebugSettings","applyStyle","NeverTileDiscardPolicy","isReady","shouldDiscardImage","OIT","_numSamples","_translucentMultipassSupport","_translucentMRTSupport","extensionsSupported","colorBufferFloat","depthTexture","floatBlend","drawBuffers","_opaqueFBO","_opaqueTexture","_depthStencilTexture","_accumulationTexture","_translucentFBO","colorAttachmentsLength","createColorAttachments","createDepthAttachments","depth","_alphaFBO","_adjustTranslucentFBO","_adjustAlphaFBO","_opaqueClearCommand","_translucentMRTClearCommand","_translucentMultipassClearCommand","_alphaClearCommand","_translucentRenderStateCache","_alphaRenderStateCache","_compositeCommand","_adjustTranslucentCommand","_adjustAlphaCommand","_viewport","_rs","_useScissorTest","_scissorRectangle","_useHDR","destroyTextures","oit","_revealageTexture","destroyFramebuffers","destroyResources","passState","framebuffer","useHDR","numSamples","isSupported","getColorTexture","getDepthStencilTexture","accumulationTexture","textureChanged","samplesChanged","updateTextures","completeFBO","supported","setColorTexture","setDepthStencilTexture","status","translucentComplete","alphaComplete","adjustTranslucentComplete","adjustAlphaComplete","updateFramebuffers","defines","u_opaque","u_accumulation","u_revealage","createViewportQuadCommand","u_bgColor","u_depthTexture","useScissorTest","viewport","updateScissor","scissorTest","rectangle","translucentMRTBlend","translucentColorBlend","translucentAlphaBlend","translucentBlending","translucentState","getTranslucentShaderProgram","keyword","shaderCache","getDerivedShaderProgram","splice","createDerivedShaderProgram","createDerivedCommands","translucentShader","translucentRenderState","shaderProgramId","getTranslucentMRTShaderProgram","colorShader","colorRenderState","alphaShader","alphaRenderState","alphaCommand","getTranslucentColorShaderProgram","getTranslucentColorRenderState","getTranslucentAlphaShaderProgram","getTranslucentAlphaRenderState","executeCommands","executeFunction","invertClassification","useLogDepth","useHdr","_hdr","lightShadowsEnabled","shadowState","debugFramebuffer","derivedCommand","derivedCommands","logDepth","hdr","unclassifiedCommand","executeTranslucentCommandsSortedMRT","executeTranslucentCommandsSortedMultipass","clear","clearColor","OctahedralProjectedCubeMap","_cubeMapBuffers","_cubeMaps","_texture","_mipTextures","_va","_sp","_maximumMipmapLevel","_loading","colorBufferHalfFloat","halfFloatingPointTexture","floatingPointTexture","v1","v2","v3","v4","v5","cubeMapCoordinates","flatCubeMapCoordinates","flatPositions","createUniformTexture","cleanupResources","cubeMaps","mipTextures","cachedTexture","textureCache","cubeMapBuffers","e","positiveX","positionBuffer","cubeMapCoordinatesBuffer","createVertexArray","originalSize","positiveY","negativeY","cubeMap","mipTexture","outputTexture","persists","addTexture","atlasCommand","defaultCredit","OpenStreetMapImageryProvider","appendForwardSlash","fileExtension","tilingScheme","minimumLevel","maximumLevel","swTile","positionToTileXY","neTile","tileCount","abs","tileWidth","tileHeight","create","constructor","OrderedGroundPrimitiveCollection","_length","_collections","_collectionsArray","add","zIndex","destroyPrimitives","_zIndex","remove","doNotDestroy","contains","removeAndDestroy","removeAll","collections","defaultSize","Particle","mass","velocity","life","startColor","endColor","startScale","endScale","imageSize","_age","_normalizedAge","_billboard","age","normalizedAge","deltaScratch","dt","particleUpdateFunction","ParticleBurst","minimum","maximum","_complete","complete","ParticleEmitter","emit","particle","defaultImageSize","ParticleSystem","updateCallback","loop","emitter","_emitter","_bursts","bursts","_emitterModelMatrix","emitterModelMatrix","_matrixDirty","_combinedMatrix","_startColor","_endColor","_startScale","_endScale","_emissionRate","emissionRate","_minimumSpeed","speed","minimumSpeed","_maximumSpeed","maximumSpeed","_minimumParticleLife","particleLife","minimumParticleLife","_maximumParticleLife","maximumParticleLife","_minimumMass","minimumMass","_maximumMass","maximumMass","_minimumImageSize","minimumImageSize","_maximumImageSize","maximumImageSize","_sizeInMeters","sizeInMeters","_lifetime","lifetime","_billboardCollection","_particles","_particlePool","_previousTime","_currentTime","_carryOver","_isComplete","_updateParticlePool","_particleEstimate","getOrCreateParticle","system","addParticleToPool","removeBillboard","updateBillboard","billboard","r","g","addParticle","isComplete","rotatedVelocityScratch","burstAmount","billboardCollection","particleEstimate","particles","particlePool","numToAdd","updateParticlePool","numToEmit","burst","currentTime","calculateNumberToEmit","combinedMatrix","burstLength","numParticles","numInPool","estimate","start","freeParticlePool","PerInstanceColorAppearance","closed","flat","vertexFormat","FLAT_VERTEX_FORMAT","VERTEX_FORMAT","_vertexShaderSource","_fragmentShaderSource","_renderState","_closed","_vertexFormat","_flat","_faceForward","faceForward","getFragmentShaderSource","getRenderState","PerformanceDisplay","container","_container","display","className","fpsElement","_fpsText","createTextNode","appendChild","msElement","_msText","_lastFpsSampleTime","_lastMsSampleTime","_fpsFrameCount","_msFrameCount","_throttled","throttledElement","_throttledText","throttled","nodeValue","renderedThisFrame","updateDisplay","fpsElapsedTime","fps","msElapsedTime","ms","toFixed","PickDepth","_framebuffer","_textureToCopy","_copyDepthCommand","pickDepth","u_texture","updateCopyCommands","scratchPackedDepth","packedDepthScale","getDepth","pixels","readPixels","packedDepth","executeCopyDepth","PickDepthFramebuffer","depthStencil","supportsDepthTexture","_passState","drawingBufferPosition","PickFramebuffer","_context","_fb","_width","_height","begin","screenSpaceRectangle","colorScratch","end","halfWidth","halfHeight","dx","dy","getObjectByPickColor","temp","mostDetailedPreloadTilesetPassState","mostDetailedPickTilesetPassState","pickTilesetPassState","Picking","_mostDetailedRayPicks","pickRenderStateCache","_pickPositionCache","_pickPositionCacheDirty","pickOffscreenViewport","pickOffscreenCamera","aspectRatio","_pickOffscreenView","getPickDepth","pickDepths","scratchOrthoPickingFrustum","scratchOrthoOrigin","scratchOrthoDirection","scratchOrthoPixelSize","scratchOrthoPickVolumeMatrix4","scratchPerspPickingFrustum","scratchPerspPixelSize","getPickCullingVolume","_offCenterFrustum","top","bottom","_setTransform","origin","up","pixelSize","getPixelDimensions","ortho","computeCullingVolume","directionWC","upWC","getPickOrthographicCullingVolume","tanPhi","tan","fovy","tanTheta","xDir","yDir","pickWidth","pickHeight","offCenter","getPickPerspectiveCullingVolume","scratchRectangleWidth","scratchRectangleHeight","scratchRectangle","scratchColorZero","windowPosition","us","defaultView","disableThisFrame","updateFrameState","cullingVolume","tilesetPassState","updateEnvironment","pickFramebuffer","updateAndExecuteCommands","resolveFramebuffers","endFrame","scratchPerspectiveFrustum","scratchPerspectiveOffCenterFrustum","scratchOrthographicFrustum","scratchOrthographicOffCenterFrustum","pickPositionWorldCoordinates","useDepthPicking","pickTranslucentDepth","environmentState","clearPasses","renderTranslucentDepthForPick","pickDepthFramebuffer","fov","infiniteProjectionMatrix","frustumCommandsList","numFrustums","renderedFrustum","height2D","updateFrustum","opaqueFrustumNearOffset","scratchPickPositionCartographic","drillPick","limit","pickCallback","pickedPrimitives","pickedAttributes","pickedFeatures","pickedResult","exclude","hasShowAttribute","getGeometryInstanceAttributes","pickPosition","cart","unproject","element","scratchRight","scratchUp","MostDetailedRayPick","ray","tilesets","deferred","updateOffscreenCameraFromRay","picking","direction","orthogonalAxis","updateMostDetailedRayPick","rayPick","tilesetsLength","updateForPass","getTilesets","objectsToExclude","isCesium3DTileset","launchMostDetailedRayPick","isExcluded","getRayIntersections","requirePosition","mostDetailed","offscreen","distance","getRayIntersection","pickFromRay","results","drillPickFromRay","deferPromiseUntilPostRender","removeCallback","postRender","requestRender","updateMostDetailedRayPicks","rayPicks","pickFromRayMostDetailed","drillPickFromRayMostDetailed","scratchSurfacePosition","scratchSurfaceNormal","scratchSurfaceRay","getRayForSampleHeight","surfaceNormal","geodeticSurfaceNormalCartographic","surfacePosition","surfaceRay","getRayForClampToHeight","getHeightFromCartesian","sampleHeightMostDetailed","pickResult","clampToHeightMostDetailed","sampleHeight","sampleHeightSupported","clampToHeight","clampToHeightSupported","positions","promises","heights","cartesians","clampedCartesians","PntsParser","sizeOfUint32","parse","DataView","getUint32","featureTableJsonByteLength","featureTableBinaryByteLength","batchTableJsonByteLength","batchTableBinaryByteLength","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","featureTable","getGlobalProperty","rtcCenter","parsedContent","dracoBuffer","dracoFeatureTableProperties","dracoBatchTableProperties","featureTableDraco","batchTableDraco","hasPositions","hasColors","hasBatchIds","draco","dracoByteOffset","dracoByteLength","RGB","RGBA","BATCH_ID","featureTableProperties","batchTableProperties","parseDracoProperties","getPropertyArray","isQuantized","POSITION_QUANTIZED","quantizedVolumeScale","quantizedRange","quantizedComponentDatatype","quantizedType","parsePositions","normals","octEncodedZXY","NORMAL_OCT16P","parseNormals","colors","isRGB565","RGB565","CONSTANT_RGBA","constantRGBA","constantColor","parseColors","hasConstantColor","batchIds","parseBatchIds","batchLength"],"sourceRoot":""}