{"version":3,"file":"js/vender~ce1661ac.14e61c12.js","mappings":"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","sources":["webpack:///../../../node_modules/cesium/Source/Scene/Fog.js","webpack:///../../../node_modules/cesium/Source/Scene/FrameRateMonitor.js","webpack:///../../../node_modules/cesium/Source/Scene/FrameState.js","webpack:///../../../node_modules/cesium/Source/Scene/FrustumCommands.js","webpack:///../../../node_modules/cesium/Source/Scene/Geometry3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/GetFeatureInfoFormat.js","webpack:///../../../node_modules/cesium/Source/Scene/Globe.js","webpack:///../../../node_modules/cesium/Source/Scene/GlobeDepth.js","webpack:///../../../node_modules/cesium/Source/Scene/GlobeSurfaceShaderSet.js","webpack:///../../../node_modules/cesium/Source/Scene/GlobeSurfaceTile.js","webpack:///../../../node_modules/cesium/Source/Scene/GlobeSurfaceTileProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/GlobeTranslucency.js","webpack:///../../../node_modules/cesium/Source/Scene/GlobeTranslucencyFramebuffer.js","webpack:///../../../node_modules/cesium/Source/Scene/GlobeTranslucencyState.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfBufferViewLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfDracoLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfImageLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfIndexBufferLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfJsonLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfLoaderUtil.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/ForEach.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/addBuffer.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/addDefaults.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/addExtensionsRequired.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/addExtensionsUsed.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/addPipelineExtras.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/addToArray.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/findAccessorMinMax.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/forEachTextureInMaterial.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/getAccessorByteStride.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/getComponentReader.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/moveTechniqueRenderStates.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/moveTechniquesToExtension.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/numberOfComponentsForType.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/parseGlb.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/readAccessorPacked.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/removeExtensionsRequired.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/removeExtensionsUsed.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/removePipelineExtras.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/removeUnusedElements.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/updateAccessorComponentTypes.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/updateVersion.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfPipeline/usesExtension.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfStructuralMetadataLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfTextureLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/GltfVertexBufferLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/GoogleEarthEnterpriseImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/GoogleEarthEnterpriseMapsProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/GridImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/GroundPolylinePrimitive.js","webpack:///../../../node_modules/cesium/Source/Scene/GroundPrimitive.js","webpack:///../../../node_modules/cesium/Source/Scene/GroupMetadata.js","webpack:///../../../node_modules/cesium/Source/Scene/HeightReference.js","webpack:///../../../node_modules/cesium/Source/Scene/HorizontalOrigin.js","webpack:///../../../node_modules/cesium/Source/Scene/I3dmParser.js","webpack:///../../../node_modules/cesium/Source/Scene/ImageBasedLighting.js","webpack:///../../../node_modules/cesium/Source/Scene/Imagery.js","webpack:///../../../node_modules/cesium/Source/Scene/ImageryLayer.js","webpack:///../../../node_modules/cesium/Source/Scene/ImageryLayerCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/ImageryLayerFeatureInfo.js","webpack:///../../../node_modules/cesium/Source/Scene/ImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/ImageryState.js","webpack:///../../../node_modules/cesium/Source/Scene/Implicit3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/ImplicitAvailabilityBitstream.js","webpack:///../../../node_modules/cesium/Source/Scene/ImplicitMetadataView.js","webpack:///../../../node_modules/cesium/Source/Scene/ImplicitSubdivisionScheme.js","webpack:///../../../node_modules/cesium/Source/Scene/ImplicitSubtree.js","webpack:///../../../node_modules/cesium/Source/Scene/ImplicitSubtreeMetadata.js","webpack:///../../../node_modules/cesium/Source/Scene/ImplicitTileCoordinates.js","webpack:///../../../node_modules/cesium/Source/Scene/ImplicitTileset.js","webpack:///../../../node_modules/cesium/Source/Scene/InstanceAttributeSemantic.js","webpack:///../../../node_modules/cesium/Source/Scene/Instanced3DModel3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/InvertClassification.js","webpack:///../../../node_modules/cesium/Source/Scene/IonImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/IonWorldImageryStyle.js","webpack:///../../../node_modules/cesium/Source/Scene/JobScheduler.js","webpack:///../../../node_modules/cesium/Source/Scene/JobType.js"],"sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional\n * performance improvements by rendering less geometry and dispatching less terrain requests.\n *\n * @alias Fog\n * @constructor\n */\nfunction Fog() {\n  /**\n   * <code>true</code> if fog is enabled, <code>false</code> otherwise.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enabled = true;\n  /**\n   * <code>true</code> if fog is renderable in shaders, <code>false</code> otherwise.\n   * This allows to benefits from optimized tile loading strategy based on fog density without the actual visual rendering.\n   * @type {Boolean}\n   * @default true\n   */\n  this.renderable = true;\n  /**\n   * A scalar that determines the density of the fog. Terrain that is in full fog are culled.\n   * The density of the fog increases as this number approaches 1.0 and becomes less dense as it approaches zero.\n   * The more dense the fog is, the more aggressively the terrain is culled. For example, if the camera is a height of\n   * 1000.0m above the ellipsoid, increasing the value to 3.0e-3 will cause many tiles close to the viewer be culled.\n   * Decreasing the value will push the fog further from the viewer, but decrease performance as more of the terrain is rendered.\n   * @type {Number}\n   * @default 2.0e-4\n   */\n  this.density = 2.0e-4;\n  /**\n   * A factor used to increase the screen space error of terrain tiles when they are partially in fog. The effect is to reduce\n   * the number of terrain tiles requested for rendering. If set to zero, the feature will be disabled. If the value is increased\n   * for mountainous regions, less tiles will need to be requested, but the terrain meshes near the horizon may be a noticeably\n   * lower resolution. If the value is increased in a relatively flat area, there will be little noticeable change on the horizon.\n   * @type {Number}\n   * @default 2.0\n   */\n  this.screenSpaceErrorFactor = 2.0;\n  /**\n   * The minimum brightness of the fog color from lighting. A value of 0.0 can cause the fog to be completely black. A value of 1.0 will not affect\n   * the brightness at all.\n   * @type {Number}\n   * @default 0.03\n   */\n  this.minimumBrightness = 0.03;\n}\n\n// These values were found by sampling the density at certain views and finding at what point culled tiles impacted the view at the horizon.\nconst heightsTable = [\n  359.393,\n  800.749,\n  1275.6501,\n  2151.1192,\n  3141.7763,\n  4777.5198,\n  6281.2493,\n  12364.307,\n  15900.765,\n  49889.0549,\n  78026.8259,\n  99260.7344,\n  120036.3873,\n  151011.0158,\n  156091.1953,\n  203849.3112,\n  274866.9803,\n  319916.3149,\n  493552.0528,\n  628733.5874,\n];\nconst densityTable = [\n  2.0e-5,\n  2.0e-4,\n  1.0e-4,\n  7.0e-5,\n  5.0e-5,\n  4.0e-5,\n  3.0e-5,\n  1.9e-5,\n  1.0e-5,\n  8.5e-6,\n  6.2e-6,\n  5.8e-6,\n  5.3e-6,\n  5.2e-6,\n  5.1e-6,\n  4.2e-6,\n  4.0e-6,\n  3.4e-6,\n  2.6e-6,\n  2.2e-6,\n];\n\n// Scale densities by 1e6 to bring lowest value to ~1. Prevents divide by zero.\nfor (let i = 0; i < densityTable.length; ++i) {\n  densityTable[i] *= 1.0e6;\n}\n// Change range to [0, 1].\nconst tableStartDensity = densityTable[1];\nconst tableEndDensity = densityTable[densityTable.length - 1];\nfor (let j = 0; j < densityTable.length; ++j) {\n  densityTable[j] =\n    (densityTable[j] - tableEndDensity) / (tableStartDensity - tableEndDensity);\n}\n\nlet tableLastIndex = 0;\n\nfunction findInterval(height) {\n  const heights = heightsTable;\n  const length = heights.length;\n\n  if (height < heights[0]) {\n    tableLastIndex = 0;\n    return tableLastIndex;\n  } else if (height > heights[length - 1]) {\n    tableLastIndex = length - 2;\n    return tableLastIndex;\n  }\n\n  // Take advantage of temporal coherence by checking current, next and previous intervals\n  // for containment of time.\n  if (height >= heights[tableLastIndex]) {\n    if (tableLastIndex + 1 < length && height < heights[tableLastIndex + 1]) {\n      return tableLastIndex;\n    } else if (\n      tableLastIndex + 2 < length &&\n      height < heights[tableLastIndex + 2]\n    ) {\n      ++tableLastIndex;\n      return tableLastIndex;\n    }\n  } else if (tableLastIndex - 1 >= 0 && height >= heights[tableLastIndex - 1]) {\n    --tableLastIndex;\n    return tableLastIndex;\n  }\n\n  // The above failed so do a linear search.\n  let i;\n  for (i = 0; i < length - 2; ++i) {\n    if (height >= heights[i] && height < heights[i + 1]) {\n      break;\n    }\n  }\n\n  tableLastIndex = i;\n  return tableLastIndex;\n}\n\nconst scratchPositionNormal = new Cartesian3();\n\nFog.prototype.update = function (frameState) {\n  const enabled = (frameState.fog.enabled = this.enabled);\n  if (!enabled) {\n    return;\n  }\n\n  frameState.fog.renderable = this.renderable;\n\n  const camera = frameState.camera;\n  const positionCartographic = camera.positionCartographic;\n\n  // Turn off fog in space.\n  if (\n    !defined(positionCartographic) ||\n    positionCartographic.height > 800000.0 ||\n    frameState.mode !== SceneMode.SCENE3D\n  ) {\n    frameState.fog.enabled = false;\n    return;\n  }\n\n  const height = positionCartographic.height;\n  const i = findInterval(height);\n  const t = CesiumMath.clamp(\n    (height - heightsTable[i]) / (heightsTable[i + 1] - heightsTable[i]),\n    0.0,\n    1.0\n  );\n  let density = CesiumMath.lerp(densityTable[i], densityTable[i + 1], t);\n\n  // Again, scale value to be in the range of densityTable (prevents divide by zero) and change to new range.\n  const startDensity = this.density * 1.0e6;\n  const endDensity = (startDensity / tableStartDensity) * tableEndDensity;\n  density = density * (startDensity - endDensity) * 1.0e-6;\n\n  // Fade fog in as the camera tilts toward the horizon.\n  const positionNormal = Cartesian3.normalize(\n    camera.positionWC,\n    scratchPositionNormal\n  );\n  const dot = Math.abs(Cartesian3.dot(camera.directionWC, positionNormal));\n  density *= 1.0 - dot;\n\n  frameState.fog.density = density;\n  frameState.fog.sse = this.screenSpaceErrorFactor;\n  frameState.fog.minimumBrightness = this.minimumBrightness;\n};\nexport default Fog;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport TimeConstants from \"../Core/TimeConstants.js\";\n\n/**\n * Monitors the frame rate (frames per second) in a {@link Scene} and raises an event if the frame rate is\n * lower than a threshold.  Later, if the frame rate returns to the required level, a separate event is raised.\n * To avoid creating multiple FrameRateMonitors for a single {@link Scene}, use {@link FrameRateMonitor.fromScene}\n * instead of constructing an instance explicitly.\n *\n * @alias FrameRateMonitor\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Scene} options.scene The Scene instance for which to monitor performance.\n * @param {Number} [options.samplingWindow=5.0] The length of the sliding window over which to compute the average frame rate, in seconds.\n * @param {Number} [options.quietPeriod=2.0] The length of time to wait at startup and each time the page becomes visible (i.e. when the user\n *        switches back to the tab) before starting to measure performance, in seconds.\n * @param {Number} [options.warmupPeriod=5.0] The length of the warmup period, in seconds.  During the warmup period, a separate\n *        (usually lower) frame rate is required.\n * @param {Number} [options.minimumFrameRateDuringWarmup=4] The minimum frames-per-second that are required for acceptable performance during\n *        the warmup period.  If the frame rate averages less than this during any samplingWindow during the warmupPeriod, the\n *        lowFrameRate event will be raised and the page will redirect to the redirectOnLowFrameRateUrl, if any.\n * @param {Number} [options.minimumFrameRateAfterWarmup=8] The minimum frames-per-second that are required for acceptable performance after\n *        the end of the warmup period.  If the frame rate averages less than this during any samplingWindow after the warmupPeriod, the\n *        lowFrameRate event will be raised and the page will redirect to the redirectOnLowFrameRateUrl, if any.\n */\nfunction FrameRateMonitor(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.scene)) {\n    throw new DeveloperError(\"options.scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._scene = options.scene;\n\n  /**\n   * Gets or sets the length of the sliding window over which to compute the average frame rate, in seconds.\n   * @type {Number}\n   */\n  this.samplingWindow = defaultValue(\n    options.samplingWindow,\n    FrameRateMonitor.defaultSettings.samplingWindow\n  );\n\n  /**\n   * Gets or sets the length of time to wait at startup and each time the page becomes visible (i.e. when the user\n   * switches back to the tab) before starting to measure performance, in seconds.\n   * @type {Number}\n   */\n  this.quietPeriod = defaultValue(\n    options.quietPeriod,\n    FrameRateMonitor.defaultSettings.quietPeriod\n  );\n\n  /**\n   * Gets or sets the length of the warmup period, in seconds.  During the warmup period, a separate\n   * (usually lower) frame rate is required.\n   * @type {Number}\n   */\n  this.warmupPeriod = defaultValue(\n    options.warmupPeriod,\n    FrameRateMonitor.defaultSettings.warmupPeriod\n  );\n\n  /**\n   * Gets or sets the minimum frames-per-second that are required for acceptable performance during\n   * the warmup period.  If the frame rate averages less than this during any <code>samplingWindow</code> during the <code>warmupPeriod</code>, the\n   * <code>lowFrameRate</code> event will be raised and the page will redirect to the <code>redirectOnLowFrameRateUrl</code>, if any.\n   * @type {Number}\n   */\n  this.minimumFrameRateDuringWarmup = defaultValue(\n    options.minimumFrameRateDuringWarmup,\n    FrameRateMonitor.defaultSettings.minimumFrameRateDuringWarmup\n  );\n\n  /**\n   * Gets or sets the minimum frames-per-second that are required for acceptable performance after\n   * the end of the warmup period.  If the frame rate averages less than this during any <code>samplingWindow</code> after the <code>warmupPeriod</code>, the\n   * <code>lowFrameRate</code> event will be raised and the page will redirect to the <code>redirectOnLowFrameRateUrl</code>, if any.\n   * @type {Number}\n   */\n  this.minimumFrameRateAfterWarmup = defaultValue(\n    options.minimumFrameRateAfterWarmup,\n    FrameRateMonitor.defaultSettings.minimumFrameRateAfterWarmup\n  );\n\n  this._lowFrameRate = new Event();\n  this._nominalFrameRate = new Event();\n\n  this._frameTimes = [];\n  this._needsQuietPeriod = true;\n  this._quietPeriodEndTime = 0.0;\n  this._warmupPeriodEndTime = 0.0;\n  this._frameRateIsLow = false;\n  this._lastFramesPerSecond = undefined;\n  this._pauseCount = 0;\n\n  const that = this;\n  this._preUpdateRemoveListener = this._scene.preUpdate.addEventListener(\n    function (scene, time) {\n      update(that, time);\n    }\n  );\n\n  this._hiddenPropertyName =\n    document.hidden !== undefined\n      ? \"hidden\"\n      : document.mozHidden !== undefined\n      ? \"mozHidden\"\n      : document.msHidden !== undefined\n      ? \"msHidden\"\n      : document.webkitHidden !== undefined\n      ? \"webkitHidden\"\n      : undefined;\n\n  const visibilityChangeEventName =\n    document.hidden !== undefined\n      ? \"visibilitychange\"\n      : document.mozHidden !== undefined\n      ? \"mozvisibilitychange\"\n      : document.msHidden !== undefined\n      ? \"msvisibilitychange\"\n      : document.webkitHidden !== undefined\n      ? \"webkitvisibilitychange\"\n      : undefined;\n\n  function visibilityChangeListener() {\n    visibilityChanged(that);\n  }\n\n  this._visibilityChangeRemoveListener = undefined;\n  if (defined(visibilityChangeEventName)) {\n    document.addEventListener(\n      visibilityChangeEventName,\n      visibilityChangeListener,\n      false\n    );\n\n    this._visibilityChangeRemoveListener = function () {\n      document.removeEventListener(\n        visibilityChangeEventName,\n        visibilityChangeListener,\n        false\n      );\n    };\n  }\n}\n\n/**\n * The default frame rate monitoring settings.  These settings are used when {@link FrameRateMonitor.fromScene}\n * needs to create a new frame rate monitor, and for any settings that are not passed to the\n * {@link FrameRateMonitor} constructor.\n *\n * @memberof FrameRateMonitor\n * @type {Object}\n */\nFrameRateMonitor.defaultSettings = {\n  samplingWindow: 5.0,\n  quietPeriod: 2.0,\n  warmupPeriod: 5.0,\n  minimumFrameRateDuringWarmup: 4,\n  minimumFrameRateAfterWarmup: 8,\n};\n\n/**\n * Gets the {@link FrameRateMonitor} for a given scene.  If the scene does not yet have\n * a {@link FrameRateMonitor}, one is created with the {@link FrameRateMonitor.defaultSettings}.\n *\n * @param {Scene} scene The scene for which to get the {@link FrameRateMonitor}.\n * @returns {FrameRateMonitor} The scene's {@link FrameRateMonitor}.\n */\nFrameRateMonitor.fromScene = function (scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (\n    !defined(scene._frameRateMonitor) ||\n    scene._frameRateMonitor.isDestroyed()\n  ) {\n    scene._frameRateMonitor = new FrameRateMonitor({\n      scene: scene,\n    });\n  }\n\n  return scene._frameRateMonitor;\n};\n\nObject.defineProperties(FrameRateMonitor.prototype, {\n  /**\n   * Gets the {@link Scene} instance for which to monitor performance.\n   * @memberof FrameRateMonitor.prototype\n   * @type {Scene}\n   */\n  scene: {\n    get: function () {\n      return this._scene;\n    },\n  },\n\n  /**\n   * Gets the event that is raised when a low frame rate is detected.  The function will be passed\n   * the {@link Scene} instance as its first parameter and the average number of frames per second\n   * over the sampling window as its second parameter.\n   * @memberof FrameRateMonitor.prototype\n   * @type {Event}\n   */\n  lowFrameRate: {\n    get: function () {\n      return this._lowFrameRate;\n    },\n  },\n\n  /**\n   * Gets the event that is raised when the frame rate returns to a normal level after having been low.\n   * The function will be passed the {@link Scene} instance as its first parameter and the average\n   * number of frames per second over the sampling window as its second parameter.\n   * @memberof FrameRateMonitor.prototype\n   * @type {Event}\n   */\n  nominalFrameRate: {\n    get: function () {\n      return this._nominalFrameRate;\n    },\n  },\n\n  /**\n   * Gets the most recently computed average frames-per-second over the last <code>samplingWindow</code>.\n   * This property may be undefined if the frame rate has not been computed.\n   * @memberof FrameRateMonitor.prototype\n   * @type {Number}\n   */\n  lastFramesPerSecond: {\n    get: function () {\n      return this._lastFramesPerSecond;\n    },\n  },\n});\n\n/**\n * Pauses monitoring of the frame rate.  To resume monitoring, {@link FrameRateMonitor#unpause}\n * must be called once for each time this function is called.\n * @memberof FrameRateMonitor\n */\nFrameRateMonitor.prototype.pause = function () {\n  ++this._pauseCount;\n  if (this._pauseCount === 1) {\n    this._frameTimes.length = 0;\n    this._lastFramesPerSecond = undefined;\n  }\n};\n\n/**\n * Resumes monitoring of the frame rate.  If {@link FrameRateMonitor#pause} was called\n * multiple times, this function must be called the same number of times in order to\n * actually resume monitoring.\n * @memberof FrameRateMonitor\n */\nFrameRateMonitor.prototype.unpause = function () {\n  --this._pauseCount;\n  if (this._pauseCount <= 0) {\n    this._pauseCount = 0;\n    this._needsQuietPeriod = true;\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @memberof FrameRateMonitor\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see FrameRateMonitor#destroy\n */\nFrameRateMonitor.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Unsubscribes this instance from all events it is listening to.\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @memberof FrameRateMonitor\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see FrameRateMonitor#isDestroyed\n */\nFrameRateMonitor.prototype.destroy = function () {\n  this._preUpdateRemoveListener();\n\n  if (defined(this._visibilityChangeRemoveListener)) {\n    this._visibilityChangeRemoveListener();\n  }\n\n  return destroyObject(this);\n};\n\nfunction update(monitor, time) {\n  if (monitor._pauseCount > 0) {\n    return;\n  }\n\n  const timeStamp = getTimestamp();\n\n  if (monitor._needsQuietPeriod) {\n    monitor._needsQuietPeriod = false;\n    monitor._frameTimes.length = 0;\n    monitor._quietPeriodEndTime =\n      timeStamp + monitor.quietPeriod / TimeConstants.SECONDS_PER_MILLISECOND;\n    monitor._warmupPeriodEndTime =\n      monitor._quietPeriodEndTime +\n      (monitor.warmupPeriod + monitor.samplingWindow) /\n        TimeConstants.SECONDS_PER_MILLISECOND;\n  } else if (timeStamp >= monitor._quietPeriodEndTime) {\n    monitor._frameTimes.push(timeStamp);\n\n    const beginningOfWindow =\n      timeStamp -\n      monitor.samplingWindow / TimeConstants.SECONDS_PER_MILLISECOND;\n\n    if (\n      monitor._frameTimes.length >= 2 &&\n      monitor._frameTimes[0] <= beginningOfWindow\n    ) {\n      while (\n        monitor._frameTimes.length >= 2 &&\n        monitor._frameTimes[1] < beginningOfWindow\n      ) {\n        monitor._frameTimes.shift();\n      }\n\n      const averageTimeBetweenFrames =\n        (timeStamp - monitor._frameTimes[0]) / (monitor._frameTimes.length - 1);\n\n      monitor._lastFramesPerSecond = 1000.0 / averageTimeBetweenFrames;\n\n      const maximumFrameTime =\n        1000.0 /\n        (timeStamp > monitor._warmupPeriodEndTime\n          ? monitor.minimumFrameRateAfterWarmup\n          : monitor.minimumFrameRateDuringWarmup);\n      if (averageTimeBetweenFrames > maximumFrameTime) {\n        if (!monitor._frameRateIsLow) {\n          monitor._frameRateIsLow = true;\n          monitor._needsQuietPeriod = true;\n          monitor.lowFrameRate.raiseEvent(\n            monitor.scene,\n            monitor._lastFramesPerSecond\n          );\n        }\n      } else if (monitor._frameRateIsLow) {\n        monitor._frameRateIsLow = false;\n        monitor._needsQuietPeriod = true;\n        monitor.nominalFrameRate.raiseEvent(\n          monitor.scene,\n          monitor._lastFramesPerSecond\n        );\n      }\n    }\n  }\n}\n\nfunction visibilityChanged(monitor) {\n  if (document[monitor._hiddenPropertyName]) {\n    monitor.pause();\n  } else {\n    monitor.unpause();\n  }\n}\nexport default FrameRateMonitor;\n","import SceneMode from \"./SceneMode.js\";\n\n/**\n * State information about the current frame.  An instance of this class\n * is provided to update functions.\n *\n * @param {Context} context The rendering context\n * @param {CreditDisplay} creditDisplay Handles adding and removing credits from an HTML element\n * @param {JobScheduler} jobScheduler The job scheduler\n *\n * @alias FrameState\n * @constructor\n *\n * @private\n */\nfunction FrameState(context, creditDisplay, jobScheduler) {\n  /**\n   * The rendering context.\n   *\n   * @type {Context}\n   */\n  this.context = context;\n\n  /**\n   * An array of rendering commands.\n   *\n   * @type {DrawCommand[]}\n   */\n  this.commandList = [];\n\n  /**\n   * An array of shadow maps.\n   * @type {ShadowMap[]}\n   */\n  this.shadowMaps = [];\n\n  /**\n   * The BRDF look up texture generator used for image-based lighting for PBR models\n   * @type {BrdfLutGenerator}\n   */\n  this.brdfLutGenerator = undefined;\n\n  /**\n   * The environment map used for image-based lighting for PBR models\n   * @type {CubeMap}\n   */\n  this.environmentMap = undefined;\n\n  /**\n   * The spherical harmonic coefficients used for image-based lighting for PBR models.\n   * @type {Cartesian3[]}\n   */\n  this.sphericalHarmonicCoefficients = undefined;\n\n  /**\n   * The specular environment atlas used for image-based lighting for PBR models.\n   * @type {Texture}\n   */\n  this.specularEnvironmentMaps = undefined;\n\n  /**\n   * The maximum level-of-detail of the specular environment atlas used for image-based lighting for PBR models.\n   * @type {Number}\n   */\n  this.specularEnvironmentMapsMaximumLOD = undefined;\n\n  /**\n   * The current mode of the scene.\n   *\n   * @type {SceneMode}\n   * @default {@link SceneMode.SCENE3D}\n   */\n  this.mode = SceneMode.SCENE3D;\n\n  /**\n   * The current morph transition time between 2D/Columbus View and 3D,\n   * with 0.0 being 2D or Columbus View and 1.0 being 3D.\n   *\n   * @type {Number}\n   */\n  this.morphTime = SceneMode.getMorphTime(SceneMode.SCENE3D);\n\n  /**\n   * The current frame number.\n   *\n   * @type {Number}\n   * @default 0\n   */\n  this.frameNumber = 0;\n\n  /**\n   * <code>true</code> if a new frame has been issued and the frame number has been updated.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.newFrame = false;\n\n  /**\n   * The scene's current time.\n   *\n   * @type {JulianDate}\n   * @default undefined\n   */\n  this.time = undefined;\n\n  /**\n   * The job scheduler.\n   *\n   * @type {JobScheduler}\n   */\n  this.jobScheduler = jobScheduler;\n\n  /**\n   * The map projection to use in 2D and Columbus View modes.\n   *\n   * @type {MapProjection}\n   * @default undefined\n   */\n  this.mapProjection = undefined;\n\n  /**\n   * The current camera.\n   *\n   * @type {Camera}\n   * @default undefined\n   */\n  this.camera = undefined;\n\n  /**\n   * Whether the camera is underground.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.cameraUnderground = false;\n\n  /**\n   * The {@link GlobeTranslucencyState} object used by the scene.\n   *\n   * @type {GlobeTranslucencyState}\n   * @default undefined\n   */\n  this.globeTranslucencyState = undefined;\n\n  /**\n   * The culling volume.\n   *\n   * @type {CullingVolume}\n   * @default undefined\n   */\n  this.cullingVolume = undefined;\n\n  /**\n   * The current occluder.\n   *\n   * @type {Occluder}\n   * @default undefined\n   */\n  this.occluder = undefined;\n\n  /**\n   * The maximum screen-space error used to drive level-of-detail refinement.  Higher\n   * values will provide better performance but lower visual quality.\n   *\n   * @type {Number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = undefined;\n\n  /**\n   * Ratio between a pixel and a density-independent pixel. Provides a standard unit of\n   * measure for real pixel measurements appropriate to a particular device.\n   *\n   * @type {Number}\n   * @default 1.0\n   */\n  this.pixelRatio = 1.0;\n\n  /**\n   * @typedef FrameState.Passes\n   * @type {Object}\n   * @property {Boolean} render <code>true</code> if the primitive should update for a render pass, <code>false</code> otherwise.\n   * @property {Boolean} pick <code>true</code> if the primitive should update for a picking pass, <code>false</code> otherwise.\n   * @property {Boolean} depth <code>true</code> if the primitive should update for a depth only pass, <code>false</code> otherwise.\n   * @property {Boolean} postProcess <code>true</code> if the primitive should update for a per-feature post-process pass, <code>false</code> otherwise.\n   * @property {Boolean} offscreen <code>true</code> if the primitive should update for an offscreen pass, <code>false</code> otherwise.\n   */\n\n  /**\n   * @type {FrameState.Passes}\n   */\n  this.passes = {\n    /**\n     * @default false\n     */\n    render: false,\n    /**\n     * @default false\n     */\n    pick: false,\n    /**\n     * @default false\n     */\n    depth: false,\n    /**\n     * @default false\n     */\n    postProcess: false,\n    /**\n     * @default false\n     */\n    offscreen: false,\n  };\n\n  /**\n   * The credit display.\n   *\n   * @type {CreditDisplay}\n   */\n  this.creditDisplay = creditDisplay;\n\n  /**\n   * An array of functions to be called at the end of the frame.  This array\n   * will be cleared after each frame.\n   * <p>\n   * This allows queueing up events in <code>update</code> functions and\n   * firing them at a time when the subscribers are free to change the\n   * scene state, e.g., manipulate the camera, instead of firing events\n   * directly in <code>update</code> functions.\n   * </p>\n   *\n   * @type {FrameState.AfterRenderCallback[]}\n   *\n   * @example\n   * frameState.afterRender.push(function() {\n   *   // take some action, raise an event, etc.\n   * });\n   */\n  this.afterRender = [];\n\n  /**\n   * Gets whether or not to optimize for 3D only.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.scene3DOnly = false;\n\n  /**\n   * @typedef FrameState.Fog\n   * @type {Object}\n   * @property {Boolean} enabled <code>true</code> if fog is enabled, <code>false</code> otherwise.\n   * @property {Number} density A positive number used to mix the color and fog color based on camera distance.\n   * @property {Number} sse A scalar used to modify the screen space error of geometry partially in fog.\n   * @property {Number} minimumBrightness The minimum brightness of terrain with fog applied.\n   */\n\n  /**\n   * @type {FrameState.Fog}\n   */\n\n  this.fog = {\n    /**\n     * @default false\n     */\n    enabled: false,\n    density: undefined,\n    sse: undefined,\n    minimumBrightness: undefined,\n  };\n\n  /**\n   * A scalar used to exaggerate the terrain.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.terrainExaggeration = 1.0;\n\n  /**\n   * The height relative to which terrain is exaggerated.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.terrainExaggerationRelativeHeight = 0.0;\n\n  /**\n   * @typedef FrameState.ShadowState\n   * @type {Object}\n   * @property {Boolean} shadowsEnabled Whether there are any active shadow maps this frame.\n   * @property {Boolean} lightShadowsEnabled Whether there are any active shadow maps that originate from light sources. Does not include shadow maps that are used for analytical purposes.\n   * @property {ShadowMap[]} shadowMaps All shadow maps that are enabled this frame.\n   * @property {ShadowMap[]} lightShadowMaps Shadow maps that originate from light sources. Does not include shadow maps that are used for analytical purposes. Only these shadow maps will be used to generate receive shadows shaders.\n   * @property {Number} nearPlane The near plane of the scene's frustum commands. Used for fitting cascaded shadow maps.\n   * @property {Number} farPlane The far plane of the scene's frustum commands. Used for fitting cascaded shadow maps.\n   * @property {Number} closestObjectSize The size of the bounding volume that is closest to the camera. This is used to place more shadow detail near the object.\n   * @property {Number} lastDirtyTime The time when a shadow map was last dirty\n   * @property {Boolean} outOfView Whether the shadows maps are out of view this frame\n   */\n\n  /**\n   * @type {FrameState.ShadowState}\n   */\n\n  this.shadowState = {\n    /**\n     * @default true\n     */\n    shadowsEnabled: true,\n    shadowMaps: [],\n    lightShadowMaps: [],\n    /**\n     * @default 1.0\n     */\n    nearPlane: 1.0,\n    /**\n     * @default 5000.0\n     */\n    farPlane: 5000.0,\n    /**\n     * @default 1000.0\n     */\n    closestObjectSize: 1000.0,\n    /**\n     * @default 0\n     */\n    lastDirtyTime: 0,\n    /**\n     * @default true\n     */\n    outOfView: true,\n  };\n\n  /**\n   * The position of the splitter to use when rendering different things on either side of a splitter.\n   * This value should be between 0.0 and 1.0 with 0 being the far left of the viewport and 1 being the far right of the viewport.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.splitPosition = 0.0;\n\n  /**\n   * Distances to the near and far planes of the camera frustums\n   * @type {Number[]}\n   * @default []\n   */\n  this.frustumSplits = [];\n\n  /**\n   * The current scene background color\n   *\n   * @type {Color}\n   */\n  this.backgroundColor = undefined;\n\n  /**\n   * The light used to shade the scene.\n   *\n   * @type {Light}\n   */\n  this.light = undefined;\n\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied.\n   * @type {Number}\n   */\n  this.minimumDisableDepthTestDistance = undefined;\n\n  /**\n   * When <code>false</code>, 3D Tiles will render normally. When <code>true</code>, classified 3D Tile geometry will render normally and\n   * unclassified 3D Tile geometry will render with the color multiplied with {@link FrameState#invertClassificationColor}.\n   * @type {Boolean}\n   * @default false\n   */\n  this.invertClassification = false;\n\n  /**\n   * The highlight color of unclassified 3D Tile geometry when {@link FrameState#invertClassification} is <code>true</code>.\n   * @type {Color}\n   */\n  this.invertClassificationColor = undefined;\n\n  /**\n   * Whether or not the scene uses a logarithmic depth buffer.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.useLogDepth = false;\n\n  /**\n   * Additional state used to update 3D Tilesets.\n   *\n   * @type {Cesium3DTilePassState}\n   */\n  this.tilesetPassState = undefined;\n\n  /**\n   * The minimum terrain height out of all rendered terrain tiles. Used to improve culling for objects underneath the ellipsoid but above terrain.\n   *\n   * @type {Number}\n   * @default 0.0\n   */\n  this.minimumTerrainHeight = 0.0;\n}\n\n/**\n * A function that will be called at the end of the frame.\n *\n * @callback FrameState.AfterRenderCallback\n */\nexport default FrameState;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport Pass from \"../Renderer/Pass.js\";\n\n/**\n * Defines a list of commands whose geometry are bound by near and far distances from the camera.\n * @alias FrustumCommands\n * @constructor\n *\n * @param {Number} [near=0.0] The lower bound or closest distance from the camera.\n * @param {Number} [far=0.0] The upper bound or farthest distance from the camera.\n *\n * @private\n */\nfunction FrustumCommands(near, far) {\n  this.near = defaultValue(near, 0.0);\n  this.far = defaultValue(far, 0.0);\n\n  const numPasses = Pass.NUMBER_OF_PASSES;\n  const commands = new Array(numPasses);\n  const indices = new Array(numPasses);\n\n  for (let i = 0; i < numPasses; ++i) {\n    commands[i] = [];\n    indices[i] = 0;\n  }\n\n  this.commands = commands;\n  this.indices = indices;\n}\nexport default FrustumCommands;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Vector3DTileGeometry from \"./Vector3DTileGeometry.js\";\n\n/**\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Geometry3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Geometry3DTileContent(\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset\n) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n  this._geometries = undefined;\n\n  this._metadata = undefined;\n\n  this._batchTable = undefined;\n  this._features = undefined;\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface.\n   */\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n\n  this._readyPromise = initialize(this, arrayBuffer, byteOffset);\n}\n\nObject.defineProperties(Geometry3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.featuresLength : 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      if (defined(this._geometries)) {\n        return this._geometries.trianglesLength;\n      }\n      return 0;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      if (defined(this._geometries)) {\n        return this._geometries.geometryByteLength;\n      }\n      return 0;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return defined(this._batchTable) ? this._batchTable.memorySizeInBytes : 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\nfunction createColorChangedCallback(content) {\n  return function (batchId, color) {\n    if (defined(content._geometries)) {\n      content._geometries.updateCommands(batchId, color);\n    }\n  };\n}\n\nfunction getBatchIds(featureTableJson, featureTableBinary) {\n  let boxBatchIds;\n  let cylinderBatchIds;\n  let ellipsoidBatchIds;\n  let sphereBatchIds;\n  let i;\n\n  const numberOfBoxes = defaultValue(featureTableJson.BOXES_LENGTH, 0);\n  const numberOfCylinders = defaultValue(featureTableJson.CYLINDERS_LENGTH, 0);\n  const numberOfEllipsoids = defaultValue(\n    featureTableJson.ELLIPSOIDS_LENGTH,\n    0\n  );\n  const numberOfSpheres = defaultValue(featureTableJson.SPHERES_LENGTH, 0);\n\n  if (numberOfBoxes > 0 && defined(featureTableJson.BOX_BATCH_IDS)) {\n    const boxBatchIdsByteOffset =\n      featureTableBinary.byteOffset + featureTableJson.BOX_BATCH_IDS.byteOffset;\n    boxBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      boxBatchIdsByteOffset,\n      numberOfBoxes\n    );\n  }\n\n  if (numberOfCylinders > 0 && defined(featureTableJson.CYLINDER_BATCH_IDS)) {\n    const cylinderBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.CYLINDER_BATCH_IDS.byteOffset;\n    cylinderBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      cylinderBatchIdsByteOffset,\n      numberOfCylinders\n    );\n  }\n\n  if (numberOfEllipsoids > 0 && defined(featureTableJson.ELLIPSOID_BATCH_IDS)) {\n    const ellipsoidBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.ELLIPSOID_BATCH_IDS.byteOffset;\n    ellipsoidBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      ellipsoidBatchIdsByteOffset,\n      numberOfEllipsoids\n    );\n  }\n\n  if (numberOfSpheres > 0 && defined(featureTableJson.SPHERE_BATCH_IDS)) {\n    const sphereBatchIdsByteOffset =\n      featureTableBinary.byteOffset +\n      featureTableJson.SPHERE_BATCH_IDS.byteOffset;\n    sphereBatchIds = new Uint16Array(\n      featureTableBinary.buffer,\n      sphereBatchIdsByteOffset,\n      numberOfSpheres\n    );\n  }\n\n  const atLeastOneDefined =\n    defined(boxBatchIds) ||\n    defined(cylinderBatchIds) ||\n    defined(ellipsoidBatchIds) ||\n    defined(sphereBatchIds);\n  const atLeastOneUndefined =\n    (numberOfBoxes > 0 && !defined(boxBatchIds)) ||\n    (numberOfCylinders > 0 && !defined(cylinderBatchIds)) ||\n    (numberOfEllipsoids > 0 && !defined(ellipsoidBatchIds)) ||\n    (numberOfSpheres > 0 && !defined(sphereBatchIds));\n\n  if (atLeastOneDefined && atLeastOneUndefined) {\n    throw new RuntimeError(\n      \"If one group of batch ids is defined, then all batch ids must be defined.\"\n    );\n  }\n\n  const allUndefinedBatchIds =\n    !defined(boxBatchIds) &&\n    !defined(cylinderBatchIds) &&\n    !defined(ellipsoidBatchIds) &&\n    !defined(sphereBatchIds);\n  if (allUndefinedBatchIds) {\n    let id = 0;\n    if (!defined(boxBatchIds) && numberOfBoxes > 0) {\n      boxBatchIds = new Uint16Array(numberOfBoxes);\n      for (i = 0; i < numberOfBoxes; ++i) {\n        boxBatchIds[i] = id++;\n      }\n    }\n    if (!defined(cylinderBatchIds) && numberOfCylinders > 0) {\n      cylinderBatchIds = new Uint16Array(numberOfCylinders);\n      for (i = 0; i < numberOfCylinders; ++i) {\n        cylinderBatchIds[i] = id++;\n      }\n    }\n    if (!defined(ellipsoidBatchIds) && numberOfEllipsoids > 0) {\n      ellipsoidBatchIds = new Uint16Array(numberOfEllipsoids);\n      for (i = 0; i < numberOfEllipsoids; ++i) {\n        ellipsoidBatchIds[i] = id++;\n      }\n    }\n    if (!defined(sphereBatchIds) && numberOfSpheres > 0) {\n      sphereBatchIds = new Uint16Array(numberOfSpheres);\n      for (i = 0; i < numberOfSpheres; ++i) {\n        sphereBatchIds[i] = id++;\n      }\n    }\n  }\n\n  return {\n    boxes: boxBatchIds,\n    cylinders: cylinderBatchIds,\n    ellipsoids: ellipsoidBatchIds,\n    spheres: sphereBatchIds,\n  };\n}\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction initialize(content, arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic number\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Geometry tile version 1 is supported.  Version ${version} is not.`\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (byteLength === 0) {\n    content._readyPromise.resolve(content);\n    return;\n  }\n\n  const featureTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  if (featureTableJSONByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\"\n    );\n  }\n\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableJSONByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const featureTableJson = getJsonFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJSONByteLength\n  );\n  byteOffset += featureTableJSONByteLength;\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJSONByteLength > 0) {\n    // PERFORMANCE_IDEA: is it possible to allocate this on-demand?  Perhaps keep the\n    // arraybuffer/string compressed in memory and then decompress it when it is first accessed.\n    //\n    // We could also make another request for it, but that would make the property set/get\n    // API async, and would double the number of numbers in some cases.\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJSONByteLength\n    );\n    byteOffset += batchTableJSONByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength\n      );\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n  }\n\n  const numberOfBoxes = defaultValue(featureTableJson.BOXES_LENGTH, 0);\n  const numberOfCylinders = defaultValue(featureTableJson.CYLINDERS_LENGTH, 0);\n  const numberOfEllipsoids = defaultValue(\n    featureTableJson.ELLIPSOIDS_LENGTH,\n    0\n  );\n  const numberOfSpheres = defaultValue(featureTableJson.SPHERES_LENGTH, 0);\n\n  const totalPrimitives =\n    numberOfBoxes + numberOfCylinders + numberOfEllipsoids + numberOfSpheres;\n\n  const batchTable = new Cesium3DTileBatchTable(\n    content,\n    totalPrimitives,\n    batchTableJson,\n    batchTableBinary,\n    createColorChangedCallback(content)\n  );\n  content._batchTable = batchTable;\n\n  if (totalPrimitives === 0) {\n    return;\n  }\n\n  const modelMatrix = content.tile.computedTransform;\n\n  let center;\n  if (defined(featureTableJson.RTC_CENTER)) {\n    center = Cartesian3.unpack(featureTableJson.RTC_CENTER);\n    Matrix4.multiplyByPoint(modelMatrix, center, center);\n  }\n\n  const batchIds = getBatchIds(featureTableJson, featureTableBinary);\n\n  if (\n    numberOfBoxes > 0 ||\n    numberOfCylinders > 0 ||\n    numberOfEllipsoids > 0 ||\n    numberOfSpheres > 0\n  ) {\n    let boxes;\n    let cylinders;\n    let ellipsoids;\n    let spheres;\n\n    if (numberOfBoxes > 0) {\n      const boxesByteOffset =\n        featureTableBinary.byteOffset + featureTableJson.BOXES.byteOffset;\n      boxes = new Float32Array(\n        featureTableBinary.buffer,\n        boxesByteOffset,\n        Vector3DTileGeometry.packedBoxLength * numberOfBoxes\n      );\n    }\n\n    if (numberOfCylinders > 0) {\n      const cylindersByteOffset =\n        featureTableBinary.byteOffset + featureTableJson.CYLINDERS.byteOffset;\n      cylinders = new Float32Array(\n        featureTableBinary.buffer,\n        cylindersByteOffset,\n        Vector3DTileGeometry.packedCylinderLength * numberOfCylinders\n      );\n    }\n\n    if (numberOfEllipsoids > 0) {\n      const ellipsoidsByteOffset =\n        featureTableBinary.byteOffset + featureTableJson.ELLIPSOIDS.byteOffset;\n      ellipsoids = new Float32Array(\n        featureTableBinary.buffer,\n        ellipsoidsByteOffset,\n        Vector3DTileGeometry.packedEllipsoidLength * numberOfEllipsoids\n      );\n    }\n\n    if (numberOfSpheres > 0) {\n      const spheresByteOffset =\n        featureTableBinary.byteOffset + featureTableJson.SPHERES.byteOffset;\n      spheres = new Float32Array(\n        featureTableBinary.buffer,\n        spheresByteOffset,\n        Vector3DTileGeometry.packedSphereLength * numberOfSpheres\n      );\n    }\n\n    content._geometries = new Vector3DTileGeometry({\n      boxes: boxes,\n      boxBatchIds: batchIds.boxes,\n      cylinders: cylinders,\n      cylinderBatchIds: batchIds.cylinders,\n      ellipsoids: ellipsoids,\n      ellipsoidBatchIds: batchIds.ellipsoids,\n      spheres: spheres,\n      sphereBatchIds: batchIds.spheres,\n      center: center,\n      modelMatrix: modelMatrix,\n      batchTable: batchTable,\n      boundingVolume: content.tile.boundingVolume.boundingVolume,\n    });\n\n    return content._geometries.readyPromise.then(function () {\n      return content;\n    });\n  }\n\n  return Promise.resolve(content);\n}\n\nfunction createFeatures(content) {\n  const featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    const features = new Array(featuresLength);\n    if (defined(content._geometries)) {\n      content._geometries.createFeatures(content, features);\n    }\n    content._features = features;\n  }\n}\n\nGeometry3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\n\nGeometry3DTileContent.prototype.getFeature = function (batchId) {\n  //>>includeStart('debug', pragmas.debug);\n  const featuresLength = this.featuresLength;\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${\n        featuresLength - 1\n      }).`\n    );\n  }\n  //>>includeEnd('debug');\n\n  createFeatures(this);\n  return this._features[batchId];\n};\n\nGeometry3DTileContent.prototype.applyDebugSettings = function (enabled, color) {\n  if (defined(this._geometries)) {\n    this._geometries.applyDebugSettings(enabled, color);\n  }\n};\n\nGeometry3DTileContent.prototype.applyStyle = function (style) {\n  createFeatures(this);\n  if (defined(this._geometries)) {\n    this._geometries.applyStyle(style, this._features);\n  }\n};\n\nGeometry3DTileContent.prototype.update = function (tileset, frameState) {\n  if (defined(this._geometries)) {\n    this._geometries.classificationType = this._tileset.classificationType;\n    this._geometries.debugWireframe = this._tileset.debugWireframe;\n    this._geometries.update(frameState);\n  }\n  if (defined(this._batchTable) && this._geometries._ready) {\n    this._batchTable.update(tileset, frameState);\n  }\n};\n\nGeometry3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nGeometry3DTileContent.prototype.destroy = function () {\n  this._geometries = this._geometries && this._geometries.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n  return destroyObject(this);\n};\nexport default Geometry3DTileContent;\n","import Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ImageryLayerFeatureInfo from \"./ImageryLayerFeatureInfo.js\";\n\n/**\n * Describes the format in which to request GetFeatureInfo from a Web Map Service (WMS) server.\n *\n * @alias GetFeatureInfoFormat\n * @constructor\n *\n * @param {String} type The type of response to expect from a GetFeatureInfo request.  Valid\n *        values are 'json', 'xml', 'html', or 'text'.\n * @param {String} [format] The info format to request from the WMS server.  This is usually a\n *        MIME type such as 'application/json' or text/xml'.  If this parameter is not specified, the provider will request 'json'\n *        using 'application/json', 'xml' using 'text/xml', 'html' using 'text/html', and 'text' using 'text/plain'.\n * @param {Function} [callback] A function to invoke with the GetFeatureInfo response from the WMS server\n *        in order to produce an array of picked {@link ImageryLayerFeatureInfo} instances.  If this parameter is not specified,\n *        a default function for the type of response is used.\n */\nfunction GetFeatureInfoFormat(type, format, callback) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(type)) {\n    throw new DeveloperError(\"type is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this.type = type;\n\n  if (!defined(format)) {\n    if (type === \"json\") {\n      format = \"application/json\";\n    } else if (type === \"xml\") {\n      format = \"text/xml\";\n    } else if (type === \"html\") {\n      format = \"text/html\";\n    } else if (type === \"text\") {\n      format = \"text/plain\";\n    }\n    //>>includeStart('debug', pragmas.debug);\n    else {\n      throw new DeveloperError(\n        'format is required when type is not \"json\", \"xml\", \"html\", or \"text\".'\n      );\n    }\n    //>>includeEnd('debug');\n  }\n\n  this.format = format;\n\n  if (!defined(callback)) {\n    if (type === \"json\") {\n      callback = geoJsonToFeatureInfo;\n    } else if (type === \"xml\") {\n      callback = xmlToFeatureInfo;\n    } else if (type === \"html\") {\n      callback = textToFeatureInfo;\n    } else if (type === \"text\") {\n      callback = textToFeatureInfo;\n    }\n    //>>includeStart('debug', pragmas.debug);\n    else {\n      throw new DeveloperError(\n        'callback is required when type is not \"json\", \"xml\", \"html\", or \"text\".'\n      );\n    }\n    //>>includeEnd('debug');\n  }\n\n  this.callback = callback;\n}\n\nfunction geoJsonToFeatureInfo(json) {\n  const result = [];\n\n  const features = json.features;\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n\n    const featureInfo = new ImageryLayerFeatureInfo();\n    featureInfo.data = feature;\n    featureInfo.properties = feature.properties;\n    featureInfo.configureNameFromProperties(feature.properties);\n    featureInfo.configureDescriptionFromProperties(feature.properties);\n\n    // If this is a point feature, use the coordinates of the point.\n    if (defined(feature.geometry) && feature.geometry.type === \"Point\") {\n      const longitude = feature.geometry.coordinates[0];\n      const latitude = feature.geometry.coordinates[1];\n      featureInfo.position = Cartographic.fromDegrees(longitude, latitude);\n    }\n\n    result.push(featureInfo);\n  }\n\n  return result;\n}\n\nconst mapInfoMxpNamespace = \"http://www.mapinfo.com/mxp\";\nconst esriWmsNamespace = \"http://www.esri.com/wms\";\nconst wfsNamespace = \"http://www.opengis.net/wfs\";\nconst gmlNamespace = \"http://www.opengis.net/gml\";\n\nfunction xmlToFeatureInfo(xml) {\n  const documentElement = xml.documentElement;\n  if (\n    documentElement.localName === \"MultiFeatureCollection\" &&\n    documentElement.namespaceURI === mapInfoMxpNamespace\n  ) {\n    // This looks like a MapInfo MXP response\n    return mapInfoXmlToFeatureInfo(xml);\n  } else if (\n    documentElement.localName === \"FeatureInfoResponse\" &&\n    documentElement.namespaceURI === esriWmsNamespace\n  ) {\n    // This looks like an Esri WMS response\n    return esriXmlToFeatureInfo(xml);\n  } else if (\n    documentElement.localName === \"FeatureCollection\" &&\n    documentElement.namespaceURI === wfsNamespace\n  ) {\n    // This looks like a WFS/GML response.\n    return gmlToFeatureInfo(xml);\n  } else if (documentElement.localName === \"ServiceExceptionReport\") {\n    // This looks like a WMS server error, so no features picked.\n    throw new RuntimeError(\n      new XMLSerializer().serializeToString(documentElement)\n    );\n  } else if (documentElement.localName === \"msGMLOutput\") {\n    return msGmlToFeatureInfo(xml);\n  } else {\n    // Unknown response type, so just dump the XML itself into the description.\n    return unknownXmlToFeatureInfo(xml);\n  }\n}\n\nfunction mapInfoXmlToFeatureInfo(xml) {\n  const result = [];\n\n  const multiFeatureCollection = xml.documentElement;\n\n  const features = multiFeatureCollection.getElementsByTagNameNS(\n    mapInfoMxpNamespace,\n    \"Feature\"\n  );\n  for (let featureIndex = 0; featureIndex < features.length; ++featureIndex) {\n    const feature = features[featureIndex];\n\n    const properties = {};\n\n    const propertyElements = feature.getElementsByTagNameNS(\n      mapInfoMxpNamespace,\n      \"Val\"\n    );\n    for (\n      let propertyIndex = 0;\n      propertyIndex < propertyElements.length;\n      ++propertyIndex\n    ) {\n      const propertyElement = propertyElements[propertyIndex];\n      if (propertyElement.hasAttribute(\"ref\")) {\n        const name = propertyElement.getAttribute(\"ref\");\n        const value = propertyElement.textContent.trim();\n        properties[name] = value;\n      }\n    }\n\n    const featureInfo = new ImageryLayerFeatureInfo();\n    featureInfo.data = feature;\n    featureInfo.properties = properties;\n    featureInfo.configureNameFromProperties(properties);\n    featureInfo.configureDescriptionFromProperties(properties);\n    result.push(featureInfo);\n  }\n\n  return result;\n}\n\nfunction esriXmlToFeatureInfo(xml) {\n  const featureInfoResponse = xml.documentElement;\n  const result = [];\n  let properties;\n\n  const features = featureInfoResponse.getElementsByTagNameNS(\"*\", \"FIELDS\");\n  if (features.length > 0) {\n    // Standard esri format\n    for (let featureIndex = 0; featureIndex < features.length; ++featureIndex) {\n      const feature = features[featureIndex];\n\n      properties = {};\n\n      const propertyAttributes = feature.attributes;\n      for (\n        let attributeIndex = 0;\n        attributeIndex < propertyAttributes.length;\n        ++attributeIndex\n      ) {\n        const attribute = propertyAttributes[attributeIndex];\n        properties[attribute.name] = attribute.value;\n      }\n\n      result.push(\n        imageryLayerFeatureInfoFromDataAndProperties(feature, properties)\n      );\n    }\n  } else {\n    // Thredds format -- looks like esri, but instead of containing FIELDS, contains FeatureInfo element\n    const featureInfoElements = featureInfoResponse.getElementsByTagNameNS(\n      \"*\",\n      \"FeatureInfo\"\n    );\n    for (\n      let featureInfoElementIndex = 0;\n      featureInfoElementIndex < featureInfoElements.length;\n      ++featureInfoElementIndex\n    ) {\n      const featureInfoElement = featureInfoElements[featureInfoElementIndex];\n\n      properties = {};\n\n      // node.children is not supported in IE9-11, so use childNodes and check that child.nodeType is an element\n      const featureInfoChildren = featureInfoElement.childNodes;\n      for (\n        let childIndex = 0;\n        childIndex < featureInfoChildren.length;\n        ++childIndex\n      ) {\n        const child = featureInfoChildren[childIndex];\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          properties[child.localName] = child.textContent;\n        }\n      }\n\n      result.push(\n        imageryLayerFeatureInfoFromDataAndProperties(\n          featureInfoElement,\n          properties\n        )\n      );\n    }\n  }\n\n  return result;\n}\n\nfunction gmlToFeatureInfo(xml) {\n  const result = [];\n\n  const featureCollection = xml.documentElement;\n\n  const featureMembers = featureCollection.getElementsByTagNameNS(\n    gmlNamespace,\n    \"featureMember\"\n  );\n  for (\n    let featureIndex = 0;\n    featureIndex < featureMembers.length;\n    ++featureIndex\n  ) {\n    const featureMember = featureMembers[featureIndex];\n\n    const properties = {};\n    getGmlPropertiesRecursively(featureMember, properties);\n    result.push(\n      imageryLayerFeatureInfoFromDataAndProperties(featureMember, properties)\n    );\n  }\n\n  return result;\n}\n\n// msGmlToFeatureInfo is similar to gmlToFeatureInfo, but assumes different XML structure\n// eg. <msGMLOutput> <ABC_layer> <ABC_feature> <foo>bar</foo> ... </ABC_feature> </ABC_layer> </msGMLOutput>\n\nfunction msGmlToFeatureInfo(xml) {\n  const result = [];\n\n  // Find the first child. Except for IE, this would work:\n  // const layer = xml.documentElement.children[0];\n  let layer;\n  const children = xml.documentElement.childNodes;\n  for (let i = 0; i < children.length; i++) {\n    if (children[i].nodeType === Node.ELEMENT_NODE) {\n      layer = children[i];\n      break;\n    }\n  }\n  if (!defined(layer)) {\n    throw new RuntimeError(\n      \"Unable to find first child of the feature info xml document\"\n    );\n  }\n  const featureMembers = layer.childNodes;\n  for (\n    let featureIndex = 0;\n    featureIndex < featureMembers.length;\n    ++featureIndex\n  ) {\n    const featureMember = featureMembers[featureIndex];\n    if (featureMember.nodeType === Node.ELEMENT_NODE) {\n      const properties = {};\n      getGmlPropertiesRecursively(featureMember, properties);\n      result.push(\n        imageryLayerFeatureInfoFromDataAndProperties(featureMember, properties)\n      );\n    }\n  }\n\n  return result;\n}\n\nfunction getGmlPropertiesRecursively(gmlNode, properties) {\n  let isSingleValue = true;\n\n  for (let i = 0; i < gmlNode.childNodes.length; ++i) {\n    const child = gmlNode.childNodes[i];\n\n    if (child.nodeType === Node.ELEMENT_NODE) {\n      isSingleValue = false;\n    }\n\n    if (\n      child.localName === \"Point\" ||\n      child.localName === \"LineString\" ||\n      child.localName === \"Polygon\" ||\n      child.localName === \"boundedBy\"\n    ) {\n      continue;\n    }\n\n    if (\n      child.hasChildNodes() &&\n      getGmlPropertiesRecursively(child, properties)\n    ) {\n      properties[child.localName] = child.textContent;\n    }\n  }\n\n  return isSingleValue;\n}\n\nfunction imageryLayerFeatureInfoFromDataAndProperties(data, properties) {\n  const featureInfo = new ImageryLayerFeatureInfo();\n  featureInfo.data = data;\n  featureInfo.properties = properties;\n  featureInfo.configureNameFromProperties(properties);\n  featureInfo.configureDescriptionFromProperties(properties);\n  return featureInfo;\n}\n\nfunction unknownXmlToFeatureInfo(xml) {\n  const xmlText = new XMLSerializer().serializeToString(xml);\n\n  const element = document.createElement(\"div\");\n  const pre = document.createElement(\"pre\");\n  pre.textContent = xmlText;\n  element.appendChild(pre);\n\n  const featureInfo = new ImageryLayerFeatureInfo();\n  featureInfo.data = xml;\n  featureInfo.description = element.innerHTML;\n  return [featureInfo];\n}\n\nconst emptyBodyRegex = /<body>\\s*<\\/body>/im;\nconst wmsServiceExceptionReportRegex = /<ServiceExceptionReport([\\s\\S]*)<\\/ServiceExceptionReport>/im;\nconst titleRegex = /<title>([\\s\\S]*)<\\/title>/im;\n\nfunction textToFeatureInfo(text) {\n  // If the text is HTML and it has an empty body tag, assume it means no features were found.\n  if (emptyBodyRegex.test(text)) {\n    return undefined;\n  }\n\n  // If this is a WMS exception report, treat it as \"no features found\" rather than showing\n  // bogus feature info.\n  if (wmsServiceExceptionReportRegex.test(text)) {\n    return undefined;\n  }\n\n  // If the text has a <title> element, use it as the name.\n  let name;\n  const title = titleRegex.exec(text);\n  if (title && title.length > 1) {\n    name = title[1];\n  }\n\n  const featureInfo = new ImageryLayerFeatureInfo();\n  featureInfo.name = name;\n  featureInfo.description = text;\n  featureInfo.data = text;\n  return [featureInfo];\n}\nexport default GetFeatureInfoFormat;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidTerrainProvider from \"../Core/EllipsoidTerrainProvider.js\";\nimport Event from \"../Core/Event.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport GlobeFS from \"../Shaders/GlobeFS.js\";\nimport GlobeVS from \"../Shaders/GlobeVS.js\";\nimport AtmosphereCommon from \"../Shaders/AtmosphereCommon.js\";\nimport GroundAtmosphere from \"../Shaders/GroundAtmosphere.js\";\nimport GlobeSurfaceShaderSet from \"./GlobeSurfaceShaderSet.js\";\nimport GlobeSurfaceTileProvider from \"./GlobeSurfaceTileProvider.js\";\nimport GlobeTranslucency from \"./GlobeTranslucency.js\";\nimport ImageryLayerCollection from \"./ImageryLayerCollection.js\";\nimport QuadtreePrimitive from \"./QuadtreePrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})\n * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.\n *\n * @alias Globe\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] Determines the size and shape of the\n * globe.\n */\nfunction Globe(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  const terrainProvider = new EllipsoidTerrainProvider({\n    ellipsoid: ellipsoid,\n  });\n  const imageryLayerCollection = new ImageryLayerCollection();\n\n  this._ellipsoid = ellipsoid;\n  this._imageryLayerCollection = imageryLayerCollection;\n\n  this._surfaceShaderSet = new GlobeSurfaceShaderSet();\n  this._material = undefined;\n\n  this._surface = new QuadtreePrimitive({\n    tileProvider: new GlobeSurfaceTileProvider({\n      terrainProvider: terrainProvider,\n      imageryLayers: imageryLayerCollection,\n      surfaceShaderSet: this._surfaceShaderSet,\n    }),\n  });\n\n  this._terrainProvider = terrainProvider;\n  this._terrainProviderChanged = new Event();\n\n  this._undergroundColor = Color.clone(Color.BLACK);\n  this._undergroundColorAlphaByDistance = new NearFarScalar(\n    ellipsoid.maximumRadius / 1000.0,\n    0.0,\n    ellipsoid.maximumRadius / 5.0,\n    1.0\n  );\n\n  this._translucency = new GlobeTranslucency();\n\n  makeShadersDirty(this);\n\n  /**\n   * Determines if the globe will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = true;\n\n  this._oceanNormalMapResourceDirty = true;\n  this._oceanNormalMapResource = new Resource({\n    url: buildModuleUrl(\"Assets/Textures/waterNormalsSmall.jpg\"),\n  });\n\n  /**\n   * The maximum screen-space error used to drive level-of-detail refinement.  Higher\n   * values will provide better performance but lower visual quality.\n   *\n   * @type {Number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = 2;\n\n  /**\n   * The size of the terrain tile cache, expressed as a number of tiles.  Any additional\n   * tiles beyond this number will be freed, as long as they aren't needed for rendering\n   * this frame.  A larger number will consume more memory but will show detail faster\n   * when, for example, zooming out and then back in.\n   *\n   * @type {Number}\n   * @default 100\n   */\n  this.tileCacheSize = 100;\n\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {Number}\n   * @default 20\n   */\n  this.loadingDescendantLimit = 20;\n\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {Boolean}\n   * @default true\n   */\n  this.preloadAncestors = true;\n\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {Boolean}\n   * @default false\n   */\n  this.preloadSiblings = false;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  /**\n   * Enable lighting the globe with the scene's light source.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.enableLighting = false;\n\n  /**\n   * A multiplier to adjust terrain lambert lighting.\n   * This number is multiplied by the result of <code>czm_getLambertDiffuse</code> in GlobeFS.glsl.\n   * This only takes effect when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 0.9\n   */\n  this.lambertDiffuseMultiplier = 0.9;\n\n  /**\n   * Enable dynamic lighting effects on atmosphere and fog. This only takes effect\n   * when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.dynamicAtmosphereLighting = true;\n\n  /**\n   * Whether dynamic atmosphere lighting uses the sun direction instead of the scene's\n   * light direction. This only takes effect when <code>enableLighting</code> and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.dynamicAtmosphereLightingFromSun = false;\n\n  /**\n   * Enable the ground atmosphere, which is drawn over the globe when viewed from a distance between <code>lightingFadeInDistance</code> and <code>lightingFadeOutDistance</code>.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.showGroundAtmosphere = true;\n\n  /**\n   * The intensity of the light that is used for computing the ground atmosphere color.\n   *\n   * @type {Number}\n   * @default 10.0\n   */\n  this.atmosphereLightIntensity = 10.0;\n\n  /**\n   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(5.5e-6, 13.0e-6, 28.4e-6)\n   */\n  this.atmosphereRayleighCoefficient = new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6);\n\n  /**\n   * The Mie scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3(21e-6, 21e-6, 21e-6)\n   */\n  this.atmosphereMieCoefficient = new Cartesian3(21e-6, 21e-6, 21e-6);\n\n  /**\n   * The Rayleigh scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.\n   *\n   * @type {Number}\n   * @default 10000.0\n   */\n  this.atmosphereRayleighScaleHeight = 10000.0;\n\n  /**\n   * The Mie scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.\n   *\n   * @type {Number}\n   * @default 3200.0\n   */\n  this.atmosphereMieScaleHeight = 3200.0;\n\n  /**\n   * The anisotropy of the medium to consider for Mie scattering.\n   * <p>\n   * Valid values are between -1.0 and 1.0.\n   * </p>\n   * @type {Number}\n   * @default 0.9\n   */\n  this.atmosphereMieAnisotropy = 0.9;\n\n  /**\n   * The distance where everything becomes lit. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n  this.lightingFadeOutDistance = 1.0e7;\n\n  /**\n   * The distance where lighting resumes. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 20000000.0\n   */\n  this.lightingFadeInDistance = 2.0e7;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades out to a lit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n  this.nightFadeOutDistance = 1.0e7;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades in to an unlit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 50000000.0\n   */\n  this.nightFadeInDistance = 5.0e7;\n\n  /**\n   * True if an animated wave effect should be shown in areas of the globe\n   * covered by water; otherwise, false.  This property is ignored if the\n   * <code>terrainProvider</code> does not provide a water mask.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.showWaterEffect = true;\n\n  /**\n   * True if primitives such as billboards, polylines, labels, etc. should be depth-tested\n   * against the terrain surface, or false if such primitives should always be drawn on top\n   * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth\n   * testing primitives against terrain is that slight numerical noise or terrain level-of-detail\n   * switched can sometimes make a primitive that should be on the surface disappear underneath it.\n   *\n   * @type {Boolean}\n   * @default false\n   *\n   */\n  this.depthTestAgainstTerrain = false;\n\n  /**\n   * Determines whether the globe casts or receives shadows from light sources. Setting the globe\n   * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.\n   * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.RECEIVE_ONLY\n   */\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.atmosphereHueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.atmosphereSaturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.atmosphereBrightnessShift = 0.0;\n\n  /**\n   * A scalar used to exaggerate the terrain. Defaults to <code>1.0</code> (no exaggeration).\n   * A value of <code>2.0</code> scales the terrain by 2x.\n   * A value of <code>0.0</code> makes the terrain completely flat.\n   * Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.terrainExaggeration = 1.0;\n\n  /**\n   * The height from which terrain is exaggerated. Defaults to <code>0.0</code> (scaled relative to ellipsoid surface).\n   * Terrain that is above this height will scale upwards and terrain that is below this height will scale downwards.\n   * Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.\n   * If {@link Globe#terrainExaggeration} is <code>1.0</code> this value will have no effect.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.terrainExaggerationRelativeHeight = 0.0;\n\n  /**\n   * Whether to show terrain skirts. Terrain skirts are geometry extending downwards from a tile's edges used to hide seams between neighboring tiles.\n   * Skirts are always hidden when the camera is underground or translucency is enabled.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.showSkirts = true;\n\n  /**\n   * Whether to cull back-facing terrain. Back faces are not culled when the camera is underground or translucency is enabled.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.backFaceCulling = true;\n\n  this._oceanNormalMap = undefined;\n  this._zoomedOutOceanSpecularIntensity = undefined;\n}\n\nObject.defineProperties(Globe.prototype, {\n  /**\n   * Gets an ellipsoid describing the shape of this globe.\n   * @memberof Globe.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets the collection of image layers that will be rendered on this globe.\n   * @memberof Globe.prototype\n   * @type {ImageryLayerCollection}\n   */\n  imageryLayers: {\n    get: function () {\n      return this._imageryLayerCollection;\n    },\n  },\n  /**\n   * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._surface.tileProvider.imageryLayersUpdatedEvent;\n    },\n  },\n  /**\n   * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.\n   * @memberof Globe.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  tilesLoaded: {\n    get: function () {\n      if (!defined(this._surface)) {\n        return true;\n      }\n      return (\n        this._surface.tileProvider.ready &&\n        this._surface._tileLoadQueueHigh.length === 0 &&\n        this._surface._tileLoadQueueMedium.length === 0 &&\n        this._surface._tileLoadQueueLow.length === 0\n      );\n    },\n  },\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof Globe.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._surface.tileProvider.baseColor;\n    },\n    set: function (value) {\n      this._surface.tileProvider.baseColor = value;\n    },\n  },\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   *\n   * @memberof Globe.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._surface.tileProvider.clippingPlanes;\n    },\n    set: function (value) {\n      this._surface.tileProvider.clippingPlanes = value;\n    },\n  },\n  /**\n   * A property specifying a {@link Rectangle} used to limit globe rendering to a cartographic area.\n   * Defaults to the maximum extent of cartographic coordinates.\n   *\n   * @memberof Globe.prototype\n   * @type {Rectangle}\n   * @default {@link Rectangle.MAX_VALUE}\n   */\n  cartographicLimitRectangle: {\n    get: function () {\n      return this._surface.tileProvider.cartographicLimitRectangle;\n    },\n    set: function (value) {\n      if (!defined(value)) {\n        value = Rectangle.clone(Rectangle.MAX_VALUE);\n      }\n      this._surface.tileProvider.cartographicLimitRectangle = value;\n    },\n  },\n  /**\n   * The normal map to use for rendering waves in the ocean.  Setting this property will\n   * only have an effect if the configured terrain provider includes a water mask.\n   * @memberof Globe.prototype\n   * @type {String}\n   * @default buildModuleUrl('Assets/Textures/waterNormalsSmall.jpg')\n   */\n  oceanNormalMapUrl: {\n    get: function () {\n      return this._oceanNormalMapResource.url;\n    },\n    set: function (value) {\n      this._oceanNormalMapResource.url = value;\n      this._oceanNormalMapResourceDirty = true;\n    },\n  },\n  /**\n   * The terrain provider providing surface geometry for this globe.\n   * @type {TerrainProvider}\n   *\n   * @memberof Globe.prototype\n   * @type {TerrainProvider}\n   *\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (value) {\n      if (value !== this._terrainProvider) {\n        this._terrainProvider = value;\n        this._terrainProviderChanged.raiseEvent(value);\n        if (defined(this._material)) {\n          makeShadersDirty(this);\n        }\n      }\n    },\n  },\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function () {\n      return this._terrainProviderChanged;\n    },\n  },\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._surface.tileLoadProgressEvent;\n    },\n  },\n\n  /**\n   * Gets or sets the material appearance of the Globe.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * @memberof Globe.prototype\n   * @type {Material | undefined}\n   */\n  material: {\n    get: function () {\n      return this._material;\n    },\n    set: function (material) {\n      if (this._material !== material) {\n        this._material = material;\n        makeShadersDirty(this);\n      }\n    },\n  },\n\n  /**\n   * The color to render the back side of the globe when the camera is underground or the globe is translucent,\n   * blended with the globe color based on the camera's distance.\n   * <br /><br />\n   * To disable underground coloring, set <code>undergroundColor</code> to <code>undefined</code>.\n   *\n   * @memberof Globe.prototype\n   * @type {Color}\n   * @default {@link Color.BLACK}\n   *\n   * @see Globe#undergroundColorAlphaByDistance\n   */\n  undergroundColor: {\n    get: function () {\n      return this._undergroundColor;\n    },\n    set: function (value) {\n      this._undergroundColor = Color.clone(value, this._undergroundColor);\n    },\n  },\n\n  /**\n   * Gets or sets the near and far distance for blending {@link Globe#undergroundColor} with the globe color.\n   * The alpha will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the alpha remains clamped to the nearest bound. If undefined,\n   * the underground color will not be blended with the globe color.\n   * <br /> <br />\n   * When the camera is above the ellipsoid the distance is computed from the nearest\n   * point on the ellipsoid instead of the camera's position.\n   *\n   * @memberof Globe.prototype\n   * @type {NearFarScalar}\n   *\n   * @see Globe#undergroundColor\n   *\n   */\n  undergroundColorAlphaByDistance: {\n    get: function () {\n      return this._undergroundColorAlphaByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far < value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n      this._undergroundColorAlphaByDistance = NearFarScalar.clone(\n        value,\n        this._undergroundColorAlphaByDistance\n      );\n    },\n  },\n\n  /**\n   * Properties for controlling globe translucency.\n   *\n   * @memberof Globe.prototype\n   * @type {GlobeTranslucency}\n   */\n  translucency: {\n    get: function () {\n      return this._translucency;\n    },\n  },\n});\n\nfunction makeShadersDirty(globe) {\n  const defines = [];\n\n  const requireNormals =\n    defined(globe._material) &&\n    (globe._material.shaderSource.match(/slope/) ||\n      globe._material.shaderSource.match(\"normalEC\"));\n\n  const fragmentSources = [AtmosphereCommon, GroundAtmosphere];\n  if (\n    defined(globe._material) &&\n    (!requireNormals || globe._terrainProvider.requestVertexNormals)\n  ) {\n    fragmentSources.push(globe._material.shaderSource);\n    defines.push(\"APPLY_MATERIAL\");\n    globe._surface._tileProvider.materialUniformMap = globe._material._uniforms;\n  } else {\n    globe._surface._tileProvider.materialUniformMap = undefined;\n  }\n  fragmentSources.push(GlobeFS);\n\n  globe._surfaceShaderSet.baseVertexShaderSource = new ShaderSource({\n    sources: [AtmosphereCommon, GroundAtmosphere, GlobeVS],\n    defines: defines,\n  });\n\n  globe._surfaceShaderSet.baseFragmentShaderSource = new ShaderSource({\n    sources: fragmentSources,\n    defines: defines,\n  });\n  globe._surfaceShaderSet.material = globe._material;\n}\n\nfunction createComparePickTileFunction(rayOrigin) {\n  return function (a, b) {\n    const aDist = BoundingSphere.distanceSquaredTo(\n      a.pickBoundingSphere,\n      rayOrigin\n    );\n    const bDist = BoundingSphere.distanceSquaredTo(\n      b.pickBoundingSphere,\n      rayOrigin\n    );\n\n    return aDist - bDist;\n  };\n}\n\nconst scratchArray = [];\nconst scratchSphereIntersectionResult = {\n  start: 0.0,\n  stop: 0.0,\n};\n\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Boolean} [cullBackFaces=true] Set to true to not pick back faces.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.  The returned position is in projected coordinates for 2D and Columbus View.\n *\n * @private\n */\nGlobe.prototype.pickWorldCoordinates = function (\n  ray,\n  scene,\n  cullBackFaces,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required\");\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = defaultValue(cullBackFaces, true);\n\n  const mode = scene.mode;\n  const projection = scene.mapProjection;\n\n  const sphereIntersections = scratchArray;\n  sphereIntersections.length = 0;\n\n  const tilesToRender = this._surface._tilesToRender;\n  let length = tilesToRender.length;\n\n  let tile;\n  let i;\n\n  for (i = 0; i < length; ++i) {\n    tile = tilesToRender[i];\n    const surfaceTile = tile.data;\n\n    if (!defined(surfaceTile)) {\n      continue;\n    }\n\n    let boundingVolume = surfaceTile.pickBoundingSphere;\n    if (mode !== SceneMode.SCENE3D) {\n      surfaceTile.pickBoundingSphere = boundingVolume = BoundingSphere.fromRectangleWithHeights2D(\n        tile.rectangle,\n        projection,\n        surfaceTile.tileBoundingRegion.minimumHeight,\n        surfaceTile.tileBoundingRegion.maximumHeight,\n        boundingVolume\n      );\n      Cartesian3.fromElements(\n        boundingVolume.center.z,\n        boundingVolume.center.x,\n        boundingVolume.center.y,\n        boundingVolume.center\n      );\n    } else if (defined(surfaceTile.renderedMesh)) {\n      BoundingSphere.clone(\n        surfaceTile.tileBoundingRegion.boundingSphere,\n        boundingVolume\n      );\n    } else {\n      // So wait how did we render this thing then? It shouldn't be possible to get here.\n      continue;\n    }\n\n    const boundingSphereIntersection = IntersectionTests.raySphere(\n      ray,\n      boundingVolume,\n      scratchSphereIntersectionResult\n    );\n    if (defined(boundingSphereIntersection)) {\n      sphereIntersections.push(surfaceTile);\n    }\n  }\n\n  sphereIntersections.sort(createComparePickTileFunction(ray.origin));\n\n  let intersection;\n  length = sphereIntersections.length;\n  for (i = 0; i < length; ++i) {\n    intersection = sphereIntersections[i].pick(\n      ray,\n      scene.mode,\n      scene.mapProjection,\n      cullBackFaces,\n      result\n    );\n    if (defined(intersection)) {\n      break;\n    }\n  }\n\n  return intersection;\n};\n\nconst cartoScratch = new Cartographic();\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @example\n * // find intersection of ray through a pixel and the globe\n * const ray = viewer.camera.getPickRay(windowCoordinates);\n * const intersection = globe.pick(ray, scene);\n */\nGlobe.prototype.pick = function (ray, scene, result) {\n  result = this.pickWorldCoordinates(ray, scene, true, result);\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    result = Cartesian3.fromElements(result.y, result.z, result.x, result);\n    const carto = scene.mapProjection.unproject(result, cartoScratch);\n    result = scene.globe.ellipsoid.cartographicToCartesian(carto, result);\n  }\n\n  return result;\n};\n\nconst scratchGetHeightCartesian = new Cartesian3();\nconst scratchGetHeightIntersection = new Cartesian3();\nconst scratchGetHeightCartographic = new Cartographic();\nconst scratchGetHeightRay = new Ray();\n\nfunction tileIfContainsCartographic(tile, cartographic) {\n  return defined(tile) && Rectangle.contains(tile.rectangle, cartographic)\n    ? tile\n    : undefined;\n}\n\n/**\n * Get the height of the surface at a given cartographic.\n *\n * @param {Cartographic} cartographic The cartographic for which to find the height.\n * @returns {Number|undefined} The height of the cartographic or undefined if it could not be found.\n */\nGlobe.prototype.getHeight = function (cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartographic)) {\n    throw new DeveloperError(\"cartographic is required\");\n  }\n  //>>includeEnd('debug');\n\n  const levelZeroTiles = this._surface._levelZeroTiles;\n  if (!defined(levelZeroTiles)) {\n    return;\n  }\n\n  let tile;\n  let i;\n\n  const length = levelZeroTiles.length;\n  for (i = 0; i < length; ++i) {\n    tile = levelZeroTiles[i];\n    if (Rectangle.contains(tile.rectangle, cartographic)) {\n      break;\n    }\n  }\n\n  if (i >= length) {\n    return undefined;\n  }\n\n  let tileWithMesh = tile;\n\n  while (defined(tile)) {\n    tile =\n      tileIfContainsCartographic(tile._southwestChild, cartographic) ||\n      tileIfContainsCartographic(tile._southeastChild, cartographic) ||\n      tileIfContainsCartographic(tile._northwestChild, cartographic) ||\n      tile._northeastChild;\n\n    if (\n      defined(tile) &&\n      defined(tile.data) &&\n      defined(tile.data.renderedMesh)\n    ) {\n      tileWithMesh = tile;\n    }\n  }\n\n  tile = tileWithMesh;\n\n  // This tile was either rendered or culled.\n  // It is sometimes useful to get a height from a culled tile,\n  // e.g. when we're getting a height in order to place a billboard\n  // on terrain, and the camera is looking at that same billboard.\n  // The culled tile must have a valid mesh, though.\n  if (\n    !defined(tile) ||\n    !defined(tile.data) ||\n    !defined(tile.data.renderedMesh)\n  ) {\n    // Tile was not rendered (culled).\n    return undefined;\n  }\n\n  const projection = this._surface._tileProvider.tilingScheme.projection;\n  const ellipsoid = this._surface._tileProvider.tilingScheme.ellipsoid;\n\n  //cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n  const cartesian = Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    0.0,\n    ellipsoid,\n    scratchGetHeightCartesian\n  );\n\n  const ray = scratchGetHeightRay;\n  const surfaceNormal = ellipsoid.geodeticSurfaceNormal(\n    cartesian,\n    ray.direction\n  );\n\n  // Try to find the intersection point between the surface normal and z-axis.\n  // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n  const rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(\n    cartesian,\n    11500.0,\n    ray.origin\n  );\n\n  // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n  if (!defined(rayOrigin)) {\n    // intersection point is outside the ellipsoid, try other value\n    // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n    let minimumHeight;\n    if (defined(tile.data.tileBoundingRegion)) {\n      minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n    }\n    const magnitude = Math.min(defaultValue(minimumHeight, 0.0), -11500.0);\n\n    // multiply by the *positive* value of the magnitude\n    const vectorToMinimumPoint = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Math.abs(magnitude) + 1,\n      scratchGetHeightIntersection\n    );\n    Cartesian3.subtract(cartesian, vectorToMinimumPoint, ray.origin);\n  }\n\n  const intersection = tile.data.pick(\n    ray,\n    undefined,\n    projection,\n    false,\n    scratchGetHeightIntersection\n  );\n  if (!defined(intersection)) {\n    return undefined;\n  }\n\n  return ellipsoid.cartesianToCartographic(\n    intersection,\n    scratchGetHeightCartographic\n  ).height;\n};\n\n/**\n * @private\n */\nGlobe.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.update(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.beginFrame = function (frameState) {\n  const surface = this._surface;\n  const tileProvider = surface.tileProvider;\n  const terrainProvider = this.terrainProvider;\n  const hasWaterMask =\n    this.showWaterEffect &&\n    terrainProvider.ready &&\n    terrainProvider.hasWaterMask;\n\n  if (hasWaterMask && this._oceanNormalMapResourceDirty) {\n    // url changed, load new normal map asynchronously\n    this._oceanNormalMapResourceDirty = false;\n    const oceanNormalMapResource = this._oceanNormalMapResource;\n    const oceanNormalMapUrl = oceanNormalMapResource.url;\n    if (defined(oceanNormalMapUrl)) {\n      const that = this;\n      oceanNormalMapResource.fetchImage().then(function (image) {\n        if (oceanNormalMapUrl !== that._oceanNormalMapResource.url) {\n          // url changed while we were loading\n          return;\n        }\n\n        that._oceanNormalMap =\n          that._oceanNormalMap && that._oceanNormalMap.destroy();\n        that._oceanNormalMap = new Texture({\n          context: frameState.context,\n          source: image,\n        });\n      });\n    } else {\n      this._oceanNormalMap =\n        this._oceanNormalMap && this._oceanNormalMap.destroy();\n    }\n  }\n\n  const pass = frameState.passes;\n  const mode = frameState.mode;\n\n  if (pass.render) {\n    if (this.showGroundAtmosphere) {\n      this._zoomedOutOceanSpecularIntensity = 0.4;\n    } else {\n      this._zoomedOutOceanSpecularIntensity = 0.5;\n    }\n\n    surface.maximumScreenSpaceError = this.maximumScreenSpaceError;\n    surface.tileCacheSize = this.tileCacheSize;\n    surface.loadingDescendantLimit = this.loadingDescendantLimit;\n    surface.preloadAncestors = this.preloadAncestors;\n    surface.preloadSiblings = this.preloadSiblings;\n\n    tileProvider.terrainProvider = this.terrainProvider;\n    tileProvider.lightingFadeOutDistance = this.lightingFadeOutDistance;\n    tileProvider.lightingFadeInDistance = this.lightingFadeInDistance;\n    tileProvider.nightFadeOutDistance = this.nightFadeOutDistance;\n    tileProvider.nightFadeInDistance = this.nightFadeInDistance;\n    tileProvider.zoomedOutOceanSpecularIntensity =\n      mode === SceneMode.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0.0;\n    tileProvider.hasWaterMask = hasWaterMask;\n    tileProvider.oceanNormalMap = this._oceanNormalMap;\n    tileProvider.enableLighting = this.enableLighting;\n    tileProvider.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting;\n    tileProvider.dynamicAtmosphereLightingFromSun = this.dynamicAtmosphereLightingFromSun;\n    tileProvider.showGroundAtmosphere = this.showGroundAtmosphere;\n    tileProvider.atmosphereLightIntensity = this.atmosphereLightIntensity;\n    tileProvider.atmosphereRayleighCoefficient = this.atmosphereRayleighCoefficient;\n    tileProvider.atmosphereMieCoefficient = this.atmosphereMieCoefficient;\n    tileProvider.atmosphereRayleighScaleHeight = this.atmosphereRayleighScaleHeight;\n    tileProvider.atmosphereMieScaleHeight = this.atmosphereMieScaleHeight;\n    tileProvider.atmosphereMieAnisotropy = this.atmosphereMieAnisotropy;\n    tileProvider.shadows = this.shadows;\n    tileProvider.hueShift = this.atmosphereHueShift;\n    tileProvider.saturationShift = this.atmosphereSaturationShift;\n    tileProvider.brightnessShift = this.atmosphereBrightnessShift;\n    tileProvider.fillHighlightColor = this.fillHighlightColor;\n    tileProvider.showSkirts = this.showSkirts;\n    tileProvider.backFaceCulling = this.backFaceCulling;\n    tileProvider.undergroundColor = this._undergroundColor;\n    tileProvider.undergroundColorAlphaByDistance = this._undergroundColorAlphaByDistance;\n    tileProvider.lambertDiffuseMultiplier = this.lambertDiffuseMultiplier;\n    surface.beginFrame(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.render = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(frameState.context);\n  }\n\n  this._surface.render(frameState);\n};\n\n/**\n * @private\n */\nGlobe.prototype.endFrame = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.endFrame(frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see Globe#destroy\n */\nGlobe.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * globe = globe && globe.destroy();\n *\n * @see Globe#isDestroyed\n */\nGlobe.prototype.destroy = function () {\n  this._surfaceShaderSet =\n    this._surfaceShaderSet && this._surfaceShaderSet.destroy();\n  this._surface = this._surface && this._surface.destroy();\n  this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n  return destroyObject(this);\n};\nexport default Globe;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport PassThrough from \"../Shaders/PostProcessStages/PassThrough.js\";\nimport PassThroughDepth from \"../Shaders/PostProcessStages/PassThroughDepth.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * @private\n */\nfunction GlobeDepth() {\n  this._picking = false;\n  this._numSamples = 1;\n  this._tempCopyDepthTexture = undefined;\n\n  this._pickColorFramebuffer = new FramebufferManager({\n    depthStencil: true,\n    supportsDepthTexture: true,\n  });\n  this._outputFramebuffer = new FramebufferManager({\n    depthStencil: true,\n    supportsDepthTexture: true,\n  });\n  this._copyDepthFramebuffer = new FramebufferManager();\n  this._tempCopyDepthFramebuffer = new FramebufferManager();\n  this._updateDepthFramebuffer = new FramebufferManager({\n    createColorAttachments: false,\n    createDepthAttachments: false,\n    depthStencil: true,\n  });\n\n  this._clearGlobeColorCommand = undefined;\n  this._copyColorCommand = undefined;\n  this._copyDepthCommand = undefined;\n  this._tempCopyDepthCommand = undefined;\n  this._updateDepthCommand = undefined;\n\n  this._viewport = new BoundingRectangle();\n  this._rs = undefined;\n  this._rsBlend = undefined;\n  this._rsUpdate = undefined;\n\n  this._useScissorTest = false;\n  this._scissorRectangle = undefined;\n\n  this._useHdr = undefined;\n  this._clearGlobeDepth = undefined;\n}\n\nObject.defineProperties(GlobeDepth.prototype, {\n  colorFramebufferManager: {\n    get: function () {\n      return this._picking\n        ? this._pickColorFramebuffer\n        : this._outputFramebuffer;\n    },\n  },\n  framebuffer: {\n    get: function () {\n      return this.colorFramebufferManager.framebuffer;\n    },\n  },\n  depthStencilTexture: {\n    get: function () {\n      return this.colorFramebufferManager.getDepthStencilTexture();\n    },\n  },\n  picking: {\n    get: function () {\n      return this._picking;\n    },\n    set: function (value) {\n      this._picking = value;\n    },\n  },\n});\n\nfunction destroyFramebuffers(globeDepth) {\n  globeDepth._pickColorFramebuffer.destroy();\n  globeDepth._outputFramebuffer.destroy();\n  globeDepth._copyDepthFramebuffer.destroy();\n  globeDepth._tempCopyDepthFramebuffer.destroy();\n  globeDepth._updateDepthFramebuffer.destroy();\n}\n\nfunction updateCopyCommands(globeDepth, context, width, height, passState) {\n  globeDepth._viewport.width = width;\n  globeDepth._viewport.height = height;\n\n  const useScissorTest = !BoundingRectangle.equals(\n    globeDepth._viewport,\n    passState.viewport\n  );\n  let updateScissor = useScissorTest !== globeDepth._useScissorTest;\n  globeDepth._useScissorTest = useScissorTest;\n\n  if (\n    !BoundingRectangle.equals(globeDepth._scissorRectangle, passState.viewport)\n  ) {\n    globeDepth._scissorRectangle = BoundingRectangle.clone(\n      passState.viewport,\n      globeDepth._scissorRectangle\n    );\n    updateScissor = true;\n  }\n\n  if (\n    !defined(globeDepth._rs) ||\n    !BoundingRectangle.equals(globeDepth._viewport, globeDepth._rs.viewport) ||\n    updateScissor\n  ) {\n    globeDepth._rs = RenderState.fromCache({\n      viewport: globeDepth._viewport,\n      scissorTest: {\n        enabled: globeDepth._useScissorTest,\n        rectangle: globeDepth._scissorRectangle,\n      },\n    });\n    globeDepth._rsBlend = RenderState.fromCache({\n      viewport: globeDepth._viewport,\n      scissorTest: {\n        enabled: globeDepth._useScissorTest,\n        rectangle: globeDepth._scissorRectangle,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n    });\n\n    // Copy packed depth only if the 3D Tiles bit is set\n    globeDepth._rsUpdate = RenderState.fromCache({\n      viewport: globeDepth._viewport,\n      scissorTest: {\n        enabled: globeDepth._useScissorTest,\n        rectangle: globeDepth._scissorRectangle,\n      },\n      stencilTest: {\n        enabled: true,\n        frontFunction: StencilFunction.EQUAL,\n        frontOperation: {\n          fail: StencilOperation.KEEP,\n          zFail: StencilOperation.KEEP,\n          zPass: StencilOperation.KEEP,\n        },\n        backFunction: StencilFunction.NEVER,\n        reference: StencilConstants.CESIUM_3D_TILE_MASK,\n        mask: StencilConstants.CESIUM_3D_TILE_MASK,\n      },\n    });\n  }\n\n  if (!defined(globeDepth._copyDepthCommand)) {\n    globeDepth._copyDepthCommand = context.createViewportQuadCommand(\n      PassThroughDepth,\n      {\n        uniformMap: {\n          u_depthTexture: function () {\n            return globeDepth.colorFramebufferManager.getDepthStencilTexture();\n          },\n        },\n        owner: globeDepth,\n      }\n    );\n  }\n\n  globeDepth._copyDepthCommand.framebuffer =\n    globeDepth._copyDepthFramebuffer.framebuffer;\n  globeDepth._copyDepthCommand.renderState = globeDepth._rs;\n\n  if (!defined(globeDepth._copyColorCommand)) {\n    globeDepth._copyColorCommand = context.createViewportQuadCommand(\n      PassThrough,\n      {\n        uniformMap: {\n          colorTexture: function () {\n            return globeDepth.colorFramebufferManager.getColorTexture();\n          },\n        },\n        owner: globeDepth,\n      }\n    );\n  }\n\n  globeDepth._copyColorCommand.renderState = globeDepth._rs;\n\n  if (!defined(globeDepth._tempCopyDepthCommand)) {\n    globeDepth._tempCopyDepthCommand = context.createViewportQuadCommand(\n      PassThroughDepth,\n      {\n        uniformMap: {\n          u_depthTexture: function () {\n            return globeDepth._tempCopyDepthTexture;\n          },\n        },\n        owner: globeDepth,\n      }\n    );\n  }\n\n  globeDepth._tempCopyDepthCommand.framebuffer =\n    globeDepth._tempCopyDepthFramebuffer.framebuffer;\n  globeDepth._tempCopyDepthCommand.renderState = globeDepth._rs;\n\n  if (!defined(globeDepth._updateDepthCommand)) {\n    globeDepth._updateDepthCommand = context.createViewportQuadCommand(\n      PassThrough,\n      {\n        uniformMap: {\n          colorTexture: function () {\n            return globeDepth._tempCopyDepthFramebuffer.getColorTexture();\n          },\n        },\n        owner: globeDepth,\n      }\n    );\n  }\n\n  globeDepth._updateDepthCommand.framebuffer =\n    globeDepth._updateDepthFramebuffer.framebuffer;\n  globeDepth._updateDepthCommand.renderState = globeDepth._rsUpdate;\n\n  if (!defined(globeDepth._clearGlobeColorCommand)) {\n    globeDepth._clearGlobeColorCommand = new ClearCommand({\n      color: new Color(0.0, 0.0, 0.0, 0.0),\n      stencil: 0.0,\n      owner: globeDepth,\n    });\n  }\n\n  globeDepth._clearGlobeColorCommand.framebuffer = globeDepth.framebuffer;\n}\n\nGlobeDepth.prototype.update = function (\n  context,\n  passState,\n  viewport,\n  numSamples,\n  hdr,\n  clearGlobeDepth\n) {\n  const width = viewport.width;\n  const height = viewport.height;\n\n  const pixelDatatype = hdr\n    ? context.halfFloatingPointTexture\n      ? PixelDatatype.HALF_FLOAT\n      : PixelDatatype.FLOAT\n    : PixelDatatype.UNSIGNED_BYTE;\n  this._numSamples = numSamples;\n  if (this.picking) {\n    this._pickColorFramebuffer.update(context, width, height);\n  } else {\n    this._outputFramebuffer.update(\n      context,\n      width,\n      height,\n      numSamples,\n      pixelDatatype\n    );\n  }\n  this._copyDepthFramebuffer.update(context, width, height);\n  updateCopyCommands(this, context, width, height, passState);\n  context.uniformState.globeDepthTexture = undefined;\n\n  this._useHdr = hdr;\n  this._clearGlobeDepth = clearGlobeDepth;\n};\n\nGlobeDepth.prototype.prepareColorTextures = function (context, blitStencil) {\n  if (!this.picking && this._numSamples > 1) {\n    this._outputFramebuffer.prepareTextures(context, blitStencil);\n  }\n};\n\nGlobeDepth.prototype.executeCopyDepth = function (context, passState) {\n  if (defined(this._copyDepthCommand)) {\n    this.prepareColorTextures(context);\n    this._copyDepthCommand.execute(context, passState);\n    context.uniformState.globeDepthTexture = this._copyDepthFramebuffer.getColorTexture();\n  }\n};\n\nGlobeDepth.prototype.executeUpdateDepth = function (\n  context,\n  passState,\n  clearGlobeDepth,\n  depthTexture\n) {\n  const depthTextureToCopy = defined(depthTexture)\n    ? depthTexture\n    : passState.framebuffer.depthStencilTexture;\n  if (\n    clearGlobeDepth ||\n    depthTextureToCopy !== this.colorFramebufferManager.getDepthStencilTexture()\n  ) {\n    // First copy the depth to a temporary globe depth texture, then update the\n    // main globe depth texture where the stencil bit for 3D Tiles is set.\n    // This preserves the original globe depth except where 3D Tiles is rendered.\n    // The additional texture and framebuffer resources are created on demand.\n    if (defined(this._updateDepthCommand)) {\n      if (\n        !defined(this._updateDepthFramebuffer.framebuffer) ||\n        this._updateDepthFramebuffer.getDepthStencilTexture() !==\n          depthTextureToCopy ||\n        this._updateDepthFramebuffer.getColorTexture() !==\n          this._copyDepthFramebuffer.getColorTexture()\n      ) {\n        const width = this._copyDepthFramebuffer.getColorTexture().width;\n        const height = this._copyDepthFramebuffer.getColorTexture().height;\n        this._tempCopyDepthFramebuffer.destroy();\n        this._tempCopyDepthFramebuffer.update(context, width, height);\n\n        const colorTexture = this._copyDepthFramebuffer.getColorTexture();\n        this._updateDepthFramebuffer.setColorTexture(colorTexture, 0);\n        this._updateDepthFramebuffer.setDepthStencilTexture(depthTextureToCopy);\n        this._updateDepthFramebuffer.update(context, width, height);\n\n        updateCopyCommands(this, context, width, height, passState);\n      }\n      this._tempCopyDepthTexture = depthTextureToCopy;\n      this._tempCopyDepthCommand.execute(context, passState);\n      this._updateDepthCommand.execute(context, passState);\n    }\n    return;\n  }\n\n  // Fast path - the depth texture can be copied normally.\n  if (defined(this._copyDepthCommand)) {\n    this._copyDepthCommand.execute(context, passState);\n  }\n};\n\nGlobeDepth.prototype.executeCopyColor = function (context, passState) {\n  if (defined(this._copyColorCommand)) {\n    this._copyColorCommand.execute(context, passState);\n  }\n};\n\nGlobeDepth.prototype.clear = function (context, passState, clearColor) {\n  const clear = this._clearGlobeColorCommand;\n  if (defined(clear)) {\n    Color.clone(clearColor, clear.color);\n    this.colorFramebufferManager.clear(context, clear, passState);\n  }\n};\n\nGlobeDepth.prototype.isDestroyed = function () {\n  return false;\n};\n\nGlobeDepth.prototype.destroy = function () {\n  destroyFramebuffers(this);\n\n  if (defined(this._copyColorCommand)) {\n    this._copyColorCommand.shaderProgram = this._copyColorCommand.shaderProgram.destroy();\n  }\n\n  if (defined(this._copyDepthCommand)) {\n    this._copyDepthCommand.shaderProgram = this._copyDepthCommand.shaderProgram.destroy();\n  }\n\n  if (defined(this._tempCopyDepthCommand)) {\n    this._tempCopyDepthCommand.shaderProgram = this._tempCopyDepthCommand.shaderProgram.destroy();\n  }\n\n  if (defined(this._updateDepthCommand)) {\n    this._updateDepthCommand.shaderProgram = this._updateDepthCommand.shaderProgram.destroy();\n  }\n\n  return destroyObject(this);\n};\nexport default GlobeDepth;\n","import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nfunction GlobeSurfaceShader(\n  numberOfDayTextures,\n  flags,\n  material,\n  shaderProgram,\n  clippingShaderState\n) {\n  this.numberOfDayTextures = numberOfDayTextures;\n  this.flags = flags;\n  this.material = material;\n  this.shaderProgram = shaderProgram;\n  this.clippingShaderState = clippingShaderState;\n}\n\n/**\n * Manages the shaders used to shade the surface of a {@link Globe}.\n *\n * @alias GlobeSurfaceShaderSet\n * @private\n */\nfunction GlobeSurfaceShaderSet() {\n  this.baseVertexShaderSource = undefined;\n  this.baseFragmentShaderSource = undefined;\n\n  this._shadersByTexturesFlags = [];\n\n  this.material = undefined;\n}\n\nfunction getPositionMode(sceneMode) {\n  const getPosition3DMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }\";\n  const getPositionColumbusViewAnd2DMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }\";\n  const getPositionMorphingMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }\";\n\n  let positionMode;\n\n  switch (sceneMode) {\n    case SceneMode.SCENE3D:\n      positionMode = getPosition3DMode;\n      break;\n    case SceneMode.SCENE2D:\n    case SceneMode.COLUMBUS_VIEW:\n      positionMode = getPositionColumbusViewAnd2DMode;\n      break;\n    case SceneMode.MORPHING:\n      positionMode = getPositionMorphingMode;\n      break;\n  }\n\n  return positionMode;\n}\n\nfunction get2DYPositionFraction(useWebMercatorProjection) {\n  const get2DYPositionFractionGeographicProjection =\n    \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }\";\n  const get2DYPositionFractionMercatorProjection =\n    \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }\";\n  return useWebMercatorProjection\n    ? get2DYPositionFractionMercatorProjection\n    : get2DYPositionFractionGeographicProjection;\n}\n\nGlobeSurfaceShaderSet.prototype.getShaderProgram = function (options) {\n  const frameState = options.frameState;\n  const surfaceTile = options.surfaceTile;\n  const numberOfDayTextures = options.numberOfDayTextures;\n  const applyBrightness = options.applyBrightness;\n  const applyContrast = options.applyContrast;\n  const applyHue = options.applyHue;\n  const applySaturation = options.applySaturation;\n  const applyGamma = options.applyGamma;\n  const applyAlpha = options.applyAlpha;\n  const applyDayNightAlpha = options.applyDayNightAlpha;\n  const applySplit = options.applySplit;\n  const showReflectiveOcean = options.showReflectiveOcean;\n  const showOceanWaves = options.showOceanWaves;\n  const enableLighting = options.enableLighting;\n  const dynamicAtmosphereLighting = options.dynamicAtmosphereLighting;\n  const dynamicAtmosphereLightingFromSun =\n    options.dynamicAtmosphereLightingFromSun;\n  const showGroundAtmosphere = options.showGroundAtmosphere;\n  const perFragmentGroundAtmosphere = options.perFragmentGroundAtmosphere;\n  const hasVertexNormals = options.hasVertexNormals;\n  const useWebMercatorProjection = options.useWebMercatorProjection;\n  const enableFog = options.enableFog;\n  const enableClippingPlanes = options.enableClippingPlanes;\n  const clippingPlanes = options.clippingPlanes;\n  const clippedByBoundaries = options.clippedByBoundaries;\n  const hasImageryLayerCutout = options.hasImageryLayerCutout;\n  const colorCorrect = options.colorCorrect;\n  const highlightFillTile = options.highlightFillTile;\n  const colorToAlpha = options.colorToAlpha;\n  const hasGeodeticSurfaceNormals = options.hasGeodeticSurfaceNormals;\n  const hasExaggeration = options.hasExaggeration;\n  const showUndergroundColor = options.showUndergroundColor;\n  const translucent = options.translucent;\n\n  let quantization = 0;\n  let quantizationDefine = \"\";\n\n  const mesh = surfaceTile.renderedMesh;\n  const terrainEncoding = mesh.encoding;\n  const quantizationMode = terrainEncoding.quantization;\n  if (quantizationMode === TerrainQuantization.BITS12) {\n    quantization = 1;\n    quantizationDefine = \"QUANTIZATION_BITS12\";\n  }\n\n  let cartographicLimitRectangleFlag = 0;\n  let cartographicLimitRectangleDefine = \"\";\n  if (clippedByBoundaries) {\n    cartographicLimitRectangleFlag = 1;\n    cartographicLimitRectangleDefine = \"TILE_LIMIT_RECTANGLE\";\n  }\n\n  let imageryCutoutFlag = 0;\n  let imageryCutoutDefine = \"\";\n  if (hasImageryLayerCutout) {\n    imageryCutoutFlag = 1;\n    imageryCutoutDefine = \"APPLY_IMAGERY_CUTOUT\";\n  }\n\n  const sceneMode = frameState.mode;\n  const flags =\n    sceneMode |\n    (applyBrightness << 2) |\n    (applyContrast << 3) |\n    (applyHue << 4) |\n    (applySaturation << 5) |\n    (applyGamma << 6) |\n    (applyAlpha << 7) |\n    (showReflectiveOcean << 8) |\n    (showOceanWaves << 9) |\n    (enableLighting << 10) |\n    (dynamicAtmosphereLighting << 11) |\n    (dynamicAtmosphereLightingFromSun << 12) |\n    (showGroundAtmosphere << 13) |\n    (perFragmentGroundAtmosphere << 14) |\n    (hasVertexNormals << 15) |\n    (useWebMercatorProjection << 16) |\n    (enableFog << 17) |\n    (quantization << 18) |\n    (applySplit << 19) |\n    (enableClippingPlanes << 20) |\n    (cartographicLimitRectangleFlag << 21) |\n    (imageryCutoutFlag << 22) |\n    (colorCorrect << 23) |\n    (highlightFillTile << 24) |\n    (colorToAlpha << 25) |\n    (hasGeodeticSurfaceNormals << 26) |\n    (hasExaggeration << 27) |\n    (showUndergroundColor << 28) |\n    (translucent << 29) |\n    (applyDayNightAlpha << 30);\n\n  let currentClippingShaderState = 0;\n  if (defined(clippingPlanes) && clippingPlanes.length > 0) {\n    currentClippingShaderState = enableClippingPlanes\n      ? clippingPlanes.clippingPlanesState\n      : 0;\n  }\n  let surfaceShader = surfaceTile.surfaceShader;\n  if (\n    defined(surfaceShader) &&\n    surfaceShader.numberOfDayTextures === numberOfDayTextures &&\n    surfaceShader.flags === flags &&\n    surfaceShader.material === this.material &&\n    surfaceShader.clippingShaderState === currentClippingShaderState\n  ) {\n    return surfaceShader.shaderProgram;\n  }\n\n  // New tile, or tile changed number of textures, flags, or clipping planes\n  let shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures];\n  if (!defined(shadersByFlags)) {\n    shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures] = [];\n  }\n\n  surfaceShader = shadersByFlags[flags];\n  if (\n    !defined(surfaceShader) ||\n    surfaceShader.material !== this.material ||\n    surfaceShader.clippingShaderState !== currentClippingShaderState\n  ) {\n    // Cache miss - we've never seen this combination of numberOfDayTextures and flags before.\n    const vs = this.baseVertexShaderSource.clone();\n    const fs = this.baseFragmentShaderSource.clone();\n\n    if (currentClippingShaderState !== 0) {\n      fs.sources.unshift(\n        getClippingFunction(clippingPlanes, frameState.context)\n      ); // Need to go before GlobeFS\n    }\n\n    vs.defines.push(quantizationDefine);\n    fs.defines.push(\n      `TEXTURE_UNITS ${numberOfDayTextures}`,\n      cartographicLimitRectangleDefine,\n      imageryCutoutDefine\n    );\n\n    if (applyBrightness) {\n      fs.defines.push(\"APPLY_BRIGHTNESS\");\n    }\n    if (applyContrast) {\n      fs.defines.push(\"APPLY_CONTRAST\");\n    }\n    if (applyHue) {\n      fs.defines.push(\"APPLY_HUE\");\n    }\n    if (applySaturation) {\n      fs.defines.push(\"APPLY_SATURATION\");\n    }\n    if (applyGamma) {\n      fs.defines.push(\"APPLY_GAMMA\");\n    }\n    if (applyAlpha) {\n      fs.defines.push(\"APPLY_ALPHA\");\n    }\n    if (applyDayNightAlpha) {\n      fs.defines.push(\"APPLY_DAY_NIGHT_ALPHA\");\n    }\n    if (showReflectiveOcean) {\n      fs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n      vs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n    }\n    if (showOceanWaves) {\n      fs.defines.push(\"SHOW_OCEAN_WAVES\");\n    }\n    if (colorToAlpha) {\n      fs.defines.push(\"APPLY_COLOR_TO_ALPHA\");\n    }\n    if (showUndergroundColor) {\n      vs.defines.push(\"UNDERGROUND_COLOR\");\n      fs.defines.push(\"UNDERGROUND_COLOR\");\n    }\n    if (translucent) {\n      vs.defines.push(\"TRANSLUCENT\");\n      fs.defines.push(\"TRANSLUCENT\");\n    }\n    if (enableLighting) {\n      if (hasVertexNormals) {\n        vs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n        fs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n      } else {\n        vs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n        fs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n      }\n    }\n\n    if (dynamicAtmosphereLighting) {\n      vs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n      fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n      if (dynamicAtmosphereLightingFromSun) {\n        vs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n        fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n      }\n    }\n\n    if (showGroundAtmosphere) {\n      vs.defines.push(\"GROUND_ATMOSPHERE\");\n      fs.defines.push(\"GROUND_ATMOSPHERE\");\n      if (perFragmentGroundAtmosphere) {\n        vs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n        fs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n      }\n    }\n\n    vs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n    fs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n\n    if (enableFog) {\n      vs.defines.push(\"FOG\");\n      fs.defines.push(\"FOG\");\n    }\n\n    if (applySplit) {\n      fs.defines.push(\"APPLY_SPLIT\");\n    }\n\n    if (enableClippingPlanes) {\n      fs.defines.push(\"ENABLE_CLIPPING_PLANES\");\n    }\n\n    if (colorCorrect) {\n      fs.defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (highlightFillTile) {\n      fs.defines.push(\"HIGHLIGHT_FILL_TILE\");\n    }\n\n    if (hasGeodeticSurfaceNormals) {\n      vs.defines.push(\"GEODETIC_SURFACE_NORMALS\");\n    }\n\n    if (hasExaggeration) {\n      vs.defines.push(\"EXAGGERATION\");\n    }\n\n    let computeDayColor =\n      \"\\\n    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend)\\n\\\n    {\\n\\\n        vec4 color = initialColor;\\n\";\n\n    if (hasImageryLayerCutout) {\n      computeDayColor +=\n        \"\\\n        vec4 cutoutAndColorResult;\\n\\\n        bool texelUnclipped;\\n\";\n    }\n\n    for (let i = 0; i < numberOfDayTextures; ++i) {\n      if (hasImageryLayerCutout) {\n        computeDayColor += `\\\n        cutoutAndColorResult = u_dayTextureCutoutRectangles[${i}];\\n\\\n        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;\\n\\\n        cutoutAndColorResult = sampleAndBlend(\\n`;\n      } else {\n        computeDayColor += \"\\\n        color = sampleAndBlend(\\n\";\n      }\n      computeDayColor += `\\\n            color,\\n\\\n            u_dayTextures[${i}],\\n\\\n            u_dayTextureUseWebMercatorT[${i}] ? textureCoordinates.xz : textureCoordinates.xy,\\n\\\n            u_dayTextureTexCoordsRectangle[${i}],\\n\\\n            u_dayTextureTranslationAndScale[${i}],\\n\\\n            ${applyAlpha ? `u_dayTextureAlpha[${i}]` : \"1.0\"},\\n\\\n            ${applyDayNightAlpha ? `u_dayTextureNightAlpha[${i}]` : \"1.0\"},\\n${\n        applyDayNightAlpha ? `u_dayTextureDayAlpha[${i}]` : \"1.0\"\n      },\\n${applyBrightness ? `u_dayTextureBrightness[${i}]` : \"0.0\"},\\n\\\n            ${applyContrast ? `u_dayTextureContrast[${i}]` : \"0.0\"},\\n\\\n            ${applyHue ? `u_dayTextureHue[${i}]` : \"0.0\"},\\n\\\n            ${applySaturation ? `u_dayTextureSaturation[${i}]` : \"0.0\"},\\n\\\n            ${applyGamma ? `u_dayTextureOneOverGamma[${i}]` : \"0.0\"},\\n\\\n            ${applySplit ? `u_dayTextureSplit[${i}]` : \"0.0\"},\\n\\\n            ${colorToAlpha ? `u_colorsToAlpha[${i}]` : \"vec4(0.0)\"},\\n\\\n        nightBlend\\\n        );\\n`;\n      if (hasImageryLayerCutout) {\n        computeDayColor +=\n          \"\\\n        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);\\n\";\n      }\n    }\n\n    computeDayColor += \"\\\n        return color;\\n\\\n    }\";\n\n    fs.sources.push(computeDayColor);\n\n    vs.sources.push(getPositionMode(sceneMode));\n    vs.sources.push(get2DYPositionFraction(useWebMercatorProjection));\n\n    const shader = ShaderProgram.fromCache({\n      context: frameState.context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: terrainEncoding.getAttributeLocations(),\n    });\n\n    surfaceShader = shadersByFlags[flags] = new GlobeSurfaceShader(\n      numberOfDayTextures,\n      flags,\n      this.material,\n      shader,\n      currentClippingShaderState\n    );\n  }\n\n  surfaceTile.surfaceShader = surfaceShader;\n  return surfaceShader.shaderProgram;\n};\n\nGlobeSurfaceShaderSet.prototype.destroy = function () {\n  let flags;\n  let shader;\n\n  const shadersByTexturesFlags = this._shadersByTexturesFlags;\n  for (const textureCount in shadersByTexturesFlags) {\n    if (shadersByTexturesFlags.hasOwnProperty(textureCount)) {\n      const shadersByFlags = shadersByTexturesFlags[textureCount];\n      if (!defined(shadersByFlags)) {\n        continue;\n      }\n\n      for (flags in shadersByFlags) {\n        if (shadersByFlags.hasOwnProperty(flags)) {\n          shader = shadersByFlags[flags];\n          if (defined(shader)) {\n            shader.shaderProgram.destroy();\n          }\n        }\n      }\n    }\n  }\n\n  return destroyObject(this);\n};\nexport default GlobeSurfaceShaderSet;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport TerrainState from \"./TerrainState.js\";\n\n/**\n * Contains additional information about a {@link QuadtreeTile} of the globe's surface, and\n * encapsulates state transition logic for loading tiles.\n *\n * @constructor\n * @alias GlobeSurfaceTile\n * @private\n */\nfunction GlobeSurfaceTile() {\n  /**\n   * The {@link TileImagery} attached to this tile.\n   * @type {TileImagery[]}\n   * @default []\n   */\n  this.imagery = [];\n\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4(0.0, 0.0, 1.0, 1.0);\n\n  this.terrainData = undefined;\n  this.vertexArray = undefined;\n\n  /**\n   * A bounding region used to estimate distance to the tile. The horizontal bounds are always tight-fitting,\n   * but the `minimumHeight` and `maximumHeight` properties may be derived from the min/max of an ancestor tile\n   * and be quite loose-fitting and thus very poor for estimating distance.\n   * @type {TileBoundingRegion}\n   */\n  this.tileBoundingRegion = undefined;\n  this.occludeePointInScaledSpace = new Cartesian3();\n  this.boundingVolumeSourceTile = undefined;\n  this.boundingVolumeIsFromMesh = false;\n\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = undefined;\n\n  this.pickBoundingSphere = new BoundingSphere();\n\n  this.surfaceShader = undefined;\n  this.isClipped = true;\n\n  this.clippedByBoundaries = false;\n}\n\nObject.defineProperties(GlobeSurfaceTile.prototype, {\n  /**\n   * Gets a value indicating whether or not this tile is eligible to be unloaded.\n   * Typically, a tile is ineligible to be unloaded while an asynchronous operation,\n   * such as a request for data, is in progress on it.  A tile will never be\n   * unloaded while it is needed for rendering, regardless of the value of this\n   * property.\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {Boolean}\n   */\n  eligibleForUnloading: {\n    get: function () {\n      // Do not remove tiles that are transitioning or that have\n      // imagery that is transitioning.\n      const terrainState = this.terrainState;\n      const loadingIsTransitioning =\n        terrainState === TerrainState.RECEIVING ||\n        terrainState === TerrainState.TRANSFORMING;\n\n      let shouldRemoveTile = !loadingIsTransitioning;\n\n      const imagery = this.imagery;\n      for (let i = 0, len = imagery.length; shouldRemoveTile && i < len; ++i) {\n        const tileImagery = imagery[i];\n        shouldRemoveTile =\n          !defined(tileImagery.loadingImagery) ||\n          tileImagery.loadingImagery.state !== ImageryState.TRANSITIONING;\n      }\n\n      return shouldRemoveTile;\n    },\n  },\n\n  /**\n   * Gets the {@link TerrainMesh} that is used for rendering this tile, if any.\n   * Returns the value of the {@link GlobeSurfaceTile#mesh} property if\n   * {@link GlobeSurfaceTile#vertexArray} is defined. Otherwise, It returns the\n   * {@link TerrainFillMesh#mesh} property of the {@link GlobeSurfaceTile#fill}.\n   * If there is no fill, it returns undefined.\n   *\n   * @memberof GlobeSurfaceTile.prototype\n   * @type {TerrainMesh}\n   */\n  renderedMesh: {\n    get: function () {\n      if (defined(this.vertexArray)) {\n        return this.mesh;\n      } else if (defined(this.fill)) {\n        return this.fill.mesh;\n      }\n      return undefined;\n    },\n  },\n});\n\nconst scratchCartographic = new Cartographic();\n\nfunction getPosition(encoding, mode, projection, vertices, index, result) {\n  let position = encoding.getExaggeratedPosition(vertices, index, result);\n\n  if (defined(mode) && mode !== SceneMode.SCENE3D) {\n    const ellipsoid = projection.ellipsoid;\n    const positionCartographic = ellipsoid.cartesianToCartographic(\n      position,\n      scratchCartographic\n    );\n    position = projection.project(positionCartographic, result);\n    position = Cartesian3.fromElements(\n      position.z,\n      position.x,\n      position.y,\n      result\n    );\n  }\n\n  return position;\n}\n\nconst scratchV0 = new Cartesian3();\nconst scratchV1 = new Cartesian3();\nconst scratchV2 = new Cartesian3();\n\nGlobeSurfaceTile.prototype.pick = function (\n  ray,\n  mode,\n  projection,\n  cullBackFaces,\n  result\n) {\n  const mesh = this.renderedMesh;\n  if (!defined(mesh)) {\n    return undefined;\n  }\n\n  const vertices = mesh.vertices;\n  const indices = mesh.indices;\n  const encoding = mesh.encoding;\n  const indicesLength = indices.length;\n\n  let minT = Number.MAX_VALUE;\n\n  for (let i = 0; i < indicesLength; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    const v0 = getPosition(encoding, mode, projection, vertices, i0, scratchV0);\n    const v1 = getPosition(encoding, mode, projection, vertices, i1, scratchV1);\n    const v2 = getPosition(encoding, mode, projection, vertices, i2, scratchV2);\n\n    const t = IntersectionTests.rayTriangleParametric(\n      ray,\n      v0,\n      v1,\n      v2,\n      cullBackFaces\n    );\n    if (defined(t) && t < minT && t >= 0.0) {\n      minT = t;\n    }\n  }\n\n  return minT !== Number.MAX_VALUE\n    ? Ray.getPoint(ray, minT, result)\n    : undefined;\n};\n\nGlobeSurfaceTile.prototype.freeResources = function () {\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n    this.waterMaskTexture = undefined;\n  }\n\n  this.terrainData = undefined;\n\n  this.terrainState = TerrainState.UNLOADED;\n  this.mesh = undefined;\n  this.fill = this.fill && this.fill.destroy();\n\n  const imageryList = this.imagery;\n  for (let i = 0, len = imageryList.length; i < len; ++i) {\n    imageryList[i].freeResources();\n  }\n  this.imagery.length = 0;\n\n  this.freeVertexArray();\n};\n\nGlobeSurfaceTile.prototype.freeVertexArray = function () {\n  GlobeSurfaceTile._freeVertexArray(this.vertexArray);\n  this.vertexArray = undefined;\n  GlobeSurfaceTile._freeVertexArray(this.wireframeVertexArray);\n  this.wireframeVertexArray = undefined;\n};\n\nGlobeSurfaceTile.initialize = function (\n  tile,\n  terrainProvider,\n  imageryLayerCollection\n) {\n  let surfaceTile = tile.data;\n  if (!defined(surfaceTile)) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  if (tile.state === QuadtreeTileLoadState.START) {\n    prepareNewTile(tile, terrainProvider, imageryLayerCollection);\n    tile.state = QuadtreeTileLoadState.LOADING;\n  }\n};\n\nGlobeSurfaceTile.processStateMachine = function (\n  tile,\n  frameState,\n  terrainProvider,\n  imageryLayerCollection,\n  quadtree,\n  vertexArraysToDestroy,\n  terrainOnly\n) {\n  GlobeSurfaceTile.initialize(tile, terrainProvider, imageryLayerCollection);\n\n  const surfaceTile = tile.data;\n\n  if (tile.state === QuadtreeTileLoadState.LOADING) {\n    processTerrainStateMachine(\n      tile,\n      frameState,\n      terrainProvider,\n      imageryLayerCollection,\n      quadtree,\n      vertexArraysToDestroy\n    );\n  }\n\n  // From here down we're loading imagery, not terrain. We don't want to load imagery until\n  // we're certain that the terrain tiles are actually visible, though. We'll load terrainOnly\n  // in these scenarios:\n  //   * our bounding volume isn't accurate so we're not certain this tile is really visible (see GlobeSurfaceTileProvider#loadTile).\n  //   * we want to upsample from this tile but don't plan to render it (see processTerrainStateMachine).\n  if (terrainOnly) {\n    return;\n  }\n\n  const wasAlreadyRenderable = tile.renderable;\n\n  // The terrain is renderable as soon as we have a valid vertex array.\n  tile.renderable = defined(surfaceTile.vertexArray);\n\n  // But it's not done loading until it's in the READY state.\n  const isTerrainDoneLoading = surfaceTile.terrainState === TerrainState.READY;\n\n  // If this tile's terrain and imagery are just upsampled from its parent, mark the tile as\n  // upsampled only.  We won't refine a tile if its four children are upsampled only.\n  tile.upsampledFromParent =\n    defined(surfaceTile.terrainData) &&\n    surfaceTile.terrainData.wasCreatedByUpsampling();\n\n  const isImageryDoneLoading = surfaceTile.processImagery(\n    tile,\n    terrainProvider,\n    frameState\n  );\n\n  if (isTerrainDoneLoading && isImageryDoneLoading) {\n    const callbacks = tile._loadedCallbacks;\n    const newCallbacks = {};\n    for (const layerId in callbacks) {\n      if (callbacks.hasOwnProperty(layerId)) {\n        if (!callbacks[layerId](tile)) {\n          newCallbacks[layerId] = callbacks[layerId];\n        }\n      }\n    }\n    tile._loadedCallbacks = newCallbacks;\n\n    tile.state = QuadtreeTileLoadState.DONE;\n  }\n\n  // Once a tile is renderable, it stays renderable, because doing otherwise would\n  // cause detail (or maybe even the entire globe) to vanish when adding a new\n  // imagery layer. `GlobeSurfaceTileProvider._onLayerAdded` sets renderable to\n  // false for all affected tiles that are not currently being rendered.\n  if (wasAlreadyRenderable) {\n    tile.renderable = true;\n  }\n};\n\nGlobeSurfaceTile.prototype.processImagery = function (\n  tile,\n  terrainProvider,\n  frameState,\n  skipLoading\n) {\n  const surfaceTile = tile.data;\n  let isUpsampledOnly = tile.upsampledFromParent;\n  let isAnyTileLoaded = false;\n  let isDoneLoading = true;\n\n  // Transition imagery states\n  const tileImageryCollection = surfaceTile.imagery;\n  let i, len;\n  for (i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    const tileImagery = tileImageryCollection[i];\n    if (!defined(tileImagery.loadingImagery)) {\n      isUpsampledOnly = false;\n      continue;\n    }\n\n    if (tileImagery.loadingImagery.state === ImageryState.PLACEHOLDER) {\n      const imageryLayer = tileImagery.loadingImagery.imageryLayer;\n      if (imageryLayer.imageryProvider.ready) {\n        // Remove the placeholder and add the actual skeletons (if any)\n        // at the same position.  Then continue the loop at the same index.\n        tileImagery.freeResources();\n        tileImageryCollection.splice(i, 1);\n        imageryLayer._createTileImagerySkeletons(tile, terrainProvider, i);\n        --i;\n        len = tileImageryCollection.length;\n        continue;\n      } else {\n        isUpsampledOnly = false;\n      }\n    }\n\n    const thisTileDoneLoading = tileImagery.processStateMachine(\n      tile,\n      frameState,\n      skipLoading\n    );\n    isDoneLoading = isDoneLoading && thisTileDoneLoading;\n\n    // The imagery is renderable as soon as we have any renderable imagery for this region.\n    isAnyTileLoaded =\n      isAnyTileLoaded ||\n      thisTileDoneLoading ||\n      defined(tileImagery.readyImagery);\n\n    isUpsampledOnly =\n      isUpsampledOnly &&\n      defined(tileImagery.loadingImagery) &&\n      (tileImagery.loadingImagery.state === ImageryState.FAILED ||\n        tileImagery.loadingImagery.state === ImageryState.INVALID);\n  }\n\n  tile.upsampledFromParent = isUpsampledOnly;\n\n  // Allow rendering if any available layers are loaded\n  tile.renderable = tile.renderable && (isAnyTileLoaded || isDoneLoading);\n\n  return isDoneLoading;\n};\n\nfunction toggleGeodeticSurfaceNormals(\n  surfaceTile,\n  enabled,\n  ellipsoid,\n  frameState\n) {\n  const renderedMesh = surfaceTile.renderedMesh;\n  const vertexBuffer = renderedMesh.vertices;\n  const encoding = renderedMesh.encoding;\n  const vertexCount = vertexBuffer.length / encoding.stride;\n\n  // Calculate the new stride and generate a new buffer\n  // Clone the other encoding, toggle geodetic surface normals, then clone again to get updated stride\n  let newEncoding = TerrainEncoding.clone(encoding);\n  newEncoding.hasGeodeticSurfaceNormals = enabled;\n  newEncoding = TerrainEncoding.clone(newEncoding);\n  const newStride = newEncoding.stride;\n  const newVertexBuffer = new Float32Array(vertexCount * newStride);\n\n  if (enabled) {\n    encoding.addGeodeticSurfaceNormals(\n      vertexBuffer,\n      newVertexBuffer,\n      ellipsoid\n    );\n  } else {\n    encoding.removeGeodeticSurfaceNormals(vertexBuffer, newVertexBuffer);\n  }\n\n  renderedMesh.vertices = newVertexBuffer;\n  renderedMesh.stride = newStride;\n\n  // delete the old vertex array (which deletes the vertex buffer attached to it), and create a new vertex array with the new vertex buffer\n  const isFill = renderedMesh !== surfaceTile.mesh;\n  if (isFill) {\n    GlobeSurfaceTile._freeVertexArray(surfaceTile.fill.vertexArray);\n    surfaceTile.fill.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n      frameState.context,\n      renderedMesh\n    );\n  } else {\n    GlobeSurfaceTile._freeVertexArray(surfaceTile.vertexArray);\n    surfaceTile.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n      frameState.context,\n      renderedMesh\n    );\n  }\n  GlobeSurfaceTile._freeVertexArray(surfaceTile.wireframeVertexArray);\n  surfaceTile.wireframeVertexArray = undefined;\n}\n\nGlobeSurfaceTile.prototype.addGeodeticSurfaceNormals = function (\n  ellipsoid,\n  frameState\n) {\n  toggleGeodeticSurfaceNormals(this, true, ellipsoid, frameState);\n};\n\nGlobeSurfaceTile.prototype.removeGeodeticSurfaceNormals = function (\n  frameState\n) {\n  toggleGeodeticSurfaceNormals(this, false, undefined, frameState);\n};\n\nGlobeSurfaceTile.prototype.updateExaggeration = function (\n  tile,\n  frameState,\n  quadtree\n) {\n  const surfaceTile = this;\n  const mesh = surfaceTile.renderedMesh;\n  if (mesh === undefined) {\n    return;\n  }\n\n  // Check the tile's terrain encoding to see if it has been exaggerated yet\n  const exaggeration = frameState.terrainExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.terrainExaggerationRelativeHeight;\n  const hasExaggerationScale = exaggeration !== 1.0;\n\n  const encoding = mesh.encoding;\n  const encodingExaggerationScaleChanged =\n    encoding.exaggeration !== exaggeration;\n  const encodingRelativeHeightChanged =\n    encoding.exaggerationRelativeHeight !== exaggerationRelativeHeight;\n\n  if (encodingExaggerationScaleChanged || encodingRelativeHeightChanged) {\n    // Turning exaggeration scale on/off requires adding or removing geodetic surface normals\n    // Relative height only translates, so it has no effect on normals\n    if (encodingExaggerationScaleChanged) {\n      if (hasExaggerationScale && !encoding.hasGeodeticSurfaceNormals) {\n        const ellipsoid = tile.tilingScheme.ellipsoid;\n        surfaceTile.addGeodeticSurfaceNormals(ellipsoid, frameState);\n      } else if (!hasExaggerationScale && encoding.hasGeodeticSurfaceNormals) {\n        surfaceTile.removeGeodeticSurfaceNormals(frameState);\n      }\n    }\n\n    encoding.exaggeration = exaggeration;\n    encoding.exaggerationRelativeHeight = exaggerationRelativeHeight;\n\n    // Notify the quadtree that this tile's height has changed\n    if (quadtree !== undefined) {\n      quadtree._tileToUpdateHeights.push(tile);\n      const customData = tile.customData;\n      const customDataLength = customData.length;\n      for (let i = 0; i < customDataLength; i++) {\n        // Restart the level so that a height update is triggered\n        const data = customData[i];\n        data.level = -1;\n      }\n    }\n  }\n};\n\nfunction prepareNewTile(tile, terrainProvider, imageryLayerCollection) {\n  let available = terrainProvider.getTileDataAvailable(\n    tile.x,\n    tile.y,\n    tile.level\n  );\n\n  if (!defined(available) && defined(tile.parent)) {\n    // Provider doesn't know if this tile is available. Does the parent tile know?\n    const parent = tile.parent;\n    const parentSurfaceTile = parent.data;\n    if (defined(parentSurfaceTile) && defined(parentSurfaceTile.terrainData)) {\n      available = parentSurfaceTile.terrainData.isChildAvailable(\n        parent.x,\n        parent.y,\n        tile.x,\n        tile.y\n      );\n    }\n  }\n\n  if (available === false) {\n    // This tile is not available, so mark it failed so we start upsampling right away.\n    tile.data.terrainState = TerrainState.FAILED;\n  }\n\n  // Map imagery tiles to this terrain tile\n  for (let i = 0, len = imageryLayerCollection.length; i < len; ++i) {\n    const layer = imageryLayerCollection.get(i);\n    if (layer.show) {\n      layer._createTileImagerySkeletons(tile, terrainProvider);\n    }\n  }\n}\n\nfunction processTerrainStateMachine(\n  tile,\n  frameState,\n  terrainProvider,\n  imageryLayerCollection,\n  quadtree,\n  vertexArraysToDestroy\n) {\n  const surfaceTile = tile.data;\n\n  // If this tile is FAILED, we'll need to upsample from the parent. If the parent isn't\n  // ready for that, let's push it along.\n  const parent = tile.parent;\n  if (\n    surfaceTile.terrainState === TerrainState.FAILED &&\n    parent !== undefined\n  ) {\n    const parentReady =\n      parent.data !== undefined &&\n      parent.data.terrainData !== undefined &&\n      parent.data.terrainData.canUpsample !== false;\n    if (!parentReady) {\n      GlobeSurfaceTile.processStateMachine(\n        parent,\n        frameState,\n        terrainProvider,\n        imageryLayerCollection,\n        quadtree,\n        vertexArraysToDestroy,\n        true\n      );\n    }\n  }\n\n  if (surfaceTile.terrainState === TerrainState.FAILED) {\n    upsample(\n      surfaceTile,\n      tile,\n      frameState,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level\n    );\n  }\n\n  if (surfaceTile.terrainState === TerrainState.UNLOADED) {\n    requestTileGeometry(\n      surfaceTile,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level\n    );\n  }\n\n  if (surfaceTile.terrainState === TerrainState.RECEIVED) {\n    transform(\n      surfaceTile,\n      frameState,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level\n    );\n  }\n\n  if (surfaceTile.terrainState === TerrainState.TRANSFORMED) {\n    createResources(\n      surfaceTile,\n      frameState.context,\n      terrainProvider,\n      tile.x,\n      tile.y,\n      tile.level,\n      vertexArraysToDestroy\n    );\n\n    // Update the tile's exaggeration in case the globe's exaggeration changed while the tile was being processed\n    surfaceTile.updateExaggeration(tile, frameState, quadtree);\n  }\n\n  if (\n    surfaceTile.terrainState >= TerrainState.RECEIVED &&\n    surfaceTile.waterMaskTexture === undefined &&\n    terrainProvider.hasWaterMask\n  ) {\n    const terrainData = surfaceTile.terrainData;\n    if (terrainData.waterMask !== undefined) {\n      createWaterMaskTextureIfNeeded(frameState.context, surfaceTile);\n    } else {\n      const sourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n      if (defined(sourceTile) && defined(sourceTile.data.waterMaskTexture)) {\n        surfaceTile.waterMaskTexture = sourceTile.data.waterMaskTexture;\n        ++surfaceTile.waterMaskTexture.referenceCount;\n        surfaceTile._computeWaterMaskTranslationAndScale(\n          tile,\n          sourceTile,\n          surfaceTile.waterMaskTranslationAndScale\n        );\n      }\n    }\n  }\n}\n\nfunction upsample(surfaceTile, tile, frameState, terrainProvider, x, y, level) {\n  const parent = tile.parent;\n  if (!parent) {\n    // Trying to upsample from a root tile. No can do. This tile is a failure.\n    tile.state = QuadtreeTileLoadState.FAILED;\n    return;\n  }\n\n  const sourceData = parent.data.terrainData;\n  const sourceX = parent.x;\n  const sourceY = parent.y;\n  const sourceLevel = parent.level;\n\n  if (!defined(sourceData)) {\n    // Parent is not available, so we can't upsample this tile yet.\n    return;\n  }\n\n  const terrainDataPromise = sourceData.upsample(\n    terrainProvider.tilingScheme,\n    sourceX,\n    sourceY,\n    sourceLevel,\n    x,\n    y,\n    level\n  );\n  if (!defined(terrainDataPromise)) {\n    // The upsample request has been deferred - try again later.\n    return;\n  }\n\n  surfaceTile.terrainState = TerrainState.RECEIVING;\n\n  Promise.resolve(terrainDataPromise)\n    .then(function (terrainData) {\n      surfaceTile.terrainData = terrainData;\n      surfaceTile.terrainState = TerrainState.RECEIVED;\n    })\n    .catch(function () {\n      surfaceTile.terrainState = TerrainState.FAILED;\n    });\n}\n\nfunction requestTileGeometry(surfaceTile, terrainProvider, x, y, level) {\n  function success(terrainData) {\n    surfaceTile.terrainData = terrainData;\n    surfaceTile.terrainState = TerrainState.RECEIVED;\n    surfaceTile.request = undefined;\n  }\n\n  function failure(error) {\n    if (surfaceTile.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      surfaceTile.terrainData = undefined;\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n      return;\n    }\n\n    // Initially assume failure.  handleError may retry, in which case the state will\n    // change to RECEIVING or UNLOADED.\n    surfaceTile.terrainState = TerrainState.FAILED;\n    surfaceTile.request = undefined;\n\n    const message = `Failed to obtain terrain tile X: ${x} Y: ${y} Level: ${level}. Error message: \"${error}\"`;\n    terrainProvider._requestError = TileProviderError.handleError(\n      terrainProvider._requestError,\n      terrainProvider,\n      terrainProvider.errorEvent,\n      message,\n      x,\n      y,\n      level,\n      doRequest\n    );\n  }\n\n  function doRequest() {\n    // Request the terrain from the terrain provider.\n    const request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.TERRAIN,\n    });\n    surfaceTile.request = request;\n\n    const requestPromise = terrainProvider.requestTileGeometry(\n      x,\n      y,\n      level,\n      request\n    );\n\n    // If the request method returns undefined (instead of a promise), the request\n    // has been deferred.\n    if (defined(requestPromise)) {\n      surfaceTile.terrainState = TerrainState.RECEIVING;\n      Promise.resolve(requestPromise)\n        .then(function (terrainData) {\n          success(terrainData);\n        })\n        .catch(function (e) {\n          failure(e);\n        });\n    } else {\n      // Deferred - try again later.\n      surfaceTile.terrainState = TerrainState.UNLOADED;\n      surfaceTile.request = undefined;\n    }\n  }\n\n  doRequest();\n}\n\nconst scratchCreateMeshOptions = {\n  tilingScheme: undefined,\n  x: 0,\n  y: 0,\n  level: 0,\n  exaggeration: 1.0,\n  exaggerationRelativeHeight: 0.0,\n  throttle: true,\n};\n\nfunction transform(surfaceTile, frameState, terrainProvider, x, y, level) {\n  const tilingScheme = terrainProvider.tilingScheme;\n\n  const createMeshOptions = scratchCreateMeshOptions;\n  createMeshOptions.tilingScheme = tilingScheme;\n  createMeshOptions.x = x;\n  createMeshOptions.y = y;\n  createMeshOptions.level = level;\n  createMeshOptions.exaggeration = frameState.terrainExaggeration;\n  createMeshOptions.exaggerationRelativeHeight =\n    frameState.terrainExaggerationRelativeHeight;\n  createMeshOptions.throttle = true;\n\n  const terrainData = surfaceTile.terrainData;\n  const meshPromise = terrainData.createMesh(createMeshOptions);\n\n  if (!defined(meshPromise)) {\n    // Postponed.\n    return;\n  }\n\n  surfaceTile.terrainState = TerrainState.TRANSFORMING;\n\n  Promise.resolve(meshPromise)\n    .then(function (mesh) {\n      surfaceTile.mesh = mesh;\n      surfaceTile.terrainState = TerrainState.TRANSFORMED;\n    })\n    .catch(function () {\n      surfaceTile.terrainState = TerrainState.FAILED;\n    });\n}\n\nGlobeSurfaceTile._createVertexArrayForMesh = function (context, mesh) {\n  const typedArray = mesh.vertices;\n  const buffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: typedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  const attributes = mesh.encoding.getAttributes(buffer);\n\n  const indexBuffers = mesh.indices.indexBuffers || {};\n  let indexBuffer = indexBuffers[context.id];\n  if (!defined(indexBuffer) || indexBuffer.isDestroyed()) {\n    const indices = mesh.indices;\n    indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.fromSizeInBytes(indices.BYTES_PER_ELEMENT),\n    });\n    indexBuffer.vertexArrayDestroyable = false;\n    indexBuffer.referenceCount = 1;\n    indexBuffers[context.id] = indexBuffer;\n    mesh.indices.indexBuffers = indexBuffers;\n  } else {\n    ++indexBuffer.referenceCount;\n  }\n\n  return new VertexArray({\n    context: context,\n    attributes: attributes,\n    indexBuffer: indexBuffer,\n  });\n};\n\nGlobeSurfaceTile._freeVertexArray = function (vertexArray) {\n  if (defined(vertexArray)) {\n    const indexBuffer = vertexArray.indexBuffer;\n\n    if (!vertexArray.isDestroyed()) {\n      vertexArray.destroy();\n    }\n\n    if (\n      defined(indexBuffer) &&\n      !indexBuffer.isDestroyed() &&\n      defined(indexBuffer.referenceCount)\n    ) {\n      --indexBuffer.referenceCount;\n      if (indexBuffer.referenceCount === 0) {\n        indexBuffer.destroy();\n      }\n    }\n  }\n};\n\nfunction createResources(\n  surfaceTile,\n  context,\n  terrainProvider,\n  x,\n  y,\n  level,\n  vertexArraysToDestroy\n) {\n  surfaceTile.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n    context,\n    surfaceTile.mesh\n  );\n  surfaceTile.terrainState = TerrainState.READY;\n  surfaceTile.fill =\n    surfaceTile.fill && surfaceTile.fill.destroy(vertexArraysToDestroy);\n}\n\nfunction getContextWaterMaskData(context) {\n  let data = context.cache.tile_waterMaskData;\n\n  if (!defined(data)) {\n    const allWaterTexture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        arrayBufferView: new Uint8Array([255]),\n        width: 1,\n        height: 1,\n      },\n    });\n    allWaterTexture.referenceCount = 1;\n\n    const sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    });\n\n    data = {\n      allWaterTexture: allWaterTexture,\n      sampler: sampler,\n      destroy: function () {\n        this.allWaterTexture.destroy();\n      },\n    };\n\n    context.cache.tile_waterMaskData = data;\n  }\n\n  return data;\n}\n\nfunction createWaterMaskTextureIfNeeded(context, surfaceTile) {\n  const waterMask = surfaceTile.terrainData.waterMask;\n  const waterMaskData = getContextWaterMaskData(context);\n  let texture;\n\n  const waterMaskLength = waterMask.length;\n  if (waterMaskLength === 1) {\n    // Length 1 means the tile is entirely land or entirely water.\n    // A value of 0 indicates entirely land, a value of 1 indicates entirely water.\n    if (waterMask[0] !== 0) {\n      texture = waterMaskData.allWaterTexture;\n    } else {\n      // Leave the texture undefined if the tile is entirely land.\n      return;\n    }\n  } else {\n    const textureSize = Math.sqrt(waterMaskLength);\n    texture = Texture.create({\n      context: context,\n      pixelFormat: PixelFormat.LUMINANCE,\n      pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n      source: {\n        width: textureSize,\n        height: textureSize,\n        arrayBufferView: waterMask,\n      },\n      sampler: waterMaskData.sampler,\n      flipY: false,\n    });\n\n    texture.referenceCount = 0;\n  }\n\n  ++texture.referenceCount;\n  surfaceTile.waterMaskTexture = texture;\n\n  Cartesian4.fromElements(\n    0.0,\n    0.0,\n    1.0,\n    1.0,\n    surfaceTile.waterMaskTranslationAndScale\n  );\n}\n\nGlobeSurfaceTile.prototype._findAncestorTileWithTerrainData = function (tile) {\n  let sourceTile = tile.parent;\n\n  while (\n    defined(sourceTile) &&\n    (!defined(sourceTile.data) ||\n      !defined(sourceTile.data.terrainData) ||\n      sourceTile.data.terrainData.wasCreatedByUpsampling())\n  ) {\n    sourceTile = sourceTile.parent;\n  }\n\n  return sourceTile;\n};\n\nGlobeSurfaceTile.prototype._computeWaterMaskTranslationAndScale = function (\n  tile,\n  sourceTile,\n  result\n) {\n  const sourceTileRectangle = sourceTile.rectangle;\n  const tileRectangle = tile.rectangle;\n  const tileWidth = tileRectangle.width;\n  const tileHeight = tileRectangle.height;\n\n  const scaleX = tileWidth / sourceTileRectangle.width;\n  const scaleY = tileHeight / sourceTileRectangle.height;\n  result.x =\n    (scaleX * (tileRectangle.west - sourceTileRectangle.west)) / tileWidth;\n  result.y =\n    (scaleY * (tileRectangle.south - sourceTileRectangle.south)) / tileHeight;\n  result.z = scaleX;\n  result.w = scaleY;\n\n  return result;\n};\nexport default GlobeSurfaceTile;\n","import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport TerrainExaggeration from \"../Core/TerrainExaggeration.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport TerrainFillMesh from \"./TerrainFillMesh.js\";\nimport TerrainState from \"./TerrainState.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Provides quadtree tiles representing the surface of the globe.  This type is intended to be used\n * with {@link QuadtreePrimitive}.\n *\n * @alias GlobeSurfaceTileProvider\n * @constructor\n *\n * @param {TerrainProvider} options.terrainProvider The terrain provider that describes the surface geometry.\n * @param {ImageryLayerCollection} option.imageryLayers The collection of imagery layers describing the shading of the surface.\n * @param {GlobeSurfaceShaderSet} options.surfaceShaderSet The set of shaders used to render the surface.\n *\n * @private\n */\nfunction GlobeSurfaceTileProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.terrainProvider)) {\n    throw new DeveloperError(\"options.terrainProvider is required.\");\n  } else if (!defined(options.imageryLayers)) {\n    throw new DeveloperError(\"options.imageryLayers is required.\");\n  } else if (!defined(options.surfaceShaderSet)) {\n    throw new DeveloperError(\"options.surfaceShaderSet is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this.lightingFadeOutDistance = 6500000.0;\n  this.lightingFadeInDistance = 9000000.0;\n  this.hasWaterMask = false;\n  this.oceanNormalMap = undefined;\n  this.zoomedOutOceanSpecularIntensity = 0.5;\n  this.enableLighting = false;\n  this.dynamicAtmosphereLighting = false;\n  this.dynamicAtmosphereLightingFromSun = false;\n  this.showGroundAtmosphere = false;\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  this.hueShift = 0.0;\n  this.saturationShift = 0.0;\n  this.brightnessShift = 0.0;\n\n  this.showSkirts = true;\n  this.backFaceCulling = true;\n  this.undergroundColor = undefined;\n  this.undergroundColorAlphaByDistance = undefined;\n\n  this.lambertDiffuseMultiplier = 0.0;\n\n  this.materialUniformMap = undefined;\n  this._materialUniformMap = undefined;\n\n  this._quadtree = undefined;\n  this._terrainProvider = options.terrainProvider;\n  this._imageryLayers = options.imageryLayers;\n  this._surfaceShaderSet = options.surfaceShaderSet;\n\n  this._renderState = undefined;\n  this._blendRenderState = undefined;\n  this._disableCullingRenderState = undefined;\n  this._disableCullingBlendRenderState = undefined;\n\n  this._errorEvent = new Event();\n\n  this._imageryLayers.layerAdded.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerAdded,\n    this\n  );\n  this._imageryLayers.layerRemoved.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerRemoved,\n    this\n  );\n  this._imageryLayers.layerMoved.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerMoved,\n    this\n  );\n  this._imageryLayers.layerShownOrHidden.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden,\n    this\n  );\n  this._imageryLayersUpdatedEvent = new Event();\n\n  this._layerOrderChanged = false;\n\n  this._tilesToRenderByTextureCount = [];\n  this._drawCommands = [];\n  this._uniformMaps = [];\n  this._usedDrawCommands = 0;\n\n  this._vertexArraysToDestroy = [];\n\n  this._debug = {\n    wireframe: false,\n    boundingSphereTile: undefined,\n  };\n\n  this._baseColor = undefined;\n  this._firstPassInitialColor = undefined;\n  this.baseColor = new Color(0.0, 0.0, 0.5, 1.0);\n\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * A property specifying a {@link Rectangle} used to selectively limit terrain and imagery rendering.\n   * @type {Rectangle}\n   */\n  this.cartographicLimitRectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n\n  this._oldTerrainExaggeration = undefined;\n  this._oldTerrainExaggerationRelativeHeight = undefined;\n}\n\nObject.defineProperties(GlobeSurfaceTileProvider.prototype, {\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._baseColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._baseColor = value;\n      this._firstPassInitialColor = Cartesian4.fromColor(\n        value,\n        this._firstPassInitialColor\n      );\n    },\n  },\n  /**\n   * Gets or sets the {@link QuadtreePrimitive} for which this provider is\n   * providing tiles.  This property may be undefined if the provider is not yet associated\n   * with a {@link QuadtreePrimitive}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {QuadtreePrimitive}\n   */\n  quadtree: {\n    get: function () {\n      return this._quadtree;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._quadtree = value;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return (\n        this._terrainProvider.ready &&\n        (this._imageryLayers.length === 0 ||\n          this._imageryLayers.get(0).imageryProvider.ready)\n      );\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This property should\n   * not be accessed before {@link GlobeSurfaceTileProvider#ready} returns true.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      return this._terrainProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the geometry provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when an imagery layer is added, shown, hidden, moved, or removed.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._imageryLayersUpdatedEvent;\n    },\n  },\n\n  /**\n   * Gets or sets the terrain provider that describes the surface geometry.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (this._terrainProvider === terrainProvider) {\n        return;\n      }\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(terrainProvider)) {\n        throw new DeveloperError(\"terrainProvider is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._terrainProvider = terrainProvider;\n\n      if (defined(this._quadtree)) {\n        this._quadtree.invalidateAllTiles();\n      }\n    },\n  },\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the tileset.\n   *\n   * @type {ClippingPlaneCollection}\n   *\n   * @private\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n});\n\nfunction sortTileImageryByLayerIndex(a, b) {\n  let aImagery = a.loadingImagery;\n  if (!defined(aImagery)) {\n    aImagery = a.readyImagery;\n  }\n\n  let bImagery = b.loadingImagery;\n  if (!defined(bImagery)) {\n    bImagery = b.readyImagery;\n  }\n\n  return aImagery.imageryLayer._layerIndex - bImagery.imageryLayer._layerIndex;\n}\n\n/**\n * Make updates to the tile provider that are not involved in rendering. Called before the render update cycle.\n */\nGlobeSurfaceTileProvider.prototype.update = function (frameState) {\n  // update collection: imagery indices, base layers, raise layer show/hide event\n  this._imageryLayers._update();\n};\n\nfunction updateCredits(surface, frameState) {\n  const creditDisplay = frameState.creditDisplay;\n  if (\n    surface._terrainProvider.ready &&\n    defined(surface._terrainProvider.credit)\n  ) {\n    creditDisplay.addCredit(surface._terrainProvider.credit);\n  }\n\n  const imageryLayers = surface._imageryLayers;\n  for (let i = 0, len = imageryLayers.length; i < len; ++i) {\n    const imageryProvider = imageryLayers.get(i).imageryProvider;\n    if (imageryProvider.ready && defined(imageryProvider.credit)) {\n      creditDisplay.addCredit(imageryProvider.credit);\n    }\n  }\n}\n\n/**\n * Called at the beginning of each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.initialize = function (frameState) {\n  // update each layer for texture reprojection.\n  this._imageryLayers.queueReprojectionCommands(frameState);\n\n  if (this._layerOrderChanged) {\n    this._layerOrderChanged = false;\n\n    // Sort the TileImagery instances in each tile by the layer index.\n    this._quadtree.forEachLoadedTile(function (tile) {\n      tile.data.imagery.sort(sortTileImageryByLayerIndex);\n    });\n  }\n\n  // Add credits for terrain and imagery providers.\n  updateCredits(this, frameState);\n\n  const vertexArraysToDestroy = this._vertexArraysToDestroy;\n  const length = vertexArraysToDestroy.length;\n  for (let j = 0; j < length; ++j) {\n    GlobeSurfaceTile._freeVertexArray(vertexArraysToDestroy[j]);\n  }\n  vertexArraysToDestroy.length = 0;\n};\n\n/**\n * Called at the beginning of the update cycle for each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * or any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.beginUpdate = function (frameState) {\n  const tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (let i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {\n    const tiles = tilesToRenderByTextureCount[i];\n    if (defined(tiles)) {\n      tiles.length = 0;\n    }\n  }\n  // update clipping planes\n  const clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    clippingPlanes.update(frameState);\n  }\n  this._usedDrawCommands = 0;\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n};\n\n/**\n * Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}\n * and any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.endUpdate = function (frameState) {\n  if (!defined(this._renderState)) {\n    this._renderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS,\n      },\n    });\n\n    this._blendRenderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS_OR_EQUAL,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n    });\n\n    let rs = clone(this._renderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingRenderState = RenderState.fromCache(rs);\n\n    rs = clone(this._blendRenderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingBlendRenderState = RenderState.fromCache(rs);\n  }\n\n  // If this frame has a mix of loaded and fill tiles, we need to propagate\n  // loaded heights to the fill tiles.\n  if (this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame) {\n    TerrainFillMesh.updateFillTiles(\n      this,\n      this._quadtree._tilesToRender,\n      frameState,\n      this._vertexArraysToDestroy\n    );\n  }\n\n  // When terrain exaggeration changes, all of the loaded tiles need to generate\n  // geodetic surface normals so they can scale properly when rendered.\n  // When exaggeration is reset, geodetic surface normals are removed to decrease\n  // memory usage. Some tiles might have been constructed with the correct\n  // exaggeration already, so skip over them.\n\n  // If the geodetic surface normals can't be created because the tile doesn't\n  // have a mesh, keep checking until the tile does have a mesh. This can happen\n  // if the tile's mesh starts construction in a worker thread right before the\n  // exaggeration changes.\n\n  const quadtree = this.quadtree;\n  const exaggeration = frameState.terrainExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.terrainExaggerationRelativeHeight;\n  const exaggerationChanged =\n    this._oldTerrainExaggeration !== exaggeration ||\n    this._oldTerrainExaggerationRelativeHeight !== exaggerationRelativeHeight;\n\n  // Keep track of the next time there is a change in exaggeration\n  this._oldTerrainExaggeration = exaggeration;\n  this._oldTerrainExaggerationRelativeHeight = exaggerationRelativeHeight;\n\n  if (exaggerationChanged) {\n    quadtree.forEachLoadedTile(function (tile) {\n      const surfaceTile = tile.data;\n      surfaceTile.updateExaggeration(tile, frameState, quadtree);\n    });\n  }\n\n  // Add the tile render commands to the command list, sorted by texture count.\n  const tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (\n    let textureCountIndex = 0,\n      textureCountLength = tilesToRenderByTextureCount.length;\n    textureCountIndex < textureCountLength;\n    ++textureCountIndex\n  ) {\n    const tilesToRender = tilesToRenderByTextureCount[textureCountIndex];\n    if (!defined(tilesToRender)) {\n      continue;\n    }\n\n    for (\n      let tileIndex = 0, tileLength = tilesToRender.length;\n      tileIndex < tileLength;\n      ++tileIndex\n    ) {\n      const tile = tilesToRender[tileIndex];\n      const tileBoundingRegion = tile.data.tileBoundingRegion;\n      addDrawCommandsForTile(this, tile, frameState);\n      frameState.minimumTerrainHeight = Math.min(\n        frameState.minimumTerrainHeight,\n        tileBoundingRegion.minimumHeight\n      );\n    }\n  }\n};\n\nfunction pushCommand(command, frameState) {\n  const globeTranslucencyState = frameState.globeTranslucencyState;\n  if (globeTranslucencyState.translucent) {\n    const isBlendCommand = command.renderState.blending.enabled;\n    globeTranslucencyState.pushDerivedCommands(\n      command,\n      isBlendCommand,\n      frameState\n    );\n  } else {\n    frameState.commandList.push(command);\n  }\n}\n\n/**\n * Adds draw commands for tiles rendered in the previous frame for a pick pass.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.updateForPick = function (frameState) {\n  // Add the tile pick commands from the tiles drawn last frame.\n  const drawCommands = this._drawCommands;\n  for (let i = 0, length = this._usedDrawCommands; i < length; ++i) {\n    pushCommand(drawCommands[i], frameState);\n  }\n};\n\n/**\n * Cancels any imagery re-projections in the queue.\n */\nGlobeSurfaceTileProvider.prototype.cancelReprojections = function () {\n  this._imageryLayers.cancelReprojections();\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level, in meters.  This function should not be\n * called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error in meters.\n */\nGlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._terrainProvider.getLevelMaximumGeometricError(level);\n};\n\n/**\n * Loads, or continues loading, a given tile.  This function will continue to be called\n * until {@link QuadtreeTile#state} is no longer {@link QuadtreeTileLoadState#LOADING}.  This function should\n * not be called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to load.\n *\n * @exception {DeveloperError} <code>loadTile</code> must not be called before the tile provider is ready.\n */\nGlobeSurfaceTileProvider.prototype.loadTile = function (frameState, tile) {\n  // We don't want to load imagery until we're certain that the terrain tiles are actually visible.\n  // So if our bounding volume isn't accurate because it came from another tile, load terrain only\n  // initially. If we load some terrain and suddenly have a more accurate bounding volume and the\n  // tile is _still_ visible, give the tile a chance to load imagery immediately rather than\n  // waiting for next frame.\n\n  let surfaceTile = tile.data;\n  let terrainOnly = true;\n  let terrainStateBefore;\n  if (defined(surfaceTile)) {\n    terrainOnly =\n      surfaceTile.boundingVolumeSourceTile !== tile ||\n      tile._lastSelectionResult === TileSelectionResult.CULLED_BUT_NEEDED;\n    terrainStateBefore = surfaceTile.terrainState;\n  }\n\n  GlobeSurfaceTile.processStateMachine(\n    tile,\n    frameState,\n    this.terrainProvider,\n    this._imageryLayers,\n    this.quadtree,\n    this._vertexArraysToDestroy,\n    terrainOnly\n  );\n\n  surfaceTile = tile.data;\n  if (terrainOnly && terrainStateBefore !== tile.data.terrainState) {\n    // Terrain state changed. If:\n    // a) The tile is visible, and\n    // b) The bounding volume is accurate (updated as a side effect of computing visibility)\n    // Then we'll load imagery, too.\n    if (\n      this.computeTileVisibility(tile, frameState, this.quadtree.occluders) !==\n        Visibility.NONE &&\n      surfaceTile.boundingVolumeSourceTile === tile\n    ) {\n      terrainOnly = false;\n      GlobeSurfaceTile.processStateMachine(\n        tile,\n        frameState,\n        this.terrainProvider,\n        this._imageryLayers,\n        this.quadtree,\n        this._vertexArraysToDestroy,\n        terrainOnly\n      );\n    }\n  }\n};\n\nconst boundingSphereScratch = new BoundingSphere();\nconst rectangleIntersectionScratch = new Rectangle();\nconst splitCartographicLimitRectangleScratch = new Rectangle();\nconst rectangleCenterScratch = new Cartographic();\n\n// cartographicLimitRectangle may span the IDL, but tiles never will.\nfunction clipRectangleAntimeridian(tileRectangle, cartographicLimitRectangle) {\n  if (cartographicLimitRectangle.west < cartographicLimitRectangle.east) {\n    return cartographicLimitRectangle;\n  }\n  const splitRectangle = Rectangle.clone(\n    cartographicLimitRectangle,\n    splitCartographicLimitRectangleScratch\n  );\n  const tileCenter = Rectangle.center(tileRectangle, rectangleCenterScratch);\n  if (tileCenter.longitude > 0.0) {\n    splitRectangle.east = CesiumMath.PI;\n  } else {\n    splitRectangle.west = -CesiumMath.PI;\n  }\n  return splitRectangle;\n}\n\nfunction isUndergroundVisible(tileProvider, frameState) {\n  if (frameState.cameraUnderground) {\n    return true;\n  }\n\n  if (frameState.globeTranslucencyState.translucent) {\n    return true;\n  }\n\n  if (tileProvider.backFaceCulling) {\n    return false;\n  }\n\n  const clippingPlanes = tileProvider._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    return true;\n  }\n\n  if (\n    !Rectangle.equals(\n      tileProvider.cartographicLimitRectangle,\n      Rectangle.MAX_VALUE\n    )\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Determines the visibility of a given tile.  The tile may be fully visible, partially visible, or not\n * visible at all.  Tiles that are renderable and are at least partially visible will be shown by a call\n * to {@link GlobeSurfaceTileProvider#showTileThisFrame}.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information about the current frame.\n * @param {QuadtreeOccluders} occluders The objects that may occlude this tile.\n *\n * @returns {Visibility} Visibility.NONE if the tile is not visible,\n *                       Visibility.PARTIAL if the tile is partially visible, or\n *                       Visibility.FULL if the tile is fully visible.\n */\nGlobeSurfaceTileProvider.prototype.computeTileVisibility = function (\n  tile,\n  frameState,\n  occluders\n) {\n  const distance = this.computeDistanceToTile(tile, frameState);\n  tile._distance = distance;\n\n  const undergroundVisible = isUndergroundVisible(this, frameState);\n\n  if (frameState.fog.enabled && !undergroundVisible) {\n    if (CesiumMath.fog(distance, frameState.fog.density) >= 1.0) {\n      // Tile is completely in fog so return that it is not visible.\n      return Visibility.NONE;\n    }\n  }\n\n  const surfaceTile = tile.data;\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (surfaceTile.boundingVolumeSourceTile === undefined) {\n    // We have no idea where this tile is, so let's just call it partially visible.\n    return Visibility.PARTIAL;\n  }\n\n  const cullingVolume = frameState.cullingVolume;\n  let boundingVolume = tileBoundingRegion.boundingVolume;\n\n  if (!defined(boundingVolume)) {\n    boundingVolume = tileBoundingRegion.boundingSphere;\n  }\n\n  // Check if the tile is outside the limit area in cartographic space\n  surfaceTile.clippedByBoundaries = false;\n  const clippedCartographicLimitRectangle = clipRectangleAntimeridian(\n    tile.rectangle,\n    this.cartographicLimitRectangle\n  );\n  const areaLimitIntersection = Rectangle.simpleIntersection(\n    clippedCartographicLimitRectangle,\n    tile.rectangle,\n    rectangleIntersectionScratch\n  );\n  if (!defined(areaLimitIntersection)) {\n    return Visibility.NONE;\n  }\n  if (!Rectangle.equals(areaLimitIntersection, tile.rectangle)) {\n    surfaceTile.clippedByBoundaries = true;\n  }\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    boundingVolume = boundingSphereScratch;\n    BoundingSphere.fromRectangleWithHeights2D(\n      tile.rectangle,\n      frameState.mapProjection,\n      tileBoundingRegion.minimumHeight,\n      tileBoundingRegion.maximumHeight,\n      boundingVolume\n    );\n    Cartesian3.fromElements(\n      boundingVolume.center.z,\n      boundingVolume.center.x,\n      boundingVolume.center.y,\n      boundingVolume.center\n    );\n\n    if (\n      frameState.mode === SceneMode.MORPHING &&\n      defined(surfaceTile.renderedMesh)\n    ) {\n      boundingVolume = BoundingSphere.union(\n        tileBoundingRegion.boundingSphere,\n        boundingVolume,\n        boundingVolume\n      );\n    }\n  }\n\n  if (!defined(boundingVolume)) {\n    return Visibility.PARTIAL;\n  }\n\n  const clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    const planeIntersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n      boundingVolume\n    );\n    tile.isClipped = planeIntersection !== Intersect.INSIDE;\n    if (planeIntersection === Intersect.OUTSIDE) {\n      return Visibility.NONE;\n    }\n  }\n\n  let visibility;\n  const intersection = cullingVolume.computeVisibility(boundingVolume);\n\n  if (intersection === Intersect.OUTSIDE) {\n    visibility = Visibility.NONE;\n  } else if (intersection === Intersect.INTERSECTING) {\n    visibility = Visibility.PARTIAL;\n  } else if (intersection === Intersect.INSIDE) {\n    visibility = Visibility.FULL;\n  }\n\n  if (visibility === Visibility.NONE) {\n    return visibility;\n  }\n\n  const ortho3D =\n    frameState.mode === SceneMode.SCENE3D &&\n    frameState.camera.frustum instanceof OrthographicFrustum;\n  if (\n    frameState.mode === SceneMode.SCENE3D &&\n    !ortho3D &&\n    defined(occluders) &&\n    !undergroundVisible\n  ) {\n    const occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;\n    if (!defined(occludeePointInScaledSpace)) {\n      return visibility;\n    }\n\n    if (\n      occluders.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(\n        occludeePointInScaledSpace,\n        tileBoundingRegion.minimumHeight\n      )\n    ) {\n      return visibility;\n    }\n\n    return Visibility.NONE;\n  }\n\n  return visibility;\n};\n\n/**\n * Determines if the given tile can be refined\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be refined, false if it cannot.\n */\nGlobeSurfaceTileProvider.prototype.canRefine = function (tile) {\n  // Only allow refinement it we know whether or not the children of this tile exist.\n  // For a tileset with `availability`, we'll always be able to refine.\n  // We can ask for availability of _any_ child tile because we only need to confirm\n  // that we get a yes or no answer, it doesn't matter what the answer is.\n  if (defined(tile.data.terrainData)) {\n    return true;\n  }\n  const childAvailable = this.terrainProvider.getTileDataAvailable(\n    tile.x * 2,\n    tile.y * 2,\n    tile.level + 1\n  );\n  return childAvailable !== undefined;\n};\n\nconst readyImageryScratch = [];\nconst canRenderTraversalStack = [];\n\n/**\n * Determines if the given not-fully-loaded tile can be rendered without losing detail that\n * was present last frame as a result of rendering descendant tiles. This method will only be\n * called if this tile's descendants were rendered last frame. If the tile is fully loaded,\n * it is assumed that this method will return true and it will not be called.\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be rendered without losing detail.\n */\nGlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail = function (\n  tile,\n  frameState\n) {\n  const surfaceTile = tile.data;\n\n  const readyImagery = readyImageryScratch;\n  readyImagery.length = this._imageryLayers.length;\n\n  let terrainReady = false;\n  let initialImageryState = false;\n  let imagery;\n\n  if (defined(surfaceTile)) {\n    // We can render even with non-ready terrain as long as all our rendered descendants\n    // are missing terrain geometry too. i.e. if we rendered fills for more detailed tiles\n    // last frame, it's ok to render a fill for this tile this frame.\n    terrainReady = surfaceTile.terrainState === TerrainState.READY;\n\n    // Initially assume all imagery layers are ready, unless imagery hasn't been initialized at all.\n    initialImageryState = true;\n\n    imagery = surfaceTile.imagery;\n  }\n\n  let i;\n  let len;\n\n  for (i = 0, len = readyImagery.length; i < len; ++i) {\n    readyImagery[i] = initialImageryState;\n  }\n\n  if (defined(imagery)) {\n    for (i = 0, len = imagery.length; i < len; ++i) {\n      const tileImagery = imagery[i];\n      const loadingImagery = tileImagery.loadingImagery;\n      const isReady =\n        !defined(loadingImagery) ||\n        loadingImagery.state === ImageryState.FAILED ||\n        loadingImagery.state === ImageryState.INVALID;\n      const layerIndex = (\n        tileImagery.loadingImagery || tileImagery.readyImagery\n      ).imageryLayer._layerIndex;\n\n      // For a layer to be ready, all tiles belonging to that layer must be ready.\n      readyImagery[layerIndex] = isReady && readyImagery[layerIndex];\n    }\n  }\n\n  const lastFrame = this.quadtree._lastSelectionFrameNumber;\n\n  // Traverse the descendants looking for one with terrain or imagery that is not loaded on this tile.\n  const stack = canRenderTraversalStack;\n  stack.length = 0;\n  stack.push(\n    tile.southwestChild,\n    tile.southeastChild,\n    tile.northwestChild,\n    tile.northeastChild\n  );\n\n  while (stack.length > 0) {\n    const descendant = stack.pop();\n    const lastFrameSelectionResult =\n      descendant._lastSelectionResultFrame === lastFrame\n        ? descendant._lastSelectionResult\n        : TileSelectionResult.NONE;\n\n    if (lastFrameSelectionResult === TileSelectionResult.RENDERED) {\n      const descendantSurface = descendant.data;\n\n      if (!defined(descendantSurface)) {\n        // Descendant has no data, so it can't block rendering.\n        continue;\n      }\n\n      if (\n        !terrainReady &&\n        descendant.data.terrainState === TerrainState.READY\n      ) {\n        // Rendered descendant has real terrain, but we don't. Rendering is blocked.\n        return false;\n      }\n\n      const descendantImagery = descendant.data.imagery;\n      for (i = 0, len = descendantImagery.length; i < len; ++i) {\n        const descendantTileImagery = descendantImagery[i];\n        const descendantLoadingImagery = descendantTileImagery.loadingImagery;\n        const descendantIsReady =\n          !defined(descendantLoadingImagery) ||\n          descendantLoadingImagery.state === ImageryState.FAILED ||\n          descendantLoadingImagery.state === ImageryState.INVALID;\n        const descendantLayerIndex = (\n          descendantTileImagery.loadingImagery ||\n          descendantTileImagery.readyImagery\n        ).imageryLayer._layerIndex;\n\n        // If this imagery tile of a descendant is ready but the layer isn't ready in this tile,\n        // then rendering is blocked.\n        if (descendantIsReady && !readyImagery[descendantLayerIndex]) {\n          return false;\n        }\n      }\n    } else if (lastFrameSelectionResult === TileSelectionResult.REFINED) {\n      stack.push(\n        descendant.southwestChild,\n        descendant.southeastChild,\n        descendant.northwestChild,\n        descendant.northeastChild\n      );\n    }\n  }\n\n  return true;\n};\n\nconst tileDirectionScratch = new Cartesian3();\n\n/**\n * Determines the priority for loading this tile. Lower priority values load sooner.\n * @param {QuadtreeTile} tile The tile.\n * @param {FrameState} frameState The frame state.\n * @returns {Number} The load priority value.\n */\nGlobeSurfaceTileProvider.prototype.computeTileLoadPriority = function (\n  tile,\n  frameState\n) {\n  const surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    return 0.0;\n  }\n\n  const obb = surfaceTile.tileBoundingRegion.boundingVolume;\n  if (obb === undefined) {\n    return 0.0;\n  }\n\n  const cameraPosition = frameState.camera.positionWC;\n  const cameraDirection = frameState.camera.directionWC;\n  const tileDirection = Cartesian3.subtract(\n    obb.center,\n    cameraPosition,\n    tileDirectionScratch\n  );\n  const magnitude = Cartesian3.magnitude(tileDirection);\n  if (magnitude < CesiumMath.EPSILON5) {\n    return 0.0;\n  }\n  Cartesian3.divideByScalar(tileDirection, magnitude, tileDirection);\n  return (\n    (1.0 - Cartesian3.dot(tileDirection, cameraDirection)) * tile._distance\n  );\n};\n\nconst modifiedModelViewScratch = new Matrix4();\nconst modifiedModelViewProjectionScratch = new Matrix4();\nconst tileRectangleScratch = new Cartesian4();\nconst localizedCartographicLimitRectangleScratch = new Cartesian4();\nconst localizedTranslucencyRectangleScratch = new Cartesian4();\nconst rtcScratch = new Cartesian3();\nconst centerEyeScratch = new Cartesian3();\nconst southwestScratch = new Cartesian3();\nconst northeastScratch = new Cartesian3();\n\n/**\n * Shows a specified tile in this frame.  The provider can cause the tile to be shown by adding\n * render commands to the commandList, or use any other method as appropriate.  The tile is not\n * expected to be visible next frame as well, unless this method is called next frame, too.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n */\nGlobeSurfaceTileProvider.prototype.showTileThisFrame = function (\n  tile,\n  frameState\n) {\n  let readyTextureCount = 0;\n  const tileImageryCollection = tile.data.imagery;\n  for (let i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    const tileImagery = tileImageryCollection[i];\n    if (\n      defined(tileImagery.readyImagery) &&\n      tileImagery.readyImagery.imageryLayer.alpha !== 0.0\n    ) {\n      ++readyTextureCount;\n    }\n  }\n\n  let tileSet = this._tilesToRenderByTextureCount[readyTextureCount];\n  if (!defined(tileSet)) {\n    tileSet = [];\n    this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;\n  }\n\n  tileSet.push(tile);\n\n  const surfaceTile = tile.data;\n  if (!defined(surfaceTile.vertexArray)) {\n    this._hasFillTilesThisFrame = true;\n  } else {\n    this._hasLoadedTilesThisFrame = true;\n  }\n\n  const debug = this._debug;\n  ++debug.tilesRendered;\n  debug.texturesRendered += readyTextureCount;\n};\n\nconst cornerPositionsScratch = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeOccludeePoint(\n  tileProvider,\n  center,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  result\n) {\n  const ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  const ellipsoid = ellipsoidalOccluder.ellipsoid;\n\n  const cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[0]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[1]\n  );\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[2]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[3]\n  );\n\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    center,\n    cornerPositions,\n    minimumHeight,\n    result\n  );\n}\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n *\n * @returns {Number} The distance from the camera to the closest point on the tile, in meters.\n */\nGlobeSurfaceTileProvider.prototype.computeDistanceToTile = function (\n  tile,\n  frameState\n) {\n  // The distance should be:\n  // 1. the actual distance to the tight-fitting bounding volume, or\n  // 2. a distance that is equal to or greater than the actual distance to the tight-fitting bounding volume.\n  //\n  // When we don't know the min/max heights for a tile, but we do know the min/max of an ancestor tile, we can\n  // build a tight-fitting bounding volume horizontally, but not vertically. The min/max heights from the\n  // ancestor will likely form a volume that is much bigger than it needs to be. This means that the volume may\n  // be deemed to be much closer to the camera than it really is, causing us to select tiles that are too detailed.\n  // Loading too-detailed tiles is super expensive, so we don't want to do that. We don't know where the child\n  // tile really lies within the parent range of heights, but we _do_ know the child tile can't be any closer than\n  // the ancestor height surface (min or max) that is _farthest away_ from the camera. So if we compute distance\n  // based on that conservative metric, we may end up loading tiles that are not detailed enough, but that's much\n  // better (faster) than loading tiles that are too detailed.\n\n  updateTileBoundingRegion(tile, this, frameState);\n\n  const surfaceTile = tile.data;\n  const boundingVolumeSourceTile = surfaceTile.boundingVolumeSourceTile;\n  if (boundingVolumeSourceTile === undefined) {\n    // Can't find any min/max heights anywhere? Ok, let's just say the\n    // tile is really far away so we'll load and render it rather than\n    // refining.\n    return 9999999999.0;\n  }\n\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  const min = tileBoundingRegion.minimumHeight;\n  const max = tileBoundingRegion.maximumHeight;\n\n  if (surfaceTile.boundingVolumeSourceTile !== tile) {\n    const cameraHeight = frameState.camera.positionCartographic.height;\n    const distanceToMin = Math.abs(cameraHeight - min);\n    const distanceToMax = Math.abs(cameraHeight - max);\n    if (distanceToMin > distanceToMax) {\n      tileBoundingRegion.minimumHeight = min;\n      tileBoundingRegion.maximumHeight = min;\n    } else {\n      tileBoundingRegion.minimumHeight = max;\n      tileBoundingRegion.maximumHeight = max;\n    }\n  }\n\n  const result = tileBoundingRegion.distanceToCamera(frameState);\n\n  tileBoundingRegion.minimumHeight = min;\n  tileBoundingRegion.maximumHeight = max;\n\n  return result;\n};\n\nfunction updateTileBoundingRegion(tile, tileProvider, frameState) {\n  let surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  const ellipsoid = tile.tilingScheme.ellipsoid;\n  if (surfaceTile.tileBoundingRegion === undefined) {\n    surfaceTile.tileBoundingRegion = new TileBoundingRegion({\n      computeBoundingVolumes: false,\n      rectangle: tile.rectangle,\n      ellipsoid: ellipsoid,\n      minimumHeight: 0.0,\n      maximumHeight: 0.0,\n    });\n  }\n\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n  const oldMinimumHeight = tileBoundingRegion.minimumHeight;\n  const oldMaximumHeight = tileBoundingRegion.maximumHeight;\n  let hasBoundingVolumesFromMesh = false;\n  let sourceTile = tile;\n\n  // Get min and max heights from the mesh.\n  // If the mesh is not available, get them from the terrain data.\n  // If the terrain data is not available either, get them from an ancestor.\n  // If none of the ancestors are available, then there are no min and max heights for this tile at this time.\n  const mesh = surfaceTile.mesh;\n  const terrainData = surfaceTile.terrainData;\n  if (\n    mesh !== undefined &&\n    mesh.minimumHeight !== undefined &&\n    mesh.maximumHeight !== undefined\n  ) {\n    tileBoundingRegion.minimumHeight = mesh.minimumHeight;\n    tileBoundingRegion.maximumHeight = mesh.maximumHeight;\n    hasBoundingVolumesFromMesh = true;\n  } else if (\n    terrainData !== undefined &&\n    terrainData._minimumHeight !== undefined &&\n    terrainData._maximumHeight !== undefined\n  ) {\n    tileBoundingRegion.minimumHeight = terrainData._minimumHeight;\n    tileBoundingRegion.maximumHeight = terrainData._maximumHeight;\n  } else {\n    // No accurate min/max heights available, so we're stuck with min/max heights from an ancestor tile.\n    tileBoundingRegion.minimumHeight = Number.NaN;\n    tileBoundingRegion.maximumHeight = Number.NaN;\n\n    let ancestorTile = tile.parent;\n    while (ancestorTile !== undefined) {\n      const ancestorSurfaceTile = ancestorTile.data;\n      if (ancestorSurfaceTile !== undefined) {\n        const ancestorMesh = ancestorSurfaceTile.mesh;\n        const ancestorTerrainData = ancestorSurfaceTile.terrainData;\n        if (\n          ancestorMesh !== undefined &&\n          ancestorMesh.minimumHeight !== undefined &&\n          ancestorMesh.maximumHeight !== undefined\n        ) {\n          tileBoundingRegion.minimumHeight = ancestorMesh.minimumHeight;\n          tileBoundingRegion.maximumHeight = ancestorMesh.maximumHeight;\n          break;\n        } else if (\n          ancestorTerrainData !== undefined &&\n          ancestorTerrainData._minimumHeight !== undefined &&\n          ancestorTerrainData._maximumHeight !== undefined\n        ) {\n          tileBoundingRegion.minimumHeight = ancestorTerrainData._minimumHeight;\n          tileBoundingRegion.maximumHeight = ancestorTerrainData._maximumHeight;\n          break;\n        }\n      }\n      ancestorTile = ancestorTile.parent;\n    }\n    sourceTile = ancestorTile;\n  }\n\n  // Update bounding regions from the min and max heights\n  if (sourceTile !== undefined) {\n    const exaggeration = frameState.terrainExaggeration;\n    const exaggerationRelativeHeight =\n      frameState.terrainExaggerationRelativeHeight;\n    const hasExaggeration = exaggeration !== 1.0;\n    if (hasExaggeration) {\n      hasBoundingVolumesFromMesh = false;\n      tileBoundingRegion.minimumHeight = TerrainExaggeration.getHeight(\n        tileBoundingRegion.minimumHeight,\n        exaggeration,\n        exaggerationRelativeHeight\n      );\n      tileBoundingRegion.maximumHeight = TerrainExaggeration.getHeight(\n        tileBoundingRegion.maximumHeight,\n        exaggeration,\n        exaggerationRelativeHeight\n      );\n    }\n\n    if (hasBoundingVolumesFromMesh) {\n      if (!surfaceTile.boundingVolumeIsFromMesh) {\n        tileBoundingRegion._orientedBoundingBox = OrientedBoundingBox.clone(\n          mesh.orientedBoundingBox,\n          tileBoundingRegion._orientedBoundingBox\n        );\n        tileBoundingRegion._boundingSphere = BoundingSphere.clone(\n          mesh.boundingSphere3D,\n          tileBoundingRegion._boundingSphere\n        );\n        surfaceTile.occludeePointInScaledSpace = Cartesian3.clone(\n          mesh.occludeePointInScaledSpace,\n          surfaceTile.occludeePointInScaledSpace\n        );\n\n        // If the occludee point is not defined, fallback to calculating it from the OBB\n        if (!defined(surfaceTile.occludeePointInScaledSpace)) {\n          surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(\n            tileProvider,\n            tileBoundingRegion._orientedBoundingBox.center,\n            tile.rectangle,\n            tileBoundingRegion.minimumHeight,\n            tileBoundingRegion.maximumHeight,\n            surfaceTile.occludeePointInScaledSpace\n          );\n        }\n      }\n    } else {\n      const needsBounds =\n        tileBoundingRegion._orientedBoundingBox === undefined ||\n        tileBoundingRegion._boundingSphere === undefined;\n      const heightChanged =\n        tileBoundingRegion.minimumHeight !== oldMinimumHeight ||\n        tileBoundingRegion.maximumHeight !== oldMaximumHeight;\n      if (heightChanged || needsBounds) {\n        // Bounding volumes need to be recomputed in some circumstances\n        tileBoundingRegion.computeBoundingVolumes(ellipsoid);\n        surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(\n          tileProvider,\n          tileBoundingRegion._orientedBoundingBox.center,\n          tile.rectangle,\n          tileBoundingRegion.minimumHeight,\n          tileBoundingRegion.maximumHeight,\n          surfaceTile.occludeePointInScaledSpace\n        );\n      }\n    }\n    surfaceTile.boundingVolumeSourceTile = sourceTile;\n    surfaceTile.boundingVolumeIsFromMesh = hasBoundingVolumesFromMesh;\n  } else {\n    surfaceTile.boundingVolumeSourceTile = undefined;\n    surfaceTile.boundingVolumeIsFromMesh = false;\n  }\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see GlobeSurfaceTileProvider#destroy\n */\nGlobeSurfaceTileProvider.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * provider = provider && provider();\n *\n * @see GlobeSurfaceTileProvider#isDestroyed\n */\nGlobeSurfaceTileProvider.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n\n  return destroyObject(this);\n};\n\nfunction getTileReadyCallback(tileImageriesToFree, layer, terrainProvider) {\n  return function (tile) {\n    let tileImagery;\n    let imagery;\n    let startIndex = -1;\n    const tileImageryCollection = tile.data.imagery;\n    const length = tileImageryCollection.length;\n    let i;\n    for (i = 0; i < length; ++i) {\n      tileImagery = tileImageryCollection[i];\n      imagery = defaultValue(\n        tileImagery.readyImagery,\n        tileImagery.loadingImagery\n      );\n      if (imagery.imageryLayer === layer) {\n        startIndex = i;\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      const endIndex = startIndex + tileImageriesToFree;\n      tileImagery = tileImageryCollection[endIndex];\n      imagery = defined(tileImagery)\n        ? defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery)\n        : undefined;\n      if (!defined(imagery) || imagery.imageryLayer !== layer) {\n        // Return false to keep the callback if we have to wait on the skeletons\n        // Return true to remove the callback if something went wrong\n        return !layer._createTileImagerySkeletons(\n          tile,\n          terrainProvider,\n          endIndex\n        );\n      }\n\n      for (i = startIndex; i < endIndex; ++i) {\n        tileImageryCollection[i].freeResources();\n      }\n\n      tileImageryCollection.splice(startIndex, tileImageriesToFree);\n    }\n\n    return true; // Everything is done, so remove the callback\n  };\n}\n\nGlobeSurfaceTileProvider.prototype._onLayerAdded = function (layer, index) {\n  if (layer.show) {\n    const terrainProvider = this._terrainProvider;\n\n    const that = this;\n    const imageryProvider = layer.imageryProvider;\n    const tileImageryUpdatedEvent = this._imageryLayersUpdatedEvent;\n    imageryProvider._reload = function () {\n      // Clear the layer's cache\n      layer._imageryCache = {};\n\n      that._quadtree.forEachLoadedTile(function (tile) {\n        // If this layer is still waiting to for the loaded callback, just return\n        if (defined(tile._loadedCallbacks[layer._layerIndex])) {\n          return;\n        }\n\n        let i;\n\n        // Figure out how many TileImageries we will need to remove and where to insert new ones\n        const tileImageryCollection = tile.data.imagery;\n        const length = tileImageryCollection.length;\n        let startIndex = -1;\n        let tileImageriesToFree = 0;\n        for (i = 0; i < length; ++i) {\n          const tileImagery = tileImageryCollection[i];\n          const imagery = defaultValue(\n            tileImagery.readyImagery,\n            tileImagery.loadingImagery\n          );\n          if (imagery.imageryLayer === layer) {\n            if (startIndex === -1) {\n              startIndex = i;\n            }\n\n            ++tileImageriesToFree;\n          } else if (startIndex !== -1) {\n            // iterated past the section of TileImageries belonging to this layer, no need to continue.\n            break;\n          }\n        }\n\n        if (startIndex === -1) {\n          return;\n        }\n\n        // Insert immediately after existing TileImageries\n        const insertionPoint = startIndex + tileImageriesToFree;\n\n        // Create new TileImageries for all loaded tiles\n        if (\n          layer._createTileImagerySkeletons(\n            tile,\n            terrainProvider,\n            insertionPoint\n          )\n        ) {\n          // Add callback to remove old TileImageries when the new TileImageries are ready\n          tile._loadedCallbacks[layer._layerIndex] = getTileReadyCallback(\n            tileImageriesToFree,\n            layer,\n            terrainProvider\n          );\n\n          tile.state = QuadtreeTileLoadState.LOADING;\n        }\n      });\n    };\n\n    // create TileImageries for this layer for all previously loaded tiles\n    this._quadtree.forEachLoadedTile(function (tile) {\n      if (layer._createTileImagerySkeletons(tile, terrainProvider)) {\n        tile.state = QuadtreeTileLoadState.LOADING;\n\n        // Tiles that are not currently being rendered need to load the new layer before they're renderable.\n        // We don't mark the rendered tiles non-renderable, though, because that would make the globe disappear.\n        if (\n          tile.level !== 0 &&\n          (tile._lastSelectionResultFrame !==\n            that.quadtree._lastSelectionFrameNumber ||\n            tile._lastSelectionResult !== TileSelectionResult.RENDERED)\n        ) {\n          tile.renderable = false;\n        }\n      }\n    });\n\n    this._layerOrderChanged = true;\n    tileImageryUpdatedEvent.raiseEvent();\n  }\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerRemoved = function (layer, index) {\n  // destroy TileImagerys for this layer for all previously loaded tiles\n  this._quadtree.forEachLoadedTile(function (tile) {\n    const tileImageryCollection = tile.data.imagery;\n\n    let startIndex = -1;\n    let numDestroyed = 0;\n    for (let i = 0, len = tileImageryCollection.length; i < len; ++i) {\n      const tileImagery = tileImageryCollection[i];\n      let imagery = tileImagery.loadingImagery;\n      if (!defined(imagery)) {\n        imagery = tileImagery.readyImagery;\n      }\n      if (imagery.imageryLayer === layer) {\n        if (startIndex === -1) {\n          startIndex = i;\n        }\n\n        tileImagery.freeResources();\n        ++numDestroyed;\n      } else if (startIndex !== -1) {\n        // iterated past the section of TileImagerys belonging to this layer, no need to continue.\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      tileImageryCollection.splice(startIndex, numDestroyed);\n    }\n  });\n\n  if (defined(layer.imageryProvider)) {\n    layer.imageryProvider._reload = undefined;\n  }\n\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerMoved = function (\n  layer,\n  newIndex,\n  oldIndex\n) {\n  this._layerOrderChanged = true;\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerShownOrHidden = function (\n  layer,\n  index,\n  show\n) {\n  if (show) {\n    this._onLayerAdded(layer, index);\n  } else {\n    this._onLayerRemoved(layer, index);\n  }\n};\n\nconst scratchClippingPlanesMatrix = new Matrix4();\nconst scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\nfunction createTileUniformMap(frameState, globeSurfaceTileProvider) {\n  const uniformMap = {\n    u_initialColor: function () {\n      return this.properties.initialColor;\n    },\n    u_fillHighlightColor: function () {\n      return this.properties.fillHighlightColor;\n    },\n    u_zoomedOutOceanSpecularIntensity: function () {\n      return this.properties.zoomedOutOceanSpecularIntensity;\n    },\n    u_oceanNormalMap: function () {\n      return this.properties.oceanNormalMap;\n    },\n    u_atmosphereLightIntensity: function () {\n      return this.properties.atmosphereLightIntensity;\n    },\n    u_atmosphereRayleighCoefficient: function () {\n      return this.properties.atmosphereRayleighCoefficient;\n    },\n    u_atmosphereMieCoefficient: function () {\n      return this.properties.atmosphereMieCoefficient;\n    },\n    u_atmosphereRayleighScaleHeight: function () {\n      return this.properties.atmosphereRayleighScaleHeight;\n    },\n    u_atmosphereMieScaleHeight: function () {\n      return this.properties.atmosphereMieScaleHeight;\n    },\n    u_atmosphereMieAnisotropy: function () {\n      return this.properties.atmosphereMieAnisotropy;\n    },\n    u_lightingFadeDistance: function () {\n      return this.properties.lightingFadeDistance;\n    },\n    u_nightFadeDistance: function () {\n      return this.properties.nightFadeDistance;\n    },\n    u_center3D: function () {\n      return this.properties.center3D;\n    },\n    u_terrainExaggerationAndRelativeHeight: function () {\n      return this.properties.terrainExaggerationAndRelativeHeight;\n    },\n    u_tileRectangle: function () {\n      return this.properties.tileRectangle;\n    },\n    u_modifiedModelView: function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      const centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch\n      );\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_modifiedModelViewProjection: function () {\n      const viewMatrix = frameState.context.uniformState.view;\n      const projectionMatrix = frameState.context.uniformState.projection;\n      const centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch\n      );\n      Matrix4.setTranslation(\n        viewMatrix,\n        centerEye,\n        modifiedModelViewProjectionScratch\n      );\n      Matrix4.multiply(\n        projectionMatrix,\n        modifiedModelViewProjectionScratch,\n        modifiedModelViewProjectionScratch\n      );\n      return modifiedModelViewProjectionScratch;\n    },\n    u_dayTextures: function () {\n      return this.properties.dayTextures;\n    },\n    u_dayTextureTranslationAndScale: function () {\n      return this.properties.dayTextureTranslationAndScale;\n    },\n    u_dayTextureTexCoordsRectangle: function () {\n      return this.properties.dayTextureTexCoordsRectangle;\n    },\n    u_dayTextureUseWebMercatorT: function () {\n      return this.properties.dayTextureUseWebMercatorT;\n    },\n    u_dayTextureAlpha: function () {\n      return this.properties.dayTextureAlpha;\n    },\n    u_dayTextureNightAlpha: function () {\n      return this.properties.dayTextureNightAlpha;\n    },\n    u_dayTextureDayAlpha: function () {\n      return this.properties.dayTextureDayAlpha;\n    },\n    u_dayTextureBrightness: function () {\n      return this.properties.dayTextureBrightness;\n    },\n    u_dayTextureContrast: function () {\n      return this.properties.dayTextureContrast;\n    },\n    u_dayTextureHue: function () {\n      return this.properties.dayTextureHue;\n    },\n    u_dayTextureSaturation: function () {\n      return this.properties.dayTextureSaturation;\n    },\n    u_dayTextureOneOverGamma: function () {\n      return this.properties.dayTextureOneOverGamma;\n    },\n    u_dayIntensity: function () {\n      return this.properties.dayIntensity;\n    },\n    u_southAndNorthLatitude: function () {\n      return this.properties.southAndNorthLatitude;\n    },\n    u_southMercatorYAndOneOverHeight: function () {\n      return this.properties.southMercatorYAndOneOverHeight;\n    },\n    u_waterMask: function () {\n      return this.properties.waterMask;\n    },\n    u_waterMaskTranslationAndScale: function () {\n      return this.properties.waterMaskTranslationAndScale;\n    },\n    u_minMaxHeight: function () {\n      return this.properties.minMaxHeight;\n    },\n    u_scaleAndBias: function () {\n      return this.properties.scaleAndBias;\n    },\n    u_dayTextureSplit: function () {\n      return this.properties.dayTextureSplit;\n    },\n    u_dayTextureCutoutRectangles: function () {\n      return this.properties.dayTextureCutoutRectangles;\n    },\n    u_clippingPlanes: function () {\n      const clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      if (defined(clippingPlanes) && defined(clippingPlanes.texture)) {\n        // Check in case clippingPlanes hasn't been updated yet.\n        return clippingPlanes.texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_cartographicLimitRectangle: function () {\n      return this.properties.localizedCartographicLimitRectangle;\n    },\n    u_clippingPlanesMatrix: function () {\n      const clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      const transform = defined(clippingPlanes)\n        ? Matrix4.multiply(\n            frameState.context.uniformState.view,\n            clippingPlanes.modelMatrix,\n            scratchClippingPlanesMatrix\n          )\n        : Matrix4.IDENTITY;\n\n      return Matrix4.inverseTranspose(\n        transform,\n        scratchInverseTransposeClippingPlanesMatrix\n      );\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      const style = this.properties.clippingPlanesEdgeColor;\n      style.alpha = this.properties.clippingPlanesEdgeWidth;\n      return style;\n    },\n    u_minimumBrightness: function () {\n      return frameState.fog.minimumBrightness;\n    },\n    u_hsbShift: function () {\n      return this.properties.hsbShift;\n    },\n    u_colorsToAlpha: function () {\n      return this.properties.colorsToAlpha;\n    },\n    u_frontFaceAlphaByDistance: function () {\n      return this.properties.frontFaceAlphaByDistance;\n    },\n    u_backFaceAlphaByDistance: function () {\n      return this.properties.backFaceAlphaByDistance;\n    },\n    u_translucencyRectangle: function () {\n      return this.properties.localizedTranslucencyRectangle;\n    },\n    u_undergroundColor: function () {\n      return this.properties.undergroundColor;\n    },\n    u_undergroundColorAlphaByDistance: function () {\n      return this.properties.undergroundColorAlphaByDistance;\n    },\n    u_lambertDiffuseMultiplier: function () {\n      return this.properties.lambertDiffuseMultiplier;\n    },\n\n    // make a separate object so that changes to the properties are seen on\n    // derived commands that combine another uniform map with this one.\n    properties: {\n      initialColor: new Cartesian4(0.0, 0.0, 0.5, 1.0),\n      fillHighlightColor: new Color(0.0, 0.0, 0.0, 0.0),\n      zoomedOutOceanSpecularIntensity: 0.5,\n      oceanNormalMap: undefined,\n      lightingFadeDistance: new Cartesian2(6500000.0, 9000000.0),\n      nightFadeDistance: new Cartesian2(10000000.0, 40000000.0),\n      atmosphereLightIntensity: 10.0,\n      atmosphereRayleighCoefficient: new Cartesian3(5.5e-6, 13.0e-6, 28.4e-6),\n      atmosphereMieCoefficient: new Cartesian3(21e-6, 21e-6, 21e-6),\n      atmosphereRayleighScaleHeight: 10000.0,\n      atmosphereMieScaleHeight: 3200.0,\n      atmosphereMieAnisotropy: 0.9,\n      hsbShift: new Cartesian3(),\n\n      center3D: undefined,\n      rtc: new Cartesian3(),\n      modifiedModelView: new Matrix4(),\n      tileRectangle: new Cartesian4(),\n\n      terrainExaggerationAndRelativeHeight: new Cartesian2(1.0, 0.0),\n\n      dayTextures: [],\n      dayTextureTranslationAndScale: [],\n      dayTextureTexCoordsRectangle: [],\n      dayTextureUseWebMercatorT: [],\n      dayTextureAlpha: [],\n      dayTextureNightAlpha: [],\n      dayTextureDayAlpha: [],\n      dayTextureBrightness: [],\n      dayTextureContrast: [],\n      dayTextureHue: [],\n      dayTextureSaturation: [],\n      dayTextureOneOverGamma: [],\n      dayTextureSplit: [],\n      dayTextureCutoutRectangles: [],\n      dayIntensity: 0.0,\n      colorsToAlpha: [],\n\n      southAndNorthLatitude: new Cartesian2(),\n      southMercatorYAndOneOverHeight: new Cartesian2(),\n\n      waterMask: undefined,\n      waterMaskTranslationAndScale: new Cartesian4(),\n\n      minMaxHeight: new Cartesian2(),\n      scaleAndBias: new Matrix4(),\n      clippingPlanesEdgeColor: Color.clone(Color.WHITE),\n      clippingPlanesEdgeWidth: 0.0,\n\n      localizedCartographicLimitRectangle: new Cartesian4(),\n\n      frontFaceAlphaByDistance: new Cartesian4(),\n      backFaceAlphaByDistance: new Cartesian4(),\n      localizedTranslucencyRectangle: new Cartesian4(),\n      undergroundColor: Color.clone(Color.TRANSPARENT),\n      undergroundColorAlphaByDistance: new Cartesian4(),\n      lambertDiffuseMultiplier: 0.0,\n    },\n  };\n\n  if (defined(globeSurfaceTileProvider.materialUniformMap)) {\n    return combine(uniformMap, globeSurfaceTileProvider.materialUniformMap);\n  }\n\n  return uniformMap;\n}\n\nfunction createWireframeVertexArrayIfNecessary(context, provider, tile) {\n  const surfaceTile = tile.data;\n\n  let mesh;\n  let vertexArray;\n\n  if (defined(surfaceTile.vertexArray)) {\n    mesh = surfaceTile.mesh;\n    vertexArray = surfaceTile.vertexArray;\n  } else if (\n    defined(surfaceTile.fill) &&\n    defined(surfaceTile.fill.vertexArray)\n  ) {\n    mesh = surfaceTile.fill.mesh;\n    vertexArray = surfaceTile.fill.vertexArray;\n  }\n\n  if (!defined(mesh) || !defined(vertexArray)) {\n    return;\n  }\n\n  if (defined(surfaceTile.wireframeVertexArray)) {\n    if (surfaceTile.wireframeVertexArray.mesh === mesh) {\n      return;\n    }\n\n    surfaceTile.wireframeVertexArray.destroy();\n    surfaceTile.wireframeVertexArray = undefined;\n  }\n\n  surfaceTile.wireframeVertexArray = createWireframeVertexArray(\n    context,\n    vertexArray,\n    mesh\n  );\n  surfaceTile.wireframeVertexArray.mesh = mesh;\n}\n\n/**\n * Creates a vertex array for wireframe rendering of a terrain tile.\n *\n * @private\n *\n * @param {Context} context The context in which to create the vertex array.\n * @param {VertexArray} vertexArray The existing, non-wireframe vertex array.  The new vertex array\n *                      will share vertex buffers with this existing one.\n * @param {TerrainMesh} terrainMesh The terrain mesh containing non-wireframe indices.\n * @returns {VertexArray} The vertex array for wireframe rendering.\n */\nfunction createWireframeVertexArray(context, vertexArray, terrainMesh) {\n  const indices = terrainMesh.indices;\n\n  const geometry = {\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  GeometryPipeline.toWireframe(geometry);\n\n  const wireframeIndices = geometry.indices;\n  const wireframeIndexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.fromSizeInBytes(\n      wireframeIndices.BYTES_PER_ELEMENT\n    ),\n  });\n  return new VertexArray({\n    context: context,\n    attributes: vertexArray._attributes,\n    indexBuffer: wireframeIndexBuffer,\n  });\n}\n\nlet getDebugOrientedBoundingBox;\nlet getDebugBoundingSphere;\nlet debugDestroyPrimitive;\n\n(function () {\n  const instanceOBB = new GeometryInstance({\n    geometry: BoxOutlineGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0),\n    }),\n  });\n  const instanceSphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({ radius: 1.0 }),\n  });\n  let modelMatrix = new Matrix4();\n  let previousVolume;\n  let primitive;\n\n  function createDebugPrimitive(instance) {\n    return new Primitive({\n      geometryInstances: instance,\n      appearance: new PerInstanceColorAppearance({\n        translucent: false,\n        flat: true,\n      }),\n      asynchronous: false,\n    });\n  }\n\n  getDebugOrientedBoundingBox = function (obb, color) {\n    if (obb === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = obb;\n    modelMatrix = Matrix4.fromRotationTranslation(\n      obb.halfAxes,\n      obb.center,\n      modelMatrix\n    );\n\n    instanceOBB.modelMatrix = modelMatrix;\n    instanceOBB.attributes.color = ColorGeometryInstanceAttribute.fromColor(\n      color\n    );\n\n    primitive = createDebugPrimitive(instanceOBB);\n    return primitive;\n  };\n\n  getDebugBoundingSphere = function (sphere, color) {\n    if (sphere === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = sphere;\n    modelMatrix = Matrix4.fromTranslation(sphere.center, modelMatrix);\n    modelMatrix = Matrix4.multiplyByUniformScale(\n      modelMatrix,\n      sphere.radius,\n      modelMatrix\n    );\n\n    instanceSphere.modelMatrix = modelMatrix;\n    instanceSphere.attributes.color = ColorGeometryInstanceAttribute.fromColor(\n      color\n    );\n\n    primitive = createDebugPrimitive(instanceSphere);\n    return primitive;\n  };\n\n  debugDestroyPrimitive = function () {\n    if (defined(primitive)) {\n      primitive.destroy();\n      primitive = undefined;\n      previousVolume = undefined;\n    }\n  };\n})();\n\nconst otherPassesInitialColor = new Cartesian4(0.0, 0.0, 0.0, 0.0);\nconst surfaceShaderSetOptionsScratch = {\n  frameState: undefined,\n  surfaceTile: undefined,\n  numberOfDayTextures: undefined,\n  applyBrightness: undefined,\n  applyContrast: undefined,\n  applyHue: undefined,\n  applySaturation: undefined,\n  applyGamma: undefined,\n  applyAlpha: undefined,\n  applyDayNightAlpha: undefined,\n  applySplit: undefined,\n  showReflectiveOcean: undefined,\n  showOceanWaves: undefined,\n  enableLighting: undefined,\n  dynamicAtmosphereLighting: undefined,\n  dynamicAtmosphereLightingFromSun: undefined,\n  showGroundAtmosphere: undefined,\n  perFragmentGroundAtmosphere: undefined,\n  hasVertexNormals: undefined,\n  useWebMercatorProjection: undefined,\n  enableFog: undefined,\n  enableClippingPlanes: undefined,\n  clippingPlanes: undefined,\n  clippedByBoundaries: undefined,\n  hasImageryLayerCutout: undefined,\n  colorCorrect: undefined,\n  colorToAlpha: undefined,\n  hasGeodeticSurfaceNormals: undefined,\n  hasExaggeration: undefined,\n};\n\nconst defaultUndergroundColor = Color.TRANSPARENT;\nconst defaultUndergroundColorAlphaByDistance = new NearFarScalar();\n\nfunction addDrawCommandsForTile(tileProvider, tile, frameState) {\n  const surfaceTile = tile.data;\n\n  if (!defined(surfaceTile.vertexArray)) {\n    if (surfaceTile.fill === undefined) {\n      // No fill was created for this tile, probably because this tile is not connected to\n      // any renderable tiles. So create a simple tile in the middle of the tile's possible\n      // height range.\n      surfaceTile.fill = new TerrainFillMesh(tile);\n    }\n    surfaceTile.fill.update(tileProvider, frameState);\n  }\n\n  const creditDisplay = frameState.creditDisplay;\n\n  const terrainData = surfaceTile.terrainData;\n  if (defined(terrainData) && defined(terrainData.credits)) {\n    const tileCredits = terrainData.credits;\n    for (\n      let tileCreditIndex = 0, tileCreditLength = tileCredits.length;\n      tileCreditIndex < tileCreditLength;\n      ++tileCreditIndex\n    ) {\n      creditDisplay.addCredit(tileCredits[tileCreditIndex]);\n    }\n  }\n\n  let maxTextures = ContextLimits.maximumTextureImageUnits;\n\n  let waterMaskTexture = surfaceTile.waterMaskTexture;\n  let waterMaskTranslationAndScale = surfaceTile.waterMaskTranslationAndScale;\n  if (!defined(waterMaskTexture) && defined(surfaceTile.fill)) {\n    waterMaskTexture = surfaceTile.fill.waterMaskTexture;\n    waterMaskTranslationAndScale =\n      surfaceTile.fill.waterMaskTranslationAndScale;\n  }\n\n  const cameraUnderground = frameState.cameraUnderground;\n\n  const globeTranslucencyState = frameState.globeTranslucencyState;\n  const translucent = globeTranslucencyState.translucent;\n  const frontFaceAlphaByDistance =\n    globeTranslucencyState.frontFaceAlphaByDistance;\n  const backFaceAlphaByDistance =\n    globeTranslucencyState.backFaceAlphaByDistance;\n  const translucencyRectangle = globeTranslucencyState.rectangle;\n\n  const undergroundColor = defaultValue(\n    tileProvider.undergroundColor,\n    defaultUndergroundColor\n  );\n  const undergroundColorAlphaByDistance = defaultValue(\n    tileProvider.undergroundColorAlphaByDistance,\n    defaultUndergroundColorAlphaByDistance\n  );\n  const showUndergroundColor =\n    isUndergroundVisible(tileProvider, frameState) &&\n    frameState.mode === SceneMode.SCENE3D &&\n    undergroundColor.alpha > 0.0 &&\n    (undergroundColorAlphaByDistance.nearValue > 0.0 ||\n      undergroundColorAlphaByDistance.farValue > 0.0);\n\n  const lambertDiffuseMultiplier = tileProvider.lambertDiffuseMultiplier;\n\n  const showReflectiveOcean =\n    tileProvider.hasWaterMask && defined(waterMaskTexture);\n  const oceanNormalMap = tileProvider.oceanNormalMap;\n  const showOceanWaves = showReflectiveOcean && defined(oceanNormalMap);\n  const hasVertexNormals =\n    tileProvider.terrainProvider.ready &&\n    tileProvider.terrainProvider.hasVertexNormals;\n  const enableFog =\n    frameState.fog.enabled && frameState.fog.renderable && !cameraUnderground;\n  const showGroundAtmosphere =\n    tileProvider.showGroundAtmosphere && frameState.mode === SceneMode.SCENE3D;\n  const castShadows =\n    ShadowMode.castShadows(tileProvider.shadows) && !translucent;\n  const receiveShadows =\n    ShadowMode.receiveShadows(tileProvider.shadows) && !translucent;\n\n  const hueShift = tileProvider.hueShift;\n  const saturationShift = tileProvider.saturationShift;\n  const brightnessShift = tileProvider.brightnessShift;\n\n  let colorCorrect = !(\n    CesiumMath.equalsEpsilon(hueShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(saturationShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(brightnessShift, 0.0, CesiumMath.EPSILON7)\n  );\n\n  let perFragmentGroundAtmosphere = false;\n  if (showGroundAtmosphere) {\n    const cameraDistance = Cartesian3.magnitude(frameState.camera.positionWC);\n    const fadeOutDistance = tileProvider.nightFadeOutDistance;\n    perFragmentGroundAtmosphere = cameraDistance > fadeOutDistance;\n  }\n\n  if (showReflectiveOcean) {\n    --maxTextures;\n  }\n  if (showOceanWaves) {\n    --maxTextures;\n  }\n  if (\n    defined(frameState.shadowState) &&\n    frameState.shadowState.shadowsEnabled\n  ) {\n    --maxTextures;\n  }\n  if (\n    defined(tileProvider.clippingPlanes) &&\n    tileProvider.clippingPlanes.enabled\n  ) {\n    --maxTextures;\n  }\n\n  maxTextures -= globeTranslucencyState.numberOfTextureUniforms;\n\n  const mesh = surfaceTile.renderedMesh;\n  let rtc = mesh.center;\n  const encoding = mesh.encoding;\n  const tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  const exaggeration = frameState.terrainExaggeration;\n  const exaggerationRelativeHeight =\n    frameState.terrainExaggerationRelativeHeight;\n  const hasExaggeration = exaggeration !== 1.0;\n  const hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n\n  // Not used in 3D.\n  const tileRectangle = tileRectangleScratch;\n\n  // Only used for Mercator projections.\n  let southLatitude = 0.0;\n  let northLatitude = 0.0;\n  let southMercatorY = 0.0;\n  let oneOverMercatorHeight = 0.0;\n\n  let useWebMercatorProjection = false;\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    const projection = frameState.mapProjection;\n    const southwest = projection.project(\n      Rectangle.southwest(tile.rectangle),\n      southwestScratch\n    );\n    const northeast = projection.project(\n      Rectangle.northeast(tile.rectangle),\n      northeastScratch\n    );\n\n    tileRectangle.x = southwest.x;\n    tileRectangle.y = southwest.y;\n    tileRectangle.z = northeast.x;\n    tileRectangle.w = northeast.y;\n\n    // In 2D and Columbus View, use the center of the tile for RTC rendering.\n    if (frameState.mode !== SceneMode.MORPHING) {\n      rtc = rtcScratch;\n      rtc.x = 0.0;\n      rtc.y = (tileRectangle.z + tileRectangle.x) * 0.5;\n      rtc.z = (tileRectangle.w + tileRectangle.y) * 0.5;\n      tileRectangle.x -= rtc.y;\n      tileRectangle.y -= rtc.z;\n      tileRectangle.z -= rtc.y;\n      tileRectangle.w -= rtc.z;\n    }\n\n    if (\n      frameState.mode === SceneMode.SCENE2D &&\n      encoding.quantization === TerrainQuantization.BITS12\n    ) {\n      // In 2D, the texture coordinates of the tile are interpolated over the rectangle to get the position in the vertex shader.\n      // When the texture coordinates are quantized, error is introduced. This can be seen through the 1px wide cracking\n      // between the quantized tiles in 2D. To compensate for the error, move the expand the rectangle in each direction by\n      // half the error amount.\n      const epsilon = (1.0 / (Math.pow(2.0, 12.0) - 1.0)) * 0.5;\n      const widthEpsilon = (tileRectangle.z - tileRectangle.x) * epsilon;\n      const heightEpsilon = (tileRectangle.w - tileRectangle.y) * epsilon;\n      tileRectangle.x -= widthEpsilon;\n      tileRectangle.y -= heightEpsilon;\n      tileRectangle.z += widthEpsilon;\n      tileRectangle.w += heightEpsilon;\n    }\n\n    if (projection instanceof WebMercatorProjection) {\n      southLatitude = tile.rectangle.south;\n      northLatitude = tile.rectangle.north;\n\n      southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n        southLatitude\n      );\n\n      oneOverMercatorHeight =\n        1.0 /\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude) -\n          southMercatorY);\n\n      useWebMercatorProjection = true;\n    }\n  }\n\n  const surfaceShaderSetOptions = surfaceShaderSetOptionsScratch;\n  surfaceShaderSetOptions.frameState = frameState;\n  surfaceShaderSetOptions.surfaceTile = surfaceTile;\n  surfaceShaderSetOptions.showReflectiveOcean = showReflectiveOcean;\n  surfaceShaderSetOptions.showOceanWaves = showOceanWaves;\n  surfaceShaderSetOptions.enableLighting = tileProvider.enableLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLighting =\n    tileProvider.dynamicAtmosphereLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLightingFromSun =\n    tileProvider.dynamicAtmosphereLightingFromSun;\n  surfaceShaderSetOptions.showGroundAtmosphere = showGroundAtmosphere;\n  surfaceShaderSetOptions.atmosphereLightIntensity =\n    tileProvider.atmosphereLightIntensity;\n  surfaceShaderSetOptions.atmosphereRayleighCoefficient =\n    tileProvider.atmosphereRayleighCoefficient;\n  surfaceShaderSetOptions.atmosphereMieCoefficient =\n    tileProvider.atmosphereMieCoefficient;\n  surfaceShaderSetOptions.atmosphereRayleighScaleHeight =\n    tileProvider.atmosphereRayleighScaleHeight;\n  surfaceShaderSetOptions.atmosphereMieScaleHeight =\n    tileProvider.atmosphereMieScaleHeight;\n  surfaceShaderSetOptions.atmosphereMieAnisotropy =\n    tileProvider.atmosphereMieAnisotropy;\n  surfaceShaderSetOptions.perFragmentGroundAtmosphere = perFragmentGroundAtmosphere;\n  surfaceShaderSetOptions.hasVertexNormals = hasVertexNormals;\n  surfaceShaderSetOptions.useWebMercatorProjection = useWebMercatorProjection;\n  surfaceShaderSetOptions.clippedByBoundaries = surfaceTile.clippedByBoundaries;\n  surfaceShaderSetOptions.hasGeodeticSurfaceNormals = hasGeodeticSurfaceNormals;\n  surfaceShaderSetOptions.hasExaggeration = hasExaggeration;\n\n  const tileImageryCollection = surfaceTile.imagery;\n  let imageryIndex = 0;\n  const imageryLen = tileImageryCollection.length;\n\n  const showSkirts =\n    tileProvider.showSkirts && !cameraUnderground && !translucent;\n  const backFaceCulling =\n    tileProvider.backFaceCulling && !cameraUnderground && !translucent;\n  const firstPassRenderState = backFaceCulling\n    ? tileProvider._renderState\n    : tileProvider._disableCullingRenderState;\n  const otherPassesRenderState = backFaceCulling\n    ? tileProvider._blendRenderState\n    : tileProvider._disableCullingBlendRenderState;\n  let renderState = firstPassRenderState;\n\n  let initialColor = tileProvider._firstPassInitialColor;\n\n  const context = frameState.context;\n\n  if (!defined(tileProvider._debug.boundingSphereTile)) {\n    debugDestroyPrimitive();\n  }\n\n  const materialUniformMapChanged =\n    tileProvider._materialUniformMap !== tileProvider.materialUniformMap;\n  if (materialUniformMapChanged) {\n    tileProvider._materialUniformMap = tileProvider.materialUniformMap;\n    const drawCommandsLength = tileProvider._drawCommands.length;\n    for (let i = 0; i < drawCommandsLength; ++i) {\n      tileProvider._uniformMaps[i] = createTileUniformMap(\n        frameState,\n        tileProvider\n      );\n    }\n  }\n\n  do {\n    let numberOfDayTextures = 0;\n\n    let command;\n    let uniformMap;\n\n    if (tileProvider._drawCommands.length <= tileProvider._usedDrawCommands) {\n      command = new DrawCommand();\n      command.owner = tile;\n      command.cull = false;\n      command.boundingVolume = new BoundingSphere();\n      command.orientedBoundingBox = undefined;\n\n      uniformMap = createTileUniformMap(frameState, tileProvider);\n\n      tileProvider._drawCommands.push(command);\n      tileProvider._uniformMaps.push(uniformMap);\n    } else {\n      command = tileProvider._drawCommands[tileProvider._usedDrawCommands];\n      uniformMap = tileProvider._uniformMaps[tileProvider._usedDrawCommands];\n    }\n\n    command.owner = tile;\n\n    ++tileProvider._usedDrawCommands;\n\n    if (tile === tileProvider._debug.boundingSphereTile) {\n      const obb = tileBoundingRegion.boundingVolume;\n      const boundingSphere = tileBoundingRegion.boundingSphere;\n      // If a debug primitive already exists for this tile, it will not be\n      // re-created, to avoid allocation every frame. If it were possible\n      // to have more than one selected tile, this would have to change.\n      if (defined(obb)) {\n        getDebugOrientedBoundingBox(obb, Color.RED).update(frameState);\n      } else if (defined(boundingSphere)) {\n        getDebugBoundingSphere(boundingSphere, Color.RED).update(frameState);\n      }\n    }\n\n    const uniformMapProperties = uniformMap.properties;\n    Cartesian4.clone(initialColor, uniformMapProperties.initialColor);\n    uniformMapProperties.oceanNormalMap = oceanNormalMap;\n    uniformMapProperties.lightingFadeDistance.x =\n      tileProvider.lightingFadeOutDistance;\n    uniformMapProperties.lightingFadeDistance.y =\n      tileProvider.lightingFadeInDistance;\n    uniformMapProperties.nightFadeDistance.x =\n      tileProvider.nightFadeOutDistance;\n    uniformMapProperties.nightFadeDistance.y = tileProvider.nightFadeInDistance;\n    uniformMapProperties.atmosphereLightIntensity =\n      tileProvider.atmosphereLightIntensity;\n    uniformMapProperties.atmosphereRayleighCoefficient =\n      tileProvider.atmosphereRayleighCoefficient;\n    uniformMapProperties.atmosphereMieCoefficient =\n      tileProvider.atmosphereMieCoefficient;\n    uniformMapProperties.atmosphereRayleighScaleHeight =\n      tileProvider.atmosphereRayleighScaleHeight;\n    uniformMapProperties.atmosphereMieScaleHeight =\n      tileProvider.atmosphereMieScaleHeight;\n    uniformMapProperties.atmosphereMieAnisotropy =\n      tileProvider.atmosphereMieAnisotropy;\n    uniformMapProperties.zoomedOutOceanSpecularIntensity =\n      tileProvider.zoomedOutOceanSpecularIntensity;\n\n    const frontFaceAlphaByDistanceFinal = cameraUnderground\n      ? backFaceAlphaByDistance\n      : frontFaceAlphaByDistance;\n    const backFaceAlphaByDistanceFinal = cameraUnderground\n      ? frontFaceAlphaByDistance\n      : backFaceAlphaByDistance;\n\n    if (defined(frontFaceAlphaByDistanceFinal)) {\n      Cartesian4.fromElements(\n        frontFaceAlphaByDistanceFinal.near,\n        frontFaceAlphaByDistanceFinal.nearValue,\n        frontFaceAlphaByDistanceFinal.far,\n        frontFaceAlphaByDistanceFinal.farValue,\n        uniformMapProperties.frontFaceAlphaByDistance\n      );\n      Cartesian4.fromElements(\n        backFaceAlphaByDistanceFinal.near,\n        backFaceAlphaByDistanceFinal.nearValue,\n        backFaceAlphaByDistanceFinal.far,\n        backFaceAlphaByDistanceFinal.farValue,\n        uniformMapProperties.backFaceAlphaByDistance\n      );\n    }\n\n    Cartesian4.fromElements(\n      undergroundColorAlphaByDistance.near,\n      undergroundColorAlphaByDistance.nearValue,\n      undergroundColorAlphaByDistance.far,\n      undergroundColorAlphaByDistance.farValue,\n      uniformMapProperties.undergroundColorAlphaByDistance\n    );\n    Color.clone(undergroundColor, uniformMapProperties.undergroundColor);\n\n    uniformMapProperties.lambertDiffuseMultiplier = lambertDiffuseMultiplier;\n\n    const highlightFillTile =\n      !defined(surfaceTile.vertexArray) &&\n      defined(tileProvider.fillHighlightColor) &&\n      tileProvider.fillHighlightColor.alpha > 0.0;\n    if (highlightFillTile) {\n      Color.clone(\n        tileProvider.fillHighlightColor,\n        uniformMapProperties.fillHighlightColor\n      );\n    }\n\n    uniformMapProperties.terrainExaggerationAndRelativeHeight.x = exaggeration;\n    uniformMapProperties.terrainExaggerationAndRelativeHeight.y = exaggerationRelativeHeight;\n\n    uniformMapProperties.center3D = mesh.center;\n    Cartesian3.clone(rtc, uniformMapProperties.rtc);\n\n    Cartesian4.clone(tileRectangle, uniformMapProperties.tileRectangle);\n    uniformMapProperties.southAndNorthLatitude.x = southLatitude;\n    uniformMapProperties.southAndNorthLatitude.y = northLatitude;\n    uniformMapProperties.southMercatorYAndOneOverHeight.x = southMercatorY;\n    uniformMapProperties.southMercatorYAndOneOverHeight.y = oneOverMercatorHeight;\n\n    // Convert tile limiter rectangle from cartographic to texture space using the tileRectangle.\n    const localizedCartographicLimitRectangle = localizedCartographicLimitRectangleScratch;\n    const cartographicLimitRectangle = clipRectangleAntimeridian(\n      tile.rectangle,\n      tileProvider.cartographicLimitRectangle\n    );\n\n    const localizedTranslucencyRectangle = localizedTranslucencyRectangleScratch;\n    const clippedTranslucencyRectangle = clipRectangleAntimeridian(\n      tile.rectangle,\n      translucencyRectangle\n    );\n\n    Cartesian3.fromElements(\n      hueShift,\n      saturationShift,\n      brightnessShift,\n      uniformMapProperties.hsbShift\n    );\n\n    const cartographicTileRectangle = tile.rectangle;\n    const inverseTileWidth = 1.0 / cartographicTileRectangle.width;\n    const inverseTileHeight = 1.0 / cartographicTileRectangle.height;\n    localizedCartographicLimitRectangle.x =\n      (cartographicLimitRectangle.west - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.y =\n      (cartographicLimitRectangle.south - cartographicTileRectangle.south) *\n      inverseTileHeight;\n    localizedCartographicLimitRectangle.z =\n      (cartographicLimitRectangle.east - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.w =\n      (cartographicLimitRectangle.north - cartographicTileRectangle.south) *\n      inverseTileHeight;\n\n    Cartesian4.clone(\n      localizedCartographicLimitRectangle,\n      uniformMapProperties.localizedCartographicLimitRectangle\n    );\n\n    localizedTranslucencyRectangle.x =\n      (clippedTranslucencyRectangle.west - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedTranslucencyRectangle.y =\n      (clippedTranslucencyRectangle.south - cartographicTileRectangle.south) *\n      inverseTileHeight;\n    localizedTranslucencyRectangle.z =\n      (clippedTranslucencyRectangle.east - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedTranslucencyRectangle.w =\n      (clippedTranslucencyRectangle.north - cartographicTileRectangle.south) *\n      inverseTileHeight;\n\n    Cartesian4.clone(\n      localizedTranslucencyRectangle,\n      uniformMapProperties.localizedTranslucencyRectangle\n    );\n\n    // For performance, use fog in the shader only when the tile is in fog.\n    const applyFog =\n      enableFog &&\n      CesiumMath.fog(tile._distance, frameState.fog.density) >\n        CesiumMath.EPSILON3;\n    colorCorrect = colorCorrect && (applyFog || showGroundAtmosphere);\n\n    let applyBrightness = false;\n    let applyContrast = false;\n    let applyHue = false;\n    let applySaturation = false;\n    let applyGamma = false;\n    let applyAlpha = false;\n    let applyDayNightAlpha = false;\n    let applySplit = false;\n    let applyCutout = false;\n    let applyColorToAlpha = false;\n\n    while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {\n      const tileImagery = tileImageryCollection[imageryIndex];\n      const imagery = tileImagery.readyImagery;\n      ++imageryIndex;\n\n      if (!defined(imagery) || imagery.imageryLayer.alpha === 0.0) {\n        continue;\n      }\n\n      const texture = tileImagery.useWebMercatorT\n        ? imagery.textureWebMercator\n        : imagery.texture;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(texture)) {\n        // Our \"ready\" texture isn't actually ready.  This should never happen.\n        //\n        // Side note: It IS possible for it to not be in the READY ImageryState, though.\n        // This can happen when a single imagery tile is shared by two terrain tiles (common)\n        // and one of them (A) needs a geographic version of the tile because it is near the poles,\n        // and the other (B) does not.  B can and will transition the imagery tile to the READY state\n        // without reprojecting to geographic.  Then, later, A will deem that same tile not-ready-yet\n        // because it only has the Web Mercator texture, and flip it back to the TRANSITIONING state.\n        // The imagery tile won't be in the READY state anymore, but it's still READY enough for B's\n        // purposes.\n        throw new DeveloperError(\"readyImagery is not actually ready!\");\n      }\n      //>>includeEnd('debug');\n\n      const imageryLayer = imagery.imageryLayer;\n\n      if (!defined(tileImagery.textureTranslationAndScale)) {\n        tileImagery.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(\n          tile,\n          tileImagery\n        );\n      }\n\n      uniformMapProperties.dayTextures[numberOfDayTextures] = texture;\n      uniformMapProperties.dayTextureTranslationAndScale[numberOfDayTextures] =\n        tileImagery.textureTranslationAndScale;\n      uniformMapProperties.dayTextureTexCoordsRectangle[numberOfDayTextures] =\n        tileImagery.textureCoordinateRectangle;\n      uniformMapProperties.dayTextureUseWebMercatorT[numberOfDayTextures] =\n        tileImagery.useWebMercatorT;\n\n      uniformMapProperties.dayTextureAlpha[numberOfDayTextures] =\n        imageryLayer.alpha;\n      applyAlpha =\n        applyAlpha ||\n        uniformMapProperties.dayTextureAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] =\n        imageryLayer.nightAlpha;\n      applyDayNightAlpha =\n        applyDayNightAlpha ||\n        uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] =\n        imageryLayer.dayAlpha;\n      applyDayNightAlpha =\n        applyDayNightAlpha ||\n        uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureBrightness[numberOfDayTextures] =\n        imageryLayer.brightness;\n      applyBrightness =\n        applyBrightness ||\n        uniformMapProperties.dayTextureBrightness[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_BRIGHTNESS;\n\n      uniformMapProperties.dayTextureContrast[numberOfDayTextures] =\n        imageryLayer.contrast;\n      applyContrast =\n        applyContrast ||\n        uniformMapProperties.dayTextureContrast[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_CONTRAST;\n\n      uniformMapProperties.dayTextureHue[numberOfDayTextures] =\n        imageryLayer.hue;\n      applyHue =\n        applyHue ||\n        uniformMapProperties.dayTextureHue[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_HUE;\n\n      uniformMapProperties.dayTextureSaturation[numberOfDayTextures] =\n        imageryLayer.saturation;\n      applySaturation =\n        applySaturation ||\n        uniformMapProperties.dayTextureSaturation[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_SATURATION;\n\n      uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] =\n        1.0 / imageryLayer.gamma;\n      applyGamma =\n        applyGamma ||\n        uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] !==\n          1.0 / ImageryLayer.DEFAULT_GAMMA;\n\n      uniformMapProperties.dayTextureSplit[numberOfDayTextures] =\n        imageryLayer.splitDirection;\n      applySplit =\n        applySplit ||\n        uniformMapProperties.dayTextureSplit[numberOfDayTextures] !== 0.0;\n\n      // Update cutout rectangle\n      let dayTextureCutoutRectangle =\n        uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures];\n      if (!defined(dayTextureCutoutRectangle)) {\n        dayTextureCutoutRectangle = uniformMapProperties.dayTextureCutoutRectangles[\n          numberOfDayTextures\n        ] = new Cartesian4();\n      }\n\n      Cartesian4.clone(Cartesian4.ZERO, dayTextureCutoutRectangle);\n      if (defined(imageryLayer.cutoutRectangle)) {\n        const cutoutRectangle = clipRectangleAntimeridian(\n          cartographicTileRectangle,\n          imageryLayer.cutoutRectangle\n        );\n        const intersection = Rectangle.simpleIntersection(\n          cutoutRectangle,\n          cartographicTileRectangle,\n          rectangleIntersectionScratch\n        );\n        applyCutout = defined(intersection) || applyCutout;\n\n        dayTextureCutoutRectangle.x =\n          (cutoutRectangle.west - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.y =\n          (cutoutRectangle.south - cartographicTileRectangle.south) *\n          inverseTileHeight;\n        dayTextureCutoutRectangle.z =\n          (cutoutRectangle.east - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.w =\n          (cutoutRectangle.north - cartographicTileRectangle.south) *\n          inverseTileHeight;\n      }\n\n      // Update color to alpha\n      let colorToAlpha =\n        uniformMapProperties.colorsToAlpha[numberOfDayTextures];\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = uniformMapProperties.colorsToAlpha[\n          numberOfDayTextures\n        ] = new Cartesian4();\n      }\n\n      const hasColorToAlpha =\n        defined(imageryLayer.colorToAlpha) &&\n        imageryLayer.colorToAlphaThreshold > 0.0;\n      applyColorToAlpha = applyColorToAlpha || hasColorToAlpha;\n\n      if (hasColorToAlpha) {\n        const color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n\n      if (defined(imagery.credits)) {\n        const credits = imagery.credits;\n        for (\n          let creditIndex = 0, creditLength = credits.length;\n          creditIndex < creditLength;\n          ++creditIndex\n        ) {\n          creditDisplay.addCredit(credits[creditIndex]);\n        }\n      }\n\n      ++numberOfDayTextures;\n    }\n\n    // trim texture array to the used length so we don't end up using old textures\n    // which might get destroyed eventually\n    uniformMapProperties.dayTextures.length = numberOfDayTextures;\n    uniformMapProperties.waterMask = waterMaskTexture;\n    Cartesian4.clone(\n      waterMaskTranslationAndScale,\n      uniformMapProperties.waterMaskTranslationAndScale\n    );\n\n    uniformMapProperties.minMaxHeight.x = encoding.minimumHeight;\n    uniformMapProperties.minMaxHeight.y = encoding.maximumHeight;\n    Matrix4.clone(encoding.matrix, uniformMapProperties.scaleAndBias);\n\n    // update clipping planes\n    const clippingPlanes = tileProvider._clippingPlanes;\n    const clippingPlanesEnabled =\n      defined(clippingPlanes) && clippingPlanes.enabled && tile.isClipped;\n    if (clippingPlanesEnabled) {\n      uniformMapProperties.clippingPlanesEdgeColor = Color.clone(\n        clippingPlanes.edgeColor,\n        uniformMapProperties.clippingPlanesEdgeColor\n      );\n      uniformMapProperties.clippingPlanesEdgeWidth = clippingPlanes.edgeWidth;\n    }\n\n    surfaceShaderSetOptions.numberOfDayTextures = numberOfDayTextures;\n    surfaceShaderSetOptions.applyBrightness = applyBrightness;\n    surfaceShaderSetOptions.applyContrast = applyContrast;\n    surfaceShaderSetOptions.applyHue = applyHue;\n    surfaceShaderSetOptions.applySaturation = applySaturation;\n    surfaceShaderSetOptions.applyGamma = applyGamma;\n    surfaceShaderSetOptions.applyAlpha = applyAlpha;\n    surfaceShaderSetOptions.applyDayNightAlpha = applyDayNightAlpha;\n    surfaceShaderSetOptions.applySplit = applySplit;\n    surfaceShaderSetOptions.enableFog = applyFog;\n    surfaceShaderSetOptions.enableClippingPlanes = clippingPlanesEnabled;\n    surfaceShaderSetOptions.clippingPlanes = clippingPlanes;\n    surfaceShaderSetOptions.hasImageryLayerCutout = applyCutout;\n    surfaceShaderSetOptions.colorCorrect = colorCorrect;\n    surfaceShaderSetOptions.highlightFillTile = highlightFillTile;\n    surfaceShaderSetOptions.colorToAlpha = applyColorToAlpha;\n    surfaceShaderSetOptions.showUndergroundColor = showUndergroundColor;\n    surfaceShaderSetOptions.translucent = translucent;\n\n    let count = surfaceTile.renderedMesh.indices.length;\n    if (!showSkirts) {\n      count = surfaceTile.renderedMesh.indexCountWithoutSkirts;\n    }\n\n    command.shaderProgram = tileProvider._surfaceShaderSet.getShaderProgram(\n      surfaceShaderSetOptions\n    );\n    command.castShadows = castShadows;\n    command.receiveShadows = receiveShadows;\n    command.renderState = renderState;\n    command.primitiveType = PrimitiveType.TRIANGLES;\n    command.vertexArray =\n      surfaceTile.vertexArray || surfaceTile.fill.vertexArray;\n    command.count = count;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.GLOBE;\n\n    if (tileProvider._debug.wireframe) {\n      createWireframeVertexArrayIfNecessary(context, tileProvider, tile);\n      if (defined(surfaceTile.wireframeVertexArray)) {\n        command.vertexArray = surfaceTile.wireframeVertexArray;\n        command.primitiveType = PrimitiveType.LINES;\n        command.count = count * 2;\n      }\n    }\n\n    let boundingVolume = command.boundingVolume;\n    const orientedBoundingBox = command.orientedBoundingBox;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      BoundingSphere.fromRectangleWithHeights2D(\n        tile.rectangle,\n        frameState.mapProjection,\n        tileBoundingRegion.minimumHeight,\n        tileBoundingRegion.maximumHeight,\n        boundingVolume\n      );\n      Cartesian3.fromElements(\n        boundingVolume.center.z,\n        boundingVolume.center.x,\n        boundingVolume.center.y,\n        boundingVolume.center\n      );\n\n      if (frameState.mode === SceneMode.MORPHING) {\n        boundingVolume = BoundingSphere.union(\n          tileBoundingRegion.boundingSphere,\n          boundingVolume,\n          boundingVolume\n        );\n      }\n    } else {\n      command.boundingVolume = BoundingSphere.clone(\n        tileBoundingRegion.boundingSphere,\n        boundingVolume\n      );\n      command.orientedBoundingBox = OrientedBoundingBox.clone(\n        tileBoundingRegion.boundingVolume,\n        orientedBoundingBox\n      );\n    }\n\n    command.dirty = true;\n\n    if (translucent) {\n      globeTranslucencyState.updateDerivedCommands(command, frameState);\n    }\n\n    pushCommand(command, frameState);\n\n    renderState = otherPassesRenderState;\n    initialColor = otherPassesInitialColor;\n  } while (imageryIndex < imageryLen);\n}\nexport default GlobeSurfaceTileProvider;\n","import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\n\n/**\n * Properties for controlling globe translucency.\n *\n * @alias GlobeTranslucency\n * @constructor\n */\nfunction GlobeTranslucency() {\n  this._enabled = false;\n  this._frontFaceAlpha = 1.0;\n  this._frontFaceAlphaByDistance = undefined;\n  this._backFaceAlpha = 1.0;\n  this._backFaceAlphaByDistance = undefined;\n  this._rectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n}\n\nObject.defineProperties(GlobeTranslucency.prototype, {\n  /**\n   * When true, the globe is rendered as a translucent surface.\n   * <br /><br />\n   * The alpha is computed by blending {@link Globe#material}, {@link Globe#imageryLayers},\n   * and {@link Globe#baseColor}, all of which may contain translucency, and then multiplying by\n   * {@link GlobeTranslucency#frontFaceAlpha} and {@link GlobeTranslucency#frontFaceAlphaByDistance} for front faces and\n   * {@link GlobeTranslucency#backFaceAlpha} and {@link GlobeTranslucency#backFaceAlphaByDistance} for back faces.\n   * When the camera is underground back faces and front faces are swapped, i.e. back-facing geometry\n   * is considered front facing.\n   * <br /><br />\n   * Translucency is disabled by default.\n   *\n   * @memberof GlobeTranslucency.prototype\n   *\n   * @type {Boolean}\n   * @default false\n   *\n   * @see GlobeTranslucency#frontFaceAlpha\n   * @see GlobeTranslucency#frontFaceAlphaByDistance\n   * @see GlobeTranslucency#backFaceAlpha\n   * @see GlobeTranslucency#backFaceAlphaByDistance\n   */\n  enabled: {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.bool(\"enabled\", value);\n      //>>includeEnd('debug');\n      this._enabled = value;\n    },\n  },\n\n  /**\n   * A constant translucency to apply to front faces of the globe.\n   * <br /><br />\n   * {@link GlobeTranslucency#enabled} must be set to true for this option to take effect.\n   *\n   * @memberof GlobeTranslucency.prototype\n   *\n   * @type {Number}\n   * @default 1.0\n   *\n   * @see GlobeTranslucency#enabled\n   * @see GlobeTranslucency#frontFaceAlphaByDistance\n   *\n   * @example\n   * // Set front face translucency to 0.5.\n   * globe.translucency.frontFaceAlpha = 0.5;\n   * globe.translucency.enabled = true;\n   */\n  frontFaceAlpha: {\n    get: function () {\n      return this._frontFaceAlpha;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"frontFaceAlpha\", value, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"frontFaceAlpha\", value, 1.0);\n      //>>includeEnd('debug');\n      this._frontFaceAlpha = value;\n    },\n  },\n  /**\n   * Gets or sets near and far translucency properties of front faces of the globe based on the distance to the camera.\n   * The translucency will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the translucency remains clamped to the nearest bound.  If undefined,\n   * frontFaceAlphaByDistance will be disabled.\n   * <br /><br />\n   * {@link GlobeTranslucency#enabled} must be set to true for this option to take effect.\n   *\n   * @memberof GlobeTranslucency.prototype\n   *\n   * @type {NearFarScalar}\n   * @default undefined\n   *\n   * @see GlobeTranslucency#enabled\n   * @see GlobeTranslucency#frontFaceAlpha\n   *\n   * @example\n   * // Example 1.\n   * // Set front face translucency to 0.5 when the\n   * // camera is 1500 meters from the surface and 1.0\n   * // as the camera distance approaches 8.0e6 meters.\n   * globe.translucency.frontFaceAlphaByDistance = new Cesium.NearFarScalar(1.5e2, 0.5, 8.0e6, 1.0);\n   * globe.translucency.enabled = true;\n   *\n   * @example\n   * // Example 2.\n   * // Disable front face translucency by distance\n   * globe.translucency.frontFaceAlphaByDistance = undefined;\n   */\n  frontFaceAlphaByDistance: {\n    get: function () {\n      return this._frontFaceAlphaByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far < value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n      this._frontFaceAlphaByDistance = NearFarScalar.clone(\n        value,\n        this._frontFaceAlphaByDistance\n      );\n    },\n  },\n\n  /**\n   * A constant translucency to apply to back faces of the globe.\n   * <br /><br />\n   * {@link GlobeTranslucency#enabled} must be set to true for this option to take effect.\n   *\n   * @memberof GlobeTranslucency.prototype\n   *\n   * @type {Number}\n   * @default 1.0\n   *\n   * @see GlobeTranslucency#enabled\n   * @see GlobeTranslucency#backFaceAlphaByDistance\n   *\n   * @example\n   * // Set back face translucency to 0.5.\n   * globe.translucency.backFaceAlpha = 0.5;\n   * globe.translucency.enabled = true;\n   */\n  backFaceAlpha: {\n    get: function () {\n      return this._backFaceAlpha;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.number.greaterThanOrEquals(\"backFaceAlpha\", value, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"backFaceAlpha\", value, 1.0);\n      //>>includeEnd('debug');\n      this._backFaceAlpha = value;\n    },\n  },\n  /**\n   * Gets or sets near and far translucency properties of back faces of the globe based on the distance to the camera.\n   * The translucency will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the translucency remains clamped to the nearest bound.  If undefined,\n   * backFaceAlphaByDistance will be disabled.\n   * <br /><br />\n   * {@link GlobeTranslucency#enabled} must be set to true for this option to take effect.\n   *\n   * @memberof GlobeTranslucency.prototype\n   *\n   * @type {NearFarScalar}\n   * @default undefined\n   *\n   * @see GlobeTranslucency#enabled\n   * @see GlobeTranslucency#backFaceAlpha\n   *\n   * @example\n   * // Example 1.\n   * // Set back face translucency to 0.5 when the\n   * // camera is 1500 meters from the surface and 1.0\n   * // as the camera distance approaches 8.0e6 meters.\n   * globe.translucency.backFaceAlphaByDistance = new Cesium.NearFarScalar(1.5e2, 0.5, 8.0e6, 1.0);\n   * globe.translucency.enabled = true;\n   *\n   * @example\n   * // Example 2.\n   * // Disable back face translucency by distance\n   * globe.translucency.backFaceAlphaByDistance = undefined;\n   */\n  backFaceAlphaByDistance: {\n    get: function () {\n      return this._backFaceAlphaByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far < value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n      this._backFaceAlphaByDistance = NearFarScalar.clone(\n        value,\n        this._backFaceAlphaByDistance\n      );\n    },\n  },\n\n  /**\n   * A property specifying a {@link Rectangle} used to limit translucency to a cartographic area.\n   * Defaults to the maximum extent of cartographic coordinates.\n   *\n   * @memberof GlobeTranslucency.prototype\n   *\n   * @type {Rectangle}\n   * @default {@link Rectangle.MAX_VALUE}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n    set: function (value) {\n      if (!defined(value)) {\n        value = Rectangle.clone(Rectangle.MAX_VALUE);\n      }\n      Rectangle.clone(value, this._rectangle);\n    },\n  },\n});\n\nexport default GlobeTranslucency;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport PassThroughDepth from \"../Shaders/PostProcessStages/PassThroughDepth.js\";\n\n/**\n * @private\n */\nfunction GlobeTranslucencyFramebuffer() {\n  this._framebuffer = new FramebufferManager({\n    depthStencil: true,\n    supportsDepthTexture: true,\n  });\n  this._packedDepthFramebuffer = new FramebufferManager();\n\n  this._renderState = undefined;\n\n  this._packedDepthCommand = undefined;\n  this._clearCommand = undefined;\n\n  this._viewport = new BoundingRectangle();\n  this._useScissorTest = false;\n  this._scissorRectangle = undefined;\n  this._useHdr = undefined;\n}\n\nObject.defineProperties(GlobeTranslucencyFramebuffer.prototype, {\n  // Exposed for testing\n  classificationTexture: {\n    get: function () {\n      return this._framebuffer.getColorTexture();\n    },\n  },\n  classificationFramebuffer: {\n    get: function () {\n      return this._framebuffer.framebuffer;\n    },\n  },\n  // Exposed for testing\n  packedDepthFramebuffer: {\n    get: function () {\n      return this._packedDepthFramebuffer.framebuffer;\n    },\n  },\n  depthStencilTexture: {\n    get: function () {\n      return this._framebuffer.getDepthStencilTexture();\n    },\n  },\n  // Exposed for testing\n  depthStencilRenderbuffer: {\n    get: function () {\n      return this._framebuffer.getDepthStencilRenderbuffer();\n    },\n  },\n  packedDepthTexture: {\n    get: function () {\n      return this._packedDepthFramebuffer.getColorTexture();\n    },\n  },\n});\n\nfunction destroyResources(globeTranslucency) {\n  globeTranslucency._framebuffer.destroy();\n  globeTranslucency._packedDepthFramebuffer.destroy();\n}\n\nfunction updateResources(globeTranslucency, context, width, height, hdr) {\n  const pixelDatatype = hdr\n    ? context.halfFloatingPointTexture\n      ? PixelDatatype.HALF_FLOAT\n      : PixelDatatype.FLOAT\n    : PixelDatatype.UNSIGNED_BYTE;\n  globeTranslucency._framebuffer.update(\n    context,\n    width,\n    height,\n    1,\n    pixelDatatype\n  );\n  globeTranslucency._packedDepthFramebuffer.update(context, width, height);\n}\n\nfunction updateCommands(globeTranslucency, context, width, height, passState) {\n  globeTranslucency._viewport.width = width;\n  globeTranslucency._viewport.height = height;\n\n  const useScissorTest = !BoundingRectangle.equals(\n    globeTranslucency._viewport,\n    passState.viewport\n  );\n  let updateScissor = useScissorTest !== globeTranslucency._useScissorTest;\n  globeTranslucency._useScissorTest = useScissorTest;\n\n  if (\n    !BoundingRectangle.equals(\n      globeTranslucency._scissorRectangle,\n      passState.viewport\n    )\n  ) {\n    globeTranslucency._scissorRectangle = BoundingRectangle.clone(\n      passState.viewport,\n      globeTranslucency._scissorRectangle\n    );\n    updateScissor = true;\n  }\n\n  if (\n    !defined(globeTranslucency._renderState) ||\n    !BoundingRectangle.equals(\n      globeTranslucency._viewport,\n      globeTranslucency._renderState.viewport\n    ) ||\n    updateScissor\n  ) {\n    globeTranslucency._renderState = RenderState.fromCache({\n      viewport: globeTranslucency._viewport,\n      scissorTest: {\n        enabled: globeTranslucency._useScissorTest,\n        rectangle: globeTranslucency._scissorRectangle,\n      },\n    });\n  }\n\n  if (!defined(globeTranslucency._packedDepthCommand)) {\n    globeTranslucency._packedDepthCommand = context.createViewportQuadCommand(\n      PassThroughDepth,\n      {\n        uniformMap: {\n          u_depthTexture: function () {\n            return globeTranslucency.depthStencilTexture;\n          },\n        },\n        owner: globeTranslucency,\n      }\n    );\n  }\n\n  if (!defined(globeTranslucency._clearCommand)) {\n    globeTranslucency._clearCommand = new ClearCommand({\n      color: new Color(0.0, 0.0, 0.0, 0.0),\n      depth: 1.0,\n      stencil: 0.0,\n      owner: globeTranslucency,\n    });\n  }\n\n  globeTranslucency._packedDepthCommand.framebuffer =\n    globeTranslucency._packedDepthFramebuffer.framebuffer;\n  globeTranslucency._packedDepthCommand.renderState =\n    globeTranslucency._renderState;\n  globeTranslucency._clearCommand.framebuffer =\n    globeTranslucency.classificationFramebuffer;\n  globeTranslucency._clearCommand.renderState = globeTranslucency._renderState;\n}\n\nGlobeTranslucencyFramebuffer.prototype.updateAndClear = function (\n  hdr,\n  viewport,\n  context,\n  passState\n) {\n  const width = viewport.width;\n  const height = viewport.height;\n\n  updateResources(this, context, width, height, hdr);\n  updateCommands(this, context, width, height, passState);\n\n  this._useHdr = hdr;\n};\n\nGlobeTranslucencyFramebuffer.prototype.clearClassification = function (\n  context,\n  passState\n) {\n  this._clearCommand.execute(context, passState);\n};\n\nGlobeTranslucencyFramebuffer.prototype.packDepth = function (\n  context,\n  passState\n) {\n  this._packedDepthCommand.execute(context, passState);\n  return this.packedDepthTexture;\n};\n\nGlobeTranslucencyFramebuffer.prototype.isDestroyed = function () {\n  return false;\n};\n\nGlobeTranslucencyFramebuffer.prototype.destroy = function () {\n  destroyResources(this);\n  return destroyObject(this);\n};\n\nexport default GlobeTranslucencyFramebuffer;\n","import combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nconst DerivedCommandType = {\n  OPAQUE_FRONT_FACE: 0,\n  OPAQUE_BACK_FACE: 1,\n  DEPTH_ONLY_FRONT_FACE: 2,\n  DEPTH_ONLY_BACK_FACE: 3,\n  DEPTH_ONLY_FRONT_AND_BACK_FACE: 4,\n  TRANSLUCENT_FRONT_FACE: 5,\n  TRANSLUCENT_BACK_FACE: 6,\n  TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST: 7,\n  TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST: 8,\n  PICK_FRONT_FACE: 9,\n  PICK_BACK_FACE: 10,\n  DERIVED_COMMANDS_MAXIMUM_LENGTH: 11,\n};\n\nconst derivedCommandsMaximumLength =\n  DerivedCommandType.DERIVED_COMMANDS_MAXIMUM_LENGTH;\n\nconst DerivedCommandNames = [\n  \"opaqueFrontFaceCommand\",\n  \"opaqueBackFaceCommand\",\n  \"depthOnlyFrontFaceCommand\",\n  \"depthOnlyBackFaceCommand\",\n  \"depthOnlyFrontAndBackFaceCommand\",\n  \"translucentFrontFaceCommand\",\n  \"translucentBackFaceCommand\",\n  \"translucentFrontFaceManualDepthTestCommand\",\n  \"translucentBackFaceManualDepthTestCommand\",\n  \"pickFrontFaceCommand\",\n  \"pickBackFaceCommand\",\n];\n\n/**\n * @private\n */\nfunction GlobeTranslucencyState() {\n  this._frontFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n  this._backFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n\n  this._frontFaceTranslucent = false;\n  this._backFaceTranslucent = false;\n  this._requiresManualDepthTest = false;\n  this._sunVisibleThroughGlobe = false;\n  this._environmentVisible = false;\n  this._useDepthPlane = false;\n  this._numberOfTextureUniforms = 0;\n  this._globeTranslucencyFramebuffer = undefined;\n  this._rectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n\n  this._derivedCommandKey = 0;\n  this._derivedCommandsDirty = false;\n  this._derivedCommandPacks = undefined;\n\n  this._derivedCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedBlendCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedPickCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedCommandTypesToUpdate = new Array(derivedCommandsMaximumLength);\n\n  this._derivedCommandsLength = 0;\n  this._derivedBlendCommandsLength = 0;\n  this._derivedPickCommandsLength = 0;\n  this._derivedCommandsToUpdateLength = 0;\n}\n\nObject.defineProperties(GlobeTranslucencyState.prototype, {\n  frontFaceAlphaByDistance: {\n    get: function () {\n      return this._frontFaceAlphaByDistance;\n    },\n  },\n  backFaceAlphaByDistance: {\n    get: function () {\n      return this._backFaceAlphaByDistance;\n    },\n  },\n  translucent: {\n    get: function () {\n      return this._frontFaceTranslucent;\n    },\n  },\n  sunVisibleThroughGlobe: {\n    get: function () {\n      return this._sunVisibleThroughGlobe;\n    },\n  },\n  environmentVisible: {\n    get: function () {\n      return this._environmentVisible;\n    },\n  },\n  useDepthPlane: {\n    get: function () {\n      return this._useDepthPlane;\n    },\n  },\n  numberOfTextureUniforms: {\n    get: function () {\n      return this._numberOfTextureUniforms;\n    },\n  },\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n});\n\nGlobeTranslucencyState.prototype.update = function (scene) {\n  const globe = scene.globe;\n  if (!defined(globe) || !globe.show) {\n    this._frontFaceTranslucent = false;\n    this._backFaceTranslucent = false;\n    this._sunVisibleThroughGlobe = true;\n    this._environmentVisible = true;\n    this._useDepthPlane = false;\n    return;\n  }\n\n  this._frontFaceAlphaByDistance = updateAlphaByDistance(\n    globe.translucency.enabled,\n    globe.translucency.frontFaceAlpha,\n    globe.translucency.frontFaceAlphaByDistance,\n    this._frontFaceAlphaByDistance\n  );\n  this._backFaceAlphaByDistance = updateAlphaByDistance(\n    globe.translucency.enabled,\n    globe.translucency.backFaceAlpha,\n    globe.translucency.backFaceAlphaByDistance,\n    this._backFaceAlphaByDistance\n  );\n\n  this._frontFaceTranslucent = isFaceTranslucent(\n    globe.translucency.enabled,\n    this._frontFaceAlphaByDistance,\n    globe\n  );\n  this._backFaceTranslucent = isFaceTranslucent(\n    globe.translucency.enabled,\n    this._backFaceAlphaByDistance,\n    globe\n  );\n\n  this._requiresManualDepthTest = requiresManualDepthTest(this, scene, globe);\n\n  this._sunVisibleThroughGlobe = isSunVisibleThroughGlobe(this, scene);\n  this._environmentVisible = isEnvironmentVisible(this, scene);\n  this._useDepthPlane = useDepthPlane(this, scene);\n  this._numberOfTextureUniforms = getNumberOfTextureUniforms(this);\n\n  this._rectangle = Rectangle.clone(\n    globe.translucency.rectangle,\n    this._rectangle\n  );\n\n  gatherDerivedCommandRequirements(this, scene);\n};\n\nfunction updateAlphaByDistance(enabled, alpha, alphaByDistance, result) {\n  if (!enabled) {\n    result.nearValue = 1.0;\n    result.farValue = 1.0;\n    return result;\n  }\n\n  if (!defined(alphaByDistance)) {\n    result.nearValue = alpha;\n    result.farValue = alpha;\n    return result;\n  }\n\n  NearFarScalar.clone(alphaByDistance, result);\n  result.nearValue *= alpha;\n  result.farValue *= alpha;\n  return result;\n}\n\nfunction isFaceTranslucent(translucencyEnabled, alphaByDistance, globe) {\n  return (\n    translucencyEnabled &&\n    (globe.baseColor.alpha < 1.0 ||\n      alphaByDistance.nearValue < 1.0 ||\n      alphaByDistance.farValue < 1.0)\n  );\n}\n\nfunction isSunVisibleThroughGlobe(state, scene) {\n  // The sun is visible through the globe if the front and back faces are translucent when above ground\n  // or if front faces are translucent when below ground\n  const frontTranslucent = state._frontFaceTranslucent;\n  const backTranslucent = state._backFaceTranslucent;\n  return frontTranslucent && (scene.cameraUnderground || backTranslucent);\n}\n\nfunction isEnvironmentVisible(state, scene) {\n  // The environment is visible if the camera is above ground or underground with translucency\n  return !scene.cameraUnderground || state._frontFaceTranslucent;\n}\n\nfunction useDepthPlane(state, scene) {\n  // Use the depth plane when the camera is above ground and the globe is opaque\n  return !scene.cameraUnderground && !state._frontFaceTranslucent;\n}\n\nfunction requiresManualDepthTest(state, scene, globe) {\n  return (\n    state._frontFaceTranslucent &&\n    !state._backFaceTranslucent &&\n    !globe.depthTestAgainstTerrain &&\n    scene.mode !== SceneMode.SCENE2D &&\n    scene.context.depthTexture\n  );\n}\n\nfunction getNumberOfTextureUniforms(state) {\n  let numberOfTextureUniforms = 0;\n\n  if (state._frontFaceTranslucent) {\n    ++numberOfTextureUniforms; // classification texture\n  }\n\n  if (state._requiresManualDepthTest) {\n    ++numberOfTextureUniforms; // czm_globeDepthTexture for manual depth testing\n  }\n\n  return numberOfTextureUniforms;\n}\n\nfunction gatherDerivedCommandRequirements(state, scene) {\n  state._derivedCommandsLength = getDerivedCommandTypes(\n    state,\n    scene,\n    false,\n    false,\n    state._derivedCommandTypes\n  );\n\n  state._derivedBlendCommandsLength = getDerivedCommandTypes(\n    state,\n    scene,\n    true,\n    false,\n    state._derivedBlendCommandTypes\n  );\n\n  state._derivedPickCommandsLength = getDerivedCommandTypes(\n    state,\n    scene,\n    false,\n    true,\n    state._derivedPickCommandTypes\n  );\n\n  let i;\n\n  let derivedCommandKey = 0;\n  for (i = 0; i < state._derivedCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedCommandTypes[i];\n  }\n  for (i = 0; i < state._derivedBlendCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedBlendCommandTypes[i];\n  }\n  for (i = 0; i < state._derivedPickCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedPickCommandTypes[i];\n  }\n\n  let derivedCommandsToUpdateLength = 0;\n  for (i = 0; i < derivedCommandsMaximumLength; ++i) {\n    if ((derivedCommandKey & (1 << i)) > 0) {\n      state._derivedCommandTypesToUpdate[derivedCommandsToUpdateLength++] = i;\n    }\n  }\n  state._derivedCommandsToUpdateLength = derivedCommandsToUpdateLength;\n\n  const derivedCommandsDirty = derivedCommandKey !== state._derivedCommandKey;\n  state._derivedCommandKey = derivedCommandKey;\n  state._derivedCommandsDirty = derivedCommandsDirty;\n\n  if (!defined(state._derivedCommandPacks) && state._frontFaceTranslucent) {\n    state._derivedCommandPacks = createDerivedCommandPacks();\n  }\n}\n\nfunction getDerivedCommandTypes(\n  state,\n  scene,\n  isBlendCommand,\n  isPickCommand,\n  types\n) {\n  let length = 0;\n\n  const frontTranslucent = state._frontFaceTranslucent;\n  const backTranslucent = state._backFaceTranslucent;\n\n  if (!frontTranslucent) {\n    // Don't use derived commands if the globe is opaque\n    return length;\n  }\n\n  const cameraUnderground = scene.cameraUnderground;\n  const requiresManualDepthTest = state._requiresManualDepthTest;\n\n  const translucentFrontFaceCommandType = isPickCommand\n    ? DerivedCommandType.PICK_FRONT_FACE\n    : requiresManualDepthTest\n    ? DerivedCommandType.TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST\n    : DerivedCommandType.TRANSLUCENT_FRONT_FACE;\n\n  const translucentBackFaceCommandType = isPickCommand\n    ? DerivedCommandType.PICK_BACK_FACE\n    : requiresManualDepthTest\n    ? DerivedCommandType.TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST\n    : DerivedCommandType.TRANSLUCENT_BACK_FACE;\n\n  if (scene.mode === SceneMode.SCENE2D) {\n    types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n    types[length++] = translucentFrontFaceCommandType;\n    return length;\n  }\n\n  if (backTranslucent) {\n    // Push depth-only command for classification. Blend commands do not need to write depth.\n    // Push translucent commands for front and back faces.\n    if (!isBlendCommand) {\n      types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE;\n    }\n    if (cameraUnderground) {\n      types[length++] = translucentFrontFaceCommandType;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      types[length++] = translucentBackFaceCommandType;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  } else {\n    // Push opaque command for the face that appears in back.\n    // Push depth-only command and translucent command for the face that appears in front.\n    // eslint-disable-next-line no-lonely-if\n    if (cameraUnderground) {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_BACK_FACE;\n      }\n      types[length++] = DerivedCommandType.OPAQUE_FRONT_FACE;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n      }\n      types[length++] = DerivedCommandType.OPAQUE_BACK_FACE;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  }\n\n  return length;\n}\n\nfunction removeDefine(defines, defineToRemove) {\n  const index = defines.indexOf(defineToRemove);\n  if (index > -1) {\n    defines.splice(index, 1);\n  }\n}\n\nfunction hasDefine(defines, define) {\n  return defines.indexOf(define) > -1;\n}\n\nfunction getOpaqueFrontFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\n\nfunction getOpaqueBackFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\n\nfunction getDepthOnlyShaderProgram(vs, fs) {\n  if (\n    hasDefine(fs.defines, \"TILE_LIMIT_RECTANGLE\") ||\n    hasDefine(fs.defines, \"ENABLE_CLIPPING_PLANES\")\n  ) {\n    // Need to execute the full shader if discard is called\n    return;\n  }\n\n  const depthOnlyShader =\n    \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = vec4(1.0); \\n\" + \"} \\n\";\n\n  fs.sources = [depthOnlyShader];\n}\n\nfunction getTranslucentShaderProgram(vs, fs) {\n  const sources = fs.sources;\n  const length = sources.length;\n  for (let i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(\n      sources[i],\n      \"czm_globe_translucency_main\"\n    );\n  }\n\n  const globeTranslucencyMain =\n    \"\\n\\n\" +\n    \"uniform sampler2D u_classificationTexture; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" +\n    \"#ifdef MANUAL_DEPTH_TEST \\n\" +\n    \"    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st)); \\n\" +\n    \"    if (logDepthOrDepth != 0.0) \\n\" +\n    \"    { \\n\" +\n    \"        vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); \\n\" +\n    \"        float depthEC = eyeCoordinate.z / eyeCoordinate.w; \\n\" +\n    \"        if (v_positionEC.z < depthEC) \\n\" +\n    \"        { \\n\" +\n    \"            discard; \\n\" +\n    \"        } \\n\" +\n    \"    } \\n\" +\n    \"#endif \\n\" +\n    \"    czm_globe_translucency_main(); \\n\" +\n    \"    vec4 classificationColor = texture2D(u_classificationTexture, st); \\n\" +\n    \"    if (classificationColor.a > 0.0) \\n\" +\n    \"    { \\n\" +\n    \"        // Reverse premultiplication process to get the correct composited result of the classification primitives \\n\" +\n    \"        classificationColor.rgb /= classificationColor.a; \\n\" +\n    \"    } \\n\" +\n    \"    gl_FragColor = classificationColor * vec4(classificationColor.aaa, 1.0) + gl_FragColor * (1.0 - classificationColor.a); \\n\" +\n    \"} \\n\";\n\n  sources.push(globeTranslucencyMain);\n}\n\nfunction getTranslucentBackFaceShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n}\n\nfunction getTranslucentFrontFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\n\nfunction getTranslucentBackFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentBackFaceShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\n\nfunction getPickShaderProgram(vs, fs) {\n  const pickShader =\n    \"uniform sampler2D u_classificationTexture; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" +\n    \"    vec4 pickColor = texture2D(u_classificationTexture, st); \\n\" +\n    \"    if (pickColor == vec4(0.0)) \\n\" +\n    \"    { \\n\" +\n    \"        discard; \\n\" +\n    \"    } \\n\" +\n    \"    gl_FragColor = pickColor; \\n\" +\n    \"} \\n\";\n\n  fs.sources = [pickShader];\n}\n\nfunction getDerivedShaderProgram(\n  context,\n  shaderProgram,\n  derivedShaderProgram,\n  shaderProgramDirty,\n  getShaderProgramFunction,\n  cacheName\n) {\n  if (!defined(getShaderProgramFunction)) {\n    return shaderProgram;\n  }\n\n  if (!shaderProgramDirty && defined(derivedShaderProgram)) {\n    return derivedShaderProgram;\n  }\n\n  let shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    cacheName\n  );\n  if (!defined(shader)) {\n    const attributeLocations = shaderProgram._attributeLocations;\n    const vs = shaderProgram.vertexShaderSource.clone();\n    const fs = shaderProgram.fragmentShaderSource.clone();\n    vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n\n    getShaderProgramFunction(vs, fs);\n\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      cacheName,\n      {\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nfunction getOpaqueFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n}\n\nfunction getOpaqueBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n}\n\nfunction getDepthOnlyFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n}\n\nfunction getDepthOnlyBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n}\n\nfunction getDepthOnlyFrontAndBackFaceRenderState(renderState) {\n  renderState.cull.enabled = false;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n}\n\nfunction getTranslucentFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\n\nfunction getTranslucentBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\n\nfunction getPickFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\n\nfunction getPickBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\n\nfunction getDerivedRenderState(\n  renderState,\n  derivedRenderState,\n  renderStateDirty,\n  getRenderStateFunction,\n  cache\n) {\n  if (!defined(getRenderStateFunction)) {\n    return renderState;\n  }\n\n  if (!renderStateDirty && defined(derivedRenderState)) {\n    return derivedRenderState;\n  }\n\n  let cachedRenderState = cache[renderState.id];\n  if (!defined(cachedRenderState)) {\n    const rs = RenderState.getState(renderState);\n    getRenderStateFunction(rs);\n    cachedRenderState = RenderState.fromCache(rs);\n    cache[renderState.id] = cachedRenderState;\n  }\n\n  return cachedRenderState;\n}\n\nfunction getTranslucencyUniformMap(state) {\n  return {\n    u_classificationTexture: function () {\n      return state._globeTranslucencyFramebuffer.classificationTexture;\n    },\n  };\n}\n\nfunction getDerivedUniformMap(\n  state,\n  uniformMap,\n  derivedUniformMap,\n  uniformMapDirty,\n  getDerivedUniformMapFunction\n) {\n  if (!defined(getDerivedUniformMapFunction)) {\n    return uniformMap;\n  }\n\n  if (!uniformMapDirty && defined(derivedUniformMap)) {\n    return derivedUniformMap;\n  }\n\n  return combine(uniformMap, getDerivedUniformMapFunction(state), false);\n}\n\nfunction DerivedCommandPack(options) {\n  this.pass = options.pass;\n  this.pickOnly = options.pickOnly;\n  this.getShaderProgramFunction = options.getShaderProgramFunction;\n  this.getRenderStateFunction = options.getRenderStateFunction;\n  this.getUniformMapFunction = options.getUniformMapFunction;\n  this.renderStateCache = {};\n}\n\nfunction createDerivedCommandPacks() {\n  return [\n    // opaqueFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getOpaqueFrontFaceShaderProgram,\n      getRenderStateFunction: getOpaqueFrontFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // opaqueBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getOpaqueBackFaceShaderProgram,\n      getRenderStateFunction: getOpaqueBackFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // depthOnlyFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getDepthOnlyShaderProgram,\n      getRenderStateFunction: getDepthOnlyFrontFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // depthOnlyBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getDepthOnlyShaderProgram,\n      getRenderStateFunction: getDepthOnlyBackFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // depthOnlyFrontAndBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getDepthOnlyShaderProgram,\n      getRenderStateFunction: getDepthOnlyFrontAndBackFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // translucentFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentShaderProgram,\n      getRenderStateFunction: getTranslucentFrontFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // translucentBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentBackFaceShaderProgram,\n      getRenderStateFunction: getTranslucentBackFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // translucentFrontFaceManualDepthTestCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentFrontFaceManualDepthTestShaderProgram,\n      getRenderStateFunction: getTranslucentFrontFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // translucentBackFaceManualDepthTestCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentBackFaceManualDepthTestShaderProgram,\n      getRenderStateFunction: getTranslucentBackFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // pickFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: true,\n      getShaderProgramFunction: getPickShaderProgram,\n      getRenderStateFunction: getPickFrontFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // pickBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: true,\n      getShaderProgramFunction: getPickShaderProgram,\n      getRenderStateFunction: getPickBackFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n  ];\n}\n\nconst derivedCommandNames = new Array(derivedCommandsMaximumLength);\nconst derivedCommandPacks = new Array(derivedCommandsMaximumLength);\n\nGlobeTranslucencyState.prototype.updateDerivedCommands = function (\n  command,\n  frameState\n) {\n  const derivedCommandTypes = this._derivedCommandTypesToUpdate;\n  const derivedCommandsLength = this._derivedCommandsToUpdateLength;\n\n  if (derivedCommandsLength === 0) {\n    return;\n  }\n\n  for (let i = 0; i < derivedCommandsLength; ++i) {\n    derivedCommandPacks[i] = this._derivedCommandPacks[derivedCommandTypes[i]];\n    derivedCommandNames[i] = DerivedCommandNames[derivedCommandTypes[i]];\n  }\n\n  updateDerivedCommands(\n    this,\n    command,\n    derivedCommandsLength,\n    derivedCommandTypes,\n    derivedCommandNames,\n    derivedCommandPacks,\n    frameState\n  );\n};\n\nfunction updateDerivedCommands(\n  state,\n  command,\n  derivedCommandsLength,\n  derivedCommandTypes,\n  derivedCommandNames,\n  derivedCommandPacks,\n  frameState\n) {\n  let derivedCommandsObject = command.derivedCommands.globeTranslucency;\n  const derivedCommandsDirty = state._derivedCommandsDirty;\n\n  if (\n    command.dirty ||\n    !defined(derivedCommandsObject) ||\n    derivedCommandsDirty\n  ) {\n    command.dirty = false;\n\n    if (!defined(derivedCommandsObject)) {\n      derivedCommandsObject = {};\n      command.derivedCommands.globeTranslucency = derivedCommandsObject;\n    }\n\n    const frameNumber = frameState.frameNumber;\n\n    const uniformMapDirtyFrame = defaultValue(\n      derivedCommandsObject.uniformMapDirtyFrame,\n      0\n    );\n    const shaderProgramDirtyFrame = defaultValue(\n      derivedCommandsObject.shaderProgramDirtyFrame,\n      0\n    );\n    const renderStateDirtyFrame = defaultValue(\n      derivedCommandsObject.renderStateDirtyFrame,\n      0\n    );\n\n    const uniformMapDirty =\n      derivedCommandsObject.uniformMap !== command.uniformMap;\n\n    const shaderProgramDirty =\n      derivedCommandsObject.shaderProgramId !== command.shaderProgram.id;\n\n    const renderStateDirty =\n      derivedCommandsObject.renderStateId !== command.renderState.id;\n\n    if (uniformMapDirty) {\n      derivedCommandsObject.uniformMapDirtyFrame = frameNumber;\n    }\n    if (shaderProgramDirty) {\n      derivedCommandsObject.shaderProgramDirtyFrame = frameNumber;\n    }\n    if (renderStateDirty) {\n      derivedCommandsObject.renderStateDirtyFrame = frameNumber;\n    }\n\n    derivedCommandsObject.uniformMap = command.uniformMap;\n    derivedCommandsObject.shaderProgramId = command.shaderProgram.id;\n    derivedCommandsObject.renderStateId = command.renderState.id;\n\n    for (let i = 0; i < derivedCommandsLength; ++i) {\n      const derivedCommandPack = derivedCommandPacks[i];\n      const derivedCommandType = derivedCommandTypes[i];\n      const derivedCommandName = derivedCommandNames[i];\n      let derivedCommand = derivedCommandsObject[derivedCommandName];\n\n      let derivedUniformMap;\n      let derivedShaderProgram;\n      let derivedRenderState;\n\n      if (defined(derivedCommand)) {\n        derivedUniformMap = derivedCommand.uniformMap;\n        derivedShaderProgram = derivedCommand.shaderProgram;\n        derivedRenderState = derivedCommand.renderState;\n      } else {\n        derivedUniformMap = undefined;\n        derivedShaderProgram = undefined;\n        derivedRenderState = undefined;\n      }\n\n      derivedCommand = DrawCommand.shallowClone(command, derivedCommand);\n      derivedCommandsObject[derivedCommandName] = derivedCommand;\n\n      const derivedUniformMapDirtyFrame = defaultValue(\n        derivedCommand.derivedCommands.uniformMapDirtyFrame,\n        0\n      );\n      const derivedShaderProgramDirtyFrame = defaultValue(\n        derivedCommand.derivedCommands.shaderProgramDirtyFrame,\n        0\n      );\n      const derivedRenderStateDirtyFrame = defaultValue(\n        derivedCommand.derivedCommands.renderStateDirtyFrame,\n        0\n      );\n\n      const derivedUniformMapDirty =\n        uniformMapDirty || derivedUniformMapDirtyFrame < uniformMapDirtyFrame;\n      const derivedShaderProgramDirty =\n        shaderProgramDirty ||\n        derivedShaderProgramDirtyFrame < shaderProgramDirtyFrame;\n      const derivedRenderStateDirty =\n        renderStateDirty ||\n        derivedRenderStateDirtyFrame < renderStateDirtyFrame;\n\n      if (derivedUniformMapDirty) {\n        derivedCommand.derivedCommands.uniformMapDirtyFrame = frameNumber;\n      }\n      if (derivedShaderProgramDirty) {\n        derivedCommand.derivedCommands.shaderProgramDirtyFrame = frameNumber;\n      }\n      if (derivedRenderStateDirty) {\n        derivedCommand.derivedCommands.renderStateDirtyFrame = frameNumber;\n      }\n\n      derivedCommand.derivedCommands.type = derivedCommandType;\n      derivedCommand.pass = derivedCommandPack.pass;\n      derivedCommand.pickOnly = derivedCommandPack.pickOnly;\n      derivedCommand.uniformMap = getDerivedUniformMap(\n        state,\n        command.uniformMap,\n        derivedUniformMap,\n        derivedUniformMapDirty,\n        derivedCommandPack.getUniformMapFunction\n      );\n      derivedCommand.shaderProgram = getDerivedShaderProgram(\n        frameState.context,\n        command.shaderProgram,\n        derivedShaderProgram,\n        derivedShaderProgramDirty,\n        derivedCommandPack.getShaderProgramFunction,\n        derivedCommandName\n      );\n      derivedCommand.renderState = getDerivedRenderState(\n        command.renderState,\n        derivedRenderState,\n        derivedRenderStateDirty,\n        derivedCommandPack.getRenderStateFunction,\n        derivedCommandPack.renderStateCache\n      );\n    }\n  }\n}\n\nGlobeTranslucencyState.prototype.pushDerivedCommands = function (\n  command,\n  isBlendCommand,\n  frameState\n) {\n  const picking = frameState.passes.pick;\n  if (picking && isBlendCommand) {\n    // No need to push blend commands in the pick pass\n    return;\n  }\n\n  let derivedCommandTypes = this._derivedCommandTypes;\n  let derivedCommandsLength = this._derivedCommandsLength;\n\n  if (picking) {\n    derivedCommandTypes = this._derivedPickCommandTypes;\n    derivedCommandsLength = this._derivedPickCommandsLength;\n  } else if (isBlendCommand) {\n    derivedCommandTypes = this._derivedBlendCommandTypes;\n    derivedCommandsLength = this._derivedBlendCommandsLength;\n  }\n\n  if (derivedCommandsLength === 0) {\n    // No derived commands to push so just push the globe command\n    frameState.commandList.push(command);\n    return;\n  }\n\n  // Push derived commands\n  const derivedCommands = command.derivedCommands.globeTranslucency;\n  for (let i = 0; i < derivedCommandsLength; ++i) {\n    const derivedCommandName = DerivedCommandNames[derivedCommandTypes[i]];\n    frameState.commandList.push(derivedCommands[derivedCommandName]);\n  }\n};\n\nfunction executeCommandsMatchingType(\n  commands,\n  commandsLength,\n  executeCommandFunction,\n  scene,\n  context,\n  passState,\n  types\n) {\n  for (let i = 0; i < commandsLength; ++i) {\n    const command = commands[i];\n    const type = command.derivedCommands.type;\n    if (!defined(types) || types.indexOf(type) > -1) {\n      executeCommandFunction(command, scene, context, passState);\n    }\n  }\n}\n\nfunction executeCommands(\n  commands,\n  commandsLength,\n  executeCommandFunction,\n  scene,\n  context,\n  passState\n) {\n  for (let i = 0; i < commandsLength; ++i) {\n    executeCommandFunction(commands[i], scene, context, passState);\n  }\n}\n\nconst opaqueTypes = [\n  DerivedCommandType.OPAQUE_FRONT_FACE,\n  DerivedCommandType.OPAQUE_BACK_FACE,\n];\nconst depthOnlyTypes = [\n  DerivedCommandType.DEPTH_ONLY_FRONT_FACE,\n  DerivedCommandType.DEPTH_ONLY_BACK_FACE,\n  DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE,\n];\n\nGlobeTranslucencyState.prototype.executeGlobeCommands = function (\n  frustumCommands,\n  executeCommandFunction,\n  globeTranslucencyFramebuffer,\n  scene,\n  passState\n) {\n  const context = scene.context;\n  const globeCommands = frustumCommands.commands[Pass.GLOBE];\n  const globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n\n  if (globeCommandsLength === 0) {\n    return;\n  }\n\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n  globeTranslucencyFramebuffer.clearClassification(context, passState);\n\n  // Render opaque commands like normal\n  executeCommandsMatchingType(\n    globeCommands,\n    globeCommandsLength,\n    executeCommandFunction,\n    scene,\n    context,\n    passState,\n    opaqueTypes\n  );\n};\n\nGlobeTranslucencyState.prototype.executeGlobeClassificationCommands = function (\n  frustumCommands,\n  executeCommandFunction,\n  globeTranslucencyFramebuffer,\n  scene,\n  passState\n) {\n  const context = scene.context;\n  const globeCommands = frustumCommands.commands[Pass.GLOBE];\n  const globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n  const classificationCommands =\n    frustumCommands.commands[Pass.TERRAIN_CLASSIFICATION];\n  const classificationCommandsLength =\n    frustumCommands.indices[Pass.TERRAIN_CLASSIFICATION];\n\n  if (globeCommandsLength === 0 || classificationCommandsLength === 0) {\n    return;\n  }\n\n  const frontTranslucent = this._frontFaceTranslucent;\n  const backTranslucent = this._backFaceTranslucent;\n\n  if (!frontTranslucent || !backTranslucent) {\n    // Render classification on opaque faces like normal\n    executeCommands(\n      classificationCommands,\n      classificationCommandsLength,\n      executeCommandFunction,\n      scene,\n      context,\n      passState\n    );\n  }\n\n  if (!frontTranslucent && !backTranslucent) {\n    // No translucent commands to render. Skip translucent classification.\n    return;\n  }\n\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n\n  const originalGlobeDepthTexture = context.uniformState.globeDepthTexture;\n  const originalFramebuffer = passState.framebuffer;\n\n  // Render to internal framebuffer and get the first depth peel\n  passState.framebuffer =\n    globeTranslucencyFramebuffer.classificationFramebuffer;\n\n  executeCommandsMatchingType(\n    globeCommands,\n    globeCommandsLength,\n    executeCommandFunction,\n    scene,\n    context,\n    passState,\n    depthOnlyTypes\n  );\n\n  if (context.depthTexture) {\n    // Pack depth into separate texture for ground polylines and textured ground primitives\n    const packedDepthTexture = globeTranslucencyFramebuffer.packDepth(\n      context,\n      passState\n    );\n    context.uniformState.globeDepthTexture = packedDepthTexture;\n  }\n\n  // Render classification on translucent faces\n  executeCommands(\n    classificationCommands,\n    classificationCommandsLength,\n    executeCommandFunction,\n    scene,\n    context,\n    passState\n  );\n\n  // Unset temporary state\n  context.uniformState.globeDepthTexture = originalGlobeDepthTexture;\n  passState.framebuffer = originalFramebuffer;\n};\n\nexport default GlobeTranslucencyState;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport MeshoptDecoder from \"../ThirdParty/meshoptimizer.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads a glTF buffer view.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfBufferViewLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.bufferViewId The buffer view ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {String} [options.cacheKey] The cache key of the resource.\n *\n * @private\n */\nexport default function GltfBufferViewLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const bufferViewId = options.bufferViewId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const cacheKey = options.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.bufferViewId\", bufferViewId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const bufferView = gltf.bufferViews[bufferViewId];\n  let bufferId = bufferView.buffer;\n  let byteOffset = bufferView.byteOffset;\n  let byteLength = bufferView.byteLength;\n\n  let hasMeshopt = false;\n  let meshoptByteStride;\n  let meshoptCount;\n  let meshoptMode;\n  let meshoptFilter;\n\n  if (hasExtension(bufferView, \"EXT_meshopt_compression\")) {\n    const meshopt = bufferView.extensions.EXT_meshopt_compression;\n    bufferId = meshopt.buffer;\n    byteOffset = defaultValue(meshopt.byteOffset, 0);\n    byteLength = meshopt.byteLength;\n\n    hasMeshopt = true;\n    meshoptByteStride = meshopt.byteStride;\n    meshoptCount = meshopt.count;\n    meshoptMode = meshopt.mode;\n    meshoptFilter = defaultValue(meshopt.filter, \"NONE\");\n  }\n\n  const buffer = gltf.buffers[bufferId];\n\n  this._hasMeshopt = hasMeshopt;\n  this._meshoptByteStride = meshoptByteStride;\n  this._meshoptCount = meshoptCount;\n  this._meshoptMode = meshoptMode;\n  this._meshoptFilter = meshoptFilter;\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._buffer = buffer;\n  this._bufferId = bufferId;\n  this._byteOffset = byteOffset;\n  this._byteLength = byteLength;\n  this._cacheKey = cacheKey;\n  this._bufferLoader = undefined;\n  this._typedArray = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n  this._process = function (loader, frameState) {};\n}\n\nif (defined(Object.create)) {\n  GltfBufferViewLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfBufferViewLoader.prototype.constructor = GltfBufferViewLoader;\n}\n\nObject.defineProperties(GltfBufferViewLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof GltfBufferViewLoader.prototype\n   *\n   * @type {Promise.<GltfBufferViewLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfBufferViewLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The typed array containing buffer view data.\n   *\n   * @memberof GltfBufferViewLoader.prototype\n   *\n   * @type {Uint8Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfBufferViewLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfBufferViewLoader.prototype.load = function () {\n  const bufferLoader = getBufferLoader(this);\n  this._bufferLoader = bufferLoader;\n  this._state = ResourceLoaderState.LOADING;\n\n  const that = this;\n  const bufferViewPromise = new Promise(function (resolve) {\n    that._process = function (loader, frameState) {\n      if (!loader._hasMeshopt) {\n        return;\n      }\n\n      if (!defined(loader._typedArray)) {\n        return;\n      }\n\n      if (loader._state !== ResourceLoaderState.PROCESSING) {\n        return;\n      }\n\n      const count = loader._meshoptCount;\n      const byteStride = loader._meshoptByteStride;\n      const result = new Uint8Array(count * byteStride);\n      MeshoptDecoder.decodeGltfBuffer(\n        result,\n        count,\n        byteStride,\n        loader._typedArray,\n        loader._meshoptMode,\n        loader._meshoptFilter\n      );\n\n      loader._typedArray = result;\n      loader._state = ResourceLoaderState.READY;\n      resolve(loader);\n    };\n  });\n\n  this._promise = bufferLoader.promise\n    .then(function () {\n      if (that.isDestroyed()) {\n        return;\n      }\n      const bufferTypedArray = bufferLoader.typedArray;\n      const bufferViewTypedArray = new Uint8Array(\n        bufferTypedArray.buffer,\n        bufferTypedArray.byteOffset + that._byteOffset,\n        that._byteLength\n      );\n\n      // Unload the buffer\n      that.unload();\n\n      that._typedArray = bufferViewTypedArray;\n      if (that._hasMeshopt) {\n        that._state = ResourceLoaderState.PROCESSING;\n        return bufferViewPromise;\n      }\n\n      that._state = ResourceLoaderState.READY;\n      return that;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n      that.unload();\n      that._state = ResourceLoaderState.FAILED;\n      const errorMessage = \"Failed to load buffer view\";\n      return Promise.reject(that.getError(errorMessage, error));\n    });\n\n  return this._promise;\n};\n\nfunction getBufferLoader(bufferViewLoader) {\n  const resourceCache = bufferViewLoader._resourceCache;\n  const buffer = bufferViewLoader._buffer;\n  if (defined(buffer.uri)) {\n    const baseResource = bufferViewLoader._baseResource;\n    const resource = baseResource.getDerivedResource({\n      url: buffer.uri,\n    });\n    return resourceCache.loadExternalBuffer({\n      resource: resource,\n    });\n  }\n  return resourceCache.loadEmbeddedBuffer({\n    parentResource: bufferViewLoader._gltfResource,\n    bufferId: bufferViewLoader._bufferId,\n  });\n}\n\n/**\n * Processes the resources. For a BufferView that does not have the EXT_meshopt_compression extension, there\n * is no processing that needs to happen, so this function returns immediately.\n *\n * @param {FrameState} frameState The frame state.\n */\nGltfBufferViewLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  return this._process(this, frameState);\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfBufferViewLoader.prototype.unload = function () {\n  if (defined(this._bufferLoader)) {\n    this._resourceCache.unload(this._bufferLoader);\n  }\n\n  this._bufferLoader = undefined;\n  this._typedArray = undefined;\n};\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Load a draco buffer from a glTF.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfDracoLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {Object} options.gltf The glTF JSON.\n * @param {Object} options.draco The Draco extension object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {String} [options.cacheKey] The cache key of the resource.\n *\n * @private\n */\nexport default function GltfDracoLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const draco = options.draco;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const cacheKey = options.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.draco\", draco);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._draco = draco;\n  this._cacheKey = cacheKey;\n  this._bufferViewLoader = undefined;\n  this._bufferViewTypedArray = undefined;\n  this._decodePromise = undefined;\n  this._decodedData = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n  this._process = function (loader, frameState) {};\n}\n\nif (defined(Object.create)) {\n  GltfDracoLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfDracoLoader.prototype.constructor = GltfDracoLoader;\n}\n\nObject.defineProperties(GltfDracoLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready.\n   *\n   * @memberof GltfDracoLoader.prototype\n   *\n   * @type {Promise.<GltfDracoLoader>}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfDracoLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The decoded data.\n   *\n   * @memberof GltfDracoLoader.prototype\n   *\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  decodedData: {\n    get: function () {\n      return this._decodedData;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfDracoLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfDracoLoader.prototype.load = function () {\n  const resourceCache = this._resourceCache;\n  const bufferViewLoader = resourceCache.loadBufferView({\n    gltf: this._gltf,\n    bufferViewId: this._draco.bufferView,\n    gltfResource: this._gltfResource,\n    baseResource: this._baseResource,\n  });\n\n  this._bufferViewLoader = bufferViewLoader;\n  this._state = ResourceLoaderState.LOADING;\n  const that = this;\n  const dracoPromise = new Promise(function (resolve, reject) {\n    that._process = function (loader, frameState) {\n      if (!defined(loader._bufferViewTypedArray)) {\n        // Not ready to decode the Draco buffer\n        return;\n      }\n\n      if (defined(loader._decodePromise)) {\n        // Currently decoding\n        return;\n      }\n\n      const draco = loader._draco;\n      const gltf = loader._gltf;\n      const bufferViews = gltf.bufferViews;\n      const bufferViewId = draco.bufferView;\n      const bufferView = bufferViews[bufferViewId];\n      const compressedAttributes = draco.attributes;\n\n      const decodeOptions = {\n        // Need to make a copy of the typed array otherwise the underlying\n        // ArrayBuffer may be accessed on both the worker and the main thread. This\n        // leads to errors such as \"ArrayBuffer at index 0 is already detached\".\n        // PERFORMANCE_IDEA: Look into SharedArrayBuffer to get around this.\n        array: new Uint8Array(loader._bufferViewTypedArray),\n        bufferView: bufferView,\n        compressedAttributes: compressedAttributes,\n        dequantizeInShader: true,\n      };\n\n      const decodePromise = DracoLoader.decodeBufferView(decodeOptions);\n\n      if (!defined(decodePromise)) {\n        // Cannot schedule task this frame\n        return;\n      }\n\n      loader._decodePromise = decodePromise\n        .then(function (results) {\n          if (loader.isDestroyed()) {\n            resolve();\n            return;\n          }\n\n          // Unload everything except the decoded data\n          loader.unload();\n\n          loader._decodedData = {\n            indices: results.indexArray,\n            vertexAttributes: results.attributeData,\n          };\n          loader._state = ResourceLoaderState.READY;\n          resolve(loader);\n        })\n        .catch(function (e) {\n          if (loader.isDestroyed()) {\n            resolve();\n            return;\n          }\n\n          reject(e);\n        });\n    };\n  });\n\n  this._promise = bufferViewLoader.promise\n    .then(function () {\n      if (that.isDestroyed()) {\n        return;\n      }\n      // Now wait for process() to run to finish loading\n      that._bufferViewTypedArray = bufferViewLoader.typedArray;\n      that._state = ResourceLoaderState.PROCESSING;\n\n      return dracoPromise;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n\n      return handleError(that, error);\n    });\n\n  return this._promise;\n};\n\nfunction handleError(dracoLoader, error) {\n  dracoLoader.unload();\n  dracoLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load Draco\";\n  return Promise.reject(dracoLoader.getError(errorMessage, error));\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfDracoLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  return this._process(this, frameState);\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfDracoLoader.prototype.unload = function () {\n  if (defined(this._bufferViewLoader)) {\n    this._resourceCache.unload(this._bufferViewLoader);\n  }\n\n  this._bufferViewLoader = undefined;\n  this._bufferViewTypedArray = undefined;\n  this._decodedData = undefined;\n  this._gltf = undefined;\n};\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport loadImageFromTypedArray from \"../Core/loadImageFromTypedArray.js\";\nimport loadKTX2 from \"../Core/loadKTX2.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads a glTF image.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfImageLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.imageId The image ID.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {String} [options.cacheKey] The cache key of the resource.\n *\n * @private\n */\nexport default function GltfImageLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const imageId = options.imageId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const cacheKey = options.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.imageId\", imageId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  const image = gltf.images[imageId];\n  const bufferViewId = image.bufferView;\n  const uri = image.uri;\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._bufferViewId = bufferViewId;\n  this._uri = uri;\n  this._cacheKey = cacheKey;\n  this._bufferViewLoader = undefined;\n  this._image = undefined;\n  this._mipLevels = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfImageLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfImageLoader.prototype.constructor = GltfImageLoader;\n}\n\nObject.defineProperties(GltfImageLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof GltfImageLoader.prototype\n   *\n   * @type {Promise.<GltfImageLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfImageLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The image.\n   *\n   * @memberof GltfImageLoader.prototype\n   *\n   * @type {Image|ImageBitmap|CompressedTextureBuffer}\n   * @readonly\n   * @private\n   */\n  image: {\n    get: function () {\n      return this._image;\n    },\n  },\n  /**\n   * The mip levels. Only defined for KTX2 files containing mip levels.\n   *\n   * @memberof GltfImageLoader.prototype\n   *\n   * @type {Uint8Array[]}\n   * @readonly\n   * @private\n   */\n  mipLevels: {\n    get: function () {\n      return this._mipLevels;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfImageLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfImageLoader.prototype.load = function () {\n  if (defined(this._bufferViewId)) {\n    this._promise = loadFromBufferView(this);\n    return this._promise;\n  }\n\n  this._promise = loadFromUri(this);\n  return this._promise;\n};\n\nfunction getImageAndMipLevels(image) {\n  // Images transcoded from KTX2 can contain multiple mip levels:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n  let mipLevels;\n  if (Array.isArray(image)) {\n    // highest detail mip should be level 0\n    mipLevels = image.slice(1, image.length).map(function (mipLevel) {\n      return mipLevel.bufferView;\n    });\n    image = image[0];\n  }\n  return {\n    image: image,\n    mipLevels: mipLevels,\n  };\n}\n\nfunction loadFromBufferView(imageLoader) {\n  const resourceCache = imageLoader._resourceCache;\n  const bufferViewLoader = resourceCache.loadBufferView({\n    gltf: imageLoader._gltf,\n    bufferViewId: imageLoader._bufferViewId,\n    gltfResource: imageLoader._gltfResource,\n    baseResource: imageLoader._baseResource,\n  });\n\n  imageLoader._bufferViewLoader = bufferViewLoader;\n  imageLoader._state = ResourceLoaderState.LOADING;\n\n  return bufferViewLoader.promise\n    .then(function () {\n      if (imageLoader.isDestroyed()) {\n        return;\n      }\n\n      const typedArray = bufferViewLoader.typedArray;\n      return loadImageFromBufferTypedArray(typedArray).then(function (image) {\n        if (imageLoader.isDestroyed()) {\n          return;\n        }\n\n        const imageAndMipLevels = getImageAndMipLevels(image);\n\n        // Unload everything except the image\n        imageLoader.unload();\n\n        imageLoader._image = imageAndMipLevels.image;\n        imageLoader._mipLevels = imageAndMipLevels.mipLevels;\n        imageLoader._state = ResourceLoaderState.READY;\n        return imageLoader;\n      });\n    })\n    .catch(function (error) {\n      if (imageLoader.isDestroyed()) {\n        return;\n      }\n      return handleError(imageLoader, error, \"Failed to load embedded image\");\n    });\n}\n\nfunction loadFromUri(imageLoader) {\n  const baseResource = imageLoader._baseResource;\n  const uri = imageLoader._uri;\n  const resource = baseResource.getDerivedResource({\n    url: uri,\n  });\n  imageLoader._state = ResourceLoaderState.LOADING;\n  return loadImageFromUri(resource)\n    .then(function (image) {\n      if (imageLoader.isDestroyed()) {\n        return;\n      }\n\n      const imageAndMipLevels = getImageAndMipLevels(image);\n\n      // Unload everything except the image\n      imageLoader.unload();\n\n      imageLoader._image = imageAndMipLevels.image;\n      imageLoader._mipLevels = imageAndMipLevels.mipLevels;\n      imageLoader._state = ResourceLoaderState.READY;\n      return imageLoader;\n    })\n    .catch(function (error) {\n      if (imageLoader.isDestroyed()) {\n        return;\n      }\n      return handleError(imageLoader, error, `Failed to load image: ${uri}`);\n    });\n}\n\nfunction handleError(imageLoader, error, errorMessage) {\n  imageLoader.unload();\n  imageLoader._state = ResourceLoaderState.FAILED;\n  return Promise.reject(imageLoader.getError(errorMessage, error));\n}\n\nfunction getMimeTypeFromTypedArray(typedArray) {\n  const header = typedArray.subarray(0, 2);\n  const webpHeaderRIFFChars = typedArray.subarray(0, 4);\n  const webpHeaderWEBPChars = typedArray.subarray(8, 12);\n\n  if (header[0] === 0xff && header[1] === 0xd8) {\n    // See https://en.wikipedia.org/wiki/JPEG_File_Interchange_Format\n    return \"image/jpeg\";\n  } else if (header[0] === 0x89 && header[1] === 0x50) {\n    // See http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html\n    return \"image/png\";\n  } else if (header[0] === 0xab && header[1] === 0x4b) {\n    // See http://github.khronos.org/KTX-Specification/#_identifier\n    return \"image/ktx2\";\n  } else if (\n    // See https://developers.google.com/speed/webp/docs/riff_container#webp_file_header\n    webpHeaderRIFFChars[0] === 0x52 &&\n    webpHeaderRIFFChars[1] === 0x49 &&\n    webpHeaderRIFFChars[2] === 0x46 &&\n    webpHeaderRIFFChars[3] === 0x46 &&\n    webpHeaderWEBPChars[0] === 0x57 &&\n    webpHeaderWEBPChars[1] === 0x45 &&\n    webpHeaderWEBPChars[2] === 0x42 &&\n    webpHeaderWEBPChars[3] === 0x50\n  ) {\n    return \"image/webp\";\n  }\n\n  throw new RuntimeError(\"Image format is not recognized\");\n}\n\nfunction loadImageFromBufferTypedArray(typedArray) {\n  const mimeType = getMimeTypeFromTypedArray(typedArray);\n  if (mimeType === \"image/ktx2\") {\n    // Need to make a copy of the embedded KTX2 buffer otherwise the underlying\n    // ArrayBuffer may be accessed on both the worker and the main thread and\n    // throw an error like \"Cannot perform Construct on a detached ArrayBuffer\".\n    // Look into SharedArrayBuffer at some point to get around this.\n    const ktxBuffer = new Uint8Array(typedArray);\n\n    // Resolves to a CompressedTextureBuffer\n    return loadKTX2(ktxBuffer);\n  }\n  // Resolves to an Image or ImageBitmap\n  return GltfImageLoader._loadImageFromTypedArray({\n    uint8Array: typedArray,\n    format: mimeType,\n    flipY: false,\n    skipColorSpaceConversion: true,\n  });\n}\n\nconst ktx2Regex = /(^data:image\\/ktx2)|(\\.ktx2$)/i;\n\nfunction loadImageFromUri(resource) {\n  const uri = resource.url;\n  if (ktx2Regex.test(uri)) {\n    // Resolves to a CompressedTextureBuffer\n    return loadKTX2(resource);\n  }\n  // Resolves to an ImageBitmap or Image\n  return resource.fetchImage({\n    skipColorSpaceConversion: true,\n    preferImageBitmap: true,\n  });\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfImageLoader.prototype.unload = function () {\n  if (defined(this._bufferViewLoader)) {\n    this._resourceCache.unload(this._bufferViewLoader);\n  }\n\n  this._bufferViewLoader = undefined;\n  this._uri = undefined; // Free in case the uri is a data uri\n  this._image = undefined;\n  this._mipLevels = undefined;\n  this._gltf = undefined;\n};\n\n// Exposed for testing\nGltfImageLoader._loadImageFromTypedArray = loadImageFromTypedArray;\n","import Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport JobType from \"./JobType.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads an index buffer from a glTF accessor.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfIndexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.accessorId The accessor ID corresponding to the index buffer.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Object} [options.draco] The Draco extension object.\n * @param {String} [options.cacheKey] The cache key of the resource.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {Boolean} [options.loadBuffer=false] Load the index buffer as a GPU index buffer.\n * @param {Boolean} [options.loadTypedArray=false] Load the index buffer as a typed array.\n * @private\n */\nexport default function GltfIndexBufferLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const accessorId = options.accessorId;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const draco = options.draco;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.accessorId\", accessorId);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const indexDatatype = gltf.accessors[accessorId].componentType;\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._accessorId = accessorId;\n  this._indexDatatype = indexDatatype;\n  this._draco = draco;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n  this._process = function (loader, frameState) {};\n}\n\nif (defined(Object.create)) {\n  GltfIndexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfIndexBufferLoader.prototype.constructor = GltfIndexBufferLoader;\n}\n\nObject.defineProperties(GltfIndexBufferLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource has not yet started loading.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Promise.<GltfIndexBufferLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The index buffer. This is only defined when <code>loadBuffer</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    },\n  },\n  /**\n   * The typed array containing indices. This is only defined when <code>loadTypedArray</code> is true.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    },\n  },\n\n  /**\n   * The index datatype after decode.\n   *\n   * @memberof GltfIndexBufferLoader.prototype\n   *\n   * @type {IndexDatatype}\n   * @readonly\n   * @private\n   */\n  indexDatatype: {\n    get: function () {\n      return this._indexDatatype;\n    },\n  },\n});\n\nconst scratchIndexBufferJob = new CreateIndexBufferJob();\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfIndexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfIndexBufferLoader.prototype.load = function () {\n  let promise;\n\n  if (defined(this._draco)) {\n    promise = loadFromDraco(this);\n  } else {\n    promise = loadFromBufferView(this);\n  }\n\n  const that = this;\n  const processPromise = new Promise(function (resolve) {\n    that._process = function (loader, frameState) {\n      if (loader._state === ResourceLoaderState.READY) {\n        return;\n      }\n\n      const typedArray = loader._typedArray;\n      const indexDatatype = loader._indexDatatype;\n\n      if (defined(loader._dracoLoader)) {\n        loader._dracoLoader.process(frameState);\n      }\n\n      if (defined(loader._bufferViewLoader)) {\n        loader._bufferViewLoader.process(frameState);\n      }\n\n      if (!defined(typedArray)) {\n        // Buffer view hasn't been loaded yet\n        return;\n      }\n\n      let buffer;\n      if (loader._loadBuffer && loader._asynchronous) {\n        const indexBufferJob = scratchIndexBufferJob;\n        indexBufferJob.set(typedArray, indexDatatype, frameState.context);\n        const jobScheduler = frameState.jobScheduler;\n        if (!jobScheduler.execute(indexBufferJob, JobType.BUFFER)) {\n          // Job scheduler is full. Try again next frame.\n          return;\n        }\n        buffer = indexBufferJob.buffer;\n      } else if (loader._loadBuffer) {\n        buffer = createIndexBuffer(\n          typedArray,\n          indexDatatype,\n          frameState.context\n        );\n      }\n\n      // Unload everything except the index buffer\n      loader.unload();\n\n      loader._buffer = buffer;\n      loader._typedArray = loader._loadTypedArray ? typedArray : undefined;\n      loader._state = ResourceLoaderState.READY;\n      resolve(loader);\n    };\n  });\n\n  this._promise = promise\n    .then(function () {\n      if (that.isDestroyed()) {\n        return;\n      }\n\n      return processPromise;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n\n      return handleError(that, error);\n    });\n\n  return this._promise;\n};\n\nfunction loadFromDraco(indexBufferLoader) {\n  const resourceCache = indexBufferLoader._resourceCache;\n  const dracoLoader = resourceCache.loadDraco({\n    gltf: indexBufferLoader._gltf,\n    draco: indexBufferLoader._draco,\n    gltfResource: indexBufferLoader._gltfResource,\n    baseResource: indexBufferLoader._baseResource,\n  });\n\n  indexBufferLoader._dracoLoader = dracoLoader;\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n\n  return dracoLoader.promise.then(function () {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n    // Now wait for process() to run to finish loading\n    const typedArray = dracoLoader.decodedData.indices.typedArray;\n    indexBufferLoader._typedArray = typedArray;\n    // The index datatype may be a smaller datatype after draco decode\n    indexBufferLoader._indexDatatype = ComponentDatatype.fromTypedArray(\n      typedArray\n    );\n    indexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return indexBufferLoader;\n  });\n}\n\nfunction loadFromBufferView(indexBufferLoader) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n\n  const resourceCache = indexBufferLoader._resourceCache;\n  const bufferViewLoader = resourceCache.loadBufferView({\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: indexBufferLoader._gltfResource,\n    baseResource: indexBufferLoader._baseResource,\n  });\n  indexBufferLoader._state = ResourceLoaderState.LOADING;\n  indexBufferLoader._bufferViewLoader = bufferViewLoader;\n\n  return bufferViewLoader.promise.then(function () {\n    if (indexBufferLoader.isDestroyed()) {\n      return;\n    }\n\n    // Now wait for process() to run to finish loading\n    const bufferViewTypedArray = bufferViewLoader.typedArray;\n    indexBufferLoader._typedArray = createIndicesTypedArray(\n      indexBufferLoader,\n      bufferViewTypedArray\n    );\n    indexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return indexBufferLoader;\n  });\n}\n\nfunction createIndicesTypedArray(indexBufferLoader, bufferViewTypedArray) {\n  const gltf = indexBufferLoader._gltf;\n  const accessorId = indexBufferLoader._accessorId;\n  const accessor = gltf.accessors[accessorId];\n  const count = accessor.count;\n  const indexDatatype = accessor.componentType;\n\n  const arrayBuffer = bufferViewTypedArray.buffer;\n  const byteOffset = bufferViewTypedArray.byteOffset + accessor.byteOffset;\n\n  let typedArray;\n  if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {\n    typedArray = new Uint8Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {\n    typedArray = new Uint16Array(arrayBuffer, byteOffset, count);\n  } else if (indexDatatype === IndexDatatype.UNSIGNED_INT) {\n    typedArray = new Uint32Array(arrayBuffer, byteOffset, count);\n  }\n\n  return typedArray;\n}\n\nfunction handleError(indexBufferLoader, error) {\n  indexBufferLoader.unload();\n  indexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load index buffer\";\n  error = indexBufferLoader.getError(errorMessage, error);\n  return Promise.reject(error);\n}\n\nfunction CreateIndexBufferJob() {\n  this.typedArray = undefined;\n  this.indexDatatype = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\n\nCreateIndexBufferJob.prototype.set = function (\n  typedArray,\n  indexDatatype,\n  context\n) {\n  this.typedArray = typedArray;\n  this.indexDatatype = indexDatatype;\n  this.context = context;\n};\n\nCreateIndexBufferJob.prototype.execute = function () {\n  this.buffer = createIndexBuffer(\n    this.typedArray,\n    this.indexDatatype,\n    this.context\n  );\n};\n\nfunction createIndexBuffer(typedArray, indexDatatype, context) {\n  const buffer = Buffer.createIndexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfIndexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  return this._process(this, frameState);\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfIndexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n\n  const resourceCache = this._resourceCache;\n\n  if (defined(this._bufferViewLoader)) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n};\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport getMagic from \"../Core/getMagic.js\";\nimport isDataUri from \"../Core/isDataUri.js\";\nimport Resource from \"../Core/Resource.js\";\nimport addDefaults from \"./GltfPipeline/addDefaults.js\";\nimport addPipelineExtras from \"./GltfPipeline/addPipelineExtras.js\";\nimport ForEach from \"./GltfPipeline/ForEach.js\";\nimport parseGlb from \"./GltfPipeline/parseGlb.js\";\nimport removePipelineExtras from \"./GltfPipeline/removePipelineExtras.js\";\nimport updateVersion from \"./GltfPipeline/updateVersion.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads a glTF JSON from a glTF or glb.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfJsonLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Uint8Array} [options.typedArray] The typed array containing the glTF contents.\n * @param {Object} [options.gltfJson] The parsed glTF JSON contents.\n * @param {String} [options.cacheKey] The cache key of the resource.\n *\n * @private\n */\nexport default function GltfJsonLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const typedArray = options.typedArray;\n  const gltfJson = options.gltfJson;\n  const cacheKey = options.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  //>>includeEnd('debug');\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._typedArray = typedArray;\n  this._gltfJson = gltfJson;\n  this._cacheKey = cacheKey;\n  this._gltf = undefined;\n  this._bufferLoaders = [];\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfJsonLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfJsonLoader.prototype.constructor = GltfJsonLoader;\n}\n\nObject.defineProperties(GltfJsonLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof GltfJsonLoader.prototype\n   *\n   * @type {Promise.<GltfJsonLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfJsonLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The glTF JSON.\n   *\n   * @memberof GltfJsonLoader.prototype\n   *\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  gltf: {\n    get: function () {\n      return this._gltf;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfJsonLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfJsonLoader.prototype.load = function () {\n  this._state = ResourceLoaderState.LOADING;\n\n  let processPromise;\n  if (defined(this._gltfJson)) {\n    processPromise = processGltfJson(this, this._gltfJson);\n  } else if (defined(this._typedArray)) {\n    processPromise = processGltfTypedArray(this, this._typedArray);\n  } else {\n    processPromise = loadFromUri(this);\n  }\n\n  const that = this;\n  this._promise = processPromise\n    .then(function (gltf) {\n      if (that.isDestroyed()) {\n        return;\n      }\n      that._gltf = gltf;\n      that._state = ResourceLoaderState.READY;\n      return that;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n      return handleError(that, error);\n    });\n\n  return this._promise;\n};\n\nfunction loadFromUri(gltfJsonLoader) {\n  return gltfJsonLoader._fetchGltf().then(function (arrayBuffer) {\n    if (gltfJsonLoader.isDestroyed()) {\n      return;\n    }\n    const typedArray = new Uint8Array(arrayBuffer);\n    return processGltfTypedArray(gltfJsonLoader, typedArray);\n  });\n}\n\nfunction handleError(gltfJsonLoader, error) {\n  gltfJsonLoader.unload();\n  gltfJsonLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = `Failed to load glTF: ${gltfJsonLoader._gltfResource.url}`;\n  return Promise.reject(gltfJsonLoader.getError(errorMessage, error));\n}\n\nfunction upgradeVersion(gltfJsonLoader, gltf) {\n  if (gltf.asset.version === \"2.0\") {\n    return Promise.resolve();\n  }\n\n  // Load all buffers into memory. updateVersion will read and in some cases modify\n  // the buffer data, which it accesses from buffer.extras._pipeline.source\n  const promises = [];\n  ForEach.buffer(gltf, function (buffer) {\n    if (\n      !defined(buffer.extras._pipeline.source) && // Ignore uri if this buffer uses the glTF 1.0 KHR_binary_glTF extension\n      defined(buffer.uri)\n    ) {\n      const resource = gltfJsonLoader._baseResource.getDerivedResource({\n        url: buffer.uri,\n      });\n      const resourceCache = gltfJsonLoader._resourceCache;\n      const bufferLoader = resourceCache.loadExternalBuffer({\n        resource: resource,\n      });\n\n      gltfJsonLoader._bufferLoaders.push(bufferLoader);\n\n      promises.push(\n        bufferLoader.promise.then(function (bufferLoader) {\n          buffer.extras._pipeline.source = bufferLoader.typedArray;\n        })\n      );\n    }\n  });\n\n  return Promise.all(promises).then(function () {\n    updateVersion(gltf);\n  });\n}\n\nfunction decodeDataUris(gltf) {\n  const promises = [];\n  ForEach.buffer(gltf, function (buffer) {\n    const bufferUri = buffer.uri;\n    if (\n      !defined(buffer.extras._pipeline.source) && // Ignore uri if this buffer uses the glTF 1.0 KHR_binary_glTF extension\n      defined(bufferUri) &&\n      isDataUri(bufferUri)\n    ) {\n      delete buffer.uri; // Delete the data URI to keep the cached glTF JSON small\n      promises.push(\n        Resource.fetchArrayBuffer(bufferUri).then(function (arrayBuffer) {\n          buffer.extras._pipeline.source = new Uint8Array(arrayBuffer);\n        })\n      );\n    }\n  });\n  return Promise.all(promises);\n}\n\nfunction loadEmbeddedBuffers(gltfJsonLoader, gltf) {\n  const promises = [];\n  ForEach.buffer(gltf, function (buffer, bufferId) {\n    const source = buffer.extras._pipeline.source;\n    if (defined(source) && !defined(buffer.uri)) {\n      const resourceCache = gltfJsonLoader._resourceCache;\n      const bufferLoader = resourceCache.loadEmbeddedBuffer({\n        parentResource: gltfJsonLoader._gltfResource,\n        bufferId: bufferId,\n        typedArray: source,\n      });\n\n      gltfJsonLoader._bufferLoaders.push(bufferLoader);\n      promises.push(bufferLoader.promise);\n    }\n  });\n  return Promise.all(promises);\n}\n\nfunction processGltfJson(gltfJsonLoader, gltf) {\n  addPipelineExtras(gltf);\n\n  return decodeDataUris(gltf)\n    .then(function () {\n      return upgradeVersion(gltfJsonLoader, gltf);\n    })\n    .then(function () {\n      addDefaults(gltf);\n      return loadEmbeddedBuffers(gltfJsonLoader, gltf);\n    })\n    .then(function () {\n      removePipelineExtras(gltf);\n      return gltf;\n    });\n}\n\nfunction processGltfTypedArray(gltfJsonLoader, typedArray) {\n  let gltf;\n  if (getMagic(typedArray) === \"glTF\") {\n    gltf = parseGlb(typedArray);\n  } else {\n    gltf = getJsonFromTypedArray(typedArray);\n  }\n\n  return processGltfJson(gltfJsonLoader, gltf);\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfJsonLoader.prototype.unload = function () {\n  const bufferLoaders = this._bufferLoaders;\n  const bufferLoadersLength = bufferLoaders.length;\n  for (let i = 0; i < bufferLoadersLength; ++i) {\n    this._resourceCache.unload(bufferLoaders[i]);\n  }\n  this._bufferLoaders.length = 0;\n\n  this._gltf = undefined;\n};\n\n/**\n * Exposed for testing\n *\n * @private\n */\nGltfJsonLoader.prototype._fetchGltf = function () {\n  return this._gltfResource.fetchArrayBuffer();\n};\n","import arrayFill from \"../Core/arrayFill.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport InterpolationType from \"../Core/InterpolationType.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport getAccessorByteStride from \"./GltfPipeline/getAccessorByteStride.js\";\nimport getComponentReader from \"./GltfPipeline/getComponentReader.js\";\nimport numberOfComponentsForType from \"./GltfPipeline/numberOfComponentsForType.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport Axis from \"./Axis.js\";\nimport GltfStructuralMetadataLoader from \"./GltfStructuralMetadataLoader.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport InstanceAttributeSemantic from \"./InstanceAttributeSemantic.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport SupportedImageFormats from \"./SupportedImageFormats.js\";\nimport VertexAttributeSemantic from \"./VertexAttributeSemantic.js\";\n\nconst Attribute = ModelComponents.Attribute;\nconst Indices = ModelComponents.Indices;\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\nconst FeatureIdTexture = ModelComponents.FeatureIdTexture;\nconst FeatureIdImplicitRange = ModelComponents.FeatureIdImplicitRange;\nconst MorphTarget = ModelComponents.MorphTarget;\nconst Primitive = ModelComponents.Primitive;\nconst Instances = ModelComponents.Instances;\nconst Skin = ModelComponents.Skin;\nconst Node = ModelComponents.Node;\nconst AnimatedPropertyType = ModelComponents.AnimatedPropertyType;\nconst AnimationSampler = ModelComponents.AnimationSampler;\nconst AnimationTarget = ModelComponents.AnimationTarget;\nconst AnimationChannel = ModelComponents.AnimationChannel;\nconst Animation = ModelComponents.Animation;\nconst Asset = ModelComponents.Asset;\nconst Scene = ModelComponents.Scene;\nconst Components = ModelComponents.Components;\nconst MetallicRoughness = ModelComponents.MetallicRoughness;\nconst SpecularGlossiness = ModelComponents.SpecularGlossiness;\nconst Material = ModelComponents.Material;\n\nconst GltfLoaderState = {\n  UNLOADED: 0,\n  LOADING: 1,\n  LOADED: 2,\n  PROCESSING: 3,\n  PROCESSED: 4,\n  READY: 4,\n  FAILED: 5,\n};\n\n/**\n * Loads a glTF model.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF. This is often the path of the .gltf or .glb file, but may also be the path of the .b3dm, .i3dm, or .cmpt file containing the embedded glb. .cmpt resources should have a URI fragment indicating the index of the inner content to which the glb belongs in order to individually identify the glb in the cache, e.g. http://example.com/tile.cmpt#index=2.\n * @param {Resource} [options.baseResource] The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Uint8Array} [options.typedArray] The typed array containing the glTF contents, e.g. from a .b3dm, .i3dm, or .cmpt file.\n * @param {Object} [options.gltfJson] A parsed glTF JSON file instead of passing it in as a typed array.\n * @param {Boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the glTF is loaded.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.Z] The forward-axis of the glTF model.\n * @param {Boolean} [options.loadAttributesAsTypedArray=false] Load all attributes and indices as typed arrays instead of GPU buffers.\n * @param {Boolean} [options.loadPositionsFor2D=false] If true, load the positions buffer as a typed array for accurately projecting models to 2D.\n * @param {Boolean} [options.loadIndicesForWireframe=false] If true, load the index buffer as both a buffer and typed array. The latter is useful for creating wireframe indices in WebGL1.\n * @param {Boolean} [options.renameBatchIdSemantic=false] If true, rename _BATCHID or BATCHID to _FEATURE_ID_0. This is used for .b3dm models\n * @private\n */\nexport default function GltfLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltfResource = options.gltfResource;\n  let baseResource = options.baseResource;\n  const typedArray = options.typedArray;\n  const releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const incrementallyLoadTextures = defaultValue(\n    options.incrementallyLoadTextures,\n    true\n  );\n  const upAxis = defaultValue(options.upAxis, Axis.Y);\n  const forwardAxis = defaultValue(options.forwardAxis, Axis.Z);\n  const loadAttributesAsTypedArray = defaultValue(\n    options.loadAttributesAsTypedArray,\n    false\n  );\n  const loadPositionsFor2D = defaultValue(options.loadPositionsFor2D, false);\n  const loadIndicesForWireframe = defaultValue(\n    options.loadIndicesForWireframe,\n    false\n  );\n  const renameBatchIdSemantic = defaultValue(\n    options.renameBatchIdSemantic,\n    false\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  //>>includeEnd('debug');\n\n  baseResource = defined(baseResource) ? baseResource : gltfResource.clone();\n\n  this._gltfJson = options.gltfJson;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._typedArray = typedArray;\n  this._releaseGltfJson = releaseGltfJson;\n  this._asynchronous = asynchronous;\n  this._incrementallyLoadTextures = incrementallyLoadTextures;\n  this._upAxis = upAxis;\n  this._forwardAxis = forwardAxis;\n  this._loadAttributesAsTypedArray = loadAttributesAsTypedArray;\n  this._loadPositionsFor2D = loadPositionsFor2D;\n  this._loadIndicesForWireframe = loadIndicesForWireframe;\n  this._renameBatchIdSemantic = renameBatchIdSemantic;\n\n  // When loading EXT_feature_metadata, the feature tables and textures\n  // are now stored as arrays like the newer EXT_structural_metadata extension.\n  // This requires sorting the dictionary keys for a consistent ordering.\n  this._sortedPropertyTableIds = undefined;\n  this._sortedFeatureTextureIds = undefined;\n\n  this._gltfJsonLoader = undefined;\n  this._state = GltfLoaderState.UNLOADED;\n  this._textureState = GltfLoaderState.UNLOADED;\n  this._promise = undefined;\n  this._texturesLoadedPromise = undefined;\n  this._process = function (loader, frameState) {};\n  this._processTextures = function (loader, frameState) {};\n\n  // Loaders that need to be processed before the glTF becomes ready\n  this._loaderPromises = [];\n  this._textureLoaders = [];\n  this._texturesPromises = [];\n  this._bufferViewLoaders = [];\n  this._geometryLoaders = [];\n  this._structuralMetadataLoader = undefined;\n\n  // Loaded results\n  this._components = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfLoader.prototype.constructor = GltfLoader;\n}\n\nObject.defineProperties(GltfLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {Promise.<GltfLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The loaded components.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n\n  /**\n   * A promise that resolves when all textures are loaded.\n   * When <code>incrementallyLoadTextures</code> is true this may resolve after\n   * <code>promise</code> resolves.\n   *\n   * @memberof GltfLoader.prototype\n   *\n   * @type {Promise<void>}\n   * @readonly\n   * @private\n   */\n  texturesLoadedPromise: {\n    get: function () {\n      return this._texturesLoadedPromise;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfLoader.prototype.load = function () {\n  const gltfJsonLoader = ResourceCache.loadGltfJson({\n    gltfResource: this._gltfResource,\n    baseResource: this._baseResource,\n    typedArray: this._typedArray,\n    gltfJson: this._gltfJson,\n  });\n\n  this._gltfJsonLoader = gltfJsonLoader;\n  this._state = GltfLoaderState.LOADING;\n  this._textureState = GltfLoaderState.LOADING;\n\n  const that = this;\n  let textureProcessPromise;\n  const processPromise = new Promise(function (resolve, reject) {\n    textureProcessPromise = new Promise(function (\n      resolveTextures,\n      rejectTextures\n    ) {\n      that._process = function (loader, frameState) {\n        if (!FeatureDetection.supportsWebP.initialized) {\n          FeatureDetection.supportsWebP.initialize();\n          return;\n        }\n\n        if (loader._state === GltfLoaderState.LOADED) {\n          loader._state = GltfLoaderState.PROCESSING;\n\n          const supportedImageFormats = new SupportedImageFormats({\n            webp: FeatureDetection.supportsWebP(),\n            basis: frameState.context.supportsBasis,\n          });\n\n          let gltf;\n          if (defined(loader._gltfJsonLoader)) {\n            gltf = loader._gltfJsonLoader.gltf;\n          } else {\n            gltf = loader._gltfJson;\n          }\n\n          // Parse the glTF which populates the loaders arrays. The promise will\n          // resolve once all the loaders are ready (i.e. all external resources\n          // have been fetched and all GPU resources have been created). Loaders that\n          // create GPU resources need to be processed every frame until they become\n          // ready since the JobScheduler is not able to execute all jobs in a single\n          // frame. Also note that it's fine to call process before a loader is ready\n          // to process; nothing will happen.\n          parse(\n            loader,\n            gltf,\n            supportedImageFormats,\n            frameState,\n            reject,\n            rejectTextures\n          );\n\n          if (defined(loader._gltfJsonLoader) && loader._releaseGltfJson) {\n            // Check that the glTF JSON loader is still defined before trying to unload it.\n            // It may be undefined if the ready promise rejects immediately (which can happen in unit tests)\n            ResourceCache.unload(loader._gltfJsonLoader);\n            loader._gltfJsonLoader = undefined;\n          }\n        }\n\n        if (loader._state === GltfLoaderState.PROCESSING) {\n          processLoaders(loader, frameState);\n        }\n\n        if (loader._state === GltfLoaderState.PROCESSED) {\n          unloadBufferViews(loader); // Buffer views can be unloaded after the data has been copied\n          loader._state = GltfLoaderState.READY;\n          resolve(loader);\n        }\n      };\n\n      that._processTextures = function (loader, frameState) {\n        if (loader._textureState === GltfLoaderState.LOADED) {\n          loader._textureState = GltfLoaderState.PROCESSING;\n        }\n\n        if (loader._textureState === GltfLoaderState.PROCESSING) {\n          let i;\n          const textureLoaders = loader._textureLoaders;\n          const textureLoadersLength = textureLoaders.length;\n          for (i = 0; i < textureLoadersLength; ++i) {\n            textureLoaders[i].process(frameState);\n          }\n        }\n\n        if (loader._textureState === GltfLoaderState.PROCESSED) {\n          loader._textureState = GltfLoaderState.READY;\n          resolveTextures(loader);\n        }\n      };\n    });\n  });\n\n  this._promise = gltfJsonLoader.promise\n    .then(function () {\n      if (that.isDestroyed()) {\n        return;\n      }\n      that._state = GltfLoaderState.LOADED;\n      that._textureState = GltfLoaderState.LOADED;\n\n      return processPromise;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n      that._state = GltfLoaderState.FAILED;\n      that._textureState = GltfLoaderState.FAILED;\n      return handleError(that, error);\n    });\n\n  this._texturesLoadedPromise = textureProcessPromise.catch(function (error) {\n    if (that.isDestroyed()) {\n      return;\n    }\n\n    that._textureState = GltfLoaderState.FAILED;\n    return handleError(that, error);\n  });\n\n  return this._promise;\n};\n\nfunction handleError(gltfLoader, error) {\n  gltfLoader.unload();\n  const errorMessage = \"Failed to load glTF\";\n  error = gltfLoader.getError(errorMessage, error);\n  return Promise.reject(error);\n}\n\nfunction processLoaders(loader, frameState) {\n  let i;\n  const bufferViewLoaders = loader._bufferViewLoaders;\n  const bufferViewLoadersLength = bufferViewLoaders.length;\n  for (i = 0; i < bufferViewLoadersLength; ++i) {\n    bufferViewLoaders[i].process(frameState);\n  }\n\n  const geometryLoaders = loader._geometryLoaders;\n  const geometryLoadersLength = geometryLoaders.length;\n  for (i = 0; i < geometryLoadersLength; ++i) {\n    geometryLoaders[i].process(frameState);\n  }\n\n  if (defined(loader._structuralMetadataLoader)) {\n    loader._structuralMetadataLoader.process(frameState);\n  }\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  this._process(this, frameState);\n  // Since textures can be loaded independently and are handled through a separate promise, they are processed in their own function\n  this._processTextures(this, frameState);\n};\n\nfunction loadVertexBuffer(\n  loader,\n  gltf,\n  accessorId,\n  semantic,\n  draco,\n  dequantize,\n  loadAsTypedArray,\n  loadFor2D\n) {\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n\n  const loadBuffer = !loadAsTypedArray;\n  const loadTypedArray = loadAsTypedArray || loadFor2D;\n\n  const vertexBufferLoader = ResourceCache.loadVertexBuffer({\n    gltf: gltf,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    bufferViewId: bufferViewId,\n    draco: draco,\n    attributeSemantic: semantic,\n    accessorId: accessorId,\n    asynchronous: loader._asynchronous,\n    dequantize: dequantize,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  loader._geometryLoaders.push(vertexBufferLoader);\n\n  return vertexBufferLoader;\n}\n\nfunction loadIndexBuffer(loader, gltf, accessorId, draco, frameState) {\n  const loadAttributesAsTypedArray = loader._loadAttributesAsTypedArray;\n\n  // Load the index buffer as a typed array to generate wireframes in WebGL1.\n  const loadForWireframe =\n    loader._loadIndicesForWireframe && !frameState.context.webgl2;\n\n  const loadBuffer = !loadAttributesAsTypedArray;\n  const loadTypedArray = loadAttributesAsTypedArray || loadForWireframe;\n\n  const indexBufferLoader = ResourceCache.loadIndexBuffer({\n    gltf: gltf,\n    accessorId: accessorId,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    draco: draco,\n    asynchronous: loader._asynchronous,\n    loadBuffer: loadBuffer,\n    loadTypedArray: loadTypedArray,\n  });\n\n  loader._geometryLoaders.push(indexBufferLoader);\n\n  return indexBufferLoader;\n}\n\nfunction loadBufferView(loader, gltf, bufferViewId) {\n  const bufferViewLoader = ResourceCache.loadBufferView({\n    gltf: gltf,\n    bufferViewId: bufferViewId,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n  });\n\n  loader._bufferViewLoaders.push(bufferViewLoader);\n\n  return bufferViewLoader;\n}\n\nfunction getPackedTypedArray(gltf, accessor, bufferViewTypedArray) {\n  let byteOffset = accessor.byteOffset;\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  const count = accessor.count;\n  const componentCount = numberOfComponentsForType(accessor.type);\n  const componentType = accessor.componentType;\n  const componentByteLength = ComponentDatatype.getSizeInBytes(componentType);\n  const defaultByteStride = componentByteLength * componentCount;\n  const componentsLength = count * componentCount;\n\n  if (byteStride === defaultByteStride) {\n    // Copy the typed array and let the underlying ArrayBuffer be freed\n    bufferViewTypedArray = new Uint8Array(bufferViewTypedArray);\n    return ComponentDatatype.createArrayBufferView(\n      componentType,\n      bufferViewTypedArray.buffer,\n      bufferViewTypedArray.byteOffset + byteOffset,\n      componentsLength\n    );\n  }\n\n  const accessorTypedArray = ComponentDatatype.createTypedArray(\n    componentType,\n    componentsLength\n  );\n\n  const dataView = new DataView(bufferViewTypedArray.buffer);\n  const components = new Array(componentCount);\n  const componentReader = getComponentReader(accessor.componentType);\n  byteOffset = bufferViewTypedArray.byteOffset + byteOffset;\n\n  for (let i = 0; i < count; ++i) {\n    componentReader(\n      dataView,\n      byteOffset,\n      componentCount,\n      componentByteLength,\n      components\n    );\n    for (let j = 0; j < componentCount; ++j) {\n      accessorTypedArray[i * componentCount + j] = components[j];\n    }\n    byteOffset += byteStride;\n  }\n\n  return accessorTypedArray;\n}\n\nfunction loadDefaultAccessorValues(accessor, values) {\n  const accessorType = accessor.type;\n  if (accessorType === AttributeType.SCALAR) {\n    return arrayFill(values, 0);\n  }\n\n  const MathType = AttributeType.getMathType(accessorType);\n  return arrayFill(values, MathType.clone(MathType.ZERO));\n}\n\nfunction loadAccessorValues(accessor, packedTypedArray, values, useQuaternion) {\n  const accessorType = accessor.type;\n  const accessorCount = accessor.count;\n\n  if (accessorType === AttributeType.SCALAR) {\n    for (let i = 0; i < accessorCount; i++) {\n      values[i] = packedTypedArray[i];\n    }\n  } else if (accessorType === AttributeType.VEC4 && useQuaternion) {\n    for (let i = 0; i < accessorCount; i++) {\n      values[i] = Quaternion.unpack(packedTypedArray, i * 4);\n    }\n  } else {\n    const MathType = AttributeType.getMathType(accessorType);\n    const numberOfComponents = AttributeType.getNumberOfComponents(\n      accessorType\n    );\n\n    for (let i = 0; i < accessorCount; i++) {\n      values[i] = MathType.unpack(packedTypedArray, i * numberOfComponents);\n    }\n  }\n\n  return values;\n}\n\nfunction loadAccessor(loader, gltf, accessorId, useQuaternion) {\n  const accessor = gltf.accessors[accessorId];\n  const accessorCount = accessor.count;\n  const values = new Array(accessorCount);\n\n  const bufferViewId = accessor.bufferView;\n  if (defined(bufferViewId)) {\n    const bufferViewLoader = loadBufferView(loader, gltf, bufferViewId);\n    const promise = bufferViewLoader.promise\n      .then(function (bufferViewLoader) {\n        if (loader.isDestroyed()) {\n          return;\n        }\n        const bufferViewTypedArray = bufferViewLoader.typedArray;\n        const packedTypedArray = getPackedTypedArray(\n          gltf,\n          accessor,\n          bufferViewTypedArray\n        );\n\n        useQuaternion = defaultValue(useQuaternion, false);\n        loadAccessorValues(accessor, packedTypedArray, values, useQuaternion);\n      })\n      .catch(function () {\n        loadDefaultAccessorValues(accessor, values);\n      });\n    loader._loaderPromises.push(promise);\n\n    return values;\n  }\n\n  return loadDefaultAccessorValues(accessor, values);\n}\n\nfunction fromArray(MathType, values) {\n  if (!defined(values)) {\n    return undefined;\n  }\n\n  if (MathType === Number) {\n    return values[0];\n  }\n\n  return MathType.unpack(values);\n}\n\nfunction getDefault(MathType) {\n  if (MathType === Number) {\n    return 0.0;\n  }\n\n  return new MathType(); // defaults to 0.0 for all types\n}\n\nfunction createAttribute(gltf, accessorId, name, semantic, setIndex) {\n  const accessor = gltf.accessors[accessorId];\n  const MathType = AttributeType.getMathType(accessor.type);\n\n  const attribute = new Attribute();\n  attribute.name = name;\n  attribute.semantic = semantic;\n  attribute.setIndex = setIndex;\n  attribute.constant = getDefault(MathType);\n  attribute.componentDatatype = accessor.componentType;\n  attribute.normalized = defaultValue(accessor.normalized, false);\n  attribute.count = accessor.count;\n  attribute.type = accessor.type;\n  attribute.min = fromArray(MathType, accessor.min);\n  attribute.max = fromArray(MathType, accessor.max);\n  attribute.byteOffset = accessor.byteOffset;\n  attribute.byteStride = getAccessorByteStride(gltf, accessor);\n\n  return attribute;\n}\n\nfunction getSetIndex(gltfSemantic) {\n  const setIndexRegex = /^\\w+_(\\d+)$/;\n  const setIndexMatch = setIndexRegex.exec(gltfSemantic);\n  if (setIndexMatch !== null) {\n    return parseInt(setIndexMatch[1]);\n  }\n  return undefined;\n}\n\nfunction loadAttribute(\n  loader,\n  gltf,\n  accessorId,\n  semanticType,\n  gltfSemantic,\n  draco,\n  dequantize,\n  loadAsTypedArray,\n  loadAsTypedArrayPacked,\n  frameState\n) {\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n\n  // For .b3dm, rename _BATCHID (or the legacy BATCHID) to _FEATURE_ID_0\n  // in the generated model components for compatibility with EXT_mesh_features\n  let renamedSemantic = gltfSemantic;\n  if (\n    loader._renameBatchIdSemantic &&\n    (gltfSemantic === \"_BATCHID\" || gltfSemantic === \"BATCHID\")\n  ) {\n    renamedSemantic = \"_FEATURE_ID_0\";\n  }\n\n  const name = gltfSemantic;\n  const modelSemantic = semanticType.fromGltfSemantic(renamedSemantic);\n  const setIndex = defined(modelSemantic)\n    ? getSetIndex(renamedSemantic)\n    : undefined;\n  const attribute = createAttribute(\n    gltf,\n    accessorId,\n    name,\n    modelSemantic,\n    setIndex\n  );\n\n  if (!defined(draco) && !defined(bufferViewId)) {\n    return attribute;\n  }\n\n  const loadFor2D =\n    modelSemantic === VertexAttributeSemantic.POSITION &&\n    loader._loadPositionsFor2D &&\n    !frameState.scene3DOnly;\n\n  const vertexBufferLoader = loadVertexBuffer(\n    loader,\n    gltf,\n    accessorId,\n    gltfSemantic,\n    draco,\n    dequantize,\n    loadAsTypedArray,\n    loadFor2D\n  );\n  const promise = vertexBufferLoader.promise.then(function (\n    vertexBufferLoader\n  ) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    if (loadAsTypedArrayPacked) {\n      // The accessor's byteOffset and byteStride should be ignored since values\n      // are tightly packed in a typed array\n      const bufferViewTypedArray = vertexBufferLoader.typedArray;\n      attribute.packedTypedArray = getPackedTypedArray(\n        gltf,\n        accessor,\n        bufferViewTypedArray\n      );\n      attribute.byteOffset = 0;\n      attribute.byteStride = undefined;\n    } else {\n      attribute.typedArray = vertexBufferLoader.typedArray;\n      attribute.buffer = vertexBufferLoader.buffer;\n    }\n\n    if (\n      defined(draco) &&\n      defined(draco.attributes) &&\n      defined(draco.attributes[gltfSemantic])\n    ) {\n      // The accessor's byteOffset and byteStride should be ignored for draco.\n      // Each attribute is tightly packed in its own buffer after decode.\n      attribute.byteOffset = 0;\n      attribute.byteStride = undefined;\n      attribute.quantization = vertexBufferLoader.quantization;\n    }\n  });\n\n  loader._loaderPromises.push(promise);\n\n  return attribute;\n}\n\nfunction loadVertexAttribute(\n  loader,\n  gltf,\n  accessorId,\n  gltfSemantic,\n  draco,\n  frameState\n) {\n  return loadAttribute(\n    loader,\n    gltf,\n    accessorId,\n    VertexAttributeSemantic,\n    gltfSemantic,\n    draco,\n    false,\n    loader._loadAttributesAsTypedArray,\n    false,\n    frameState\n  );\n}\n\nfunction loadInstancedAttribute(\n  loader,\n  gltf,\n  accessorId,\n  gltfSemantic,\n  loadAsTypedArrayPacked\n) {\n  // Don't pass in draco object since instanced attributes can't be draco compressed\n  return loadAttribute(\n    loader,\n    gltf,\n    accessorId,\n    InstanceAttributeSemantic,\n    gltfSemantic,\n    undefined,\n    true,\n    loadAsTypedArrayPacked,\n    loadAsTypedArrayPacked\n  );\n}\n\nfunction loadIndices(loader, gltf, accessorId, draco, frameState) {\n  const accessor = gltf.accessors[accessorId];\n  const bufferViewId = accessor.bufferView;\n\n  if (!defined(draco) && !defined(bufferViewId)) {\n    return undefined;\n  }\n\n  const indices = new Indices();\n  indices.count = accessor.count;\n\n  const indexBufferLoader = loadIndexBuffer(\n    loader,\n    gltf,\n    accessorId,\n    draco,\n    frameState\n  );\n\n  const promise = indexBufferLoader.promise.then(function (indexBufferLoader) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n\n    indices.indexDatatype = indexBufferLoader.indexDatatype;\n\n    indices.buffer = indexBufferLoader.buffer;\n    indices.typedArray = indexBufferLoader.typedArray;\n  });\n\n  loader._loaderPromises.push(promise);\n\n  return indices;\n}\n\nfunction loadTexture(\n  loader,\n  gltf,\n  textureInfo,\n  supportedImageFormats,\n  samplerOverride\n) {\n  const imageId = GltfLoaderUtil.getImageIdFromTexture({\n    gltf: gltf,\n    textureId: textureInfo.index,\n    supportedImageFormats: supportedImageFormats,\n  });\n\n  if (!defined(imageId)) {\n    return undefined;\n  }\n\n  const textureLoader = ResourceCache.loadTexture({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    supportedImageFormats: supportedImageFormats,\n    asynchronous: loader._asynchronous,\n  });\n\n  loader._textureLoaders.push(textureLoader);\n\n  const textureReader = GltfLoaderUtil.createModelTextureReader({\n    textureInfo: textureInfo,\n  });\n\n  const promise = textureLoader.promise.then(function (textureLoader) {\n    if (loader.isDestroyed()) {\n      return;\n    }\n    textureReader.texture = textureLoader.texture;\n    if (defined(samplerOverride)) {\n      textureReader.texture.sampler = samplerOverride;\n    }\n  });\n\n  loader._texturesPromises.push(promise);\n\n  return textureReader;\n}\n\nfunction loadMaterial(loader, gltf, gltfMaterial, supportedImageFormats) {\n  const material = new Material();\n\n  const extensions = defaultValue(\n    gltfMaterial.extensions,\n    defaultValue.EMPTY_OBJECT\n  );\n  const pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness;\n  const pbrMetallicRoughness = gltfMaterial.pbrMetallicRoughness;\n\n  material.unlit = defined(extensions.KHR_materials_unlit);\n\n  if (defined(pbrSpecularGlossiness)) {\n    const specularGlossiness = new SpecularGlossiness();\n    material.specularGlossiness = specularGlossiness;\n\n    if (defined(pbrSpecularGlossiness.diffuseTexture)) {\n      specularGlossiness.diffuseTexture = loadTexture(\n        loader,\n        gltf,\n        pbrSpecularGlossiness.diffuseTexture,\n        supportedImageFormats\n      );\n    }\n    if (defined(pbrSpecularGlossiness.specularGlossinessTexture)) {\n      if (defined(pbrSpecularGlossiness.specularGlossinessTexture)) {\n        specularGlossiness.specularGlossinessTexture = loadTexture(\n          loader,\n          gltf,\n          pbrSpecularGlossiness.specularGlossinessTexture,\n          supportedImageFormats\n        );\n      }\n    }\n    specularGlossiness.diffuseFactor = fromArray(\n      Cartesian4,\n      pbrSpecularGlossiness.diffuseFactor\n    );\n    specularGlossiness.specularFactor = fromArray(\n      Cartesian3,\n      pbrSpecularGlossiness.specularFactor\n    );\n    specularGlossiness.glossinessFactor =\n      pbrSpecularGlossiness.glossinessFactor;\n    material.pbrSpecularGlossiness = pbrSpecularGlossiness;\n  } else if (defined(pbrMetallicRoughness)) {\n    const metallicRoughness = new MetallicRoughness();\n    material.metallicRoughness = metallicRoughness;\n\n    if (defined(pbrMetallicRoughness.baseColorTexture)) {\n      metallicRoughness.baseColorTexture = loadTexture(\n        loader,\n        gltf,\n        pbrMetallicRoughness.baseColorTexture,\n        supportedImageFormats\n      );\n    }\n    if (defined(pbrMetallicRoughness.metallicRoughnessTexture)) {\n      metallicRoughness.metallicRoughnessTexture = loadTexture(\n        loader,\n        gltf,\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        supportedImageFormats\n      );\n    }\n    metallicRoughness.baseColorFactor = fromArray(\n      Cartesian4,\n      pbrMetallicRoughness.baseColorFactor\n    );\n    metallicRoughness.metallicFactor = pbrMetallicRoughness.metallicFactor;\n    metallicRoughness.roughnessFactor = pbrMetallicRoughness.roughnessFactor;\n    material.pbrMetallicRoughness = pbrMetallicRoughness;\n  }\n\n  // Top level textures\n  if (defined(gltfMaterial.emissiveTexture)) {\n    material.emissiveTexture = loadTexture(\n      loader,\n      gltf,\n      gltfMaterial.emissiveTexture,\n      supportedImageFormats\n    );\n  }\n  if (defined(gltfMaterial.normalTexture)) {\n    material.normalTexture = loadTexture(\n      loader,\n      gltf,\n      gltfMaterial.normalTexture,\n      supportedImageFormats\n    );\n  }\n  if (defined(gltfMaterial.occlusionTexture)) {\n    material.occlusionTexture = loadTexture(\n      loader,\n      gltf,\n      gltfMaterial.occlusionTexture,\n      supportedImageFormats\n    );\n  }\n  material.emissiveFactor = fromArray(Cartesian3, gltfMaterial.emissiveFactor);\n  material.alphaMode = gltfMaterial.alphaMode;\n  material.alphaCutoff = gltfMaterial.alphaCutoff;\n  material.doubleSided = gltfMaterial.doubleSided;\n\n  return material;\n}\n\n// for EXT_mesh_features\nfunction loadFeatureIdAttribute(featureIds, positionalLabel) {\n  const featureIdAttribute = new FeatureIdAttribute();\n  featureIdAttribute.featureCount = featureIds.featureCount;\n  featureIdAttribute.nullFeatureId = featureIds.nullFeatureId;\n  featureIdAttribute.propertyTableId = featureIds.propertyTable;\n  featureIdAttribute.setIndex = featureIds.attribute;\n  featureIdAttribute.label = featureIds.label;\n  featureIdAttribute.positionalLabel = positionalLabel;\n  return featureIdAttribute;\n}\n\n// for backwards compatibility with EXT_feature_metadata\nfunction loadFeatureIdAttributeLegacy(\n  gltfFeatureIdAttribute,\n  featureTableId,\n  featureCount,\n  positionalLabel\n) {\n  const featureIdAttribute = new FeatureIdAttribute();\n  const featureIds = gltfFeatureIdAttribute.featureIds;\n  featureIdAttribute.featureCount = featureCount;\n  featureIdAttribute.propertyTableId = featureTableId;\n  featureIdAttribute.setIndex = getSetIndex(featureIds.attribute);\n  featureIdAttribute.positionalLabel = positionalLabel;\n  return featureIdAttribute;\n}\n\n// implicit ranges do not exist in EXT_mesh_features and EXT_instance_features,\n// but both default to the vertex/instance ID which is like\n// an implicit range of {offset: 0, repeat: 1}\nfunction loadDefaultFeatureIds(featureIds, positionalLabel) {\n  const featureIdRange = new FeatureIdImplicitRange();\n  featureIdRange.propertyTableId = featureIds.propertyTable;\n  featureIdRange.featureCount = featureIds.featureCount;\n  featureIdRange.nullFeatureId = featureIds.nullFeatureId;\n  featureIdRange.label = featureIds.label;\n  featureIdRange.positionalLabel = positionalLabel;\n  featureIdRange.offset = 0;\n  featureIdRange.repeat = 1;\n  return featureIdRange;\n}\n\n// for backwards compatibility with EXT_feature_metadata\nfunction loadFeatureIdImplicitRangeLegacy(\n  gltfFeatureIdAttribute,\n  featureTableId,\n  featureCount,\n  positionalLabel\n) {\n  const featureIdRange = new FeatureIdImplicitRange();\n  const featureIds = gltfFeatureIdAttribute.featureIds;\n  featureIdRange.propertyTableId = featureTableId;\n  featureIdRange.featureCount = featureCount;\n\n  // constant/divisor was renamed to offset/repeat\n  featureIdRange.offset = defaultValue(featureIds.constant, 0);\n  // The default is now undefined\n  const divisor = defaultValue(featureIds.divisor, 0);\n  featureIdRange.repeat = divisor === 0 ? undefined : divisor;\n\n  featureIdRange.positionalLabel = positionalLabel;\n  return featureIdRange;\n}\n\n// for EXT_mesh_features\nfunction loadFeatureIdTexture(\n  loader,\n  gltf,\n  gltfFeatureIdTexture,\n  supportedImageFormats,\n  positionalLabel\n) {\n  const featureIdTexture = new FeatureIdTexture();\n\n  featureIdTexture.featureCount = gltfFeatureIdTexture.featureCount;\n  featureIdTexture.nullFeatureId = gltfFeatureIdTexture.nullFeatureId;\n  featureIdTexture.propertyTableId = gltfFeatureIdTexture.propertyTable;\n  featureIdTexture.label = gltfFeatureIdTexture.label;\n  featureIdTexture.positionalLabel = positionalLabel;\n\n  const textureInfo = gltfFeatureIdTexture.texture;\n  featureIdTexture.textureReader = loadTexture(\n    loader,\n    gltf,\n    textureInfo,\n    supportedImageFormats,\n    Sampler.NEAREST // Feature ID textures require nearest sampling\n  );\n\n  // Though the new channel index is more future-proof, this implementation\n  // only supports RGBA textures. At least for now, the string representation\n  // is more useful for generating shader code.\n  const channelString = textureInfo.channels\n    .map(function (channelIndex) {\n      return \"rgba\".charAt(channelIndex);\n    })\n    .join(\"\");\n  featureIdTexture.textureReader.channels = channelString;\n\n  return featureIdTexture;\n}\n\n// for backwards compatibility with EXT_feature_metadata\nfunction loadFeatureIdTextureLegacy(\n  loader,\n  gltf,\n  gltfFeatureIdTexture,\n  featureTableId,\n  supportedImageFormats,\n  featureCount,\n  positionalLabel\n) {\n  const featureIdTexture = new FeatureIdTexture();\n  const featureIds = gltfFeatureIdTexture.featureIds;\n  const textureInfo = featureIds.texture;\n  featureIdTexture.featureCount = featureCount;\n  featureIdTexture.propertyTableId = featureTableId;\n  featureIdTexture.textureReader = loadTexture(\n    loader,\n    gltf,\n    textureInfo,\n    supportedImageFormats,\n    Sampler.NEAREST // Feature ID textures require nearest sampling\n  );\n\n  featureIdTexture.textureReader.channels = featureIds.channels;\n  featureIdTexture.positionalLabel = positionalLabel;\n\n  return featureIdTexture;\n}\n\nfunction loadMorphTarget(loader, gltf, target) {\n  const morphTarget = new MorphTarget();\n\n  for (const semantic in target) {\n    if (target.hasOwnProperty(semantic)) {\n      const accessorId = target[semantic];\n      morphTarget.attributes.push(\n        // Don't pass in draco object since morph targets can't be draco compressed\n        loadVertexAttribute(loader, gltf, accessorId, semantic, undefined)\n      );\n    }\n  }\n\n  return morphTarget;\n}\n\nfunction loadPrimitive(\n  loader,\n  gltf,\n  gltfPrimitive,\n  supportedImageFormats,\n  frameState\n) {\n  const primitive = new Primitive();\n\n  const materialId = gltfPrimitive.material;\n  if (defined(materialId)) {\n    primitive.material = loadMaterial(\n      loader,\n      gltf,\n      gltf.materials[materialId],\n      supportedImageFormats\n    );\n  }\n\n  const extensions = defaultValue(\n    gltfPrimitive.extensions,\n    defaultValue.EMPTY_OBJECT\n  );\n  const draco = extensions.KHR_draco_mesh_compression;\n\n  const attributes = gltfPrimitive.attributes;\n  if (defined(attributes)) {\n    for (const semantic in attributes) {\n      if (attributes.hasOwnProperty(semantic)) {\n        const accessorId = attributes[semantic];\n        primitive.attributes.push(\n          loadVertexAttribute(\n            loader,\n            gltf,\n            accessorId,\n            semantic,\n            draco,\n            frameState\n          )\n        );\n      }\n    }\n  }\n\n  const targets = gltfPrimitive.targets;\n  if (defined(targets)) {\n    const targetsLength = targets.length;\n    for (let i = 0; i < targetsLength; ++i) {\n      primitive.morphTargets.push(loadMorphTarget(loader, gltf, targets[i]));\n    }\n  }\n\n  const indices = gltfPrimitive.indices;\n  if (defined(indices)) {\n    primitive.indices = loadIndices(loader, gltf, indices, draco, frameState);\n  }\n\n  // With the latest revision, feature IDs are defined in EXT_mesh_features\n  // while EXT_structural_metadata is for defining property textures and\n  // property mappings. In the legacy EXT_feature_metadata, these concepts\n  // were all in one extension.\n  const structuralMetadata = extensions.EXT_structural_metadata;\n  const meshFeatures = extensions.EXT_mesh_features;\n  const featureMetadataLegacy = extensions.EXT_feature_metadata;\n  const hasFeatureMetadataLegacy = defined(featureMetadataLegacy);\n\n  // Load feature Ids\n  if (defined(meshFeatures)) {\n    loadPrimitiveFeatures(\n      loader,\n      gltf,\n      primitive,\n      meshFeatures,\n      supportedImageFormats\n    );\n  } else if (hasFeatureMetadataLegacy) {\n    loadPrimitiveFeaturesLegacy(\n      loader,\n      gltf,\n      primitive,\n      featureMetadataLegacy,\n      supportedImageFormats\n    );\n  }\n\n  // Load structural metadata\n  if (defined(structuralMetadata)) {\n    loadPrimitiveMetadata(primitive, structuralMetadata);\n  } else if (hasFeatureMetadataLegacy) {\n    loadPrimitiveMetadataLegacy(loader, primitive, featureMetadataLegacy);\n  }\n\n  primitive.primitiveType = gltfPrimitive.mode;\n\n  return primitive;\n}\n\n// For EXT_mesh_features\nfunction loadPrimitiveFeatures(\n  loader,\n  gltf,\n  primitive,\n  meshFeaturesExtension,\n  supportedImageFormats\n) {\n  let featureIdsArray;\n  if (\n    defined(meshFeaturesExtension) &&\n    defined(meshFeaturesExtension.featureIds)\n  ) {\n    featureIdsArray = meshFeaturesExtension.featureIds;\n  } else {\n    featureIdsArray = [];\n  }\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const label = `featureId_${i}`;\n\n    let featureIdComponent;\n    if (defined(featureIds.texture)) {\n      featureIdComponent = loadFeatureIdTexture(\n        loader,\n        gltf,\n        featureIds,\n        supportedImageFormats,\n        label\n      );\n    } else if (defined(featureIds.attribute)) {\n      featureIdComponent = loadFeatureIdAttribute(featureIds, label);\n    } else {\n      // default to vertex ID, in other words an implicit range with\n      // offset: 0, repeat: 1\n      featureIdComponent = loadDefaultFeatureIds(featureIds, label);\n    }\n\n    primitive.featureIds.push(featureIdComponent);\n  }\n}\n\n// For EXT_feature_metadata\nfunction loadPrimitiveFeaturesLegacy(\n  loader,\n  gltf,\n  primitive,\n  metadataExtension,\n  supportedImageFormats\n) {\n  // For looking up the featureCount for each set of feature IDs\n  const featureTables = gltf.extensions.EXT_feature_metadata.featureTables;\n\n  let nextFeatureIdIndex = 0;\n\n  // Feature ID Attributes\n  const featureIdAttributes = metadataExtension.featureIdAttributes;\n  if (defined(featureIdAttributes)) {\n    const featureIdAttributesLength = featureIdAttributes.length;\n    for (let i = 0; i < featureIdAttributesLength; ++i) {\n      const featureIdAttribute = featureIdAttributes[i];\n      const featureTableId = featureIdAttribute.featureTable;\n      const propertyTableId = loader._sortedPropertyTableIds.indexOf(\n        featureTableId\n      );\n      const featureCount = featureTables[featureTableId].count;\n      const label = `featureId_${nextFeatureIdIndex}`;\n      nextFeatureIdIndex++;\n\n      let featureIdComponent;\n      if (defined(featureIdAttribute.featureIds.attribute)) {\n        featureIdComponent = loadFeatureIdAttributeLegacy(\n          featureIdAttribute,\n          propertyTableId,\n          featureCount,\n          label\n        );\n      } else {\n        featureIdComponent = loadFeatureIdImplicitRangeLegacy(\n          featureIdAttribute,\n          propertyTableId,\n          featureCount,\n          label\n        );\n      }\n      primitive.featureIds.push(featureIdComponent);\n    }\n  }\n\n  // Feature ID Textures\n  const featureIdTextures = metadataExtension.featureIdTextures;\n  if (defined(featureIdTextures)) {\n    const featureIdTexturesLength = featureIdTextures.length;\n    for (let i = 0; i < featureIdTexturesLength; ++i) {\n      const featureIdTexture = featureIdTextures[i];\n      const featureTableId = featureIdTexture.featureTable;\n      const propertyTableId = loader._sortedPropertyTableIds.indexOf(\n        featureTableId\n      );\n      const featureCount = featureTables[featureTableId].count;\n      const featureIdLabel = `featureId_${nextFeatureIdIndex}`;\n      nextFeatureIdIndex++;\n\n      const featureIdComponent = loadFeatureIdTextureLegacy(\n        loader,\n        gltf,\n        featureIdTexture,\n        propertyTableId,\n        supportedImageFormats,\n        featureCount,\n        featureIdLabel\n      );\n      // Feature ID textures are added after feature ID attributes in the list\n      primitive.featureIds.push(featureIdComponent);\n    }\n  }\n}\n\n// For primitive-level EXT_structural_metadata\nfunction loadPrimitiveMetadata(primitive, structuralMetadataExtension) {\n  if (!defined(structuralMetadataExtension)) {\n    return;\n  }\n\n  // Property Textures\n  if (defined(structuralMetadataExtension.propertyTextures)) {\n    primitive.propertyTextureIds = structuralMetadataExtension.propertyTextures;\n  }\n\n  // Property Attributes\n  if (defined(structuralMetadataExtension.propertyAttributes)) {\n    primitive.propertyAttributeIds =\n      structuralMetadataExtension.propertyAttributes;\n  }\n}\n\n// For EXT_feature_metadata\nfunction loadPrimitiveMetadataLegacy(loader, primitive, metadataExtension) {\n  // Feature Textures\n  if (defined(metadataExtension.featureTextures)) {\n    // feature textures are now identified by an integer index. To convert the\n    // string IDs to integers, find their place in the sorted list of feature\n    // table names\n    primitive.propertyTextureIds = metadataExtension.featureTextures.map(\n      function (id) {\n        return loader._sortedFeatureTextureIds.indexOf(id);\n      }\n    );\n  }\n}\n\nfunction loadInstances(loader, gltf, nodeExtensions, frameState) {\n  const instancingExtension = nodeExtensions.EXT_mesh_gpu_instancing;\n\n  const instances = new Instances();\n  const attributes = instancingExtension.attributes;\n  if (defined(attributes)) {\n    const hasRotation = defined(attributes.ROTATION);\n    const hasTranslationMinMax =\n      defined(attributes.TRANSLATION) &&\n      defined(gltf.accessors[attributes.TRANSLATION].min) &&\n      defined(gltf.accessors[attributes.TRANSLATION].max);\n    for (const semantic in attributes) {\n      if (attributes.hasOwnProperty(semantic)) {\n        // Load the attributes as typed arrays if:\n        // - the instances have rotations, so that instance matrices are computed on the CPU.\n        //   This avoids the expensive quaternion -> rotation matrix conversion in the shader.\n        // - the translation accessor does not have a min and max, so the values can be used\n        //   for computing an accurate bounding volume.\n        // - the attributes contain feature IDs, in order to add the instance's feature ID\n        //   to the pick object.\n        // - GPU instancing is not supported.\n        const isTransformAttribute =\n          semantic === InstanceAttributeSemantic.TRANSLATION ||\n          semantic === InstanceAttributeSemantic.ROTATION ||\n          semantic === InstanceAttributeSemantic.SCALE;\n        const loadAsTypedArrayPacked =\n          loader._loadAttributesAsTypedArray ||\n          ((hasRotation || !hasTranslationMinMax) && isTransformAttribute) ||\n          semantic.indexOf(InstanceAttributeSemantic.FEATURE_ID) >= 0 ||\n          !frameState.context.instancedArrays;\n\n        const accessorId = attributes[semantic];\n        instances.attributes.push(\n          loadInstancedAttribute(\n            loader,\n            gltf,\n            accessorId,\n            semantic,\n            loadAsTypedArrayPacked\n          )\n        );\n      }\n    }\n  }\n\n  const instancingExtExtensions = defaultValue(\n    instancingExtension.extensions,\n    defaultValue.EMPTY_OBJECT\n  );\n  const instanceFeatures = nodeExtensions.EXT_instance_features;\n  const featureMetadataLegacy = instancingExtExtensions.EXT_feature_metadata;\n\n  if (defined(instanceFeatures)) {\n    loadInstanceFeatures(instances, instanceFeatures);\n  } else if (defined(featureMetadataLegacy)) {\n    loadInstanceFeaturesLegacy(\n      gltf,\n      instances,\n      featureMetadataLegacy,\n      loader._sortedPropertyTableIds\n    );\n  }\n\n  return instances;\n}\n\n// For EXT_mesh_features\nfunction loadInstanceFeatures(instances, instanceFeaturesExtension) {\n  // feature IDs are required in EXT_instance_features\n  const featureIdsArray = instanceFeaturesExtension.featureIds;\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const label = `instanceFeatureId_${i}`;\n\n    let featureIdComponent;\n    if (defined(featureIds.attribute)) {\n      featureIdComponent = loadFeatureIdAttribute(featureIds, label);\n    } else {\n      // in EXT_instance_features, the default is to assign IDs by instance\n      // ID. This can be expressed with offset: 0, repeat: 1\n      featureIdComponent = loadDefaultFeatureIds(featureIds, label);\n    }\n\n    instances.featureIds.push(featureIdComponent);\n  }\n}\n\n// For backwards-compatibility with EXT_feature_metadata\nfunction loadInstanceFeaturesLegacy(\n  gltf,\n  instances,\n  metadataExtension,\n  sortedPropertyTableIds\n) {\n  // For looking up the featureCount for each set of feature IDs\n  const featureTables = gltf.extensions.EXT_feature_metadata.featureTables;\n\n  const featureIdAttributes = metadataExtension.featureIdAttributes;\n  if (defined(featureIdAttributes)) {\n    const featureIdAttributesLength = featureIdAttributes.length;\n    for (let i = 0; i < featureIdAttributesLength; ++i) {\n      const featureIdAttribute = featureIdAttributes[i];\n      const featureTableId = featureIdAttribute.featureTable;\n      const propertyTableId = sortedPropertyTableIds.indexOf(featureTableId);\n      const featureCount = featureTables[featureTableId].count;\n      const label = `instanceFeatureId_${i}`;\n\n      let featureIdComponent;\n      if (defined(featureIdAttribute.featureIds.attribute)) {\n        featureIdComponent = loadFeatureIdAttributeLegacy(\n          featureIdAttribute,\n          propertyTableId,\n          featureCount,\n          label\n        );\n      } else {\n        featureIdComponent = loadFeatureIdImplicitRangeLegacy(\n          featureIdAttribute,\n          propertyTableId,\n          featureCount,\n          label\n        );\n      }\n      instances.featureIds.push(featureIdComponent);\n    }\n  }\n}\n\nfunction loadNode(loader, gltf, gltfNode, supportedImageFormats, frameState) {\n  const node = new Node();\n\n  node.name = gltfNode.name;\n\n  node.matrix = fromArray(Matrix4, gltfNode.matrix);\n  node.translation = fromArray(Cartesian3, gltfNode.translation);\n  node.rotation = fromArray(Quaternion, gltfNode.rotation);\n  node.scale = fromArray(Cartesian3, gltfNode.scale);\n\n  const meshId = gltfNode.mesh;\n  if (defined(meshId)) {\n    const mesh = gltf.meshes[meshId];\n    const primitives = mesh.primitives;\n    const primitivesLength = primitives.length;\n    for (let i = 0; i < primitivesLength; ++i) {\n      node.primitives.push(\n        loadPrimitive(\n          loader,\n          gltf,\n          primitives[i],\n          supportedImageFormats,\n          frameState\n        )\n      );\n    }\n\n    // If the node has no weights array, it will look for the weights array provided\n    // by the mesh. If both are undefined, it will default to an array of zero weights.\n    const morphWeights = defaultValue(gltfNode.weights, mesh.weights);\n    const targets = node.primitives[0].morphTargets;\n    const targetsLength = targets.length;\n\n    // Since meshes are not stored as separate components, the mesh weights will still\n    // be stored at the node level.\n    node.morphWeights = defined(morphWeights)\n      ? morphWeights.slice()\n      : arrayFill(new Array(targetsLength), 0.0);\n  }\n\n  const nodeExtensions = defaultValue(\n    gltfNode.extensions,\n    defaultValue.EMPTY_OBJECT\n  );\n  const instancingExtension = nodeExtensions.EXT_mesh_gpu_instancing;\n\n  if (defined(instancingExtension)) {\n    node.instances = loadInstances(loader, gltf, nodeExtensions, frameState);\n  }\n\n  return node;\n}\n\nfunction loadNodes(loader, gltf, supportedImageFormats, frameState) {\n  let i;\n  let j;\n\n  const nodesLength = gltf.nodes.length;\n  const nodes = new Array(nodesLength);\n  for (i = 0; i < nodesLength; ++i) {\n    const node = loadNode(\n      loader,\n      gltf,\n      gltf.nodes[i],\n      supportedImageFormats,\n      frameState\n    );\n    node.index = i;\n    nodes[i] = node;\n  }\n\n  for (i = 0; i < nodesLength; ++i) {\n    const childrenNodeIds = gltf.nodes[i].children;\n    if (defined(childrenNodeIds)) {\n      const childrenLength = childrenNodeIds.length;\n      for (j = 0; j < childrenLength; ++j) {\n        nodes[i].children.push(nodes[childrenNodeIds[j]]);\n      }\n    }\n  }\n\n  return nodes;\n}\n\nfunction loadSkin(loader, gltf, gltfSkin, nodes) {\n  const skin = new Skin();\n\n  const jointIds = gltfSkin.joints;\n  const jointsLength = jointIds.length;\n  const joints = new Array(jointsLength);\n  for (let i = 0; i < jointsLength; ++i) {\n    joints[i] = nodes[jointIds[i]];\n  }\n  skin.joints = joints;\n\n  const inverseBindMatricesAccessorId = gltfSkin.inverseBindMatrices;\n  if (defined(inverseBindMatricesAccessorId)) {\n    skin.inverseBindMatrices = loadAccessor(\n      loader,\n      gltf,\n      inverseBindMatricesAccessorId\n    );\n  } else {\n    skin.inverseBindMatrices = arrayFill(\n      new Array(jointsLength),\n      Matrix4.IDENTITY\n    );\n  }\n\n  return skin;\n}\n\nfunction loadSkins(loader, gltf, nodes) {\n  let i;\n\n  const gltfSkins = gltf.skins;\n  if (!defined(gltfSkins)) {\n    return [];\n  }\n\n  const skinsLength = gltf.skins.length;\n  const skins = new Array(skinsLength);\n  for (i = 0; i < skinsLength; ++i) {\n    const skin = loadSkin(loader, gltf, gltf.skins[i], nodes);\n    skin.index = i;\n    skins[i] = skin;\n  }\n\n  const nodesLength = nodes.length;\n  for (i = 0; i < nodesLength; ++i) {\n    const skinId = gltf.nodes[i].skin;\n    if (defined(skinId)) {\n      nodes[i].skin = skins[skinId];\n    }\n  }\n\n  return skins;\n}\n\nfunction loadStructuralMetadata(\n  loader,\n  gltf,\n  extension,\n  extensionLegacy,\n  supportedImageFormats\n) {\n  const structuralMetadataLoader = new GltfStructuralMetadataLoader({\n    gltf: gltf,\n    extension: extension,\n    extensionLegacy: extensionLegacy,\n    gltfResource: loader._gltfResource,\n    baseResource: loader._baseResource,\n    supportedImageFormats: supportedImageFormats,\n    asynchronous: loader._asynchronous,\n  });\n  structuralMetadataLoader.load();\n\n  loader._structuralMetadataLoader = structuralMetadataLoader;\n\n  return structuralMetadataLoader;\n}\n\nfunction loadAnimationSampler(loader, gltf, gltfSampler) {\n  const animationSampler = new AnimationSampler();\n\n  const inputAccessorId = gltfSampler.input;\n  animationSampler.input = loadAccessor(loader, gltf, inputAccessorId);\n\n  const gltfInterpolation = gltfSampler.interpolation;\n  animationSampler.interpolation = defaultValue(\n    InterpolationType[gltfInterpolation],\n    InterpolationType.LINEAR\n  );\n\n  const outputAccessorId = gltfSampler.output;\n  animationSampler.output = loadAccessor(loader, gltf, outputAccessorId, true);\n\n  return animationSampler;\n}\n\nfunction loadAnimationTarget(gltfTarget, nodes) {\n  const animationTarget = new AnimationTarget();\n\n  const nodeIndex = gltfTarget.node;\n  // If the node isn't defined, the animation channel should be ignored.\n  // It's easiest to signal this by returning undefined.\n  if (!defined(nodeIndex)) {\n    return undefined;\n  }\n\n  animationTarget.node = nodes[nodeIndex];\n\n  const path = gltfTarget.path.toUpperCase();\n  animationTarget.path = AnimatedPropertyType[path];\n\n  return animationTarget;\n}\n\nfunction loadAnimationChannel(gltfChannel, samplers, nodes) {\n  const animationChannel = new AnimationChannel();\n\n  const samplerIndex = gltfChannel.sampler;\n  animationChannel.sampler = samplers[samplerIndex];\n  animationChannel.target = loadAnimationTarget(gltfChannel.target, nodes);\n\n  return animationChannel;\n}\n\nfunction loadAnimation(loader, gltf, gltfAnimation, nodes) {\n  let i;\n\n  const animation = new Animation();\n  animation.name = gltfAnimation.name;\n\n  const gltfSamplers = gltfAnimation.samplers;\n  const samplersLength = gltfSamplers.length;\n\n  const samplers = new Array(samplersLength);\n  for (i = 0; i < samplersLength; i++) {\n    const sampler = loadAnimationSampler(loader, gltf, gltfSamplers[i]);\n    sampler.index = i;\n    samplers[i] = sampler;\n  }\n\n  const gltfChannels = gltfAnimation.channels;\n  const channelsLength = gltfChannels.length;\n\n  const channels = new Array(channelsLength);\n  for (i = 0; i < channelsLength; i++) {\n    channels[i] = loadAnimationChannel(gltfChannels[i], samplers, nodes);\n  }\n\n  animation.samplers = samplers;\n  animation.channels = channels;\n\n  return animation;\n}\n\nfunction loadAnimations(loader, gltf, nodes) {\n  let i;\n\n  const gltfAnimations = gltf.animations;\n  if (!defined(gltfAnimations)) {\n    return [];\n  }\n\n  const animationsLength = gltf.animations.length;\n  const animations = new Array(animationsLength);\n  for (i = 0; i < animationsLength; ++i) {\n    const animation = loadAnimation(loader, gltf, gltf.animations[i], nodes);\n    animation.index = i;\n    animations[i] = animation;\n  }\n\n  return animations;\n}\n\nfunction getSceneNodeIds(gltf) {\n  let nodesIds;\n  if (defined(gltf.scenes) && defined(gltf.scene)) {\n    nodesIds = gltf.scenes[gltf.scene].nodes;\n  }\n  nodesIds = defaultValue(nodesIds, gltf.nodes);\n  nodesIds = defined(nodesIds) ? nodesIds : [];\n  return nodesIds;\n}\n\nfunction loadScene(gltf, nodes) {\n  const scene = new Scene();\n  const sceneNodeIds = getSceneNodeIds(gltf);\n  scene.nodes = sceneNodeIds.map(function (sceneNodeId) {\n    return nodes[sceneNodeId];\n  });\n  return scene;\n}\n\nfunction parse(\n  loader,\n  gltf,\n  supportedImageFormats,\n  frameState,\n  rejectPromise,\n  rejectTexturesPromise\n) {\n  const extensions = defaultValue(gltf.extensions, defaultValue.EMPTY_OBJECT);\n  const structuralMetadataExtension = extensions.EXT_structural_metadata;\n  const featureMetadataExtensionLegacy = extensions.EXT_feature_metadata;\n\n  if (defined(featureMetadataExtensionLegacy)) {\n    // If the old EXT_feature_metadata extension is present, sort the IDs of the\n    // feature tables and feature textures so we don't have to do this once\n    // per primitive.\n    //\n    // This must run before loadNodes so these IDs are available when\n    // attributes are processed.\n    const featureTables = featureMetadataExtensionLegacy.featureTables;\n    const featureTextures = featureMetadataExtensionLegacy.featureTextures;\n    const allPropertyTableIds = defined(featureTables) ? featureTables : [];\n    const allFeatureTextureIds = defined(featureTextures)\n      ? featureTextures\n      : [];\n    loader._sortedPropertyTableIds = Object.keys(allPropertyTableIds).sort();\n    loader._sortedFeatureTextureIds = Object.keys(allFeatureTextureIds).sort();\n  }\n\n  const nodes = loadNodes(loader, gltf, supportedImageFormats, frameState);\n  const skins = loadSkins(loader, gltf, nodes);\n  const animations = loadAnimations(loader, gltf, nodes);\n  const scene = loadScene(gltf, nodes);\n\n  const components = new Components();\n  const asset = new Asset();\n  const copyright = gltf.asset.copyright;\n  if (defined(copyright)) {\n    const credits = copyright.split(\";\").map(function (string) {\n      return new Credit(string.trim());\n    });\n    asset.credits = credits;\n  }\n\n  components.asset = asset;\n  components.scene = scene;\n  components.nodes = nodes;\n  components.skins = skins;\n  components.animations = animations;\n  components.upAxis = loader._upAxis;\n  components.forwardAxis = loader._forwardAxis;\n\n  loader._components = components;\n\n  // Load structural metadata (property tables and property textures)\n  if (\n    defined(structuralMetadataExtension) ||\n    defined(featureMetadataExtensionLegacy)\n  ) {\n    const structuralMetadataLoader = loadStructuralMetadata(\n      loader,\n      gltf,\n      structuralMetadataExtension,\n      featureMetadataExtensionLegacy,\n      supportedImageFormats\n    );\n    const promise = structuralMetadataLoader.promise.then(function (\n      structuralMetadataLoader\n    ) {\n      if (loader.isDestroyed()) {\n        return;\n      }\n      components.structuralMetadata =\n        structuralMetadataLoader.structuralMetadata;\n    });\n    loader._loaderPromises.push(promise);\n  }\n\n  // Gather promises and reject if any promises fail.\n  const readyPromises = [];\n  readyPromises.push.apply(readyPromises, loader._loaderPromises);\n\n  if (!loader._incrementallyLoadTextures) {\n    readyPromises.push.apply(readyPromises, loader._texturesPromises);\n  }\n\n  Promise.all(readyPromises)\n    .then(function () {\n      if (loader.isDestroyed()) {\n        return;\n      }\n      loader._state = GltfLoaderState.PROCESSED;\n    })\n    .catch(rejectPromise);\n\n  // Separate promise will resolve once textures are loaded.\n  Promise.all(loader._texturesPromises)\n    .then(function () {\n      if (loader.isDestroyed()) {\n        return;\n      }\n      loader._textureState = GltfLoaderState.PROCESSED;\n    })\n    .catch(rejectTexturesPromise);\n}\n\nfunction unloadTextures(loader) {\n  const textureLoaders = loader._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    ResourceCache.unload(textureLoaders[i]);\n  }\n  loader._textureLoaders.length = 0;\n}\n\nfunction unloadBufferViews(loader) {\n  const bufferViewLoaders = loader._bufferViewLoaders;\n  const bufferViewLoadersLength = bufferViewLoaders.length;\n  for (let i = 0; i < bufferViewLoadersLength; ++i) {\n    ResourceCache.unload(bufferViewLoaders[i]);\n  }\n  loader._bufferViewLoaders.length = 0;\n}\n\nfunction unloadGeometry(loader) {\n  const geometryLoaders = loader._geometryLoaders;\n  const geometryLoadersLength = geometryLoaders.length;\n  for (let i = 0; i < geometryLoadersLength; ++i) {\n    ResourceCache.unload(geometryLoaders[i]);\n  }\n  loader._geometryLoaders.length = 0;\n}\n\nfunction unloadStructuralMetadata(loader) {\n  if (defined(loader._structuralMetadataLoader)) {\n    loader._structuralMetadataLoader.destroy();\n    loader._structuralMetadataLoader = undefined;\n  }\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfLoader.prototype.unload = function () {\n  if (defined(this._gltfJsonLoader)) {\n    ResourceCache.unload(this._gltfJsonLoader);\n  }\n  this._gltfJsonLoader = undefined;\n\n  unloadTextures(this);\n  unloadBufferViews(this);\n  unloadGeometry(this);\n  unloadStructuralMetadata(this);\n\n  this._components = undefined;\n};\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport ModelComponents from \"./ModelComponents.js\";\n\n/**\n * glTF loading utilities.\n *\n * @namespace GltfLoaderUtil\n *\n * @private\n */\nconst GltfLoaderUtil = {};\n\n/**\n * Get the image ID referenced by a texture.\n * <p>\n * When the texture has the EXT_texture_webp extension and the browser supports\n * WebP images the WebP image ID is returned.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Number} options.textureId The texture ID.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n *\n * @returns {Number} The image ID.\n * @private\n */\nGltfLoaderUtil.getImageIdFromTexture = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const textureId = options.textureId;\n  const supportedImageFormats = options.supportedImageFormats;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.number(\"options.textureId\", textureId);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  //>>includeEnd('debug');\n\n  const texture = gltf.textures[textureId];\n  const extensions = texture.extensions;\n  if (defined(extensions)) {\n    if (supportedImageFormats.webp && defined(extensions.EXT_texture_webp)) {\n      return extensions.EXT_texture_webp.source;\n    } else if (\n      supportedImageFormats.basis &&\n      defined(extensions.KHR_texture_basisu)\n    ) {\n      return extensions.KHR_texture_basisu.source;\n    }\n  }\n  return texture.source;\n};\n\n/**\n * Create a sampler for a texture.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {Object} options.textureInfo The texture info object.\n * @param {Boolean} [options.compressedTextureNoMipmap=false] True when the texture is compressed and does not have an embedded mipmap.\n *\n * @returns {Sampler} The sampler.\n * @private\n */\nGltfLoaderUtil.createSampler = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const textureInfo = options.textureInfo;\n  const compressedTextureNoMipmap = defaultValue(\n    options.compressedTextureNoMipmap,\n    false\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  //>>includeEnd('debug');\n\n  // Default sampler properties\n  let wrapS = TextureWrap.REPEAT;\n  let wrapT = TextureWrap.REPEAT;\n  let minFilter = TextureMinificationFilter.LINEAR;\n  let magFilter = TextureMagnificationFilter.LINEAR;\n\n  const textureId = textureInfo.index;\n  const texture = gltf.textures[textureId];\n  const samplerId = texture.sampler;\n\n  if (defined(samplerId)) {\n    const sampler = gltf.samplers[samplerId];\n    wrapS = defaultValue(sampler.wrapS, wrapS);\n    wrapT = defaultValue(sampler.wrapT, wrapT);\n    minFilter = defaultValue(sampler.minFilter, minFilter);\n    magFilter = defaultValue(sampler.magFilter, magFilter);\n  }\n\n  let usesTextureTransform = false;\n  const extensions = textureInfo.extensions;\n  if (defined(extensions) && defined(extensions.KHR_texture_transform)) {\n    usesTextureTransform = true;\n  }\n\n  if (\n    (compressedTextureNoMipmap || usesTextureTransform) &&\n    minFilter !== TextureMinificationFilter.LINEAR &&\n    minFilter !== TextureMinificationFilter.NEAREST\n  ) {\n    if (\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n    ) {\n      minFilter = TextureMinificationFilter.NEAREST;\n    } else {\n      minFilter = TextureMinificationFilter.LINEAR;\n    }\n  }\n\n  return new Sampler({\n    wrapS: wrapS,\n    wrapT: wrapT,\n    minificationFilter: minFilter,\n    magnificationFilter: magFilter,\n  });\n};\n\nconst defaultScale = new Cartesian2(1.0, 1.0);\n\n/**\n * Create a model texture reader.\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.textureInfo The texture info JSON.\n * @param {String} [options.channels] The texture channels to read from.\n * @param {Texture} [options.texture] The texture object.\n *\n * @returns {ModelComponents.TextureReader} The texture reader for this model.\n */\nGltfLoaderUtil.createModelTextureReader = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const textureInfo = options.textureInfo;\n  const channels = options.channels;\n  const texture = options.texture;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  //>>includeEnd('debug');\n\n  let texCoord = defaultValue(textureInfo.texCoord, 0);\n  let transform;\n\n  const textureTransform = defaultValue(\n    textureInfo.extensions,\n    defaultValue.EMPTY_OBJECT\n  ).KHR_texture_transform;\n\n  if (defined(textureTransform)) {\n    texCoord = defaultValue(textureTransform.texCoord, texCoord);\n\n    const offset = defined(textureTransform.offset)\n      ? Cartesian2.unpack(textureTransform.offset)\n      : Cartesian2.ZERO;\n    let rotation = defaultValue(textureTransform.rotation, 0.0);\n    const scale = defined(textureTransform.scale)\n      ? Cartesian2.unpack(textureTransform.scale)\n      : defaultScale;\n\n    // glTF assumes UV coordinates start with (0, 0) in the top left corner\n    // (y-down) unlike WebGL which puts (0, 0) in the bottom left corner (y-up).\n    // This means rotations are reversed since the angle from x to y is now\n    // clockwise instead of CCW. Translations and scales are not impacted by\n    // this.\n    rotation = -rotation;\n\n    // prettier-ignore\n    transform = new Matrix3(\n        Math.cos(rotation) * scale.x, -Math.sin(rotation) * scale.y, offset.x,\n        Math.sin(rotation) * scale.x, Math.cos(rotation) * scale.y, offset.y,\n        0.0, 0.0, 1.0\n      );\n  }\n\n  const modelTextureReader = new ModelComponents.TextureReader();\n  modelTextureReader.index = textureInfo.index;\n  modelTextureReader.texture = texture;\n  modelTextureReader.texCoord = texCoord;\n  modelTextureReader.transform = transform;\n  modelTextureReader.channels = channels;\n\n  return modelTextureReader;\n};\n\nexport default GltfLoaderUtil;\n","import usesExtension from \"./usesExtension.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Contains traversal functions for processing elements of the glTF hierarchy.\n * @constructor\n *\n * @private\n */\nfunction ForEach() {}\n\n/**\n * Fallback for glTF 1.0\n * @private\n */\nForEach.objectLegacy = function (objects, handler) {\n  if (defined(objects)) {\n    for (const objectId in objects) {\n      if (Object.prototype.hasOwnProperty.call(objects, objectId)) {\n        const object = objects[objectId];\n        const value = handler(object, objectId);\n\n        if (defined(value)) {\n          return value;\n        }\n      }\n    }\n  }\n};\n\n/**\n * @private\n */\nForEach.object = function (arrayOfObjects, handler) {\n  if (defined(arrayOfObjects)) {\n    const length = arrayOfObjects.length;\n    for (let i = 0; i < length; i++) {\n      const object = arrayOfObjects[i];\n      const value = handler(object, i);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\n/**\n * Supports glTF 1.0 and 2.0\n * @private\n */\nForEach.topLevel = function (gltf, name, handler) {\n  const gltfProperty = gltf[name];\n  if (defined(gltfProperty) && !Array.isArray(gltfProperty)) {\n    return ForEach.objectLegacy(gltfProperty, handler);\n  }\n\n  return ForEach.object(gltfProperty, handler);\n};\n\nForEach.accessor = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"accessors\", handler);\n};\n\nForEach.accessorWithSemantic = function (gltf, semantic, handler) {\n  const visited = {};\n  return ForEach.mesh(gltf, function (mesh) {\n    return ForEach.meshPrimitive(mesh, function (primitive) {\n      const valueForEach = ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, attributeSemantic) {\n          if (\n            attributeSemantic.indexOf(semantic) === 0 &&\n            !defined(visited[accessorId])\n          ) {\n            visited[accessorId] = true;\n            const value = handler(accessorId);\n\n            if (defined(value)) {\n              return value;\n            }\n          }\n        }\n      );\n\n      if (defined(valueForEach)) {\n        return valueForEach;\n      }\n\n      return ForEach.meshPrimitiveTarget(primitive, function (target) {\n        return ForEach.meshPrimitiveTargetAttribute(\n          target,\n          function (accessorId, attributeSemantic) {\n            if (\n              attributeSemantic.indexOf(semantic) === 0 &&\n              !defined(visited[accessorId])\n            ) {\n              visited[accessorId] = true;\n              const value = handler(accessorId);\n\n              if (defined(value)) {\n                return value;\n              }\n            }\n          }\n        );\n      });\n    });\n  });\n};\n\nForEach.accessorContainingVertexAttributeData = function (gltf, handler) {\n  const visited = {};\n  return ForEach.mesh(gltf, function (mesh) {\n    return ForEach.meshPrimitive(mesh, function (primitive) {\n      const valueForEach = ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId) {\n          if (!defined(visited[accessorId])) {\n            visited[accessorId] = true;\n            const value = handler(accessorId);\n\n            if (defined(value)) {\n              return value;\n            }\n          }\n        }\n      );\n\n      if (defined(valueForEach)) {\n        return valueForEach;\n      }\n\n      return ForEach.meshPrimitiveTarget(primitive, function (target) {\n        return ForEach.meshPrimitiveTargetAttribute(\n          target,\n          function (accessorId) {\n            if (!defined(visited[accessorId])) {\n              visited[accessorId] = true;\n              const value = handler(accessorId);\n\n              if (defined(value)) {\n                return value;\n              }\n            }\n          }\n        );\n      });\n    });\n  });\n};\n\nForEach.accessorContainingIndexData = function (gltf, handler) {\n  const visited = {};\n  return ForEach.mesh(gltf, function (mesh) {\n    return ForEach.meshPrimitive(mesh, function (primitive) {\n      const indices = primitive.indices;\n      if (defined(indices) && !defined(visited[indices])) {\n        visited[indices] = true;\n        const value = handler(indices);\n\n        if (defined(value)) {\n          return value;\n        }\n      }\n    });\n  });\n};\n\nForEach.animation = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"animations\", handler);\n};\n\nForEach.animationChannel = function (animation, handler) {\n  const channels = animation.channels;\n  return ForEach.object(channels, handler);\n};\n\nForEach.animationSampler = function (animation, handler) {\n  const samplers = animation.samplers;\n  return ForEach.object(samplers, handler);\n};\n\nForEach.buffer = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"buffers\", handler);\n};\n\nForEach.bufferView = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"bufferViews\", handler);\n};\n\nForEach.camera = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"cameras\", handler);\n};\n\nForEach.image = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"images\", handler);\n};\n\nForEach.material = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"materials\", handler);\n};\n\nForEach.materialValue = function (material, handler) {\n  let values = material.values;\n  if (\n    defined(material.extensions) &&\n    defined(material.extensions.KHR_techniques_webgl)\n  ) {\n    values = material.extensions.KHR_techniques_webgl.values;\n  }\n\n  for (const name in values) {\n    if (Object.prototype.hasOwnProperty.call(values, name)) {\n      const value = handler(values[name], name);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.mesh = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"meshes\", handler);\n};\n\nForEach.meshPrimitive = function (mesh, handler) {\n  const primitives = mesh.primitives;\n  if (defined(primitives)) {\n    const primitivesLength = primitives.length;\n    for (let i = 0; i < primitivesLength; i++) {\n      const primitive = primitives[i];\n      const value = handler(primitive, i);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.meshPrimitiveAttribute = function (primitive, handler) {\n  const attributes = primitive.attributes;\n  for (const semantic in attributes) {\n    if (Object.prototype.hasOwnProperty.call(attributes, semantic)) {\n      const value = handler(attributes[semantic], semantic);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.meshPrimitiveTarget = function (primitive, handler) {\n  const targets = primitive.targets;\n  if (defined(targets)) {\n    const length = targets.length;\n    for (let i = 0; i < length; ++i) {\n      const value = handler(targets[i], i);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.meshPrimitiveTargetAttribute = function (target, handler) {\n  for (const semantic in target) {\n    if (Object.prototype.hasOwnProperty.call(target, semantic)) {\n      const accessorId = target[semantic];\n      const value = handler(accessorId, semantic);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.node = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"nodes\", handler);\n};\n\nForEach.nodeInTree = function (gltf, nodeIds, handler) {\n  const nodes = gltf.nodes;\n  if (defined(nodes)) {\n    const length = nodeIds.length;\n    for (let i = 0; i < length; i++) {\n      const nodeId = nodeIds[i];\n      const node = nodes[nodeId];\n      if (defined(node)) {\n        let value = handler(node, nodeId);\n\n        if (defined(value)) {\n          return value;\n        }\n\n        const children = node.children;\n        if (defined(children)) {\n          value = ForEach.nodeInTree(gltf, children, handler);\n\n          if (defined(value)) {\n            return value;\n          }\n        }\n      }\n    }\n  }\n};\n\nForEach.nodeInScene = function (gltf, scene, handler) {\n  const sceneNodeIds = scene.nodes;\n  if (defined(sceneNodeIds)) {\n    return ForEach.nodeInTree(gltf, sceneNodeIds, handler);\n  }\n};\n\nForEach.program = function (gltf, handler) {\n  if (usesExtension(gltf, \"KHR_techniques_webgl\")) {\n    return ForEach.object(\n      gltf.extensions.KHR_techniques_webgl.programs,\n      handler\n    );\n  }\n\n  return ForEach.topLevel(gltf, \"programs\", handler);\n};\n\nForEach.sampler = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"samplers\", handler);\n};\n\nForEach.scene = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"scenes\", handler);\n};\n\nForEach.shader = function (gltf, handler) {\n  if (usesExtension(gltf, \"KHR_techniques_webgl\")) {\n    return ForEach.object(\n      gltf.extensions.KHR_techniques_webgl.shaders,\n      handler\n    );\n  }\n\n  return ForEach.topLevel(gltf, \"shaders\", handler);\n};\n\nForEach.skin = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"skins\", handler);\n};\n\nForEach.skinJoint = function (skin, handler) {\n  const joints = skin.joints;\n  if (defined(joints)) {\n    const jointsLength = joints.length;\n    for (let i = 0; i < jointsLength; i++) {\n      const joint = joints[i];\n      const value = handler(joint);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.techniqueAttribute = function (technique, handler) {\n  const attributes = technique.attributes;\n  for (const attributeName in attributes) {\n    if (Object.prototype.hasOwnProperty.call(attributes, attributeName)) {\n      const value = handler(attributes[attributeName], attributeName);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.techniqueUniform = function (technique, handler) {\n  const uniforms = technique.uniforms;\n  for (const uniformName in uniforms) {\n    if (Object.prototype.hasOwnProperty.call(uniforms, uniformName)) {\n      const value = handler(uniforms[uniformName], uniformName);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.techniqueParameter = function (technique, handler) {\n  const parameters = technique.parameters;\n  for (const parameterName in parameters) {\n    if (Object.prototype.hasOwnProperty.call(parameters, parameterName)) {\n      const value = handler(parameters[parameterName], parameterName);\n\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n};\n\nForEach.technique = function (gltf, handler) {\n  if (usesExtension(gltf, \"KHR_techniques_webgl\")) {\n    return ForEach.object(\n      gltf.extensions.KHR_techniques_webgl.techniques,\n      handler\n    );\n  }\n\n  return ForEach.topLevel(gltf, \"techniques\", handler);\n};\n\nForEach.texture = function (gltf, handler) {\n  return ForEach.topLevel(gltf, \"textures\", handler);\n};\n\nexport default ForEach;\n","import addToArray from \"./addToArray.js\";\n\n/**\n * Adds buffer to gltf.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {Buffer} buffer A Buffer object which will be added to gltf.buffers.\n * @returns {Number} The bufferView id of the newly added bufferView.\n *\n * @private\n */\nfunction addBuffer(gltf, buffer) {\n  const newBuffer = {\n    byteLength: buffer.length,\n    extras: {\n      _pipeline: {\n        source: buffer,\n      },\n    },\n  };\n  const bufferId = addToArray(gltf.buffers, newBuffer);\n  const bufferView = {\n    buffer: bufferId,\n    byteOffset: 0,\n    byteLength: buffer.length,\n  };\n  return addToArray(gltf.bufferViews, bufferView);\n}\n\nexport default addBuffer;\n","import addToArray from \"./addToArray.js\";\nimport ForEach from \"./ForEach.js\";\nimport getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\n/**\n * Adds default glTF values if they don't exist.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The modified glTF.\n *\n * @private\n */\nfunction addDefaults(gltf) {\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      accessor.byteOffset = defaultValue(accessor.byteOffset, 0);\n    }\n  });\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      bufferView.byteOffset = defaultValue(bufferView.byteOffset, 0);\n    }\n  });\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      primitive.mode = defaultValue(primitive.mode, WebGLConstants.TRIANGLES);\n      if (!defined(primitive.material)) {\n        if (!defined(gltf.materials)) {\n          gltf.materials = [];\n        }\n        const defaultMaterial = {\n          name: \"default\",\n        };\n        primitive.material = addToArray(gltf.materials, defaultMaterial);\n      }\n    });\n  });\n\n  ForEach.accessorContainingVertexAttributeData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    const bufferViewId = accessor.bufferView;\n    accessor.normalized = defaultValue(accessor.normalized, false);\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      bufferView.byteStride = getAccessorByteStride(gltf, accessor);\n      bufferView.target = WebGLConstants.ARRAY_BUFFER;\n    }\n  });\n\n  ForEach.accessorContainingIndexData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    const bufferViewId = accessor.bufferView;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      bufferView.target = WebGLConstants.ELEMENT_ARRAY_BUFFER;\n    }\n  });\n\n  ForEach.material(gltf, function (material) {\n    const extensions = defaultValue(\n      material.extensions,\n      defaultValue.EMPTY_OBJECT\n    );\n    const materialsCommon = extensions.KHR_materials_common;\n    if (defined(materialsCommon)) {\n      const technique = materialsCommon.technique;\n      const values = defined(materialsCommon.values)\n        ? materialsCommon.values\n        : {};\n      materialsCommon.values = values;\n\n      values.ambient = defined(values.ambient)\n        ? values.ambient\n        : [0.0, 0.0, 0.0, 1.0];\n      values.emission = defined(values.emission)\n        ? values.emission\n        : [0.0, 0.0, 0.0, 1.0];\n\n      values.transparency = defaultValue(values.transparency, 1.0);\n      values.transparent = defaultValue(values.transparent, false);\n      values.doubleSided = defaultValue(values.doubleSided, false);\n\n      if (technique !== \"CONSTANT\") {\n        values.diffuse = defined(values.diffuse)\n          ? values.diffuse\n          : [0.0, 0.0, 0.0, 1.0];\n        if (technique !== \"LAMBERT\") {\n          values.specular = defined(values.specular)\n            ? values.specular\n            : [0.0, 0.0, 0.0, 1.0];\n          values.shininess = defaultValue(values.shininess, 0.0);\n        }\n      }\n      return;\n    }\n\n    material.emissiveFactor = defaultValue(\n      material.emissiveFactor,\n      [0.0, 0.0, 0.0]\n    );\n    material.alphaMode = defaultValue(material.alphaMode, \"OPAQUE\");\n    material.doubleSided = defaultValue(material.doubleSided, false);\n\n    if (material.alphaMode === \"MASK\") {\n      material.alphaCutoff = defaultValue(material.alphaCutoff, 0.5);\n    }\n\n    const techniquesExtension = extensions.KHR_techniques_webgl;\n    if (defined(techniquesExtension)) {\n      ForEach.materialValue(material, function (materialValue) {\n        // Check if material value is a TextureInfo object\n        if (defined(materialValue.index)) {\n          addTextureDefaults(materialValue);\n        }\n      });\n    }\n\n    addTextureDefaults(material.emissiveTexture);\n    addTextureDefaults(material.normalTexture);\n    addTextureDefaults(material.occlusionTexture);\n\n    const pbrMetallicRoughness = material.pbrMetallicRoughness;\n    if (defined(pbrMetallicRoughness)) {\n      pbrMetallicRoughness.baseColorFactor = defaultValue(\n        pbrMetallicRoughness.baseColorFactor,\n        [1.0, 1.0, 1.0, 1.0]\n      );\n      pbrMetallicRoughness.metallicFactor = defaultValue(\n        pbrMetallicRoughness.metallicFactor,\n        1.0\n      );\n      pbrMetallicRoughness.roughnessFactor = defaultValue(\n        pbrMetallicRoughness.roughnessFactor,\n        1.0\n      );\n      addTextureDefaults(pbrMetallicRoughness.baseColorTexture);\n      addTextureDefaults(pbrMetallicRoughness.metallicRoughnessTexture);\n    }\n\n    const pbrSpecularGlossiness =\n      extensions.KHR_materials_pbrSpecularGlossiness;\n    if (defined(pbrSpecularGlossiness)) {\n      pbrSpecularGlossiness.diffuseFactor = defaultValue(\n        pbrSpecularGlossiness.diffuseFactor,\n        [1.0, 1.0, 1.0, 1.0]\n      );\n      pbrSpecularGlossiness.specularFactor = defaultValue(\n        pbrSpecularGlossiness.specularFactor,\n        [1.0, 1.0, 1.0]\n      );\n      pbrSpecularGlossiness.glossinessFactor = defaultValue(\n        pbrSpecularGlossiness.glossinessFactor,\n        1.0\n      );\n      addTextureDefaults(pbrSpecularGlossiness.specularGlossinessTexture);\n    }\n  });\n\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      sampler.interpolation = defaultValue(sampler.interpolation, \"LINEAR\");\n    });\n  });\n\n  const animatedNodes = getAnimatedNodes(gltf);\n  ForEach.node(gltf, function (node, id) {\n    const animated = defined(animatedNodes[id]);\n    if (\n      animated ||\n      defined(node.translation) ||\n      defined(node.rotation) ||\n      defined(node.scale)\n    ) {\n      node.translation = defaultValue(node.translation, [0.0, 0.0, 0.0]);\n      node.rotation = defaultValue(node.rotation, [0.0, 0.0, 0.0, 1.0]);\n      node.scale = defaultValue(node.scale, [1.0, 1.0, 1.0]);\n    } else {\n      node.matrix = defaultValue(\n        node.matrix,\n        [\n          1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\n          0.0, 1.0,\n        ]\n      );\n    }\n  });\n\n  ForEach.sampler(gltf, function (sampler) {\n    sampler.wrapS = defaultValue(sampler.wrapS, WebGLConstants.REPEAT);\n    sampler.wrapT = defaultValue(sampler.wrapT, WebGLConstants.REPEAT);\n  });\n\n  if (defined(gltf.scenes) && !defined(gltf.scene)) {\n    gltf.scene = 0;\n  }\n\n  return gltf;\n}\n\nfunction getAnimatedNodes(gltf) {\n  const nodes = {};\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      const target = channel.target;\n      const nodeId = target.node;\n      const path = target.path;\n      // Ignore animations that target 'weights'\n      if (path === \"translation\" || path === \"rotation\" || path === \"scale\") {\n        nodes[nodeId] = true;\n      }\n    });\n  });\n  return nodes;\n}\n\nfunction addTextureDefaults(texture) {\n  if (defined(texture)) {\n    texture.texCoord = defaultValue(texture.texCoord, 0);\n  }\n}\n\nexport default addDefaults;\n","import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addToArray from \"./addToArray.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Adds an extension to gltf.extensionsRequired if it does not already exist.\n * Initializes extensionsRequired if it is not defined.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {String} extension The extension to add.\n *\n * @private\n */\nfunction addExtensionsRequired(gltf, extension) {\n  let extensionsRequired = gltf.extensionsRequired;\n  if (!defined(extensionsRequired)) {\n    extensionsRequired = [];\n    gltf.extensionsRequired = extensionsRequired;\n  }\n  addToArray(extensionsRequired, extension, true);\n  addExtensionsUsed(gltf, extension);\n}\n\nexport default addExtensionsRequired;\n","import addToArray from \"./addToArray.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Adds an extension to gltf.extensionsUsed if it does not already exist.\n * Initializes extensionsUsed if it is not defined.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {String} extension The extension to add.\n *\n * @private\n */\nfunction addExtensionsUsed(gltf, extension) {\n  let extensionsUsed = gltf.extensionsUsed;\n  if (!defined(extensionsUsed)) {\n    extensionsUsed = [];\n    gltf.extensionsUsed = extensionsUsed;\n  }\n  addToArray(extensionsUsed, extension, true);\n}\n\nexport default addExtensionsUsed;\n","import ForEach from \"./ForEach.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Adds extras._pipeline to each object that can have extras in the glTF asset.\n * This stage runs before updateVersion and handles both glTF 1.0 and glTF 2.0 assets.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset with the added pipeline extras.\n *\n * @private\n */\nfunction addPipelineExtras(gltf) {\n  ForEach.shader(gltf, function (shader) {\n    addExtras(shader);\n  });\n  ForEach.buffer(gltf, function (buffer) {\n    addExtras(buffer);\n  });\n  ForEach.image(gltf, function (image) {\n    addExtras(image);\n  });\n\n  addExtras(gltf);\n\n  return gltf;\n}\n\nfunction addExtras(object) {\n  object.extras = defined(object.extras) ? object.extras : {};\n  object.extras._pipeline = defined(object.extras._pipeline)\n    ? object.extras._pipeline\n    : {};\n}\n\nexport default addPipelineExtras;\n","import defaultValue from \"../../Core/defaultValue.js\";\n\n/**\n * Adds an element to an array and returns the element's index.\n *\n * @param {Array} array The array to add to.\n * @param {Object} element The element to add.\n * @param {Boolean} [checkDuplicates=false] When <code>true</code>, if a duplicate element is found its index is returned and <code>element</code> is not added to the array.\n *\n * @private\n */\nfunction addToArray(array, element, checkDuplicates) {\n  checkDuplicates = defaultValue(checkDuplicates, false);\n  if (checkDuplicates) {\n    const index = array.indexOf(element);\n    if (index > -1) {\n      return index;\n    }\n  }\n\n  array.push(element);\n  return array.length - 1;\n}\n\nexport default addToArray;\n","import getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport getComponentReader from \"./getComponentReader.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport arrayFill from \"../../Core/arrayFill.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Finds the min and max values of the accessor.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {Object} accessor The accessor object from the glTF asset to read.\n * @returns {{min: Array, max: Array}} min holding the array of minimum values and max holding the array of maximum values.\n *\n * @private\n */\nfunction findAccessorMinMax(gltf, accessor) {\n  const bufferViews = gltf.bufferViews;\n  const buffers = gltf.buffers;\n  const bufferViewId = accessor.bufferView;\n  const numberOfComponents = numberOfComponentsForType(accessor.type);\n\n  // According to the spec, when bufferView is not defined, accessor must be initialized with zeros\n  if (!defined(accessor.bufferView)) {\n    return {\n      min: arrayFill(new Array(numberOfComponents), 0.0),\n      max: arrayFill(new Array(numberOfComponents), 0.0),\n    };\n  }\n\n  const min = arrayFill(\n    new Array(numberOfComponents),\n    Number.POSITIVE_INFINITY\n  );\n  const max = arrayFill(\n    new Array(numberOfComponents),\n    Number.NEGATIVE_INFINITY\n  );\n\n  const bufferView = bufferViews[bufferViewId];\n  const bufferId = bufferView.buffer;\n  const buffer = buffers[bufferId];\n  const source = buffer.extras._pipeline.source;\n\n  const count = accessor.count;\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  let byteOffset =\n    accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n  const componentType = accessor.componentType;\n  const componentTypeByteLength =\n    ComponentDatatype.getSizeInBytes(componentType);\n  const dataView = new DataView(source.buffer);\n  const components = new Array(numberOfComponents);\n  const componentReader = getComponentReader(componentType);\n\n  for (let i = 0; i < count; i++) {\n    componentReader(\n      dataView,\n      byteOffset,\n      numberOfComponents,\n      componentTypeByteLength,\n      components\n    );\n    for (let j = 0; j < numberOfComponents; j++) {\n      const value = components[j];\n      min[j] = Math.min(min[j], value);\n      max[j] = Math.max(max[j], value);\n    }\n    byteOffset += byteStride;\n  }\n\n  return {\n    min: min,\n    max: max,\n  };\n}\n\nexport default findAccessorMinMax;\n","import ForEach from \"./ForEach.js\";\nimport Check from \"../../Core/Check.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Calls the provider handler function on each texture used by the material.\n * Mimics the behavior of functions in gltf-pipeline ForEach.\n * @param {Object} material The glTF material.\n * @param {forEachTextureInMaterial~handler} handler Function that is called for each texture in the material.\n *\n * @private\n */\nfunction forEachTextureInMaterial(material, handler) {\n  Check.typeOf.object(\"material\", material);\n  Check.defined(\"handler\", handler);\n\n  // Metallic roughness\n  const pbrMetallicRoughness = material.pbrMetallicRoughness;\n  if (defined(pbrMetallicRoughness)) {\n    if (defined(pbrMetallicRoughness.baseColorTexture)) {\n      const textureInfo = pbrMetallicRoughness.baseColorTexture;\n      const value = handler(textureInfo.index, textureInfo);\n      if (defined(value)) {\n        return value;\n      }\n    }\n    if (defined(pbrMetallicRoughness.metallicRoughnessTexture)) {\n      const textureInfo = pbrMetallicRoughness.metallicRoughnessTexture;\n      const value = handler(textureInfo.index, textureInfo);\n      if (defined(value)) {\n        return value;\n      }\n    }\n  }\n\n  if (defined(material.extensions)) {\n    // Spec gloss extension\n    const pbrSpecularGlossiness =\n      material.extensions.KHR_materials_pbrSpecularGlossiness;\n    if (defined(pbrSpecularGlossiness)) {\n      if (defined(pbrSpecularGlossiness.diffuseTexture)) {\n        const textureInfo = pbrSpecularGlossiness.diffuseTexture;\n        const value = handler(textureInfo.index, textureInfo);\n        if (defined(value)) {\n          return value;\n        }\n      }\n      if (defined(pbrSpecularGlossiness.specularGlossinessTexture)) {\n        const textureInfo = pbrSpecularGlossiness.specularGlossinessTexture;\n        const value = handler(textureInfo.index, textureInfo);\n        if (defined(value)) {\n          return value;\n        }\n      }\n    }\n\n    // Materials common extension (may be present in models converted from glTF 1.0)\n    const materialsCommon = material.extensions.KHR_materials_common;\n    if (defined(materialsCommon)) {\n      const diffuse = materialsCommon.values.diffuse;\n      const ambient = materialsCommon.values.ambient;\n      const emission = materialsCommon.values.emission;\n      const specular = materialsCommon.values.specular;\n      if (defined(diffuse) && defined(diffuse.index)) {\n        const value = handler(diffuse.index, diffuse);\n        if (defined(value)) {\n          return value;\n        }\n      }\n      if (defined(ambient) && defined(ambient.index)) {\n        const value = handler(ambient.index, ambient);\n        if (defined(value)) {\n          return value;\n        }\n      }\n      if (defined(emission) && defined(emission.index)) {\n        const value = handler(emission.index, emission);\n        if (defined(value)) {\n          return value;\n        }\n      }\n      if (defined(specular) && defined(specular.index)) {\n        const value = handler(specular.index, specular);\n        if (defined(value)) {\n          return value;\n        }\n      }\n    }\n  }\n\n  // KHR_techniques_webgl extension\n  const value = ForEach.materialValue(material, function (materialValue) {\n    if (defined(materialValue.index)) {\n      const value = handler(materialValue.index, materialValue);\n      if (defined(value)) {\n        return value;\n      }\n    }\n  });\n  if (defined(value)) {\n    return value;\n  }\n\n  // Top level textures\n  if (defined(material.emissiveTexture)) {\n    const textureInfo = material.emissiveTexture;\n    const value = handler(textureInfo.index, textureInfo);\n    if (defined(value)) {\n      return value;\n    }\n  }\n\n  if (defined(material.normalTexture)) {\n    const textureInfo = material.normalTexture;\n    const value = handler(textureInfo.index, textureInfo);\n    if (defined(value)) {\n      return value;\n    }\n  }\n\n  if (defined(material.occlusionTexture)) {\n    const textureInfo = material.occlusionTexture;\n    const value = handler(textureInfo.index, textureInfo);\n    if (defined(value)) {\n      return value;\n    }\n  }\n}\n\n/**\n * Function that is called for each texture in the material. If this function returns a value the for each stops and returns that value.\n * @callback forEachTextureInMaterial~handler\n * @param {Number} The texture index.\n * @param {Object} The texture info object.\n *\n * @private\n */\n\nexport default forEachTextureInMaterial;\n","import numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Returns the byte stride of the provided accessor.\n * If the byteStride is 0, it is calculated based on type and componentType\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {Object} accessor The accessor.\n * @returns {Number} The byte stride of the accessor.\n *\n * @private\n */\nfunction getAccessorByteStride(gltf, accessor) {\n  const bufferViewId = accessor.bufferView;\n  if (defined(bufferViewId)) {\n    const bufferView = gltf.bufferViews[bufferViewId];\n    if (defined(bufferView.byteStride) && bufferView.byteStride > 0) {\n      return bufferView.byteStride;\n    }\n  }\n  return (\n    ComponentDatatype.getSizeInBytes(accessor.componentType) *\n    numberOfComponentsForType(accessor.type)\n  );\n}\n\nexport default getAccessorByteStride;\n","import ComponentDatatype from \"../../Core/ComponentDatatype.js\";\n\n/**\n * Returns a function to read and convert data from a DataView into an array.\n *\n * @param {Number} componentType Type to convert the data to.\n * @returns {ComponentReader} Function that reads and converts data.\n *\n * @private\n */\nfunction getComponentReader(componentType) {\n  switch (componentType) {\n    case ComponentDatatype.BYTE:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getInt8(\n            byteOffset + i * componentTypeByteLength\n          );\n        }\n      };\n    case ComponentDatatype.UNSIGNED_BYTE:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getUint8(\n            byteOffset + i * componentTypeByteLength\n          );\n        }\n      };\n    case ComponentDatatype.SHORT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getInt16(\n            byteOffset + i * componentTypeByteLength,\n            true\n          );\n        }\n      };\n    case ComponentDatatype.UNSIGNED_SHORT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getUint16(\n            byteOffset + i * componentTypeByteLength,\n            true\n          );\n        }\n      };\n    case ComponentDatatype.INT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getInt32(\n            byteOffset + i * componentTypeByteLength,\n            true\n          );\n        }\n      };\n    case ComponentDatatype.UNSIGNED_INT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getUint32(\n            byteOffset + i * componentTypeByteLength,\n            true\n          );\n        }\n      };\n    case ComponentDatatype.FLOAT:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getFloat32(\n            byteOffset + i * componentTypeByteLength,\n            true\n          );\n        }\n      };\n    case ComponentDatatype.DOUBLE:\n      return function (\n        dataView,\n        byteOffset,\n        numberOfComponents,\n        componentTypeByteLength,\n        result\n      ) {\n        for (let i = 0; i < numberOfComponents; ++i) {\n          result[i] = dataView.getFloat64(\n            byteOffset + i * componentTypeByteLength,\n            true\n          );\n        }\n      };\n  }\n}\n\n/**\n * A callback function that logs messages.\n * @callback ComponentReader\n *\n * @param {DataView} dataView The data view to read from.\n * @param {Number} byteOffset The byte offset applied when reading from the data view.\n * @param {Number} numberOfComponents The number of components to read.\n * @param {Number} componentTypeByteLength The byte length of each component.\n * @param {Number} result An array storing the components that are read.\n *\n * @private\n */\n\nexport default getComponentReader;\n","import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport ForEach from \"./ForEach.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\nconst defaultBlendEquation = [WebGLConstants.FUNC_ADD, WebGLConstants.FUNC_ADD];\n\nconst defaultBlendFactors = [\n  WebGLConstants.ONE,\n  WebGLConstants.ZERO,\n  WebGLConstants.ONE,\n  WebGLConstants.ZERO,\n];\n\nfunction isStateEnabled(renderStates, state) {\n  const enabled = renderStates.enable;\n  if (!defined(enabled)) {\n    return false;\n  }\n\n  return enabled.indexOf(state) > -1;\n}\n\nconst supportedBlendFactors = [\n  WebGLConstants.ZERO,\n  WebGLConstants.ONE,\n  WebGLConstants.SRC_COLOR,\n  WebGLConstants.ONE_MINUS_SRC_COLOR,\n  WebGLConstants.SRC_ALPHA,\n  WebGLConstants.ONE_MINUS_SRC_ALPHA,\n  WebGLConstants.DST_ALPHA,\n  WebGLConstants.ONE_MINUS_DST_ALPHA,\n  WebGLConstants.DST_COLOR,\n  WebGLConstants.ONE_MINUS_DST_COLOR,\n];\n\n// If any of the blend factors are not supported, return the default\nfunction getSupportedBlendFactors(value, defaultValue) {\n  if (!defined(value)) {\n    return defaultValue;\n  }\n\n  for (let i = 0; i < 4; i++) {\n    if (supportedBlendFactors.indexOf(value[i]) === -1) {\n      return defaultValue;\n    }\n  }\n\n  return value;\n}\n\n/**\n * Move glTF 1.0 technique render states to glTF 2.0 materials properties and KHR_blend extension.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The updated glTF asset.\n *\n * @private\n */\nfunction moveTechniqueRenderStates(gltf) {\n  const blendingForTechnique = {};\n  const materialPropertiesForTechnique = {};\n  const techniquesLegacy = gltf.techniques;\n  if (!defined(techniquesLegacy)) {\n    return gltf;\n  }\n\n  ForEach.technique(gltf, function (techniqueLegacy, techniqueIndex) {\n    const renderStates = techniqueLegacy.states;\n    if (defined(renderStates)) {\n      const materialProperties = (materialPropertiesForTechnique[\n        techniqueIndex\n      ] = {});\n\n      // If BLEND is enabled, the material should have alpha mode BLEND\n      if (isStateEnabled(renderStates, WebGLConstants.BLEND)) {\n        materialProperties.alphaMode = \"BLEND\";\n\n        const blendFunctions = renderStates.functions;\n        if (\n          defined(blendFunctions) &&\n          (defined(blendFunctions.blendEquationSeparate) ||\n            defined(blendFunctions.blendFuncSeparate))\n        ) {\n          blendingForTechnique[techniqueIndex] = {\n            blendEquation: defaultValue(\n              blendFunctions.blendEquationSeparate,\n              defaultBlendEquation\n            ),\n            blendFactors: getSupportedBlendFactors(\n              blendFunctions.blendFuncSeparate,\n              defaultBlendFactors\n            ),\n          };\n        }\n      }\n\n      // If CULL_FACE is not enabled, the material should be doubleSided\n      if (!isStateEnabled(renderStates, WebGLConstants.CULL_FACE)) {\n        materialProperties.doubleSided = true;\n      }\n\n      delete techniqueLegacy.states;\n    }\n  });\n\n  if (Object.keys(blendingForTechnique).length > 0) {\n    if (!defined(gltf.extensions)) {\n      gltf.extensions = {};\n    }\n\n    addExtensionsUsed(gltf, \"KHR_blend\");\n  }\n\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      const materialProperties =\n        materialPropertiesForTechnique[material.technique];\n      ForEach.objectLegacy(materialProperties, function (value, property) {\n        material[property] = value;\n      });\n\n      const blending = blendingForTechnique[material.technique];\n      if (defined(blending)) {\n        if (!defined(material.extensions)) {\n          material.extensions = {};\n        }\n\n        material.extensions.KHR_blend = blending;\n      }\n    }\n  });\n\n  return gltf;\n}\n\nexport default moveTechniqueRenderStates;\n","import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addExtensionsRequired from \"./addExtensionsRequired.js\";\nimport addToArray from \"./addToArray.js\";\nimport ForEach from \"./ForEach.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Move glTF 1.0 material techniques to glTF 2.0 KHR_techniques_webgl extension.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The updated glTF asset.\n *\n * @private\n */\nfunction moveTechniquesToExtension(gltf) {\n  const techniquesLegacy = gltf.techniques;\n  const mappedUniforms = {};\n  const updatedTechniqueIndices = {};\n  const seenPrograms = {};\n  if (defined(techniquesLegacy)) {\n    const extension = {\n      programs: [],\n      shaders: [],\n      techniques: [],\n    };\n\n    // Some 1.1 models have a glExtensionsUsed property that can be transferred to program.glExtensions\n    const glExtensions = gltf.glExtensionsUsed;\n    delete gltf.glExtensionsUsed;\n\n    ForEach.technique(gltf, function (techniqueLegacy, techniqueId) {\n      const technique = {\n        name: techniqueLegacy.name,\n        program: undefined,\n        attributes: {},\n        uniforms: {},\n      };\n\n      let parameterLegacy;\n      ForEach.techniqueAttribute(\n        techniqueLegacy,\n        function (parameterName, attributeName) {\n          parameterLegacy = techniqueLegacy.parameters[parameterName];\n          technique.attributes[attributeName] = {\n            semantic: parameterLegacy.semantic,\n          };\n        }\n      );\n\n      ForEach.techniqueUniform(\n        techniqueLegacy,\n        function (parameterName, uniformName) {\n          parameterLegacy = techniqueLegacy.parameters[parameterName];\n          technique.uniforms[uniformName] = {\n            count: parameterLegacy.count,\n            node: parameterLegacy.node,\n            type: parameterLegacy.type,\n            semantic: parameterLegacy.semantic,\n            value: parameterLegacy.value,\n          };\n\n          // Store the name of the uniform to update material values.\n          if (!defined(mappedUniforms[techniqueId])) {\n            mappedUniforms[techniqueId] = {};\n          }\n          mappedUniforms[techniqueId][parameterName] = uniformName;\n        }\n      );\n\n      if (!defined(seenPrograms[techniqueLegacy.program])) {\n        const programLegacy = gltf.programs[techniqueLegacy.program];\n\n        const program = {\n          name: programLegacy.name,\n          fragmentShader: undefined,\n          vertexShader: undefined,\n          glExtensions: glExtensions,\n        };\n\n        const fs = gltf.shaders[programLegacy.fragmentShader];\n        program.fragmentShader = addToArray(extension.shaders, fs, true);\n\n        const vs = gltf.shaders[programLegacy.vertexShader];\n        program.vertexShader = addToArray(extension.shaders, vs, true);\n\n        technique.program = addToArray(extension.programs, program);\n        seenPrograms[techniqueLegacy.program] = technique.program;\n      } else {\n        technique.program = seenPrograms[techniqueLegacy.program];\n      }\n\n      // Store the index of the new technique to reference instead.\n      updatedTechniqueIndices[techniqueId] = addToArray(\n        extension.techniques,\n        technique\n      );\n    });\n\n    if (extension.techniques.length > 0) {\n      if (!defined(gltf.extensions)) {\n        gltf.extensions = {};\n      }\n\n      gltf.extensions.KHR_techniques_webgl = extension;\n      addExtensionsUsed(gltf, \"KHR_techniques_webgl\");\n      addExtensionsRequired(gltf, \"KHR_techniques_webgl\");\n    }\n  }\n\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      const materialExtension = {\n        technique: updatedTechniqueIndices[material.technique],\n      };\n\n      ForEach.objectLegacy(material.values, function (value, parameterName) {\n        if (!defined(materialExtension.values)) {\n          materialExtension.values = {};\n        }\n\n        const uniformName = mappedUniforms[material.technique][parameterName];\n        materialExtension.values[uniformName] = value;\n      });\n\n      if (!defined(material.extensions)) {\n        material.extensions = {};\n      }\n\n      material.extensions.KHR_techniques_webgl = materialExtension;\n    }\n\n    delete material.technique;\n    delete material.values;\n  });\n\n  delete gltf.techniques;\n  delete gltf.programs;\n  delete gltf.shaders;\n\n  return gltf;\n}\n\nexport default moveTechniquesToExtension;\n","\n\n/**\n * Utility function for retrieving the number of components in a given type.\n *\n * @param {String} type glTF type\n * @returns {Number} The number of components in that type.\n *\n * @private\n */\nfunction numberOfComponentsForType(type) {\n  switch (type) {\n    case \"SCALAR\":\n      return 1;\n    case \"VEC2\":\n      return 2;\n    case \"VEC3\":\n      return 3;\n    case \"VEC4\":\n    case \"MAT2\":\n      return 4;\n    case \"MAT3\":\n      return 9;\n    case \"MAT4\":\n      return 16;\n  }\n}\n\nexport default numberOfComponentsForType;\n","import addPipelineExtras from \"./addPipelineExtras.js\";\nimport removeExtensionsUsed from \"./removeExtensionsUsed.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport getMagic from \"../../Core/getMagic.js\";\nimport getStringFromTypedArray from \"../../Core/getStringFromTypedArray.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\n\nconst sizeOfUint32 = 4;\n\n/**\n * Convert a binary glTF to glTF.\n *\n * The returned glTF has pipeline extras included. The embedded binary data is stored in gltf.buffers[0].extras._pipeline.source.\n *\n * @param {Buffer} glb The glb data to parse.\n * @returns {Object} A javascript object containing a glTF asset with pipeline extras included.\n *\n * @private\n */\nfunction parseGlb(glb) {\n  // Check that the magic string is present\n  const magic = getMagic(glb);\n  if (magic !== \"glTF\") {\n    throw new RuntimeError(\"File is not valid binary glTF\");\n  }\n\n  const header = readHeader(glb, 0, 5);\n  const version = header[1];\n  if (version !== 1 && version !== 2) {\n    throw new RuntimeError(\"Binary glTF version is not 1 or 2\");\n  }\n\n  if (version === 1) {\n    return parseGlbVersion1(glb, header);\n  }\n\n  return parseGlbVersion2(glb, header);\n}\n\nfunction readHeader(glb, byteOffset, count) {\n  const dataView = new DataView(glb.buffer);\n  const header = new Array(count);\n  for (let i = 0; i < count; ++i) {\n    header[i] = dataView.getUint32(\n      glb.byteOffset + byteOffset + i * sizeOfUint32,\n      true\n    );\n  }\n  return header;\n}\n\nfunction parseGlbVersion1(glb, header) {\n  const length = header[2];\n  const contentLength = header[3];\n  const contentFormat = header[4];\n\n  // Check that the content format is 0, indicating that it is JSON\n  if (contentFormat !== 0) {\n    throw new RuntimeError(\"Binary glTF scene format is not JSON\");\n  }\n\n  const jsonStart = 20;\n  const binaryStart = jsonStart + contentLength;\n\n  const contentString = getStringFromTypedArray(glb, jsonStart, contentLength);\n  const gltf = JSON.parse(contentString);\n  addPipelineExtras(gltf);\n\n  const binaryBuffer = glb.subarray(binaryStart, length);\n\n  const buffers = gltf.buffers;\n  if (defined(buffers) && Object.keys(buffers).length > 0) {\n    // In some older models, the binary glTF buffer is named KHR_binary_glTF\n    const binaryGltfBuffer = defaultValue(\n      buffers.binary_glTF,\n      buffers.KHR_binary_glTF\n    );\n    if (defined(binaryGltfBuffer)) {\n      binaryGltfBuffer.extras._pipeline.source = binaryBuffer;\n      delete binaryGltfBuffer.uri;\n    }\n  }\n  // Remove the KHR_binary_glTF extension\n  removeExtensionsUsed(gltf, \"KHR_binary_glTF\");\n  return gltf;\n}\n\nfunction parseGlbVersion2(glb, header) {\n  const length = header[2];\n  let byteOffset = 12;\n  let gltf;\n  let binaryBuffer;\n  while (byteOffset < length) {\n    const chunkHeader = readHeader(glb, byteOffset, 2);\n    const chunkLength = chunkHeader[0];\n    const chunkType = chunkHeader[1];\n    byteOffset += 8;\n    const chunkBuffer = glb.subarray(byteOffset, byteOffset + chunkLength);\n    byteOffset += chunkLength;\n    // Load JSON chunk\n    if (chunkType === 0x4e4f534a) {\n      const jsonString = getStringFromTypedArray(chunkBuffer);\n      gltf = JSON.parse(jsonString);\n      addPipelineExtras(gltf);\n    }\n    // Load Binary chunk\n    else if (chunkType === 0x004e4942) {\n      binaryBuffer = chunkBuffer;\n    }\n  }\n  if (defined(gltf) && defined(binaryBuffer)) {\n    const buffers = gltf.buffers;\n    if (defined(buffers) && buffers.length > 0) {\n      const buffer = buffers[0];\n      buffer.extras._pipeline.source = binaryBuffer;\n    }\n  }\n  return gltf;\n}\n\nexport default parseGlb;\n","import getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport getComponentReader from \"./getComponentReader.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport arrayFill from \"../../Core/arrayFill.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Returns the accessor data in a contiguous array.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {Object} accessor The accessor.\n * @returns {Array} The accessor values in a contiguous array.\n *\n * @private\n */\nfunction readAccessorPacked(gltf, accessor) {\n  const byteStride = getAccessorByteStride(gltf, accessor);\n  const componentTypeByteLength = ComponentDatatype.getSizeInBytes(\n    accessor.componentType\n  );\n  const numberOfComponents = numberOfComponentsForType(accessor.type);\n  const count = accessor.count;\n  const values = new Array(numberOfComponents * count);\n\n  if (!defined(accessor.bufferView)) {\n    arrayFill(values, 0);\n    return values;\n  }\n\n  const bufferView = gltf.bufferViews[accessor.bufferView];\n  const source = gltf.buffers[bufferView.buffer].extras._pipeline.source;\n  let byteOffset =\n    accessor.byteOffset + bufferView.byteOffset + source.byteOffset;\n\n  const dataView = new DataView(source.buffer);\n  const components = new Array(numberOfComponents);\n  const componentReader = getComponentReader(accessor.componentType);\n\n  for (let i = 0; i < count; ++i) {\n    componentReader(\n      dataView,\n      byteOffset,\n      numberOfComponents,\n      componentTypeByteLength,\n      components\n    );\n    for (let j = 0; j < numberOfComponents; ++j) {\n      values[i * numberOfComponents + j] = components[j];\n    }\n    byteOffset += byteStride;\n  }\n  return values;\n}\n\nexport default readAccessorPacked;\n","import defined from \"../../Core/defined.js\";\n\n/**\n * Removes an extension from gltf.extensionsRequired if it is present.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {String} extension The extension to remove.\n *\n * @private\n */\nfunction removeExtensionsRequired(gltf, extension) {\n  const extensionsRequired = gltf.extensionsRequired;\n  if (defined(extensionsRequired)) {\n    const index = extensionsRequired.indexOf(extension);\n    if (index >= 0) {\n      extensionsRequired.splice(index, 1);\n    }\n    if (extensionsRequired.length === 0) {\n      delete gltf.extensionsRequired;\n    }\n  }\n}\n\nexport default removeExtensionsRequired;\n","import removeExtensionsRequired from \"./removeExtensionsRequired.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Removes an extension from gltf.extensionsUsed and gltf.extensionsRequired if it is present.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {String} extension The extension to remove.\n *\n * @private\n */\nfunction removeExtensionsUsed(gltf, extension) {\n  const extensionsUsed = gltf.extensionsUsed;\n  if (defined(extensionsUsed)) {\n    const index = extensionsUsed.indexOf(extension);\n    if (index >= 0) {\n      extensionsUsed.splice(index, 1);\n    }\n    removeExtensionsRequired(gltf, extension);\n    if (extensionsUsed.length === 0) {\n      delete gltf.extensionsUsed;\n    }\n  }\n}\n\nexport default removeExtensionsUsed;\n","import ForEach from \"./ForEach.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * Iterate through the objects within the glTF and delete their pipeline extras object.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} glTF with no pipeline extras.\n *\n * @private\n */\nfunction removePipelineExtras(gltf) {\n  ForEach.shader(gltf, function (shader) {\n    removeExtras(shader);\n  });\n  ForEach.buffer(gltf, function (buffer) {\n    removeExtras(buffer);\n  });\n  ForEach.image(gltf, function (image) {\n    removeExtras(image);\n  });\n\n  removeExtras(gltf);\n\n  return gltf;\n}\n\nfunction removeExtras(object) {\n  if (!defined(object.extras)) {\n    return;\n  }\n\n  if (defined(object.extras._pipeline)) {\n    delete object.extras._pipeline;\n  }\n\n  if (Object.keys(object.extras).length === 0) {\n    delete object.extras;\n  }\n}\n\nexport default removePipelineExtras;\n","import ForEach from \"./ForEach.js\";\nimport forEachTextureInMaterial from \"./forEachTextureInMaterial.js\";\nimport usesExtension from \"./usesExtension.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\n\nconst allElementTypes = [\n  \"mesh\",\n  \"node\",\n  \"material\",\n  \"accessor\",\n  \"bufferView\",\n  \"buffer\",\n  \"texture\",\n  \"sampler\",\n  \"image\",\n];\n\n/**\n * Removes unused elements from gltf.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {String[]} [elementTypes=['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer']] Element types to be removed. Needs to be a subset of ['mesh', 'node', 'material', 'accessor', 'bufferView', 'buffer'], other items will be ignored.\n *\n * @private\n */\nfunction removeUnusedElements(gltf, elementTypes) {\n  elementTypes = defaultValue(elementTypes, allElementTypes);\n  allElementTypes.forEach(function (type) {\n    if (elementTypes.indexOf(type) > -1) {\n      removeUnusedElementsByType(gltf, type);\n    }\n  });\n  return gltf;\n}\n\nconst TypeToGltfElementName = {\n  accessor: \"accessors\",\n  buffer: \"buffers\",\n  bufferView: \"bufferViews\",\n  image: \"images\",\n  node: \"nodes\",\n  material: \"materials\",\n  mesh: \"meshes\",\n  sampler: \"samplers\",\n  texture: \"textures\",\n};\n\nfunction removeUnusedElementsByType(gltf, type) {\n  const name = TypeToGltfElementName[type];\n  const arrayOfObjects = gltf[name];\n\n  if (defined(arrayOfObjects)) {\n    let removed = 0;\n    const usedIds = getListOfElementsIdsInUse[type](gltf);\n    const length = arrayOfObjects.length;\n\n    for (let i = 0; i < length; ++i) {\n      if (!usedIds[i]) {\n        Remove[type](gltf, i - removed);\n        removed++;\n      }\n    }\n  }\n}\n\n/**\n * Contains functions for removing elements from a glTF hierarchy.\n * Since top-level glTF elements are arrays, when something is removed, referring\n * indices need to be updated.\n * @constructor\n *\n * @private\n */\nfunction Remove() {}\n\nRemove.accessor = function (gltf, accessorId) {\n  const accessors = gltf.accessors;\n\n  accessors.splice(accessorId, 1);\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      // Update accessor ids for the primitives.\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (attributeAccessorId, semantic) {\n          if (attributeAccessorId > accessorId) {\n            primitive.attributes[semantic]--;\n          }\n        }\n      );\n\n      // Update accessor ids for the targets.\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(\n          target,\n          function (attributeAccessorId, semantic) {\n            if (attributeAccessorId > accessorId) {\n              target[semantic]--;\n            }\n          }\n        );\n      });\n      const indices = primitive.indices;\n      if (defined(indices) && indices > accessorId) {\n        primitive.indices--;\n      }\n    });\n  });\n\n  ForEach.skin(gltf, function (skin) {\n    if (\n      defined(skin.inverseBindMatrices) &&\n      skin.inverseBindMatrices > accessorId\n    ) {\n      skin.inverseBindMatrices--;\n    }\n  });\n\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input) && sampler.input > accessorId) {\n        sampler.input--;\n      }\n      if (defined(sampler.output) && sampler.output > accessorId) {\n        sampler.output--;\n      }\n    });\n  });\n};\n\nRemove.buffer = function (gltf, bufferId) {\n  const buffers = gltf.buffers;\n\n  buffers.splice(bufferId, 1);\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer) && bufferView.buffer > bufferId) {\n      bufferView.buffer--;\n    }\n\n    if (\n      defined(bufferView.extensions) &&\n      defined(bufferView.extensions.EXT_meshopt_compression)\n    ) {\n      bufferView.extensions.EXT_meshopt_compression.buffer--;\n    }\n  });\n};\n\nRemove.bufferView = function (gltf, bufferViewId) {\n  const bufferViews = gltf.bufferViews;\n\n  bufferViews.splice(bufferViewId, 1);\n\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView) && accessor.bufferView > bufferViewId) {\n      accessor.bufferView--;\n    }\n  });\n\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView) && shader.bufferView > bufferViewId) {\n      shader.bufferView--;\n    }\n  });\n\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView) && image.bufferView > bufferViewId) {\n      image.bufferView--;\n    }\n  });\n\n  if (usesExtension(gltf, \"KHR_draco_mesh_compression\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (\n          defined(primitive.extensions) &&\n          defined(primitive.extensions.KHR_draco_mesh_compression)\n        ) {\n          if (\n            primitive.extensions.KHR_draco_mesh_compression.bufferView >\n            bufferViewId\n          ) {\n            primitive.extensions.KHR_draco_mesh_compression.bufferView--;\n          }\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTables = extension.featureTables;\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              if (\n                defined(property.bufferView) &&\n                property.bufferView > bufferViewId\n              ) {\n                property.bufferView--;\n              }\n              if (\n                defined(property.arrayOffsetBufferView) &&\n                property.arrayOffsetBufferView > bufferViewId\n              ) {\n                property.arrayOffsetBufferView--;\n              }\n              if (\n                defined(property.stringOffsetBufferView) &&\n                property.stringOffsetBufferView > bufferViewId\n              ) {\n                property.stringOffsetBufferView--;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nRemove.image = function (gltf, imageId) {\n  const images = gltf.images;\n  images.splice(imageId, 1);\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.source)) {\n      if (texture.source > imageId) {\n        --texture.source;\n      }\n    }\n    const ext = texture.extensions;\n    if (\n      defined(ext) &&\n      defined(ext.EXT_texture_webp) &&\n      ext.EXT_texture_webp.source > imageId\n    ) {\n      --texture.extensions.EXT_texture_webp.source;\n    } else if (\n      defined(ext) &&\n      defined(ext.KHR_texture_basisu) &&\n      ext.KHR_texture_basisu.source > imageId\n    ) {\n      --texture.extensions.KHR_texture_basisu.source;\n    }\n  });\n};\n\nRemove.mesh = function (gltf, meshId) {\n  const meshes = gltf.meshes;\n  meshes.splice(meshId, 1);\n\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh)) {\n      if (node.mesh > meshId) {\n        node.mesh--;\n      } else if (node.mesh === meshId) {\n        // Remove reference to deleted mesh\n        delete node.mesh;\n      }\n    }\n  });\n};\n\nRemove.node = function (gltf, nodeId) {\n  const nodes = gltf.nodes;\n  nodes.splice(nodeId, 1);\n\n  // Shift all node references\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton) && skin.skeleton > nodeId) {\n      skin.skeleton--;\n    }\n\n    skin.joints = skin.joints.map(function (x) {\n      return x > nodeId ? x - 1 : x;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (\n        defined(channel.target) &&\n        defined(channel.target.node) &&\n        channel.target.node > nodeId\n      ) {\n        channel.target.node--;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node) && uniform.node > nodeId) {\n        uniform.node--;\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    if (!defined(node.children)) {\n      return;\n    }\n\n    node.children = node.children\n      .filter(function (x) {\n        return x !== nodeId; // Remove\n      })\n      .map(function (x) {\n        return x > nodeId ? x - 1 : x; // Shift indices\n      });\n  });\n  ForEach.scene(gltf, function (scene) {\n    scene.nodes = scene.nodes\n      .filter(function (x) {\n        return x !== nodeId; // Remove\n      })\n      .map(function (x) {\n        return x > nodeId ? x - 1 : x; // Shift indices\n      });\n  });\n};\n\nRemove.material = function (gltf, materialId) {\n  const materials = gltf.materials;\n  materials.splice(materialId, 1);\n\n  // Shift other material ids\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material) && primitive.material > materialId) {\n        primitive.material--;\n      }\n    });\n  });\n};\n\nRemove.sampler = function (gltf, samplerId) {\n  const samplers = gltf.samplers;\n  samplers.splice(samplerId, 1);\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      if (texture.sampler > samplerId) {\n        --texture.sampler;\n      }\n    }\n  });\n};\n\nRemove.texture = function (gltf, textureId) {\n  const textures = gltf.textures;\n  textures.splice(textureId, 1);\n\n  ForEach.material(gltf, function (material) {\n    forEachTextureInMaterial(material, function (textureIndex, textureInfo) {\n      if (textureInfo.index > textureId) {\n        --textureInfo.index;\n      }\n    });\n  });\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_feature_metadata)) {\n          const extension = extensions.EXT_feature_metadata;\n          const featureIdTextures = extension.featureIdTextures;\n          if (defined(featureIdTextures)) {\n            const featureIdTexturesLength = featureIdTextures.length;\n            for (let i = 0; i < featureIdTexturesLength; ++i) {\n              const featureIdTexture = featureIdTextures[i];\n              const textureInfo = featureIdTexture.featureIds.texture;\n              if (textureInfo.index > textureId) {\n                --textureInfo.index;\n              }\n            }\n          }\n        }\n      });\n    });\n\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTextures = extension.featureTextures;\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              const textureInfo = property.texture;\n              if (textureInfo.index > textureId) {\n                --textureInfo.index;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\n * Contains functions for getting a list of element ids in use by the glTF asset.\n * @constructor\n *\n * @private\n */\nfunction getListOfElementsIdsInUse() {}\n\ngetListOfElementsIdsInUse.accessor = function (gltf) {\n  // Calculate accessor's that are currently in use.\n  const usedAccessorIds = {};\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId) {\n        usedAccessorIds[accessorId] = true;\n      });\n      ForEach.meshPrimitiveTarget(primitive, function (target) {\n        ForEach.meshPrimitiveTargetAttribute(target, function (accessorId) {\n          usedAccessorIds[accessorId] = true;\n        });\n      });\n      const indices = primitive.indices;\n      if (defined(indices)) {\n        usedAccessorIds[indices] = true;\n      }\n    });\n  });\n\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      usedAccessorIds[skin.inverseBindMatrices] = true;\n    }\n  });\n\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      if (defined(sampler.input)) {\n        usedAccessorIds[sampler.input] = true;\n      }\n      if (defined(sampler.output)) {\n        usedAccessorIds[sampler.output] = true;\n      }\n    });\n  });\n\n  if (usesExtension(gltf, \"EXT_mesh_gpu_instancing\")) {\n    ForEach.node(gltf, function (node) {\n      if (\n        defined(node.extensions) &&\n        defined(node.extensions.EXT_mesh_gpu_instancing)\n      ) {\n        Object.keys(node.extensions.EXT_mesh_gpu_instancing.attributes).forEach(\n          function (key) {\n            const attributeAccessorId =\n              node.extensions.EXT_mesh_gpu_instancing.attributes[key];\n            usedAccessorIds[attributeAccessorId] = true;\n          }\n        );\n      }\n    });\n  }\n\n  return usedAccessorIds;\n};\n\ngetListOfElementsIdsInUse.buffer = function (gltf) {\n  // Calculate buffer's that are currently in use.\n  const usedBufferIds = {};\n\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      usedBufferIds[bufferView.buffer] = true;\n    }\n    if (\n      defined(bufferView.extensions) &&\n      defined(bufferView.extensions.EXT_meshopt_compression)\n    ) {\n      usedBufferIds[\n        bufferView.extensions.EXT_meshopt_compression.buffer\n      ] = true;\n    }\n  });\n\n  return usedBufferIds;\n};\n\ngetListOfElementsIdsInUse.bufferView = function (gltf) {\n  // Calculate bufferView's that are currently in use.\n  const usedBufferViewIds = {};\n\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      usedBufferViewIds[accessor.bufferView] = true;\n    }\n  });\n\n  ForEach.shader(gltf, function (shader) {\n    if (defined(shader.bufferView)) {\n      usedBufferViewIds[shader.bufferView] = true;\n    }\n  });\n\n  ForEach.image(gltf, function (image) {\n    if (defined(image.bufferView)) {\n      usedBufferViewIds[image.bufferView] = true;\n    }\n  });\n\n  if (usesExtension(gltf, \"KHR_draco_mesh_compression\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        if (\n          defined(primitive.extensions) &&\n          defined(primitive.extensions.KHR_draco_mesh_compression)\n        ) {\n          usedBufferViewIds[\n            primitive.extensions.KHR_draco_mesh_compression.bufferView\n          ] = true;\n        }\n      });\n    });\n  }\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTables = extension.featureTables;\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              if (defined(property.bufferView)) {\n                usedBufferViewIds[property.bufferView] = true;\n              }\n              if (defined(property.arrayOffsetBufferView)) {\n                usedBufferViewIds[property.arrayOffsetBufferView] = true;\n              }\n              if (defined(property.stringOffsetBufferView)) {\n                usedBufferViewIds[property.stringOffsetBufferView] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return usedBufferViewIds;\n};\n\ngetListOfElementsIdsInUse.image = function (gltf) {\n  const usedImageIds = {};\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.source)) {\n      usedImageIds[texture.source] = true;\n    }\n\n    if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.EXT_texture_webp)\n    ) {\n      usedImageIds[texture.extensions.EXT_texture_webp.source] = true;\n    } else if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.KHR_texture_basisu)\n    ) {\n      usedImageIds[texture.extensions.KHR_texture_basisu.source] = true;\n    }\n  });\n  return usedImageIds;\n};\n\ngetListOfElementsIdsInUse.mesh = function (gltf) {\n  const usedMeshIds = {};\n  ForEach.node(gltf, function (node) {\n    if (defined(node.mesh && defined(gltf.meshes))) {\n      const mesh = gltf.meshes[node.mesh];\n      if (\n        defined(mesh) &&\n        defined(mesh.primitives) &&\n        mesh.primitives.length > 0\n      ) {\n        usedMeshIds[node.mesh] = true;\n      }\n    }\n  });\n\n  return usedMeshIds;\n};\n\n// Check if node is empty. It is considered empty if neither referencing\n// mesh, camera, extensions and has no children\nfunction nodeIsEmpty(gltf, nodeId, usedNodeIds) {\n  const node = gltf.nodes[nodeId];\n  if (\n    defined(node.mesh) ||\n    defined(node.camera) ||\n    defined(node.skin) ||\n    defined(node.weights) ||\n    defined(node.extras) ||\n    (defined(node.extensions) && Object.keys(node.extensions).length !== 0) ||\n    defined(usedNodeIds[nodeId])\n  ) {\n    return false;\n  }\n\n  // Empty if no children or children are all empty nodes\n  return (\n    !defined(node.children) ||\n    node.children.filter(function (n) {\n      return !nodeIsEmpty(gltf, n, usedNodeIds);\n    }).length === 0\n  );\n}\n\ngetListOfElementsIdsInUse.node = function (gltf) {\n  const usedNodeIds = {};\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.skeleton)) {\n      usedNodeIds[skin.skeleton] = true;\n    }\n\n    ForEach.skinJoint(skin, function (joint) {\n      usedNodeIds[joint] = true;\n    });\n  });\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationChannel(animation, function (channel) {\n      if (defined(channel.target) && defined(channel.target.node)) {\n        usedNodeIds[channel.target.node] = true;\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueUniform(technique, function (uniform) {\n      if (defined(uniform.node)) {\n        usedNodeIds[uniform.node] = true;\n      }\n    });\n  });\n  ForEach.node(gltf, function (node, nodeId) {\n    if (!nodeIsEmpty(gltf, nodeId, usedNodeIds)) {\n      usedNodeIds[nodeId] = true;\n    }\n  });\n\n  return usedNodeIds;\n};\n\ngetListOfElementsIdsInUse.material = function (gltf) {\n  const usedMaterialIds = {};\n\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.material)) {\n        usedMaterialIds[primitive.material] = true;\n      }\n    });\n  });\n\n  return usedMaterialIds;\n};\n\ngetListOfElementsIdsInUse.texture = function (gltf) {\n  const usedTextureIds = {};\n\n  ForEach.material(gltf, function (material) {\n    forEachTextureInMaterial(material, function (textureId) {\n      usedTextureIds[textureId] = true;\n    });\n  });\n\n  if (usesExtension(gltf, \"EXT_feature_metadata\")) {\n    ForEach.mesh(gltf, function (mesh) {\n      ForEach.meshPrimitive(mesh, function (primitive) {\n        const extensions = primitive.extensions;\n        if (defined(extensions) && defined(extensions.EXT_feature_metadata)) {\n          const extension = extensions.EXT_feature_metadata;\n          const featureIdTextures = extension.featureIdTextures;\n          if (defined(featureIdTextures)) {\n            const featureIdTexturesLength = featureIdTextures.length;\n            for (let i = 0; i < featureIdTexturesLength; ++i) {\n              const featureIdTexture = featureIdTextures[i];\n              const textureInfo = featureIdTexture.featureIds.texture;\n              usedTextureIds[textureInfo.index] = true;\n            }\n          }\n        }\n      });\n    });\n\n    const extension = gltf.extensions.EXT_feature_metadata;\n    const featureTextures = extension.featureTextures;\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          for (const propertyId in properties) {\n            if (properties.hasOwnProperty(propertyId)) {\n              const property = properties[propertyId];\n              const textureInfo = property.texture;\n              usedTextureIds[textureInfo.index] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return usedTextureIds;\n};\n\ngetListOfElementsIdsInUse.sampler = function (gltf) {\n  const usedSamplerIds = {};\n\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      usedSamplerIds[texture.sampler] = true;\n    }\n  });\n\n  return usedSamplerIds;\n};\n\nexport default removeUnusedElements;\n","import addBuffer from \"./addBuffer.js\";\nimport ForEach from \"./ForEach.js\";\nimport readAccessorPacked from \"./readAccessorPacked.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\n/**\n * Update accessors referenced by JOINTS_0 and WEIGHTS_0 attributes to use correct component types.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset with compressed meshes.\n *\n * @private\n */\nfunction updateAccessorComponentTypes(gltf) {\n  let componentType;\n  ForEach.accessorWithSemantic(gltf, \"JOINTS_0\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    componentType = accessor.componentType;\n    if (componentType === WebGLConstants.BYTE) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n    } else if (\n      componentType !== WebGLConstants.UNSIGNED_BYTE &&\n      componentType !== WebGLConstants.UNSIGNED_SHORT\n    ) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n    }\n  });\n  ForEach.accessorWithSemantic(gltf, \"WEIGHTS_0\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    componentType = accessor.componentType;\n    if (componentType === WebGLConstants.BYTE) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_BYTE);\n    } else if (componentType === WebGLConstants.SHORT) {\n      convertType(gltf, accessor, ComponentDatatype.UNSIGNED_SHORT);\n    }\n  });\n\n  return gltf;\n}\n\nfunction convertType(gltf, accessor, updatedComponentType) {\n  const typedArray = ComponentDatatype.createTypedArray(\n    updatedComponentType,\n    readAccessorPacked(gltf, accessor)\n  );\n  const newBuffer = new Uint8Array(typedArray.buffer);\n  accessor.bufferView = addBuffer(gltf, newBuffer);\n  accessor.componentType = updatedComponentType;\n  accessor.byteOffset = 0;\n}\n\nexport default updateAccessorComponentTypes;\n","import addExtensionsUsed from \"./addExtensionsUsed.js\";\nimport addToArray from \"./addToArray.js\";\nimport findAccessorMinMax from \"./findAccessorMinMax.js\";\nimport ForEach from \"./ForEach.js\";\nimport getAccessorByteStride from \"./getAccessorByteStride.js\";\nimport numberOfComponentsForType from \"./numberOfComponentsForType.js\";\nimport moveTechniqueRenderStates from \"./moveTechniqueRenderStates.js\";\nimport moveTechniquesToExtension from \"./moveTechniquesToExtension.js\";\nimport removeUnusedElements from \"./removeUnusedElements.js\";\nimport updateAccessorComponentTypes from \"./updateAccessorComponentTypes.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport clone from \"../../Core/clone.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport WebGLConstants from \"../../Core/WebGLConstants.js\";\n\nconst updateFunctions = {\n  0.8: glTF08to10,\n  \"1.0\": glTF10to20,\n  \"2.0\": undefined,\n};\n\n/**\n * Update the glTF version to the latest version (2.0), or targetVersion if specified.\n * Applies changes made to the glTF spec between revisions so that the core library\n * only has to handle the latest version.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {Object} [options] Options for updating the glTF.\n * @param {String} [options.targetVersion] The glTF will be upgraded until it hits the specified version.\n * @returns {Object} The updated glTF asset.\n *\n * @private\n */\nfunction updateVersion(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const targetVersion = options.targetVersion;\n  let version = gltf.version;\n\n  gltf.asset = defaultValue(gltf.asset, {\n    version: \"1.0\",\n  });\n\n  gltf.asset.version = defaultValue(gltf.asset.version, \"1.0\");\n  version = defaultValue(version, gltf.asset.version).toString();\n\n  // Invalid version\n  if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n    // Try truncating trailing version numbers, could be a number as well if it is 0.8\n    if (defined(version)) {\n      version = version.substring(0, 3);\n    }\n    // Default to 1.0 if it cannot be determined\n    if (!Object.prototype.hasOwnProperty.call(updateFunctions, version)) {\n      version = \"1.0\";\n    }\n  }\n\n  let updateFunction = updateFunctions[version];\n\n  while (defined(updateFunction)) {\n    if (version === targetVersion) {\n      break;\n    }\n    updateFunction(gltf, options);\n    version = gltf.asset.version;\n    updateFunction = updateFunctions[version];\n  }\n  return gltf;\n}\n\nfunction updateInstanceTechniques(gltf) {\n  const materials = gltf.materials;\n  for (const materialId in materials) {\n    if (Object.prototype.hasOwnProperty.call(materials, materialId)) {\n      const material = materials[materialId];\n      const instanceTechnique = material.instanceTechnique;\n      if (defined(instanceTechnique)) {\n        material.technique = instanceTechnique.technique;\n        material.values = instanceTechnique.values;\n        delete material.instanceTechnique;\n      }\n    }\n  }\n}\n\nfunction setPrimitiveModes(gltf) {\n  const meshes = gltf.meshes;\n  for (const meshId in meshes) {\n    if (Object.prototype.hasOwnProperty.call(meshes, meshId)) {\n      const mesh = meshes[meshId];\n      const primitives = mesh.primitives;\n      if (defined(primitives)) {\n        const primitivesLength = primitives.length;\n        for (let i = 0; i < primitivesLength; ++i) {\n          const primitive = primitives[i];\n          const defaultMode = defaultValue(\n            primitive.primitive,\n            WebGLConstants.TRIANGLES\n          );\n          primitive.mode = defaultValue(primitive.mode, defaultMode);\n          delete primitive.primitive;\n        }\n      }\n    }\n  }\n}\n\nfunction updateNodes(gltf) {\n  const nodes = gltf.nodes;\n  const axis = new Cartesian3();\n  const quat = new Quaternion();\n  for (const nodeId in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n      const node = nodes[nodeId];\n      if (defined(node.rotation)) {\n        const rotation = node.rotation;\n        Cartesian3.fromArray(rotation, 0, axis);\n        Quaternion.fromAxisAngle(axis, rotation[3], quat);\n        node.rotation = [quat.x, quat.y, quat.z, quat.w];\n      }\n      const instanceSkin = node.instanceSkin;\n      if (defined(instanceSkin)) {\n        node.skeletons = instanceSkin.skeletons;\n        node.skin = instanceSkin.skin;\n        node.meshes = instanceSkin.meshes;\n        delete node.instanceSkin;\n      }\n    }\n  }\n}\n\nfunction updateAnimations(gltf) {\n  const animations = gltf.animations;\n  const accessors = gltf.accessors;\n  const bufferViews = gltf.bufferViews;\n  const buffers = gltf.buffers;\n  const updatedAccessors = {};\n  const axis = new Cartesian3();\n  const quat = new Quaternion();\n  for (const animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      const animation = animations[animationId];\n      const channels = animation.channels;\n      const parameters = animation.parameters;\n      const samplers = animation.samplers;\n      if (defined(channels)) {\n        const channelsLength = channels.length;\n        for (let i = 0; i < channelsLength; ++i) {\n          const channel = channels[i];\n          if (channel.target.path === \"rotation\") {\n            const accessorId = parameters[samplers[channel.sampler].output];\n            if (defined(updatedAccessors[accessorId])) {\n              continue;\n            }\n            updatedAccessors[accessorId] = true;\n            const accessor = accessors[accessorId];\n            const bufferView = bufferViews[accessor.bufferView];\n            const buffer = buffers[bufferView.buffer];\n            const source = buffer.extras._pipeline.source;\n            const byteOffset =\n              source.byteOffset + bufferView.byteOffset + accessor.byteOffset;\n            const componentType = accessor.componentType;\n            const count = accessor.count;\n            const componentsLength = numberOfComponentsForType(accessor.type);\n            const length = accessor.count * componentsLength;\n            const typedArray = ComponentDatatype.createArrayBufferView(\n              componentType,\n              source.buffer,\n              byteOffset,\n              length\n            );\n\n            for (let j = 0; j < count; j++) {\n              const offset = j * componentsLength;\n              Cartesian3.unpack(typedArray, offset, axis);\n              const angle = typedArray[offset + 3];\n              Quaternion.fromAxisAngle(axis, angle, quat);\n              Quaternion.pack(quat, typedArray, offset);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction removeTechniquePasses(gltf) {\n  const techniques = gltf.techniques;\n  for (const techniqueId in techniques) {\n    if (Object.prototype.hasOwnProperty.call(techniques, techniqueId)) {\n      const technique = techniques[techniqueId];\n      const passes = technique.passes;\n      if (defined(passes)) {\n        const passName = defaultValue(technique.pass, \"defaultPass\");\n        if (Object.prototype.hasOwnProperty.call(passes, passName)) {\n          const pass = passes[passName];\n          const instanceProgram = pass.instanceProgram;\n          technique.attributes = defaultValue(\n            technique.attributes,\n            instanceProgram.attributes\n          );\n          technique.program = defaultValue(\n            technique.program,\n            instanceProgram.program\n          );\n          technique.uniforms = defaultValue(\n            technique.uniforms,\n            instanceProgram.uniforms\n          );\n          technique.states = defaultValue(technique.states, pass.states);\n        }\n        delete technique.passes;\n        delete technique.pass;\n      }\n    }\n  }\n}\n\nfunction glTF08to10(gltf) {\n  if (!defined(gltf.asset)) {\n    gltf.asset = {};\n  }\n  const asset = gltf.asset;\n  asset.version = \"1.0\";\n  // Profile should be an object, not a string\n  if (typeof asset.profile === \"string\") {\n    const split = asset.profile.split(\" \");\n    asset.profile = {\n      api: split[0],\n      version: split[1],\n    };\n  } else {\n    asset.profile = {};\n  }\n\n  // Version property should be in asset, not on the root element\n  if (defined(gltf.version)) {\n    delete gltf.version;\n  }\n  // material.instanceTechnique properties should be directly on the material\n  updateInstanceTechniques(gltf);\n  // primitive.primitive should be primitive.mode\n  setPrimitiveModes(gltf);\n  // Node rotation should be quaternion, not axis-angle\n  // node.instanceSkin is deprecated\n  updateNodes(gltf);\n  // Animations that target rotations should be quaternion, not axis-angle\n  updateAnimations(gltf);\n  // technique.pass and techniques.passes are deprecated\n  removeTechniquePasses(gltf);\n  // gltf.allExtensions -> extensionsUsed\n  if (defined(gltf.allExtensions)) {\n    gltf.extensionsUsed = gltf.allExtensions;\n    delete gltf.allExtensions;\n  }\n  // gltf.lights -> khrMaterialsCommon.lights\n  if (defined(gltf.lights)) {\n    const extensions = defaultValue(gltf.extensions, {});\n    gltf.extensions = extensions;\n    const materialsCommon = defaultValue(extensions.KHR_materials_common, {});\n    extensions.KHR_materials_common = materialsCommon;\n    materialsCommon.lights = gltf.lights;\n    delete gltf.lights;\n    addExtensionsUsed(gltf, \"KHR_materials_common\");\n  }\n}\n\nfunction removeAnimationSamplersIndirection(gltf) {\n  const animations = gltf.animations;\n  for (const animationId in animations) {\n    if (Object.prototype.hasOwnProperty.call(animations, animationId)) {\n      const animation = animations[animationId];\n      const parameters = animation.parameters;\n      if (defined(parameters)) {\n        const samplers = animation.samplers;\n        for (const samplerId in samplers) {\n          if (Object.prototype.hasOwnProperty.call(samplers, samplerId)) {\n            const sampler = samplers[samplerId];\n            sampler.input = parameters[sampler.input];\n            sampler.output = parameters[sampler.output];\n          }\n        }\n        delete animation.parameters;\n      }\n    }\n  }\n}\n\nfunction objectToArray(object, mapping) {\n  const array = [];\n  for (const id in object) {\n    if (Object.prototype.hasOwnProperty.call(object, id)) {\n      const value = object[id];\n      mapping[id] = array.length;\n      array.push(value);\n      if (!defined(value.name)) {\n        value.name = id;\n      }\n    }\n  }\n  return array;\n}\n\nfunction objectsToArrays(gltf) {\n  let i;\n  const globalMapping = {\n    accessors: {},\n    animations: {},\n    buffers: {},\n    bufferViews: {},\n    cameras: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    programs: {},\n    samplers: {},\n    scenes: {},\n    shaders: {},\n    skins: {},\n    textures: {},\n    techniques: {},\n  };\n\n  // Map joint names to id names\n  let jointName;\n  const jointNameToId = {};\n  const nodes = gltf.nodes;\n  for (const id in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n      jointName = nodes[id].jointName;\n      if (defined(jointName)) {\n        jointNameToId[jointName] = id;\n      }\n    }\n  }\n\n  // Convert top level objects to arrays\n  for (const topLevelId in gltf) {\n    if (\n      Object.prototype.hasOwnProperty.call(gltf, topLevelId) &&\n      defined(globalMapping[topLevelId])\n    ) {\n      const objectMapping = {};\n      const object = gltf[topLevelId];\n      gltf[topLevelId] = objectToArray(object, objectMapping);\n      globalMapping[topLevelId] = objectMapping;\n    }\n  }\n\n  // Remap joint names to array indexes\n  for (jointName in jointNameToId) {\n    if (Object.prototype.hasOwnProperty.call(jointNameToId, jointName)) {\n      jointNameToId[jointName] = globalMapping.nodes[jointNameToId[jointName]];\n    }\n  }\n\n  // Fix references\n  if (defined(gltf.scene)) {\n    gltf.scene = globalMapping.scenes[gltf.scene];\n  }\n  ForEach.bufferView(gltf, function (bufferView) {\n    if (defined(bufferView.buffer)) {\n      bufferView.buffer = globalMapping.buffers[bufferView.buffer];\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      accessor.bufferView = globalMapping.bufferViews[accessor.bufferView];\n    }\n  });\n  ForEach.shader(gltf, function (shader) {\n    const extensions = shader.extensions;\n    if (defined(extensions)) {\n      const binaryGltf = extensions.KHR_binary_glTF;\n      if (defined(binaryGltf)) {\n        shader.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        delete extensions.KHR_binary_glTF;\n      }\n      if (Object.keys(extensions).length === 0) {\n        delete shader.extensions;\n      }\n    }\n  });\n  ForEach.program(gltf, function (program) {\n    if (defined(program.vertexShader)) {\n      program.vertexShader = globalMapping.shaders[program.vertexShader];\n    }\n    if (defined(program.fragmentShader)) {\n      program.fragmentShader = globalMapping.shaders[program.fragmentShader];\n    }\n  });\n  ForEach.technique(gltf, function (technique) {\n    if (defined(technique.program)) {\n      technique.program = globalMapping.programs[technique.program];\n    }\n    ForEach.techniqueParameter(technique, function (parameter) {\n      if (defined(parameter.node)) {\n        parameter.node = globalMapping.nodes[parameter.node];\n      }\n      const value = parameter.value;\n      if (typeof value === \"string\") {\n        parameter.value = {\n          index: globalMapping.textures[value],\n        };\n      }\n    });\n  });\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      if (defined(primitive.indices)) {\n        primitive.indices = globalMapping.accessors[primitive.indices];\n      }\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, semantic) {\n          primitive.attributes[semantic] = globalMapping.accessors[accessorId];\n        }\n      );\n      if (defined(primitive.material)) {\n        primitive.material = globalMapping.materials[primitive.material];\n      }\n    });\n  });\n  ForEach.node(gltf, function (node) {\n    let children = node.children;\n    if (defined(children)) {\n      const childrenLength = children.length;\n      for (i = 0; i < childrenLength; ++i) {\n        children[i] = globalMapping.nodes[children[i]];\n      }\n    }\n    if (defined(node.meshes)) {\n      // Split out meshes on nodes\n      const meshes = node.meshes;\n      const meshesLength = meshes.length;\n      if (meshesLength > 0) {\n        node.mesh = globalMapping.meshes[meshes[0]];\n        for (i = 1; i < meshesLength; ++i) {\n          const meshNode = {\n            mesh: globalMapping.meshes[meshes[i]],\n          };\n          const meshNodeId = addToArray(gltf.nodes, meshNode);\n          if (!defined(children)) {\n            children = [];\n            node.children = children;\n          }\n          children.push(meshNodeId);\n        }\n      }\n      delete node.meshes;\n    }\n    if (defined(node.camera)) {\n      node.camera = globalMapping.cameras[node.camera];\n    }\n    if (defined(node.skin)) {\n      node.skin = globalMapping.skins[node.skin];\n    }\n    if (defined(node.skeletons)) {\n      // Assign skeletons to skins\n      const skeletons = node.skeletons;\n      const skeletonsLength = skeletons.length;\n      if (skeletonsLength > 0 && defined(node.skin)) {\n        const skin = gltf.skins[node.skin];\n        skin.skeleton = globalMapping.nodes[skeletons[0]];\n      }\n      delete node.skeletons;\n    }\n    if (defined(node.jointName)) {\n      delete node.jointName;\n    }\n  });\n  ForEach.skin(gltf, function (skin) {\n    if (defined(skin.inverseBindMatrices)) {\n      skin.inverseBindMatrices =\n        globalMapping.accessors[skin.inverseBindMatrices];\n    }\n    const jointNames = skin.jointNames;\n    if (defined(jointNames)) {\n      const joints = [];\n      const jointNamesLength = jointNames.length;\n      for (i = 0; i < jointNamesLength; ++i) {\n        joints[i] = jointNameToId[jointNames[i]];\n      }\n      skin.joints = joints;\n      delete skin.jointNames;\n    }\n  });\n  ForEach.scene(gltf, function (scene) {\n    const sceneNodes = scene.nodes;\n    if (defined(sceneNodes)) {\n      const sceneNodesLength = sceneNodes.length;\n      for (i = 0; i < sceneNodesLength; ++i) {\n        sceneNodes[i] = globalMapping.nodes[sceneNodes[i]];\n      }\n    }\n  });\n  ForEach.animation(gltf, function (animation) {\n    const samplerMapping = {};\n    animation.samplers = objectToArray(animation.samplers, samplerMapping);\n    ForEach.animationSampler(animation, function (sampler) {\n      sampler.input = globalMapping.accessors[sampler.input];\n      sampler.output = globalMapping.accessors[sampler.output];\n    });\n    ForEach.animationChannel(animation, function (channel) {\n      channel.sampler = samplerMapping[channel.sampler];\n      const target = channel.target;\n      if (defined(target)) {\n        target.node = globalMapping.nodes[target.id];\n        delete target.id;\n      }\n    });\n  });\n  ForEach.material(gltf, function (material) {\n    if (defined(material.technique)) {\n      material.technique = globalMapping.techniques[material.technique];\n    }\n    ForEach.materialValue(material, function (value, name) {\n      if (typeof value === \"string\") {\n        material.values[name] = {\n          index: globalMapping.textures[value],\n        };\n      }\n    });\n    const extensions = material.extensions;\n    if (defined(extensions)) {\n      const materialsCommon = extensions.KHR_materials_common;\n      if (defined(materialsCommon)) {\n        ForEach.materialValue(materialsCommon, function (value, name) {\n          if (typeof value === \"string\") {\n            materialsCommon.values[name] = {\n              index: globalMapping.textures[value],\n            };\n          }\n        });\n      }\n    }\n  });\n  ForEach.image(gltf, function (image) {\n    const extensions = image.extensions;\n    if (defined(extensions)) {\n      const binaryGltf = extensions.KHR_binary_glTF;\n      if (defined(binaryGltf)) {\n        image.bufferView = globalMapping.bufferViews[binaryGltf.bufferView];\n        image.mimeType = binaryGltf.mimeType;\n        delete extensions.KHR_binary_glTF;\n      }\n      if (Object.keys(extensions).length === 0) {\n        delete image.extensions;\n      }\n    }\n  });\n  ForEach.texture(gltf, function (texture) {\n    if (defined(texture.sampler)) {\n      texture.sampler = globalMapping.samplers[texture.sampler];\n    }\n    if (defined(texture.source)) {\n      texture.source = globalMapping.images[texture.source];\n    }\n  });\n}\n\nfunction removeAnimationSamplerNames(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      delete sampler.name;\n    });\n  });\n}\n\nfunction removeEmptyArrays(gltf) {\n  for (const topLevelId in gltf) {\n    if (Object.prototype.hasOwnProperty.call(gltf, topLevelId)) {\n      const array = gltf[topLevelId];\n      if (Array.isArray(array) && array.length === 0) {\n        delete gltf[topLevelId];\n      }\n    }\n  }\n  ForEach.node(gltf, function (node) {\n    if (defined(node.children) && node.children.length === 0) {\n      delete node.children;\n    }\n  });\n}\n\nfunction stripAsset(gltf) {\n  const asset = gltf.asset;\n  delete asset.profile;\n  delete asset.premultipliedAlpha;\n}\n\nconst knownExtensions = {\n  CESIUM_RTC: true,\n  KHR_materials_common: true,\n  WEB3D_quantized_attributes: true,\n};\nfunction requireKnownExtensions(gltf) {\n  const extensionsUsed = gltf.extensionsUsed;\n  gltf.extensionsRequired = defaultValue(gltf.extensionsRequired, []);\n  if (defined(extensionsUsed)) {\n    const extensionsUsedLength = extensionsUsed.length;\n    for (let i = 0; i < extensionsUsedLength; ++i) {\n      const extension = extensionsUsed[i];\n      if (defined(knownExtensions[extension])) {\n        gltf.extensionsRequired.push(extension);\n      }\n    }\n  }\n}\n\nfunction removeBufferType(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    delete buffer.type;\n  });\n}\n\nfunction removeTextureProperties(gltf) {\n  ForEach.texture(gltf, function (texture) {\n    delete texture.format;\n    delete texture.internalFormat;\n    delete texture.target;\n    delete texture.type;\n  });\n}\n\nfunction requireAttributeSetIndex(gltf) {\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, semantic) {\n          if (semantic === \"TEXCOORD\") {\n            primitive.attributes.TEXCOORD_0 = accessorId;\n          } else if (semantic === \"COLOR\") {\n            primitive.attributes.COLOR_0 = accessorId;\n          }\n        }\n      );\n      delete primitive.attributes.TEXCOORD;\n      delete primitive.attributes.COLOR;\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      const semantic = parameter.semantic;\n      if (defined(semantic)) {\n        if (semantic === \"TEXCOORD\") {\n          parameter.semantic = \"TEXCOORD_0\";\n        } else if (semantic === \"COLOR\") {\n          parameter.semantic = \"COLOR_0\";\n        }\n      }\n    });\n  });\n}\n\nconst knownSemantics = {\n  POSITION: true,\n  NORMAL: true,\n  TANGENT: true,\n};\nconst indexedSemantics = {\n  COLOR: \"COLOR\",\n  JOINT: \"JOINTS\",\n  JOINTS: \"JOINTS\",\n  TEXCOORD: \"TEXCOORD\",\n  WEIGHT: \"WEIGHTS\",\n  WEIGHTS: \"WEIGHTS\",\n};\nfunction underscoreApplicationSpecificSemantics(gltf) {\n  const mappedSemantics = {};\n  ForEach.mesh(gltf, function (mesh) {\n    ForEach.meshPrimitive(mesh, function (primitive) {\n      /*eslint-disable no-unused-vars*/\n      ForEach.meshPrimitiveAttribute(\n        primitive,\n        function (accessorId, semantic) {\n          if (semantic.charAt(0) !== \"_\") {\n            const setIndex = semantic.search(/_[0-9]+/g);\n            let strippedSemantic = semantic;\n            let suffix = \"_0\";\n            if (setIndex >= 0) {\n              strippedSemantic = semantic.substring(0, setIndex);\n              suffix = semantic.substring(setIndex);\n            }\n            let newSemantic;\n            const indexedSemantic = indexedSemantics[strippedSemantic];\n            if (defined(indexedSemantic)) {\n              newSemantic = indexedSemantic + suffix;\n              mappedSemantics[semantic] = newSemantic;\n            } else if (!defined(knownSemantics[strippedSemantic])) {\n              newSemantic = \"_\" + semantic;\n              mappedSemantics[semantic] = newSemantic;\n            }\n          }\n        }\n      );\n      for (const semantic in mappedSemantics) {\n        if (Object.prototype.hasOwnProperty.call(mappedSemantics, semantic)) {\n          const mappedSemantic = mappedSemantics[semantic];\n          const accessorId = primitive.attributes[semantic];\n          if (defined(accessorId)) {\n            delete primitive.attributes[semantic];\n            primitive.attributes[mappedSemantic] = accessorId;\n          }\n        }\n      }\n    });\n  });\n  ForEach.technique(gltf, function (technique) {\n    ForEach.techniqueParameter(technique, function (parameter) {\n      const mappedSemantic = mappedSemantics[parameter.semantic];\n      if (defined(mappedSemantic)) {\n        parameter.semantic = mappedSemantic;\n      }\n    });\n  });\n}\n\nfunction clampCameraParameters(gltf) {\n  ForEach.camera(gltf, function (camera) {\n    const perspective = camera.perspective;\n    if (defined(perspective)) {\n      const aspectRatio = perspective.aspectRatio;\n      if (defined(aspectRatio) && aspectRatio === 0.0) {\n        delete perspective.aspectRatio;\n      }\n      const yfov = perspective.yfov;\n      if (defined(yfov) && yfov === 0.0) {\n        perspective.yfov = 1.0;\n      }\n    }\n  });\n}\n\nfunction computeAccessorByteStride(gltf, accessor) {\n  return defined(accessor.byteStride) && accessor.byteStride !== 0\n    ? accessor.byteStride\n    : getAccessorByteStride(gltf, accessor);\n}\n\nfunction requireByteLength(gltf) {\n  ForEach.buffer(gltf, function (buffer) {\n    if (!defined(buffer.byteLength)) {\n      buffer.byteLength = buffer.extras._pipeline.source.length;\n    }\n  });\n  ForEach.accessor(gltf, function (accessor) {\n    const bufferViewId = accessor.bufferView;\n    if (defined(bufferViewId)) {\n      const bufferView = gltf.bufferViews[bufferViewId];\n      const accessorByteStride = computeAccessorByteStride(gltf, accessor);\n      const accessorByteEnd =\n        accessor.byteOffset + accessor.count * accessorByteStride;\n      bufferView.byteLength = Math.max(\n        defaultValue(bufferView.byteLength, 0),\n        accessorByteEnd\n      );\n    }\n  });\n}\n\nfunction moveByteStrideToBufferView(gltf) {\n  let i;\n  let j;\n  let bufferView;\n  const bufferViews = gltf.bufferViews;\n\n  const bufferViewHasVertexAttributes = {};\n  ForEach.accessorContainingVertexAttributeData(gltf, function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    if (defined(accessor.bufferView)) {\n      bufferViewHasVertexAttributes[accessor.bufferView] = true;\n    }\n  });\n\n  // Map buffer views to a list of accessors\n  const bufferViewMap = {};\n  ForEach.accessor(gltf, function (accessor) {\n    if (defined(accessor.bufferView)) {\n      bufferViewMap[accessor.bufferView] = defaultValue(\n        bufferViewMap[accessor.bufferView],\n        []\n      );\n      bufferViewMap[accessor.bufferView].push(accessor);\n    }\n  });\n\n  // Split accessors with different byte strides\n  for (const bufferViewId in bufferViewMap) {\n    if (Object.prototype.hasOwnProperty.call(bufferViewMap, bufferViewId)) {\n      bufferView = bufferViews[bufferViewId];\n      const accessors = bufferViewMap[bufferViewId];\n      accessors.sort(function (a, b) {\n        return a.byteOffset - b.byteOffset;\n      });\n      let currentByteOffset = 0;\n      let currentIndex = 0;\n      const accessorsLength = accessors.length;\n      for (i = 0; i < accessorsLength; ++i) {\n        let accessor = accessors[i];\n        const accessorByteStride = computeAccessorByteStride(gltf, accessor);\n        const accessorByteOffset = accessor.byteOffset;\n        const accessorByteLength = accessor.count * accessorByteStride;\n        delete accessor.byteStride;\n\n        const hasNextAccessor = i < accessorsLength - 1;\n        const nextAccessorByteStride = hasNextAccessor\n          ? computeAccessorByteStride(gltf, accessors[i + 1])\n          : undefined;\n        if (accessorByteStride !== nextAccessorByteStride) {\n          const newBufferView = clone(bufferView, true);\n          if (bufferViewHasVertexAttributes[bufferViewId]) {\n            newBufferView.byteStride = accessorByteStride;\n          }\n          newBufferView.byteOffset += currentByteOffset;\n          newBufferView.byteLength =\n            accessorByteOffset + accessorByteLength - currentByteOffset;\n          const newBufferViewId = addToArray(bufferViews, newBufferView);\n          for (j = currentIndex; j <= i; ++j) {\n            accessor = accessors[j];\n            accessor.bufferView = newBufferViewId;\n            accessor.byteOffset = accessor.byteOffset - currentByteOffset;\n          }\n          // Set current byte offset to next accessor's byte offset\n          currentByteOffset = hasNextAccessor\n            ? accessors[i + 1].byteOffset\n            : undefined;\n          currentIndex = i + 1;\n        }\n      }\n    }\n  }\n\n  // Remove unused buffer views\n  removeUnusedElements(gltf, [\"accessor\", \"bufferView\", \"buffer\"]);\n}\n\nfunction requirePositionAccessorMinMax(gltf) {\n  ForEach.accessorWithSemantic(gltf, \"POSITION\", function (accessorId) {\n    const accessor = gltf.accessors[accessorId];\n    if (!defined(accessor.min) || !defined(accessor.max)) {\n      const minMax = findAccessorMinMax(gltf, accessor);\n      accessor.min = minMax.min;\n      accessor.max = minMax.max;\n    }\n  });\n}\n\nfunction isNodeEmpty(node) {\n  return (\n    (!defined(node.children) || node.children.length === 0) &&\n    (!defined(node.meshes) || node.meshes.length === 0) &&\n    !defined(node.camera) &&\n    !defined(node.skin) &&\n    !defined(node.skeletons) &&\n    !defined(node.jointName) &&\n    (!defined(node.translation) ||\n      Cartesian3.fromArray(node.translation).equals(Cartesian3.ZERO)) &&\n    (!defined(node.scale) ||\n      Cartesian3.fromArray(node.scale).equals(new Cartesian3(1.0, 1.0, 1.0))) &&\n    (!defined(node.rotation) ||\n      Cartesian4.fromArray(node.rotation).equals(\n        new Cartesian4(0.0, 0.0, 0.0, 1.0)\n      )) &&\n    (!defined(node.matrix) ||\n      Matrix4.fromColumnMajorArray(node.matrix).equals(Matrix4.IDENTITY)) &&\n    !defined(node.extensions) &&\n    !defined(node.extras)\n  );\n}\n\nfunction deleteNode(gltf, nodeId) {\n  // Remove from list of nodes in scene\n  ForEach.scene(gltf, function (scene) {\n    const sceneNodes = scene.nodes;\n    if (defined(sceneNodes)) {\n      const sceneNodesLength = sceneNodes.length;\n      for (let i = sceneNodesLength; i >= 0; --i) {\n        if (sceneNodes[i] === nodeId) {\n          sceneNodes.splice(i, 1);\n          return;\n        }\n      }\n    }\n  });\n\n  // Remove parent node's reference to this node, and delete the parent if also empty\n  ForEach.node(gltf, function (parentNode, parentNodeId) {\n    if (defined(parentNode.children)) {\n      const index = parentNode.children.indexOf(nodeId);\n      if (index > -1) {\n        parentNode.children.splice(index, 1);\n\n        if (isNodeEmpty(parentNode)) {\n          deleteNode(gltf, parentNodeId);\n        }\n      }\n    }\n  });\n\n  delete gltf.nodes[nodeId];\n}\n\nfunction removeEmptyNodes(gltf) {\n  ForEach.node(gltf, function (node, nodeId) {\n    if (isNodeEmpty(node)) {\n      deleteNode(gltf, nodeId);\n    }\n  });\n\n  return gltf;\n}\n\nfunction requireAnimationAccessorMinMax(gltf) {\n  ForEach.animation(gltf, function (animation) {\n    ForEach.animationSampler(animation, function (sampler) {\n      const accessor = gltf.accessors[sampler.input];\n      if (!defined(accessor.min) || !defined(accessor.max)) {\n        const minMax = findAccessorMinMax(gltf, accessor);\n        accessor.min = minMax.min;\n        accessor.max = minMax.max;\n      }\n    });\n  });\n}\n\nfunction glTF10to20(gltf) {\n  gltf.asset = defaultValue(gltf.asset, {});\n  gltf.asset.version = \"2.0\";\n  // material.instanceTechnique properties should be directly on the material. instanceTechnique is a gltf 0.8 property but is seen in some 1.0 models.\n  updateInstanceTechniques(gltf);\n  // animation.samplers now refers directly to accessors and animation.parameters should be removed\n  removeAnimationSamplersIndirection(gltf);\n  // Remove empty nodes and re-assign referencing indices\n  removeEmptyNodes(gltf);\n  // Top-level objects are now arrays referenced by index instead of id\n  objectsToArrays(gltf);\n  // Animation.sampler objects cannot have names\n  removeAnimationSamplerNames(gltf);\n  // asset.profile no longer exists\n  stripAsset(gltf);\n  // Move known extensions from extensionsUsed to extensionsRequired\n  requireKnownExtensions(gltf);\n  // bufferView.byteLength and buffer.byteLength are required\n  requireByteLength(gltf);\n  // byteStride moved from accessor to bufferView\n  moveByteStrideToBufferView(gltf);\n  // accessor.min and accessor.max must be defined for accessors containing POSITION attributes\n  requirePositionAccessorMinMax(gltf);\n  // An animation sampler's input accessor must have min and max properties defined\n  requireAnimationAccessorMinMax(gltf);\n  // buffer.type is unnecessary and should be removed\n  removeBufferType(gltf);\n  // Remove format, internalFormat, target, and type\n  removeTextureProperties(gltf);\n  // TEXCOORD and COLOR attributes must be written with a set index (TEXCOORD_#)\n  requireAttributeSetIndex(gltf);\n  // Add underscores to application-specific parameters\n  underscoreApplicationSpecificSemantics(gltf);\n  // Accessors referenced by JOINTS_0 and WEIGHTS_0 attributes must have correct component types\n  updateAccessorComponentTypes(gltf);\n  // Clamp camera parameters\n  clampCameraParameters(gltf);\n  // Move legacy technique render states to material properties and add KHR_blend extension blending functions\n  moveTechniqueRenderStates(gltf);\n  // Add material techniques to KHR_techniques_webgl extension, removing shaders, programs, and techniques\n  moveTechniquesToExtension(gltf);\n  // Remove empty arrays\n  removeEmptyArrays(gltf);\n}\n\nexport default updateVersion;\n","import defined from \"../../Core/defined.js\";\n\n/**\n * Checks whether the glTF uses the given extension.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @param {String} extension The name of the extension.\n * @returns {Boolean} Whether the glTF uses the given extension.\n *\n * @private\n */\nfunction usesExtension(gltf, extension) {\n  return (\n    defined(gltf.extensionsUsed) && gltf.extensionsUsed.indexOf(extension) >= 0\n  );\n}\n\nexport default usesExtension;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport parseStructuralMetadata from \"./parseStructuralMetadata.js\";\nimport parseFeatureMetadataLegacy from \"./parseFeatureMetadataLegacy.js\";\nimport ResourceCache from \"./ResourceCache.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads glTF structural metadata\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfStructuralMetadataLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.gltf The glTF JSON.\n * @param {String} [options.extension] The <code>EXT_structural_metadata</code> extension object. If this is undefined, then extensionLegacy must be defined.\n * @param {String} [options.extensionLegacy] The legacy <code>EXT_feature_metadata</code> extension for backwards compatibility.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {String} [options.cacheKey] The cache key of the resource.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function GltfStructuralMetadataLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const gltf = options.gltf;\n  const extension = options.extension;\n  const extensionLegacy = options.extensionLegacy;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const supportedImageFormats = options.supportedImageFormats;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n\n  if (!defined(options.extension) && !defined(options.extensionLegacy)) {\n    throw new DeveloperError(\n      \"One of options.extension or options.extensionLegacy must be specified\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._extension = extension;\n  this._extensionLegacy = extensionLegacy;\n  this._supportedImageFormats = supportedImageFormats;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._bufferViewLoaders = [];\n  this._textureLoaders = [];\n  this._schemaLoader = undefined;\n  this._structuralMetadata = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  GltfStructuralMetadataLoader.prototype = Object.create(\n    ResourceLoader.prototype\n  );\n  GltfStructuralMetadataLoader.prototype.constructor = GltfStructuralMetadataLoader;\n}\n\nObject.defineProperties(GltfStructuralMetadataLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof GltfStructuralMetadataLoader.prototype\n   *\n   * @type {Promise.<GltfStructuralMetadataLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfStructuralMetadataLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The parsed structural metadata\n   *\n   * @memberof GltfStructuralMetadataLoader.prototype\n   *\n   * @type {StructuralMetadata}\n   * @readonly\n   * @private\n   */\n  structuralMetadata: {\n    get: function () {\n      return this._structuralMetadata;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfStructuralMetadataLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfStructuralMetadataLoader.prototype.load = function () {\n  const bufferViewsPromise = loadBufferViews(this);\n  const texturesPromise = loadTextures(this);\n  const schemaPromise = loadSchema(this);\n\n  this._gltf = undefined; // No longer need to hold onto the glTF\n  this._state = ResourceLoaderState.LOADING;\n\n  const that = this;\n\n  this._promise = Promise.all([\n    bufferViewsPromise,\n    texturesPromise,\n    schemaPromise,\n  ])\n    .then(function (results) {\n      if (that.isDestroyed()) {\n        return;\n      }\n      const bufferViews = results[0];\n      const textures = results[1];\n      const schema = results[2];\n\n      if (defined(that._extension)) {\n        that._structuralMetadata = parseStructuralMetadata({\n          extension: that._extension,\n          schema: schema,\n          bufferViews: bufferViews,\n          textures: textures,\n        });\n      } else {\n        that._structuralMetadata = parseFeatureMetadataLegacy({\n          extension: that._extensionLegacy,\n          schema: schema,\n          bufferViews: bufferViews,\n          textures: textures,\n        });\n      }\n      that._state = ResourceLoaderState.READY;\n      return that;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n      that.unload();\n      that._state = ResourceLoaderState.FAILED;\n      const errorMessage = \"Failed to load structural metadata\";\n      return Promise.reject(that.getError(errorMessage, error));\n    });\n};\n\nfunction gatherBufferViewIdsFromProperties(properties, bufferViewIdSet) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const property = properties[propertyId];\n      const values = property.values;\n      const arrayOffsets = property.arrayOffsets;\n      const stringOffsets = property.stringOffsets;\n\n      // Using an object like a mathematical set\n      if (defined(values)) {\n        bufferViewIdSet[values] = true;\n      }\n      if (defined(arrayOffsets)) {\n        bufferViewIdSet[arrayOffsets] = true;\n      }\n      if (defined(stringOffsets)) {\n        bufferViewIdSet[stringOffsets] = true;\n      }\n    }\n  }\n}\n\nfunction gatherBufferViewIdsFromPropertiesLegacy(properties, bufferViewIdSet) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const property = properties[propertyId];\n      const bufferView = property.bufferView;\n      const arrayOffsetBufferView = property.arrayOffsetBufferView;\n      const stringOffsetBufferView = property.stringOffsetBufferView;\n\n      // Using an object like a mathematical set\n      if (defined(bufferView)) {\n        bufferViewIdSet[bufferView] = true;\n      }\n      if (defined(arrayOffsetBufferView)) {\n        bufferViewIdSet[arrayOffsetBufferView] = true;\n      }\n      if (defined(stringOffsetBufferView)) {\n        bufferViewIdSet[stringOffsetBufferView] = true;\n      }\n    }\n  }\n}\n\nfunction gatherUsedBufferViewIds(extension) {\n  const propertyTables = extension.propertyTables;\n  const bufferViewIdSet = {};\n  if (defined(propertyTables)) {\n    for (let i = 0; i < propertyTables.length; i++) {\n      const propertyTable = propertyTables[i];\n      gatherBufferViewIdsFromProperties(\n        propertyTable.properties,\n        bufferViewIdSet\n      );\n    }\n  }\n  return bufferViewIdSet;\n}\n\nfunction gatherUsedBufferViewIdsLegacy(extensionLegacy) {\n  const featureTables = extensionLegacy.featureTables;\n\n  const bufferViewIdSet = {};\n  if (defined(featureTables)) {\n    for (const featureTableId in featureTables) {\n      if (featureTables.hasOwnProperty(featureTableId)) {\n        const featureTable = featureTables[featureTableId];\n        const properties = featureTable.properties;\n        if (defined(properties)) {\n          gatherBufferViewIdsFromPropertiesLegacy(properties, bufferViewIdSet);\n        }\n      }\n    }\n  }\n  return bufferViewIdSet;\n}\n\nfunction loadBufferViews(structuralMetadataLoader) {\n  let bufferViewIds;\n  if (defined(structuralMetadataLoader._extension)) {\n    bufferViewIds = gatherUsedBufferViewIds(\n      structuralMetadataLoader._extension\n    );\n  } else {\n    bufferViewIds = gatherUsedBufferViewIdsLegacy(\n      structuralMetadataLoader._extensionLegacy\n    );\n  }\n\n  // Load the buffer views\n  const bufferViewPromises = [];\n  const bufferViewLoaders = {};\n  for (const bufferViewId in bufferViewIds) {\n    if (bufferViewIds.hasOwnProperty(bufferViewId)) {\n      const bufferViewLoader = ResourceCache.loadBufferView({\n        gltf: structuralMetadataLoader._gltf,\n        bufferViewId: parseInt(bufferViewId),\n        gltfResource: structuralMetadataLoader._gltfResource,\n        baseResource: structuralMetadataLoader._baseResource,\n      });\n      bufferViewPromises.push(bufferViewLoader.promise);\n      structuralMetadataLoader._bufferViewLoaders.push(bufferViewLoader);\n      bufferViewLoaders[bufferViewId] = bufferViewLoader;\n    }\n  }\n\n  // Return a promise to a map of buffer view IDs to typed arrays\n  return Promise.all(bufferViewPromises).then(function () {\n    const bufferViews = {};\n    for (const bufferViewId in bufferViewLoaders) {\n      if (bufferViewLoaders.hasOwnProperty(bufferViewId)) {\n        const bufferViewLoader = bufferViewLoaders[bufferViewId];\n        // Copy the typed array and let the underlying ArrayBuffer be freed\n        const bufferViewTypedArray = new Uint8Array(\n          bufferViewLoader.typedArray\n        );\n        bufferViews[bufferViewId] = bufferViewTypedArray;\n      }\n    }\n\n    // Buffer views can be unloaded after the data has been copied\n    unloadBufferViews(structuralMetadataLoader);\n\n    return bufferViews;\n  });\n}\n\nfunction gatherUsedTextureIds(structuralMetadataExtension) {\n  // Gather the used textures\n  const textureIds = {};\n  const propertyTextures = structuralMetadataExtension.propertyTextures;\n  if (defined(propertyTextures)) {\n    for (let i = 0; i < propertyTextures.length; i++) {\n      const propertyTexture = propertyTextures[i];\n      const properties = propertyTexture.properties;\n      if (defined(properties)) {\n        gatherTextureIdsFromProperties(properties, textureIds);\n      }\n    }\n  }\n  return textureIds;\n}\n\nfunction gatherTextureIdsFromProperties(properties, textureIds) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      // in EXT_structural_metadata the property is a valid textureInfo.\n      const textureInfo = properties[propertyId];\n      textureIds[textureInfo.index] = textureInfo;\n    }\n  }\n}\n\nfunction gatherUsedTextureIdsLegacy(extensionLegacy) {\n  // Gather the used textures\n  const textureIds = {};\n  const featureTextures = extensionLegacy.featureTextures;\n  if (defined(featureTextures)) {\n    for (const featureTextureId in featureTextures) {\n      if (featureTextures.hasOwnProperty(featureTextureId)) {\n        const featureTexture = featureTextures[featureTextureId];\n        const properties = featureTexture.properties;\n        if (defined(properties)) {\n          gatherTextureIdsFromPropertiesLegacy(properties, textureIds);\n        }\n      }\n    }\n  }\n\n  return textureIds;\n}\n\nfunction gatherTextureIdsFromPropertiesLegacy(properties, textureIds) {\n  for (const propertyId in properties) {\n    if (properties.hasOwnProperty(propertyId)) {\n      const property = properties[propertyId];\n      const textureInfo = property.texture;\n      textureIds[textureInfo.index] = textureInfo;\n    }\n  }\n}\n\nfunction loadTextures(structuralMetadataLoader) {\n  let textureIds;\n  if (defined(structuralMetadataLoader._extension)) {\n    textureIds = gatherUsedTextureIds(structuralMetadataLoader._extension);\n  } else {\n    textureIds = gatherUsedTextureIdsLegacy(\n      structuralMetadataLoader._extensionLegacy\n    );\n  }\n\n  const gltf = structuralMetadataLoader._gltf;\n  const gltfResource = structuralMetadataLoader._gltfResource;\n  const baseResource = structuralMetadataLoader._baseResource;\n  const supportedImageFormats = structuralMetadataLoader._supportedImageFormats;\n  const asynchronous = structuralMetadataLoader._asynchronous;\n\n  // Load the textures\n  const texturePromises = [];\n  const textureLoaders = {};\n  for (const textureId in textureIds) {\n    if (textureIds.hasOwnProperty(textureId)) {\n      const textureLoader = ResourceCache.loadTexture({\n        gltf: gltf,\n        textureInfo: textureIds[textureId],\n        gltfResource: gltfResource,\n        baseResource: baseResource,\n        supportedImageFormats: supportedImageFormats,\n        asynchronous: asynchronous,\n      });\n      texturePromises.push(textureLoader.promise);\n      structuralMetadataLoader._textureLoaders.push(textureLoader);\n      textureLoaders[textureId] = textureLoader;\n    }\n  }\n\n  // Return a promise to a map of texture IDs to Texture objects\n  return Promise.all(texturePromises).then(function () {\n    const textures = {};\n    for (const textureId in textureLoaders) {\n      if (textureLoaders.hasOwnProperty(textureId)) {\n        const textureLoader = textureLoaders[textureId];\n        textures[textureId] = textureLoader.texture;\n      }\n    }\n    return textures;\n  });\n}\n\nfunction loadSchema(structuralMetadataLoader) {\n  const extension = defaultValue(\n    structuralMetadataLoader._extension,\n    structuralMetadataLoader._extensionLegacy\n  );\n\n  let schemaLoader;\n  if (defined(extension.schemaUri)) {\n    const resource = structuralMetadataLoader._baseResource.getDerivedResource({\n      url: extension.schemaUri,\n    });\n    schemaLoader = ResourceCache.loadSchema({\n      resource: resource,\n    });\n  } else {\n    schemaLoader = ResourceCache.loadSchema({\n      schema: extension.schema,\n    });\n  }\n\n  structuralMetadataLoader._schemaLoader = schemaLoader;\n\n  return schemaLoader.promise.then(function (schemaLoader) {\n    return schemaLoader.schema;\n  });\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfStructuralMetadataLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state !== ResourceLoaderState.LOADING) {\n    return;\n  }\n\n  const textureLoaders = this._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    const textureLoader = textureLoaders[i];\n    textureLoader.process(frameState);\n  }\n};\n\nfunction unloadBufferViews(structuralMetadataLoader) {\n  const bufferViewLoaders = structuralMetadataLoader._bufferViewLoaders;\n  const bufferViewLoadersLength = bufferViewLoaders.length;\n  for (let i = 0; i < bufferViewLoadersLength; ++i) {\n    ResourceCache.unload(bufferViewLoaders[i]);\n  }\n  structuralMetadataLoader._bufferViewLoaders.length = 0;\n}\n\nfunction unloadTextures(structuralMetadataLoader) {\n  const textureLoaders = structuralMetadataLoader._textureLoaders;\n  const textureLoadersLength = textureLoaders.length;\n  for (let i = 0; i < textureLoadersLength; ++i) {\n    ResourceCache.unload(textureLoaders[i]);\n  }\n  structuralMetadataLoader._textureLoaders.length = 0;\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfStructuralMetadataLoader.prototype.unload = function () {\n  unloadBufferViews(this);\n  unloadTextures(this);\n\n  if (defined(this._schemaLoader)) {\n    ResourceCache.unload(this._schemaLoader);\n  }\n  this._schemaLoader = undefined;\n\n  this._structuralMetadata = undefined;\n};\n","import Check from \"../Core/Check.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport GltfLoaderUtil from \"./GltfLoaderUtil.js\";\nimport JobType from \"./JobType.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * Loads a glTF texture.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfTextureLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {Object} options.gltf The glTF JSON.\n * @param {Object} options.textureInfo The texture info object.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {SupportedImageFormats} options.supportedImageFormats The supported image formats.\n * @param {String} [options.cacheKey] The cache key of the resource.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n *\n * @private\n */\nexport default function GltfTextureLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const textureInfo = options.textureInfo;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const supportedImageFormats = options.supportedImageFormats;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.textureInfo\", textureInfo);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  Check.typeOf.object(\"options.supportedImageFormats\", supportedImageFormats);\n  //>>includeEnd('debug');\n\n  const textureId = textureInfo.index;\n\n  // imageId is guaranteed to be defined otherwise the GltfTextureLoader\n  // wouldn't have been created\n  const imageId = GltfLoaderUtil.getImageIdFromTexture({\n    gltf: gltf,\n    textureId: textureId,\n    supportedImageFormats: supportedImageFormats,\n  });\n\n  this._resourceCache = resourceCache;\n  this._gltf = gltf;\n  this._textureInfo = textureInfo;\n  this._imageId = imageId;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._imageLoader = undefined;\n  this._image = undefined;\n  this._mipLevels = undefined;\n  this._texture = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n  this._process = function (loader, frameState) {};\n}\n\nif (defined(Object.create)) {\n  GltfTextureLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfTextureLoader.prototype.constructor = GltfTextureLoader;\n}\n\nObject.defineProperties(GltfTextureLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof GltfTextureLoader.prototype\n   *\n   * @type {Promise.<GltfTextureLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfTextureLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The texture.\n   *\n   * @memberof GltfTextureLoader.prototype\n   *\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  texture: {\n    get: function () {\n      return this._texture;\n    },\n  },\n});\n\nconst scratchTextureJob = new CreateTextureJob();\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfDracoLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfTextureLoader.prototype.load = function () {\n  const resourceCache = this._resourceCache;\n  const imageLoader = resourceCache.loadImage({\n    gltf: this._gltf,\n    imageId: this._imageId,\n    gltfResource: this._gltfResource,\n    baseResource: this._baseResource,\n  });\n\n  this._imageLoader = imageLoader;\n  this._state = ResourceLoaderState.LOADING;\n  const that = this;\n  const processPromise = new Promise(function (resolve) {\n    that._process = function (loader, frameState) {\n      if (defined(loader._texture)) {\n        // Already created texture\n        return;\n      }\n\n      if (!defined(loader._image)) {\n        // Not ready to create texture\n        return;\n      }\n\n      let texture;\n\n      if (loader._asynchronous) {\n        const textureJob = scratchTextureJob;\n        textureJob.set(\n          loader._gltf,\n          loader._textureInfo,\n          loader._image,\n          loader._mipLevels,\n          frameState.context\n        );\n        const jobScheduler = frameState.jobScheduler;\n        if (!jobScheduler.execute(textureJob, JobType.TEXTURE)) {\n          // Job scheduler is full. Try again next frame.\n          return;\n        }\n        texture = textureJob.texture;\n      } else {\n        texture = createTexture(\n          loader._gltf,\n          loader._textureInfo,\n          loader._image,\n          loader._mipLevels,\n          frameState.context\n        );\n      }\n\n      // Unload everything except the texture\n      loader.unload();\n\n      loader._texture = texture;\n      loader._state = ResourceLoaderState.READY;\n      resolve(loader);\n    };\n  });\n\n  this._promise = imageLoader.promise\n    .then(function () {\n      if (that.isDestroyed()) {\n        return;\n      }\n      // Now wait for process() to run to finish loading\n      that._image = imageLoader.image;\n      that._mipLevels = imageLoader.mipLevels;\n      that._state = ResourceLoaderState.PROCESSING;\n      return processPromise;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n      that.unload();\n      that._state = ResourceLoaderState.FAILED;\n      const errorMessage = \"Failed to load texture\";\n      return Promise.reject(that.getError(errorMessage, error));\n    });\n\n  return this._promise;\n};\n\nfunction CreateTextureJob() {\n  this.gltf = undefined;\n  this.textureInfo = undefined;\n  this.image = undefined;\n  this.context = undefined;\n  this.texture = undefined;\n}\n\nCreateTextureJob.prototype.set = function (\n  gltf,\n  textureInfo,\n  image,\n  mipLevels,\n  context\n) {\n  this.gltf = gltf;\n  this.textureInfo = textureInfo;\n  this.image = image;\n  this.mipLevels = mipLevels;\n  this.context = context;\n};\n\nCreateTextureJob.prototype.execute = function () {\n  this.texture = createTexture(\n    this.gltf,\n    this.textureInfo,\n    this.image,\n    this.mipLevels,\n    this.context\n  );\n};\n\nfunction resizeImageToNextPowerOfTwo(image) {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = CesiumMath.nextPowerOfTwo(image.width);\n  canvas.height = CesiumMath.nextPowerOfTwo(image.height);\n  const canvasContext = canvas.getContext(\"2d\");\n  canvasContext.drawImage(\n    image,\n    0,\n    0,\n    image.width,\n    image.height,\n    0,\n    0,\n    canvas.width,\n    canvas.height\n  );\n  return canvas;\n}\n\nfunction createTexture(gltf, textureInfo, image, mipLevels, context) {\n  // internalFormat is only defined for CompressedTextureBuffer\n  const internalFormat = image.internalFormat;\n\n  let compressedTextureNoMipmap = false;\n  if (PixelFormat.isCompressedFormat(internalFormat) && !defined(mipLevels)) {\n    compressedTextureNoMipmap = true;\n  }\n\n  const sampler = GltfLoaderUtil.createSampler({\n    gltf: gltf,\n    textureInfo: textureInfo,\n    compressedTextureNoMipmap: compressedTextureNoMipmap,\n  });\n\n  const minFilter = sampler.minificationFilter;\n  const wrapS = sampler.wrapS;\n  const wrapT = sampler.wrapT;\n\n  const samplerRequiresMipmap =\n    minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n    minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR ||\n    minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST ||\n    minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n\n  // generateMipmap is disallowed for compressed textures. Compressed textures\n  // can have mipmaps but they must come with the KTX2 instead of generated by\n  // WebGL. Also note from the KHR_texture_basisu spec:\n  //\n  //   When a texture refers to a sampler with mipmap minification or when the\n  //   sampler is undefined, the KTX2 image SHOULD contain a full mip pyramid.\n  //\n  const generateMipmap = !defined(internalFormat) && samplerRequiresMipmap;\n\n  // WebGL 1 requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.\n  const requiresPowerOfTwo =\n    generateMipmap ||\n    wrapS === TextureWrap.REPEAT ||\n    wrapS === TextureWrap.MIRRORED_REPEAT ||\n    wrapT === TextureWrap.REPEAT ||\n    wrapT === TextureWrap.MIRRORED_REPEAT;\n\n  const nonPowerOfTwo =\n    !CesiumMath.isPowerOfTwo(image.width) ||\n    !CesiumMath.isPowerOfTwo(image.height);\n\n  const requiresResize = requiresPowerOfTwo && nonPowerOfTwo;\n\n  let texture;\n  if (defined(internalFormat)) {\n    if (\n      !context.webgl2 &&\n      PixelFormat.isCompressedFormat(internalFormat) &&\n      nonPowerOfTwo &&\n      requiresPowerOfTwo\n    ) {\n      console.warn(\n        \"Compressed texture uses REPEAT or MIRRORED_REPEAT texture wrap mode and dimensions are not powers of two. The texture may be rendered incorrectly.\"\n      );\n    }\n\n    texture = Texture.create({\n      context: context,\n      source: {\n        arrayBufferView: image.bufferView, // Only defined for CompressedTextureBuffer\n        mipLevels: mipLevels,\n      },\n      width: image.width,\n      height: image.height,\n      pixelFormat: image.internalFormat, // Only defined for CompressedTextureBuffer\n      sampler: sampler,\n    });\n  } else {\n    if (requiresResize) {\n      image = resizeImageToNextPowerOfTwo(image);\n    }\n    texture = Texture.create({\n      context: context,\n      source: image,\n      sampler: sampler,\n      flipY: false,\n      skipColorSpaceConversion: true,\n    });\n  }\n\n  if (generateMipmap) {\n    texture.generateMipmap();\n  }\n\n  return texture;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfTextureLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  return this._process(this, frameState);\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfTextureLoader.prototype.unload = function () {\n  if (defined(this._texture)) {\n    this._texture.destroy();\n  }\n\n  if (defined(this._imageLoader)) {\n    this._resourceCache.unload(this._imageLoader);\n  }\n\n  this._imageLoader = undefined;\n  this._image = undefined;\n  this._mipLevels = undefined;\n  this._texture = undefined;\n  this._gltf = undefined;\n};\n","import arrayFill from \"../Core/arrayFill.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport AttributeType from \"./AttributeType.js\";\nimport JobType from \"./JobType.js\";\nimport ModelComponents from \"./ModelComponents.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\nimport AttributeCompression from \"../Core/AttributeCompression.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\n\n/**\n * Loads a vertex buffer from a glTF buffer view.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GltfVertexBufferLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {ResourceCache} options.resourceCache The {@link ResourceCache} (to avoid circular dependencies).\n * @param {Object} options.gltf The glTF JSON.\n * @param {Resource} options.gltfResource The {@link Resource} containing the glTF.\n * @param {Resource} options.baseResource The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Number} [options.bufferViewId] The bufferView ID corresponding to the vertex buffer.\n * @param {Object} [options.draco] The Draco extension object.\n * @param {String} [options.attributeSemantic] The attribute semantic, e.g. POSITION or NORMAL.\n * @param {Number} [options.accessorId] The accessor id.\n * @param {String} [options.cacheKey] The cache key of the resource.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {Boolean} [options.dequantize=false] Determines whether or not the vertex buffer will be dequantized on the CPU.\n * @param {Boolean} [options.loadBuffer=false] Load vertex buffer as a GPU vertex buffer.\n * @param {Boolean} [options.loadTypedArray=false] Load vertex buffer as a typed array.\n *\n * @exception {DeveloperError} One of options.bufferViewId and options.draco must be defined.\n * @exception {DeveloperError} When options.draco is defined options.attributeSemantic must also be defined.\n * @exception {DeveloperError} When options.draco is defined options.accessorId must also be defined.\n *\n * @private\n */\nexport default function GltfVertexBufferLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const resourceCache = options.resourceCache;\n  const gltf = options.gltf;\n  const gltfResource = options.gltfResource;\n  const baseResource = options.baseResource;\n  const bufferViewId = options.bufferViewId;\n  const draco = options.draco;\n  const attributeSemantic = options.attributeSemantic;\n  const accessorId = options.accessorId;\n  const cacheKey = options.cacheKey;\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const dequantize = defaultValue(options.dequantize, false);\n  const loadBuffer = defaultValue(options.loadBuffer, false);\n  const loadTypedArray = defaultValue(options.loadTypedArray, false);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"options.resourceCache\", resourceCache);\n  Check.typeOf.object(\"options.gltf\", gltf);\n  Check.typeOf.object(\"options.gltfResource\", gltfResource);\n  Check.typeOf.object(\"options.baseResource\", baseResource);\n  if (!loadBuffer && !loadTypedArray) {\n    throw new DeveloperError(\n      \"At least one of loadBuffer and loadTypedArray must be true.\"\n    );\n  }\n\n  const hasBufferViewId = defined(bufferViewId);\n  const hasDraco = defined(draco);\n  const hasAttributeSemantic = defined(attributeSemantic);\n  const hasAccessorId = defined(accessorId);\n\n  if (hasBufferViewId === hasDraco) {\n    throw new DeveloperError(\n      \"One of options.bufferViewId and options.draco must be defined.\"\n    );\n  }\n\n  if (hasDraco && !hasAttributeSemantic) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.attributeSemantic must also be defined.\"\n    );\n  }\n\n  if (hasDraco && !hasAccessorId) {\n    throw new DeveloperError(\n      \"When options.draco is defined options.accessorId must also be defined.\"\n    );\n  }\n\n  if (hasDraco) {\n    Check.typeOf.object(\"options.draco\", draco);\n    Check.typeOf.string(\"options.attributeSemantic\", attributeSemantic);\n    Check.typeOf.number(\"options.accessorId\", accessorId);\n  }\n  //>>includeEnd('debug');\n\n  this._resourceCache = resourceCache;\n  this._gltfResource = gltfResource;\n  this._baseResource = baseResource;\n  this._gltf = gltf;\n  this._bufferViewId = bufferViewId;\n  this._draco = draco;\n  this._attributeSemantic = attributeSemantic;\n  this._accessorId = accessorId;\n  this._cacheKey = cacheKey;\n  this._asynchronous = asynchronous;\n  this._dequantize = dequantize;\n  this._loadBuffer = loadBuffer;\n  this._loadTypedArray = loadTypedArray;\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._quantization = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n  this._process = function (loader, frameState) {};\n}\n\nif (defined(Object.create)) {\n  GltfVertexBufferLoader.prototype = Object.create(ResourceLoader.prototype);\n  GltfVertexBufferLoader.prototype.constructor = GltfVertexBufferLoader;\n}\n\nObject.defineProperties(GltfVertexBufferLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Promise.<GltfVertexBufferLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The vertex buffer. This is only defined when <code>loadAsTypedArray</code> is false.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Buffer}\n   * @readonly\n   * @private\n   */\n  buffer: {\n    get: function () {\n      return this._buffer;\n    },\n  },\n  /**\n   * The typed array containing vertex buffer data. This is only defined when <code>loadAsTypedArray</code> is true.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {Uint8Array}\n   * @readonly\n   * @private\n   */\n  typedArray: {\n    get: function () {\n      return this._typedArray;\n    },\n  },\n  /**\n   * Information about the quantized vertex attribute after Draco decode.\n   *\n   * @memberof GltfVertexBufferLoader.prototype\n   *\n   * @type {ModelComponents.Quantization}\n   * @readonly\n   * @private\n   */\n  quantization: {\n    get: function () {\n      return this._quantization;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<GltfVertexBufferLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGltfVertexBufferLoader.prototype.load = function () {\n  let promise;\n\n  if (defined(this._draco)) {\n    promise = loadFromDraco(this);\n  } else {\n    promise = loadFromBufferView(this);\n  }\n\n  const that = this;\n  const scratchVertexBufferJob = new CreateVertexBufferJob();\n  const processPromise = new Promise(function (resolve) {\n    that._process = function (loader, frameState) {\n      if (loader._state === ResourceLoaderState.READY) {\n        return;\n      }\n\n      const typedArray = loader._typedArray;\n      const dequantize = loader._dequantize;\n\n      if (defined(loader._dracoLoader)) {\n        loader._dracoLoader.process(frameState);\n      }\n\n      if (defined(loader._bufferViewLoader)) {\n        loader._bufferViewLoader.process(frameState);\n      }\n\n      if (!defined(typedArray)) {\n        // Buffer view hasn't been loaded yet\n        return;\n      }\n\n      const accessor = loader._gltf.accessors[loader._accessorId];\n\n      let buffer;\n      if (loader._loadBuffer && loader._asynchronous) {\n        const vertexBufferJob = scratchVertexBufferJob;\n        vertexBufferJob.set(\n          typedArray,\n          dequantize,\n          accessor.componentType,\n          accessor.type,\n          accessor.count,\n          frameState.context\n        );\n        const jobScheduler = frameState.jobScheduler;\n        if (!jobScheduler.execute(vertexBufferJob, JobType.BUFFER)) {\n          // Job scheduler is full. Try again next frame.\n          return;\n        }\n        buffer = vertexBufferJob.buffer;\n      } else if (loader._loadBuffer) {\n        buffer = createVertexBuffer(\n          typedArray,\n          dequantize,\n          accessor.componentType,\n          accessor.type,\n          accessor.count,\n          frameState.context\n        );\n      }\n\n      // Unload everything except the vertex buffer\n      loader.unload();\n\n      loader._buffer = buffer;\n      loader._typedArray = loader._loadTypedArray ? typedArray : undefined;\n      loader._state = ResourceLoaderState.READY;\n      resolve(loader);\n    };\n  });\n\n  this._promise = promise\n    .then(function () {\n      if (that.isDestroyed()) {\n        return;\n      }\n\n      return processPromise;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n\n      return handleError(that, error);\n    });\n  return this._promise;\n};\n\nfunction getQuantizationInformation(\n  dracoQuantization,\n  componentDatatype,\n  componentCount,\n  type\n) {\n  const quantizationBits = dracoQuantization.quantizationBits;\n  const normalizationRange = (1 << quantizationBits) - 1;\n  const normalizationDivisor = 1.0 / normalizationRange;\n\n  const quantization = new ModelComponents.Quantization();\n  quantization.componentDatatype = componentDatatype;\n  quantization.octEncoded = dracoQuantization.octEncoded;\n  quantization.octEncodedZXY = true;\n  quantization.type = type;\n\n  if (quantization.octEncoded) {\n    quantization.type = AttributeType.VEC2;\n    quantization.normalizationRange = normalizationRange;\n  } else {\n    const MathType = AttributeType.getMathType(type);\n    if (MathType === Number) {\n      const dimensions = dracoQuantization.range;\n      quantization.quantizedVolumeOffset = dracoQuantization.minValues[0];\n      quantization.quantizedVolumeDimensions = dimensions;\n      quantization.normalizationRange = normalizationRange;\n      quantization.quantizedVolumeStepSize = dimensions * normalizationDivisor;\n    } else {\n      quantization.quantizedVolumeOffset = MathType.unpack(\n        dracoQuantization.minValues\n      );\n      quantization.normalizationRange = MathType.unpack(\n        arrayFill(new Array(componentCount), normalizationRange)\n      );\n      const packedDimensions = arrayFill(\n        new Array(componentCount),\n        dracoQuantization.range\n      );\n      quantization.quantizedVolumeDimensions = MathType.unpack(\n        packedDimensions\n      );\n\n      // Computing the step size\n      const packedSteps = packedDimensions.map(function (dimension) {\n        return dimension * normalizationDivisor;\n      });\n      quantization.quantizedVolumeStepSize = MathType.unpack(packedSteps);\n    }\n  }\n\n  return quantization;\n}\n\nfunction loadFromDraco(vertexBufferLoader) {\n  const resourceCache = vertexBufferLoader._resourceCache;\n  const dracoLoader = resourceCache.loadDraco({\n    gltf: vertexBufferLoader._gltf,\n    draco: vertexBufferLoader._draco,\n    gltfResource: vertexBufferLoader._gltfResource,\n    baseResource: vertexBufferLoader._baseResource,\n  });\n\n  vertexBufferLoader._dracoLoader = dracoLoader;\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n\n  return dracoLoader.promise.then(function () {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n    // Get the typed array and quantization information\n    const decodedVertexAttributes = dracoLoader.decodedData.vertexAttributes;\n    const attributeSemantic = vertexBufferLoader._attributeSemantic;\n    const dracoAttribute = decodedVertexAttributes[attributeSemantic];\n    const accessorId = vertexBufferLoader._accessorId;\n    const accessor = vertexBufferLoader._gltf.accessors[accessorId];\n    const type = accessor.type;\n    const typedArray = dracoAttribute.array;\n    const dracoQuantization = dracoAttribute.data.quantization;\n    if (defined(dracoQuantization)) {\n      vertexBufferLoader._quantization = getQuantizationInformation(\n        dracoQuantization,\n        dracoAttribute.data.componentDatatype,\n        dracoAttribute.data.componentsPerAttribute,\n        type\n      );\n    }\n\n    // Now wait for process() to run to finish loading\n    vertexBufferLoader._typedArray = typedArray;\n    vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return vertexBufferLoader;\n  });\n}\n\nfunction loadFromBufferView(vertexBufferLoader) {\n  const resourceCache = vertexBufferLoader._resourceCache;\n  const bufferViewLoader = resourceCache.loadBufferView({\n    gltf: vertexBufferLoader._gltf,\n    bufferViewId: vertexBufferLoader._bufferViewId,\n    gltfResource: vertexBufferLoader._gltfResource,\n    baseResource: vertexBufferLoader._baseResource,\n  });\n  vertexBufferLoader._state = ResourceLoaderState.LOADING;\n  vertexBufferLoader._bufferViewLoader = bufferViewLoader;\n\n  return bufferViewLoader.promise.then(function () {\n    if (vertexBufferLoader.isDestroyed()) {\n      return;\n    }\n    // Now wait for process() to run to finish loading\n    vertexBufferLoader._typedArray = bufferViewLoader.typedArray;\n    vertexBufferLoader._state = ResourceLoaderState.PROCESSING;\n    return vertexBufferLoader;\n  });\n}\n\nfunction handleError(vertexBufferLoader, error) {\n  vertexBufferLoader.unload();\n  vertexBufferLoader._state = ResourceLoaderState.FAILED;\n  const errorMessage = \"Failed to load vertex buffer\";\n  error = vertexBufferLoader.getError(errorMessage, error);\n  return Promise.reject(error);\n}\n\nfunction CreateVertexBufferJob() {\n  this.typedArray = undefined;\n  this.dequantize = undefined;\n  this.componentType = undefined;\n  this.type = undefined;\n  this.count = undefined;\n  this.context = undefined;\n  this.buffer = undefined;\n}\n\nCreateVertexBufferJob.prototype.set = function (\n  typedArray,\n  dequantize,\n  componentType,\n  type,\n  count,\n  context\n) {\n  this.typedArray = typedArray;\n  this.dequantize = dequantize;\n  this.componentType = componentType;\n  this.type = type;\n  this.count = count;\n  this.context = context;\n};\n\nCreateVertexBufferJob.prototype.execute = function () {\n  this.buffer = createVertexBuffer(\n    this.typedArray,\n    this.dequantize,\n    this.componentType,\n    this.type,\n    this.count,\n    this.context\n  );\n};\n\nfunction createVertexBuffer(\n  typedArray,\n  dequantize,\n  componentType,\n  type,\n  count,\n  context\n) {\n  if (dequantize && componentType !== ComponentDatatype.FLOAT) {\n    typedArray = AttributeCompression.dequantize(\n      typedArray,\n      componentType,\n      type,\n      count\n    );\n  }\n\n  const buffer = Buffer.createVertexBuffer({\n    typedArray: typedArray,\n    context: context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  buffer.vertexArrayDestroyable = false;\n  return buffer;\n}\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGltfVertexBufferLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  return this._process(this, frameState);\n};\n\n/**\n * Unloads the resource.\n * @private\n */\nGltfVertexBufferLoader.prototype.unload = function () {\n  if (defined(this._buffer)) {\n    this._buffer.destroy();\n  }\n\n  const resourceCache = this._resourceCache;\n\n  if (defined(this._bufferViewLoader)) {\n    resourceCache.unload(this._bufferViewLoader);\n  }\n\n  if (defined(this._dracoLoader)) {\n    resourceCache.unload(this._dracoLoader);\n  }\n\n  this._bufferViewLoader = undefined;\n  this._dracoLoader = undefined;\n  this._typedArray = undefined;\n  this._buffer = undefined;\n  this._gltf = undefined;\n};\n","import Credit from \"../Core/Credit.js\";\nimport decodeGoogleEarthEnterpriseData from \"../Core/decodeGoogleEarthEnterpriseData.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\nimport GoogleEarthEnterpriseMetadata from \"../Core/GoogleEarthEnterpriseMetadata.js\";\nimport loadImageFromTypedArray from \"../Core/loadImageFromTypedArray.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Request from \"../Core/Request.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport protobuf from \"../ThirdParty/protobufjs.js\";\n\n/**\n * @private\n */\nfunction GoogleEarthEnterpriseDiscardPolicy() {\n  this._image = new Image();\n}\n\n/**\n * Determines if the discard policy is ready to process images.\n * @returns {Boolean} True if the discard policy is ready to process images; otherwise, false.\n */\nGoogleEarthEnterpriseDiscardPolicy.prototype.isReady = function () {\n  return true;\n};\n\n/**\n * Given a tile image, decide whether to discard that image.\n *\n * @param {HTMLImageElement} image An image to test.\n * @returns {Boolean} True if the image should be discarded; otherwise, false.\n */\nGoogleEarthEnterpriseDiscardPolicy.prototype.shouldDiscardImage = function (\n  image\n) {\n  return image === this._image;\n};\n\n/**\n * @typedef {Object} GoogleEarthEnterpriseImageryProvider.ConstructorOptions\n *\n * Initialization options for the GoogleEarthEnterpriseImageryProvider constructor\n *\n * @property {Resource|String} url The url of the Google Earth Enterprise server hosting the imagery.\n * @property {GoogleEarthEnterpriseMetadata} metadata A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseTerrainProvider.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @property {TileDiscardPolicy} [tileDiscardPolicy] The policy that determines if a tile\n *        is invalid and should be discarded. If this value is not specified, a default\n *        is to discard tiles that fail to download.\n * @property {Credit|String} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * Provides tiled imagery using the Google Earth Enterprise REST API.\n *\n * Notes: This provider is for use with the 3D Earth API of Google Earth Enterprise,\n *        {@link GoogleEarthEnterpriseMapsProvider} should be used with 2D Maps API.\n *\n * @alias GoogleEarthEnterpriseImageryProvider\n * @constructor\n *\n * @param {GoogleEarthEnterpriseImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @see GoogleEarthEnterpriseTerrainProvider\n * @see ArcGisMapServerImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n *\n *\n * @example\n * const geeMetadata = new GoogleEarthEnterpriseMetadata('http://www.earthenterprise.org/3d');\n * const gee = new Cesium.GoogleEarthEnterpriseImageryProvider({\n *     metadata : geeMetadata\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nfunction GoogleEarthEnterpriseImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!(defined(options.url) || defined(options.metadata))) {\n    throw new DeveloperError(\"options.url or options.metadata is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  let metadata;\n  if (defined(options.metadata)) {\n    metadata = options.metadata;\n  } else {\n    const resource = Resource.createIfNeeded(options.url);\n    metadata = new GoogleEarthEnterpriseMetadata(resource);\n  }\n  this._metadata = metadata;\n  this._tileDiscardPolicy = options.tileDiscardPolicy;\n\n  this._tilingScheme = new GeographicTilingScheme({\n    numberOfLevelZeroTilesX: 2,\n    numberOfLevelZeroTilesY: 2,\n    rectangle: new Rectangle(\n      -CesiumMath.PI,\n      -CesiumMath.PI,\n      CesiumMath.PI,\n      CesiumMath.PI\n    ),\n    ellipsoid: options.ellipsoid,\n  });\n\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  this._tileWidth = 256;\n  this._tileHeight = 256;\n  this._maximumLevel = 23;\n\n  // Install the default tile discard policy if none has been supplied.\n  if (!defined(this._tileDiscardPolicy)) {\n    this._tileDiscardPolicy = new GoogleEarthEnterpriseDiscardPolicy();\n  }\n\n  this._errorEvent = new Event();\n\n  this._ready = false;\n  const that = this;\n  let metadataError;\n  this._readyPromise = metadata.readyPromise\n    .then(function (result) {\n      if (!metadata.imageryPresent) {\n        const e = new RuntimeError(\n          `The server ${metadata.url} doesn't have imagery`\n        );\n        metadataError = TileProviderError.handleError(\n          metadataError,\n          that,\n          that._errorEvent,\n          e.message,\n          undefined,\n          undefined,\n          undefined,\n          e\n        );\n        return Promise.reject(e);\n      }\n\n      TileProviderError.handleSuccess(metadataError);\n      that._ready = result;\n      return result;\n    })\n    .catch(function (e) {\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        e.message,\n        undefined,\n        undefined,\n        undefined,\n        e\n      );\n      return Promise.reject(e);\n    });\n}\n\nObject.defineProperties(GoogleEarthEnterpriseImageryProvider.prototype, {\n  /**\n   * Gets the name of the Google Earth Enterprise server url hosting the imagery.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._metadata.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._metadata.proxy;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileWidth must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"maximumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"minimumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"rectangle must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme.rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileDiscardPolicy must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage\n   * and texture upload time.\n   * @memberof GoogleEarthEnterpriseImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return false;\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nGoogleEarthEnterpriseImageryProvider.prototype.getTileCredits = function (\n  x,\n  y,\n  level\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"getTileCredits must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const metadata = this._metadata;\n  const info = metadata.getTileInformation(x, y, level);\n  if (defined(info)) {\n    const credit = metadata.providers[info.imageryProvider];\n    if (defined(credit)) {\n      return [credit];\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nGoogleEarthEnterpriseImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestImage must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const invalidImage = this._tileDiscardPolicy._image; // Empty image or undefined depending on discard policy\n  const metadata = this._metadata;\n  const quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  const info = metadata.getTileInformation(x, y, level);\n  if (!defined(info)) {\n    if (metadata.isValid(quadKey)) {\n      const metadataRequest = new Request({\n        throttle: request.throttle,\n        throttleByServer: request.throttleByServer,\n        type: request.type,\n        priorityFunction: request.priorityFunction,\n      });\n      metadata.populateSubtree(x, y, level, metadataRequest);\n      return undefined; // No metadata so return undefined so we can be loaded later\n    }\n    return Promise.resolve(invalidImage); // Image doesn't exist\n  }\n\n  if (!info.hasImagery()) {\n    // Already have info and there isn't any imagery here\n    return Promise.resolve(invalidImage);\n  }\n  const promise = buildImageResource(\n    this,\n    info,\n    x,\n    y,\n    level,\n    request\n  ).fetchArrayBuffer();\n  if (!defined(promise)) {\n    return undefined; // Throttled\n  }\n\n  return promise.then(function (image) {\n    decodeGoogleEarthEnterpriseData(metadata.key, image);\n    let a = new Uint8Array(image);\n    let type;\n\n    const protoImagery = metadata.protoImagery;\n    if (!defined(protoImagery) || !protoImagery) {\n      type = getImageType(a);\n    }\n\n    if (!defined(type) && (!defined(protoImagery) || protoImagery)) {\n      const message = decodeEarthImageryPacket(a);\n      type = message.imageType;\n      a = message.imageData;\n    }\n\n    if (!defined(type) || !defined(a)) {\n      return invalidImage;\n    }\n\n    return loadImageFromTypedArray({\n      uint8Array: a,\n      format: type,\n      flipY: true,\n    });\n  });\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {undefined} Undefined since picking is not supported.\n */\nGoogleEarthEnterpriseImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return undefined;\n};\n\n//\n// Functions to handle imagery packets\n//\nfunction buildImageResource(imageryProvider, info, x, y, level, request) {\n  const quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  let version = info.imageryVersion;\n  version = defined(version) && version > 0 ? version : 1;\n\n  return imageryProvider._metadata.resource.getDerivedResource({\n    url: `flatfile?f1-0${quadKey}-i.${version.toString()}`,\n    request: request,\n  });\n}\n\n// Detects if a Uint8Array is a JPEG or PNG\nfunction getImageType(image) {\n  const jpeg = \"JFIF\";\n  if (\n    image[6] === jpeg.charCodeAt(0) &&\n    image[7] === jpeg.charCodeAt(1) &&\n    image[8] === jpeg.charCodeAt(2) &&\n    image[9] === jpeg.charCodeAt(3)\n  ) {\n    return \"image/jpeg\";\n  }\n\n  const png = \"PNG\";\n  if (\n    image[1] === png.charCodeAt(0) &&\n    image[2] === png.charCodeAt(1) &&\n    image[3] === png.charCodeAt(2)\n  ) {\n    return \"image/png\";\n  }\n\n  return undefined;\n}\n\n// Decodes an Imagery protobuf into the message\n// Partially generated with the help of protobuf.js static generator\nfunction decodeEarthImageryPacket(data) {\n  const reader = protobuf.Reader.create(data);\n  const end = reader.len;\n  const message = {};\n  while (reader.pos < end) {\n    const tag = reader.uint32();\n    let copyrightIds;\n    switch (tag >>> 3) {\n      case 1:\n        message.imageType = reader.uint32();\n        break;\n      case 2:\n        message.imageData = reader.bytes();\n        break;\n      case 3:\n        message.alphaType = reader.uint32();\n        break;\n      case 4:\n        message.imageAlpha = reader.bytes();\n        break;\n      case 5:\n        copyrightIds = message.copyrightIds;\n        if (!defined(copyrightIds)) {\n          copyrightIds = message.copyrightIds = [];\n        }\n        if ((tag & 7) === 2) {\n          const end2 = reader.uint32() + reader.pos;\n          while (reader.pos < end2) {\n            copyrightIds.push(reader.uint32());\n          }\n        } else {\n          copyrightIds.push(reader.uint32());\n        }\n        break;\n      default:\n        reader.skipType(tag & 7);\n        break;\n    }\n  }\n\n  const imageType = message.imageType;\n  if (defined(imageType)) {\n    switch (imageType) {\n      case 0:\n        message.imageType = \"image/jpeg\";\n        break;\n      case 4:\n        message.imageType = \"image/png\";\n        break;\n      default:\n        throw new RuntimeError(\n          \"GoogleEarthEnterpriseImageryProvider: Unsupported image type.\"\n        );\n    }\n  }\n\n  const alphaType = message.alphaType;\n  if (defined(alphaType) && alphaType !== 0) {\n    console.log(\n      \"GoogleEarthEnterpriseImageryProvider: External alpha not supported.\"\n    );\n    delete message.alphaType;\n    delete message.imageAlpha;\n  }\n\n  return message;\n}\nexport default GoogleEarthEnterpriseImageryProvider;\n","import buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Check from \"../Core/Check.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorTilingScheme from \"../Core/WebMercatorTilingScheme.js\";\nimport ImageryProvider from \"./ImageryProvider.js\";\n\n/**\n * @typedef {Object} GoogleEarthEnterpriseMapsProvider.ConstructorOptions\n *\n * Initialization options for the GoogleEarthEnterpriseMapsProvider constructor\n *\n * @property {Resource|String} url The url of the Google Earth server hosting the imagery.\n * @property {Number} channel The channel (id) to be used when requesting data from the server.\n *        The channel number can be found by looking at the json file located at:\n *        earth.localdomain/default_map/query?request=Json&vars=geeServerDefs The /default_map path may\n *        differ depending on your Google Earth Enterprise server configuration. Look for the \"id\" that\n *        is associated with a \"ImageryMaps\" requestType. There may be more than one id available.\n *        Example:\n *        {\n *          layers: [\n *            {\n *              id: 1002,\n *              requestType: \"ImageryMaps\"\n *            },\n *            {\n *              id: 1007,\n *              requestType: \"VectorMapsRaster\"\n *            }\n *          ]\n *        }\n * @property {String} [path=\"/default_map\"] The path of the Google Earth server hosting the imagery.\n * @property {Number} [maximumLevel] The maximum level-of-detail supported by the Google Earth\n *        Enterprise server, or undefined if there is no limit.\n * @property {TileDiscardPolicy} [tileDiscardPolicy] The policy that determines if a tile\n *        is invalid and should be discarded. To ensure that no tiles are discarded, construct and pass\n *        a {@link NeverTileDiscardPolicy} for this parameter.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n */\n\n/**\n * Provides tiled imagery using the Google Earth Imagery API.\n *\n * Notes: This imagery provider does not work with the public Google Earth servers. It works with the\n *        Google Earth Enterprise Server.\n *\n *        By default the Google Earth Enterprise server does not set the\n *        {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing} headers. You can either\n *        use a proxy server which adds these headers, or in the /opt/google/gehttpd/conf/gehttpd.conf\n *        and add the 'Header set Access-Control-Allow-Origin \"*\"' option to the '&lt;Directory /&gt;' and\n *        '&lt;Directory \"/opt/google/gehttpd/htdocs\"&gt;' directives.\n *\n *        This provider is for use with 2D Maps API as part of Google Earth Enterprise. For 3D Earth API uses, it\n *        is necessary to use {@link GoogleEarthEnterpriseImageryProvider}\n *\n * @alias GoogleEarthEnterpriseMapsProvider\n * @constructor\n *\n * @param {GoogleEarthEnterpriseMapsProvider.ConstructorOptions} options Object describing initialization options\n *\n * @exception {RuntimeError} Could not find layer with channel (id) of <code>options.channel</code>.\n * @exception {RuntimeError} Could not find a version in channel (id) <code>options.channel</code>.\n * @exception {RuntimeError} Unsupported projection <code>data.projection</code>.\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see OpenStreetMapImageryProvider\n * @see SingleTileImageryProvider\n * @see TileMapServiceImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n * @see UrlTemplateImageryProvider\n *\n *\n * @example\n * const google = new Cesium.GoogleEarthEnterpriseMapsProvider({\n *     url : 'https://earth.localdomain',\n *     channel : 1008\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nfunction GoogleEarthEnterpriseMapsProvider(options) {\n  options = defaultValue(options, {});\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.url)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  if (!defined(options.channel)) {\n    throw new DeveloperError(\"options.channel is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default 1.9\n   */\n  this.defaultGamma = 1.9;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  const url = options.url;\n  const path = defaultValue(options.path, \"/default_map\");\n\n  const resource = Resource.createIfNeeded(url).getDerivedResource({\n    // We used to just append path to url, so now that we do proper URI resolution, removed the /\n    url: path[0] === \"/\" ? path.substring(1) : path,\n  });\n\n  resource.appendForwardSlash();\n\n  this._resource = resource;\n  this._url = url;\n  this._path = path;\n  this._tileDiscardPolicy = options.tileDiscardPolicy;\n  this._channel = options.channel;\n  this._requestType = \"ImageryMaps\";\n  this._credit = new Credit(\n    `<a href=\"http://www.google.com/enterprise/mapsearth/products/earthenterprise.html\"><img src=\"${GoogleEarthEnterpriseMapsProvider.logoUrl}\" title=\"Google Imagery\"/></a>`\n  );\n\n  this._tilingScheme = undefined;\n\n  this._version = undefined;\n\n  this._tileWidth = 256;\n  this._tileHeight = 256;\n  this._maximumLevel = options.maximumLevel;\n\n  this._errorEvent = new Event();\n\n  this._ready = false;\n  this._readyPromise = defer();\n\n  const metadataResource = resource.getDerivedResource({\n    url: \"query\",\n    queryParameters: {\n      request: \"Json\",\n      vars: \"geeServerDefs\",\n      is2d: \"t\",\n    },\n  });\n  const that = this;\n  let metadataError;\n\n  function metadataSuccess(text) {\n    let data;\n\n    // The Google Earth server sends malformed JSON data currently...\n    try {\n      // First, try parsing it like normal in case a future version sends correctly formatted JSON\n      data = JSON.parse(text);\n    } catch (e) {\n      // Quote object strings manually, then try parsing again\n      data = JSON.parse(\n        text.replace(/([\\[\\{,])[\\n\\r ]*([A-Za-z0-9]+)[\\n\\r ]*:/g, '$1\"$2\":')\n      );\n    }\n\n    let layer;\n    for (let i = 0; i < data.layers.length; i++) {\n      if (data.layers[i].id === that._channel) {\n        layer = data.layers[i];\n        break;\n      }\n    }\n\n    let message;\n\n    if (!defined(layer)) {\n      message = `Could not find layer with channel (id) of ${that._channel}.`;\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestMetadata\n      );\n      throw new RuntimeError(message);\n    }\n\n    if (!defined(layer.version)) {\n      message = `Could not find a version in channel (id) ${that._channel}.`;\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestMetadata\n      );\n      throw new RuntimeError(message);\n    }\n    that._version = layer.version;\n\n    if (defined(data.projection) && data.projection === \"flat\") {\n      that._tilingScheme = new GeographicTilingScheme({\n        numberOfLevelZeroTilesX: 2,\n        numberOfLevelZeroTilesY: 2,\n        rectangle: new Rectangle(-Math.PI, -Math.PI, Math.PI, Math.PI),\n        ellipsoid: options.ellipsoid,\n      });\n      // Default to mercator projection when projection is undefined\n    } else if (!defined(data.projection) || data.projection === \"mercator\") {\n      that._tilingScheme = new WebMercatorTilingScheme({\n        numberOfLevelZeroTilesX: 2,\n        numberOfLevelZeroTilesY: 2,\n        ellipsoid: options.ellipsoid,\n      });\n    } else {\n      message = `Unsupported projection ${data.projection}.`;\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestMetadata\n      );\n      throw new RuntimeError(message);\n    }\n\n    that._ready = true;\n    that._readyPromise.resolve(true);\n    TileProviderError.handleSuccess(metadataError);\n  }\n\n  function metadataFailure(e) {\n    const message = defaultValue(\n      e.message,\n      `An error occurred while accessing ${metadataResource.url}.`\n    );\n    metadataError = TileProviderError.handleError(\n      metadataError,\n      that,\n      that._errorEvent,\n      message,\n      undefined,\n      undefined,\n      undefined,\n      requestMetadata\n    );\n    that._readyPromise.reject(new RuntimeError(message));\n  }\n\n  function requestMetadata() {\n    metadataResource\n      .fetchText()\n      .then(function (text) {\n        metadataSuccess(text);\n      })\n      .catch(function (e) {\n        metadataFailure(e);\n      });\n  }\n\n  requestMetadata();\n}\n\nObject.defineProperties(GoogleEarthEnterpriseMapsProvider.prototype, {\n  /**\n   * Gets the URL of the Google Earth MapServer.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._url;\n    },\n  },\n\n  /**\n   * Gets the url path of the data on the Google Earth server.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  path: {\n    get: function () {\n      return this._path;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._resource.proxy;\n    },\n  },\n\n  /**\n   * Gets the imagery channel (id) currently being used.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  channel: {\n    get: function () {\n      return this._channel;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileWidth must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"maximumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"minimumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return 0;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the version of the data used by this provider.  This function should\n   * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  version: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"version must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._version;\n    },\n  },\n\n  /**\n   * Gets the type of data that is being requested from the provider.  This function should\n   * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  requestType: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"requestType must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._requestType;\n    },\n  },\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"rectangle must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme.rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileDiscardPolicy must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof GoogleEarthEnterpriseMapsProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return true;\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nGoogleEarthEnterpriseMapsProvider.prototype.getTileCredits = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nGoogleEarthEnterpriseMapsProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestImage must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const resource = this._resource.getDerivedResource({\n    url: \"query\",\n    request: request,\n    queryParameters: {\n      request: this._requestType,\n      channel: this._channel,\n      version: this._version,\n      x: x,\n      y: y,\n      z: level + 1, // Google Earth starts with a zoom level of 1, not 0\n    },\n  });\n\n  return ImageryProvider.loadImage(this, resource);\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {undefined} Undefined since picking is not supported.\n */\nGoogleEarthEnterpriseMapsProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return undefined;\n};\n\nGoogleEarthEnterpriseMapsProvider._logoUrl = undefined;\n\nObject.defineProperties(GoogleEarthEnterpriseMapsProvider, {\n  /**\n   * Gets or sets the URL to the Google Earth logo for display in the credit.\n   * @memberof GoogleEarthEnterpriseMapsProvider\n   * @type {String}\n   */\n  logoUrl: {\n    get: function () {\n      if (!defined(GoogleEarthEnterpriseMapsProvider._logoUrl)) {\n        GoogleEarthEnterpriseMapsProvider._logoUrl = buildModuleUrl(\n          \"Assets/Images/google_earth_credit.png\"\n        );\n      }\n      return GoogleEarthEnterpriseMapsProvider._logoUrl;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n\n      GoogleEarthEnterpriseMapsProvider._logoUrl = value;\n    },\n  },\n});\nexport default GoogleEarthEnterpriseMapsProvider;\n","import Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Event from \"../Core/Event.js\";\nimport GeographicTilingScheme from \"../Core/GeographicTilingScheme.js\";\n\nconst defaultColor = new Color(1.0, 1.0, 1.0, 0.4);\nconst defaultGlowColor = new Color(0.0, 1.0, 0.0, 0.05);\nconst defaultBackgroundColor = new Color(0.0, 0.5, 0.0, 0.2);\n\n/**\n * @typedef {Object} GridImageryProvider.ConstructorOptions\n *\n * Initialization options for the GridImageryProvider constructor\n *\n * @property {TilingScheme} [tilingScheme=new GeographicTilingScheme()] The tiling scheme for which to draw tiles.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n *                    parameter is specified, the WGS84 ellipsoid is used.\n * @property {Number} [cells=8] The number of grids cells.\n * @property {Color} [color=Color(1.0, 1.0, 1.0, 0.4)] The color to draw grid lines.\n * @property {Color} [glowColor=Color(0.0, 1.0, 0.0, 0.05)] The color to draw glow for grid lines.\n * @property {Number} [glowWidth=6] The width of lines used for rendering the line glow effect.\n * @property {Color} [backgroundColor=Color(0.0, 0.5, 0.0, 0.2)] Background fill color.\n * @property {Number} [tileWidth=256] The width of the tile for level-of-detail selection purposes.\n * @property {Number} [tileHeight=256] The height of the tile for level-of-detail selection purposes.\n * @property {Number} [canvasSize=256] The size of the canvas used for rendering.\n */\n\n/**\n * An {@link ImageryProvider} that draws a wireframe grid on every tile with controllable background and glow.\n * May be useful for custom rendering effects or debugging terrain.\n *\n * @alias GridImageryProvider\n * @constructor\n * @param {GridImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n */\nfunction GridImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  this._tilingScheme = defined(options.tilingScheme)\n    ? options.tilingScheme\n    : new GeographicTilingScheme({ ellipsoid: options.ellipsoid });\n  this._cells = defaultValue(options.cells, 8);\n  this._color = defaultValue(options.color, defaultColor);\n  this._glowColor = defaultValue(options.glowColor, defaultGlowColor);\n  this._glowWidth = defaultValue(options.glowWidth, 6);\n  this._backgroundColor = defaultValue(\n    options.backgroundColor,\n    defaultBackgroundColor\n  );\n  this._errorEvent = new Event();\n\n  this._tileWidth = defaultValue(options.tileWidth, 256);\n  this._tileHeight = defaultValue(options.tileHeight, 256);\n\n  // A little larger than tile size so lines are sharper\n  // Note: can't be too much difference otherwise texture blowout\n  this._canvasSize = defaultValue(options.canvasSize, 256);\n\n  // We only need a single canvas since all tiles will be the same\n  this._canvas = this._createGridCanvas();\n\n  this._readyPromise = Promise.resolve(true);\n}\n\nObject.defineProperties(GridImageryProvider.prototype, {\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof GridImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels. This function should\n   * not be called before {@link GridImageryProvider#ready} returns true.\n   * @memberof GridImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      return this._tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link GridImageryProvider#ready} returns true.\n   * @memberof GridImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      return this._tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link GridImageryProvider#ready} returns true.\n   * @memberof GridImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link GridImageryProvider#ready} returns true.\n   * @memberof GridImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link GridImageryProvider#ready} returns true.\n   * @memberof GridImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should\n   * not be called before {@link GridImageryProvider#ready} returns true.\n   * @memberof GridImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._tilingScheme.rectangle;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link GridImageryProvider#ready} returns true.\n   * @memberof GridImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GridImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GridImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return true;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof GridImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery.  This function should not be called before {@link GridImageryProvider#ready} returns true.\n   * @memberof GridImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof GridImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return true;\n    },\n  },\n});\n\n/**\n * Draws a grid of lines into a canvas.\n */\nGridImageryProvider.prototype._drawGrid = function (context) {\n  const minPixel = 0;\n  const maxPixel = this._canvasSize;\n  for (let x = 0; x <= this._cells; ++x) {\n    const nx = x / this._cells;\n    const val = 1 + nx * (maxPixel - 1);\n\n    context.moveTo(val, minPixel);\n    context.lineTo(val, maxPixel);\n    context.moveTo(minPixel, val);\n    context.lineTo(maxPixel, val);\n  }\n  context.stroke();\n};\n\n/**\n * Render a grid into a canvas with background and glow\n */\nGridImageryProvider.prototype._createGridCanvas = function () {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = this._canvasSize;\n  canvas.height = this._canvasSize;\n  const minPixel = 0;\n  const maxPixel = this._canvasSize;\n\n  const context = canvas.getContext(\"2d\");\n\n  // Fill the background\n  const cssBackgroundColor = this._backgroundColor.toCssColorString();\n  context.fillStyle = cssBackgroundColor;\n  context.fillRect(minPixel, minPixel, maxPixel, maxPixel);\n\n  // Glow for grid lines\n  const cssGlowColor = this._glowColor.toCssColorString();\n  context.strokeStyle = cssGlowColor;\n  // Wide\n  context.lineWidth = this._glowWidth;\n  context.strokeRect(minPixel, minPixel, maxPixel, maxPixel);\n  this._drawGrid(context);\n  // Narrow\n  context.lineWidth = this._glowWidth * 0.5;\n  context.strokeRect(minPixel, minPixel, maxPixel, maxPixel);\n  this._drawGrid(context);\n\n  // Grid lines\n  const cssColor = this._color.toCssColorString();\n  // Border\n  context.strokeStyle = cssColor;\n  context.lineWidth = 2;\n  context.strokeRect(minPixel, minPixel, maxPixel, maxPixel);\n  // Inner\n  context.lineWidth = 1;\n  this._drawGrid(context);\n\n  return canvas;\n};\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nGridImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link GridImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<HTMLCanvasElement>} The resolved image as a Canvas DOM object.\n */\nGridImageryProvider.prototype.requestImage = function (x, y, level, request) {\n  return Promise.resolve(this._canvas);\n};\n\n/**\n * Picking features is not currently supported by this imagery provider, so this function simply returns\n * undefined.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {undefined} Undefined since picking is not supported.\n */\nGridImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return undefined;\n};\nexport default GridImageryProvider;\n","import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryInstanceAttribute from \"../Core/GeometryInstanceAttribute.js\";\nimport GroundPolylineGeometry from \"../Core/GroundPolylineGeometry.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport PolylineShadowVolumeFS from \"../Shaders/PolylineShadowVolumeFS.js\";\nimport PolylineShadowVolumeMorphFS from \"../Shaders/PolylineShadowVolumeMorphFS.js\";\nimport PolylineShadowVolumeMorphVS from \"../Shaders/PolylineShadowVolumeMorphVS.js\";\nimport PolylineShadowVolumeVS from \"../Shaders/PolylineShadowVolumeVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport CullFace from \"./CullFace.js\";\nimport PolylineColorAppearance from \"./PolylineColorAppearance.js\";\nimport PolylineMaterialAppearance from \"./PolylineMaterialAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * A GroundPolylinePrimitive represents a polyline draped over the terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * Only to be used with GeometryInstances containing {@link GroundPolylineGeometry}.\n * </p>\n *\n * @alias GroundPolylinePrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] GeometryInstances containing GroundPolylineGeometry\n * @param {Appearance} [options.appearance] The Appearance used to render the polyline. Defaults to a white color {@link Material} on a {@link PolylineMaterialAppearance}.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on creation to have effect.\n *\n * @example\n * // 1. Draw a polyline on terrain with a basic color material\n *\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715\n *      ]),\n *      width : 4.0\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.PolylineMaterialAppearance()\n * }));\n *\n * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.\n * // Distance display conditions for polylines on terrain are based on an approximate terrain height\n * // instead of true terrain height.\n *\n * const instance2 = new Cesium.GeometryInstance({\n *   geometry : new Cesium.GroundPolylineGeometry({\n *      positions : Cesium.Cartesian3.fromDegreesArray([\n *          -112.1340164450331, 36.05494287836128,\n *          -112.08821010582645, 36.097804071380715,\n *          -112.13296079730024, 36.168769146801104\n *      ]),\n *      loop : true,\n *      width : 4.0\n *   }),\n *   attributes : {\n *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),\n *      distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)\n *   },\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n *\n * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({\n *   geometryInstances : instance2,\n *   appearance : new Cesium.PolylineColorAppearance()\n * }));\n */\nfunction GroundPolylinePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The geometry instances rendered with this primitive. This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n  this._hasPerInstanceColors = true;\n\n  let appearance = options.appearance;\n  if (!defined(appearance)) {\n    appearance = new PolylineMaterialAppearance();\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PolylineColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = appearance;\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  // Shadow volume is shown by removing a discard in the shader, so this isn't toggleable.\n  this._debugShowShadowVolume = defaultValue(\n    options.debugShowShadowVolume,\n    false\n  );\n\n  this._primitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: false,\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(\n      options.releaseGeometryInstances,\n      true\n    ),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: false,\n    _createShaderProgramFunction: undefined,\n    _createCommandsFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n  };\n\n  // Used when inserting in an OrderedPrimitiveCollection\n  this._zIndex = undefined;\n\n  this._ready = false;\n  this._readyPromise = defer();\n\n  this._primitive = undefined;\n\n  this._sp = undefined;\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n\n  this._renderState = getRenderState(false);\n  this._renderState3DTiles = getRenderState(true);\n\n  this._renderStateMorph = RenderState.fromCache({\n    cull: {\n      enabled: true,\n      face: CullFace.FRONT, // Geometry is \"inverted,\" so cull front when materials on volume instead of on terrain (morph)\n    },\n    depthTest: {\n      enabled: true,\n    },\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n    depthMask: false,\n  });\n}\n\nObject.defineProperties(GroundPolylinePrimitive.prototype, {\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._primitiveOptions.interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._primitiveOptions.releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._primitiveOptions.allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._primitiveOptions.asynchronous;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof GroundPolylinePrimitive.prototype\n   * @type {Promise.<GroundPolylinePrimitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * If true, draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @memberof GroundPolylinePrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  debugShowShadowVolume: {\n    get: function () {\n      return this._debugShowShadowVolume;\n    },\n  },\n});\n\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPolylinePrimitive synchronously.\n *\n * @returns {Promise<void>} A promise that will resolve once the terrain heights have been loaded.\n */\nGroundPolylinePrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\n\nfunction createShaderProgram(groundPolylinePrimitive, frameState, appearance) {\n  const context = frameState.context;\n  const primitive = groundPolylinePrimitive._primitive;\n  const attributeLocations = primitive._attributeLocations;\n\n  let vs = primitive._batchTable.getVertexShaderCallback()(\n    PolylineShadowVolumeVS\n  );\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs);\n  vs = Primitive._modifyShaderPosition(\n    groundPolylinePrimitive,\n    vs,\n    frameState.scene3DOnly\n  );\n\n  let vsMorph = primitive._batchTable.getVertexShaderCallback()(\n    PolylineShadowVolumeMorphVS\n  );\n  vsMorph = Primitive._appendShowToShader(primitive, vsMorph);\n  vsMorph = Primitive._appendDistanceDisplayConditionToShader(\n    primitive,\n    vsMorph\n  );\n  vsMorph = Primitive._modifyShaderPosition(\n    groundPolylinePrimitive,\n    vsMorph,\n    frameState.scene3DOnly\n  );\n\n  // Access pick color from fragment shader.\n  // Helps with varying budget.\n  let fs = primitive._batchTable.getVertexShaderCallback()(\n    PolylineShadowVolumeFS\n  );\n\n  const vsDefines = [\n    `GLOBE_MINIMUM_ALTITUDE ${frameState.mapProjection.ellipsoid.minimumRadius.toFixed(\n      1\n    )}`,\n  ];\n  let colorDefine = \"\";\n  let materialShaderSource = \"\";\n  if (defined(appearance.material)) {\n    materialShaderSource = defined(appearance.material)\n      ? appearance.material.shaderSource\n      : \"\";\n\n    // Check for use of v_width and v_polylineAngle in material shader\n    // to determine whether these varyings should be active in the vertex shader.\n    if (\n      materialShaderSource.search(/varying\\s+float\\s+v_polylineAngle;/g) !== -1\n    ) {\n      vsDefines.push(\"ANGLE_VARYING\");\n    }\n    if (materialShaderSource.search(/varying\\s+float\\s+v_width;/g) !== -1) {\n      vsDefines.push(\"WIDTH_VARYING\");\n    }\n  } else {\n    colorDefine = \"PER_INSTANCE_COLOR\";\n  }\n\n  vsDefines.push(colorDefine);\n  const fsDefines = groundPolylinePrimitive.debugShowShadowVolume\n    ? [\"DEBUG_SHOW_VOLUME\", colorDefine]\n    : [colorDefine];\n\n  const vsColor3D = new ShaderSource({\n    defines: vsDefines,\n    sources: [vs],\n  });\n  const fsColor3D = new ShaderSource({\n    defines: fsDefines,\n    sources: [materialShaderSource, fs],\n  });\n  groundPolylinePrimitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vsColor3D,\n    fragmentShaderSource: fsColor3D,\n    attributeLocations: attributeLocations,\n  });\n\n  // Derive 2D/CV\n  let colorProgram2D = context.shaderCache.getDerivedShaderProgram(\n    groundPolylinePrimitive._sp,\n    \"2dColor\"\n  );\n  if (!defined(colorProgram2D)) {\n    const vsColor2D = new ShaderSource({\n      defines: vsDefines.concat([\"COLUMBUS_VIEW_2D\"]),\n      sources: [vs],\n    });\n    colorProgram2D = context.shaderCache.createDerivedShaderProgram(\n      groundPolylinePrimitive._sp,\n      \"2dColor\",\n      {\n        context: context,\n        shaderProgram: groundPolylinePrimitive._sp2D,\n        vertexShaderSource: vsColor2D,\n        fragmentShaderSource: fsColor3D,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n  groundPolylinePrimitive._sp2D = colorProgram2D;\n\n  // Derive Morph\n  let colorProgramMorph = context.shaderCache.getDerivedShaderProgram(\n    groundPolylinePrimitive._sp,\n    \"MorphColor\"\n  );\n  if (!defined(colorProgramMorph)) {\n    const vsColorMorph = new ShaderSource({\n      defines: vsDefines.concat([\n        `MAX_TERRAIN_HEIGHT ${ApproximateTerrainHeights._defaultMaxTerrainHeight.toFixed(\n          1\n        )}`,\n      ]),\n      sources: [vsMorph],\n    });\n\n    fs = primitive._batchTable.getVertexShaderCallback()(\n      PolylineShadowVolumeMorphFS\n    );\n    const fsColorMorph = new ShaderSource({\n      defines: fsDefines,\n      sources: [materialShaderSource, fs],\n    });\n    colorProgramMorph = context.shaderCache.createDerivedShaderProgram(\n      groundPolylinePrimitive._sp,\n      \"MorphColor\",\n      {\n        context: context,\n        shaderProgram: groundPolylinePrimitive._spMorph,\n        vertexShaderSource: vsColorMorph,\n        fragmentShaderSource: fsColorMorph,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n  groundPolylinePrimitive._spMorph = colorProgramMorph;\n}\n\nfunction getRenderState(mask3DTiles) {\n  return RenderState.fromCache({\n    cull: {\n      enabled: true, // prevent double-draw. Geometry is \"inverted\" (reversed winding order) so we're drawing backfaces.\n    },\n    blending: BlendingState.PRE_MULTIPLIED_ALPHA_BLEND,\n    depthMask: false,\n    stencilTest: {\n      enabled: mask3DTiles,\n      frontFunction: StencilFunction.EQUAL,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: StencilFunction.EQUAL,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.KEEP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n  });\n}\n\nfunction createCommands(\n  groundPolylinePrimitive,\n  appearance,\n  material,\n  translucent,\n  colorCommands,\n  pickCommands\n) {\n  const primitive = groundPolylinePrimitive._primitive;\n  const length = primitive._va.length;\n  colorCommands.length = length;\n  pickCommands.length = length;\n\n  const isPolylineColorAppearance =\n    appearance instanceof PolylineColorAppearance;\n\n  const materialUniforms = isPolylineColorAppearance ? {} : material._uniforms;\n  const uniformMap = primitive._batchTable.getUniformMapCallback()(\n    materialUniforms\n  );\n\n  for (let i = 0; i < length; i++) {\n    const vertexArray = primitive._va[i];\n\n    let command = colorCommands[i];\n    if (!defined(command)) {\n      command = colorCommands[i] = new DrawCommand({\n        owner: groundPolylinePrimitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n\n    command.vertexArray = vertexArray;\n    command.renderState = groundPolylinePrimitive._renderState;\n    command.shaderProgram = groundPolylinePrimitive._sp;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.TERRAIN_CLASSIFICATION;\n    command.pickId = \"czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)\";\n\n    const derivedTilesetCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.tileset\n    );\n    derivedTilesetCommand.renderState =\n      groundPolylinePrimitive._renderState3DTiles;\n    derivedTilesetCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    command.derivedCommands.tileset = derivedTilesetCommand;\n\n    // derive for 2D\n    const derived2DCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.color2D\n    );\n    derived2DCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    command.derivedCommands.color2D = derived2DCommand;\n\n    const derived2DTilesetCommand = DrawCommand.shallowClone(\n      derivedTilesetCommand,\n      derivedTilesetCommand.derivedCommands.color2D\n    );\n    derived2DTilesetCommand.shaderProgram = groundPolylinePrimitive._sp2D;\n    derivedTilesetCommand.derivedCommands.color2D = derived2DTilesetCommand;\n\n    // derive for Morph\n    const derivedMorphCommand = DrawCommand.shallowClone(\n      command,\n      command.derivedCommands.colorMorph\n    );\n    derivedMorphCommand.renderState = groundPolylinePrimitive._renderStateMorph;\n    derivedMorphCommand.shaderProgram = groundPolylinePrimitive._spMorph;\n    derivedMorphCommand.pickId = \"czm_batchTable_pickColor(v_batchId)\";\n    command.derivedCommands.colorMorph = derivedMorphCommand;\n  }\n}\n\nfunction updateAndQueueCommand(\n  groundPolylinePrimitive,\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n  debugShowBoundingVolume\n) {\n  // Use derived appearance command for morph and 2D\n  if (frameState.mode === SceneMode.MORPHING) {\n    command = command.derivedCommands.colorMorph;\n  } else if (frameState.mode !== SceneMode.SCENE3D) {\n    command = command.derivedCommands.color2D;\n  }\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(\n  groundPolylinePrimitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume\n) {\n  const primitive = groundPolylinePrimitive._primitive;\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix); // Expected to be identity - GroundPrimitives don't support other model matrices\n\n  let boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  const morphing = frameState.mode === SceneMode.MORPHING;\n  const classificationType = groundPolylinePrimitive.classificationType;\n  const queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands =\n    classificationType !== ClassificationType.TERRAIN && !morphing;\n\n  let command;\n  const passes = frameState.passes;\n  if (passes.render || (passes.pick && primitive.allowPicking)) {\n    const colorLength = colorCommands.length;\n    for (let j = 0; j < colorLength; ++j) {\n      const boundingVolume = boundingSpheres[j];\n      if (queueTerrainCommands) {\n        command = colorCommands[j];\n        updateAndQueueCommand(\n          groundPolylinePrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[j].derivedCommands.tileset;\n        updateAndQueueCommand(\n          groundPolylinePrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\n */\nGroundPolylinePrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\n        \"For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    GroundPolylinePrimitive.initializeTerrainHeights();\n    return;\n  }\n\n  let i;\n\n  const that = this;\n  const primitiveOptions = this._primitiveOptions;\n  if (!defined(this._primitive)) {\n    const geometryInstances = Array.isArray(this.geometryInstances)\n      ? this.geometryInstances\n      : [this.geometryInstances];\n    const geometryInstancesLength = geometryInstances.length;\n    const groundInstances = new Array(geometryInstancesLength);\n\n    let attributes;\n\n    // Check if each instance has a color attribute.\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      attributes = geometryInstances[i].attributes;\n      if (!defined(attributes) || !defined(attributes.color)) {\n        this._hasPerInstanceColors = false;\n        break;\n      }\n    }\n\n    for (i = 0; i < geometryInstancesLength; ++i) {\n      const geometryInstance = geometryInstances[i];\n      attributes = {};\n      const instanceAttributes = geometryInstance.attributes;\n      for (const attributeKey in instanceAttributes) {\n        if (instanceAttributes.hasOwnProperty(attributeKey)) {\n          attributes[attributeKey] = instanceAttributes[attributeKey];\n        }\n      }\n\n      // Automatically create line width attribute if not already given\n      if (!defined(attributes.width)) {\n        attributes.width = new GeometryInstanceAttribute({\n          componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n          componentsPerAttribute: 1.0,\n          value: [geometryInstance.geometry.width],\n        });\n      }\n\n      // Update each geometry for framestate.scene3DOnly = true and projection\n      geometryInstance.geometry._scene3DOnly = frameState.scene3DOnly;\n      GroundPolylineGeometry.setProjectionAndEllipsoid(\n        geometryInstance.geometry,\n        frameState.mapProjection\n      );\n\n      groundInstances[i] = new GeometryInstance({\n        geometry: geometryInstance.geometry,\n        attributes: attributes,\n        id: geometryInstance.id,\n        pickPrimitive: that,\n      });\n    }\n\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n\n    primitiveOptions._createShaderProgramFunction = function (\n      primitive,\n      frameState,\n      appearance\n    ) {\n      createShaderProgram(that, frameState, appearance);\n    };\n    primitiveOptions._createCommandsFunction = function (\n      primitive,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      colorCommands,\n      pickCommands\n    ) {\n      createCommands(\n        that,\n        appearance,\n        material,\n        translucent,\n        colorCommands,\n        pickCommands\n      );\n    };\n    primitiveOptions._updateAndQueueCommandsFunction = function (\n      primitive,\n      frameState,\n      colorCommands,\n      pickCommands,\n      modelMatrix,\n      cull,\n      debugShowBoundingVolume,\n      twoPasses\n    ) {\n      updateAndQueueCommands(\n        that,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume\n      );\n    };\n\n    this._primitive = new Primitive(primitiveOptions);\n    this._primitive.readyPromise.then(function (primitive) {\n      that._ready = true;\n\n      if (that.releaseGeometryInstances) {\n        that.geometryInstances = undefined;\n      }\n\n      const error = primitive._error;\n      if (!defined(error)) {\n        that._readyPromise.resolve(that);\n      } else {\n        that._readyPromise.reject(error);\n      }\n    });\n  }\n\n  if (\n    this.appearance instanceof PolylineColorAppearance &&\n    !this._hasPerInstanceColors\n  ) {\n    throw new DeveloperError(\n      \"All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\"\n    );\n  }\n\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nGroundPolylinePrimitive.prototype.getGeometryInstanceAttributes = function (\n  id\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Checks if the given Scene supports GroundPolylinePrimitives.\n * GroundPolylinePrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {Boolean} Whether or not the current scene supports GroundPolylinePrimitives.\n */\nGroundPolylinePrimitive.isSupported = function (scene) {\n  return scene.frameState.context.depthTexture;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPolylinePrimitive#destroy\n */\nGroundPolylinePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPolylinePrimitive#isDestroyed\n */\nGroundPolylinePrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  this._sp = this._sp && this._sp.destroy();\n\n  // Derived programs, destroyed above if they existed.\n  this._sp2D = undefined;\n  this._spMorph = undefined;\n\n  return destroyObject(this);\n};\nexport default GroundPolylinePrimitive;\n","import ApproximateTerrainHeights from \"../Core/ApproximateTerrainHeights.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defer from \"../Core/defer.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TerrainExaggeration from \"../Core/TerrainExaggeration.js\";\nimport ClassificationPrimitive from \"./ClassificationPrimitive.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowVolumeAppearance from \"./ShadowVolumeAppearance.js\";\n\nconst GroundPrimitiveUniformMap = {\n  u_globeMinimumAltitude: function () {\n    return 55000.0;\n  },\n};\n\n/**\n * A ground primitive represents geometry draped over terrain or 3D Tiles in the {@link Scene}.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Support for the WEBGL_depth_texture extension is required to use GeometryInstances with different PerInstanceColors\n * or materials besides PerInstanceColorAppearance.\n * </p>\n * <p>\n * Textured GroundPrimitives were designed for notional patterns and are not meant for precisely mapping\n * textures to terrain - for that use case, use {@link SingleTileImageryProvider}.\n * </p>\n * <p>\n * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there\n * will be rendering artifacts for some viewing angles.\n * </p>\n * <p>\n * Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.\n * </p>\n *\n * @alias GroundPrimitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to a flat PerInstanceColorAppearance when GeometryInstances have a color attribute.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.\n * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on\n *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.\n *\n * @example\n * // Example 1: Create primitive with a single instance\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : rectangleInstance\n * }));\n *\n * // Example 2: Batch instances\n * const color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.\n * const rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : color\n *   }\n * });\n * const ellipseInstance = new Cesium.GeometryInstance({\n *     geometry : new Cesium.EllipseGeometry({\n *         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),\n *         semiMinorAxis : 300000.0,\n *         semiMajorAxis : 400000.0\n *     }),\n *     id : 'ellipse',\n *     attributes : {\n *         color : color\n *     }\n * });\n * scene.primitives.add(new Cesium.GroundPrimitive({\n *   geometryInstances : [rectangleInstance, ellipseInstance]\n * }));\n *\n * @see Primitive\n * @see ClassificationPrimitive\n * @see GeometryInstance\n * @see Appearance\n */\nfunction GroundPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  let appearance = options.appearance;\n  const geometryInstances = options.geometryInstances;\n  if (!defined(appearance) && defined(geometryInstances)) {\n    const geometryInstancesArray = Array.isArray(geometryInstances)\n      ? geometryInstances\n      : [geometryInstances];\n    const geometryInstanceCount = geometryInstancesArray.length;\n    for (let i = 0; i < geometryInstanceCount; i++) {\n      const attributes = geometryInstancesArray[i].attributes;\n      if (defined(attributes) && defined(attributes.color)) {\n        appearance = new PerInstanceColorAppearance({\n          flat: true,\n        });\n        break;\n      }\n    }\n  }\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = appearance;\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type {Array|GeometryInstance}\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n  /**\n   * Determines whether terrain, 3D Tiles or both will be classified.\n   *\n   * @type {ClassificationType}\n   *\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH\n  );\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the shadow volume for each geometry in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowShadowVolume = defaultValue(\n    options.debugShowShadowVolume,\n    false\n  );\n\n  this._boundingVolumes = [];\n  this._boundingVolumes2D = [];\n\n  this._ready = false;\n  this._readyPromise = defer();\n\n  this._primitive = undefined;\n\n  this._maxHeight = undefined;\n  this._minHeight = undefined;\n\n  this._maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  this._minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n\n  this._boundingSpheresKeys = [];\n  this._boundingSpheres = [];\n\n  this._useFragmentCulling = false;\n  // Used when inserting in an OrderedPrimitiveCollection\n  this._zIndex = undefined;\n\n  const that = this;\n  this._classificationPrimitiveOptions = {\n    geometryInstances: undefined,\n    appearance: undefined,\n    vertexCacheOptimize: defaultValue(options.vertexCacheOptimize, false),\n    interleave: defaultValue(options.interleave, false),\n    releaseGeometryInstances: defaultValue(\n      options.releaseGeometryInstances,\n      true\n    ),\n    allowPicking: defaultValue(options.allowPicking, true),\n    asynchronous: defaultValue(options.asynchronous, true),\n    compressVertices: defaultValue(options.compressVertices, true),\n    _createBoundingVolumeFunction: undefined,\n    _updateAndQueueCommandsFunction: undefined,\n    _pickPrimitive: that,\n    _extruded: true,\n    _uniformMap: GroundPrimitiveUniformMap,\n  };\n}\n\nObject.defineProperties(GroundPrimitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._classificationPrimitiveOptions.vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._classificationPrimitiveOptions.interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._classificationPrimitiveOptions.releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._classificationPrimitiveOptions.allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._classificationPrimitiveOptions.asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._classificationPrimitiveOptions.compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}\n   * is called.\n   *\n   * @memberof GroundPrimitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof GroundPrimitive.prototype\n   * @type {Promise.<GroundPrimitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\n/**\n * Determines if GroundPrimitive rendering is supported.\n *\n * @function\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if GroundPrimitives are supported; otherwise, returns <code>false</code>\n */\nGroundPrimitive.isSupported = ClassificationPrimitive.isSupported;\n\nfunction getComputeMaximumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    const r = ellipsoid.maximumRadius;\n    const delta = r / Math.cos(granularity * 0.5) - r;\n    return primitive._maxHeight + delta;\n  };\n}\n\nfunction getComputeMinimumHeightFunction(primitive) {\n  return function (granularity, ellipsoid) {\n    return primitive._minHeight;\n  };\n}\n\nconst scratchBVCartesianHigh = new Cartesian3();\nconst scratchBVCartesianLow = new Cartesian3();\nconst scratchBVCartesian = new Cartesian3();\nconst scratchBVCartographic = new Cartographic();\nconst scratchBVRectangle = new Rectangle();\n\nfunction getRectangle(frameState, geometry) {\n  const ellipsoid = frameState.mapProjection.ellipsoid;\n\n  if (\n    !defined(geometry.attributes) ||\n    !defined(geometry.attributes.position3DHigh)\n  ) {\n    if (defined(geometry.rectangle)) {\n      return geometry.rectangle;\n    }\n\n    return undefined;\n  }\n\n  const highPositions = geometry.attributes.position3DHigh.values;\n  const lowPositions = geometry.attributes.position3DLow.values;\n  const length = highPositions.length;\n\n  let minLat = Number.POSITIVE_INFINITY;\n  let minLon = Number.POSITIVE_INFINITY;\n  let maxLat = Number.NEGATIVE_INFINITY;\n  let maxLon = Number.NEGATIVE_INFINITY;\n\n  for (let i = 0; i < length; i += 3) {\n    const highPosition = Cartesian3.unpack(\n      highPositions,\n      i,\n      scratchBVCartesianHigh\n    );\n    const lowPosition = Cartesian3.unpack(\n      lowPositions,\n      i,\n      scratchBVCartesianLow\n    );\n\n    const position = Cartesian3.add(\n      highPosition,\n      lowPosition,\n      scratchBVCartesian\n    );\n    const cartographic = ellipsoid.cartesianToCartographic(\n      position,\n      scratchBVCartographic\n    );\n\n    const latitude = cartographic.latitude;\n    const longitude = cartographic.longitude;\n\n    minLat = Math.min(minLat, latitude);\n    minLon = Math.min(minLon, longitude);\n    maxLat = Math.max(maxLat, latitude);\n    maxLon = Math.max(maxLon, longitude);\n  }\n\n  const rectangle = scratchBVRectangle;\n  rectangle.north = maxLat;\n  rectangle.south = minLat;\n  rectangle.east = maxLon;\n  rectangle.west = minLon;\n\n  return rectangle;\n}\n\nfunction setMinMaxTerrainHeights(primitive, rectangle, ellipsoid) {\n  const result = ApproximateTerrainHeights.getMinimumMaximumHeights(\n    rectangle,\n    ellipsoid\n  );\n\n  primitive._minTerrainHeight = result.minimumTerrainHeight;\n  primitive._maxTerrainHeight = result.maximumTerrainHeight;\n}\n\nfunction createBoundingVolume(groundPrimitive, frameState, geometry) {\n  const ellipsoid = frameState.mapProjection.ellipsoid;\n  const rectangle = getRectangle(frameState, geometry);\n\n  const obb = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    groundPrimitive._minHeight,\n    groundPrimitive._maxHeight,\n    ellipsoid\n  );\n  groundPrimitive._boundingVolumes.push(obb);\n\n  if (!frameState.scene3DOnly) {\n    const projection = frameState.mapProjection;\n    const boundingVolume = BoundingSphere.fromRectangleWithHeights2D(\n      rectangle,\n      projection,\n      groundPrimitive._maxHeight,\n      groundPrimitive._minHeight\n    );\n    Cartesian3.fromElements(\n      boundingVolume.center.z,\n      boundingVolume.center.x,\n      boundingVolume.center.y,\n      boundingVolume.center\n    );\n\n    groundPrimitive._boundingVolumes2D.push(boundingVolume);\n  }\n}\n\nfunction boundingVolumeIndex(commandIndex, length) {\n  return Math.floor((commandIndex % length) / 2);\n}\n\nfunction updateAndQueueRenderCommand(\n  groundPrimitive,\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume,\n  debugShowBoundingVolume\n) {\n  // Use derived appearance command for 2D if needed\n  const classificationPrimitive = groundPrimitive._primitive;\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    command.shaderProgram === classificationPrimitive._spColor &&\n    classificationPrimitive._needs2DShader\n  ) {\n    command = command.derivedCommands.appearance2D;\n  }\n\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n  command.debugShowBoundingVolume = debugShowBoundingVolume;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueuePickCommand(\n  groundPrimitive,\n  command,\n  frameState,\n  modelMatrix,\n  cull,\n  boundingVolume\n) {\n  // Use derived pick command for 2D if needed\n  const classificationPrimitive = groundPrimitive._primitive;\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    command.shaderProgram === classificationPrimitive._spPick &&\n    classificationPrimitive._needs2DShader\n  ) {\n    command = command.derivedCommands.pick2D;\n  }\n\n  command.owner = groundPrimitive;\n  command.modelMatrix = modelMatrix;\n  command.boundingVolume = boundingVolume;\n  command.cull = cull;\n\n  frameState.commandList.push(command);\n}\n\nfunction updateAndQueueCommands(\n  groundPrimitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses\n) {\n  let boundingVolumes;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingVolumes = groundPrimitive._boundingVolumes;\n  } else {\n    boundingVolumes = groundPrimitive._boundingVolumes2D;\n  }\n\n  const classificationType = groundPrimitive.classificationType;\n  const queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  const queue3DTilesCommands =\n    classificationType !== ClassificationType.TERRAIN;\n\n  const passes = frameState.passes;\n  const classificationPrimitive = groundPrimitive._primitive;\n\n  let i;\n  let boundingVolume;\n  let command;\n\n  if (passes.render) {\n    const colorLength = colorCommands.length;\n\n    for (i = 0; i < colorLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, colorLength)];\n      if (queueTerrainCommands) {\n        command = colorCommands[i];\n        updateAndQueueRenderCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = colorCommands[i].derivedCommands.tileset;\n        updateAndQueueRenderCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n    }\n\n    if (frameState.invertClassification) {\n      const ignoreShowCommands = classificationPrimitive._commandsIgnoreShow;\n      const ignoreShowCommandsLength = ignoreShowCommands.length;\n      for (i = 0; i < ignoreShowCommandsLength; ++i) {\n        boundingVolume = boundingVolumes[i];\n        command = ignoreShowCommands[i];\n        updateAndQueueRenderCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume,\n          debugShowBoundingVolume\n        );\n      }\n    }\n  }\n\n  if (passes.pick) {\n    const pickLength = pickCommands.length;\n\n    let pickOffsets;\n    if (!groundPrimitive._useFragmentCulling) {\n      // Must be using pick offsets\n      pickOffsets = classificationPrimitive._primitive._pickOffsets;\n    }\n    for (i = 0; i < pickLength; ++i) {\n      boundingVolume = boundingVolumes[boundingVolumeIndex(i, pickLength)];\n      if (!groundPrimitive._useFragmentCulling) {\n        const pickOffset = pickOffsets[boundingVolumeIndex(i, pickLength)];\n        boundingVolume = boundingVolumes[pickOffset.index];\n      }\n      if (queueTerrainCommands) {\n        command = pickCommands[i];\n        updateAndQueuePickCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume\n        );\n      }\n      if (queue3DTilesCommands) {\n        command = pickCommands[i].derivedCommands.tileset;\n        updateAndQueuePickCommand(\n          groundPrimitive,\n          command,\n          frameState,\n          modelMatrix,\n          cull,\n          boundingVolume\n        );\n      }\n    }\n  }\n}\n\n/**\n * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the\n * GroundPrimitive synchronously.\n *\n * @returns {Promise<void>} A promise that will resolve once the terrain heights have been loaded.\n *\n */\nGroundPrimitive.initializeTerrainHeights = function () {\n  return ApproximateTerrainHeights.initialize();\n};\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} For synchronous GroundPrimitive, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n */\nGroundPrimitive.prototype.update = function (frameState) {\n  if (!defined(this._primitive) && !defined(this.geometryInstances)) {\n    return;\n  }\n\n  if (!ApproximateTerrainHeights.initialized) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!this.asynchronous) {\n      throw new DeveloperError(\n        \"For synchronous GroundPrimitives, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    GroundPrimitive.initializeTerrainHeights();\n    return;\n  }\n\n  const that = this;\n  const primitiveOptions = this._classificationPrimitiveOptions;\n\n  if (!defined(this._primitive)) {\n    const ellipsoid = frameState.mapProjection.ellipsoid;\n\n    let instance;\n    let geometry;\n    let instanceType;\n\n    const instances = Array.isArray(this.geometryInstances)\n      ? this.geometryInstances\n      : [this.geometryInstances];\n    const length = instances.length;\n    const groundInstances = new Array(length);\n\n    let i;\n    let rectangle;\n    for (i = 0; i < length; ++i) {\n      instance = instances[i];\n      geometry = instance.geometry;\n      const instanceRectangle = getRectangle(frameState, geometry);\n      if (!defined(rectangle)) {\n        rectangle = Rectangle.clone(instanceRectangle);\n      } else if (defined(instanceRectangle)) {\n        Rectangle.union(rectangle, instanceRectangle, rectangle);\n      }\n\n      const id = instance.id;\n      if (defined(id) && defined(instanceRectangle)) {\n        const boundingSphere = ApproximateTerrainHeights.getBoundingSphere(\n          instanceRectangle,\n          ellipsoid\n        );\n        this._boundingSpheresKeys.push(id);\n        this._boundingSpheres.push(boundingSphere);\n      }\n\n      instanceType = geometry.constructor;\n      if (!defined(instanceType) || !defined(instanceType.createShadowVolume)) {\n        //>>includeStart('debug', pragmas.debug);\n        throw new DeveloperError(\n          \"Not all of the geometry instances have GroundPrimitive support.\"\n        );\n        //>>includeEnd('debug');\n      }\n    }\n\n    // Now compute the min/max heights for the primitive\n    setMinMaxTerrainHeights(this, rectangle, ellipsoid);\n    const exaggeration = frameState.terrainExaggeration;\n    const exaggerationRelativeHeight =\n      frameState.terrainExaggerationRelativeHeight;\n    this._minHeight = TerrainExaggeration.getHeight(\n      this._minTerrainHeight,\n      exaggeration,\n      exaggerationRelativeHeight\n    );\n    this._maxHeight = TerrainExaggeration.getHeight(\n      this._maxTerrainHeight,\n      exaggeration,\n      exaggerationRelativeHeight\n    );\n\n    const useFragmentCulling = GroundPrimitive._supportsMaterials(\n      frameState.context\n    );\n    this._useFragmentCulling = useFragmentCulling;\n\n    if (useFragmentCulling) {\n      // Determine whether to add spherical or planar extent attributes for computing texture coordinates.\n      // This depends on the size of the GeometryInstances.\n      let attributes;\n      let usePlanarExtents = true;\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        rectangle = getRectangle(frameState, geometry);\n        if (ShadowVolumeAppearance.shouldUseSphericalCoordinates(rectangle)) {\n          usePlanarExtents = false;\n          break;\n        }\n      }\n\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n\n        const boundingRectangle = getRectangle(frameState, geometry);\n        const textureCoordinateRotationPoints =\n          geometry.textureCoordinateRotationPoints;\n\n        if (usePlanarExtents) {\n          attributes = ShadowVolumeAppearance.getPlanarTextureCoordinateAttributes(\n            boundingRectangle,\n            textureCoordinateRotationPoints,\n            ellipsoid,\n            frameState.mapProjection,\n            this._maxHeight\n          );\n        } else {\n          attributes = ShadowVolumeAppearance.getSphericalExtentGeometryInstanceAttributes(\n            boundingRectangle,\n            textureCoordinateRotationPoints,\n            ellipsoid,\n            frameState.mapProjection\n          );\n        }\n\n        const instanceAttributes = instance.attributes;\n        for (const attributeKey in instanceAttributes) {\n          if (instanceAttributes.hasOwnProperty(attributeKey)) {\n            attributes[attributeKey] = instanceAttributes[attributeKey];\n          }\n        }\n\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(\n            geometry,\n            getComputeMinimumHeightFunction(this),\n            getComputeMaximumHeightFunction(this)\n          ),\n          attributes: attributes,\n          id: instance.id,\n        });\n      }\n    } else {\n      // ClassificationPrimitive will check if the colors are all the same if it detects lack of fragment culling attributes\n      for (i = 0; i < length; ++i) {\n        instance = instances[i];\n        geometry = instance.geometry;\n        instanceType = geometry.constructor;\n        groundInstances[i] = new GeometryInstance({\n          geometry: instanceType.createShadowVolume(\n            geometry,\n            getComputeMinimumHeightFunction(this),\n            getComputeMaximumHeightFunction(this)\n          ),\n          attributes: instance.attributes,\n          id: instance.id,\n        });\n      }\n    }\n\n    primitiveOptions.geometryInstances = groundInstances;\n    primitiveOptions.appearance = this.appearance;\n\n    primitiveOptions._createBoundingVolumeFunction = function (\n      frameState,\n      geometry\n    ) {\n      createBoundingVolume(that, frameState, geometry);\n    };\n    primitiveOptions._updateAndQueueCommandsFunction = function (\n      primitive,\n      frameState,\n      colorCommands,\n      pickCommands,\n      modelMatrix,\n      cull,\n      debugShowBoundingVolume,\n      twoPasses\n    ) {\n      updateAndQueueCommands(\n        that,\n        frameState,\n        colorCommands,\n        pickCommands,\n        modelMatrix,\n        cull,\n        debugShowBoundingVolume,\n        twoPasses\n      );\n    };\n\n    this._primitive = new ClassificationPrimitive(primitiveOptions);\n    this._primitive.readyPromise.then(function (primitive) {\n      that._ready = true;\n\n      if (that.releaseGeometryInstances) {\n        that.geometryInstances = undefined;\n      }\n\n      const error = primitive._error;\n      if (!defined(error)) {\n        that._readyPromise.resolve(that);\n      } else {\n        that._readyPromise.reject(error);\n      }\n    });\n  }\n\n  this._primitive.appearance = this.appearance;\n  this._primitive.show = this.show;\n  this._primitive.debugShowShadowVolume = this.debugShowShadowVolume;\n  this._primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  this._primitive.update(frameState);\n};\n\n/**\n * @private\n */\nGroundPrimitive.prototype.getBoundingSphere = function (id) {\n  const index = this._boundingSpheresKeys.indexOf(id);\n  if (index !== -1) {\n    return this._boundingSpheres[index];\n  }\n\n  return undefined;\n};\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n */\nGroundPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._primitive)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._primitive.getGeometryInstanceAttributes(id);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see GroundPrimitive#destroy\n */\nGroundPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see GroundPrimitive#isDestroyed\n */\nGroundPrimitive.prototype.destroy = function () {\n  this._primitive = this._primitive && this._primitive.destroy();\n  return destroyObject(this);\n};\n\n/**\n * Exposed for testing.\n *\n * @param {Context} context Rendering context\n * @returns {Boolean} Whether or not the current context supports materials on GroundPrimitives.\n * @private\n */\nGroundPrimitive._supportsMaterials = function (context) {\n  return context.depthTexture;\n};\n\n/**\n * Checks if the given Scene supports materials on GroundPrimitives.\n * Materials on GroundPrimitives require support for the WEBGL_depth_texture extension.\n *\n * @param {Scene} scene The current scene.\n * @returns {Boolean} Whether or not the current scene supports materials on GroundPrimitives.\n */\nGroundPrimitive.supportsMaterials = function (scene) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"scene\", scene);\n  //>>includeEnd('debug');\n\n  return GroundPrimitive._supportsMaterials(scene.frameState.context);\n};\nexport default GroundPrimitive;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataEntity from \"./MetadataEntity.js\";\n\n/**\n * Metadata about a group of {@link Cesium3DTileContent}\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} options.id The ID of the group.\n * @param {Object} options.group The group JSON object.\n * @param {MetadataClass} options.class The class that group metadata conforms to.\n *\n * @alias GroupMetadata\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction GroupMetadata(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const id = options.id;\n  const group = options.group;\n  const metadataClass = options.class;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.group\", group);\n  Check.typeOf.object(\"options.class\", metadataClass);\n  //>>includeEnd('debug');\n\n  const properties = defined(group.properties) ? group.properties : {};\n\n  this._class = metadataClass;\n  this._properties = properties;\n  this._id = id;\n  this._extras = group.extras;\n  this._extensions = group.extensions;\n}\n\nObject.defineProperties(GroupMetadata.prototype, {\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof GroupMetadata.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    get: function () {\n      return this._class;\n    },\n  },\n\n  /**\n   * The ID of the group.\n   *\n   * @memberof GroupMetadata.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof GroupMetadata.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof GroupMetadata.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * Returns whether the group has this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the group has this property.\n * @private\n */\nGroupMetadata.prototype.hasProperty = function (propertyId) {\n  return MetadataEntity.hasProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Returns whether the group has a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {Boolean} Whether the group has a property with the given semantic.\n * @private\n */\nGroupMetadata.prototype.hasPropertyBySemantic = function (semantic) {\n  return MetadataEntity.hasPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nGroupMetadata.prototype.getPropertyIds = function (results) {\n  return MetadataEntity.getPropertyIds(this._properties, this._class, results);\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the group does not have this property.\n * @private\n */\nGroupMetadata.prototype.getProperty = function (propertyId) {\n  return MetadataEntity.getProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nGroupMetadata.prototype.setProperty = function (propertyId, value) {\n  return MetadataEntity.setProperty(\n    propertyId,\n    value,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the group does not have this semantic.\n * @private\n */\nGroupMetadata.prototype.getPropertyBySemantic = function (semantic) {\n  return MetadataEntity.getPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nGroupMetadata.prototype.setPropertyBySemantic = function (semantic, value) {\n  return MetadataEntity.setPropertyBySemantic(\n    semantic,\n    value,\n    this._properties,\n    this._class\n  );\n};\n\nexport default GroupMetadata;\n","/**\n * Represents the position relative to the terrain.\n *\n * @enum {Number}\n */\nconst HeightReference = {\n  /**\n   * The position is absolute.\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * The position is clamped to the terrain.\n   * @type {Number}\n   * @constant\n   */\n  CLAMP_TO_GROUND: 1,\n\n  /**\n   * The position height is the height above the terrain.\n   * @type {Number}\n   * @constant\n   */\n  RELATIVE_TO_GROUND: 2,\n};\nexport default Object.freeze(HeightReference);\n","/**\n * The horizontal location of an origin relative to an object, e.g., a {@link Billboard}\n * or {@link Label}.  For example, setting the horizontal origin to <code>LEFT</code>\n * or <code>RIGHT</code> will display a billboard to the left or right (in screen space)\n * of the anchor position.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />\n * </div>\n *\n * @enum {Number}\n *\n * @see Billboard#horizontalOrigin\n * @see Label#horizontalOrigin\n */\nconst HorizontalOrigin = {\n  /**\n   * The origin is at the horizontal center of the object.\n   *\n   * @type {Number}\n   * @constant\n   */\n  CENTER: 0,\n\n  /**\n   * The origin is on the left side of the object.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LEFT: 1,\n\n  /**\n   * The origin is on the right side of the object.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RIGHT: -1,\n};\nexport default Object.freeze(HorizontalOrigin);\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * Handles parsing of an Instanced 3D Model.\n *\n * @namespace I3dmParser\n * @private\n */\nconst I3dmParser = {};\nI3dmParser._deprecationWarning = deprecationWarning;\n\nconst sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\n/**\n * Parses the contents of a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Instanced3DModel|Instanced 3D Model}.\n *\n * @private\n *\n * @param {ArrayBuffer} arrayBuffer The array buffer containing the i3dm.\n * @param {Number} [byteOffset=0] The byte offset of the beginning of the i3dm in the array buffer.\n * @returns {Object} Returns an object with the glTF format, feature table (binary and json), batch table (binary and json) and glTF parts of the i3dm.\n */\nI3dmParser.parse = function (arrayBuffer, byteOffset) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  const byteStart = defaultValue(byteOffset, 0);\n  byteOffset = byteStart;\n\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  const version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      `Only Instanced 3D Model version 1 is supported. Version ${version} is not.`\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const byteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\n      \"featureTableJsonByteLength is zero, the feature table must be defined.\"\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  const gltfFormat = view.getUint32(byteOffset, true);\n  if (gltfFormat !== 1 && gltfFormat !== 0) {\n    throw new RuntimeError(\n      `Only glTF format 0 (uri) or 1 (embedded) are supported. Format ${gltfFormat} is not.`\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  const featureTableJson = getJsonFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJsonByteLength\n  );\n  byteOffset += featureTableJsonByteLength;\n\n  const featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  let batchTableJson;\n  let batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJsonByteLength\n    );\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength\n      );\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  const gltfByteLength = byteStart + byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new RuntimeError(\"glTF byte length must be greater than 0.\");\n  }\n\n  let gltfView;\n  if (byteOffset % 4 === 0) {\n    gltfView = new Uint8Array(arrayBuffer, byteOffset, gltfByteLength);\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    I3dmParser._deprecationWarning(\n      \"i3dm-glb-unaligned\",\n      \"The embedded glb is not aligned to a 4-byte boundary.\"\n    );\n    gltfView = new Uint8Array(\n      uint8Array.subarray(byteOffset, byteOffset + gltfByteLength)\n    );\n  }\n\n  return {\n    gltfFormat: gltfFormat,\n    featureTableJson: featureTableJson,\n    featureTableBinary: featureTableBinary,\n    batchTableJson: batchTableJson,\n    batchTableBinary: batchTableBinary,\n    gltf: gltfView,\n  };\n};\n\nexport default I3dmParser;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport OctahedralProjectedCubeMap from \"./OctahedralProjectedCubeMap.js\";\n\n/**\n * Properties for managing image-based lighting on tilesets and models.\n * Also manages the necessary resources and textures.\n * <p>\n * If specular environment maps are used, {@link ImageBasedLighting#destroy} must be called\n * when the image-based lighting is no longer needed to clean up GPU resources properly.\n * If a model or tileset creates an instance of ImageBasedLighting, it will handle this.\n * Otherwise, the application is responsible for calling destroy().\n *</p>\n *\n * @alias ImageBasedLighting\n * @constructor\n *\n * @param {Cartesian2} [options.imageBasedLightingFactor=Cartesian2(1.0, 1.0)] Scales diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n * @param {String} [options.specularEnvironmentMaps] A URL to a KTX2 file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n */\nexport default function ImageBasedLighting(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const imageBasedLightingFactor = defined(options.imageBasedLightingFactor)\n    ? Cartesian2.clone(options.imageBasedLightingFactor)\n    : new Cartesian2(1.0, 1.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\n    \"options.imageBasedLightingFactor\",\n    imageBasedLightingFactor\n  );\n  Check.typeOf.number.greaterThanOrEquals(\n    \"options.imageBasedLightingFactor.x\",\n    imageBasedLightingFactor.x,\n    0.0\n  );\n  Check.typeOf.number.lessThanOrEquals(\n    \"options.imageBasedLightingFactor.x\",\n    imageBasedLightingFactor.x,\n    1.0\n  );\n  Check.typeOf.number.greaterThanOrEquals(\n    \"options.imageBasedLightingFactor.y\",\n    imageBasedLightingFactor.y,\n    0.0\n  );\n  Check.typeOf.number.lessThanOrEquals(\n    \"options.imageBasedLightingFactor.y\",\n    imageBasedLightingFactor.y,\n    1.0\n  );\n  //>>includeEnd('debug');\n\n  this._imageBasedLightingFactor = imageBasedLightingFactor;\n\n  const luminanceAtZenith = defaultValue(options.luminanceAtZenith, 0.2);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.luminanceAtZenith\", luminanceAtZenith);\n  //>>includeEnd('debug');\n\n  this._luminanceAtZenith = luminanceAtZenith;\n\n  const sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(sphericalHarmonicCoefficients) &&\n    (!Array.isArray(sphericalHarmonicCoefficients) ||\n      sphericalHarmonicCoefficients.length !== 9)\n  ) {\n    throw new DeveloperError(\n      \"options.sphericalHarmonicCoefficients must be an array of 9 Cartesian3 values.\"\n    );\n  }\n  //>>includeEnd('debug');\n  this._sphericalHarmonicCoefficients = sphericalHarmonicCoefficients;\n\n  // The specular environment map texture is created in update();\n  this._specularEnvironmentMaps = options.specularEnvironmentMaps;\n  this._specularEnvironmentMapAtlas = undefined;\n  this._specularEnvironmentMapAtlasDirty = true;\n  this._specularEnvironmentMapLoaded = false;\n  this._previousSpecularEnvironmentMapLoaded = false;\n\n  this._useDefaultSpecularMaps = false;\n  this._useDefaultSphericalHarmonics = false;\n  this._shouldRegenerateShaders = false;\n\n  // Store the previous frame number to prevent redundant update calls\n  this._previousFrameNumber = undefined;\n\n  // Keeps track of the last values for use during update logic\n  this._previousImageBasedLightingFactor = Cartesian2.clone(\n    imageBasedLightingFactor\n  );\n  this._previousLuminanceAtZenith = luminanceAtZenith;\n  this._previousSphericalHarmonicCoefficients = sphericalHarmonicCoefficients;\n}\n\nObject.defineProperties(ImageBasedLighting.prototype, {\n  /**\n   * Cesium adds lighting from the earth, sky, atmosphere, and star skybox.\n   * This cartesian is used to scale the final diffuse and specular lighting\n   * contribution from those sources to the final color. A value of 0.0 will\n   * disable those light sources.\n   *\n   * @memberof ImageBasedLighting.prototype\n   *\n   * @type {Cartesian2}\n   * @default Cartesian2(1.0, 1.0)\n   */\n  imageBasedLightingFactor: {\n    get: function () {\n      return this._imageBasedLightingFactor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLightingFactor\", value);\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        1.0\n      );\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        1.0\n      );\n      //>>includeEnd('debug');\n      this._previousImageBasedLightingFactor = Cartesian2.clone(\n        this._imageBasedLightingFactor,\n        this._previousImageBasedLightingFactor\n      );\n      this._imageBasedLightingFactor = Cartesian2.clone(\n        value,\n        this._imageBasedLightingFactor\n      );\n    },\n  },\n\n  /**\n   * The sun's luminance at the zenith in kilo candela per meter squared\n   * to use for this model's procedural environment map. This is used when\n   * {@link ImageBasedLighting#specularEnvironmentMaps} and {@link ImageBasedLighting#sphericalHarmonicCoefficients}\n   * are not defined.\n   *\n   * @memberof ImageBasedLighting.prototype\n   *\n   * @type {Number}\n   * @default 0.2\n   */\n  luminanceAtZenith: {\n    get: function () {\n      return this._luminanceAtZenith;\n    },\n    set: function (value) {\n      this._previousLuminanceAtZenith = this._luminanceAtZenith;\n      this._luminanceAtZenith = value;\n    },\n  },\n\n  /**\n   * The third order spherical harmonic coefficients used for the diffuse color of image-based lighting. When <code>undefined</code>, a diffuse irradiance\n   * computed from the atmosphere color is used.\n   * <p>\n   * There are nine <code>Cartesian3</code> coefficients.\n   * The order of the coefficients is: L<sub>0,0</sub>, L<sub>1,-1</sub>, L<sub>1,0</sub>, L<sub>1,1</sub>, L<sub>2,-2</sub>, L<sub>2,-1</sub>, L<sub>2,0</sub>, L<sub>2,1</sub>, L<sub>2,2</sub>\n   * </p>\n   *\n   * These values can be obtained by preprocessing the environment map using the <code>cmgen</code> tool of\n   * {@link https://github.com/google/filament/releases|Google's Filament project}. This will also generate a KTX file that can be\n   * supplied to {@link Model#specularEnvironmentMaps}.\n   *\n   * @memberof ImageBasedLighting.prototype\n   *\n   * @type {Cartesian3[]}\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && (!Array.isArray(value) || value.length !== 9)) {\n        throw new DeveloperError(\n          \"sphericalHarmonicCoefficients must be an array of 9 Cartesian3 values.\"\n        );\n      }\n      //>>includeEnd('debug');\n      this._previousSphericalHarmonicCoefficients = this._sphericalHarmonicCoefficients;\n      this._sphericalHarmonicCoefficients = value;\n    },\n  },\n\n  /**\n   * A URL to a KTX2 file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n   *\n   * @memberof ImageBasedLighting.prototype\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @type {String}\n   * @see ImageBasedLighting#sphericalHarmonicCoefficients\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    },\n    set: function (value) {\n      if (value !== this._specularEnvironmentMaps) {\n        this._specularEnvironmentMapAtlasDirty =\n          this._specularEnvironmentMapAtlasDirty ||\n          value !== this._specularEnvironmentMaps;\n        this._specularEnvironmentMapLoaded = false;\n      }\n      this._specularEnvironmentMaps = value;\n    },\n  },\n\n  /**\n   * Whether or not image-based lighting is enabled.\n   *\n   * @memberof ImageBasedLighting.prototype\n   * @type {Boolean}\n   *\n   * @private\n   */\n  enabled: {\n    get: function () {\n      return (\n        this._imageBasedLightingFactor.x > 0.0 ||\n        this._imageBasedLightingFactor.y > 0.0\n      );\n    },\n  },\n\n  /**\n   * Whether or not the models that use this lighting should regenerate their shaders,\n   * based on the properties and resources have changed.\n   *\n   * @memberof ImageBasedLighting.prototype\n   * @type {Boolean}\n   *\n   * @private\n   */\n  shouldRegenerateShaders: {\n    get: function () {\n      return this._shouldRegenerateShaders;\n    },\n  },\n\n  /**\n   * Whether or not to use the default spherical harmonic coefficients.\n   *\n   * @memberof ImageBasedLighting.prototype\n   * @type {Boolean}\n   *\n   * @private\n   */\n  useDefaultSphericalHarmonics: {\n    get: function () {\n      return this._useDefaultSphericalHarmonics;\n    },\n  },\n\n  /**\n   * Whether or not the image-based lighting settings use spherical harmonic coefficients.\n   *\n   * @memberof ImageBasedLighting.prototype\n   * @type {Boolean}\n   *\n   * @private\n   */\n  useSphericalHarmonicCoefficients: {\n    get: function () {\n      return (\n        defined(this._sphericalHarmonicCoefficients) ||\n        this._useDefaultSphericalHarmonics\n      );\n    },\n  },\n\n  /**\n   * The texture atlas for the specular environment maps.\n   *\n   * @memberof ImageBasedLighting.prototype\n   * @type {OctahedralProjectedCubeMap}\n   *\n   * @private\n   */\n  specularEnvironmentMapAtlas: {\n    get: function () {\n      return this._specularEnvironmentMapAtlas;\n    },\n  },\n\n  /**\n   * Whether or not to use the default specular environment maps.\n   *\n   * @memberof ImageBasedLighting.prototype\n   * @type {Boolean}\n   *\n   * @private\n   */\n  useDefaultSpecularMaps: {\n    get: function () {\n      return this._useDefaultSpecularMaps;\n    },\n  },\n\n  /**\n   * Whether or not the image-based lighting settings use specular environment maps.\n   *\n   * @memberof ImageBasedLighting.prototype\n   * @type {Boolean}\n   *\n   * @private\n   */\n  useSpecularEnvironmentMaps: {\n    get: function () {\n      return (\n        (defined(this._specularEnvironmentMapAtlas) &&\n          this._specularEnvironmentMapAtlas.ready) ||\n        this._useDefaultSpecularMaps\n      );\n    },\n  },\n});\n\nfunction createSpecularEnvironmentMapAtlas(imageBasedLighting, context) {\n  if (!OctahedralProjectedCubeMap.isSupported(context)) {\n    return;\n  }\n\n  imageBasedLighting._specularEnvironmentMapAtlas =\n    imageBasedLighting._specularEnvironmentMapAtlas &&\n    imageBasedLighting._specularEnvironmentMapAtlas.destroy();\n\n  if (defined(imageBasedLighting._specularEnvironmentMaps)) {\n    const atlas = new OctahedralProjectedCubeMap(\n      imageBasedLighting._specularEnvironmentMaps\n    );\n    imageBasedLighting._specularEnvironmentMapAtlas = atlas;\n\n    atlas.readyPromise\n      .then(function () {\n        imageBasedLighting._specularEnvironmentMapLoaded = true;\n      })\n      .catch(function (error) {\n        console.error(`Error loading specularEnvironmentMaps: ${error}`);\n      });\n  }\n\n  // Regenerate shaders so they do not use an environment map.\n  // Will be set to true again if there was a new environment map and it is ready.\n  imageBasedLighting._shouldRegenerateShaders = true;\n}\n\nImageBasedLighting.prototype.update = function (frameState) {\n  if (frameState.frameNumber === this._previousFrameNumber) {\n    return;\n  }\n\n  this._previousFrameNumber = frameState.frameNumber;\n  const context = frameState.context;\n\n  frameState.brdfLutGenerator.update(frameState);\n  this._shouldRegenerateShaders = false;\n\n  const iblFactor = this._imageBasedLightingFactor;\n  const previousIBLFactor = this._previousImageBasedLightingFactor;\n  if (!Cartesian2.equals(iblFactor, previousIBLFactor)) {\n    this._shouldRegenerateShaders =\n      (iblFactor.x > 0.0 && previousIBLFactor.x === 0.0) ||\n      (iblFactor.x === 0.0 && previousIBLFactor.x > 0.0);\n    this._shouldRegenerateShaders =\n      this._shouldRegenerateShaders ||\n      (iblFactor.y > 0.0 && previousIBLFactor.y === 0.0) ||\n      (iblFactor.y === 0.0 && previousIBLFactor.y > 0.0);\n\n    this._previousImageBasedLightingFactor = Cartesian2.clone(\n      this._imageBasedLightingFactor,\n      this._previousImageBasedLightingFactor\n    );\n  }\n\n  if (this._luminanceAtZenith !== this._previousLuminanceAtZenith) {\n    this._shouldRegenerateShaders =\n      this._shouldRegenerateShaders ||\n      defined(this._luminanceAtZenith) !==\n        defined(this._previousLuminanceAtZenith);\n\n    this._previousLuminanceAtZenith = this._luminanceAtZenith;\n  }\n\n  if (\n    this._previousSphericalHarmonicCoefficients !==\n    this._sphericalHarmonicCoefficients\n  ) {\n    this._shouldRegenerateShaders =\n      this._shouldRegenerateShaders ||\n      defined(this._previousSphericalHarmonicCoefficients) !==\n        defined(this._sphericalHarmonicCoefficients);\n\n    this._previousSphericalHarmonicCoefficients = this._sphericalHarmonicCoefficients;\n  }\n\n  this._shouldRegenerateShaders =\n    this._shouldRegenerateShaders ||\n    this._previousSpecularEnvironmentMapLoaded !==\n      this._specularEnvironmentMapLoaded;\n\n  this._previousSpecularEnvironmentMapLoaded = this._specularEnvironmentMapLoaded;\n\n  if (this._specularEnvironmentMapAtlasDirty) {\n    createSpecularEnvironmentMapAtlas(this, context);\n    this._specularEnvironmentMapAtlasDirty = false;\n  }\n\n  if (defined(this._specularEnvironmentMapAtlas)) {\n    this._specularEnvironmentMapAtlas.update(frameState);\n  }\n\n  const recompileWithDefaultAtlas =\n    !defined(this._specularEnvironmentMapAtlas) &&\n    defined(frameState.specularEnvironmentMaps) &&\n    !this._useDefaultSpecularMaps;\n  const recompileWithoutDefaultAtlas =\n    !defined(frameState.specularEnvironmentMaps) &&\n    this._useDefaultSpecularMaps;\n\n  const recompileWithDefaultSHCoeffs =\n    !defined(this._sphericalHarmonicCoefficients) &&\n    defined(frameState.sphericalHarmonicCoefficients) &&\n    !this._useDefaultSphericalHarmonics;\n  const recompileWithoutDefaultSHCoeffs =\n    !defined(frameState.sphericalHarmonicCoefficients) &&\n    this._useDefaultSphericalHarmonics;\n\n  this._shouldRegenerateShaders =\n    this._shouldRegenerateShaders ||\n    recompileWithDefaultAtlas ||\n    recompileWithoutDefaultAtlas ||\n    recompileWithDefaultSHCoeffs ||\n    recompileWithoutDefaultSHCoeffs;\n\n  this._useDefaultSpecularMaps =\n    !defined(this._specularEnvironmentMapAtlas) &&\n    defined(frameState.specularEnvironmentMaps);\n  this._useDefaultSphericalHarmonics =\n    !defined(this._sphericalHarmonicCoefficients) &&\n    defined(frameState.sphericalHarmonicCoefficients);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see ImageBasedLighting#destroy\n * @private\n */\nImageBasedLighting.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * imageBasedLighting = imageBasedLighting && imageBasedLighting.destroy();\n *\n * @see ImageBasedLighting#isDestroyed\n * @private\n */\nImageBasedLighting.prototype.destroy = function () {\n  this._specularEnvironmentMapAtlas =\n    this._specularEnvironmentMapAtlas &&\n    this._specularEnvironmentMapAtlas.destroy();\n  return destroyObject(this);\n};\n","import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport ImageryState from \"./ImageryState.js\";\n\n/**\n * Stores details about a tile of imagery.\n *\n * @alias Imagery\n * @private\n */\nfunction Imagery(imageryLayer, x, y, level, rectangle) {\n  this.imageryLayer = imageryLayer;\n  this.x = x;\n  this.y = y;\n  this.level = level;\n  this.request = undefined;\n\n  if (level !== 0) {\n    const parentX = (x / 2) | 0;\n    const parentY = (y / 2) | 0;\n    const parentLevel = level - 1;\n    this.parent = imageryLayer.getImageryFromCache(\n      parentX,\n      parentY,\n      parentLevel\n    );\n  }\n\n  this.state = ImageryState.UNLOADED;\n  this.imageUrl = undefined;\n  this.image = undefined;\n  this.texture = undefined;\n  this.textureWebMercator = undefined;\n  this.credits = undefined;\n  this.referenceCount = 0;\n\n  if (!defined(rectangle) && imageryLayer.imageryProvider.ready) {\n    const tilingScheme = imageryLayer.imageryProvider.tilingScheme;\n    rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  }\n\n  this.rectangle = rectangle;\n}\nImagery.createPlaceholder = function (imageryLayer) {\n  const result = new Imagery(imageryLayer, 0, 0, 0);\n  result.addReference();\n  result.state = ImageryState.PLACEHOLDER;\n  return result;\n};\n\nImagery.prototype.addReference = function () {\n  ++this.referenceCount;\n};\n\nImagery.prototype.releaseReference = function () {\n  --this.referenceCount;\n\n  if (this.referenceCount === 0) {\n    this.imageryLayer.removeImageryFromCache(this);\n\n    if (defined(this.parent)) {\n      this.parent.releaseReference();\n    }\n\n    if (defined(this.image) && defined(this.image.destroy)) {\n      this.image.destroy();\n    }\n\n    if (defined(this.texture)) {\n      this.texture.destroy();\n    }\n\n    if (\n      defined(this.textureWebMercator) &&\n      this.texture !== this.textureWebMercator\n    ) {\n      this.textureWebMercator.destroy();\n    }\n\n    destroyObject(this);\n\n    return 0;\n  }\n\n  return this.referenceCount;\n};\n\nImagery.prototype.processStateMachine = function (\n  frameState,\n  needGeographicProjection,\n  skipLoading\n) {\n  if (this.state === ImageryState.UNLOADED && !skipLoading) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._requestImagery(this);\n  }\n\n  if (this.state === ImageryState.RECEIVED) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._createTexture(frameState.context, this);\n  }\n\n  // If the imagery is already ready, but we need a geographic version and don't have it yet,\n  // we still need to do the reprojection step. This can happen if the Web Mercator version\n  // is fine initially, but the geographic one is needed later.\n  const needsReprojection =\n    this.state === ImageryState.READY &&\n    needGeographicProjection &&\n    !this.texture;\n\n  if (this.state === ImageryState.TEXTURE_LOADED || needsReprojection) {\n    this.state = ImageryState.TRANSITIONING;\n    this.imageryLayer._reprojectTexture(\n      frameState,\n      this,\n      needGeographicProjection\n    );\n  }\n};\nexport default Imagery;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport GeographicProjection from \"../Core/GeographicProjection.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestState from \"../Core/RequestState.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport TerrainProvider from \"../Core/TerrainProvider.js\";\nimport TileProviderError from \"../Core/TileProviderError.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ComputeCommand from \"../Renderer/ComputeCommand.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport MipmapHint from \"../Renderer/MipmapHint.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ReprojectWebMercatorFS from \"../Shaders/ReprojectWebMercatorFS.js\";\nimport ReprojectWebMercatorVS from \"../Shaders/ReprojectWebMercatorVS.js\";\nimport Imagery from \"./Imagery.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport SplitDirection from \"./SplitDirection.js\";\nimport TileImagery from \"./TileImagery.js\";\n\n/**\n * An imagery layer that displays tiled image data from a single imagery provider\n * on a {@link Globe}.\n *\n * @alias ImageryLayer\n * @constructor\n *\n * @param {ImageryProvider} imageryProvider The imagery provider to use.\n * @param {Object} [options] Object with the following properties:\n * @param {Rectangle} [options.rectangle=imageryProvider.rectangle] The rectangle of the layer.  This rectangle\n *        can limit the visible portion of the imagery provider.\n * @param {Number|Function} [options.alpha=1.0] The alpha blending value of this layer, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile.\n * @param {Number|Function} [options.nightAlpha=1.0] The alpha blending value of this layer on the night side of the globe, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.\n * @param {Number|Function} [options.dayAlpha=1.0] The alpha blending value of this layer on the day side of the globe, from 0.0 to 1.0.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the alpha is required, and it is expected to return\n *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.\n * @param {Number|Function} [options.brightness=1.0] The brightness of this layer.  1.0 uses the unmodified imagery\n *                          color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the brightness is required, and it is expected to return\n *                          the brightness value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.contrast=1.0] The contrast of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the contrast while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the contrast is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.hue=0.0] The hue of this layer.  0.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the hue is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.saturation=1.0] The saturation of this layer.  1.0 uses the unmodified imagery color.\n *                          Less than 1.0 reduces the saturation while greater than 1.0 increases it.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates\n *                          of the imagery tile for which the saturation is required, and it is expected to return\n *                          the contrast value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {Number|Function} [options.gamma=1.0] The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n *                          This can either be a simple number or a function with the signature\n *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the\n *                          current frame state, this layer, and the x, y, and level coordinates of the\n *                          imagery tile for which the gamma is required, and it is expected to return\n *                          the gamma value to use for the tile.  The function is executed for every\n *                          frame and for every tile, so it must be fast.\n * @param {SplitDirection|Function} [options.splitDirection=SplitDirection.NONE] The {@link SplitDirection} split to apply to this layer.\n * @param {TextureMinificationFilter} [options.minificationFilter=TextureMinificationFilter.LINEAR] The\n *                                    texture minification filter to apply to this layer. Possible values\n *                                    are <code>TextureMinificationFilter.LINEAR</code> and\n *                                    <code>TextureMinificationFilter.NEAREST</code>.\n * @param {TextureMagnificationFilter} [options.magnificationFilter=TextureMagnificationFilter.LINEAR] The\n *                                     texture minification filter to apply to this layer. Possible values\n *                                     are <code>TextureMagnificationFilter.LINEAR</code> and\n *                                     <code>TextureMagnificationFilter.NEAREST</code>.\n * @param {Boolean} [options.show=true] True if the layer is shown; otherwise, false.\n * @param {Number} [options.maximumAnisotropy=maximum supported] The maximum anisotropy level to use\n *        for texture filtering.  If this parameter is not specified, the maximum anisotropy supported\n *        by the WebGL stack will be used.  Larger values make the imagery look better in horizon\n *        views.\n * @param {Number} [options.minimumTerrainLevel] The minimum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @param {Number} [options.maximumTerrainLevel] The maximum terrain level-of-detail at which to show this imagery layer,\n *                 or undefined to show it at all levels.  Level zero is the least-detailed level.\n * @param {Rectangle} [options.cutoutRectangle] Cartographic rectangle for cutting out a portion of this ImageryLayer.\n * @param {Color} [options.colorToAlpha] Color to be used as alpha.\n * @param {Number} [options.colorToAlphaThreshold=0.004] Threshold for color-to-alpha.\n */\nfunction ImageryLayer(imageryProvider, options) {\n  this._imageryProvider = imageryProvider;\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The alpha blending value of this layer, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number}\n   * @default 1.0\n   */\n  this.alpha = defaultValue(\n    options.alpha,\n    defaultValue(imageryProvider.defaultAlpha, 1.0)\n  );\n\n  /**\n   * The alpha blending value of this layer on the night side of the globe, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 1.0\n   */\n  this.nightAlpha = defaultValue(\n    options.nightAlpha,\n    defaultValue(imageryProvider.defaultNightAlpha, 1.0)\n  );\n\n  /**\n   * The alpha blending value of this layer on the day side of the globe, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 1.0\n   */\n  this.dayAlpha = defaultValue(\n    options.dayAlpha,\n    defaultValue(imageryProvider.defaultDayAlpha, 1.0)\n  );\n\n  /**\n   * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_BRIGHTNESS}\n   */\n  this.brightness = defaultValue(\n    options.brightness,\n    defaultValue(\n      imageryProvider.defaultBrightness,\n      ImageryLayer.DEFAULT_BRIGHTNESS\n    )\n  );\n\n  /**\n   * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_CONTRAST}\n   */\n  this.contrast = defaultValue(\n    options.contrast,\n    defaultValue(imageryProvider.defaultContrast, ImageryLayer.DEFAULT_CONTRAST)\n  );\n\n  /**\n   * The hue of this layer in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_HUE}\n   */\n  this.hue = defaultValue(\n    options.hue,\n    defaultValue(imageryProvider.defaultHue, ImageryLayer.DEFAULT_HUE)\n  );\n\n  /**\n   * The saturation of this layer. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_SATURATION}\n   */\n  this.saturation = defaultValue(\n    options.saturation,\n    defaultValue(\n      imageryProvider.defaultSaturation,\n      ImageryLayer.DEFAULT_SATURATION\n    )\n  );\n\n  /**\n   * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number}\n   * @default {@link ImageryLayer.DEFAULT_GAMMA}\n   */\n  this.gamma = defaultValue(\n    options.gamma,\n    defaultValue(imageryProvider.defaultGamma, ImageryLayer.DEFAULT_GAMMA)\n  );\n\n  /**\n   * The {@link SplitDirection} to apply to this layer.\n   *\n   * @type {SplitDirection}\n   * @default {@link ImageryLayer.DEFAULT_SPLIT}\n   */\n  this.splitDirection = defaultValue(\n    options.splitDirection,\n    defaultValue(imageryProvider.defaultSplit, ImageryLayer.DEFAULT_SPLIT)\n  );\n\n  /**\n   * The {@link TextureMinificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMinificationFilter.LINEAR} (the default)\n   * and {@link TextureMinificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMinificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MINIFICATION_FILTER}\n   */\n  this.minificationFilter = defaultValue(\n    options.minificationFilter,\n    defaultValue(\n      imageryProvider.defaultMinificationFilter,\n      ImageryLayer.DEFAULT_MINIFICATION_FILTER\n    )\n  );\n\n  /**\n   * The {@link TextureMagnificationFilter} to apply to this layer.\n   * Possible values are {@link TextureMagnificationFilter.LINEAR} (the default)\n   * and {@link TextureMagnificationFilter.NEAREST}.\n   *\n   * To take effect, this property must be set immediately after adding the imagery layer.\n   * Once a texture is loaded it won't be possible to change the texture filter used.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default {@link ImageryLayer.DEFAULT_MAGNIFICATION_FILTER}\n   */\n  this.magnificationFilter = defaultValue(\n    options.magnificationFilter,\n    defaultValue(\n      imageryProvider.defaultMagnificationFilter,\n      ImageryLayer.DEFAULT_MAGNIFICATION_FILTER\n    )\n  );\n\n  /**\n   * Determines if this layer is shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  this._minimumTerrainLevel = options.minimumTerrainLevel;\n  this._maximumTerrainLevel = options.maximumTerrainLevel;\n\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._maximumAnisotropy = options.maximumAnisotropy;\n\n  this._imageryCache = {};\n\n  this._skeletonPlaceholder = new TileImagery(Imagery.createPlaceholder(this));\n\n  // The value of the show property on the last update.\n  this._show = true;\n\n  // The index of this layer in the ImageryLayerCollection.\n  this._layerIndex = -1;\n\n  // true if this is the base (lowest shown) layer.\n  this._isBaseLayer = false;\n\n  this._requestImageError = undefined;\n\n  this._reprojectComputeCommands = [];\n\n  /**\n   * Rectangle cutout in this layer of imagery.\n   *\n   * @type {Rectangle}\n   */\n  this.cutoutRectangle = options.cutoutRectangle;\n\n  /**\n   * Color value that should be set to transparent.\n   *\n   * @type {Color}\n   */\n  this.colorToAlpha = options.colorToAlpha;\n\n  /**\n   * Normalized (0-1) threshold for color-to-alpha.\n   *\n   * @type {Number}\n   */\n  this.colorToAlphaThreshold = defaultValue(\n    options.colorToAlphaThreshold,\n    ImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD\n  );\n}\n\nObject.defineProperties(ImageryLayer.prototype, {\n  /**\n   * Gets the imagery provider for this layer.\n   * @memberof ImageryLayer.prototype\n   * @type {ImageryProvider}\n   * @readonly\n   */\n  imageryProvider: {\n    get: function () {\n      return this._imageryProvider;\n    },\n  },\n\n  /**\n   * Gets the rectangle of this layer.  If this rectangle is smaller than the rectangle of the\n   * {@link ImageryProvider}, only a portion of the imagery provider is shown.\n   * @memberof ImageryLayer.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n});\n\n/**\n * This value is used as the default brightness for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the brightness of the imagery.\n * @type {Number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_BRIGHTNESS = 1.0;\n/**\n * This value is used as the default contrast for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the contrast of the imagery.\n * @type {Number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_CONTRAST = 1.0;\n/**\n * This value is used as the default hue for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the hue of the imagery.\n * @type {Number}\n * @default 0.0\n */\nImageryLayer.DEFAULT_HUE = 0.0;\n/**\n * This value is used as the default saturation for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the saturation of the imagery.\n * @type {Number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_SATURATION = 1.0;\n/**\n * This value is used as the default gamma for the imagery layer if one is not provided during construction\n * or by the imagery provider. This value does not modify the gamma of the imagery.\n * @type {Number}\n * @default 1.0\n */\nImageryLayer.DEFAULT_GAMMA = 1.0;\n\n/**\n * This value is used as the default split for the imagery layer if one is not provided during construction\n * or by the imagery provider.\n * @type {SplitDirection}\n * @default SplitDirection.NONE\n */\nImageryLayer.DEFAULT_SPLIT = SplitDirection.NONE;\n\n/**\n * This value is used as the default texture minification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMinificationFilter}\n * @default TextureMinificationFilter.LINEAR\n */\nImageryLayer.DEFAULT_MINIFICATION_FILTER = TextureMinificationFilter.LINEAR;\n\n/**\n * This value is used as the default texture magnification filter for the imagery layer if one is not provided\n * during construction or by the imagery provider.\n * @type {TextureMagnificationFilter}\n * @default TextureMagnificationFilter.LINEAR\n */\nImageryLayer.DEFAULT_MAGNIFICATION_FILTER = TextureMagnificationFilter.LINEAR;\n\n/**\n * This value is used as the default threshold for color-to-alpha if one is not provided\n * during construction or by the imagery provider.\n * @type {Number}\n * @default 0.004\n */\nImageryLayer.DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD = 0.004;\n\n/**\n * Gets a value indicating whether this layer is the base layer in the\n * {@link ImageryLayerCollection}.  The base layer is the one that underlies all\n * others.  It is special in that it is treated as if it has global rectangle, even if\n * it actually does not, by stretching the texels at the edges over the entire\n * globe.\n *\n * @returns {Boolean} true if this is the base layer; otherwise, false.\n */\nImageryLayer.prototype.isBaseLayer = function () {\n  return this._isBaseLayer;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayer#destroy\n */\nImageryLayer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * imageryLayer = imageryLayer && imageryLayer.destroy();\n *\n * @see ImageryLayer#isDestroyed\n */\nImageryLayer.prototype.destroy = function () {\n  return destroyObject(this);\n};\n\nconst imageryBoundsScratch = new Rectangle();\nconst tileImageryBoundsScratch = new Rectangle();\nconst clippedRectangleScratch = new Rectangle();\nconst terrainRectangleScratch = new Rectangle();\n\n/**\n * Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,\n * producing the overall bounds of imagery that can be produced by this layer.\n *\n * @returns {Promise.<Rectangle>} A promise to a rectangle which defines the overall bounds of imagery that can be produced by this layer.\n *\n * @example\n * // Zoom to an imagery layer.\n * imageryLayer.getViewableRectangle().then(function (rectangle) {\n *     return camera.flyTo({\n *         destination: rectangle\n *     });\n * });\n */\nImageryLayer.prototype.getViewableRectangle = function () {\n  const imageryProvider = this._imageryProvider;\n  const rectangle = this._rectangle;\n  return imageryProvider.readyPromise.then(function () {\n    return Rectangle.intersection(imageryProvider.rectangle, rectangle);\n  });\n};\n\n/**\n * Create skeletons for the imagery tiles that partially or completely overlap a given terrain\n * tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TerrainProvider} terrainProvider The terrain provider associated with the terrain tile.\n * @param {Number} insertionPoint The position to insert new skeletons before in the tile's imagery list.\n * @returns {Boolean} true if this layer overlaps any portion of the terrain tile; otherwise, false.\n */\nImageryLayer.prototype._createTileImagerySkeletons = function (\n  tile,\n  terrainProvider,\n  insertionPoint\n) {\n  const surfaceTile = tile.data;\n\n  if (\n    defined(this._minimumTerrainLevel) &&\n    tile.level < this._minimumTerrainLevel\n  ) {\n    return false;\n  }\n  if (\n    defined(this._maximumTerrainLevel) &&\n    tile.level > this._maximumTerrainLevel\n  ) {\n    return false;\n  }\n\n  const imageryProvider = this._imageryProvider;\n\n  if (!defined(insertionPoint)) {\n    insertionPoint = surfaceTile.imagery.length;\n  }\n\n  if (!imageryProvider.ready) {\n    // The imagery provider is not ready, so we can't create skeletons, yet.\n    // Instead, add a placeholder so that we'll know to create\n    // the skeletons once the provider is ready.\n    this._skeletonPlaceholder.loadingImagery.addReference();\n    surfaceTile.imagery.splice(insertionPoint, 0, this._skeletonPlaceholder);\n    return true;\n  }\n\n  // Use Web Mercator for our texture coordinate computations if this imagery layer uses\n  // that projection and the terrain tile falls entirely inside the valid bounds of the\n  // projection.\n  const useWebMercatorT =\n    imageryProvider.tilingScheme.projection instanceof WebMercatorProjection &&\n    tile.rectangle.north < WebMercatorProjection.MaximumLatitude &&\n    tile.rectangle.south > -WebMercatorProjection.MaximumLatitude;\n\n  // Compute the rectangle of the imagery from this imageryProvider that overlaps\n  // the geometry tile.  The ImageryProvider and ImageryLayer both have the\n  // opportunity to constrain the rectangle.  The imagery TilingScheme's rectangle\n  // always fully contains the ImageryProvider's rectangle.\n  const imageryBounds = Rectangle.intersection(\n    imageryProvider.rectangle,\n    this._rectangle,\n    imageryBoundsScratch\n  );\n  let rectangle = Rectangle.intersection(\n    tile.rectangle,\n    imageryBounds,\n    tileImageryBoundsScratch\n  );\n\n  if (!defined(rectangle)) {\n    // There is no overlap between this terrain tile and this imagery\n    // provider.  Unless this is the base layer, no skeletons need to be created.\n    // We stretch texels at the edge of the base layer over the entire globe.\n    if (!this.isBaseLayer()) {\n      return false;\n    }\n\n    const baseImageryRectangle = imageryBounds;\n    const baseTerrainRectangle = tile.rectangle;\n    rectangle = tileImageryBoundsScratch;\n\n    if (baseTerrainRectangle.south >= baseImageryRectangle.north) {\n      rectangle.north = rectangle.south = baseImageryRectangle.north;\n    } else if (baseTerrainRectangle.north <= baseImageryRectangle.south) {\n      rectangle.north = rectangle.south = baseImageryRectangle.south;\n    } else {\n      rectangle.south = Math.max(\n        baseTerrainRectangle.south,\n        baseImageryRectangle.south\n      );\n      rectangle.north = Math.min(\n        baseTerrainRectangle.north,\n        baseImageryRectangle.north\n      );\n    }\n\n    if (baseTerrainRectangle.west >= baseImageryRectangle.east) {\n      rectangle.west = rectangle.east = baseImageryRectangle.east;\n    } else if (baseTerrainRectangle.east <= baseImageryRectangle.west) {\n      rectangle.west = rectangle.east = baseImageryRectangle.west;\n    } else {\n      rectangle.west = Math.max(\n        baseTerrainRectangle.west,\n        baseImageryRectangle.west\n      );\n      rectangle.east = Math.min(\n        baseTerrainRectangle.east,\n        baseImageryRectangle.east\n      );\n    }\n  }\n\n  let latitudeClosestToEquator = 0.0;\n  if (rectangle.south > 0.0) {\n    latitudeClosestToEquator = rectangle.south;\n  } else if (rectangle.north < 0.0) {\n    latitudeClosestToEquator = rectangle.north;\n  }\n\n  // Compute the required level in the imagery tiling scheme.\n  // The errorRatio should really be imagerySSE / terrainSSE rather than this hard-coded value.\n  // But first we need configurable imagery SSE and we need the rendering to be able to handle more\n  // images attached to a terrain tile than there are available texture units.  So that's for the future.\n  const errorRatio = 1.0;\n  const targetGeometricError =\n    errorRatio * terrainProvider.getLevelMaximumGeometricError(tile.level);\n  let imageryLevel = getLevelWithMaximumTexelSpacing(\n    this,\n    targetGeometricError,\n    latitudeClosestToEquator\n  );\n  imageryLevel = Math.max(0, imageryLevel);\n  const maximumLevel = imageryProvider.maximumLevel;\n  if (imageryLevel > maximumLevel) {\n    imageryLevel = maximumLevel;\n  }\n\n  if (defined(imageryProvider.minimumLevel)) {\n    const minimumLevel = imageryProvider.minimumLevel;\n    if (imageryLevel < minimumLevel) {\n      imageryLevel = minimumLevel;\n    }\n  }\n\n  const imageryTilingScheme = imageryProvider.tilingScheme;\n  const northwestTileCoordinates = imageryTilingScheme.positionToTileXY(\n    Rectangle.northwest(rectangle),\n    imageryLevel\n  );\n  const southeastTileCoordinates = imageryTilingScheme.positionToTileXY(\n    Rectangle.southeast(rectangle),\n    imageryLevel\n  );\n\n  // If the southeast corner of the rectangle lies very close to the north or west side\n  // of the southeast tile, we don't actually need the southernmost or easternmost\n  // tiles.\n  // Similarly, if the northwest corner of the rectangle lies very close to the south or east side\n  // of the northwest tile, we don't actually need the northernmost or westernmost tiles.\n\n  // We define \"very close\" as being within 1/512 of the width of the tile.\n  let veryCloseX = tile.rectangle.width / 512.0;\n  let veryCloseY = tile.rectangle.height / 512.0;\n\n  const northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(\n    northwestTileCoordinates.x,\n    northwestTileCoordinates.y,\n    imageryLevel\n  );\n  if (\n    Math.abs(northwestTileRectangle.south - tile.rectangle.north) <\n      veryCloseY &&\n    northwestTileCoordinates.y < southeastTileCoordinates.y\n  ) {\n    ++northwestTileCoordinates.y;\n  }\n  if (\n    Math.abs(northwestTileRectangle.east - tile.rectangle.west) < veryCloseX &&\n    northwestTileCoordinates.x < southeastTileCoordinates.x\n  ) {\n    ++northwestTileCoordinates.x;\n  }\n\n  const southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(\n    southeastTileCoordinates.x,\n    southeastTileCoordinates.y,\n    imageryLevel\n  );\n  if (\n    Math.abs(southeastTileRectangle.north - tile.rectangle.south) <\n      veryCloseY &&\n    southeastTileCoordinates.y > northwestTileCoordinates.y\n  ) {\n    --southeastTileCoordinates.y;\n  }\n  if (\n    Math.abs(southeastTileRectangle.west - tile.rectangle.east) < veryCloseX &&\n    southeastTileCoordinates.x > northwestTileCoordinates.x\n  ) {\n    --southeastTileCoordinates.x;\n  }\n\n  // Create TileImagery instances for each imagery tile overlapping this terrain tile.\n  // We need to do all texture coordinate computations in the imagery tile's tiling scheme.\n\n  const terrainRectangle = Rectangle.clone(\n    tile.rectangle,\n    terrainRectangleScratch\n  );\n  let imageryRectangle = imageryTilingScheme.tileXYToRectangle(\n    northwestTileCoordinates.x,\n    northwestTileCoordinates.y,\n    imageryLevel\n  );\n  let clippedImageryRectangle = Rectangle.intersection(\n    imageryRectangle,\n    imageryBounds,\n    clippedRectangleScratch\n  );\n\n  let imageryTileXYToRectangle;\n  if (useWebMercatorT) {\n    imageryTilingScheme.rectangleToNativeRectangle(\n      terrainRectangle,\n      terrainRectangle\n    );\n    imageryTilingScheme.rectangleToNativeRectangle(\n      imageryRectangle,\n      imageryRectangle\n    );\n    imageryTilingScheme.rectangleToNativeRectangle(\n      clippedImageryRectangle,\n      clippedImageryRectangle\n    );\n    imageryTilingScheme.rectangleToNativeRectangle(\n      imageryBounds,\n      imageryBounds\n    );\n    imageryTileXYToRectangle = imageryTilingScheme.tileXYToNativeRectangle.bind(\n      imageryTilingScheme\n    );\n    veryCloseX = terrainRectangle.width / 512.0;\n    veryCloseY = terrainRectangle.height / 512.0;\n  } else {\n    imageryTileXYToRectangle = imageryTilingScheme.tileXYToRectangle.bind(\n      imageryTilingScheme\n    );\n  }\n\n  let minU;\n  let maxU = 0.0;\n\n  let minV = 1.0;\n  let maxV;\n\n  // If this is the northern-most or western-most tile in the imagery tiling scheme,\n  // it may not start at the northern or western edge of the terrain tile.\n  // Calculate where it does start.\n  if (\n    !this.isBaseLayer() &&\n    Math.abs(clippedImageryRectangle.west - terrainRectangle.west) >= veryCloseX\n  ) {\n    maxU = Math.min(\n      1.0,\n      (clippedImageryRectangle.west - terrainRectangle.west) /\n        terrainRectangle.width\n    );\n  }\n\n  if (\n    !this.isBaseLayer() &&\n    Math.abs(clippedImageryRectangle.north - terrainRectangle.north) >=\n      veryCloseY\n  ) {\n    minV = Math.max(\n      0.0,\n      (clippedImageryRectangle.north - terrainRectangle.south) /\n        terrainRectangle.height\n    );\n  }\n\n  const initialMinV = minV;\n\n  for (\n    let i = northwestTileCoordinates.x;\n    i <= southeastTileCoordinates.x;\n    i++\n  ) {\n    minU = maxU;\n\n    imageryRectangle = imageryTileXYToRectangle(\n      i,\n      northwestTileCoordinates.y,\n      imageryLevel\n    );\n    clippedImageryRectangle = Rectangle.simpleIntersection(\n      imageryRectangle,\n      imageryBounds,\n      clippedRectangleScratch\n    );\n\n    if (!defined(clippedImageryRectangle)) {\n      continue;\n    }\n\n    maxU = Math.min(\n      1.0,\n      (clippedImageryRectangle.east - terrainRectangle.west) /\n        terrainRectangle.width\n    );\n\n    // If this is the eastern-most imagery tile mapped to this terrain tile,\n    // and there are more imagery tiles to the east of this one, the maxU\n    // should be 1.0 to make sure rounding errors don't make the last\n    // image fall shy of the edge of the terrain tile.\n    if (\n      i === southeastTileCoordinates.x &&\n      (this.isBaseLayer() ||\n        Math.abs(clippedImageryRectangle.east - terrainRectangle.east) <\n          veryCloseX)\n    ) {\n      maxU = 1.0;\n    }\n\n    minV = initialMinV;\n\n    for (\n      let j = northwestTileCoordinates.y;\n      j <= southeastTileCoordinates.y;\n      j++\n    ) {\n      maxV = minV;\n\n      imageryRectangle = imageryTileXYToRectangle(i, j, imageryLevel);\n      clippedImageryRectangle = Rectangle.simpleIntersection(\n        imageryRectangle,\n        imageryBounds,\n        clippedRectangleScratch\n      );\n\n      if (!defined(clippedImageryRectangle)) {\n        continue;\n      }\n\n      minV = Math.max(\n        0.0,\n        (clippedImageryRectangle.south - terrainRectangle.south) /\n          terrainRectangle.height\n      );\n\n      // If this is the southern-most imagery tile mapped to this terrain tile,\n      // and there are more imagery tiles to the south of this one, the minV\n      // should be 0.0 to make sure rounding errors don't make the last\n      // image fall shy of the edge of the terrain tile.\n      if (\n        j === southeastTileCoordinates.y &&\n        (this.isBaseLayer() ||\n          Math.abs(clippedImageryRectangle.south - terrainRectangle.south) <\n            veryCloseY)\n      ) {\n        minV = 0.0;\n      }\n\n      const texCoordsRectangle = new Cartesian4(minU, minV, maxU, maxV);\n      const imagery = this.getImageryFromCache(i, j, imageryLevel);\n      surfaceTile.imagery.splice(\n        insertionPoint,\n        0,\n        new TileImagery(imagery, texCoordsRectangle, useWebMercatorT)\n      );\n      ++insertionPoint;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Calculate the translation and scale for a particular {@link TileImagery} attached to a\n * particular terrain tile.\n *\n * @private\n *\n * @param {Tile} tile The terrain tile.\n * @param {TileImagery} tileImagery The imagery tile mapping.\n * @returns {Cartesian4} The translation and scale where X and Y are the translation and Z and W\n *          are the scale.\n */\nImageryLayer.prototype._calculateTextureTranslationAndScale = function (\n  tile,\n  tileImagery\n) {\n  let imageryRectangle = tileImagery.readyImagery.rectangle;\n  let terrainRectangle = tile.rectangle;\n\n  if (tileImagery.useWebMercatorT) {\n    const tilingScheme =\n      tileImagery.readyImagery.imageryLayer.imageryProvider.tilingScheme;\n    imageryRectangle = tilingScheme.rectangleToNativeRectangle(\n      imageryRectangle,\n      imageryBoundsScratch\n    );\n    terrainRectangle = tilingScheme.rectangleToNativeRectangle(\n      terrainRectangle,\n      terrainRectangleScratch\n    );\n  }\n\n  const terrainWidth = terrainRectangle.width;\n  const terrainHeight = terrainRectangle.height;\n\n  const scaleX = terrainWidth / imageryRectangle.width;\n  const scaleY = terrainHeight / imageryRectangle.height;\n  return new Cartesian4(\n    (scaleX * (terrainRectangle.west - imageryRectangle.west)) / terrainWidth,\n    (scaleY * (terrainRectangle.south - imageryRectangle.south)) /\n      terrainHeight,\n    scaleX,\n    scaleY\n  );\n};\n\n/**\n * Request a particular piece of imagery from the imagery provider.  This method handles raising an\n * error event if the request fails, and retrying the request if necessary.\n *\n * @private\n *\n * @param {Imagery} imagery The imagery to request.\n */\nImageryLayer.prototype._requestImagery = function (imagery) {\n  const imageryProvider = this._imageryProvider;\n\n  const that = this;\n\n  function success(image) {\n    if (!defined(image)) {\n      return failure();\n    }\n\n    imagery.image = image;\n    imagery.state = ImageryState.RECEIVED;\n    imagery.request = undefined;\n\n    TileProviderError.handleSuccess(that._requestImageError);\n  }\n\n  function failure(e) {\n    if (imagery.request.state === RequestState.CANCELLED) {\n      // Cancelled due to low priority - try again later.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    }\n\n    // Initially assume failure.  handleError may retry, in which case the state will\n    // change to TRANSITIONING.\n    imagery.state = ImageryState.FAILED;\n    imagery.request = undefined;\n\n    const message = `Failed to obtain image tile X: ${imagery.x} Y: ${imagery.y} Level: ${imagery.level}.`;\n    that._requestImageError = TileProviderError.handleError(\n      that._requestImageError,\n      imageryProvider,\n      imageryProvider.errorEvent,\n      message,\n      imagery.x,\n      imagery.y,\n      imagery.level,\n      doRequest,\n      e\n    );\n  }\n\n  function doRequest() {\n    const request = new Request({\n      throttle: false,\n      throttleByServer: true,\n      type: RequestType.IMAGERY,\n    });\n    imagery.request = request;\n    imagery.state = ImageryState.TRANSITIONING;\n    const imagePromise = imageryProvider.requestImage(\n      imagery.x,\n      imagery.y,\n      imagery.level,\n      request\n    );\n\n    if (!defined(imagePromise)) {\n      // Too many parallel requests, so postpone loading tile.\n      imagery.state = ImageryState.UNLOADED;\n      imagery.request = undefined;\n      return;\n    }\n\n    if (defined(imageryProvider.getTileCredits)) {\n      imagery.credits = imageryProvider.getTileCredits(\n        imagery.x,\n        imagery.y,\n        imagery.level\n      );\n    }\n\n    imagePromise\n      .then(function (image) {\n        success(image);\n      })\n      .catch(function (e) {\n        failure(e);\n      });\n  }\n\n  doRequest();\n};\n\nImageryLayer.prototype._createTextureWebGL = function (context, imagery) {\n  const sampler = new Sampler({\n    minificationFilter: this.minificationFilter,\n    magnificationFilter: this.magnificationFilter,\n  });\n\n  const image = imagery.image;\n\n  if (defined(image.internalFormat)) {\n    return new Texture({\n      context: context,\n      pixelFormat: image.internalFormat,\n      width: image.width,\n      height: image.height,\n      source: {\n        arrayBufferView: image.bufferView,\n      },\n      sampler: sampler,\n    });\n  }\n  return new Texture({\n    context: context,\n    source: image,\n    pixelFormat: this._imageryProvider.hasAlphaChannel\n      ? PixelFormat.RGBA\n      : PixelFormat.RGB,\n    sampler: sampler,\n  });\n};\n\n/**\n * Create a WebGL texture for a given {@link Imagery} instance.\n *\n * @private\n *\n * @param {Context} context The rendered context to use to create textures.\n * @param {Imagery} imagery The imagery for which to create a texture.\n */\nImageryLayer.prototype._createTexture = function (context, imagery) {\n  const imageryProvider = this._imageryProvider;\n  const image = imagery.image;\n\n  // If this imagery provider has a discard policy, use it to check if this\n  // image should be discarded.\n  if (defined(imageryProvider.tileDiscardPolicy)) {\n    const discardPolicy = imageryProvider.tileDiscardPolicy;\n    if (defined(discardPolicy)) {\n      // If the discard policy is not ready yet, transition back to the\n      // RECEIVED state and we'll try again next time.\n      if (!discardPolicy.isReady()) {\n        imagery.state = ImageryState.RECEIVED;\n        return;\n      }\n\n      // Mark discarded imagery tiles invalid.  Parent imagery will be used instead.\n      if (discardPolicy.shouldDiscardImage(image)) {\n        imagery.state = ImageryState.INVALID;\n        return;\n      }\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    this.minificationFilter !== TextureMinificationFilter.NEAREST &&\n    this.minificationFilter !== TextureMinificationFilter.LINEAR\n  ) {\n    throw new DeveloperError(\n      \"ImageryLayer minification filter must be NEAREST or LINEAR\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Imagery does not need to be discarded, so upload it to WebGL.\n  const texture = this._createTextureWebGL(context, imagery);\n\n  if (\n    imageryProvider.tilingScheme.projection instanceof WebMercatorProjection\n  ) {\n    imagery.textureWebMercator = texture;\n  } else {\n    imagery.texture = texture;\n  }\n  imagery.image = undefined;\n  imagery.state = ImageryState.TEXTURE_LOADED;\n};\n\nfunction getSamplerKey(\n  minificationFilter,\n  magnificationFilter,\n  maximumAnisotropy\n) {\n  return `${minificationFilter}:${magnificationFilter}:${maximumAnisotropy}`;\n}\n\nImageryLayer.prototype._finalizeReprojectTexture = function (context, texture) {\n  let minificationFilter = this.minificationFilter;\n  const magnificationFilter = this.magnificationFilter;\n  const usesLinearTextureFilter =\n    minificationFilter === TextureMinificationFilter.LINEAR &&\n    magnificationFilter === TextureMagnificationFilter.LINEAR;\n  // Use mipmaps if this texture has power-of-two dimensions.\n  // In addition, mipmaps are only generated if the texture filters are both LINEAR.\n  if (\n    usesLinearTextureFilter &&\n    !PixelFormat.isCompressedFormat(texture.pixelFormat) &&\n    CesiumMath.isPowerOfTwo(texture.width) &&\n    CesiumMath.isPowerOfTwo(texture.height)\n  ) {\n    minificationFilter = TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;\n    const maximumSupportedAnisotropy =\n      ContextLimits.maximumTextureFilterAnisotropy;\n    const maximumAnisotropy = Math.min(\n      maximumSupportedAnisotropy,\n      defaultValue(this._maximumAnisotropy, maximumSupportedAnisotropy)\n    );\n    const mipmapSamplerKey = getSamplerKey(\n      minificationFilter,\n      magnificationFilter,\n      maximumAnisotropy\n    );\n    let mipmapSamplers = context.cache.imageryLayerMipmapSamplers;\n    if (!defined(mipmapSamplers)) {\n      mipmapSamplers = {};\n      context.cache.imageryLayerMipmapSamplers = mipmapSamplers;\n    }\n    let mipmapSampler = mipmapSamplers[mipmapSamplerKey];\n    if (!defined(mipmapSampler)) {\n      mipmapSampler = mipmapSamplers[mipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter,\n        maximumAnisotropy: maximumAnisotropy,\n      });\n    }\n    texture.generateMipmap(MipmapHint.NICEST);\n    texture.sampler = mipmapSampler;\n  } else {\n    const nonMipmapSamplerKey = getSamplerKey(\n      minificationFilter,\n      magnificationFilter,\n      0\n    );\n    let nonMipmapSamplers = context.cache.imageryLayerNonMipmapSamplers;\n    if (!defined(nonMipmapSamplers)) {\n      nonMipmapSamplers = {};\n      context.cache.imageryLayerNonMipmapSamplers = nonMipmapSamplers;\n    }\n    let nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey];\n    if (!defined(nonMipmapSampler)) {\n      nonMipmapSampler = nonMipmapSamplers[nonMipmapSamplerKey] = new Sampler({\n        wrapS: TextureWrap.CLAMP_TO_EDGE,\n        wrapT: TextureWrap.CLAMP_TO_EDGE,\n        minificationFilter: minificationFilter,\n        magnificationFilter: magnificationFilter,\n      });\n    }\n    texture.sampler = nonMipmapSampler;\n  }\n};\n\n/**\n * Enqueues a command re-projecting a texture to a {@link GeographicProjection} on the next update, if necessary, and generate\n * mipmaps for the geographic texture.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n * @param {Imagery} imagery The imagery instance to reproject.\n * @param {Boolean} [needGeographicProjection=true] True to reproject to geographic, or false if Web Mercator is fine.\n */\nImageryLayer.prototype._reprojectTexture = function (\n  frameState,\n  imagery,\n  needGeographicProjection\n) {\n  const texture = imagery.textureWebMercator || imagery.texture;\n  const rectangle = imagery.rectangle;\n  const context = frameState.context;\n\n  needGeographicProjection = defaultValue(needGeographicProjection, true);\n\n  // Reproject this texture if it is not already in a geographic projection and\n  // the pixels are more than 1e-5 radians apart.  The pixel spacing cutoff\n  // avoids precision problems in the reprojection transformation while making\n  // no noticeable difference in the georeferencing of the image.\n  if (\n    needGeographicProjection &&\n    !(\n      this._imageryProvider.tilingScheme.projection instanceof\n      GeographicProjection\n    ) &&\n    rectangle.width / texture.width > 1e-5\n  ) {\n    const that = this;\n    imagery.addReference();\n    const computeCommand = new ComputeCommand({\n      persists: true,\n      owner: this,\n      // Update render resources right before execution instead of now.\n      // This allows different ImageryLayers to share the same vao and buffers.\n      preExecute: function (command) {\n        reprojectToGeographic(command, context, texture, imagery.rectangle);\n      },\n      postExecute: function (outputTexture) {\n        imagery.texture = outputTexture;\n        that._finalizeReprojectTexture(context, outputTexture);\n        imagery.state = ImageryState.READY;\n        imagery.releaseReference();\n      },\n      canceled: function () {\n        imagery.state = ImageryState.TEXTURE_LOADED;\n        imagery.releaseReference();\n      },\n    });\n    this._reprojectComputeCommands.push(computeCommand);\n  } else {\n    if (needGeographicProjection) {\n      imagery.texture = texture;\n    }\n    this._finalizeReprojectTexture(context, texture);\n    imagery.state = ImageryState.READY;\n  }\n};\n\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\nImageryLayer.prototype.queueReprojectionCommands = function (frameState) {\n  const computeCommands = this._reprojectComputeCommands;\n  const length = computeCommands.length;\n  for (let i = 0; i < length; ++i) {\n    frameState.commandList.push(computeCommands[i]);\n  }\n  computeCommands.length = 0;\n};\n\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\nImageryLayer.prototype.cancelReprojections = function () {\n  this._reprojectComputeCommands.forEach(function (command) {\n    if (defined(command.canceled)) {\n      command.canceled();\n    }\n  });\n  this._reprojectComputeCommands.length = 0;\n};\n\nImageryLayer.prototype.getImageryFromCache = function (\n  x,\n  y,\n  level,\n  imageryRectangle\n) {\n  const cacheKey = getImageryCacheKey(x, y, level);\n  let imagery = this._imageryCache[cacheKey];\n\n  if (!defined(imagery)) {\n    imagery = new Imagery(this, x, y, level, imageryRectangle);\n    this._imageryCache[cacheKey] = imagery;\n  }\n\n  imagery.addReference();\n  return imagery;\n};\n\nImageryLayer.prototype.removeImageryFromCache = function (imagery) {\n  const cacheKey = getImageryCacheKey(imagery.x, imagery.y, imagery.level);\n  delete this._imageryCache[cacheKey];\n};\n\nfunction getImageryCacheKey(x, y, level) {\n  return JSON.stringify([x, y, level]);\n}\n\nconst uniformMap = {\n  u_textureDimensions: function () {\n    return this.textureDimensions;\n  },\n  u_texture: function () {\n    return this.texture;\n  },\n\n  textureDimensions: new Cartesian2(),\n  texture: undefined,\n};\n\nconst float32ArrayScratch = FeatureDetection.supportsTypedArrays()\n  ? new Float32Array(2 * 64)\n  : undefined;\n\nfunction reprojectToGeographic(command, context, texture, rectangle) {\n  // This function has gone through a number of iterations, because GPUs are awesome.\n  //\n  // Originally, we had a very simple vertex shader and computed the Web Mercator texture coordinates\n  // per-fragment in the fragment shader.  That worked well, except on mobile devices, because\n  // fragment shaders have limited precision on many mobile devices.  The result was smearing artifacts\n  // at medium zoom levels because different geographic texture coordinates would be reprojected to Web\n  // Mercator as the same value.\n  //\n  // Our solution was to reproject to Web Mercator in the vertex shader instead of the fragment shader.\n  // This required far more vertex data.  With fragment shader reprojection, we only needed a single quad.\n  // But to achieve the same precision with vertex shader reprojection, we needed a vertex for each\n  // output pixel.  So we used a grid of 256x256 vertices, because most of our imagery\n  // tiles are 256x256.  Fortunately the grid could be created and uploaded to the GPU just once and\n  // re-used for all reprojections, so the performance was virtually unchanged from our original fragment\n  // shader approach.  See https://github.com/CesiumGS/cesium/pull/714.\n  //\n  // Over a year later, we noticed (https://github.com/CesiumGS/cesium/issues/2110)\n  // that our reprojection code was creating a rare but severe artifact on some GPUs (Intel HD 4600\n  // for one).  The problem was that the GLSL sin function on these GPUs had a discontinuity at fine scales in\n  // a few places.\n  //\n  // We solved this by implementing a more reliable sin function based on the CORDIC algorithm\n  // (https://github.com/CesiumGS/cesium/pull/2111).  Even though this was a fair\n  // amount of code to be executing per vertex, the performance seemed to be pretty good on most GPUs.\n  // Unfortunately, on some GPUs, the performance was absolutely terrible\n  // (https://github.com/CesiumGS/cesium/issues/2258).\n  //\n  // So that brings us to our current solution, the one you see here.  Effectively, we compute the Web\n  // Mercator texture coordinates on the CPU and store the T coordinate with each vertex (the S coordinate\n  // is the same in Geographic and Web Mercator).  To make this faster, we reduced our reprojection mesh\n  // to be only 2 vertices wide and 64 vertices high.  We should have reduced the width to 2 sooner,\n  // because the extra vertices weren't buying us anything.  The height of 64 means we are technically\n  // doing a slightly less accurate reprojection than we were before, but we can't see the difference\n  // so it's worth the 4x speedup.\n\n  let reproject = context.cache.imageryLayer_reproject;\n\n  if (!defined(reproject)) {\n    reproject = context.cache.imageryLayer_reproject = {\n      vertexArray: undefined,\n      shaderProgram: undefined,\n      sampler: undefined,\n      destroy: function () {\n        if (defined(this.framebuffer)) {\n          this.framebuffer.destroy();\n        }\n        if (defined(this.vertexArray)) {\n          this.vertexArray.destroy();\n        }\n        if (defined(this.shaderProgram)) {\n          this.shaderProgram.destroy();\n        }\n      },\n    };\n\n    const positions = new Float32Array(2 * 64 * 2);\n    let index = 0;\n    for (let j = 0; j < 64; ++j) {\n      const y = j / 63.0;\n      positions[index++] = 0.0;\n      positions[index++] = y;\n      positions[index++] = 1.0;\n      positions[index++] = y;\n    }\n\n    const reprojectAttributeIndices = {\n      position: 0,\n      webMercatorT: 1,\n    };\n\n    const indices = TerrainProvider.getRegularGridIndices(2, 64);\n    const indexBuffer = Buffer.createIndexBuffer({\n      context: context,\n      typedArray: indices,\n      usage: BufferUsage.STATIC_DRAW,\n      indexDatatype: IndexDatatype.UNSIGNED_SHORT,\n    });\n\n    reproject.vertexArray = new VertexArray({\n      context: context,\n      attributes: [\n        {\n          index: reprojectAttributeIndices.position,\n          vertexBuffer: Buffer.createVertexBuffer({\n            context: context,\n            typedArray: positions,\n            usage: BufferUsage.STATIC_DRAW,\n          }),\n          componentsPerAttribute: 2,\n        },\n        {\n          index: reprojectAttributeIndices.webMercatorT,\n          vertexBuffer: Buffer.createVertexBuffer({\n            context: context,\n            sizeInBytes: 64 * 2 * 4,\n            usage: BufferUsage.STREAM_DRAW,\n          }),\n          componentsPerAttribute: 1,\n        },\n      ],\n      indexBuffer: indexBuffer,\n    });\n\n    const vs = new ShaderSource({\n      sources: [ReprojectWebMercatorVS],\n    });\n\n    reproject.shaderProgram = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: ReprojectWebMercatorFS,\n      attributeLocations: reprojectAttributeIndices,\n    });\n\n    reproject.sampler = new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    });\n  }\n\n  texture.sampler = reproject.sampler;\n\n  const width = texture.width;\n  const height = texture.height;\n\n  uniformMap.textureDimensions.x = width;\n  uniformMap.textureDimensions.y = height;\n  uniformMap.texture = texture;\n\n  let sinLatitude = Math.sin(rectangle.south);\n  const southMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n\n  sinLatitude = Math.sin(rectangle.north);\n  const northMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n  const oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);\n\n  const outputTexture = new Texture({\n    context: context,\n    width: width,\n    height: height,\n    pixelFormat: texture.pixelFormat,\n    pixelDatatype: texture.pixelDatatype,\n    preMultiplyAlpha: texture.preMultiplyAlpha,\n  });\n\n  // Allocate memory for the mipmaps.  Failure to do this before rendering\n  // to the texture via the FBO, and calling generateMipmap later,\n  // will result in the texture appearing blank.  I can't pretend to\n  // understand exactly why this is.\n  if (CesiumMath.isPowerOfTwo(width) && CesiumMath.isPowerOfTwo(height)) {\n    outputTexture.generateMipmap(MipmapHint.NICEST);\n  }\n\n  const south = rectangle.south;\n  const north = rectangle.north;\n\n  const webMercatorT = float32ArrayScratch;\n\n  let outputIndex = 0;\n  for (let webMercatorTIndex = 0; webMercatorTIndex < 64; ++webMercatorTIndex) {\n    const fraction = webMercatorTIndex / 63.0;\n    const latitude = CesiumMath.lerp(south, north, fraction);\n    sinLatitude = Math.sin(latitude);\n    const mercatorY = 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    const mercatorFraction =\n      (mercatorY - southMercatorY) * oneOverMercatorHeight;\n    webMercatorT[outputIndex++] = mercatorFraction;\n    webMercatorT[outputIndex++] = mercatorFraction;\n  }\n\n  reproject.vertexArray\n    .getAttribute(1)\n    .vertexBuffer.copyFromArrayView(webMercatorT);\n\n  command.shaderProgram = reproject.shaderProgram;\n  command.outputTexture = outputTexture;\n  command.uniformMap = uniformMap;\n  command.vertexArray = reproject.vertexArray;\n}\n\n/**\n * Gets the level with the specified world coordinate spacing between texels, or less.\n *\n * @param {ImageryLayer} layer The imagery layer to use.\n * @param {Number} texelSpacing The texel spacing for which to find a corresponding level.\n * @param {Number} latitudeClosestToEquator The latitude closest to the equator that we're concerned with.\n * @returns {Number} The level with the specified texel spacing or less.\n * @private\n */\nfunction getLevelWithMaximumTexelSpacing(\n  layer,\n  texelSpacing,\n  latitudeClosestToEquator\n) {\n  // PERFORMANCE_IDEA: factor out the stuff that doesn't change.\n  const imageryProvider = layer._imageryProvider;\n  const tilingScheme = imageryProvider.tilingScheme;\n  const ellipsoid = tilingScheme.ellipsoid;\n  const latitudeFactor = !(\n    layer._imageryProvider.tilingScheme.projection instanceof\n    GeographicProjection\n  )\n    ? Math.cos(latitudeClosestToEquator)\n    : 1.0;\n  const tilingSchemeRectangle = tilingScheme.rectangle;\n  const levelZeroMaximumTexelSpacing =\n    (ellipsoid.maximumRadius * tilingSchemeRectangle.width * latitudeFactor) /\n    (imageryProvider.tileWidth * tilingScheme.getNumberOfXTilesAtLevel(0));\n\n  const twoToTheLevelPower = levelZeroMaximumTexelSpacing / texelSpacing;\n  const level = Math.log(twoToTheLevelPower) / Math.log(2);\n  const rounded = Math.round(level);\n  return rounded | 0;\n}\nexport default ImageryLayer;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\n\n/**\n * An ordered collection of imagery layers.\n *\n * @alias ImageryLayerCollection\n * @constructor\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Adjustment.html|Cesium Sandcastle Imagery Adjustment Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Layers%20Manipulation.html|Cesium Sandcastle Imagery Manipulation Demo}\n */\nfunction ImageryLayerCollection() {\n  this._layers = [];\n\n  /**\n   * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that\n   * was added and the index at which it was added.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerAdded = new Event();\n\n  /**\n   * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that\n   * was removed and the index from which it was removed.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerRemoved = new Event();\n\n  /**\n   * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that\n   * was moved, its new index after the move, and its old index prior to the move.\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerMoved = new Event();\n\n  /**\n   * An event that is raised when a layer is shown or hidden by setting the\n   * {@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,\n   * the index of the layer in the collection, and a flag that is true if the layer is now\n   * shown or false if it is now hidden.\n   *\n   * @type {Event}\n   * @default Event()\n   */\n  this.layerShownOrHidden = new Event();\n}\n\nObject.defineProperties(ImageryLayerCollection.prototype, {\n  /**\n   * Gets the number of layers in this collection.\n   * @memberof ImageryLayerCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return this._layers.length;\n    },\n  },\n});\n\n/**\n * Adds a layer to the collection.\n *\n * @param {ImageryLayer} layer the layer to add.\n * @param {Number} [index] the index to add the layer at.  If omitted, the layer will\n *                         be added on top of all existing layers.\n *\n * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of the layers.\n */\nImageryLayerCollection.prototype.add = function (layer, index) {\n  const hasIndex = defined(index);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  }\n  if (hasIndex) {\n    if (index < 0) {\n      throw new DeveloperError(\"index must be greater than or equal to zero.\");\n    } else if (index > this._layers.length) {\n      throw new DeveloperError(\n        \"index must be less than or equal to the number of layers.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  if (!hasIndex) {\n    index = this._layers.length;\n    this._layers.push(layer);\n  } else {\n    this._layers.splice(index, 0, layer);\n  }\n\n  this._update();\n  this.layerAdded.raiseEvent(layer, index);\n};\n\n/**\n * Creates a new layer using the given ImageryProvider and adds it to the collection.\n *\n * @param {ImageryProvider} imageryProvider the imagery provider to create a new layer for.\n * @param {Number} [index] the index to add the layer at.  If omitted, the layer will\n *                         added on top of all existing layers.\n * @returns {ImageryLayer} The newly created layer.\n */\nImageryLayerCollection.prototype.addImageryProvider = function (\n  imageryProvider,\n  index\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(imageryProvider)) {\n    throw new DeveloperError(\"imageryProvider is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const layer = new ImageryLayer(imageryProvider);\n  this.add(layer, index);\n  return layer;\n};\n\n/**\n * Removes a layer from this collection, if present.\n *\n * @param {ImageryLayer} layer The layer to remove.\n * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n * @returns {Boolean} true if the layer was in the collection and was removed,\n *                    false if the layer was not in the collection.\n */\nImageryLayerCollection.prototype.remove = function (layer, destroy) {\n  destroy = defaultValue(destroy, true);\n\n  const index = this._layers.indexOf(layer);\n  if (index !== -1) {\n    this._layers.splice(index, 1);\n\n    this._update();\n\n    this.layerRemoved.raiseEvent(layer, index);\n\n    if (destroy) {\n      layer.destroy();\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all layers from this collection.\n *\n * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.\n */\nImageryLayerCollection.prototype.removeAll = function (destroy) {\n  destroy = defaultValue(destroy, true);\n\n  const layers = this._layers;\n  for (let i = 0, len = layers.length; i < len; i++) {\n    const layer = layers[i];\n    this.layerRemoved.raiseEvent(layer, i);\n\n    if (destroy) {\n      layer.destroy();\n    }\n  }\n\n  this._layers = [];\n};\n\n/**\n * Checks to see if the collection contains a given layer.\n *\n * @param {ImageryLayer} layer the layer to check for.\n *\n * @returns {Boolean} true if the collection contains the layer, false otherwise.\n */\nImageryLayerCollection.prototype.contains = function (layer) {\n  return this.indexOf(layer) !== -1;\n};\n\n/**\n * Determines the index of a given layer in the collection.\n *\n * @param {ImageryLayer} layer The layer to find the index of.\n *\n * @returns {Number} The index of the layer in the collection, or -1 if the layer does not exist in the collection.\n */\nImageryLayerCollection.prototype.indexOf = function (layer) {\n  return this._layers.indexOf(layer);\n};\n\n/**\n * Gets a layer by index from the collection.\n *\n * @param {Number} index the index to retrieve.\n *\n * @returns {ImageryLayer} The imagery layer at the given index.\n */\nImageryLayerCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\", \"index\");\n  }\n  //>>includeEnd('debug');\n\n  return this._layers[index];\n};\n\nfunction getLayerIndex(layers, layer) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(layer)) {\n    throw new DeveloperError(\"layer is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const index = layers.indexOf(layer);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (index === -1) {\n    throw new DeveloperError(\"layer is not in this collection.\");\n  }\n  //>>includeEnd('debug');\n\n  return index;\n}\n\nfunction swapLayers(collection, i, j) {\n  const arr = collection._layers;\n  i = CesiumMath.clamp(i, 0, arr.length - 1);\n  j = CesiumMath.clamp(j, 0, arr.length - 1);\n\n  if (i === j) {\n    return;\n  }\n\n  const temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n\n  collection._update();\n\n  collection.layerMoved.raiseEvent(temp, j, i);\n}\n\n/**\n * Raises a layer up one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.raise = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index + 1);\n};\n\n/**\n * Lowers a layer down one position in the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.lower = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  swapLayers(this, index, index - 1);\n};\n\n/**\n * Raises a layer to the top of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.raiseToTop = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  if (index === this._layers.length - 1) {\n    return;\n  }\n  this._layers.splice(index, 1);\n  this._layers.push(layer);\n\n  this._update();\n\n  this.layerMoved.raiseEvent(layer, this._layers.length - 1, index);\n};\n\n/**\n * Lowers a layer to the bottom of the collection.\n *\n * @param {ImageryLayer} layer the layer to move.\n *\n * @exception {DeveloperError} layer is not in this collection.\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nImageryLayerCollection.prototype.lowerToBottom = function (layer) {\n  const index = getLayerIndex(this._layers, layer);\n  if (index === 0) {\n    return;\n  }\n  this._layers.splice(index, 1);\n  this._layers.splice(0, 0, layer);\n\n  this._update();\n\n  this.layerMoved.raiseEvent(layer, 0, index);\n};\n\nconst applicableRectangleScratch = new Rectangle();\n\nfunction pickImageryHelper(scene, pickedLocation, pickFeatures, callback) {\n  // Find the terrain tile containing the picked location.\n  const tilesToRender = scene.globe._surface._tilesToRender;\n  let pickedTile;\n\n  for (\n    let textureIndex = 0;\n    !defined(pickedTile) && textureIndex < tilesToRender.length;\n    ++textureIndex\n  ) {\n    const tile = tilesToRender[textureIndex];\n    if (Rectangle.contains(tile.rectangle, pickedLocation)) {\n      pickedTile = tile;\n    }\n  }\n\n  if (!defined(pickedTile)) {\n    return;\n  }\n\n  // Pick against all attached imagery tiles containing the pickedLocation.\n  const imageryTiles = pickedTile.data.imagery;\n\n  for (let i = imageryTiles.length - 1; i >= 0; --i) {\n    const terrainImagery = imageryTiles[i];\n    const imagery = terrainImagery.readyImagery;\n    if (!defined(imagery)) {\n      continue;\n    }\n    const provider = imagery.imageryLayer.imageryProvider;\n    if (pickFeatures && !defined(provider.pickFeatures)) {\n      continue;\n    }\n\n    if (!Rectangle.contains(imagery.rectangle, pickedLocation)) {\n      continue;\n    }\n\n    // If this imagery came from a parent, it may not be applicable to its entire rectangle.\n    // Check the textureCoordinateRectangle.\n    const applicableRectangle = applicableRectangleScratch;\n\n    const epsilon = 1 / 1024; // 1/4 of a pixel in a typical 256x256 tile.\n    applicableRectangle.west = CesiumMath.lerp(\n      pickedTile.rectangle.west,\n      pickedTile.rectangle.east,\n      terrainImagery.textureCoordinateRectangle.x - epsilon\n    );\n    applicableRectangle.east = CesiumMath.lerp(\n      pickedTile.rectangle.west,\n      pickedTile.rectangle.east,\n      terrainImagery.textureCoordinateRectangle.z + epsilon\n    );\n    applicableRectangle.south = CesiumMath.lerp(\n      pickedTile.rectangle.south,\n      pickedTile.rectangle.north,\n      terrainImagery.textureCoordinateRectangle.y - epsilon\n    );\n    applicableRectangle.north = CesiumMath.lerp(\n      pickedTile.rectangle.south,\n      pickedTile.rectangle.north,\n      terrainImagery.textureCoordinateRectangle.w + epsilon\n    );\n    if (!Rectangle.contains(applicableRectangle, pickedLocation)) {\n      continue;\n    }\n\n    callback(imagery);\n  }\n}\n\n/**\n * Determines the imagery layers that are intersected by a pick ray. To compute a pick ray from a\n * location on the screen, use {@link Camera.getPickRay}.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @return {ImageryLayer[]|undefined} An array that includes all of\n *                                 the layers that are intersected by a given pick ray. Undefined if\n *                                 no layers are selected.\n *\n */\nImageryLayerCollection.prototype.pickImageryLayers = function (ray, scene) {\n  // Find the picked location on the globe.\n  const pickedPosition = scene.globe.pick(ray, scene);\n  if (!defined(pickedPosition)) {\n    return;\n  }\n\n  const pickedLocation = scene.globe.ellipsoid.cartesianToCartographic(\n    pickedPosition\n  );\n\n  const imageryLayers = [];\n\n  pickImageryHelper(scene, pickedLocation, false, function (imagery) {\n    imageryLayers.push(imagery.imageryLayer);\n  });\n\n  if (imageryLayers.length === 0) {\n    return undefined;\n  }\n\n  return imageryLayers;\n};\n\n/**\n * Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery\n * layer features are found by invoking {@link ImageryProvider#pickFeatures} for each imagery layer tile intersected\n * by the pick ray.  To compute a pick ray from a location on the screen, use {@link Camera.getPickRay}.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise that resolves to an array of features intersected by the pick ray.\n *                                             If it can be quickly determined that no features are intersected (for example,\n *                                             because no active imagery providers support {@link ImageryProvider#pickFeatures}\n *                                             or because the pick ray does not intersect the surface), this function will\n *                                             return undefined.\n *\n * @example\n * const pickRay = viewer.camera.getPickRay(windowPosition);\n * const featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);\n * if (!Cesium.defined(featuresPromise)) {\n *     console.log('No features picked.');\n * } else {\n *     Promise.resolve(featuresPromise).then(function(features) {\n *         // This function is called asynchronously when the list if picked features is available.\n *         console.log('Number of features: ' + features.length);\n *         if (features.length > 0) {\n *             console.log('First feature name: ' + features[0].name);\n *         }\n *     });\n * }\n */\nImageryLayerCollection.prototype.pickImageryLayerFeatures = function (\n  ray,\n  scene\n) {\n  // Find the picked location on the globe.\n  const pickedPosition = scene.globe.pick(ray, scene);\n  if (!defined(pickedPosition)) {\n    return;\n  }\n\n  const pickedLocation = scene.globe.ellipsoid.cartesianToCartographic(\n    pickedPosition\n  );\n\n  const promises = [];\n  const imageryLayers = [];\n\n  pickImageryHelper(scene, pickedLocation, true, function (imagery) {\n    const provider = imagery.imageryLayer.imageryProvider;\n    const promise = provider.pickFeatures(\n      imagery.x,\n      imagery.y,\n      imagery.level,\n      pickedLocation.longitude,\n      pickedLocation.latitude\n    );\n    if (defined(promise)) {\n      promises.push(promise);\n      imageryLayers.push(imagery.imageryLayer);\n    }\n  });\n\n  if (promises.length === 0) {\n    return undefined;\n  }\n  return Promise.all(promises).then(function (results) {\n    const features = [];\n    for (let resultIndex = 0; resultIndex < results.length; ++resultIndex) {\n      const result = results[resultIndex];\n      const image = imageryLayers[resultIndex];\n      if (defined(result) && result.length > 0) {\n        for (\n          let featureIndex = 0;\n          featureIndex < result.length;\n          ++featureIndex\n        ) {\n          const feature = result[featureIndex];\n          feature.imageryLayer = image;\n          // For features without a position, use the picked location.\n          if (!defined(feature.position)) {\n            feature.position = pickedLocation;\n          }\n          features.push(feature);\n        }\n      }\n    }\n    return features;\n  });\n};\n\n/**\n * Updates frame state to execute any queued texture re-projections.\n *\n * @private\n *\n * @param {FrameState} frameState The frameState.\n */\nImageryLayerCollection.prototype.queueReprojectionCommands = function (\n  frameState\n) {\n  const layers = this._layers;\n  for (let i = 0, len = layers.length; i < len; ++i) {\n    layers[i].queueReprojectionCommands(frameState);\n  }\n};\n\n/**\n * Cancels re-projection commands queued for the next frame.\n *\n * @private\n */\nImageryLayerCollection.prototype.cancelReprojections = function () {\n  const layers = this._layers;\n  for (let i = 0, len = layers.length; i < len; ++i) {\n    layers[i].cancelReprojections();\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} true if this object was destroyed; otherwise, false.\n *\n * @see ImageryLayerCollection#destroy\n */\nImageryLayerCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this\n * object allows for deterministic release of WebGL resources, instead of relying on the garbage\n * collector.\n * <br /><br />\n * Once this object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * layerCollection = layerCollection && layerCollection.destroy();\n *\n * @see ImageryLayerCollection#isDestroyed\n */\nImageryLayerCollection.prototype.destroy = function () {\n  this.removeAll(true);\n  return destroyObject(this);\n};\n\nImageryLayerCollection.prototype._update = function () {\n  let isBaseLayer = true;\n  const layers = this._layers;\n  let layersShownOrHidden;\n  let layer;\n  let i, len;\n  for (i = 0, len = layers.length; i < len; ++i) {\n    layer = layers[i];\n\n    layer._layerIndex = i;\n\n    if (layer.show) {\n      layer._isBaseLayer = isBaseLayer;\n      isBaseLayer = false;\n    } else {\n      layer._isBaseLayer = false;\n    }\n\n    if (layer.show !== layer._show) {\n      if (defined(layer._show)) {\n        if (!defined(layersShownOrHidden)) {\n          layersShownOrHidden = [];\n        }\n        layersShownOrHidden.push(layer);\n      }\n      layer._show = layer.show;\n    }\n  }\n\n  if (defined(layersShownOrHidden)) {\n    for (i = 0, len = layersShownOrHidden.length; i < len; ++i) {\n      layer = layersShownOrHidden[i];\n      this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);\n    }\n  }\n};\nexport default ImageryLayerCollection;\n","import defined from \"../Core/defined.js\";\n\n/**\n * Describes a rasterized feature, such as a point, polygon, polyline, etc., in an imagery layer.\n *\n * @alias ImageryLayerFeatureInfo\n * @constructor\n */\nfunction ImageryLayerFeatureInfo() {\n  /**\n   * Gets or sets the name of the feature.\n   * @type {String|undefined}\n   */\n  this.name = undefined;\n\n  /**\n   * Gets or sets an HTML description of the feature.  The HTML is not trusted and should\n   * be sanitized before display to the user.\n   * @type {String|undefined}\n   */\n  this.description = undefined;\n\n  /**\n   * Gets or sets the position of the feature, or undefined if the position is not known.\n   *\n   * @type {Cartographic|undefined}\n   */\n  this.position = undefined;\n\n  /**\n   * Gets or sets the raw data describing the feature.  The raw data may be in any\n   * number of formats, such as GeoJSON, KML, etc.\n   * @type {Object|undefined}\n   */\n  this.data = undefined;\n\n  /**\n   * Gets or sets the image layer of the feature.\n   * @type {Object|undefined}\n   */\n  this.imageryLayer = undefined;\n}\n\n/**\n * Configures the name of this feature by selecting an appropriate property.  The name will be obtained from\n * one of the following sources, in this order: 1) the property with the name 'name', 2) the property with the name 'title',\n * 3) the first property containing the word 'name', 4) the first property containing the word 'title'.  If\n * the name cannot be obtained from any of these sources, the existing name will be left unchanged.\n *\n * @param {Object} properties An object literal containing the properties of the feature.\n */\nImageryLayerFeatureInfo.prototype.configureNameFromProperties = function (\n  properties\n) {\n  let namePropertyPrecedence = 10;\n  let nameProperty;\n\n  for (const key in properties) {\n    if (properties.hasOwnProperty(key) && properties[key]) {\n      const lowerKey = key.toLowerCase();\n\n      if (namePropertyPrecedence > 1 && lowerKey === \"name\") {\n        namePropertyPrecedence = 1;\n        nameProperty = key;\n      } else if (namePropertyPrecedence > 2 && lowerKey === \"title\") {\n        namePropertyPrecedence = 2;\n        nameProperty = key;\n      } else if (namePropertyPrecedence > 3 && /name/i.test(key)) {\n        namePropertyPrecedence = 3;\n        nameProperty = key;\n      } else if (namePropertyPrecedence > 4 && /title/i.test(key)) {\n        namePropertyPrecedence = 4;\n        nameProperty = key;\n      }\n    }\n  }\n\n  if (defined(nameProperty)) {\n    this.name = properties[nameProperty];\n  }\n};\n\n/**\n * Configures the description of this feature by creating an HTML table of properties and their values.\n *\n * @param {Object} properties An object literal containing the properties of the feature.\n */\nImageryLayerFeatureInfo.prototype.configureDescriptionFromProperties = function (\n  properties\n) {\n  function describe(properties) {\n    let html = '<table class=\"cesium-infoBox-defaultTable\">';\n    for (const key in properties) {\n      if (properties.hasOwnProperty(key)) {\n        const value = properties[key];\n        if (defined(value)) {\n          if (typeof value === \"object\") {\n            html += `<tr><td>${key}</td><td>${describe(value)}</td></tr>`;\n          } else {\n            html += `<tr><td>${key}</td><td>${value}</td></tr>`;\n          }\n        }\n      }\n    }\n    html += \"</table>\";\n\n    return html;\n  }\n\n  this.description = describe(properties);\n};\nexport default ImageryLayerFeatureInfo;\n","import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport loadKTX2 from \"../Core/loadKTX2.js\";\nimport Resource from \"../Core/Resource.js\";\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|ImageBitmap} ImageryTypes\n *\n * The format in which {@link ImageryProvider} methods return an image may\n * vary by provider, configuration, or server settings.  Most common are\n * <code>HTMLImageElement</code>, <code>HTMLCanvasElement</code>, or on supported\n * browsers, <code>ImageBitmap</code>.\n *\n * See the documentation for each ImageryProvider class for more information about how they return images.\n */\n\n/**\n * Provides imagery to be displayed on the surface of an ellipsoid.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias ImageryProvider\n * @constructor\n * @abstract\n *\n * @see ArcGisMapServerImageryProvider\n * @see BingMapsImageryProvider\n * @see OpenStreetMapImageryProvider\n * @see TileMapServiceImageryProvider\n * @see GoogleEarthEnterpriseImageryProvider\n * @see GoogleEarthEnterpriseMapsProvider\n * @see GridImageryProvider\n * @see IonImageryProvider\n * @see MapboxImageryProvider\n * @see MapboxStyleImageryProvider\n * @see SingleTileImageryProvider\n * @see TileCoordinatesImageryProvider\n * @see UrlTemplateImageryProvider\n * @see WebMapServiceImageryProvider\n * @see WebMapTileServiceImageryProvider\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Layers.html|Cesium Sandcastle Imagery Layers Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Imagery%20Layers%20Manipulation.html|Cesium Sandcastle Imagery Manipulation Demo}\n */\nfunction ImageryProvider() {\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  DeveloperError.throwInstantiationError();\n}\n\nObject.defineProperties(ImageryProvider.prototype, {\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof ImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof ImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should\n   * not be called before {@link ImageryProvider#ready} returns true.\n   * @memberof ImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the width of each tile, in pixels.  This function should\n   * not be called before {@link ImageryProvider#ready} returns true.\n   * @memberof ImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link ImageryProvider#ready} returns true.\n   * @memberof ImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link ImageryProvider#ready} returns true.\n   * @memberof ImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link ImageryProvider#ready} returns true. Generally,\n   * a minimum level should only be used when the rectangle of the imagery is small\n   * enough that the number of tiles at the minimum level is small.  An imagery\n   * provider with more than a few tiles at the minimum level will lead to\n   * rendering problems.\n   * @memberof ImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link ImageryProvider#ready} returns true.\n   * @memberof ImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link ImageryProvider#ready} returns true.\n   * @memberof ImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error..  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof ImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery. This function should\n   * not be called before {@link ImageryProvider#ready} returns true.\n   * @memberof ImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof ImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof ImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link ImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} Returns a promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nImageryProvider.prototype.requestImage = function (x, y, level, request) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Asynchronously determines what features, if any, are located at a given longitude and latitude within\n * a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.\n * This function is optional, so it may not exist on all ImageryProviders.\n *\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n *\n * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.\n */\nImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  DeveloperError.throwInstantiationError();\n};\n\nconst ktx2Regex = /\\.ktx2$/i;\n\n/**\n * Loads an image from a given URL.  If the server referenced by the URL already has\n * too many requests pending, this function will instead return undefined, indicating\n * that the request should be retried later.\n *\n * @param {ImageryProvider} imageryProvider The imagery provider for the URL.\n * @param {Resource|String} url The URL of the image.\n * @returns {Promise.<ImageryTypes|CompressedTextureBuffer>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n */\nImageryProvider.loadImage = function (imageryProvider, url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  const resource = Resource.createIfNeeded(url);\n\n  if (ktx2Regex.test(resource.url)) {\n    // Resolves with `CompressedTextureBuffer`\n    return loadKTX2(resource);\n  } else if (\n    defined(imageryProvider) &&\n    defined(imageryProvider.tileDiscardPolicy)\n  ) {\n    // Resolves with `HTMLImageElement` or `ImageBitmap`\n    return resource.fetchImage({\n      preferBlob: true,\n      preferImageBitmap: true,\n      flipY: true,\n    });\n  }\n\n  return resource.fetchImage({\n    preferImageBitmap: true,\n    flipY: true,\n  });\n};\nexport default ImageryProvider;\n","/**\n * @private\n */\nconst ImageryState = {\n  UNLOADED: 0,\n  TRANSITIONING: 1,\n  RECEIVED: 2,\n  TEXTURE_LOADED: 3,\n  READY: 4,\n  FAILED: 5,\n  INVALID: 6,\n  PLACEHOLDER: 7,\n};\nexport default Object.freeze(ImageryState);\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport HilbertOrder from \"../Core/HilbertOrder.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport S2Cell from \"../Core/S2Cell.js\";\nimport ImplicitSubtree from \"./ImplicitSubtree.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport MetadataSemantic from \"./MetadataSemantic.js\";\nimport parseBoundingVolumeSemantics from \"./parseBoundingVolumeSemantics.js\";\n\n/**\n * A specialized {@link Cesium3DTileContent} that lazily evaluates an implicit\n * tileset. It is somewhat similar in operation to a\n * {@link Tileset3DTileContent} in that once the content is constructed, it\n * updates the tileset tree with more tiles. However, unlike external tilesets,\n * child subtrees are represented as additional placeholder nodes with\n * Implicit3DTileContent.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Implicit3DTileContent\n * @constructor\n *\n * @param {Cesium3DTileset} tileset The tileset this content belongs to\n * @param {Cesium3DTile} tile The tile this content belongs to.\n * @param {Resource} resource The resource for the tileset\n * @param {Object} [json] The JSON object containing the subtree. Mutually exclusive with arrayBuffer.\n * @param {ArrayBuffer} [arrayBuffer] The array buffer that stores the content payload. Mutually exclusive with json.\n * @param {Number} [byteOffset=0] The offset into the array buffer, if one was provided\n *\n * @exception {DeveloperError} One of json and arrayBuffer must be defined.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function Implicit3DTileContent(\n  tileset,\n  tile,\n  resource,\n  json,\n  arrayBuffer,\n  byteOffset\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"tile.implicitTileset\", tile.implicitTileset);\n  Check.defined(\"tile.implicitCoordinates\", tile.implicitCoordinates);\n  if (defined(json) === defined(arrayBuffer)) {\n    throw new DeveloperError(\"One of json and arrayBuffer must be defined.\");\n  }\n  //>>includeEnd('debug');\n\n  const implicitTileset = tile.implicitTileset;\n  const implicitCoordinates = tile.implicitCoordinates;\n\n  this._implicitTileset = implicitTileset;\n  this._implicitCoordinates = implicitCoordinates;\n  this._implicitSubtree = undefined;\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this._metadata = undefined;\n\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n\n  const templateValues = implicitCoordinates.getTemplateValues();\n  const subtreeResource = implicitTileset.subtreeUriTemplate.getDerivedResource(\n    {\n      templateValues: templateValues,\n    }\n  );\n  this._url = subtreeResource.getUrlComponent(true);\n\n  this._readyPromise = initialize(this, json, arrayBuffer, byteOffset);\n}\n\nObject.defineProperties(Implicit3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._url;\n    },\n  },\n\n  /**\n   * Part of the {@link Cesium3DTileContent} interface. <code>Implicit3DTileContent</code>\n   * always returns <code>undefined</code>. Only transcoded tiles have content metadata.\n   * @memberof Implicit3DTileContent.prototype\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return undefined;\n    },\n    set: function () {\n      //>>includeStart('debug', pragmas.debug);\n      throw new DeveloperError(\"Implicit3DTileContent cannot have metadata\");\n      //>>includeEnd('debug');\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\n/**\n * Initialize the implicit content by parsing the subtree resource and setting\n * up a promise chain to expand the immediate subtree.\n *\n * @param {Implicit3DTileContent} content The implicit content\n * @param {Object} [json] The JSON containing the subtree. Mutually exclusive with arrayBuffer.\n * @param {ArrayBuffer} [arrayBuffer] The ArrayBuffer containing a subtree binary. Mutually exclusive with json.\n * @param {Number} [byteOffset=0] The byte offset into the arrayBuffer\n * @private\n */\nfunction initialize(content, json, arrayBuffer, byteOffset) {\n  byteOffset = defaultValue(byteOffset, 0);\n  let uint8Array;\n  if (defined(arrayBuffer)) {\n    uint8Array = new Uint8Array(arrayBuffer, byteOffset);\n  }\n\n  const subtree = new ImplicitSubtree(\n    content._resource,\n    json,\n    uint8Array,\n    content._implicitTileset,\n    content._implicitCoordinates\n  );\n\n  content._implicitSubtree = subtree;\n  return subtree.readyPromise.then(function () {\n    expandSubtree(content, subtree);\n    return content;\n  });\n}\n\n/**\n * Expand a single subtree placeholder tile. This transcodes the subtree into\n * a tree of {@link Cesium3DTile}. The root of this tree is stored in\n * the placeholder tile's children array. This method also creates placeholder\n * tiles for the child subtrees to be lazily expanded as needed.\n *\n * @param {Implicit3DTileContent} content The content\n * @param {ImplicitSubtree} subtree The parsed subtree\n * @private\n */\nfunction expandSubtree(content, subtree) {\n  const placeholderTile = content._tile;\n\n  // Parse the tiles inside this immediate subtree\n  const childIndex = content._implicitCoordinates.childIndex;\n  const results = transcodeSubtreeTiles(\n    content,\n    subtree,\n    placeholderTile,\n    childIndex\n  );\n\n  // Link the new subtree to the existing placeholder tile.\n  placeholderTile.children.push(results.rootTile);\n\n  // for each child subtree, make new placeholder tiles\n  const childSubtrees = listChildSubtrees(content, subtree, results.bottomRow);\n  for (let i = 0; i < childSubtrees.length; i++) {\n    const subtreeLocator = childSubtrees[i];\n    const leafTile = subtreeLocator.tile;\n    const implicitChildTile = makePlaceholderChildSubtree(\n      content,\n      leafTile,\n      subtreeLocator.childIndex\n    );\n    leafTile.children.push(implicitChildTile);\n  }\n}\n\n/**\n * A pair of (tile, childIndex) used for finding child subtrees.\n *\n * @typedef {Object} ChildSubtreeLocator\n * @property {Cesium3DTile} tile One of the tiles in the bottommost row of the subtree.\n * @property {Number} childIndex The morton index of the child tile relative to its parent\n * @private\n */\n\n/**\n * Determine what child subtrees exist and return a list of information\n *\n * @param {Implicit3DTileContent} content The implicit content\n * @param {ImplicitSubtree} subtree The subtree for looking up availability\n * @param {Array<Cesium3DTile|undefined>} bottomRow The bottom row of tiles in a transcoded subtree\n * @returns {ChildSubtreeLocator[]} A list of identifiers for the child subtrees.\n * @private\n */\nfunction listChildSubtrees(content, subtree, bottomRow) {\n  const results = [];\n  const branchingFactor = content._implicitTileset.branchingFactor;\n  for (let i = 0; i < bottomRow.length; i++) {\n    const leafTile = bottomRow[i];\n    if (!defined(leafTile)) {\n      continue;\n    }\n\n    for (let j = 0; j < branchingFactor; j++) {\n      const index = i * branchingFactor + j;\n      if (subtree.childSubtreeIsAvailableAtIndex(index)) {\n        results.push({\n          tile: leafTile,\n          childIndex: j,\n        });\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Results of transcodeSubtreeTiles, containing the root tile of the\n * subtree and the bottom row of nodes for further processing.\n *\n * @typedef {Object} TranscodedSubtree\n * @property {Cesium3DTile} rootTile The transcoded root tile of the subtree\n * @property {Array<Cesium3DTile|undefined>} bottomRow The bottom row of transcoded tiles. This is helpful for processing child subtrees\n * @private\n */\n\n/**\n * Transcode the implicitly-defined tiles within this subtree and generate\n * explicit {@link Cesium3DTile} objects. This function only transcode tiles,\n * child subtrees are handled separately.\n *\n * @param {Implicit3DTileContent} content The implicit content\n * @param {ImplicitSubtree} subtree The subtree to get availability information\n * @param {Cesium3DTile} placeholderTile The placeholder tile, used for constructing the subtree root tile\n * @param {Number} childIndex The Morton index of the root tile relative to parentOfRootTile\n * @returns {TranscodedSubtree} The newly created subtree of tiles\n * @private\n */\nfunction transcodeSubtreeTiles(content, subtree, placeholderTile, childIndex) {\n  const rootBitIndex = 0;\n  const rootParentIsPlaceholder = true;\n  const rootTile = deriveChildTile(\n    content,\n    subtree,\n    placeholderTile,\n    childIndex,\n    rootBitIndex,\n    rootParentIsPlaceholder\n  );\n\n  // Sliding window over the levels of the tree.\n  // Each row is branchingFactor * length of previous row\n  // Tiles within a row are ordered by Morton index.\n  let parentRow = [rootTile];\n  let currentRow = [];\n\n  const implicitTileset = content._implicitTileset;\n  for (let level = 1; level < implicitTileset.subtreeLevels; level++) {\n    const levelOffset = subtree.getLevelOffset(level);\n    const numberOfChildren = implicitTileset.branchingFactor * parentRow.length;\n    for (\n      let childMortonIndex = 0;\n      childMortonIndex < numberOfChildren;\n      childMortonIndex++\n    ) {\n      const childBitIndex = levelOffset + childMortonIndex;\n\n      if (!subtree.tileIsAvailableAtIndex(childBitIndex)) {\n        currentRow.push(undefined);\n        continue;\n      }\n\n      const parentMortonIndex = subtree.getParentMortonIndex(childMortonIndex);\n      const parentTile = parentRow[parentMortonIndex];\n      const childChildIndex =\n        childMortonIndex % implicitTileset.branchingFactor;\n      const childTile = deriveChildTile(\n        content,\n        subtree,\n        parentTile,\n        childChildIndex,\n        childBitIndex\n      );\n      parentTile.children.push(childTile);\n      currentRow.push(childTile);\n    }\n\n    parentRow = currentRow;\n    currentRow = [];\n  }\n\n  return {\n    rootTile: rootTile,\n    // At the end of the last loop, bottomRow was moved to parentRow\n    bottomRow: parentRow,\n  };\n}\n\nfunction getGeometricError(tileMetadata, implicitTileset, implicitCoordinates) {\n  const semantic = MetadataSemantic.TILE_GEOMETRIC_ERROR;\n\n  if (defined(tileMetadata) && tileMetadata.hasPropertyBySemantic(semantic)) {\n    return tileMetadata.getPropertyBySemantic(semantic);\n  }\n\n  return (\n    implicitTileset.geometricError / Math.pow(2, implicitCoordinates.level)\n  );\n}\n\n/**\n * Given a parent tile and information about which child to create, derive\n * the properties of the child tile implicitly.\n * <p>\n * This creates a real tile for rendering, not a placeholder tile like some of\n * the other methods of ImplicitTileset.\n * </p>\n *\n * @param {Implicit3DTileContent} implicitContent The implicit content\n * @param {ImplicitSubtree} subtree The subtree the child tile belongs to\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @param {Number} childIndex The morton index of the child tile relative to its parent\n * @param {Number} childBitIndex The index of the child tile within the tile's availability information.\n * @param {Boolean} [parentIsPlaceholderTile=false] True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @returns {Cesium3DTile} The new child tile.\n * @private\n */\nfunction deriveChildTile(\n  implicitContent,\n  subtree,\n  parentTile,\n  childIndex,\n  childBitIndex,\n  parentIsPlaceholderTile\n) {\n  const implicitTileset = implicitContent._implicitTileset;\n  let implicitCoordinates;\n  if (defaultValue(parentIsPlaceholderTile, false)) {\n    implicitCoordinates = parentTile.implicitCoordinates;\n  } else {\n    implicitCoordinates = parentTile.implicitCoordinates.getChildCoordinates(\n      childIndex\n    );\n  }\n\n  // Parse metadata and bounding volume semantics at the beginning\n  // as the bounding volumes are needed below.\n  let tileMetadata;\n  let tileBounds;\n  let contentBounds;\n  if (defined(subtree.tilePropertyTableJson)) {\n    tileMetadata = subtree.getTileMetadataView(implicitCoordinates);\n\n    const boundingVolumeSemantics = parseBoundingVolumeSemantics(tileMetadata);\n    tileBounds = boundingVolumeSemantics.tile;\n    contentBounds = boundingVolumeSemantics.content;\n  }\n\n  // Content is not loaded at this point, so this flag is set for future reference.\n  const contentPropertyTableJsons = subtree.contentPropertyTableJsons;\n  const length = contentPropertyTableJsons.length;\n  let hasImplicitContentMetadata = false;\n  for (let i = 0; i < length; i++) {\n    if (subtree.contentIsAvailableAtCoordinates(implicitCoordinates, i)) {\n      hasImplicitContentMetadata = true;\n      break;\n    }\n  }\n\n  const boundingVolume = getTileBoundingVolume(\n    implicitTileset,\n    implicitCoordinates,\n    childIndex,\n    parentIsPlaceholderTile,\n    parentTile,\n    tileBounds\n  );\n\n  const contentJsons = [];\n  for (let i = 0; i < implicitTileset.contentCount; i++) {\n    if (!subtree.contentIsAvailableAtIndex(childBitIndex, i)) {\n      continue;\n    }\n    const childContentTemplate = implicitTileset.contentUriTemplates[i];\n    const childContentUri = childContentTemplate.getDerivedResource({\n      templateValues: implicitCoordinates.getTemplateValues(),\n    }).url;\n    const contentJson = {\n      uri: childContentUri,\n    };\n\n    const contentBoundingVolume = getContentBoundingVolume(\n      boundingVolume,\n      contentBounds\n    );\n\n    if (defined(contentBoundingVolume)) {\n      contentJson.boundingVolume = contentBoundingVolume;\n    }\n\n    // combine() is used to pass through any additional properties the\n    // user specified such as extras or extensions\n    contentJsons.push(combine(contentJson, implicitTileset.contentHeaders[i]));\n  }\n\n  const childGeometricError = getGeometricError(\n    tileMetadata,\n    implicitTileset,\n    implicitCoordinates\n  );\n\n  const tileJson = {\n    boundingVolume: boundingVolume,\n    geometricError: childGeometricError,\n    refine: implicitTileset.refine,\n    contents: contentJsons,\n  };\n\n  // combine() is used to pass through any additional properties the\n  // user specified such as extras or extensions.\n  const deep = true;\n  const rootHeader = clone(implicitTileset.tileHeader, deep);\n  delete rootHeader.boundingVolume;\n  delete rootHeader.transform;\n  const combinedTileJson = combine(tileJson, rootHeader, deep);\n\n  const childTile = makeTile(\n    implicitContent,\n    implicitTileset.baseResource,\n    combinedTileJson,\n    parentTile\n  );\n\n  childTile.implicitCoordinates = implicitCoordinates;\n  childTile.implicitSubtree = subtree;\n  childTile.metadata = tileMetadata;\n  childTile.hasImplicitContentMetadata = hasImplicitContentMetadata;\n\n  return childTile;\n}\n\n/**\n * Checks whether the bounding volume's heights can be updated.\n * Returns true if the minimumHeight/maximumHeight parameter\n * is defined and the bounding volume is a region or S2 cell.\n *\n * @param {Object} [boundingVolume] The bounding volume\n * @param {Object} [tileBounds] The tile bounds\n * @param {Number} [tileBounds.minimumHeight] The minimum height\n * @param {Number} [tileBounds.maximumHeight] The maximum height\n * @returns {Boolean} Whether the bounding volume's heights can be updated\n * @private\n */\nfunction canUpdateHeights(boundingVolume, tileBounds) {\n  return (\n    defined(boundingVolume) &&\n    defined(tileBounds) &&\n    (defined(tileBounds.minimumHeight) || defined(tileBounds.maximumHeight)) &&\n    (hasExtension(boundingVolume, \"3DTILES_bounding_volume_S2\") ||\n      defined(boundingVolume.region))\n  );\n}\n\n/**\n * Update the minimum and maximum height of the bounding volume.\n * This is typically used to tighten a bounding volume using the\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>TILE_MAXIMUM_HEIGHT</code>\n * semantics. Heights are only updated if the respective\n * minimumHeight/maximumHeight parameter is defined and the\n * bounding volume is a region or S2 cell.\n *\n * @param {Object} boundingVolume The bounding volume\n * @param {Object} [tileBounds] The tile bounds\n * @param {Number} [tileBounds.minimumHeight] The new minimum height\n * @param {Number} [tileBounds.maximumHeight] The new maximum height\n * @private\n */\nfunction updateHeights(boundingVolume, tileBounds) {\n  if (!defined(tileBounds)) {\n    return;\n  }\n\n  if (hasExtension(boundingVolume, \"3DTILES_bounding_volume_S2\")) {\n    updateS2CellHeights(\n      boundingVolume.extensions[\"3DTILES_bounding_volume_S2\"],\n      tileBounds.minimumHeight,\n      tileBounds.maximumHeight\n    );\n  } else if (defined(boundingVolume.region)) {\n    updateRegionHeights(\n      boundingVolume.region,\n      tileBounds.minimumHeight,\n      tileBounds.maximumHeight\n    );\n  }\n}\n\n/**\n * For a bounding region, update the minimum and maximum height. This\n * is typically used to tighten a bounding volume using the\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>TILE_MAXIMUM_HEIGHT</code>\n * semantics. Heights are only updated if the respective\n * minimumHeight/maximumHeight parameter is defined.\n *\n * @param {Array} region A 6-element array describing the bounding region\n * @param {Number} [minimumHeight] The new minimum height\n * @param {Number} [maximumHeight] The new maximum height\n * @private\n */\nfunction updateRegionHeights(region, minimumHeight, maximumHeight) {\n  if (defined(minimumHeight)) {\n    region[4] = minimumHeight;\n  }\n\n  if (defined(maximumHeight)) {\n    region[5] = maximumHeight;\n  }\n}\n\n/**\n * For a bounding S2 cell, update the minimum and maximum height. This\n * is typically used to tighten a bounding volume using the\n * <code>TILE_MINIMUM_HEIGHT</code> and <code>TILE_MAXIMUM_HEIGHT</code>\n * semantics. Heights are only updated if the respective\n * minimumHeight/maximumHeight parameter is defined.\n *\n * @param {Object} s2CellVolume An object describing the S2 cell\n * @param {Number} [minimumHeight] The new minimum height\n * @param {Number} [maximumHeight] The new maximum height\n * @private\n */\nfunction updateS2CellHeights(s2CellVolume, minimumHeight, maximumHeight) {\n  if (defined(minimumHeight)) {\n    s2CellVolume.minimumHeight = minimumHeight;\n  }\n\n  if (defined(maximumHeight)) {\n    s2CellVolume.maximumHeight = maximumHeight;\n  }\n}\n\n/**\n * Gets the tile's bounding volume, which may be specified via\n * metadata semantics such as TILE_BOUNDING_BOX or implicitly\n * derived from the implicit root tile's bounding volume.\n * <p>\n * Priority of bounding volume types:\n * <ol>\n * <li>Explicit min/max height\n *   <ol>\n *     <li>With explicit region</li>\n *     <li>With implicit S2</li>\n *     <li>With implicit region</li>\n *   </ol>\n * </li>\n * <li>Explicit box</li>\n * <li>Explicit region</li>\n * <li>Explicit sphere</li>\n * <li>Implicit S2</li>\n * <li>Implicit box</li>\n * <li>Implicit region</li>\n * </ol>\n * </p>\n *\n * @param {ImplicitTileset} implicitTileset The implicit tileset struct which holds the root bounding volume\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the child tile\n * @param {Number} childIndex The morton index of the child tile relative to its parent\n * @param {Boolean} parentIsPlaceholderTile True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @param {Object} [tileBounds] The tile bounds\n * @returns {Object} An object containing the JSON for a bounding volume\n * @private\n */\nfunction getTileBoundingVolume(\n  implicitTileset,\n  implicitCoordinates,\n  childIndex,\n  parentIsPlaceholderTile,\n  parentTile,\n  tileBounds\n) {\n  let boundingVolume;\n\n  if (\n    !defined(tileBounds) ||\n    !defined(tileBounds.boundingVolume) ||\n    (!canUpdateHeights(tileBounds.boundingVolume, tileBounds) &&\n      canUpdateHeights(implicitTileset.boundingVolume, tileBounds))\n  ) {\n    boundingVolume = deriveBoundingVolume(\n      implicitTileset,\n      implicitCoordinates,\n      childIndex,\n      defaultValue(parentIsPlaceholderTile, false),\n      parentTile\n    );\n  } else {\n    boundingVolume = tileBounds.boundingVolume;\n  }\n\n  // The TILE_MINIMUM_HEIGHT and TILE_MAXIMUM_HEIGHT metadata semantics\n  // can be used to tighten the bounding volume\n  updateHeights(boundingVolume, tileBounds);\n\n  return boundingVolume;\n}\n\n/**\n * Gets the content bounding volume, which may be specified via\n * metadata semantics such as CONTENT_BOUNDING_BOX.\n * <p>\n * Priority of bounding volume types:\n * <ol>\n * <li>Explicit min/max height\n *   <ol>\n *     <li>With explicit region</li>\n *     <li>With tile bounding volume (S2 or region)</li>\n *   </ol>\n * </li>\n * <li>Explicit box</li>\n * <li>Explicit region</li>\n * <li>Explicit sphere</li>\n * <li>Tile bounding volume (when content.boundingVolume is undefined)</li>\n * </ol>\n * </p>\n *\n * @param {Object} tileBoundingVolume An object containing the JSON for the tile's bounding volume\n * @param {Object} [contentBounds] The content bounds\n * @returns {Object|undefined} An object containing the JSON for a bounding volume, or <code>undefined</code> if there is no bounding volume\n * @private\n */\nfunction getContentBoundingVolume(tileBoundingVolume, contentBounds) {\n  // content bounding volumes can only be specified via\n  // metadata semantics such as CONTENT_BOUNDING_BOX\n  let contentBoundingVolume;\n  if (defined(contentBounds)) {\n    contentBoundingVolume = contentBounds.boundingVolume;\n  }\n\n  // The CONTENT_MINIMUM_HEIGHT and CONTENT_MAXIMUM_HEIGHT metadata semantics\n  // can be used to tighten the bounding volume\n  if (canUpdateHeights(contentBoundingVolume, contentBounds)) {\n    updateHeights(contentBoundingVolume, contentBounds);\n  } else if (canUpdateHeights(tileBoundingVolume, contentBounds)) {\n    contentBoundingVolume = clone(tileBoundingVolume, true);\n    updateHeights(contentBoundingVolume, contentBounds);\n  }\n\n  return contentBoundingVolume;\n}\n\n/**\n * Given the coordinates of a tile, derive its bounding volume from the root.\n *\n * @param {ImplicitTileset} implicitTileset The implicit tileset struct which holds the root bounding volume\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the child tile\n * @param {Number} childIndex The morton index of the child tile relative to its parent\n * @param {Boolean} parentIsPlaceholderTile True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @returns {Object} An object containing the JSON for a bounding volume\n * @private\n */\nfunction deriveBoundingVolume(\n  implicitTileset,\n  implicitCoordinates,\n  childIndex,\n  parentIsPlaceholderTile,\n  parentTile\n) {\n  const rootBoundingVolume = implicitTileset.boundingVolume;\n\n  if (hasExtension(rootBoundingVolume, \"3DTILES_bounding_volume_S2\")) {\n    return deriveBoundingVolumeS2(\n      parentIsPlaceholderTile,\n      parentTile,\n      childIndex,\n      implicitCoordinates.level,\n      implicitCoordinates.x,\n      implicitCoordinates.y,\n      implicitCoordinates.z\n    );\n  }\n\n  if (defined(rootBoundingVolume.region)) {\n    const childRegion = deriveBoundingRegion(\n      rootBoundingVolume.region,\n      implicitCoordinates.level,\n      implicitCoordinates.x,\n      implicitCoordinates.y,\n      implicitCoordinates.z\n    );\n\n    return {\n      region: childRegion,\n    };\n  }\n\n  const childBox = deriveBoundingBox(\n    rootBoundingVolume.box,\n    implicitCoordinates.level,\n    implicitCoordinates.x,\n    implicitCoordinates.y,\n    implicitCoordinates.z\n  );\n\n  return {\n    box: childBox,\n  };\n}\n\n/**\n * Derive a bounding volume for a descendant tile (child, grandchild, etc.),\n * assuming a quadtree or octree implicit tiling scheme. The (level, x, y, [z])\n * coordinates are given to select the descendant tile and compute its position\n * and dimensions.\n * <p>\n * If z is present, octree subdivision is used. Otherwise, quadtree subdivision\n * is used. Quadtrees are always divided at the midpoint of the the horizontal\n * dimensions, i.e. (x, y), leaving the z axis unchanged.\n * </p>\n *\n * @param {Boolean} parentIsPlaceholderTile True if parentTile is a placeholder tile. This is true for the root of each subtree.\n * @param {Cesium3DTile} parentTile The parent of the new child tile\n * @param {Number} childIndex The morton index of the child tile relative to its parent\n * @param {Number} level The level of the descendant tile relative to the root implicit tile\n * @param {Number} x The x coordinate of the descendant tile\n * @param {Number} y The y coordinate of the descendant tile\n * @param {Number} [z] The z coordinate of the descendant tile (octree only)\n * @returns {Object} An object with the 3DTILES_bounding_volume_S2 extension.\n * @private\n */\nfunction deriveBoundingVolumeS2(\n  parentIsPlaceholderTile,\n  parentTile,\n  childIndex,\n  level,\n  x,\n  y,\n  z\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.bool(\"parentIsPlaceholderTile\", parentIsPlaceholderTile);\n  Check.typeOf.object(\"parentTile\", parentTile);\n  Check.typeOf.number(\"childIndex\", childIndex);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (defined(z)) {\n    Check.typeOf.number(\"z\", z);\n  }\n  //>>includeEnd('debug');\n\n  const boundingVolumeS2 = parentTile._boundingVolume;\n\n  // Handle the placeholder tile case, where we just duplicate the placeholder's bounding volume.\n  if (parentIsPlaceholderTile) {\n    return {\n      extensions: {\n        \"3DTILES_bounding_volume_S2\": {\n          token: S2Cell.getTokenFromId(boundingVolumeS2.s2Cell._cellId),\n          minimumHeight: boundingVolumeS2.minimumHeight,\n          maximumHeight: boundingVolumeS2.maximumHeight,\n        },\n      },\n    };\n  }\n\n  // Extract the first 3 face bits from the 64-bit S2 cell ID.\n  // eslint-disable-next-line no-undef\n  const face = Number(parentTile._boundingVolume.s2Cell._cellId >> BigInt(61));\n  // The Hilbert curve is rotated for the \"odd\" faces on the S2 Earthcube.\n  // See http://s2geometry.io/devguide/img/s2cell_global.jpg\n  const position =\n    face % 2 === 0\n      ? HilbertOrder.encode2D(level, x, y)\n      : HilbertOrder.encode2D(level, y, x);\n  // eslint-disable-next-line no-undef\n  const cell = S2Cell.fromFacePositionLevel(face, BigInt(position), level);\n\n  let minHeight, maxHeight;\n  if (defined(z)) {\n    const midpointHeight =\n      (boundingVolumeS2.maximumHeight + boundingVolumeS2.minimumHeight) / 2;\n    minHeight =\n      childIndex < 4 ? boundingVolumeS2.minimumHeight : midpointHeight;\n    maxHeight =\n      childIndex < 4 ? midpointHeight : boundingVolumeS2.maximumHeight;\n  } else {\n    minHeight = boundingVolumeS2.minimumHeight;\n    maxHeight = boundingVolumeS2.maximumHeight;\n  }\n\n  return {\n    extensions: {\n      \"3DTILES_bounding_volume_S2\": {\n        token: S2Cell.getTokenFromId(cell._cellId),\n        minimumHeight: minHeight,\n        maximumHeight: maxHeight,\n      },\n    },\n  };\n}\n\nconst scratchScaleFactors = new Cartesian3();\nconst scratchRootCenter = new Cartesian3();\nconst scratchCenter = new Cartesian3();\nconst scratchHalfAxes = new Matrix3();\n/**\n * Derive a bounding volume for a descendant tile (child, grandchild, etc.),\n * assuming a quadtree or octree implicit tiling scheme. The (level, x, y, [z])\n * coordinates are given to select the descendant tile and compute its position\n * and dimensions.\n * <p>\n * If z is present, octree subdivision is used. Otherwise, quadtree subdivision\n * is used. Quadtrees are always divided at the midpoint of the the horizontal\n * dimensions, i.e. (x, y), leaving the z axis unchanged.\n * </p>\n * <p>\n * This computes the child volume directly from the root bounding volume rather\n * than recursively subdividing to minimize floating point error.\n * </p>\n *\n * @param {Number[]} rootBox An array of 12 numbers representing the bounding box of the root tile\n * @param {Number} level The level of the descendant tile relative to the root implicit tile\n * @param {Number} x The x coordinate of the descendant tile\n * @param {Number} y The y coordinate of the descendant tile\n * @param {Number} [z] The z coordinate of the descendant tile (octree only)\n * @returns {Number[]} An array of 12 numbers representing the bounding box of the descendant tile.\n * @private\n */\nfunction deriveBoundingBox(rootBox, level, x, y, z) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rootBox\", rootBox);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (defined(z)) {\n    Check.typeOf.number(\"z\", z);\n  }\n  //>>includeEnd('debug');\n\n  if (level === 0) {\n    return rootBox;\n  }\n\n  const rootCenter = Cartesian3.unpack(rootBox, 0, scratchRootCenter);\n  const rootHalfAxes = Matrix3.unpack(rootBox, 3, scratchHalfAxes);\n\n  const tileScale = Math.pow(2, -level);\n  const modelSpaceX = -1 + (2 * x + 1) * tileScale;\n  const modelSpaceY = -1 + (2 * y + 1) * tileScale;\n\n  let modelSpaceZ = 0;\n  const scaleFactors = Cartesian3.fromElements(\n    tileScale,\n    tileScale,\n    1,\n    scratchScaleFactors\n  );\n\n  if (defined(z)) {\n    modelSpaceZ = -1 + (2 * z + 1) * tileScale;\n    scaleFactors.z = tileScale;\n  }\n\n  let center = Cartesian3.fromElements(\n    modelSpaceX,\n    modelSpaceY,\n    modelSpaceZ,\n    scratchCenter\n  );\n  center = Matrix3.multiplyByVector(rootHalfAxes, center, scratchCenter);\n  center = Cartesian3.add(center, rootCenter, scratchCenter);\n\n  let halfAxes = Matrix3.clone(rootHalfAxes);\n  halfAxes = Matrix3.multiplyByScale(halfAxes, scaleFactors, halfAxes);\n\n  const childBox = new Array(12);\n  Cartesian3.pack(center, childBox);\n  Matrix3.pack(halfAxes, childBox, 3);\n  return childBox;\n}\n\nconst scratchRectangle = new Rectangle();\n/**\n * Derive a bounding volume for a descendant tile (child, grandchild, etc.),\n * assuming a quadtree or octree implicit tiling scheme. The (level, x, y, [z])\n * coordinates are given to select the descendant tile and compute its position\n * and dimensions.\n * <p>\n * If z is present, octree subdivision is used. Otherwise, quadtree subdivision\n * is used. Quadtrees are always divided at the midpoint of the the horizontal\n * dimensions, i.e. (mid_longitude, mid_latitude), leaving the height values\n * unchanged.\n * </p>\n * <p>\n * This computes the child volume directly from the root bounding volume rather\n * than recursively subdividing to minimize floating point error.\n * </p>\n * @param {Number[]} rootRegion An array of 6 numbers representing the root implicit tile\n * @param {Number} level The level of the descendant tile relative to the root implicit tile\n * @param {Number} x The x coordinate of the descendant tile\n * @param {Number} y The x coordinate of the descendant tile\n * @param {Number} [z] The z coordinate of the descendant tile (octree only)\n * @returns {Number[]} An array of 6 numbers representing the bounding region of the descendant tile\n * @private\n */\nfunction deriveBoundingRegion(rootRegion, level, x, y, z) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rootRegion\", rootRegion);\n  Check.typeOf.number(\"level\", level);\n  Check.typeOf.number(\"x\", x);\n  Check.typeOf.number(\"y\", y);\n  if (defined(z)) {\n    Check.typeOf.number(\"z\", z);\n  }\n  //>>includeEnd('debug');\n\n  if (level === 0) {\n    return rootRegion.slice();\n  }\n\n  const rectangle = Rectangle.unpack(rootRegion, 0, scratchRectangle);\n  const rootMinimumHeight = rootRegion[4];\n  const rootMaximumHeight = rootRegion[5];\n  const tileScale = Math.pow(2, -level);\n\n  const childWidth = tileScale * rectangle.width;\n  const west = CesiumMath.negativePiToPi(rectangle.west + x * childWidth);\n  const east = CesiumMath.negativePiToPi(west + childWidth);\n\n  const childHeight = tileScale * rectangle.height;\n  const south = CesiumMath.negativePiToPi(rectangle.south + y * childHeight);\n  const north = CesiumMath.negativePiToPi(south + childHeight);\n\n  // Height is only subdivided for octrees; It remains constant for quadtrees.\n  let minimumHeight = rootMinimumHeight;\n  let maximumHeight = rootMaximumHeight;\n  if (defined(z)) {\n    const childThickness = tileScale * (rootMaximumHeight - rootMinimumHeight);\n    minimumHeight += z * childThickness;\n    maximumHeight = minimumHeight + childThickness;\n  }\n\n  return [west, south, east, north, minimumHeight, maximumHeight];\n}\n\n/**\n * Create a placeholder 3D Tile whose content will be an Implicit3DTileContent\n * for lazy evaluation of a child subtree.\n *\n * @param {Implicit3DTileContent} content The content object.\n * @param {Cesium3DTile} parentTile The parent of the new child subtree.\n * @param {Number} childIndex The morton index of the child tile relative to its parent\n * @returns {Cesium3DTile} The new placeholder tile\n * @private\n */\nfunction makePlaceholderChildSubtree(content, parentTile, childIndex) {\n  const implicitTileset = content._implicitTileset;\n  const implicitCoordinates = parentTile.implicitCoordinates.getChildCoordinates(\n    childIndex\n  );\n\n  const childBoundingVolume = deriveBoundingVolume(\n    implicitTileset,\n    implicitCoordinates,\n    childIndex,\n    false,\n    parentTile\n  );\n\n  // Ignore tile metadata when computing geometric error for the placeholder tile\n  // since the child subtree's metadata hasn't been loaded yet.\n  // The actual geometric error will be computed in deriveChildTile.\n  const childGeometricError = getGeometricError(\n    undefined,\n    implicitTileset,\n    implicitCoordinates\n  );\n\n  const childContentUri = implicitTileset.subtreeUriTemplate.getDerivedResource(\n    {\n      templateValues: implicitCoordinates.getTemplateValues(),\n    }\n  ).url;\n  const tileJson = {\n    boundingVolume: childBoundingVolume,\n    geometricError: childGeometricError,\n    refine: implicitTileset.refine,\n    contents: [\n      {\n        uri: childContentUri,\n      },\n    ],\n  };\n\n  const tile = makeTile(\n    content,\n    implicitTileset.baseResource,\n    tileJson,\n    parentTile\n  );\n  tile.implicitTileset = implicitTileset;\n  tile.implicitCoordinates = implicitCoordinates;\n  return tile;\n}\n\n/**\n * Make a {@link Cesium3DTile}. This uses the content's tile's constructor instead\n * of importing Cesium3DTile. This is to avoid a circular dependency between\n * this file and Cesium3DTile.js\n * @param {Implicit3DTileContent} content The implicit content\n * @param {Resource} baseResource The base resource for the tileset\n * @param {Object} tileJson The JSON header for the tile\n * @param {Cesium3DTile} parentTile The parent of the new tile\n * @returns {Cesium3DTile} The newly created tile.\n * @private\n */\nfunction makeTile(content, baseResource, tileJson, parentTile) {\n  const Cesium3DTile = content._tile.constructor;\n  return new Cesium3DTile(content._tileset, baseResource, tileJson, parentTile);\n}\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Implicit3DTileContent</code>\n * always returns <code>false</code> since a tile of this type does not have any features.\n * @private\n */\nImplicit3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return false;\n};\n\n/**\n * Part of the {@link Cesium3DTileContent} interface.  <code>Implicit3DTileContent</code>\n * always returns <code>undefined</code> since a tile of this type does not have any features.\n * @private\n */\nImplicit3DTileContent.prototype.getFeature = function (batchId) {\n  return undefined;\n};\n\nImplicit3DTileContent.prototype.applyDebugSettings = function (\n  enabled,\n  color\n) {};\n\nImplicit3DTileContent.prototype.applyStyle = function (style) {};\n\nImplicit3DTileContent.prototype.update = function (tileset, frameState) {};\n\nImplicit3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nImplicit3DTileContent.prototype.destroy = function () {\n  this._implicitSubtree =\n    this._implicitSubtree && this._implicitSubtree.destroy();\n  return destroyObject(this);\n};\n\n// Exposed for testing\nImplicit3DTileContent._deriveBoundingBox = deriveBoundingBox;\nImplicit3DTileContent._deriveBoundingRegion = deriveBoundingRegion;\nImplicit3DTileContent._deriveBoundingVolumeS2 = deriveBoundingVolumeS2;\n","import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\n\n/**\n * An availability bitstream for use in an {@link ImplicitSubtree}. This handles\n * both Uint8Array bitstreams and constant values.\n *\n * @alias ImplicitAvailabilityBitstream\n * @constructor\n *\n * @param {Object} options An object with the following properties:\n * @param {Number} options.lengthBits The length of the bitstream in bits\n * @param {Boolean} [options.constant] A single boolean value indicating the value of all the bits in the bitstream if they are all the same\n * @param {Uint8Array} [options.bitstream] An array of bytes storing the bitstream in binary\n * @param {Number} [options.availableCount] A number indicating how many 1 bits are found in the bitstream\n * @param {Boolean} [options.computeAvailableCountEnabled=false] If true, and options.availableCount is undefined, the availableCount will be computed from the bitstream.\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function ImplicitAvailabilityBitstream(options) {\n  const lengthBits = options.lengthBits;\n  let availableCount = options.availableCount;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.lengthBits\", lengthBits);\n  //>>includeEnd('debug');\n\n  const constant = options.constant;\n  const bitstream = options.bitstream;\n\n  if (defined(constant)) {\n    // if defined, constant must be 1 which means all tiles are available\n    availableCount = lengthBits;\n  } else {\n    const expectedLength = Math.ceil(lengthBits / 8);\n    if (bitstream.length !== expectedLength) {\n      throw new RuntimeError(\n        `Availability bitstream must be exactly ${expectedLength} bytes long to store ${lengthBits} bits. Actual bitstream was ${bitstream.length} bytes long.`\n      );\n    }\n\n    // Only compute the available count if requested, as this involves looping\n    // over the bitstream.\n    const computeAvailableCountEnabled = defaultValue(\n      options.computeAvailableCountEnabled,\n      false\n    );\n    if (!defined(availableCount) && computeAvailableCountEnabled) {\n      availableCount = count1Bits(bitstream, lengthBits);\n    }\n  }\n\n  this._lengthBits = lengthBits;\n  this._availableCount = availableCount;\n  this._constant = constant;\n  this._bitstream = bitstream;\n}\n\n/**\n * Count the number of bits with value 1 in the bitstream. This is used for\n * computing availableCount if not precomputed\n *\n * @param {Uint8Array} bitstream The bitstream typed array\n * @param {Number} lengthBits How many bits are in the bitstream\n * @private\n */\nfunction count1Bits(bitstream, lengthBits) {\n  let count = 0;\n  for (let i = 0; i < lengthBits; i++) {\n    const byteIndex = i >> 3;\n    const bitIndex = i % 8;\n    count += (bitstream[byteIndex] >> bitIndex) & 1;\n  }\n  return count;\n}\n\nObject.defineProperties(ImplicitAvailabilityBitstream.prototype, {\n  /**\n   * The length of the bitstream in bits.\n   *\n   * @memberof ImplicitAvailabilityBitstream.prototype\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  lengthBits: {\n    get: function () {\n      return this._lengthBits;\n    },\n  },\n  /**\n   * The number of bits in the bitstream with value <code>1</code>.\n   *\n   * @memberof ImplicitAvailabilityBitstream.prototype\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  availableCount: {\n    get: function () {\n      return this._availableCount;\n    },\n  },\n});\n\n/**\n * Get a bit from the availability bitstream as a Boolean. If the bitstream\n * is a constant, the constant value is returned instead.\n *\n * @param {Number} index The integer index of the bit.\n * @returns {Boolean} The value of the bit\n * @private\n */\nImplicitAvailabilityBitstream.prototype.getBit = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (index < 0 || index >= this._lengthBits) {\n    throw new DeveloperError(\"Bit index out of bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  if (defined(this._constant)) {\n    return this._constant;\n  }\n\n  // byteIndex is floor(index / 8)\n  const byteIndex = index >> 3;\n  const bitIndex = index % 8;\n\n  return ((this._bitstream[byteIndex] >> bitIndex) & 1) === 1;\n};\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\n\n/**\n * This class represents a single entity in the <code>MetadataTable</code> owned by an implicit subtree. The entity is specified by the entityId.\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @param {MetadataTable} options.metadataTable The metadata table.\n * @param {MetadataClass} options.class The class that the metadata conforms to.\n * @param {Number} options.entityId The ID of the entity the metadata belongs to.\n * @param {Object} options.propertyTableJson The JSON that contains the property table of the entity.\n *\n * @alias ImplicitMetadataView\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function ImplicitMetadataView(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const metadataTable = options.metadataTable;\n  const metadataClass = options.class;\n  const entityId = options.entityId;\n  const propertyTableJson = options.propertyTableJson;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.metadataTable\", metadataTable);\n  Check.typeOf.object(\"options.class\", metadataClass);\n  Check.typeOf.number(\"options.entityId\", entityId);\n  Check.typeOf.object(\"options.propertyTableJson\", propertyTableJson);\n\n  //>>includeEnd('debug');\n\n  this._class = metadataClass;\n  this._metadataTable = metadataTable;\n  this._entityId = entityId;\n\n  this._extensions = propertyTableJson.extensions;\n  this._extras = propertyTableJson.extras;\n}\n\nObject.defineProperties(ImplicitMetadataView.prototype, {\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof ImplicitMetadataView.prototype\n   * @type {MetadataClass}\n   * @readonly\n   */\n  class: {\n    get: function () {\n      return this._class;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof ImplicitMetadataView.prototype\n   * @type {Object}\n   * @readonly\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof ImplicitMetadataView.prototype\n   * @type {Object}\n   * @readonly\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * Returns whether the metadata contains this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the tile has this property.\n * @private\n */\nImplicitMetadataView.prototype.hasProperty = function (propertyId) {\n  return this._metadataTable.hasProperty(propertyId);\n};\n\n/**\n * Returns whether the metadata contains a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {Boolean} Whether the tile has a property with the given semantic.\n * @private\n */\nImplicitMetadataView.prototype.hasPropertyBySemantic = function (semantic) {\n  return this._metadataTable.hasPropertyBySemantic(semantic);\n};\n\n/**\n * Returns an array of property IDs in the metadata table.\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nImplicitMetadataView.prototype.getPropertyIds = function (results) {\n  return this._metadataTable.getPropertyIds(results);\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the tile does not have this property.\n * @private\n */\nImplicitMetadataView.prototype.getProperty = function (propertyId) {\n  return this._metadataTable.getProperty(this._entityId, propertyId);\n};\n\n/**\n * Sets the value of the property with the given ID in the metadata table.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nImplicitMetadataView.prototype.setProperty = function (propertyId, value) {\n  return this._metadataTable.setProperty(this._entityId, propertyId, value);\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic in the metadata table.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the tile does not have this semantic.\n * @private\n */\nImplicitMetadataView.prototype.getPropertyBySemantic = function (semantic) {\n  return this._metadataTable.getPropertyBySemantic(this._entityId, semantic);\n};\n\n/**\n * Sets the value of the property with the given semantic in the metadata table.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\n\nImplicitMetadataView.prototype.setPropertyBySemantic = function (\n  semantic,\n  value\n) {\n  return this._metadataTable.setPropertyBySemantic(\n    this._entityId,\n    semantic,\n    value\n  );\n};\n","import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * The subdivision scheme for an implicit tileset.\n *\n * @enum {String}\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst ImplicitSubdivisionScheme = {\n  /**\n   * A quadtree divides a parent tile into four children, split at the midpoint\n   * of the x and y dimensions of the bounding box\n   * @type {String}\n   * @constant\n   * @private\n   */\n  QUADTREE: \"QUADTREE\",\n  /**\n   * An octree divides a parent tile into eight children, split at the midpoint\n   * of the x, y, and z dimensions of the bounding box.\n   * @type {String}\n   * @constant\n   * @private\n   */\n  OCTREE: \"OCTREE\",\n};\n\n/**\n * Get the branching factor for the given subdivision scheme\n * @param {ImplicitSubdivisionScheme} subdivisionScheme The subdivision scheme\n * @returns {Number} The branching factor, either 4 for QUADTREE or 8 for OCTREE\n * @private\n */\nImplicitSubdivisionScheme.getBranchingFactor = function (subdivisionScheme) {\n  switch (subdivisionScheme) {\n    case ImplicitSubdivisionScheme.OCTREE:\n      return 8;\n    case ImplicitSubdivisionScheme.QUADTREE:\n      return 4;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"subdivisionScheme is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\nexport default Object.freeze(ImplicitSubdivisionScheme);\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport ImplicitAvailabilityBitstream from \"./ImplicitAvailabilityBitstream.js\";\nimport ImplicitMetadataView from \"./ImplicitMetadataView.js\";\nimport ImplicitSubdivisionScheme from \"./ImplicitSubdivisionScheme.js\";\nimport ImplicitSubtreeMetadata from \"./ImplicitSubtreeMetadata.js\";\nimport MetadataTable from \"./MetadataTable.js\";\nimport ResourceCache from \"./ResourceCache.js\";\n\n/**\n * An object representing a single subtree in an implicit tileset\n * including availability.\n * <p>\n * Subtrees handle tile metadata, defined in the subtree JSON in either\n * tileMetadata (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension.\n * Subtrees also handle content metadata and metadata about the subtree itself.\n * </p>\n *\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata#implicit-tile-properties|Implicit Tile Properties in the 3DTILES_metadata specification}\n *\n * @alias ImplicitSubtree\n * @constructor\n *\n * @param {Resource} resource The resource for this subtree. This is used for fetching external buffers as needed.\n * @param {Object} [json] The JSON object for this subtree. Mutually exclusive with subtreeView.\n * @param {Uint8Array} [subtreeView] The contents of a subtree binary in a Uint8Array. Mutually exclusive with json.\n * @param {ImplicitTileset} implicitTileset The implicit tileset. This includes information about the size of subtrees\n * @param {ImplicitTileCoordinates} implicitCoordinates The coordinates of the subtree's root tile.\n *\n * @exception {DeveloperError} One of json and subtreeView must be defined.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function ImplicitSubtree(\n  resource,\n  json,\n  subtreeView,\n  implicitTileset,\n  implicitCoordinates\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"resource\", resource);\n  if (defined(json) === defined(subtreeView)) {\n    throw new DeveloperError(\"One of json and subtreeView must be defined.\");\n  }\n  Check.typeOf.object(\"implicitTileset\", implicitTileset);\n  Check.typeOf.object(\"implicitCoordinates\", implicitCoordinates);\n  //>>includeEnd('debug');\n\n  this._resource = resource;\n  this._subtreeJson = undefined;\n  this._bufferLoader = undefined;\n  this._tileAvailability = undefined;\n  this._contentAvailabilityBitstreams = [];\n  this._childSubtreeAvailability = undefined;\n  this._implicitCoordinates = implicitCoordinates;\n  this._subtreeLevels = implicitTileset.subtreeLevels;\n  this._subdivisionScheme = implicitTileset.subdivisionScheme;\n  this._branchingFactor = implicitTileset.branchingFactor;\n\n  // properties for metadata\n  this._metadata = undefined;\n  this._tileMetadataTable = undefined;\n  this._tilePropertyTableJson = undefined;\n\n  this._contentMetadataTables = [];\n  this._contentPropertyTableJsons = [];\n\n  // Jump buffers are maps of availability bit index to entity ID\n  this._tileJumpBuffer = undefined;\n  this._contentJumpBuffers = [];\n\n  this._readyPromise = initialize(this, json, subtreeView, implicitTileset);\n}\n\nObject.defineProperties(ImplicitSubtree.prototype, {\n  /**\n   * A promise that resolves once all necessary availability buffers\n   * are loaded.\n   *\n   * @type {Promise}\n   * @readonly\n   * @private\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * When subtree metadata is present (3D Tiles 1.1), this property stores an {@link ImplicitSubtreeMetadata} instance\n   *\n   * @type {ImplicitSubtreeMetadata}\n   * @readonly\n   * @private\n   */\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n  },\n\n  /**\n   * When tile metadata is present (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension is used,\n   * this property stores a {@link MetadataTable} instance for the tiles in the subtree.\n   *\n   * @type {MetadataTable}\n   * @readonly\n   * @private\n   */\n  tileMetadataTable: {\n    get: function () {\n      return this._tileMetadataTable;\n    },\n  },\n\n  /**\n   * When tile metadata is present (3D Tiles 1.1) or the <code>3DTILES_metadata</code> extension is used,\n   * this property stores the JSON from the extension. This is used by {@link TileMetadata}\n   * to get the extras and extensions for the tiles in the subtree.\n   *\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  tilePropertyTableJson: {\n    get: function () {\n      return this._tilePropertyTableJson;\n    },\n  },\n\n  /**\n   * When content metadata is present (3D Tiles 1.1), this property stores\n   * an array of {@link MetadataTable} instances for the contents in the subtree.\n   *\n   * @type {Array}\n   * @readonly\n   * @private\n   */\n  contentMetadataTables: {\n    get: function () {\n      return this._contentMetadataTables;\n    },\n  },\n\n  /**\n   * When content metadata is present (3D Tiles 1.1), this property\n   * an array of the JSONs from the extension. This is used to get the extras\n   * and extensions for the contents in the subtree.\n   *\n   * @type {Array}\n   * @readonly\n   * @private\n   */\n  contentPropertyTableJsons: {\n    get: function () {\n      return this._contentPropertyTableJsons;\n    },\n  },\n\n  /**\n   * Gets the implicit tile coordinates for the root of the subtree.\n   *\n   * @type {ImplicitTileCoordinates}\n   * @readonly\n   * @private\n   */\n  implicitCoordinates: {\n    get: function () {\n      return this._implicitCoordinates;\n    },\n  },\n});\n\n/**\n * Check if a specific tile is available at an index of the tile availability bitstream\n *\n * @param {Number} index The index of the desired tile\n * @returns {Boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.tileIsAvailableAtIndex = function (index) {\n  return this._tileAvailability.getBit(index);\n};\n\n/**\n * Check if a specific tile is available at an implicit tile coordinate\n *\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @returns {Boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.tileIsAvailableAtCoordinates = function (\n  implicitCoordinates\n) {\n  const index = this.getTileIndex(implicitCoordinates);\n  return this.tileIsAvailableAtIndex(index);\n};\n\n/**\n * Check if a specific tile's content is available at an index of the content availability bitstream\n *\n * @param {Number} index The index of the desired tile\n * @param {Number} [contentIndex=0] The index of the desired content when multiple contents are used.\n * @returns {Boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.contentIsAvailableAtIndex = function (\n  index,\n  contentIndex\n) {\n  contentIndex = defaultValue(contentIndex, 0);\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    contentIndex < 0 ||\n    contentIndex >= this._contentAvailabilityBitstreams.length\n  ) {\n    throw new DeveloperError(\"contentIndex out of bounds.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._contentAvailabilityBitstreams[contentIndex].getBit(index);\n};\n\n/**\n * Check if a specific tile's content is available at an implicit tile coordinate\n *\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @param {Number} [contentIndex=0] The index of the desired content when the <code>3DTILES_multiple_contents</code> extension is used.\n * @returns {Boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.contentIsAvailableAtCoordinates = function (\n  implicitCoordinates,\n  contentIndex\n) {\n  const index = this.getTileIndex(implicitCoordinates);\n  return this.contentIsAvailableAtIndex(index, contentIndex);\n};\n\n/**\n * Check if a child subtree is available at an index of the child subtree availability bitstream\n *\n * @param {Number} index The index of the desired child subtree\n * @returns {Boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.childSubtreeIsAvailableAtIndex = function (index) {\n  return this._childSubtreeAvailability.getBit(index);\n};\n\n/**\n * Check if a specific child subtree is available at an implicit tile coordinate\n *\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a child subtree\n * @returns {Boolean} The value of the i-th bit\n * @private\n */\nImplicitSubtree.prototype.childSubtreeIsAvailableAtCoordinates = function (\n  implicitCoordinates\n) {\n  const index = this.getChildSubtreeIndex(implicitCoordinates);\n  return this.childSubtreeIsAvailableAtIndex(index);\n};\n\n/**\n * Get the index of the first node at the given level within this subtree.\n * e.g. for a quadtree:\n * <ul>\n * <li>Level 0 starts at index 0</li>\n * <li>Level 1 starts at index 1</li>\n * <li>Level 2 starts at index 5</li>\n * </ul>\n *\n * @param {Number} level The 0-indexed level number relative to the root of the subtree\n * @returns {Number} The first index at the desired level\n * @private\n */\nImplicitSubtree.prototype.getLevelOffset = function (level) {\n  const branchingFactor = this._branchingFactor;\n  return (Math.pow(branchingFactor, level) - 1) / (branchingFactor - 1);\n};\n\n/**\n * Get the morton index of a tile's parent. This is equivalent to\n * chopping off the last 2 (quadtree) or 3 (octree) bits of the morton\n * index.\n *\n * @param {Number} childIndex The morton index of the child tile relative to its parent\n * @returns {Number} The index of the child's parent node\n * @private\n */\nImplicitSubtree.prototype.getParentMortonIndex = function (mortonIndex) {\n  let bitsPerLevel = 2;\n  if (this._subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    bitsPerLevel = 3;\n  }\n\n  return mortonIndex >> bitsPerLevel;\n};\n\n/**\n * Parse all relevant information out of the subtree. This fetches any\n * external buffers that are used by the implicit tileset. When finished,\n * it resolves/rejects subtree.readyPromise.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @param {Object} [json] The JSON object for this subtree. If parsing from a binary subtree file, this will be undefined.\n * @param {Uint8Array} [subtreeView] The contents of the subtree binary\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to.\n * @private\n */\nfunction initialize(subtree, json, subtreeView, implicitTileset) {\n  let chunks;\n  if (defined(json)) {\n    chunks = {\n      json: json,\n      binary: undefined,\n    };\n  } else {\n    chunks = parseSubtreeChunks(subtreeView);\n  }\n\n  const subtreeJson = chunks.json;\n  subtree._subtreeJson = subtreeJson;\n\n  let tilePropertyTableJson;\n  if (hasExtension(subtreeJson, \"3DTILES_metadata\")) {\n    tilePropertyTableJson = subtreeJson.extensions[\"3DTILES_metadata\"];\n  } else if (defined(subtreeJson.tileMetadata)) {\n    const propertyTableIndex = subtreeJson.tileMetadata;\n    tilePropertyTableJson = subtreeJson.propertyTables[propertyTableIndex];\n  }\n\n  const contentPropertyTableJsons = [];\n  if (defined(subtreeJson.contentMetadata)) {\n    const length = subtreeJson.contentMetadata.length;\n    for (let i = 0; i < length; i++) {\n      const propertyTableIndex = subtreeJson.contentMetadata[i];\n      contentPropertyTableJsons.push(\n        subtreeJson.propertyTables[propertyTableIndex]\n      );\n    }\n  }\n\n  let metadata;\n  const schema = implicitTileset.metadataSchema;\n  const subtreeMetadata = subtreeJson.subtreeMetadata;\n  if (defined(subtreeMetadata)) {\n    const metadataClass = subtreeMetadata.class;\n    const subtreeMetadataClass = schema.classes[metadataClass];\n    metadata = new ImplicitSubtreeMetadata({\n      subtreeMetadata: subtreeMetadata,\n      class: subtreeMetadataClass,\n    });\n  }\n\n  subtree._metadata = metadata;\n  subtree._tilePropertyTableJson = tilePropertyTableJson;\n  subtree._contentPropertyTableJsons = contentPropertyTableJsons;\n\n  // if no contentAvailability is specified, no tile in the subtree has\n  // content\n  const defaultContentAvailability = {\n    constant: 0,\n  };\n\n  // In 3D Tiles 1.1, content availability is provided in an array in the subtree JSON\n  // regardless of whether or not it contains multiple contents. This differs from previous\n  // schemas, where content availability is either a single object in the subtree JSON or\n  // as an array in the 3DTILES_multiple_contents extension.\n  //\n  // After identifying how availability is stored, put the results in this new array for consistent processing later\n  subtreeJson.contentAvailabilityHeaders = [];\n  if (hasExtension(subtreeJson, \"3DTILES_multiple_contents\")) {\n    subtreeJson.contentAvailabilityHeaders =\n      subtreeJson.extensions[\"3DTILES_multiple_contents\"].contentAvailability;\n  } else if (Array.isArray(subtreeJson.contentAvailability)) {\n    subtreeJson.contentAvailabilityHeaders = subtreeJson.contentAvailability;\n  } else {\n    subtreeJson.contentAvailabilityHeaders.push(\n      defaultValue(subtreeJson.contentAvailability, defaultContentAvailability)\n    );\n  }\n\n  const bufferHeaders = preprocessBuffers(subtreeJson.buffers);\n  const bufferViewHeaders = preprocessBufferViews(\n    subtreeJson.bufferViews,\n    bufferHeaders\n  );\n\n  // Buffers and buffer views are inactive until explicitly marked active.\n  // This way we can avoid fetching buffers that will not be used.\n  markActiveBufferViews(subtreeJson, bufferViewHeaders);\n  if (defined(tilePropertyTableJson)) {\n    markActiveMetadataBufferViews(tilePropertyTableJson, bufferViewHeaders);\n  }\n\n  for (let i = 0; i < contentPropertyTableJsons.length; i++) {\n    const contentPropertyTableJson = contentPropertyTableJsons[i];\n    markActiveMetadataBufferViews(contentPropertyTableJson, bufferViewHeaders);\n  }\n\n  return requestActiveBuffers(subtree, bufferHeaders, chunks.binary).then(\n    function (buffersU8) {\n      const bufferViewsU8 = parseActiveBufferViews(\n        bufferViewHeaders,\n        buffersU8\n      );\n      parseAvailability(subtree, subtreeJson, implicitTileset, bufferViewsU8);\n\n      if (defined(tilePropertyTableJson)) {\n        parseTileMetadataTable(subtree, implicitTileset, bufferViewsU8);\n        makeTileJumpBuffer(subtree);\n      }\n\n      parseContentMetadataTables(subtree, implicitTileset, bufferViewsU8);\n      makeContentJumpBuffers(subtree);\n\n      return subtree;\n    }\n  );\n}\n\n/**\n * A helper object for storing the two parts of the subtree binary\n *\n * @typedef {Object} SubtreeChunks\n * @property {Object} json The json chunk of the subtree\n * @property {Uint8Array} binary The binary chunk of the subtree. This represents the internal buffer.\n * @private\n */\n\n/**\n * Given the binary contents of a subtree, split into JSON and binary chunks\n *\n * @param {Uint8Array} subtreeView The subtree binary\n * @returns {SubtreeChunks} An object containing the JSON and binary chunks.\n * @private\n */\nfunction parseSubtreeChunks(subtreeView) {\n  // Parse the header\n  const littleEndian = true;\n  const subtreeReader = new DataView(\n    subtreeView.buffer,\n    subtreeView.byteOffset\n  );\n  // Skip to the chunk lengths\n  let byteOffset = 8;\n\n  // Read the bottom 32 bits of the 64-bit byte length. This is ok for now because:\n  // 1) not all browsers have native 64-bit operations\n  // 2) the data is well under 4GB\n  const jsonByteLength = subtreeReader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n  const binaryByteLength = subtreeReader.getUint32(byteOffset, littleEndian);\n  byteOffset += 8;\n\n  const subtreeJson = getJsonFromTypedArray(\n    subtreeView,\n    byteOffset,\n    jsonByteLength\n  );\n  byteOffset += jsonByteLength;\n  const subtreeBinary = subtreeView.subarray(\n    byteOffset,\n    byteOffset + binaryByteLength\n  );\n\n  return {\n    json: subtreeJson,\n    binary: subtreeBinary,\n  };\n}\n\n/**\n * A buffer header is the JSON header from the subtree JSON chunk plus\n * a couple extra boolean flags for easy reference.\n *\n * Buffers are assumed inactive until explicitly marked active. This is used\n * to avoid fetching unneeded buffers.\n *\n * @typedef {Object} BufferHeader\n * @property {Boolean} isExternal True if this is an external buffer\n * @property {Boolean} isActive Whether this buffer is currently used.\n * @property {String} [uri] The URI of the buffer (external buffers only)\n * @property {Number} byteLength The byte length of the buffer, including any padding contained within.\n * @private\n */\n\n/**\n * Iterate over the list of buffers from the subtree JSON and add the\n * isExternal and isActive fields for easier parsing later. This modifies\n * the objects in place.\n *\n * @param {Object[]} [bufferHeaders=[]] The JSON from subtreeJson.buffers.\n * @returns {BufferHeader[]} The same array of headers with additional fields.\n * @private\n */\nfunction preprocessBuffers(bufferHeaders) {\n  bufferHeaders = defined(bufferHeaders) ? bufferHeaders : [];\n  for (let i = 0; i < bufferHeaders.length; i++) {\n    const bufferHeader = bufferHeaders[i];\n    bufferHeader.isExternal = defined(bufferHeader.uri);\n    bufferHeader.isActive = false;\n  }\n\n  return bufferHeaders;\n}\n\n/**\n * A buffer header is the JSON header from the subtree JSON chunk plus\n * the isActive flag and a reference to the header for the underlying buffer\n *\n * @typedef {Object} BufferViewHeader\n * @property {BufferHeader} bufferHeader A reference to the header for the underlying buffer\n * @property {Boolean} isActive Whether this bufferView is currently used.\n * @property {Number} buffer The index of the underlying buffer.\n * @property {Number} byteOffset The start byte of the bufferView within the buffer.\n * @property {Number} byteLength The length of the bufferView. No padding is included in this length.\n * @private\n */\n\n/**\n * Iterate the list of buffer views from the subtree JSON and add the\n * isActive flag. Also save a reference to the bufferHeader\n *\n * @param {Object[]} [bufferViewHeaders=[]] The JSON from subtree.bufferViews\n * @param {BufferHeader[]} bufferHeaders The preprocessed buffer headers\n * @returns {BufferViewHeader[]} The same array of bufferView headers with additional fields\n * @private\n */\nfunction preprocessBufferViews(bufferViewHeaders, bufferHeaders) {\n  bufferViewHeaders = defined(bufferViewHeaders) ? bufferViewHeaders : [];\n  for (let i = 0; i < bufferViewHeaders.length; i++) {\n    const bufferViewHeader = bufferViewHeaders[i];\n    const bufferHeader = bufferHeaders[bufferViewHeader.buffer];\n    bufferViewHeader.bufferHeader = bufferHeader;\n    bufferViewHeader.isActive = false;\n  }\n  return bufferViewHeaders;\n}\n\n/**\n * Determine which buffer views need to be loaded into memory. This includes:\n *\n * <ul>\n * <li>The tile availability bitstream (if a bitstream is defined)</li>\n * <li>The content availability bitstream(s) (if a bitstream is defined)</li>\n * <li>The child subtree availability bitstream (if a bitstream is defined)</li>\n * </ul>\n *\n * <p>\n * This function modifies the buffer view headers' isActive flags in place.\n * </p>\n *\n * @param {Object[]} subtreeJson The JSON chunk from the subtree\n * @param {BufferViewHeader[]} bufferViewHeaders The preprocessed buffer view headers\n * @private\n */\nfunction markActiveBufferViews(subtreeJson, bufferViewHeaders) {\n  let header;\n  const tileAvailabilityHeader = subtreeJson.tileAvailability;\n\n  // Check for bitstream first, which is part of the current schema.\n  // bufferView is the name of the bitstream from an older schema.\n  if (defined(tileAvailabilityHeader.bitstream)) {\n    header = bufferViewHeaders[tileAvailabilityHeader.bitstream];\n  } else if (defined(tileAvailabilityHeader.bufferView)) {\n    header = bufferViewHeaders[tileAvailabilityHeader.bufferView];\n  }\n\n  if (defined(header)) {\n    header.isActive = true;\n    header.bufferHeader.isActive = true;\n  }\n\n  const contentAvailabilityHeaders = subtreeJson.contentAvailabilityHeaders;\n  for (let i = 0; i < contentAvailabilityHeaders.length; i++) {\n    header = undefined;\n    if (defined(contentAvailabilityHeaders[i].bitstream)) {\n      header = bufferViewHeaders[contentAvailabilityHeaders[i].bitstream];\n    } else if (defined(contentAvailabilityHeaders[i].bufferView)) {\n      header = bufferViewHeaders[contentAvailabilityHeaders[i].bufferView];\n    }\n\n    if (defined(header)) {\n      header.isActive = true;\n      header.bufferHeader.isActive = true;\n    }\n  }\n\n  header = undefined;\n  const childSubtreeAvailabilityHeader = subtreeJson.childSubtreeAvailability;\n  if (defined(childSubtreeAvailabilityHeader.bitstream)) {\n    header = bufferViewHeaders[childSubtreeAvailabilityHeader.bitstream];\n  } else if (defined(childSubtreeAvailabilityHeader.bufferView)) {\n    header = bufferViewHeaders[childSubtreeAvailabilityHeader.bufferView];\n  }\n\n  if (defined(header)) {\n    header.isActive = true;\n    header.bufferHeader.isActive = true;\n  }\n}\n\n/**\n * For handling metadata, look over the tile and content metadata buffers\n * <p>\n * This always loads all of the metadata immediately. Future iterations may\n * allow filtering this to avoid downloading unneeded buffers.\n * </p>\n *\n * @param {Object} propertyTableJson The property table JSON for either a tile or some content\n * @param {BufferViewHeader[]} bufferViewHeaders The preprocessed buffer view headers\n * @private\n */\nfunction markActiveMetadataBufferViews(propertyTableJson, bufferViewHeaders) {\n  const properties = propertyTableJson.properties;\n  let header;\n  for (const key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      const metadataHeader = properties[key];\n\n      // An older spec used bufferView\n      const valuesBufferView = defaultValue(\n        metadataHeader.values,\n        metadataHeader.bufferView\n      );\n      header = bufferViewHeaders[valuesBufferView];\n      header.isActive = true;\n      header.bufferHeader.isActive = true;\n\n      // An older spec used stringOffsetBufferView\n      const stringOffsetBufferView = defaultValue(\n        metadataHeader.stringOffsets,\n        metadataHeader.stringOffsetBufferView\n      );\n      if (defined(stringOffsetBufferView)) {\n        header = bufferViewHeaders[stringOffsetBufferView];\n        header.isActive = true;\n        header.bufferHeader.isActive = true;\n      }\n\n      // an older spec used arrayOffsetBufferView\n      const arrayOffsetBufferView = defaultValue(\n        metadataHeader.arrayOffsets,\n        metadataHeader.arrayOffsetBufferView\n      );\n      if (defined(arrayOffsetBufferView)) {\n        header = bufferViewHeaders[arrayOffsetBufferView];\n        header.isActive = true;\n        header.bufferHeader.isActive = true;\n      }\n    }\n  }\n}\n\n/**\n * Go through the list of buffers and gather all the active ones into a\n * a dictionary. Since external buffers are allowed, this sometimes involves\n * fetching separate binary files. Consequently, this method returns a promise.\n * <p>\n * The results are put into a dictionary object. The keys are indices of\n * buffers, and the values are Uint8Arrays of the contents. Only buffers\n * marked with the isActive flag are fetched.\n * </p>\n * <p>\n * The internal buffer (the subtree's binary chunk) is also stored in this\n * dictionary if it is marked active.\n * </p>\n * @param {ImplicitSubtree} subtree The subtree\n * @param {BufferHeader[]} bufferHeaders The preprocessed buffer headers\n * @param {Uint8Array} internalBuffer The binary chunk of the subtree file\n * @returns {Promise<Object>} A promise resolving to the dictionary of active buffers\n * @private\n */\nfunction requestActiveBuffers(subtree, bufferHeaders, internalBuffer) {\n  const promises = [];\n  for (let i = 0; i < bufferHeaders.length; i++) {\n    const bufferHeader = bufferHeaders[i];\n    if (!bufferHeader.isActive) {\n      promises.push(Promise.resolve(undefined));\n    } else if (bufferHeader.isExternal) {\n      const promise = requestExternalBuffer(subtree, bufferHeader);\n      promises.push(promise);\n    } else {\n      promises.push(Promise.resolve(internalBuffer));\n    }\n  }\n  return Promise.all(promises).then(function (bufferResults) {\n    const buffersU8 = {};\n    for (let i = 0; i < bufferResults.length; i++) {\n      const result = bufferResults[i];\n      if (defined(result)) {\n        buffersU8[i] = result;\n      }\n    }\n    return buffersU8;\n  });\n}\n\nfunction requestExternalBuffer(subtree, bufferHeader) {\n  const baseResource = subtree._resource;\n  const bufferResource = baseResource.getDerivedResource({\n    url: bufferHeader.uri,\n  });\n\n  const bufferLoader = ResourceCache.loadExternalBuffer({\n    resource: bufferResource,\n  });\n  subtree._bufferLoader = bufferLoader;\n\n  return bufferLoader.promise.then(function (bufferLoader) {\n    return bufferLoader.typedArray;\n  });\n}\n\n/**\n * Go through the list of buffer views, and if they are marked as active,\n * extract a subarray from one of the active buffers.\n *\n * @param {BufferViewHeader[]} bufferViewHeaders\n * @param {Object} buffersU8 A dictionary of buffer index to a Uint8Array of its contents.\n * @returns {Object} A dictionary of buffer view index to a Uint8Array of its contents.\n * @private\n */\nfunction parseActiveBufferViews(bufferViewHeaders, buffersU8) {\n  const bufferViewsU8 = {};\n  for (let i = 0; i < bufferViewHeaders.length; i++) {\n    const bufferViewHeader = bufferViewHeaders[i];\n\n    if (!bufferViewHeader.isActive) {\n      continue;\n    }\n\n    const start = bufferViewHeader.byteOffset;\n    const end = start + bufferViewHeader.byteLength;\n    const buffer = buffersU8[bufferViewHeader.buffer];\n    const bufferView = buffer.subarray(start, end);\n    bufferViewsU8[i] = bufferView;\n  }\n  return bufferViewsU8;\n}\n\n/**\n * Parse the three availability bitstreams and store them in the subtree\n *\n * @param {ImplicitSubtree} subtree The subtree to modify\n * @param {Object} subtreeJson The subtree JSON\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to\n * @param {Object} bufferViewsU8 A dictionary of buffer view index to a Uint8Array of its contents.\n * @private\n */\nfunction parseAvailability(\n  subtree,\n  subtreeJson,\n  implicitTileset,\n  bufferViewsU8\n) {\n  const branchingFactor = implicitTileset.branchingFactor;\n  const subtreeLevels = implicitTileset.subtreeLevels;\n  const tileAvailabilityBits =\n    (Math.pow(branchingFactor, subtreeLevels) - 1) / (branchingFactor - 1);\n  const childSubtreeBits = Math.pow(branchingFactor, subtreeLevels);\n\n  // availableCount is only needed for the metadata jump buffer, which\n  // corresponds to the tile availability bitstream.\n  const hasMetadataExtension = hasExtension(subtreeJson, \"3DTILES_metadata\");\n  const hasTileMetadata = defined(subtree._tilePropertyTableJson);\n  let computeAvailableCountEnabled = hasMetadataExtension || hasTileMetadata;\n\n  subtree._tileAvailability = parseAvailabilityBitstream(\n    subtreeJson.tileAvailability,\n    bufferViewsU8,\n    tileAvailabilityBits,\n    computeAvailableCountEnabled\n  );\n\n  const hasContentMetadata = subtree._contentPropertyTableJsons.length > 0;\n  computeAvailableCountEnabled =\n    computeAvailableCountEnabled || hasContentMetadata;\n\n  for (let i = 0; i < subtreeJson.contentAvailabilityHeaders.length; i++) {\n    const bitstream = parseAvailabilityBitstream(\n      subtreeJson.contentAvailabilityHeaders[i],\n      bufferViewsU8,\n      // content availability has the same length as tile availability.\n      tileAvailabilityBits,\n      computeAvailableCountEnabled\n    );\n    subtree._contentAvailabilityBitstreams.push(bitstream);\n  }\n\n  subtree._childSubtreeAvailability = parseAvailabilityBitstream(\n    subtreeJson.childSubtreeAvailability,\n    bufferViewsU8,\n    childSubtreeBits\n  );\n}\n\n/**\n * Given the JSON describing an availability bitstream, turn it into an\n * in-memory representation using an {@link ImplicitAvailabilityBitstream}\n * object. This handles both constants and bitstreams from a bufferView.\n *\n * @param {Object} availabilityJson A JSON object representing the availability\n * @param {Object} bufferViewsU8 A dictionary of bufferView index to its Uint8Array contents.\n * @param {Number} lengthBits The length of the availability bitstream in bits\n * @param {Boolean} [computeAvailableCountEnabled] If true and availabilityJson.availableCount is undefined, the availableCount will be computed.\n * @returns {ImplicitAvailabilityBitstream} The parsed bitstream object\n * @private\n */\nfunction parseAvailabilityBitstream(\n  availabilityJson,\n  bufferViewsU8,\n  lengthBits,\n  computeAvailableCountEnabled\n) {\n  if (defined(availabilityJson.constant)) {\n    return new ImplicitAvailabilityBitstream({\n      constant: Boolean(availabilityJson.constant),\n      lengthBits: lengthBits,\n      availableCount: availabilityJson.availableCount,\n    });\n  }\n\n  let bufferView;\n\n  // Check for bitstream first, which is part of the current schema.\n  // bufferView is the name of the bitstream from an older schema.\n  if (defined(availabilityJson.bitstream)) {\n    bufferView = bufferViewsU8[availabilityJson.bitstream];\n  } else if (defined(availabilityJson.bufferView)) {\n    bufferView = bufferViewsU8[availabilityJson.bufferView];\n  }\n\n  return new ImplicitAvailabilityBitstream({\n    bitstream: bufferView,\n    lengthBits: lengthBits,\n    availableCount: availabilityJson.availableCount,\n    computeAvailableCountEnabled: computeAvailableCountEnabled,\n  });\n}\n\n/**\n * Parse the metadata table for the tile metadata, storing a {@link MetadataTable}\n * in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to.\n * @param {Object} bufferViewsU8 A dictionary of bufferView index to its Uint8Array contents.\n * @private\n */\nfunction parseTileMetadataTable(subtree, implicitTileset, bufferViewsU8) {\n  const tilePropertyTableJson = subtree._tilePropertyTableJson;\n  const tileCount = subtree._tileAvailability.availableCount;\n  const metadataSchema = implicitTileset.metadataSchema;\n\n  const tileMetadataClassName = tilePropertyTableJson.class;\n  const tileMetadataClass = metadataSchema.classes[tileMetadataClassName];\n\n  subtree._tileMetadataTable = new MetadataTable({\n    class: tileMetadataClass,\n    count: tileCount,\n    properties: tilePropertyTableJson.properties,\n    bufferViews: bufferViewsU8,\n  });\n}\n\n/**\n * Parse the metadata tables for the content metadata, storing an array of\n * {@link MetadataTable}s in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileset} implicitTileset The implicit tileset this subtree belongs to.\n * @param {Object} bufferViewsU8 A dictionary of bufferView index to its Uint8Array contents.\n * @private\n */\nfunction parseContentMetadataTables(subtree, implicitTileset, bufferViewsU8) {\n  const contentPropertyTableJsons = subtree._contentPropertyTableJsons;\n  const contentAvailabilityBitstreams = subtree._contentAvailabilityBitstreams;\n  const metadataSchema = implicitTileset.metadataSchema;\n\n  const contentMetadataTables = subtree._contentMetadataTables;\n  for (let i = 0; i < contentPropertyTableJsons.length; i++) {\n    const contentPropertyTableJson = contentPropertyTableJsons[i];\n    const contentAvailabilityBitsteam = contentAvailabilityBitstreams[i];\n\n    const contentCount = contentAvailabilityBitsteam.availableCount;\n    const contentMetadataClassName = contentPropertyTableJson.class;\n    const contentMetadataClass =\n      metadataSchema.classes[contentMetadataClassName];\n\n    const metadataTable = new MetadataTable({\n      class: contentMetadataClass,\n      count: contentCount,\n      properties: contentPropertyTableJson.properties,\n      bufferViews: bufferViewsU8,\n    });\n\n    contentMetadataTables.push(metadataTable);\n  }\n}\n\n/**\n * Make a jump buffer, i.e. a map of a bit index to the metadata entity ID.\n * <p>\n * For unavailable tiles and content, the jump buffer entries will be uninitialized.\n * Use the tile and content availability to determine whether a jump buffer value is valid.\n * </p>\n *\n * @param {ImplicitAvailabilityBitstream} availability The availability bitstream to create the jump buffer from.\n * @returns {Array} The resulting jump buffer.\n * @private\n */\nfunction makeJumpBuffer(availability) {\n  let entityId = 0;\n  const bufferLength = availability.lengthBits;\n  const availableCount = availability.availableCount;\n\n  let jumpBuffer;\n  if (availableCount < 256) {\n    jumpBuffer = new Uint8Array(bufferLength);\n  } else if (availableCount < 65536) {\n    jumpBuffer = new Uint16Array(bufferLength);\n  } else {\n    jumpBuffer = new Uint32Array(bufferLength);\n  }\n\n  for (let i = 0; i < availability.lengthBits; i++) {\n    if (availability.getBit(i)) {\n      jumpBuffer[i] = entityId;\n      entityId++;\n    }\n  }\n\n  return jumpBuffer;\n}\n\n/**\n * Make the jump buffer, i.e. a map of a bit index to the metadata entity ID,\n * for the content metadata. This is stored in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @private\n */\nfunction makeTileJumpBuffer(subtree) {\n  const tileJumpBuffer = makeJumpBuffer(subtree._tileAvailability);\n  subtree._tileJumpBuffer = tileJumpBuffer;\n}\n\n/**\n * Make the jump buffers, i.e. maps of bit indices to the metadata entity IDs,\n * for the content metadata. This is stored in the subtree.\n *\n * @param {ImplicitSubtree} subtree The subtree\n * @private\n */\nfunction makeContentJumpBuffers(subtree) {\n  const contentJumpBuffers = subtree._contentJumpBuffers;\n  const contentAvailabilityBitstreams = subtree._contentAvailabilityBitstreams;\n  for (let i = 0; i < contentAvailabilityBitstreams.length; i++) {\n    const contentAvailability = contentAvailabilityBitstreams[i];\n    const contentJumpBuffer = makeJumpBuffer(contentAvailability);\n    contentJumpBuffers.push(contentJumpBuffer);\n  }\n}\n\n/**\n * Given the implicit tiling coordinates for a tile, get the index within the\n * subtree's tile availability bitstream.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @return {Number} The tile's index within the subtree.\n * @private\n */\nImplicitSubtree.prototype.getTileIndex = function (implicitCoordinates) {\n  const localLevel =\n    implicitCoordinates.level - this._implicitCoordinates.level;\n  if (localLevel < 0 || this._subtreeLevels <= localLevel) {\n    throw new RuntimeError(\"level is out of bounds for this subtree\");\n  }\n\n  const subtreeCoordinates = implicitCoordinates.getSubtreeCoordinates();\n  const offsetCoordinates = subtreeCoordinates.getOffsetCoordinates(\n    implicitCoordinates\n  );\n  const index = offsetCoordinates.tileIndex;\n  return index;\n};\n\n/**\n * Given the implicit tiling coordinates for a child subtree, get the index within the\n * subtree's child subtree availability bitstream.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a child subtree\n * @return {Number} The child subtree's index within the subtree's child subtree availability bitstream.\n * @private\n */\nImplicitSubtree.prototype.getChildSubtreeIndex = function (\n  implicitCoordinates\n) {\n  const localLevel =\n    implicitCoordinates.level - this._implicitCoordinates.level;\n  if (localLevel !== this._implicitCoordinates.subtreeLevels) {\n    throw new RuntimeError(\"level is out of bounds for this subtree\");\n  }\n\n  // Call getParentSubtreeCoordinates instead of getSubtreeCoordinates because the\n  // child subtree is by definition the root of its own subtree, so we need to find\n  // the parent subtree.\n  const parentSubtreeCoordinates = implicitCoordinates.getParentSubtreeCoordinates();\n  const offsetCoordinates = parentSubtreeCoordinates.getOffsetCoordinates(\n    implicitCoordinates\n  );\n  const index = offsetCoordinates.mortonIndex;\n  return index;\n};\n\n/**\n * Get the entity ID for a tile within this subtree.\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @return {Number} The entity ID for this tile for accessing tile metadata, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nfunction getTileEntityId(subtree, implicitCoordinates) {\n  if (!defined(subtree._tileMetadataTable)) {\n    return undefined;\n  }\n\n  const tileIndex = subtree.getTileIndex(implicitCoordinates);\n  if (subtree._tileAvailability.getBit(tileIndex)) {\n    return subtree._tileJumpBuffer[tileIndex];\n  }\n\n  return undefined;\n}\n\n/**\n * Get the entity ID for a content within this subtree.\n * @param {ImplicitSubtree} subtree The subtree\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a content\n * @param {Number} contentIndex The content index, for distinguishing between multiple contents.\n * @return {Number} The entity ID for this content for accessing content metadata, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nfunction getContentEntityId(subtree, implicitCoordinates, contentIndex) {\n  const metadataTables = subtree._contentMetadataTables;\n  if (!defined(metadataTables)) {\n    return undefined;\n  }\n\n  const metadataTable = metadataTables[contentIndex];\n  if (!defined(metadataTable)) {\n    return undefined;\n  }\n\n  const availability = subtree._contentAvailabilityBitstreams[contentIndex];\n  const tileIndex = subtree.getTileIndex(implicitCoordinates);\n  if (availability.getBit(tileIndex)) {\n    const contentJumpBuffer = subtree._contentJumpBuffers[contentIndex];\n    return contentJumpBuffer[tileIndex];\n  }\n\n  return undefined;\n}\n\n/**\n * Create and return a metadata table view for a tile within this subtree.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a tile\n * @return {ImplicitMetadataView} The metadata view for this tile, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nImplicitSubtree.prototype.getTileMetadataView = function (implicitCoordinates) {\n  const entityId = getTileEntityId(this, implicitCoordinates);\n  if (!defined(entityId)) {\n    return undefined;\n  }\n\n  const metadataTable = this._tileMetadataTable;\n  return new ImplicitMetadataView({\n    class: metadataTable.class,\n    metadataTable: metadataTable,\n    entityId: entityId,\n    propertyTableJson: this._tilePropertyTableJson,\n  });\n};\n\n/**\n * Create and return a metadata table view for a content within this subtree.\n * @param {ImplicitTileCoordinates} implicitCoordinates The global coordinates of a content\n * @param {Number} contentIndex The index of the content used to distinguish between multiple contents\n * @return {ImplicitMetadataView} The metadata view for this content, or <code>undefined</code> if not applicable.\n *\n * @private\n */\nImplicitSubtree.prototype.getContentMetadataView = function (\n  implicitCoordinates,\n  contentIndex\n) {\n  const entityId = getContentEntityId(this, implicitCoordinates, contentIndex);\n  if (!defined(entityId)) {\n    return undefined;\n  }\n\n  const metadataTable = this._contentMetadataTables[contentIndex];\n  const propertyTableJson = this._contentPropertyTableJsons[contentIndex];\n  return new ImplicitMetadataView({\n    class: metadataTable.class,\n    metadataTable: metadataTable,\n    entityId: entityId,\n    contentIndex: contentIndex,\n    propertyTableJson: propertyTableJson,\n  });\n};\n\n/**\n * @private\n */\nImplicitSubtree.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nImplicitSubtree.prototype.destroy = function () {\n  if (defined(this._bufferLoader)) {\n    ResourceCache.unload(this._bufferLoader);\n  }\n\n  return destroyObject(this);\n};\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataEntity from \"./MetadataEntity.js\";\n\n/**\n * Metadata about an implicit subtree.\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.subtreeMetadata The subtree metadata JSON object.\n * @param {MetadataClass} options.class The class that subtree metadata conforms to.\n *\n * @alias ImplicitSubtreeMetadata\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction ImplicitSubtreeMetadata(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const subtreeMetadata = options.subtreeMetadata;\n  const metadataClass = options.class;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.subtreeMetadata\", subtreeMetadata);\n  Check.typeOf.object(\"options.class\", metadataClass);\n  //>>includeEnd('debug');\n\n  const properties = defined(subtreeMetadata.properties)\n    ? subtreeMetadata.properties\n    : {};\n\n  this._class = metadataClass;\n  this._properties = properties;\n  this._extras = subtreeMetadata.extras;\n  this._extensions = subtreeMetadata.extensions;\n}\n\nObject.defineProperties(ImplicitSubtreeMetadata.prototype, {\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof ImplicitSubtreeMetadata.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    get: function () {\n      return this._class;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof ImplicitSubtreeMetadata.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof ImplicitSubtreeMetadata.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * Returns whether the subtree has this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the subtree has this property.\n * @private\n */\nImplicitSubtreeMetadata.prototype.hasProperty = function (propertyId) {\n  return MetadataEntity.hasProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Returns whether the subtree has a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {Boolean} Whether the subtree has a property with the given semantic.\n * @private\n */\nImplicitSubtreeMetadata.prototype.hasPropertyBySemantic = function (semantic) {\n  return MetadataEntity.hasPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nImplicitSubtreeMetadata.prototype.getPropertyIds = function (results) {\n  return MetadataEntity.getPropertyIds(this._properties, this._class, results);\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the subtree does not have this property.\n * @private\n */\nImplicitSubtreeMetadata.prototype.getProperty = function (propertyId) {\n  return MetadataEntity.getProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nImplicitSubtreeMetadata.prototype.setProperty = function (propertyId, value) {\n  return MetadataEntity.setProperty(\n    propertyId,\n    value,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the subtree does not have this semantic.\n * @private\n */\nImplicitSubtreeMetadata.prototype.getPropertyBySemantic = function (semantic) {\n  return MetadataEntity.getPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nImplicitSubtreeMetadata.prototype.setPropertyBySemantic = function (\n  semantic,\n  value\n) {\n  return MetadataEntity.setPropertyBySemantic(\n    semantic,\n    value,\n    this._properties,\n    this._class\n  );\n};\n\nexport default ImplicitSubtreeMetadata;\n","import CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport MortonOrder from \"../Core/MortonOrder.js\";\nimport ImplicitSubdivisionScheme from \"./ImplicitSubdivisionScheme.js\";\n\n/**\n * The coordinates for a tile in an implicit tileset. The coordinates\n * are (level, x, y) for quadtrees or (level, x, y, z) for octrees.\n * <p>\n * Level numbers are 0-indexed and typically start at the root of the implicit\n * tileset (the tile with either implicitTiling in its JSON (3D Tiles 1.1) or\n * the <code>3DTILES_implicit_tiling</code> extension).\n * This object can also represent the relative offset from one set of coordinates\n * to another. See {@link ImplicitTileCoordinates#getOffsetCoordinates}. The term\n * local coordinates refers to coordinates that are relative to the root of a\n * subtree and the term global coordinates refers to coordinates relative to the\n * root of an implicit tileset.\n * </p>\n * <p>\n * For box bounding volumes, x, y, z increase along the +x, +y, and +z\n * directions defined by the half axes.\n * </p>\n * <p>\n * For region bounding volumes, x increases in the +longitude direction, y\n * increases in the +latitude direction, and z increases in the +height\n * direction.\n * </p>\n * <p>\n * Care must be taken when converting between implicit coordinates and Morton\n * indices because there is a 16-bit limit on {@link MortonOrder#encode2D} and\n * a 10-bit limit on {@link MortonOrder#encode3D}. Typically these conversions\n * should be done on local coordinates, not global coordinates, and the maximum\n * number of levels in the subtree should be 15 for quadtree and 9 for octree (to\n * account for the extra level needed by child subtree coordinates).\n * </p>\n *\n * @alias ImplicitTileCoordinates\n * @constructor\n *\n * @param {Object} options An object with the following properties:\n * @param {ImplicitSubdivisionScheme} options.subdivisionScheme Whether the coordinates are for a quadtree or octree\n * @param {Number} options.subtreeLevels The number of distinct levels within the coordinate's subtree\n * @param {Number} options.level The level of a tile relative to the tile with the extension\n * @param {Number} options.x The x coordinate of the tile\n * @param {Number} options.y The y coordinate of the tile\n * @param {Number} [options.z] The z coordinate of the tile. Only required when options.subdivisionScheme is ImplicitSubdivisionScheme.OCTREE\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function ImplicitTileCoordinates(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.subdivisionScheme\", options.subdivisionScheme);\n  Check.typeOf.number(\"options.subtreeLevels\", options.subtreeLevels);\n  Check.typeOf.number(\"options.level\", options.level);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    Check.typeOf.number(\"options.z\", options.z);\n  }\n  // Check for values that are negative\n  if (options.level < 0) {\n    throw new DeveloperError(\"level must be non-negative\");\n  }\n  if (options.x < 0) {\n    throw new DeveloperError(\"x must be non-negative\");\n  }\n  if (options.y < 0) {\n    throw new DeveloperError(\"y must be non-negative\");\n  }\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    if (options.z < 0) {\n      throw new DeveloperError(\"z must be non-negative\");\n    }\n  }\n\n  // Check for values that are too large\n  const dimensionAtLevel = 1 << options.level;\n  if (options.x >= dimensionAtLevel) {\n    throw new DeveloperError(\"x is out of range\");\n  }\n  if (options.y >= dimensionAtLevel) {\n    throw new DeveloperError(\"y is out of range\");\n  }\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    if (options.z >= dimensionAtLevel) {\n      throw new DeveloperError(\"z is out of range\");\n    }\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * Whether the tileset is a quadtree or octree\n   *\n   * @type {ImplicitSubdivisionScheme}\n   * @readonly\n   * @private\n   */\n  this.subdivisionScheme = options.subdivisionScheme;\n\n  /**\n   * The number of distinct levels within the coordinate's subtree\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  this.subtreeLevels = options.subtreeLevels;\n\n  /**\n   * Level of this tile, relative to the tile with implicit tiling in its JSON\n   * (3D Tiles 1.1) or the <code>3DTILES_implicit_tiling</code> extension.\n   * Level numbers start at 0.\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  this.level = options.level;\n\n  /**\n   * X coordinate of this tile\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  this.x = options.x;\n\n  /**\n   * Y coordinate of this tile\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  this.y = options.y;\n\n  /**\n   * Z coordinate of this tile. Only defined for octrees.\n   *\n   * @type {Number|undefined}\n   * @readonly\n   * @private\n   */\n  this.z = undefined;\n  if (options.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    this.z = options.z;\n  }\n}\n\nObject.defineProperties(ImplicitTileCoordinates.prototype, {\n  /**\n   * An index in the range of [0, branchingFactor) that indicates\n   * which child of the parent cell these coordinates correspond to.\n   * This can be viewed as a morton index within the parent tile.\n   * <p>\n   * This is the last 3 bits of the morton index of the tile, but it can\n   * be computed more directly by concatenating the bits [z0] y0 x0\n   * </p>\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  childIndex: {\n    get: function () {\n      let childIndex = 0;\n      childIndex |= this.x & 1;\n      childIndex |= (this.y & 1) << 1;\n      if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n        childIndex |= (this.z & 1) << 2;\n      }\n\n      return childIndex;\n    },\n  },\n\n  /**\n   * Get the Morton index for this tile within the current level by interleaving\n   * the bits of the x, y and z coordinates.\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  mortonIndex: {\n    get: function () {\n      if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n        return MortonOrder.encode3D(this.x, this.y, this.z);\n      }\n      return MortonOrder.encode2D(this.x, this.y);\n    },\n  },\n\n  /**\n   * Get the tile index by adding the Morton index to the level offset\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  tileIndex: {\n    get: function () {\n      const levelOffset =\n        this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE\n          ? // (8^N - 1) / (8-1)\n            ((1 << (3 * this.level)) - 1) / 7\n          : // (4^N - 1) / (4-1)\n            ((1 << (2 * this.level)) - 1) / 3;\n\n      const mortonIndex = this.mortonIndex;\n      return levelOffset + mortonIndex;\n    },\n  },\n});\n\n/**\n * Check that the two coordinates are compatible\n * @param {ImplicitTileCoordinates} a\n * @param {ImplicitTileCoordinates} b\n * @private\n */\nfunction checkMatchingSubtreeShape(a, b) {\n  if (a.subdivisionScheme !== b.subdivisionScheme) {\n    throw new DeveloperError(\"coordinates must have same subdivisionScheme\");\n  }\n  if (a.subtreeLevels !== b.subtreeLevels) {\n    throw new DeveloperError(\"coordinates must have same subtreeLevels\");\n  }\n}\n\n/**\n * Compute the coordinates of a tile deeper in the tree with a (level, x, y, [z]) relative offset.\n *\n * @param {ImplicitTileCoordinates} offsetCoordinates The offset from the ancestor\n * @returns {ImplicitTileCoordinates} The coordinates of the descendant\n * @private\n */\nImplicitTileCoordinates.prototype.getDescendantCoordinates = function (\n  offsetCoordinates\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"offsetCoordinates\", offsetCoordinates);\n  checkMatchingSubtreeShape(this, offsetCoordinates);\n  //>>includeEnd('debug');\n\n  const descendantLevel = this.level + offsetCoordinates.level;\n  const descendantX = (this.x << offsetCoordinates.level) + offsetCoordinates.x;\n  const descendantY = (this.y << offsetCoordinates.level) + offsetCoordinates.y;\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const descendantZ =\n      (this.z << offsetCoordinates.level) + offsetCoordinates.z;\n\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: descendantLevel,\n      x: descendantX,\n      y: descendantY,\n      z: descendantZ,\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: descendantLevel,\n    x: descendantX,\n    y: descendantY,\n  });\n};\n\n/**\n * Compute the coordinates of a tile higher up in the tree by going up a number of levels.\n *\n * @param {Number} offsetLevels The number of levels to go up in the tree\n * @returns {ImplicitTileCoordinates} The coordinates of the ancestor\n * @private\n */\nImplicitTileCoordinates.prototype.getAncestorCoordinates = function (\n  offsetLevels\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"offsetLevels\", offsetLevels);\n  if (offsetLevels < 0) {\n    throw new DeveloperError(\"offsetLevels must be non-negative\");\n  }\n  if (offsetLevels > this.level) {\n    throw new DeveloperError(\"ancestor cannot be above the tileset root\");\n  }\n  //>>includeEnd('debug');\n\n  const divisor = 1 << offsetLevels;\n  const ancestorLevel = this.level - offsetLevels;\n  const ancestorX = Math.floor(this.x / divisor);\n  const ancestorY = Math.floor(this.y / divisor);\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const ancestorZ = Math.floor(this.z / divisor);\n\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: ancestorLevel,\n      x: ancestorX,\n      y: ancestorY,\n      z: ancestorZ,\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: ancestorLevel,\n    x: ancestorX,\n    y: ancestorY,\n  });\n};\n\n/**\n * Compute the (level, x, y, [z]) offset to a descendant\n *\n * @param {ImplicitTileCoordinates} descendantCoordinates The descendant coordinates\n * @returns {ImplicitTileCoordinates} The offset between the ancestor and the descendant\n */\nImplicitTileCoordinates.prototype.getOffsetCoordinates = function (\n  descendantCoordinates\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"descendantCoordinates\", descendantCoordinates);\n  if (\n    !this.isEqual(descendantCoordinates) &&\n    !this.isAncestor(descendantCoordinates)\n  ) {\n    throw new DeveloperError(\"this is not an ancestor of descendant\");\n  }\n  checkMatchingSubtreeShape(this, descendantCoordinates);\n  //>>includeEnd('debug');\n\n  const offsetLevel = descendantCoordinates.level - this.level;\n  const dimensionAtOffsetLevel = 1 << offsetLevel;\n\n  const offsetX = descendantCoordinates.x % dimensionAtOffsetLevel;\n  const offsetY = descendantCoordinates.y % dimensionAtOffsetLevel;\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const offsetZ = descendantCoordinates.z % dimensionAtOffsetLevel;\n\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: offsetLevel,\n      x: offsetX,\n      y: offsetY,\n      z: offsetZ,\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: offsetLevel,\n    x: offsetX,\n    y: offsetY,\n  });\n};\n\n/**\n * Given the morton index of the child, compute the coordinates of the child.\n * This is a special case of {@link ImplicitTileCoordinates#getDescendantCoordinates}.\n *\n * @param {Number} childIndex The morton index of the child tile relative to its parent\n * @returns {ImplicitTileCoordinates} The tile coordinates of the child\n * @private\n */\nImplicitTileCoordinates.prototype.getChildCoordinates = function (childIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"childIndex\", childIndex);\n  const branchingFactor = ImplicitSubdivisionScheme.getBranchingFactor(\n    this.subdivisionScheme\n  );\n  if (childIndex < 0 || branchingFactor <= childIndex) {\n    throw new DeveloperError(\n      `childIndex must be at least 0 and less than ${branchingFactor}`\n    );\n  }\n  //>>includeEnd('debug');\n\n  const level = this.level + 1;\n  const x = 2 * this.x + (childIndex % 2);\n  const y = 2 * this.y + (Math.floor(childIndex / 2) % 2);\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const z = 2 * this.z + (Math.floor(childIndex / 4) % 2);\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: this.subdivisionScheme,\n      subtreeLevels: this.subtreeLevels,\n      level: level,\n      x: x,\n      y: y,\n      z: z,\n    });\n  }\n\n  // Quadtree\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: this.subdivisionScheme,\n    subtreeLevels: this.subtreeLevels,\n    level: level,\n    x: x,\n    y: y,\n  });\n};\n\n/**\n * Get the coordinates of the subtree that contains this tile. If the tile is\n * the root of the subtree, the root of the subtree is returned.\n *\n * @returns {ImplicitTileCoordinates} The subtree that contains this tile\n * @private\n */\nImplicitTileCoordinates.prototype.getSubtreeCoordinates = function () {\n  return this.getAncestorCoordinates(this.level % this.subtreeLevels);\n};\n\n/**\n * Get the coordinates of the parent subtree that contains this tile\n *\n * @returns {ImplicitTileCoordinates} The parent subtree that contains this tile\n * @private\n */\nImplicitTileCoordinates.prototype.getParentSubtreeCoordinates = function () {\n  return this.getAncestorCoordinates(\n    (this.level % this.subtreeLevels) + this.subtreeLevels\n  );\n};\n\n/**\n * Returns whether this tile is an ancestor of another tile\n *\n * @param {ImplicitTileCoordinates} descendantCoordinates the descendant coordinates\n * @returns {Boolean} <code>true</code> if this tile is an ancestor of the other tile\n * @private\n */\nImplicitTileCoordinates.prototype.isAncestor = function (\n  descendantCoordinates\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"descendantCoordinates\", descendantCoordinates);\n  checkMatchingSubtreeShape(this, descendantCoordinates);\n  //>>includeEnd('debug');\n\n  const levelDifference = descendantCoordinates.level - this.level;\n  if (levelDifference <= 0) {\n    return false;\n  }\n\n  const ancestorX = descendantCoordinates.x >> levelDifference;\n  const ancestorY = descendantCoordinates.y >> levelDifference;\n  const isAncestorX = this.x === ancestorX;\n  const isAncestorY = this.y === ancestorY;\n\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    const ancestorZ = descendantCoordinates.z >> levelDifference;\n    const isAncestorZ = this.z === ancestorZ;\n    return isAncestorX && isAncestorY && isAncestorZ;\n  }\n\n  // Quadtree\n  return isAncestorX && isAncestorY;\n};\n\n/**\n * Returns whether the provided coordinates are equal to this coordinate\n *\n * @param {ImplicitTileCoordinates} otherCoordinates the other coordinates\n * @returns {Boolean} <code>true</code> if the coordinates are equal\n * @private\n */\nImplicitTileCoordinates.prototype.isEqual = function (otherCoordinates) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"otherCoordinates\", otherCoordinates);\n  //>>includeEnd('debug');\n\n  return (\n    this.subdivisionScheme === otherCoordinates.subdivisionScheme &&\n    this.subtreeLevels === otherCoordinates.subtreeLevels &&\n    this.level === otherCoordinates.level &&\n    this.x === otherCoordinates.x &&\n    this.y === otherCoordinates.y &&\n    (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE\n      ? this.z === otherCoordinates.z\n      : true)\n  );\n};\n\n/**\n * Returns whether this tile is the root of the implicit tileset\n *\n * @returns {Boolean} <code>true</code> if this tile is the root\n * @private\n */\nImplicitTileCoordinates.prototype.isImplicitTilesetRoot = function () {\n  return this.level === 0;\n};\n\n/**\n * Returns whether this tile is the root of the subtree\n *\n * @returns {Boolean} <code>true</code> if this tile is the root of the subtree\n * @private\n */\nImplicitTileCoordinates.prototype.isSubtreeRoot = function () {\n  return this.level % this.subtreeLevels === 0;\n};\n\n/**\n * Returns whether this tile is on the last row of tiles in the subtree\n *\n * @returns {Boolean} <code>true</code> if this tile is on the last row of tiles in the subtree\n * @private\n */\nImplicitTileCoordinates.prototype.isBottomOfSubtree = function () {\n  return this.level % this.subtreeLevels === this.subtreeLevels - 1;\n};\n\n/**\n * Get a dictionary of values for templating into an implicit template URI.\n *\n * @returns {Object} An object suitable for use with {@link Resource#getDerivedResource}\n * @private\n */\nImplicitTileCoordinates.prototype.getTemplateValues = function () {\n  const values = {\n    level: this.level,\n    x: this.x,\n    y: this.y,\n  };\n  if (this.subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    values.z = this.z;\n  }\n\n  return values;\n};\n\nconst scratchCoordinatesArray = [0, 0, 0];\n\n/**\n * Given a level number, morton index, and whether the tileset is an\n * octree/quadtree, compute the (level, x, y, [z]) coordinates\n *\n * @param {ImplicitSubdivisionScheme} subdivisionScheme Whether the coordinates are for a quadtree or octree\n * @param {Number} subtreeLevels The number of distinct levels within the coordinate's subtree\n * @param {Number} level The level of the tree\n * @param {Number} mortonIndex The morton index of the tile.\n * @returns {ImplicitTileCoordinates} The coordinates of the tile with the given Morton index\n * @private\n */\nImplicitTileCoordinates.fromMortonIndex = function (\n  subdivisionScheme,\n  subtreeLevels,\n  level,\n  mortonIndex\n) {\n  let coordinatesArray;\n  if (subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    coordinatesArray = MortonOrder.decode3D(\n      mortonIndex,\n      scratchCoordinatesArray\n    );\n    return new ImplicitTileCoordinates({\n      subdivisionScheme: subdivisionScheme,\n      subtreeLevels: subtreeLevels,\n      level: level,\n      x: coordinatesArray[0],\n      y: coordinatesArray[1],\n      z: coordinatesArray[2],\n    });\n  }\n\n  coordinatesArray = MortonOrder.decode2D(mortonIndex, scratchCoordinatesArray);\n  return new ImplicitTileCoordinates({\n    subdivisionScheme: subdivisionScheme,\n    subtreeLevels: subtreeLevels,\n    level: level,\n    x: coordinatesArray[0],\n    y: coordinatesArray[1],\n  });\n};\n\n/**\n * Given a tile index and whether the tileset is an octree/quadtree, compute\n * the (level, x, y, [z]) coordinates\n *\n * @param {ImplicitSubdivisionScheme} subdivisionScheme Whether the coordinates are for a quadtree or octree\n * @param {Number} subtreeLevels The number of distinct levels within the coordinate's subtree\n * @param {Number} tileIndex The tile's index\n * @returns {ImplicitTileCoordinates} The coordinates of the tile with the given tile index\n * @private\n */\nImplicitTileCoordinates.fromTileIndex = function (\n  subdivisionScheme,\n  subtreeLevels,\n  tileIndex\n) {\n  let level;\n  let levelOffset;\n  let mortonIndex;\n\n  if (subdivisionScheme === ImplicitSubdivisionScheme.OCTREE) {\n    // Node count up to octree level: (8^L - 1) / (8-1)\n    // (8^L - 1) / (8-1) <= X < (8^(L+1) - 1) / (8-1)\n    // 8^L <= (7x + 1) < 8^(L+1)\n    // L <= log8(7x + 1) < L + 1\n    // L = floor(log8(7x + 1))\n    // L = floor(log2(7x + 1) / log2(8))\n    // L = floor(log2(7x + 1) / 3)\n    level = Math.floor(CesiumMath.log2(7 * tileIndex + 1) / 3);\n    levelOffset = ((1 << (3 * level)) - 1) / 7;\n    mortonIndex = tileIndex - levelOffset;\n  } else {\n    // Node count up to quadtree level: (4^L - 1) / (4-1)\n    // (4^L - 1) / (4-1) <= X < (4^(L+1) - 1) / (4-1)\n    // 4^L <= (3x + 1) < 4^(L+1)\n    // L <= log4(3x + 1) < L + 1\n    // L = floor(log4(3x + 1))\n    // L = floor(log2(3x + 1) / log2(4))\n    // L = floor(log2(3x + 1) / 2)\n    level = Math.floor(CesiumMath.log2(3 * tileIndex + 1) / 2);\n    levelOffset = ((1 << (2 * level)) - 1) / 3;\n    mortonIndex = tileIndex - levelOffset;\n  }\n\n  return ImplicitTileCoordinates.fromMortonIndex(\n    subdivisionScheme,\n    subtreeLevels,\n    level,\n    mortonIndex\n  );\n};\n","import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport hasExtension from \"./hasExtension.js\";\nimport ImplicitSubdivisionScheme from \"./ImplicitSubdivisionScheme.js\";\n\n/**\n * An ImplicitTileset is a simple struct that stores information about the\n * structure of a single implicit tileset. This includes template URIs for\n * locating resources, details from the implicit root tile (bounding volume,\n * geometricError, etc.), and details about the subtrees (e.g. subtreeLevels,\n * subdivisionScheme).\n *\n * @alias ImplicitTileset\n * @constructor\n *\n * @param {Resource} baseResource The base resource for the tileset\n * @param {Object} tileJson The JSON header of the tile with either implicit tiling (3D Tiles 1.1) or the 3DTILES_implicit_tiling extension.\n * @param {MetadataSchema} [metadataSchema] The metadata schema containing the implicit tile metadata class.\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function ImplicitTileset(\n  baseResource,\n  tileJson,\n  metadataSchema\n) {\n  const implicitTiling = hasExtension(tileJson, \"3DTILES_implicit_tiling\")\n    ? tileJson.extensions[\"3DTILES_implicit_tiling\"]\n    : tileJson.implicitTiling;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"implicitTiling\", implicitTiling);\n  //>>includeEnd('debug');\n\n  /**\n   * The base resource for the tileset. This is stored here as it is needed\n   * later when expanding Implicit3DTileContents so tile URLs are relative\n   * to the tileset, not the subtree file.\n   *\n   * @type {Resource}\n   * @readonly\n   * @private\n   */\n  this.baseResource = baseResource;\n\n  /**\n   * The geometric error of the root tile\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  this.geometricError = tileJson.geometricError;\n\n  /**\n   * The metadata schema containing the implicit tile metadata class.\n   *\n   * @type {MetadataSchema|undefined}\n   * @readonly\n   * @private\n   */\n  this.metadataSchema = metadataSchema;\n\n  const boundingVolume = tileJson.boundingVolume;\n  if (\n    !defined(boundingVolume.box) &&\n    !defined(boundingVolume.region) &&\n    !hasExtension(boundingVolume, \"3DTILES_bounding_volume_S2\")\n  ) {\n    throw new RuntimeError(\n      \"Only box, region and 3DTILES_bounding_volume_S2 are supported for implicit tiling\"\n    );\n  }\n\n  /**\n   * The JSON representation of a bounding volume. This is either a box or a\n   * region.\n   *\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  this.boundingVolume = boundingVolume;\n\n  /**\n   * The refine strategy as a string, either 'ADD' or 'REPLACE'\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  this.refine = tileJson.refine;\n\n  /**\n   * Template URI for the subtree resources, e.g.\n   * <code>https://example.com/{level}/{x}/{y}.subtree</code>\n   *\n   * @type {Resource}\n   * @readonly\n   * @private\n   */\n\n  this.subtreeUriTemplate = new Resource({ url: implicitTiling.subtrees.uri });\n\n  /**\n   * Template URIs for locating content resources, e.g.\n   * <code>https://example.com/{level}/{x}/{y}.b3dm</code>.\n   * <p>\n   * This is an array to support multiple contents.\n   * </p>\n   *\n   * @type {Resource[]}\n   * @readonly\n   * @private\n   */\n  this.contentUriTemplates = [];\n\n  /**\n   * Store a copy of the content headers, so properties such as\n   * <code>extras</code> or <code>extensions</code> are preserved when\n   * {@link Cesium3DTile}s are created for each tile.\n   * <p>\n   * This is an array to support multiple contents.\n   * </p>\n   *\n   * @type {Object[]}\n   * @readonly\n   * @private\n   */\n  this.contentHeaders = [];\n\n  const contentHeaders = gatherContentHeaders(tileJson);\n  for (let i = 0; i < contentHeaders.length; i++) {\n    const contentHeader = contentHeaders[i];\n    this.contentHeaders.push(clone(contentHeader, true));\n    const contentResource = new Resource({ url: contentHeader.uri });\n    this.contentUriTemplates.push(contentResource);\n  }\n\n  /**\n   * The maximum number of contents as well as content availability bitstreams.\n   * This is used for loop bounds when checking content availability.\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  this.contentCount = this.contentHeaders.length;\n\n  /**\n   * Stores a copy of the root implicit tile's JSON header. This is used\n   * as a template for creating {@link Cesium3DTile}s. The following properties\n   * are removed:\n   *\n   * <ul>\n   * <li><code>tile.implicitTiling</code> to prevent infinite loops of implicit tiling</li>\n   * <li><code>tile.extensions[\"3DTILES_implicit_tiling\"]</code>, if used instead of tile.implicitTiling</li>\n   * <li><code>tile.contents</code>, since contents are handled separately</li>\n   * <li><code>tile.content</code>, if used instead of tile.contents</li>\n   * <li><code>tile.extensions[\"3DTILES_multiple_contents\"]</code>, if used instead of tile.contents or tile.content</li>\n   * </ul>\n   *\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  this.tileHeader = makeTileHeaderTemplate(tileJson);\n\n  /**\n   * The subdivision scheme for this implicit tileset; either OCTREE or QUADTREE\n   *\n   * @type {ImplicitSubdivisionScheme}\n   * @readonly\n   * @private\n   */\n  this.subdivisionScheme =\n    ImplicitSubdivisionScheme[implicitTiling.subdivisionScheme];\n\n  /**\n   * The branching factor for this tileset. Either 4 for quadtrees or 8 for\n   * octrees.\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  this.branchingFactor = ImplicitSubdivisionScheme.getBranchingFactor(\n    this.subdivisionScheme\n  );\n\n  /**\n   * How many distinct levels within each subtree. For example, a quadtree\n   * with subtreeLevels = 2 will have 5 nodes per quadtree (1 root + 4 children)\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  this.subtreeLevels = implicitTiling.subtreeLevels;\n\n  /**\n   * The number of levels containing available tiles in the tileset.\n   *\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  if (defined(implicitTiling.availableLevels)) {\n    this.availableLevels = implicitTiling.availableLevels;\n  } else {\n    this.availableLevels = implicitTiling.maximumLevel + 1;\n  }\n}\n\n/**\n * Gather JSON headers for all contents in the tile.\n * This handles both regular tiles and tiles with multiple contents, either\n * in the contents array (3D Tiles 1.1) or the `3DTILES_multiple_contents` extension\n *\n * @param {Object} tileJson The JSON header of the tile with either implicit tiling (3D Tiles 1.1) or the 3DTILES_implicit_tiling extension.\n * @return {Object[]} An array of JSON headers for the contents of each tile\n * @private\n */\nfunction gatherContentHeaders(tileJson) {\n  if (hasExtension(tileJson, \"3DTILES_multiple_contents\")) {\n    const extension = tileJson.extensions[\"3DTILES_multiple_contents\"];\n    return defined(extension.contents) ? extension.contents : extension.content;\n  }\n\n  if (defined(tileJson.contents)) {\n    return tileJson.contents;\n  }\n\n  if (defined(tileJson.content)) {\n    return [tileJson.content];\n  }\n\n  return [];\n}\n\nfunction makeTileHeaderTemplate(tileJson) {\n  const template = clone(tileJson, true);\n\n  // Remove the implicit tiling extension to prevent infinite loops,\n  // as well as content-related properties since content is handled separately\n  if (defined(template.extensions)) {\n    delete template.extensions[\"3DTILES_implicit_tiling\"];\n    delete template.extensions[\"3DTILES_multiple_contents\"];\n\n    // if there are no other extensions, remove the extensions property to\n    // keep each tile simple\n    if (Object.keys(template.extensions).length === 0) {\n      delete template.extensions;\n    }\n  }\n\n  delete template.implicitTiling;\n  delete template.contents;\n  delete template.content;\n\n  return template;\n}\n","import Check from \"../Core/Check.js\";\n\n/**\n * An enum describing the built-in instance attribute semantics.\n *\n * @enum {String}\n *\n * @private\n */\nconst InstanceAttributeSemantic = {\n  /**\n   * Per-instance translation.\n   *\n   * @type {String}\n   * @constant\n   */\n  TRANSLATION: \"TRANSLATION\",\n\n  /**\n   * Per-instance rotation.\n   *\n   * @type {String}\n   * @constant\n   */\n  ROTATION: \"ROTATION\",\n\n  /**\n   * Per-instance scale.\n   *\n   * @type {String}\n   * @constant\n   */\n  SCALE: \"SCALE\",\n\n  /**\n   * Per-instance feature ID.\n   *\n   * @type {String}\n   * @constant\n   */\n  FEATURE_ID: \"_FEATURE_ID\",\n};\n\n/**\n * Gets the instance attribute semantic matching the glTF attribute semantic.\n *\n * @returns {InstanceAttributeSemantic} The instance attribute semantic, or undefined if there is no match.\n *\n * @private\n */\nInstanceAttributeSemantic.fromGltfSemantic = function (gltfSemantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"gltfSemantic\", gltfSemantic);\n  //>>includeEnd('debug')\n\n  let semantic = gltfSemantic;\n\n  // Strip the set index from the semantic\n  const setIndexRegex = /^(\\w+)_\\d+$/;\n  const setIndexMatch = setIndexRegex.exec(gltfSemantic);\n  if (setIndexMatch !== null) {\n    semantic = setIndexMatch[1];\n  }\n\n  switch (semantic) {\n    case \"TRANSLATION\":\n      return InstanceAttributeSemantic.TRANSLATION;\n    case \"ROTATION\":\n      return InstanceAttributeSemantic.ROTATION;\n    case \"SCALE\":\n      return InstanceAttributeSemantic.SCALE;\n    case \"_FEATURE_ID\":\n      return InstanceAttributeSemantic.FEATURE_ID;\n  }\n\n  return undefined;\n};\n\nexport default Object.freeze(InstanceAttributeSemantic);\n","import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport deprecationWarning from \"../Core/deprecationWarning.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport RequestType from \"../Core/RequestType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport TranslationRotationScale from \"../Core/TranslationRotationScale.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport Axis from \"./Axis.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport I3dmParser from \"./I3dmParser.js\";\nimport ModelInstanceCollection from \"./ModelInstanceCollection.js\";\nimport ModelAnimationLoop from \"./ModelAnimationLoop.js\";\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Instanced3DModel|Instanced 3D Model}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n *\n * @alias Instanced3DModel3DTileContent\n * @constructor\n *\n * @private\n */\nfunction Instanced3DModel3DTileContent(\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset\n) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n  this._modelInstanceCollection = undefined;\n\n  this._metadata = undefined;\n\n  this._batchTable = undefined;\n  this._features = undefined;\n\n  this.featurePropertiesDirty = false;\n  this._group = undefined;\n\n  initialize(this, arrayBuffer, byteOffset);\n}\n\n// This can be overridden for testing purposes\nInstanced3DModel3DTileContent._deprecationWarning = deprecationWarning;\n\nObject.defineProperties(Instanced3DModel3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      return this._batchTable.featuresLength;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      const model = this._modelInstanceCollection._model;\n      if (defined(model)) {\n        return model.trianglesLength;\n      }\n      return 0;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      const model = this._modelInstanceCollection._model;\n      if (defined(model)) {\n        return model.geometryByteLength;\n      }\n      return 0;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      const model = this._modelInstanceCollection._model;\n      if (defined(model)) {\n        return model.texturesByteLength;\n      }\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return this._batchTable.memorySizeInBytes;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._modelInstanceCollection.readyPromise;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      return this._batchTable;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\nfunction getPickIdCallback(content) {\n  return function () {\n    return content._batchTable.getPickId();\n  };\n}\n\nconst propertyScratch1 = new Array(4);\nconst propertyScratch2 = new Array(4);\n\nfunction initialize(content, arrayBuffer, byteOffset) {\n  const i3dm = I3dmParser.parse(arrayBuffer, byteOffset);\n\n  const gltfFormat = i3dm.gltfFormat;\n  const gltfView = i3dm.gltf;\n  const featureTableJson = i3dm.featureTableJson;\n  const featureTableBinary = i3dm.featureTableBinary;\n  const batchTableJson = i3dm.batchTableJson;\n  const batchTableBinary = i3dm.batchTableBinary;\n\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary\n  );\n  const instancesLength = featureTable.getGlobalProperty(\"INSTANCES_LENGTH\");\n  featureTable.featuresLength = instancesLength;\n\n  if (!defined(instancesLength)) {\n    throw new RuntimeError(\n      \"Feature table global property: INSTANCES_LENGTH must be defined\"\n    );\n  }\n\n  content._batchTable = new Cesium3DTileBatchTable(\n    content,\n    instancesLength,\n    batchTableJson,\n    batchTableBinary\n  );\n\n  const tileset = content._tileset;\n\n  // Create model instance collection\n  const collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: content._batchTable,\n    cull: false, // Already culled by 3D Tiles\n    url: undefined,\n    requestType: RequestType.TILES3D,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    upAxis: tileset._gltfUpAxis,\n    forwardAxis: Axis.X,\n    opaquePass: Pass.CESIUM_3D_TILE, // Draw opaque portions during the 3D Tiles pass\n    pickIdLoaded: getPickIdCallback(content),\n    imageBasedLighting: tileset.imageBasedLighting,\n    backFaceCulling: tileset.backFaceCulling,\n    showOutline: tileset.showOutline,\n    showCreditsOnScreen: tileset.showCreditsOnScreen,\n  };\n\n  if (gltfFormat === 0) {\n    let gltfUrl = getStringFromTypedArray(gltfView);\n\n    // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n    // This removes all white space and null characters from the end of the string.\n    gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, \"\");\n    collectionOptions.url = content._resource.getDerivedResource({\n      url: gltfUrl,\n    });\n  } else {\n    collectionOptions.gltf = gltfView;\n    collectionOptions.basePath = content._resource.clone();\n  }\n\n  const eastNorthUp = featureTable.getGlobalProperty(\"EAST_NORTH_UP\");\n\n  let rtcCenter;\n  const rtcCenterArray = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n  if (defined(rtcCenterArray)) {\n    rtcCenter = Cartesian3.unpack(rtcCenterArray);\n  }\n\n  const instances = collectionOptions.instances;\n  const instancePosition = new Cartesian3();\n  const instancePositionArray = new Array(3);\n  const instanceNormalRight = new Cartesian3();\n  const instanceNormalUp = new Cartesian3();\n  const instanceNormalForward = new Cartesian3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  let instanceScale = new Cartesian3();\n  const instanceTranslationRotationScale = new TranslationRotationScale();\n  const instanceTransform = new Matrix4();\n  for (let i = 0; i < instancesLength; i++) {\n    // Get the instance position\n    let position = featureTable.getProperty(\n      \"POSITION\",\n      ComponentDatatype.FLOAT,\n      3,\n      i,\n      propertyScratch1\n    );\n    if (!defined(position)) {\n      position = instancePositionArray;\n      const positionQuantized = featureTable.getProperty(\n        \"POSITION_QUANTIZED\",\n        ComponentDatatype.UNSIGNED_SHORT,\n        3,\n        i,\n        propertyScratch1\n      );\n      if (!defined(positionQuantized)) {\n        throw new RuntimeError(\n          \"Either POSITION or POSITION_QUANTIZED must be defined for each instance.\"\n        );\n      }\n      const quantizedVolumeOffset = featureTable.getGlobalProperty(\n        \"QUANTIZED_VOLUME_OFFSET\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      if (!defined(quantizedVolumeOffset)) {\n        throw new RuntimeError(\n          \"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\"\n        );\n      }\n      const quantizedVolumeScale = featureTable.getGlobalProperty(\n        \"QUANTIZED_VOLUME_SCALE\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      if (!defined(quantizedVolumeScale)) {\n        throw new RuntimeError(\n          \"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\"\n        );\n      }\n      for (let j = 0; j < 3; j++) {\n        position[j] =\n          (positionQuantized[j] / 65535.0) * quantizedVolumeScale[j] +\n          quantizedVolumeOffset[j];\n      }\n    }\n    Cartesian3.unpack(position, 0, instancePosition);\n    if (defined(rtcCenter)) {\n      Cartesian3.add(instancePosition, rtcCenter, instancePosition);\n    }\n    instanceTranslationRotationScale.translation = instancePosition;\n\n    // Get the instance rotation\n    const normalUp = featureTable.getProperty(\n      \"NORMAL_UP\",\n      ComponentDatatype.FLOAT,\n      3,\n      i,\n      propertyScratch1\n    );\n    const normalRight = featureTable.getProperty(\n      \"NORMAL_RIGHT\",\n      ComponentDatatype.FLOAT,\n      3,\n      i,\n      propertyScratch2\n    );\n    let hasCustomOrientation = false;\n    if (defined(normalUp)) {\n      if (!defined(normalRight)) {\n        throw new RuntimeError(\n          \"To define a custom orientation, both NORMAL_UP and NORMAL_RIGHT must be defined.\"\n        );\n      }\n      Cartesian3.unpack(normalUp, 0, instanceNormalUp);\n      Cartesian3.unpack(normalRight, 0, instanceNormalRight);\n      hasCustomOrientation = true;\n    } else {\n      const octNormalUp = featureTable.getProperty(\n        \"NORMAL_UP_OCT32P\",\n        ComponentDatatype.UNSIGNED_SHORT,\n        2,\n        i,\n        propertyScratch1\n      );\n      const octNormalRight = featureTable.getProperty(\n        \"NORMAL_RIGHT_OCT32P\",\n        ComponentDatatype.UNSIGNED_SHORT,\n        2,\n        i,\n        propertyScratch2\n      );\n      if (defined(octNormalUp)) {\n        if (!defined(octNormalRight)) {\n          throw new RuntimeError(\n            \"To define a custom orientation with oct-encoded vectors, both NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P must be defined.\"\n          );\n        }\n        AttributeCompression.octDecodeInRange(\n          octNormalUp[0],\n          octNormalUp[1],\n          65535,\n          instanceNormalUp\n        );\n        AttributeCompression.octDecodeInRange(\n          octNormalRight[0],\n          octNormalRight[1],\n          65535,\n          instanceNormalRight\n        );\n        hasCustomOrientation = true;\n      } else if (eastNorthUp) {\n        Transforms.eastNorthUpToFixedFrame(\n          instancePosition,\n          Ellipsoid.WGS84,\n          instanceTransform\n        );\n        Matrix4.getMatrix3(instanceTransform, instanceRotation);\n      } else {\n        Matrix3.clone(Matrix3.IDENTITY, instanceRotation);\n      }\n    }\n    if (hasCustomOrientation) {\n      Cartesian3.cross(\n        instanceNormalRight,\n        instanceNormalUp,\n        instanceNormalForward\n      );\n      Cartesian3.normalize(instanceNormalForward, instanceNormalForward);\n      Matrix3.setColumn(\n        instanceRotation,\n        0,\n        instanceNormalRight,\n        instanceRotation\n      );\n      Matrix3.setColumn(\n        instanceRotation,\n        1,\n        instanceNormalUp,\n        instanceRotation\n      );\n      Matrix3.setColumn(\n        instanceRotation,\n        2,\n        instanceNormalForward,\n        instanceRotation\n      );\n    }\n    Quaternion.fromRotationMatrix(instanceRotation, instanceQuaternion);\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n\n    // Get the instance scale\n    instanceScale = Cartesian3.fromElements(1.0, 1.0, 1.0, instanceScale);\n    const scale = featureTable.getProperty(\n      \"SCALE\",\n      ComponentDatatype.FLOAT,\n      1,\n      i\n    );\n    if (defined(scale)) {\n      Cartesian3.multiplyByScalar(instanceScale, scale, instanceScale);\n    }\n    const nonUniformScale = featureTable.getProperty(\n      \"SCALE_NON_UNIFORM\",\n      ComponentDatatype.FLOAT,\n      3,\n      i,\n      propertyScratch1\n    );\n    if (defined(nonUniformScale)) {\n      instanceScale.x *= nonUniformScale[0];\n      instanceScale.y *= nonUniformScale[1];\n      instanceScale.z *= nonUniformScale[2];\n    }\n    instanceTranslationRotationScale.scale = instanceScale;\n\n    // Get the batchId\n    let batchId = featureTable.getProperty(\n      \"BATCH_ID\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1,\n      i\n    );\n    if (!defined(batchId)) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n\n    // Create the model matrix and the instance\n    Matrix4.fromTranslationRotationScale(\n      instanceTranslationRotationScale,\n      instanceTransform\n    );\n    const modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix: modelMatrix,\n      batchId: batchId,\n    };\n  }\n\n  content._modelInstanceCollection = new ModelInstanceCollection(\n    collectionOptions\n  );\n  content._modelInstanceCollection.readyPromise\n    .catch(function () {\n      // Any readyPromise failure is handled in modelInstanceCollection\n    })\n    .then(function (collection) {\n      if (content._modelInstanceCollection.ready) {\n        collection.activeAnimations.addAll({\n          loop: ModelAnimationLoop.REPEAT,\n        });\n      }\n    });\n}\n\nfunction createFeatures(content) {\n  const featuresLength = content.featuresLength;\n  if (!defined(content._features) && featuresLength > 0) {\n    const features = new Array(featuresLength);\n    for (let i = 0; i < featuresLength; ++i) {\n      features[i] = new Cesium3DTileFeature(content, i);\n    }\n    content._features = features;\n  }\n}\n\nInstanced3DModel3DTileContent.prototype.hasProperty = function (batchId, name) {\n  return this._batchTable.hasProperty(batchId, name);\n};\n\nInstanced3DModel3DTileContent.prototype.getFeature = function (batchId) {\n  const featuresLength = this.featuresLength;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(batchId) || batchId < 0 || batchId >= featuresLength) {\n    throw new DeveloperError(\n      `batchId is required and between zero and featuresLength - 1 (${\n        featuresLength - 1\n      }).`\n    );\n  }\n  //>>includeEnd('debug');\n\n  createFeatures(this);\n  return this._features[batchId];\n};\n\nInstanced3DModel3DTileContent.prototype.applyDebugSettings = function (\n  enabled,\n  color\n) {\n  color = enabled ? color : Color.WHITE;\n  this._batchTable.setAllColor(color);\n};\n\nInstanced3DModel3DTileContent.prototype.applyStyle = function (style) {\n  this._batchTable.applyStyle(style);\n};\n\nInstanced3DModel3DTileContent.prototype.update = function (\n  tileset,\n  frameState\n) {\n  const commandStart = frameState.commandList.length;\n\n  // In the PROCESSING state we may be calling update() to move forward\n  // the content's resource loading.  In the READY state, it will\n  // actually generate commands.\n  this._batchTable.update(tileset, frameState);\n  this._modelInstanceCollection.modelMatrix = this._tile.computedTransform;\n  this._modelInstanceCollection.shadows = this._tileset.shadows;\n  this._modelInstanceCollection.lightColor = this._tileset.lightColor;\n  this._modelInstanceCollection.imageBasedLighting = this._tileset.imageBasedLighting;\n  this._modelInstanceCollection.backFaceCulling = this._tileset.backFaceCulling;\n  this._modelInstanceCollection.debugWireframe = this._tileset.debugWireframe;\n  this._modelInstanceCollection.showCreditsOnScreen = this._tileset.showCreditsOnScreen;\n  this._modelInstanceCollection.splitDirection = this._tileset.splitDirection;\n\n  const model = this._modelInstanceCollection._model;\n\n  if (defined(model)) {\n    // Update for clipping planes\n    const tilesetClippingPlanes = this._tileset.clippingPlanes;\n    model.referenceMatrix = this._tileset.clippingPlanesOriginMatrix;\n    if (defined(tilesetClippingPlanes) && this._tile.clippingPlanesDirty) {\n      // Dereference the clipping planes from the model if they are irrelevant - saves on shading\n      // Link/Dereference directly to avoid ownership checks.\n      model._clippingPlanes =\n        tilesetClippingPlanes.enabled && this._tile._isClipped\n          ? tilesetClippingPlanes\n          : undefined;\n    }\n\n    // If the model references a different ClippingPlaneCollection due to the tileset's collection being replaced with a\n    // ClippingPlaneCollection that gives this tile the same clipping status, update the model to use the new ClippingPlaneCollection.\n    if (\n      defined(tilesetClippingPlanes) &&\n      defined(model._clippingPlanes) &&\n      model._clippingPlanes !== tilesetClippingPlanes\n    ) {\n      model._clippingPlanes = tilesetClippingPlanes;\n    }\n  }\n\n  this._modelInstanceCollection.update(frameState);\n\n  // If any commands were pushed, add derived commands\n  const commandEnd = frameState.commandList.length;\n  if (\n    commandStart < commandEnd &&\n    (frameState.passes.render || frameState.passes.pick)\n  ) {\n    this._batchTable.addDerivedCommands(frameState, commandStart, false);\n  }\n};\n\nInstanced3DModel3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nInstanced3DModel3DTileContent.prototype.destroy = function () {\n  this._modelInstanceCollection =\n    this._modelInstanceCollection && this._modelInstanceCollection.destroy();\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n\n  return destroyObject(this);\n};\nexport default Instanced3DModel3DTileContent;\n","import Color from \"../Core/Color.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport FramebufferManager from \"../Renderer/FramebufferManager.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Renderbuffer from \"../Renderer/Renderbuffer.js\";\nimport RenderbufferFormat from \"../Renderer/RenderbufferFormat.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport PassThrough from \"../Shaders/PostProcessStages/PassThrough.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\n\n/**\n * @private\n */\nfunction InvertClassification() {\n  this._numSamples = 1;\n  this.previousFramebuffer = undefined;\n  this._previousFramebuffer = undefined;\n\n  this._depthStencilTexture = undefined;\n  this._depthStencilRenderbuffer = undefined;\n  this._fbo = new FramebufferManager({\n    depthStencil: true,\n    createDepthAttachments: false,\n  });\n  this._fboClassified = new FramebufferManager({\n    depthStencil: true,\n    createDepthAttachments: false,\n  });\n\n  this._rsUnclassified = undefined;\n  this._rsClassified = undefined;\n\n  this._unclassifiedCommand = undefined;\n  this._classifiedCommand = undefined;\n  this._translucentCommand = undefined;\n\n  this._clearColorCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    owner: this,\n  });\n  this._clearCommand = new ClearCommand({\n    color: new Color(0.0, 0.0, 0.0, 0.0),\n    depth: 1.0,\n    stencil: 0,\n  });\n\n  const that = this;\n  this._uniformMap = {\n    colorTexture: function () {\n      return that._fbo.getColorTexture();\n    },\n    depthTexture: function () {\n      return that._depthStencilTexture;\n    },\n    classifiedTexture: function () {\n      return that._fboClassified.getColorTexture();\n    },\n  };\n}\n\nObject.defineProperties(InvertClassification.prototype, {\n  unclassifiedCommand: {\n    get: function () {\n      return this._unclassifiedCommand;\n    },\n  },\n});\n\nInvertClassification.isTranslucencySupported = function (context) {\n  return context.depthTexture && context.fragmentDepth;\n};\n\nconst rsUnclassified = {\n  depthMask: false,\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.EQUAL,\n    frontOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.KEEP,\n    },\n    backFunction: StencilFunction.NEVER,\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  blending: BlendingState.ALPHA_BLEND,\n};\n\nconst rsClassified = {\n  depthMask: false,\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.KEEP,\n      zFail: StencilOperation.KEEP,\n      zPass: StencilOperation.KEEP,\n    },\n    backFunction: StencilFunction.NEVER,\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  blending: BlendingState.ALPHA_BLEND,\n};\n\n// Set the 3D Tiles bit when rendering back into the scene's framebuffer. This is only needed if\n// invert classification does not use the scene's depth-stencil texture, which is the case if the invert\n// classification color is translucent.\nconst rsDefault = {\n  depthMask: true,\n  depthTest: {\n    enabled: true,\n  },\n  stencilTest: StencilConstants.setCesium3DTileBit(),\n  stencilMask: StencilConstants.CESIUM_3D_TILE_MASK,\n  blending: BlendingState.ALPHA_BLEND,\n};\n\nconst translucentFS =\n  \"#extension GL_EXT_frag_depth : enable\\n\" +\n  \"uniform sampler2D colorTexture;\\n\" +\n  \"uniform sampler2D depthTexture;\\n\" +\n  \"uniform sampler2D classifiedTexture;\\n\" +\n  \"varying vec2 v_textureCoordinates;\\n\" +\n  \"void main()\\n\" +\n  \"{\\n\" +\n  \"    vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n\" +\n  \"    if (color.a == 0.0)\\n\" +\n  \"    {\\n\" +\n  \"        discard;\\n\" +\n  \"    }\\n\" +\n  \"    bool isClassified = all(equal(texture2D(classifiedTexture, v_textureCoordinates), vec4(0.0)));\\n\" +\n  \"#ifdef UNCLASSIFIED\\n\" +\n  \"    vec4 highlightColor = czm_invertClassificationColor;\\n\" +\n  \"    if (isClassified)\\n\" +\n  \"    {\\n\" +\n  \"        discard;\\n\" +\n  \"    }\\n\" +\n  \"#else\\n\" +\n  \"    vec4 highlightColor = vec4(1.0);\\n\" +\n  \"    if (!isClassified)\\n\" +\n  \"    {\\n\" +\n  \"        discard;\\n\" +\n  \"    }\\n\" +\n  \"#endif\\n\" +\n  \"    gl_FragColor = color * highlightColor;\\n\" +\n  \"    gl_FragDepthEXT = texture2D(depthTexture, v_textureCoordinates).r;\\n\" +\n  \"}\\n\";\n\nconst opaqueFS =\n  \"uniform sampler2D colorTexture;\\n\" +\n  \"varying vec2 v_textureCoordinates;\\n\" +\n  \"void main()\\n\" +\n  \"{\\n\" +\n  \"    vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n\" +\n  \"    if (color.a == 0.0)\\n\" +\n  \"    {\\n\" +\n  \"        discard;\\n\" +\n  \"    }\\n\" +\n  \"#ifdef UNCLASSIFIED\\n\" +\n  \"    gl_FragColor = color * czm_invertClassificationColor;\\n\" +\n  \"#else\\n\" +\n  \"    gl_FragColor = color;\\n\" +\n  \"#endif\\n\" +\n  \"}\\n\";\n\nInvertClassification.prototype.update = function (\n  context,\n  numSamples,\n  globeFramebuffer\n) {\n  const texture = this._fbo.getColorTexture();\n  const previousFramebufferChanged =\n    this.previousFramebuffer !== this._previousFramebuffer;\n  this._previousFramebuffer = this.previousFramebuffer;\n  const samplesChanged = this._numSamples !== numSamples;\n\n  const width = context.drawingBufferWidth;\n  const height = context.drawingBufferHeight;\n  const textureChanged =\n    !defined(texture) || texture.width !== width || texture.height !== height;\n\n  if (textureChanged || previousFramebufferChanged || samplesChanged) {\n    this._numSamples = numSamples;\n    this._depthStencilTexture =\n      this._depthStencilTexture && this._depthStencilTexture.destroy();\n    this._depthStencilRenderbuffer =\n      this._depthStencilRenderbuffer &&\n      this._depthStencilRenderbuffer.destroy();\n\n    if (!defined(this._previousFramebuffer)) {\n      this._depthStencilTexture = new Texture({\n        context: context,\n        width: width,\n        height: height,\n        pixelFormat: PixelFormat.DEPTH_STENCIL,\n        pixelDatatype: PixelDatatype.UNSIGNED_INT_24_8,\n      });\n      if (numSamples > 1) {\n        this._depthStencilRenderbuffer = new Renderbuffer({\n          context: context,\n          width: width,\n          height: height,\n          format: RenderbufferFormat.DEPTH24_STENCIL8,\n          numSamples: numSamples,\n        });\n      }\n    }\n  }\n\n  if (\n    !defined(this._fbo.framebuffer) ||\n    textureChanged ||\n    previousFramebufferChanged ||\n    samplesChanged\n  ) {\n    this._fbo.destroy();\n    this._fboClassified.destroy();\n\n    let depthStencilTexture;\n    let depthStencilRenderbuffer;\n    if (defined(this._previousFramebuffer)) {\n      depthStencilTexture = globeFramebuffer.getDepthStencilTexture();\n      depthStencilRenderbuffer = globeFramebuffer.getDepthStencilRenderbuffer();\n    } else {\n      depthStencilTexture = this._depthStencilTexture;\n      depthStencilRenderbuffer = this._depthStencilRenderbuffer;\n    }\n\n    this._fbo.setDepthStencilTexture(depthStencilTexture);\n    if (defined(depthStencilRenderbuffer)) {\n      this._fbo.setDepthStencilRenderbuffer(depthStencilRenderbuffer);\n    }\n    this._fbo.update(context, width, height, numSamples);\n\n    if (!defined(this._previousFramebuffer)) {\n      this._fboClassified.setDepthStencilTexture(depthStencilTexture);\n      this._fboClassified.update(context, width, height);\n    }\n  }\n\n  if (!defined(this._rsUnclassified)) {\n    this._rsUnclassified = RenderState.fromCache(rsUnclassified);\n    this._rsClassified = RenderState.fromCache(rsClassified);\n    this._rsDefault = RenderState.fromCache(rsDefault);\n  }\n\n  if (\n    !defined(this._unclassifiedCommand) ||\n    previousFramebufferChanged ||\n    samplesChanged\n  ) {\n    if (defined(this._unclassifiedCommand)) {\n      this._unclassifiedCommand.shaderProgram =\n        this._unclassifiedCommand.shaderProgram &&\n        this._unclassifiedCommand.shaderProgram.destroy();\n      this._classifiedCommand.shaderProgram =\n        this._classifiedCommand.shaderProgram &&\n        this._classifiedCommand.shaderProgram.destroy();\n    }\n\n    const fs = defined(this._previousFramebuffer) ? opaqueFS : translucentFS;\n    const unclassifiedFSSource = new ShaderSource({\n      defines: [\"UNCLASSIFIED\"],\n      sources: [fs],\n    });\n    const classifiedFSSource = new ShaderSource({\n      sources: [fs],\n    });\n    this._unclassifiedCommand = context.createViewportQuadCommand(\n      unclassifiedFSSource,\n      {\n        renderState: defined(this._previousFramebuffer)\n          ? this._rsUnclassified\n          : this._rsDefault,\n        uniformMap: this._uniformMap,\n        owner: this,\n      }\n    );\n    this._classifiedCommand = context.createViewportQuadCommand(\n      classifiedFSSource,\n      {\n        renderState: defined(this._previousFramebuffer)\n          ? this._rsClassified\n          : this._rsDefault,\n        uniformMap: this._uniformMap,\n        owner: this,\n      }\n    );\n\n    if (defined(this._translucentCommand)) {\n      this._translucentCommand.shaderProgram =\n        this._translucentCommand.shaderProgram &&\n        this._translucentCommand.shaderProgram.destroy();\n    }\n    if (!defined(this._previousFramebuffer)) {\n      this._translucentCommand = context.createViewportQuadCommand(\n        PassThrough,\n        {\n          renderState: this._rsUnclassified,\n          uniformMap: this._uniformMap,\n          owner: this,\n        }\n      );\n    }\n  }\n};\n\nInvertClassification.prototype.prepareTextures = function (\n  context,\n  blitStencil\n) {\n  if (this._fbo._numSamples > 1) {\n    this._fbo.prepareTextures(context, blitStencil);\n  }\n};\n\nInvertClassification.prototype.clear = function (context, passState) {\n  if (defined(this._previousFramebuffer)) {\n    this._fbo.clear(context, this._clearColorCommand, passState);\n  } else {\n    this._fbo.clear(context, this._clearCommand, passState);\n    this._fboClassified.clear(context, this._clearCommand, passState);\n  }\n};\n\nInvertClassification.prototype.executeClassified = function (\n  context,\n  passState\n) {\n  if (!defined(this._previousFramebuffer)) {\n    const framebuffer = passState.framebuffer;\n\n    this.prepareTextures(context, true);\n    passState.framebuffer = this._fboClassified.framebuffer;\n    this._translucentCommand.execute(context, passState);\n\n    passState.framebuffer = framebuffer;\n  }\n  this._classifiedCommand.execute(context, passState);\n};\n\nInvertClassification.prototype.executeUnclassified = function (\n  context,\n  passState\n) {\n  this._unclassifiedCommand.execute(context, passState);\n};\n\nInvertClassification.prototype.isDestroyed = function () {\n  return false;\n};\n\nInvertClassification.prototype.destroy = function () {\n  this._fbo.destroy();\n  this._fboClassified.destroy();\n  this._depthStencilTexture =\n    this._depthStencilTexture && this._depthStencilTexture.destroy();\n  this._depthStencilRenderbuffer =\n    this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy();\n\n  if (defined(this._unclassifiedCommand)) {\n    this._unclassifiedCommand.shaderProgram =\n      this._unclassifiedCommand.shaderProgram &&\n      this._unclassifiedCommand.shaderProgram.destroy();\n    this._classifiedCommand.shaderProgram =\n      this._classifiedCommand.shaderProgram &&\n      this._classifiedCommand.shaderProgram.destroy();\n  }\n\n  return destroyObject(this);\n};\nexport default InvertClassification;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport IonResource from \"../Core/IonResource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport ArcGisMapServerImageryProvider from \"./ArcGisMapServerImageryProvider.js\";\nimport BingMapsImageryProvider from \"./BingMapsImageryProvider.js\";\nimport TileMapServiceImageryProvider from \"./TileMapServiceImageryProvider.js\";\nimport GoogleEarthEnterpriseMapsProvider from \"./GoogleEarthEnterpriseMapsProvider.js\";\nimport MapboxImageryProvider from \"./MapboxImageryProvider.js\";\nimport SingleTileImageryProvider from \"./SingleTileImageryProvider.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\nimport WebMapServiceImageryProvider from \"./WebMapServiceImageryProvider.js\";\nimport WebMapTileServiceImageryProvider from \"./WebMapTileServiceImageryProvider.js\";\n\nfunction createFactory(Type) {\n  return function (options) {\n    return new Type(options);\n  };\n}\n\n// These values are the list of supported external imagery\n// assets in the Cesium ion beta. They are subject to change.\nconst ImageryProviderMapping = {\n  ARCGIS_MAPSERVER: createFactory(ArcGisMapServerImageryProvider),\n  BING: createFactory(BingMapsImageryProvider),\n  GOOGLE_EARTH: createFactory(GoogleEarthEnterpriseMapsProvider),\n  MAPBOX: createFactory(MapboxImageryProvider),\n  SINGLE_TILE: createFactory(SingleTileImageryProvider),\n  TMS: createFactory(TileMapServiceImageryProvider),\n  URL_TEMPLATE: createFactory(UrlTemplateImageryProvider),\n  WMS: createFactory(WebMapServiceImageryProvider),\n  WMTS: createFactory(WebMapTileServiceImageryProvider),\n};\n\n/**\n * @typedef {Object} IonImageryProvider.ConstructorOptions\n *\n * Initialization options for the TileMapServiceImageryProvider constructor\n *\n * @property {Number} assetId An ion imagery asset ID\n * @property {String} [accessToken=Ion.defaultAccessToken] The access token to use.\n * @property {String|Resource} [server=Ion.defaultServer] The resource to the Cesium ion API server.\n */\n\n/**\n * Provides tiled imagery using the Cesium ion REST API.\n *\n * @alias IonImageryProvider\n * @constructor\n *\n * @param {IonImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @example\n * viewer.imageryLayers.addImageryProvider(new Cesium.IonImageryProvider({ assetId : 23489024 }));\n */\nfunction IonImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const assetId = options.assetId;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.assetId\", assetId);\n  //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  this._ready = false;\n  this._tileCredits = undefined;\n  this._errorEvent = new Event();\n\n  const that = this;\n  const endpointResource = IonResource._createEndpointResource(\n    assetId,\n    options\n  );\n\n  // A simple cache to avoid making repeated requests to ion for endpoints we've\n  // already retrieved. This exists mainly to support Bing caching to reduce\n  // world imagery sessions, but provides a small boost of performance in general\n  // if constantly reloading assets\n  const cacheKey =\n    options.assetId.toString() + options.accessToken + options.server;\n  let promise = IonImageryProvider._endpointCache[cacheKey];\n  if (!defined(promise)) {\n    promise = endpointResource.fetchJson();\n    IonImageryProvider._endpointCache[cacheKey] = promise;\n  }\n\n  this._readyPromise = promise.then(function (endpoint) {\n    if (endpoint.type !== \"IMAGERY\") {\n      return Promise.reject(\n        new RuntimeError(`Cesium ion asset ${assetId} is not an imagery asset.`)\n      );\n    }\n\n    let imageryProvider;\n    const externalType = endpoint.externalType;\n    if (!defined(externalType)) {\n      imageryProvider = new TileMapServiceImageryProvider({\n        url: new IonResource(endpoint, endpointResource),\n      });\n    } else {\n      const factory = ImageryProviderMapping[externalType];\n\n      if (!defined(factory)) {\n        return Promise.reject(\n          new RuntimeError(\n            `Unrecognized Cesium ion imagery type: ${externalType}`\n          )\n        );\n      }\n      imageryProvider = factory(endpoint.options);\n    }\n\n    that._tileCredits = IonResource.getCreditsFromEndpoint(\n      endpoint,\n      endpointResource\n    );\n\n    imageryProvider.errorEvent.addEventListener(function (tileProviderError) {\n      //Propagate the errorEvent but set the provider to this instance instead\n      //of the inner instance.\n      tileProviderError.provider = that;\n      that._errorEvent.raiseEvent(tileProviderError);\n    });\n\n    that._imageryProvider = imageryProvider;\n    return imageryProvider.readyPromise.then(function () {\n      that._ready = true;\n      return true;\n    });\n  });\n}\n\nObject.defineProperties(IonImageryProvider.prototype, {\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof IonImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof IonImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.rectangle;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileWidth must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileHeight must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"maximumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true. Generally,\n   * a minimum level should only be used when the rectangle of the imagery is small\n   * enough that the number of tiles at the minimum level is small.  An imagery\n   * provider with more than a few tiles at the minimum level will lead to\n   * rendering problems.\n   * @memberof IonImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"minimumLevel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.minimumLevel;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tileDiscardPolicy must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof IonImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery. This function should\n   * not be called before {@link IonImageryProvider#ready} returns true.\n   * @memberof IonImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"credit must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof IonImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"hasAlphaChannel must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n      return this._imageryProvider.hasAlphaChannel;\n    },\n\n    /**\n     * Gets the proxy used by this provider.\n     * @memberof IonImageryProvider.prototype\n     * @type {Proxy}\n     * @readonly\n     * @default undefined\n     */\n    proxy: {\n      get: function () {\n        return undefined;\n      },\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nIonImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"getTileCredits must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const innerCredits = this._imageryProvider.getTileCredits(x, y, level);\n  if (!defined(innerCredits)) {\n    return this._tileCredits;\n  }\n\n  return this._tileCredits.concat(innerCredits);\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link IonImageryProvider#ready} returns true.\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nIonImageryProvider.prototype.requestImage = function (x, y, level, request) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestImage must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._imageryProvider.requestImage(x, y, level, request);\n};\n\n/**\n * Asynchronously determines what features, if any, are located at a given longitude and latitude within\n * a tile.  This function should not be called before {@link IonImageryProvider#ready} returns true.\n * This function is optional, so it may not exist on all ImageryProviders.\n *\n * @function\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n *\n * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.\n */\nIonImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"pickFeatures must not be called before the imagery provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n  return this._imageryProvider.pickFeatures(x, y, level, longitude, latitude);\n};\n\n//exposed for testing\nIonImageryProvider._endpointCache = {};\nexport default IonImageryProvider;\n","// Note, these values map directly to ion asset ids.\n\n/**\n * The types of imagery provided by {@link createWorldImagery}.\n *\n * @enum {Number}\n */\nconst IonWorldImageryStyle = {\n  /**\n   * Aerial imagery.\n   *\n   * @type {Number}\n   * @constant\n   */\n  AERIAL: 2,\n\n  /**\n   * Aerial imagery with a road overlay.\n   *\n   * @type {Number}\n   * @constant\n   */\n  AERIAL_WITH_LABELS: 3,\n\n  /**\n   * Roads without additional imagery.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ROAD: 4,\n};\nexport default Object.freeze(IonWorldImageryStyle);\n","import defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport JobType from \"./JobType.js\";\n\n/**\n *\n * @private\n * @constructor\n */\nfunction JobTypeBudget(total) {\n  /**\n   * Total budget, in milliseconds, allowed for one frame\n   */\n  this._total = total;\n\n  /**\n   * Time, in milliseconds, used so far during this frame\n   */\n  this.usedThisFrame = 0.0;\n\n  /**\n   * Time, in milliseconds, that other job types stole this frame\n   */\n  this.stolenFromMeThisFrame = 0.0;\n\n  /**\n   * Indicates if this job type was starved this frame, i.e., a job\n   * tried to run but didn't have budget\n   */\n  this.starvedThisFrame = false;\n\n  /**\n   * Indicates if this job was starved last frame.  This prevents it\n   * from being stolen from this frame.\n   */\n  this.starvedLastFrame = false;\n}\n\nObject.defineProperties(JobTypeBudget.prototype, {\n  total: {\n    get: function () {\n      return this._total;\n    },\n  },\n});\n\n/**\n * Engine for time slicing jobs during a frame to amortize work over multiple frames.  This supports:\n * <ul>\n *   <li>\n *     Separate budgets for different job types, e.g., texture, shader program, and buffer creation.  This\n *     allows all job types to make progress each frame.\n *   </li>\n *   <li>\n *     Stealing from other jobs type budgets if they were not exhausted in the previous frame.  This allows\n *     using the entire budget for all job types each frame even if, for example, all the jobs are the same type.\n *   </li>\n *   <li>\n *     Guaranteed progress on all job types each frame, even if it means exceeding the total budget for the frame.\n *     This prevents, for example, several expensive texture uploads over many frames from prevent a shader compile.\n *   </li>\n * </ul>\n *\n * @private\n */\nfunction JobScheduler(budgets) {\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(budgets) && budgets.length !== JobType.NUMBER_OF_JOB_TYPES) {\n    throw new DeveloperError(\n      \"A budget must be specified for each job type; budgets.length should equal JobType.NUMBER_OF_JOB_TYPES.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Total for defaults is half of of one frame at 10 fps\n  const jobBudgets = new Array(JobType.NUMBER_OF_JOB_TYPES);\n  jobBudgets[JobType.TEXTURE] = new JobTypeBudget(\n    defined(budgets) ? budgets[JobType.TEXTURE] : 10.0\n  );\n  // On cache miss, this most likely only allows one shader compile per frame\n  jobBudgets[JobType.PROGRAM] = new JobTypeBudget(\n    defined(budgets) ? budgets[JobType.PROGRAM] : 10.0\n  );\n  jobBudgets[JobType.BUFFER] = new JobTypeBudget(\n    defined(budgets) ? budgets[JobType.BUFFER] : 30.0\n  );\n\n  const length = jobBudgets.length;\n  let i;\n\n  let totalBudget = 0.0;\n  for (i = 0; i < length; ++i) {\n    totalBudget += jobBudgets[i].total;\n  }\n\n  const executedThisFrame = new Array(length);\n  for (i = 0; i < length; ++i) {\n    executedThisFrame[i] = false;\n  }\n\n  this._totalBudget = totalBudget;\n  this._totalUsedThisFrame = 0.0;\n  this._budgets = jobBudgets;\n  this._executedThisFrame = executedThisFrame;\n}\n\n// For unit testing\nJobScheduler.getTimestamp = getTimestamp;\n\nObject.defineProperties(JobScheduler.prototype, {\n  totalBudget: {\n    get: function () {\n      return this._totalBudget;\n    },\n  },\n});\n\nJobScheduler.prototype.disableThisFrame = function () {\n  // Prevent jobs from running this frame\n  this._totalUsedThisFrame = this._totalBudget;\n};\n\nJobScheduler.prototype.resetBudgets = function () {\n  const budgets = this._budgets;\n  const length = budgets.length;\n  for (let i = 0; i < length; ++i) {\n    const budget = budgets[i];\n    budget.starvedLastFrame = budget.starvedThisFrame;\n    budget.starvedThisFrame = false;\n    budget.usedThisFrame = 0.0;\n    budget.stolenFromMeThisFrame = 0.0;\n  }\n  this._totalUsedThisFrame = 0.0;\n};\n\nJobScheduler.prototype.execute = function (job, jobType) {\n  const budgets = this._budgets;\n  const budget = budgets[jobType];\n\n  // This ensures each job type makes progress each frame by executing at least once\n  const progressThisFrame = this._executedThisFrame[jobType];\n\n  if (this._totalUsedThisFrame >= this._totalBudget && progressThisFrame) {\n    // No budget left this frame for jobs of any type\n    budget.starvedThisFrame = true;\n    return false;\n  }\n\n  let stolenBudget;\n\n  if (budget.usedThisFrame + budget.stolenFromMeThisFrame >= budget.total) {\n    // No budget remaining for jobs of this type. Try to steal from other job types.\n    const length = budgets.length;\n    let i;\n    for (i = 0; i < length; ++i) {\n      stolenBudget = budgets[i];\n\n      // Steal from this budget if it has time left and it wasn't starved last fame\n      if (\n        stolenBudget.usedThisFrame + stolenBudget.stolenFromMeThisFrame <\n          stolenBudget.total &&\n        !stolenBudget.starvedLastFrame\n      ) {\n        break;\n      }\n    }\n\n    if (i === length && progressThisFrame) {\n      // No other job types can give up their budget this frame, and\n      // this job type already progressed this frame\n      return false;\n    }\n\n    if (progressThisFrame) {\n      // It is considered \"starved\" even if it executes using stolen time so that\n      // next frame, no other job types can steal time from it.\n      budget.starvedThisFrame = true;\n    }\n  }\n\n  const startTime = JobScheduler.getTimestamp();\n  job.execute();\n  const duration = JobScheduler.getTimestamp() - startTime;\n\n  // Track both time remaining for this job type and all jobs\n  // so budget stealing does send us way over the total budget.\n  this._totalUsedThisFrame += duration;\n\n  if (stolenBudget) {\n    stolenBudget.stolenFromMeThisFrame += duration;\n  } else {\n    budget.usedThisFrame += duration;\n  }\n  this._executedThisFrame[jobType] = true;\n\n  return true;\n};\nexport default JobScheduler;\n","/**\n * @private\n */\nconst JobType = {\n  TEXTURE: 0,\n  PROGRAM: 1,\n  BUFFER: 2,\n  NUMBER_OF_JOB_TYPES: 3,\n};\nexport default Object.freeze(JobType);\n"],"names":["Fog","this","enabled","renderable","density","screenSpaceErrorFactor","minimumBrightness","heightsTable","densityTable","i","length","tableStartDensity","tableEndDensity","j","tableLastIndex","scratchPositionNormal","prototype","update","frameState","fog","camera","positionCartographic","height","mode","heights","findInterval","t","startDensity","positionNormal","positionWC","Math","abs","directionWC","sse","FrameRateMonitor","options","scene","_scene","samplingWindow","defaultSettings","quietPeriod","warmupPeriod","minimumFrameRateDuringWarmup","minimumFrameRateAfterWarmup","_lowFrameRate","_nominalFrameRate","_frameTimes","_needsQuietPeriod","_quietPeriodEndTime","_warmupPeriodEndTime","_frameRateIsLow","_lastFramesPerSecond","undefined","_pauseCount","that","_preUpdateRemoveListener","preUpdate","addEventListener","time","monitor","timeStamp","push","beginningOfWindow","shift","averageTimeBetweenFrames","lowFrameRate","raiseEvent","nominalFrameRate","_hiddenPropertyName","document","hidden","mozHidden","msHidden","webkitHidden","visibilityChangeEventName","visibilityChangeListener","pause","unpause","_visibilityChangeRemoveListener","removeEventListener","fromScene","_frameRateMonitor","isDestroyed","Object","defineProperties","get","lastFramesPerSecond","destroy","context","creditDisplay","jobScheduler","commandList","shadowMaps","brdfLutGenerator","environmentMap","sphericalHarmonicCoefficients","specularEnvironmentMaps","specularEnvironmentMapsMaximumLOD","morphTime","frameNumber","newFrame","mapProjection","cameraUnderground","globeTranslucencyState","cullingVolume","occluder","maximumScreenSpaceError","pixelRatio","passes","render","pick","depth","postProcess","offscreen","afterRender","scene3DOnly","terrainExaggeration","terrainExaggerationRelativeHeight","shadowState","shadowsEnabled","lightShadowMaps","nearPlane","farPlane","closestObjectSize","lastDirtyTime","outOfView","splitPosition","frustumSplits","backgroundColor","light","minimumDisableDepthTestDistance","invertClassification","invertClassificationColor","useLogDepth","tilesetPassState","minimumTerrainHeight","near","far","numPasses","commands","Array","indices","Geometry3DTileContent","tileset","tile","resource","arrayBuffer","byteOffset","_tileset","_tile","_resource","_geometries","_metadata","_batchTable","_features","featurePropertiesDirty","_group","_readyPromise","content","uint8Array","Uint8Array","view","DataView","sizeOfUint32","version","getUint32","byteLength","resolve","featureTableJSONByteLength","featureTableBinaryByteLength","batchTableJSONByteLength","batchTableBinaryByteLength","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","numberOfBoxes","BOXES_LENGTH","numberOfCylinders","CYLINDERS_LENGTH","numberOfEllipsoids","ELLIPSOIDS_LENGTH","numberOfSpheres","SPHERES_LENGTH","totalPrimitives","batchTable","batchId","color","updateCommands","createColorChangedCallback","modelMatrix","computedTransform","center","RTC_CENTER","batchIds","boxBatchIds","cylinderBatchIds","ellipsoidBatchIds","sphereBatchIds","BOX_BATCH_IDS","boxBatchIdsByteOffset","Uint16Array","buffer","CYLINDER_BATCH_IDS","cylinderBatchIdsByteOffset","ELLIPSOID_BATCH_IDS","ellipsoidBatchIdsByteOffset","SPHERE_BATCH_IDS","sphereBatchIdsByteOffset","atLeastOneDefined","atLeastOneUndefined","id","boxes","cylinders","ellipsoids","spheres","getBatchIds","boxesByteOffset","BOXES","Float32Array","cylindersByteOffset","CYLINDERS","ellipsoidsByteOffset","ELLIPSOIDS","spheresByteOffset","SPHERES","boundingVolume","readyPromise","then","Promise","initialize","featuresLength","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","memorySizeInBytes","innerContents","url","getUrlComponent","metadata","set","value","group","Uint32Array","BYTES_PER_ELEMENT","createFeatures","features","hasProperty","name","getFeature","applyDebugSettings","applyStyle","style","classificationType","debugWireframe","_ready","geoJsonToFeatureInfo","json","result","feature","featureInfo","data","properties","configureNameFromProperties","configureDescriptionFromProperties","geometry","type","longitude","coordinates","latitude","position","mapInfoMxpNamespace","gmlNamespace","xmlToFeatureInfo","xml","documentElement","localName","namespaceURI","getElementsByTagNameNS","featureIndex","propertyElements","propertyIndex","propertyElement","hasAttribute","getAttribute","textContent","trim","mapInfoXmlToFeatureInfo","featureInfoResponse","propertyAttributes","attributes","attributeIndex","attribute","imageryLayerFeatureInfoFromDataAndProperties","featureInfoElements","featureInfoElementIndex","featureInfoElement","featureInfoChildren","childNodes","childIndex","child","nodeType","Node","ELEMENT_NODE","esriXmlToFeatureInfo","featureMembers","featureMember","getGmlPropertiesRecursively","gmlToFeatureInfo","XMLSerializer","serializeToString","layer","children","msGmlToFeatureInfo","xmlText","element","createElement","pre","appendChild","description","innerHTML","unknownXmlToFeatureInfo","gmlNode","isSingleValue","hasChildNodes","emptyBodyRegex","wmsServiceExceptionReportRegex","titleRegex","textToFeatureInfo","text","test","title","exec","format","callback","Globe","ellipsoid","terrainProvider","imageryLayerCollection","_ellipsoid","_imageryLayerCollection","_surfaceShaderSet","_material","_surface","tileProvider","imageryLayers","surfaceShaderSet","_terrainProvider","_terrainProviderChanged","_undergroundColor","_undergroundColorAlphaByDistance","maximumRadius","_translucency","makeShadersDirty","show","_oceanNormalMapResourceDirty","_oceanNormalMapResource","tileCacheSize","loadingDescendantLimit","preloadAncestors","preloadSiblings","fillHighlightColor","enableLighting","lambertDiffuseMultiplier","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","atmosphereLightIntensity","atmosphereRayleighCoefficient","atmosphereMieCoefficient","atmosphereRayleighScaleHeight","atmosphereMieScaleHeight","atmosphereMieAnisotropy","lightingFadeOutDistance","lightingFadeInDistance","nightFadeOutDistance","nightFadeInDistance","showWaterEffect","depthTestAgainstTerrain","shadows","atmosphereHueShift","atmosphereSaturationShift","atmosphereBrightnessShift","showSkirts","backFaceCulling","_oceanNormalMap","_zoomedOutOceanSpecularIntensity","globe","defines","requireNormals","shaderSource","match","fragmentSources","requestVertexNormals","_tileProvider","materialUniformMap","_uniforms","baseVertexShaderSource","sources","baseFragmentShaderSource","material","imageryLayersUpdatedEvent","tilesLoaded","ready","_tileLoadQueueHigh","_tileLoadQueueMedium","_tileLoadQueueLow","baseColor","clippingPlanes","cartographicLimitRectangle","oceanNormalMapUrl","terrainProviderChanged","tileLoadProgressEvent","undergroundColor","undergroundColorAlphaByDistance","translucency","scratchArray","scratchSphereIntersectionResult","start","stop","pickWorldCoordinates","ray","cullBackFaces","projection","sphereIntersections","tilesToRender","_tilesToRender","surfaceTile","pickBoundingSphere","rectangle","tileBoundingRegion","minimumHeight","maximumHeight","z","x","y","renderedMesh","boundingSphere","boundingSphereIntersection","rayOrigin","intersection","sort","origin","a","b","cartoScratch","carto","unproject","cartographicToCartesian","scratchGetHeightCartesian","scratchGetHeightIntersection","scratchGetHeightCartographic","scratchGetHeightRay","tileIfContainsCartographic","cartographic","getHeight","levelZeroTiles","_levelZeroTiles","tileWithMesh","_southwestChild","_southeastChild","_northwestChild","_northeastChild","tilingScheme","cartesian","surfaceNormal","geodeticSurfaceNormal","direction","getSurfaceNormalIntersectionWithZAxis","magnitude","min","vectorToMinimumPoint","cartesianToCartographic","beginFrame","surface","hasWaterMask","oceanNormalMapResource","fetchImage","image","source","pass","zoomedOutOceanSpecularIntensity","oceanNormalMap","hueShift","saturationShift","brightnessShift","endFrame","GlobeDepth","_picking","_numSamples","_tempCopyDepthTexture","_pickColorFramebuffer","depthStencil","supportsDepthTexture","_outputFramebuffer","_copyDepthFramebuffer","_tempCopyDepthFramebuffer","_updateDepthFramebuffer","createColorAttachments","createDepthAttachments","_clearGlobeColorCommand","_copyColorCommand","_copyDepthCommand","_tempCopyDepthCommand","_updateDepthCommand","_viewport","_rs","_rsBlend","_rsUpdate","_useScissorTest","_scissorRectangle","_useHdr","_clearGlobeDepth","updateCopyCommands","globeDepth","width","passState","useScissorTest","viewport","updateScissor","scissorTest","blending","stencilTest","frontFunction","frontOperation","fail","zFail","zPass","backFunction","reference","mask","createViewportQuadCommand","uniformMap","u_depthTexture","colorFramebufferManager","getDepthStencilTexture","owner","framebuffer","renderState","colorTexture","getColorTexture","stencil","depthStencilTexture","picking","numSamples","hdr","clearGlobeDepth","pixelDatatype","halfFloatingPointTexture","uniformState","globeDepthTexture","prepareColorTextures","blitStencil","prepareTextures","executeCopyDepth","execute","executeUpdateDepth","depthTexture","depthTextureToCopy","setColorTexture","setDepthStencilTexture","executeCopyColor","clear","clearColor","shaderProgram","GlobeSurfaceShader","numberOfDayTextures","flags","clippingShaderState","GlobeSurfaceShaderSet","_shadersByTexturesFlags","getShaderProgram","applyBrightness","applyContrast","applyHue","applySaturation","applyGamma","applyAlpha","applyDayNightAlpha","applySplit","showReflectiveOcean","showOceanWaves","perFragmentGroundAtmosphere","hasVertexNormals","useWebMercatorProjection","enableFog","enableClippingPlanes","clippedByBoundaries","hasImageryLayerCutout","colorCorrect","highlightFillTile","colorToAlpha","hasGeodeticSurfaceNormals","hasExaggeration","showUndergroundColor","translucent","quantization","quantizationDefine","terrainEncoding","encoding","cartographicLimitRectangleFlag","cartographicLimitRectangleDefine","imageryCutoutFlag","imageryCutoutDefine","sceneMode","currentClippingShaderState","clippingPlanesState","surfaceShader","shadersByFlags","vs","clone","fs","unshift","computeDayColor","positionMode","getPositionMode","get2DYPositionFraction","shader","vertexShaderSource","fragmentShaderSource","attributeLocations","getAttributeLocations","shadersByTexturesFlags","textureCount","hasOwnProperty","GlobeSurfaceTile","imagery","waterMaskTexture","waterMaskTranslationAndScale","terrainData","vertexArray","occludeePointInScaledSpace","boundingVolumeSourceTile","boundingVolumeIsFromMesh","terrainState","mesh","fill","isClipped","eligibleForUnloading","shouldRemoveTile","len","tileImagery","loadingImagery","state","scratchCartographic","getPosition","vertices","index","getExaggeratedPosition","project","scratchV0","scratchV1","scratchV2","toggleGeodeticSurfaceNormals","vertexBuffer","vertexCount","stride","newEncoding","newStride","newVertexBuffer","addGeodeticSurfaceNormals","removeGeodeticSurfaceNormals","_freeVertexArray","_createVertexArrayForMesh","wireframeVertexArray","indicesLength","minT","Number","MAX_VALUE","i0","i1","i2","v0","v1","v2","freeResources","referenceCount","imageryList","freeVertexArray","available","getTileDataAvailable","level","parent","parentSurfaceTile","isChildAvailable","_createTileImagerySkeletons","prepareNewTile","processStateMachine","quadtree","vertexArraysToDestroy","terrainOnly","canUpsample","sourceData","sourceX","sourceY","sourceLevel","terrainDataPromise","upsample","catch","success","request","failure","error","message","_requestError","errorEvent","doRequest","throttle","throttleByServer","requestPromise","requestTileGeometry","e","createMeshOptions","scratchCreateMeshOptions","exaggeration","exaggerationRelativeHeight","meshPromise","createMesh","transform","createResources","updateExaggeration","waterMask","waterMaskData","cache","tile_waterMaskData","allWaterTexture","pixelFormat","arrayBufferView","sampler","wrapS","wrapT","minificationFilter","magnificationFilter","getContextWaterMaskData","texture","waterMaskLength","textureSize","sqrt","flipY","createWaterMaskTextureIfNeeded","sourceTile","_findAncestorTileWithTerrainData","_computeWaterMaskTranslationAndScale","processTerrainStateMachine","wasAlreadyRenderable","isTerrainDoneLoading","upsampledFromParent","wasCreatedByUpsampling","isImageryDoneLoading","processImagery","callbacks","_loadedCallbacks","newCallbacks","layerId","skipLoading","isUpsampledOnly","isAnyTileLoaded","isDoneLoading","tileImageryCollection","imageryLayer","imageryProvider","splice","thisTileDoneLoading","readyImagery","hasExaggerationScale","encodingExaggerationScaleChanged","encodingRelativeHeightChanged","_tileToUpdateHeights","customData","customDataLength","typedArray","usage","getAttributes","indexBuffers","indexBuffer","indexDatatype","vertexArrayDestroyable","sourceTileRectangle","tileRectangle","tileWidth","tileHeight","scaleX","scaleY","west","south","w","GlobeSurfaceTileProvider","_materialUniformMap","_quadtree","_imageryLayers","_renderState","_blendRenderState","_disableCullingRenderState","_disableCullingBlendRenderState","_errorEvent","layerAdded","_onLayerAdded","layerRemoved","_onLayerRemoved","layerMoved","_onLayerMoved","layerShownOrHidden","_onLayerShownOrHidden","_imageryLayersUpdatedEvent","_layerOrderChanged","_tilesToRenderByTextureCount","_drawCommands","_uniformMaps","_usedDrawCommands","_vertexArraysToDestroy","_debug","wireframe","boundingSphereTile","_baseColor","_firstPassInitialColor","_clippingPlanes","_hasLoadedTilesThisFrame","_hasFillTilesThisFrame","_oldTerrainExaggeration","_oldTerrainExaggerationRelativeHeight","sortTileImageryByLayerIndex","aImagery","bImagery","_layerIndex","pushCommand","command","isBlendCommand","pushDerivedCommands","invalidateAllTiles","_update","queueReprojectionCommands","forEachLoadedTile","credit","addCredit","updateCredits","beginUpdate","tilesToRenderByTextureCount","tiles","endUpdate","cull","depthTest","func","rs","exaggerationChanged","textureCountIndex","textureCountLength","tileIndex","tileLength","addDrawCommandsForTile","updateForPick","drawCommands","cancelReprojections","getLevelMaximumGeometricError","loadTile","terrainStateBefore","_lastSelectionResult","computeTileVisibility","occluders","boundingSphereScratch","rectangleIntersectionScratch","splitCartographicLimitRectangleScratch","rectangleCenterScratch","clipRectangleAntimeridian","east","splitRectangle","isUndergroundVisible","distance","computeDistanceToTile","_distance","undergroundVisible","clippedCartographicLimitRectangle","areaLimitIntersection","planeIntersection","computeIntersectionWithBoundingVolume","visibility","computeVisibility","ortho3D","frustum","isScaledSpacePointVisiblePossiblyUnderEllipsoid","canRefine","readyImageryScratch","canRenderTraversalStack","canRenderWithoutLosingDetail","terrainReady","initialImageryState","isReady","layerIndex","lastFrame","_lastSelectionFrameNumber","stack","southwestChild","southeastChild","northwestChild","northeastChild","descendant","pop","lastFrameSelectionResult","_lastSelectionResultFrame","descendantSurface","descendantImagery","descendantTileImagery","descendantLoadingImagery","descendantIsReady","descendantLayerIndex","tileDirectionScratch","computeTileLoadPriority","obb","cameraPosition","cameraDirection","tileDirection","modifiedModelViewScratch","modifiedModelViewProjectionScratch","tileRectangleScratch","localizedCartographicLimitRectangleScratch","localizedTranslucencyRectangleScratch","rtcScratch","centerEyeScratch","southwestScratch","northeastScratch","showTileThisFrame","readyTextureCount","alpha","tileSet","debug","tilesRendered","texturesRendered","cornerPositionsScratch","computeOccludeePoint","ellipsoidalOccluder","_occluders","cornerPositions","north","computeHorizonCullingPointPossiblyUnderEllipsoid","computeBoundingVolumes","oldMinimumHeight","oldMaximumHeight","hasBoundingVolumesFromMesh","_minimumHeight","_maximumHeight","NaN","ancestorTile","ancestorSurfaceTile","ancestorMesh","ancestorTerrainData","_orientedBoundingBox","orientedBoundingBox","_boundingSphere","boundingSphere3D","needsBounds","updateTileBoundingRegion","max","cameraHeight","distanceToCamera","tileImageryUpdatedEvent","_reload","_imageryCache","startIndex","tileImageriesToFree","insertionPoint","endIndex","getTileReadyCallback","numDestroyed","newIndex","oldIndex","scratchClippingPlanesMatrix","scratchInverseTransposeClippingPlanesMatrix","createTileUniformMap","globeSurfaceTileProvider","u_initialColor","initialColor","u_fillHighlightColor","u_zoomedOutOceanSpecularIntensity","u_oceanNormalMap","u_atmosphereLightIntensity","u_atmosphereRayleighCoefficient","u_atmosphereMieCoefficient","u_atmosphereRayleighScaleHeight","u_atmosphereMieScaleHeight","u_atmosphereMieAnisotropy","u_lightingFadeDistance","lightingFadeDistance","u_nightFadeDistance","nightFadeDistance","u_center3D","center3D","u_terrainExaggerationAndRelativeHeight","terrainExaggerationAndRelativeHeight","u_tileRectangle","u_modifiedModelView","viewMatrix","centerEye","rtc","u_modifiedModelViewProjection","projectionMatrix","u_dayTextures","dayTextures","u_dayTextureTranslationAndScale","dayTextureTranslationAndScale","u_dayTextureTexCoordsRectangle","dayTextureTexCoordsRectangle","u_dayTextureUseWebMercatorT","dayTextureUseWebMercatorT","u_dayTextureAlpha","dayTextureAlpha","u_dayTextureNightAlpha","dayTextureNightAlpha","u_dayTextureDayAlpha","dayTextureDayAlpha","u_dayTextureBrightness","dayTextureBrightness","u_dayTextureContrast","dayTextureContrast","u_dayTextureHue","dayTextureHue","u_dayTextureSaturation","dayTextureSaturation","u_dayTextureOneOverGamma","dayTextureOneOverGamma","u_dayIntensity","dayIntensity","u_southAndNorthLatitude","southAndNorthLatitude","u_southMercatorYAndOneOverHeight","southMercatorYAndOneOverHeight","u_waterMask","u_waterMaskTranslationAndScale","u_minMaxHeight","minMaxHeight","u_scaleAndBias","scaleAndBias","u_dayTextureSplit","dayTextureSplit","u_dayTextureCutoutRectangles","dayTextureCutoutRectangles","u_clippingPlanes","defaultTexture","u_cartographicLimitRectangle","localizedCartographicLimitRectangle","u_clippingPlanesMatrix","u_clippingPlanesEdgeStyle","clippingPlanesEdgeColor","clippingPlanesEdgeWidth","u_minimumBrightness","u_hsbShift","hsbShift","u_colorsToAlpha","colorsToAlpha","u_frontFaceAlphaByDistance","frontFaceAlphaByDistance","u_backFaceAlphaByDistance","backFaceAlphaByDistance","u_translucencyRectangle","localizedTranslucencyRectangle","u_undergroundColor","u_undergroundColorAlphaByDistance","u_lambertDiffuseMultiplier","modifiedModelView","createWireframeVertexArrayIfNecessary","provider","terrainMesh","primitiveType","wireframeIndices","wireframeIndexBuffer","_attributes","createWireframeVertexArray","getDebugOrientedBoundingBox","getDebugBoundingSphere","debugDestroyPrimitive","instanceOBB","dimensions","instanceSphere","radius","previousVolume","primitive","createDebugPrimitive","instance","geometryInstances","appearance","flat","asynchronous","halfAxes","sphere","otherPassesInitialColor","surfaceShaderSetOptionsScratch","defaultUndergroundColor","defaultUndergroundColorAlphaByDistance","credits","tileCredits","tileCreditIndex","tileCreditLength","maxTextures","translucencyRectangle","nearValue","farValue","castShadows","receiveShadows","numberOfTextureUniforms","southLatitude","northLatitude","southMercatorY","oneOverMercatorHeight","southwest","northeast","epsilon","pow","widthEpsilon","heightEpsilon","surfaceShaderSetOptions","imageryIndex","imageryLen","firstPassRenderState","otherPassesRenderState","drawCommandsLength","uniformMapProperties","frontFaceAlphaByDistanceFinal","backFaceAlphaByDistanceFinal","clippedTranslucencyRectangle","cartographicTileRectangle","inverseTileWidth","inverseTileHeight","applyFog","applyCutout","applyColorToAlpha","useWebMercatorT","textureWebMercator","textureTranslationAndScale","_calculateTextureTranslationAndScale","textureCoordinateRectangle","nightAlpha","dayAlpha","brightness","contrast","hue","saturation","gamma","splitDirection","dayTextureCutoutRectangle","cutoutRectangle","hasColorToAlpha","colorToAlphaThreshold","red","green","blue","creditIndex","creditLength","matrix","clippingPlanesEnabled","edgeColor","edgeWidth","count","indexCountWithoutSkirts","dirty","updateDerivedCommands","GlobeTranslucency","_enabled","_frontFaceAlpha","_frontFaceAlphaByDistance","_backFaceAlpha","_backFaceAlphaByDistance","_rectangle","frontFaceAlpha","backFaceAlpha","GlobeTranslucencyFramebuffer","_framebuffer","_packedDepthFramebuffer","_packedDepthCommand","_clearCommand","classificationTexture","classificationFramebuffer","packedDepthFramebuffer","depthStencilRenderbuffer","getDepthStencilRenderbuffer","packedDepthTexture","updateAndClear","globeTranslucency","updateResources","clearClassification","packDepth","DerivedCommandType","derivedCommandsMaximumLength","DerivedCommandNames","GlobeTranslucencyState","_frontFaceTranslucent","_backFaceTranslucent","_requiresManualDepthTest","_sunVisibleThroughGlobe","_environmentVisible","_useDepthPlane","_numberOfTextureUniforms","_globeTranslucencyFramebuffer","_derivedCommandKey","_derivedCommandsDirty","_derivedCommandPacks","_derivedCommandTypes","_derivedBlendCommandTypes","_derivedPickCommandTypes","_derivedCommandTypesToUpdate","_derivedCommandsLength","_derivedBlendCommandsLength","_derivedPickCommandsLength","_derivedCommandsToUpdateLength","updateAlphaByDistance","alphaByDistance","isFaceTranslucent","translucencyEnabled","getDerivedCommandTypes","isPickCommand","types","frontTranslucent","backTranslucent","requiresManualDepthTest","translucentFrontFaceCommandType","translucentBackFaceCommandType","removeDefine","defineToRemove","indexOf","hasDefine","define","getOpaqueFrontFaceShaderProgram","getOpaqueBackFaceShaderProgram","getDepthOnlyShaderProgram","getTranslucentShaderProgram","getTranslucentBackFaceShaderProgram","getTranslucentFrontFaceManualDepthTestShaderProgram","getTranslucentBackFaceManualDepthTestShaderProgram","getPickShaderProgram","getDerivedShaderProgram","derivedShaderProgram","shaderProgramDirty","getShaderProgramFunction","cacheName","shaderCache","_attributeLocations","slice","createDerivedShaderProgram","getOpaqueFrontFaceRenderState","face","getOpaqueBackFaceRenderState","getDepthOnlyFrontFaceRenderState","colorMask","getDepthOnlyBackFaceRenderState","getDepthOnlyFrontAndBackFaceRenderState","getTranslucentFrontFaceRenderState","depthMask","getTranslucentBackFaceRenderState","getPickFrontFaceRenderState","getPickBackFaceRenderState","getDerivedRenderState","derivedRenderState","renderStateDirty","getRenderStateFunction","cachedRenderState","getTranslucencyUniformMap","u_classificationTexture","getDerivedUniformMap","derivedUniformMap","uniformMapDirty","getDerivedUniformMapFunction","DerivedCommandPack","pickOnly","getUniformMapFunction","renderStateCache","sunVisibleThroughGlobe","environmentVisible","useDepthPlane","isSunVisibleThroughGlobe","isEnvironmentVisible","getNumberOfTextureUniforms","derivedCommandKey","derivedCommandsToUpdateLength","derivedCommandsDirty","gatherDerivedCommandRequirements","derivedCommandNames","derivedCommandPacks","executeCommandsMatchingType","commandsLength","executeCommandFunction","derivedCommands","executeCommands","derivedCommandTypes","derivedCommandsLength","derivedCommandsObject","uniformMapDirtyFrame","shaderProgramDirtyFrame","renderStateDirtyFrame","shaderProgramId","renderStateId","derivedCommandPack","derivedCommandType","derivedCommandName","derivedCommand","derivedUniformMapDirtyFrame","derivedShaderProgramDirtyFrame","derivedRenderStateDirtyFrame","derivedUniformMapDirty","derivedShaderProgramDirty","derivedRenderStateDirty","opaqueTypes","depthOnlyTypes","executeGlobeCommands","frustumCommands","globeTranslucencyFramebuffer","globeCommands","globeCommandsLength","executeGlobeClassificationCommands","classificationCommands","classificationCommandsLength","originalGlobeDepthTexture","originalFramebuffer","GltfBufferViewLoader","resourceCache","gltf","bufferViewId","gltfResource","baseResource","cacheKey","bufferView","bufferViews","meshoptByteStride","meshoptCount","meshoptMode","meshoptFilter","bufferId","hasMeshopt","meshopt","extensions","EXT_meshopt_compression","byteStride","filter","buffers","_hasMeshopt","_meshoptByteStride","_meshoptCount","_meshoptMode","_meshoptFilter","_resourceCache","_gltfResource","_baseResource","_buffer","_bufferId","_byteOffset","_byteLength","_cacheKey","_bufferLoader","_typedArray","_state","_promise","_process","loader","create","constructor","promise","load","bufferLoader","bufferViewLoader","uri","getDerivedResource","loadExternalBuffer","loadEmbeddedBuffer","parentResource","getBufferLoader","bufferViewPromise","bufferTypedArray","bufferViewTypedArray","unload","reject","getError","process","GltfDracoLoader","draco","_gltf","_draco","_bufferViewLoader","_bufferViewTypedArray","_decodePromise","_decodedData","decodedData","loadBufferView","dracoPromise","compressedAttributes","decodeOptions","array","dequantizeInShader","decodePromise","results","indexArray","vertexAttributes","attributeData","dracoLoader","errorMessage","handleError","GltfImageLoader","imageId","images","_bufferViewId","_uri","_image","_mipLevels","getImageAndMipLevels","mipLevels","isArray","map","mipLevel","imageLoader","mimeType","header","subarray","webpHeaderRIFFChars","webpHeaderWEBPChars","getMimeTypeFromTypedArray","ktxBuffer","_loadImageFromTypedArray","skipColorSpaceConversion","loadImageFromBufferTypedArray","imageAndMipLevels","loadFromBufferView","ktx2Regex","preferImageBitmap","loadImageFromUri","loadFromUri","GltfIndexBufferLoader","accessorId","loadBuffer","loadTypedArray","accessors","componentType","_accessorId","_indexDatatype","_asynchronous","_loadBuffer","_loadTypedArray","_dracoLoader","scratchIndexBufferJob","CreateIndexBufferJob","createIndexBuffer","indexBufferLoader","loadDraco","loadFromDraco","accessor","createIndicesTypedArray","processPromise","indexBufferJob","GltfJsonLoader","gltfJson","_gltfJson","_bufferLoaders","processGltfJson","gltfJsonLoader","promises","bufferUri","extras","_pipeline","all","decodeDataUris","asset","upgradeVersion","loadEmbeddedBuffers","processGltfTypedArray","_fetchGltf","bufferLoaders","bufferLoadersLength","fetchArrayBuffer","Attribute","Indices","FeatureIdAttribute","FeatureIdTexture","FeatureIdImplicitRange","MorphTarget","Primitive","Instances","Skin","AnimatedPropertyType","AnimationSampler","AnimationTarget","AnimationChannel","Animation","Asset","Scene","Components","MetallicRoughness","SpecularGlossiness","Material","GltfLoaderState","GltfLoader","releaseGltfJson","incrementallyLoadTextures","upAxis","forwardAxis","loadAttributesAsTypedArray","loadPositionsFor2D","loadIndicesForWireframe","renameBatchIdSemantic","_releaseGltfJson","_incrementallyLoadTextures","_upAxis","_forwardAxis","_loadAttributesAsTypedArray","_loadPositionsFor2D","_loadIndicesForWireframe","_renameBatchIdSemantic","_sortedPropertyTableIds","_sortedFeatureTextureIds","_gltfJsonLoader","_textureState","_texturesLoadedPromise","_processTextures","_loaderPromises","_textureLoaders","_texturesPromises","_bufferViewLoaders","_geometryLoaders","_structuralMetadataLoader","_components","gltfLoader","getPackedTypedArray","componentCount","componentByteLength","componentsLength","accessorTypedArray","dataView","components","componentReader","loadDefaultAccessorValues","values","accessorType","MathType","ZERO","loadAccessor","useQuaternion","accessorCount","packedTypedArray","numberOfComponents","unpack","loadAccessorValues","fromArray","createAttribute","semantic","setIndex","constant","getDefault","componentDatatype","normalized","getSetIndex","gltfSemantic","setIndexMatch","parseInt","loadAttribute","semanticType","dequantize","loadAsTypedArray","loadAsTypedArrayPacked","renamedSemantic","modelSemantic","fromGltfSemantic","loadFor2D","vertexBufferLoader","attributeSemantic","loadVertexBuffer","loadVertexAttribute","loadInstancedAttribute","loadIndices","loadForWireframe","webgl2","loadIndexBuffer","loadTexture","textureInfo","supportedImageFormats","samplerOverride","textureId","textureLoader","textureReader","loadFeatureIdAttribute","featureIds","positionalLabel","featureIdAttribute","featureCount","nullFeatureId","propertyTableId","propertyTable","label","loadFeatureIdAttributeLegacy","gltfFeatureIdAttribute","featureTableId","loadDefaultFeatureIds","featureIdRange","offset","repeat","loadFeatureIdImplicitRangeLegacy","divisor","loadFeatureIdTexture","gltfFeatureIdTexture","featureIdTexture","channelString","channels","channelIndex","charAt","join","loadFeatureIdTextureLegacy","loadMorphTarget","target","morphTarget","loadPrimitive","gltfPrimitive","materialId","gltfMaterial","pbrSpecularGlossiness","KHR_materials_pbrSpecularGlossiness","pbrMetallicRoughness","unlit","KHR_materials_unlit","specularGlossiness","diffuseTexture","specularGlossinessTexture","diffuseFactor","specularFactor","glossinessFactor","metallicRoughness","baseColorTexture","metallicRoughnessTexture","baseColorFactor","metallicFactor","roughnessFactor","emissiveTexture","normalTexture","occlusionTexture","emissiveFactor","alphaMode","alphaCutoff","doubleSided","loadMaterial","materials","KHR_draco_mesh_compression","targets","targetsLength","morphTargets","structuralMetadata","EXT_structural_metadata","meshFeatures","EXT_mesh_features","featureMetadataLegacy","EXT_feature_metadata","hasFeatureMetadataLegacy","meshFeaturesExtension","featureIdsArray","featureIdComponent","loadPrimitiveFeatures","metadataExtension","featureTables","nextFeatureIdIndex","featureIdAttributes","featureIdAttributesLength","featureTable","featureIdTextures","featureIdTexturesLength","featureIdLabel","loadPrimitiveFeaturesLegacy","structuralMetadataExtension","propertyTextures","propertyTextureIds","propertyAttributeIds","loadPrimitiveMetadata","featureTextures","loadPrimitiveMetadataLegacy","loadInstances","nodeExtensions","instancingExtension","EXT_mesh_gpu_instancing","instances","hasRotation","ROTATION","hasTranslationMinMax","TRANSLATION","isTransformAttribute","instancedArrays","instancingExtExtensions","instanceFeatures","EXT_instance_features","instanceFeaturesExtension","loadInstanceFeatures","sortedPropertyTableIds","loadInstanceFeaturesLegacy","loadNode","gltfNode","node","translation","rotation","scale","meshId","meshes","primitives","primitivesLength","morphWeights","weights","loadSkin","gltfSkin","nodes","skin","jointIds","joints","jointsLength","inverseBindMatricesAccessorId","inverseBindMatrices","loadAnimationSampler","gltfSampler","animationSampler","inputAccessorId","input","gltfInterpolation","interpolation","outputAccessorId","output","loadAnimationChannel","gltfChannel","samplers","animationChannel","samplerIndex","gltfTarget","animationTarget","nodeIndex","path","toUpperCase","loadAnimationTarget","loadAnimation","gltfAnimation","animation","gltfSamplers","samplersLength","gltfChannels","channelsLength","unloadBufferViews","bufferViewLoaders","bufferViewLoadersLength","texturesLoadedPromise","textureProcessPromise","resolveTextures","rejectTextures","webp","basis","supportsBasis","rejectPromise","rejectTexturesPromise","featureMetadataExtensionLegacy","allPropertyTableIds","allFeatureTextureIds","keys","nodesLength","childrenNodeIds","childrenLength","loadNodes","skins","gltfSkins","skinsLength","skinId","loadSkins","animations","gltfAnimations","animationsLength","loadAnimations","sceneNodeIds","nodesIds","scenes","getSceneNodeIds","sceneNodeId","loadScene","copyright","split","string","structuralMetadataLoader","extension","extensionLegacy","loadStructuralMetadata","readyPromises","apply","parse","geometryLoaders","geometryLoadersLength","processLoaders","textureLoaders","textureLoadersLength","unloadTextures","unloadGeometry","GltfLoaderUtil","textures","EXT_texture_webp","KHR_texture_basisu","compressedTextureNoMipmap","minFilter","magFilter","samplerId","usesTextureTransform","KHR_texture_transform","defaultScale","createModelTextureReader","texCoord","textureTransform","cos","sin","modelTextureReader","ForEach","objectLegacy","objects","handler","objectId","call","object","arrayOfObjects","topLevel","gltfProperty","accessorWithSemantic","visited","meshPrimitive","valueForEach","meshPrimitiveAttribute","meshPrimitiveTarget","meshPrimitiveTargetAttribute","accessorContainingVertexAttributeData","accessorContainingIndexData","materialValue","KHR_techniques_webgl","nodeInTree","nodeIds","nodeId","nodeInScene","program","programs","shaders","skinJoint","techniqueAttribute","technique","attributeName","techniqueUniform","uniforms","uniformName","techniqueParameter","parameters","parameterName","techniques","newBuffer","addTextureDefaults","defaultMaterial","materialsCommon","KHR_materials_common","ambient","emission","transparency","transparent","diffuse","specular","shininess","techniquesExtension","animatedNodes","channel","getAnimatedNodes","extensionsRequired","extensionsUsed","addExtras","checkDuplicates","POSITIVE_INFINITY","NEGATIVE_INFINITY","componentTypeByteLength","getInt8","getUint8","getInt16","getUint16","getInt32","getFloat32","getFloat64","defaultBlendEquation","defaultBlendFactors","isStateEnabled","renderStates","enable","supportedBlendFactors","getSupportedBlendFactors","defaultValue","blendingForTechnique","materialPropertiesForTechnique","techniquesLegacy","techniqueLegacy","techniqueIndex","states","materialProperties","blendFunctions","functions","blendEquationSeparate","blendFuncSeparate","blendEquation","blendFactors","property","KHR_blend","mappedUniforms","updatedTechniqueIndices","seenPrograms","glExtensions","glExtensionsUsed","techniqueId","parameterLegacy","programLegacy","fragmentShader","vertexShader","materialExtension","readHeader","glb","contentLength","jsonStart","binaryStart","contentString","JSON","binaryBuffer","binaryGltfBuffer","binary_glTF","KHR_binary_glTF","parseGlbVersion1","chunkHeader","chunkLength","chunkType","chunkBuffer","jsonString","parseGlbVersion2","removeExtras","allElementTypes","TypeToGltfElementName","Remove","getListOfElementsIdsInUse","nodeIsEmpty","usedNodeIds","n","attributeAccessorId","propertyId","arrayOffsetBufferView","stringOffsetBufferView","ext","skeleton","uniform","textureIndex","featureTextureId","usedAccessorIds","forEach","key","usedBufferIds","usedBufferViewIds","usedImageIds","usedMeshIds","joint","usedMaterialIds","usedTextureIds","usedSamplerIds","elementTypes","removed","usedIds","removeUnusedElementsByType","convertType","updatedComponentType","updateFunctions","profile","api","updateInstanceTechniques","setPrimitiveModes","updateNodes","updateAnimations","removeTechniquePasses","allExtensions","lights","animationId","removeAnimationSamplersIndirection","isNodeEmpty","deleteNode","removeEmptyNodes","globalMapping","cameras","jointName","jointNameToId","topLevelId","objectMapping","objectToArray","binaryGltf","parameter","meshesLength","meshNode","meshNodeId","skeletons","jointNames","jointNamesLength","sceneNodes","sceneNodesLength","samplerMapping","objectsToArrays","removeAnimationSamplerNames","premultipliedAlpha","stripAsset","extensionsUsedLength","knownExtensions","requireKnownExtensions","accessorByteStride","computeAccessorByteStride","accessorByteEnd","requireByteLength","bufferViewHasVertexAttributes","bufferViewMap","currentByteOffset","currentIndex","accessorsLength","accessorByteOffset","accessorByteLength","hasNextAccessor","newBufferView","newBufferViewId","moveByteStrideToBufferView","minMax","requirePositionAccessorMinMax","requireAnimationAccessorMinMax","removeBufferType","internalFormat","removeTextureProperties","TEXCOORD_0","COLOR_0","TEXCOORD","COLOR","requireAttributeSetIndex","mappedSemantics","search","newSemantic","strippedSemantic","suffix","substring","indexedSemantic","indexedSemantics","knownSemantics","mappedSemantic","underscoreApplicationSpecificSemantics","perspective","aspectRatio","yfov","clampCameraParameters","removeEmptyArrays","instanceTechnique","defaultMode","axis","quat","instanceSkin","updatedAccessors","angle","passName","instanceProgram","mapping","CESIUM_RTC","WEB3D_quantized_attributes","POSITION","NORMAL","TANGENT","JOINT","JOINTS","WEIGHT","WEIGHTS","equals","parentNode","parentNodeId","targetVersion","toString","updateFunction","GltfStructuralMetadataLoader","_extension","_extensionLegacy","_supportedImageFormats","_schemaLoader","_structuralMetadata","gatherBufferViewIdsFromProperties","bufferViewIdSet","arrayOffsets","stringOffsets","gatherBufferViewIdsFromPropertiesLegacy","gatherTextureIdsFromProperties","textureIds","gatherTextureIdsFromPropertiesLegacy","bufferViewsPromise","bufferViewIds","propertyTables","gatherUsedBufferViewIds","gatherUsedBufferViewIdsLegacy","bufferViewPromises","loadBufferViews","texturesPromise","gatherUsedTextureIds","gatherUsedTextureIdsLegacy","texturePromises","loadTextures","schemaPromise","schemaLoader","schemaUri","schema","loadSchema","GltfTextureLoader","_textureInfo","_imageId","_imageLoader","_texture","scratchTextureJob","CreateTextureJob","createTexture","samplerRequiresMipmap","generateMipmap","requiresPowerOfTwo","nonPowerOfTwo","requiresResize","canvas","getContext","drawImage","resizeImageToNextPowerOfTwo","loadImage","textureJob","GltfVertexBufferLoader","hasBufferViewId","hasDraco","hasAttributeSemantic","hasAccessorId","_attributeSemantic","_dequantize","_quantization","CreateVertexBufferJob","createVertexBuffer","dracoAttribute","dracoQuantization","normalizationRange","quantizationBits","normalizationDivisor","octEncoded","octEncodedZXY","range","quantizedVolumeOffset","minValues","quantizedVolumeDimensions","quantizedVolumeStepSize","packedDimensions","packedSteps","dimension","getQuantizationInformation","componentsPerAttribute","scratchVertexBufferJob","vertexBufferJob","GoogleEarthEnterpriseDiscardPolicy","Image","GoogleEarthEnterpriseImageryProvider","defaultAlpha","defaultNightAlpha","defaultDayAlpha","defaultBrightness","defaultContrast","defaultHue","defaultSaturation","defaultGamma","defaultMinificationFilter","defaultMagnificationFilter","_tileDiscardPolicy","tileDiscardPolicy","_tilingScheme","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","_credit","_tileWidth","_tileHeight","_maximumLevel","metadataError","imageryPresent","shouldDiscardImage","proxy","maximumLevel","minimumLevel","hasAlphaChannel","getTileCredits","info","getTileInformation","providers","requestImage","invalidImage","quadKey","isValid","metadataRequest","priorityFunction","populateSubtree","hasImagery","imageryVersion","buildImageResource","protoImagery","jpeg","charCodeAt","png","getImageType","reader","end","pos","tag","uint32","copyrightIds","imageType","imageData","bytes","alphaType","imageAlpha","end2","skipType","decodeEarthImageryPacket","pickFeatures","GoogleEarthEnterpriseMapsProvider","appendForwardSlash","_url","_path","_channel","_requestType","logoUrl","_version","metadataResource","queryParameters","vars","is2d","requestMetadata","fetchText","replace","layers","PI","metadataSuccess","metadataFailure","requestType","_logoUrl","defaultColor","defaultGlowColor","defaultBackgroundColor","GridImageryProvider","_cells","cells","_color","_glowColor","glowColor","_glowWidth","glowWidth","_backgroundColor","_canvasSize","canvasSize","_canvas","_createGridCanvas","_drawGrid","maxPixel","val","moveTo","lineTo","stroke","cssBackgroundColor","toCssColorString","fillStyle","fillRect","cssGlowColor","strokeStyle","lineWidth","strokeRect","cssColor","GroundPolylinePrimitive","_hasPerInstanceColors","debugShowBoundingVolume","_debugShowShadowVolume","debugShowShadowVolume","_primitiveOptions","vertexCacheOptimize","interleave","releaseGeometryInstances","allowPicking","compressVertices","_createShaderProgramFunction","_createCommandsFunction","_updateAndQueueCommandsFunction","_zIndex","_primitive","_sp","_sp2D","_spMorph","getRenderState","_renderState3DTiles","_renderStateMorph","mask3DTiles","backOperation","updateAndQueueCommand","groundPolylinePrimitive","colorMorph","color2D","initializeTerrainHeights","primitiveOptions","geometryInstancesLength","groundInstances","geometryInstance","instanceAttributes","attributeKey","_scene3DOnly","pickPrimitive","getVertexShaderCallback","vsMorph","vsDefines","minimumRadius","toFixed","colorDefine","materialShaderSource","fsDefines","vsColor3D","fsColor3D","colorProgram2D","vsColor2D","concat","colorProgramMorph","vsColorMorph","fsColorMorph","createShaderProgram","twoPasses","colorCommands","pickCommands","_va","materialUniforms","getUniformMapCallback","_primitiveType","pickId","derivedTilesetCommand","derived2DCommand","derived2DTilesetCommand","derivedMorphCommand","createCommands","boundingSpheres","_boundingSphereWC","_boundingSphereCV","_boundingSphere2D","_boundingSphereMorph","morphing","queueTerrainCommands","queue3DTilesCommands","colorLength","updateAndQueueCommands","_error","getGeometryInstanceAttributes","isSupported","GroundPrimitiveUniformMap","u_globeMinimumAltitude","GroundPrimitive","geometryInstancesArray","geometryInstanceCount","_boundingVolumes","_boundingVolumes2D","_maxHeight","_minHeight","_maxTerrainHeight","_minTerrainHeight","_boundingSpheresKeys","_boundingSpheres","_useFragmentCulling","_classificationPrimitiveOptions","_createBoundingVolumeFunction","_pickPrimitive","_extruded","_uniformMap","getComputeMaximumHeightFunction","granularity","r","delta","getComputeMinimumHeightFunction","scratchBVCartesianHigh","scratchBVCartesianLow","scratchBVCartesian","scratchBVCartographic","scratchBVRectangle","getRectangle","position3DHigh","highPositions","lowPositions","position3DLow","minLat","minLon","maxLat","maxLon","highPosition","lowPosition","boundingVolumeIndex","commandIndex","floor","updateAndQueueRenderCommand","groundPrimitive","classificationPrimitive","_spColor","_needs2DShader","appearance2D","updateAndQueuePickCommand","_spPick","pick2D","instanceType","instanceRectangle","createShadowVolume","maximumTerrainHeight","setMinMaxTerrainHeights","useFragmentCulling","_supportsMaterials","usePlanarExtents","boundingRectangle","textureCoordinateRotationPoints","createBoundingVolume","boundingVolumes","ignoreShowCommands","_commandsIgnoreShow","ignoreShowCommandsLength","pickLength","pickOffsets","_pickOffsets","getBoundingSphere","supportsMaterials","GroupMetadata","metadataClass","class","_class","_properties","_id","_extras","_extensions","hasPropertyBySemantic","getPropertyIds","getProperty","setProperty","getPropertyBySemantic","setPropertyBySemantic","freeze","NONE","CLAMP_TO_GROUND","RELATIVE_TO_GROUND","CENTER","LEFT","RIGHT","I3dmParser","_deprecationWarning","byteStart","featureTableJsonByteLength","batchTableJsonByteLength","gltfFormat","gltfByteLength","gltfView","ImageBasedLighting","imageBasedLightingFactor","_imageBasedLightingFactor","luminanceAtZenith","_luminanceAtZenith","_sphericalHarmonicCoefficients","_specularEnvironmentMaps","_specularEnvironmentMapAtlas","_specularEnvironmentMapAtlasDirty","_specularEnvironmentMapLoaded","_previousSpecularEnvironmentMapLoaded","_useDefaultSpecularMaps","_useDefaultSphericalHarmonics","_shouldRegenerateShaders","_previousFrameNumber","_previousImageBasedLightingFactor","_previousLuminanceAtZenith","_previousSphericalHarmonicCoefficients","shouldRegenerateShaders","useDefaultSphericalHarmonics","useSphericalHarmonicCoefficients","specularEnvironmentMapAtlas","useDefaultSpecularMaps","useSpecularEnvironmentMaps","iblFactor","previousIBLFactor","imageBasedLighting","atlas","createSpecularEnvironmentMapAtlas","recompileWithDefaultAtlas","recompileWithoutDefaultAtlas","recompileWithDefaultSHCoeffs","recompileWithoutDefaultSHCoeffs","Imagery","parentX","parentY","parentLevel","getImageryFromCache","imageUrl","tileXYToRectangle","createPlaceholder","addReference","releaseReference","removeImageryFromCache","needGeographicProjection","_requestImagery","_createTexture","needsReprojection","_reprojectTexture","ImageryLayer","_imageryProvider","DEFAULT_BRIGHTNESS","DEFAULT_CONTRAST","DEFAULT_HUE","DEFAULT_SATURATION","DEFAULT_GAMMA","defaultSplit","DEFAULT_SPLIT","DEFAULT_MINIFICATION_FILTER","DEFAULT_MAGNIFICATION_FILTER","_minimumTerrainLevel","minimumTerrainLevel","_maximumTerrainLevel","maximumTerrainLevel","_maximumAnisotropy","maximumAnisotropy","_skeletonPlaceholder","_show","_isBaseLayer","_requestImageError","_reprojectComputeCommands","DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD","isBaseLayer","imageryBoundsScratch","tileImageryBoundsScratch","clippedRectangleScratch","terrainRectangleScratch","getSamplerKey","getImageryCacheKey","stringify","getViewableRectangle","imageryBounds","baseImageryRectangle","baseTerrainRectangle","latitudeClosestToEquator","imageryLevel","texelSpacing","latitudeFactor","tilingSchemeRectangle","twoToTheLevelPower","getNumberOfXTilesAtLevel","log","round","getLevelWithMaximumTexelSpacing","imageryTilingScheme","northwestTileCoordinates","positionToTileXY","southeastTileCoordinates","veryCloseX","veryCloseY","northwestTileRectangle","southeastTileRectangle","terrainRectangle","imageryTileXYToRectangle","minU","imageryRectangle","clippedImageryRectangle","rectangleToNativeRectangle","tileXYToNativeRectangle","bind","maxV","maxU","minV","initialMinV","texCoordsRectangle","terrainWidth","terrainHeight","imagePromise","_createTextureWebGL","discardPolicy","_finalizeReprojectTexture","maximumSupportedAnisotropy","mipmapSamplerKey","mipmapSamplers","imageryLayerMipmapSamplers","mipmapSampler","nonMipmapSamplerKey","nonMipmapSamplers","imageryLayerNonMipmapSamplers","nonMipmapSampler","computeCommand","persists","preExecute","reproject","imageryLayer_reproject","positions","reprojectAttributeIndices","webMercatorT","sizeInBytes","textureDimensions","sinLatitude","outputTexture","preMultiplyAlpha","float32ArrayScratch","outputIndex","webMercatorTIndex","fraction","mercatorFraction","copyFromArrayView","reprojectToGeographic","postExecute","canceled","computeCommands","u_textureDimensions","u_texture","ImageryLayerCollection","_layers","getLayerIndex","swapLayers","collection","arr","temp","add","hasIndex","addImageryProvider","remove","removeAll","contains","raise","lower","raiseToTop","lowerToBottom","applicableRectangleScratch","pickImageryHelper","pickedLocation","pickedTile","imageryTiles","terrainImagery","applicableRectangle","pickImageryLayers","pickedPosition","pickImageryLayerFeatures","resultIndex","layersShownOrHidden","ImageryLayerFeatureInfo","nameProperty","namePropertyPrecedence","lowerKey","toLowerCase","describe","html","ImageryProvider","preferBlob","UNLOADED","TRANSITIONING","RECEIVED","TEXTURE_LOADED","READY","FAILED","INVALID","PLACEHOLDER","Implicit3DTileContent","implicitTileset","implicitCoordinates","_implicitTileset","_implicitCoordinates","_implicitSubtree","templateValues","getTemplateValues","subtreeResource","subtreeUriTemplate","subtree","placeholderTile","rootTile","deriveChildTile","parentRow","currentRow","subtreeLevels","levelOffset","getLevelOffset","numberOfChildren","branchingFactor","childMortonIndex","childBitIndex","tileIsAvailableAtIndex","parentTile","getParentMortonIndex","childTile","bottomRow","transcodeSubtreeTiles","childSubtrees","leafTile","childSubtreeIsAvailableAtIndex","listChildSubtrees","subtreeLocator","implicitChildTile","makePlaceholderChildSubtree","expandSubtree","getGeometricError","tileMetadata","geometricError","implicitContent","parentIsPlaceholderTile","tileBounds","contentBounds","getChildCoordinates","tilePropertyTableJson","getTileMetadataView","boundingVolumeSemantics","contentPropertyTableJsons","hasImplicitContentMetadata","contentIsAvailableAtCoordinates","canUpdateHeights","deriveBoundingVolume","updateHeights","getTileBoundingVolume","contentJsons","contentCount","contentIsAvailableAtIndex","contentJson","contentUriTemplates","contentBoundingVolume","getContentBoundingVolume","contentHeaders","tileJson","refine","contents","rootHeader","tileHeader","combinedTileJson","makeTile","implicitSubtree","region","s2CellVolume","updateS2CellHeights","updateRegionHeights","tileBoundingVolume","rootBoundingVolume","deriveBoundingVolumeS2","deriveBoundingRegion","box","deriveBoundingBox","boundingVolumeS2","_boundingVolume","token","s2Cell","_cellId","BigInt","cell","minHeight","maxHeight","midpointHeight","scratchScaleFactors","scratchRootCenter","scratchCenter","scratchHalfAxes","rootBox","rootCenter","rootHalfAxes","tileScale","modelSpaceX","modelSpaceY","modelSpaceZ","scaleFactors","childBox","scratchRectangle","rootRegion","rootMinimumHeight","rootMaximumHeight","childWidth","childHeight","childThickness","childBoundingVolume","childGeometricError","childContentUri","Cesium3DTile","_deriveBoundingBox","_deriveBoundingRegion","_deriveBoundingVolumeS2","ImplicitAvailabilityBitstream","lengthBits","availableCount","bitstream","expectedLength","ceil","computeAvailableCountEnabled","bitIndex","count1Bits","_lengthBits","_availableCount","_constant","_bitstream","getBit","byteIndex","ImplicitMetadataView","metadataTable","entityId","propertyTableJson","_metadataTable","_entityId","ImplicitSubdivisionScheme","QUADTREE","OCTREE","subdivisionScheme","ImplicitSubtree","subtreeView","_subtreeJson","_tileAvailability","_contentAvailabilityBitstreams","_childSubtreeAvailability","_subtreeLevels","_subdivisionScheme","_branchingFactor","_tileMetadataTable","_tilePropertyTableJson","_contentMetadataTables","_contentPropertyTableJsons","_tileJumpBuffer","_contentJumpBuffers","chunks","binary","littleEndian","subtreeReader","jsonByteLength","binaryByteLength","subtreeJson","subtreeBinary","parseSubtreeChunks","propertyTableIndex","contentMetadata","metadataSchema","subtreeMetadata","subtreeMetadataClass","classes","defaultContentAvailability","contentAvailabilityHeaders","contentAvailability","bufferHeaders","bufferHeader","isExternal","isActive","preprocessBuffers","bufferViewHeaders","bufferViewHeader","preprocessBufferViews","tileAvailabilityHeader","tileAvailability","childSubtreeAvailabilityHeader","childSubtreeAvailability","markActiveBufferViews","markActiveMetadataBufferViews","internalBuffer","requestExternalBuffer","bufferResults","buffersU8","requestActiveBuffers","bufferViewsU8","parseActiveBufferViews","tileAvailabilityBits","childSubtreeBits","hasMetadataExtension","hasTileMetadata","parseAvailabilityBitstream","hasContentMetadata","parseAvailability","tileCount","tileMetadataClassName","tileMetadataClass","parseTileMetadataTable","tileJumpBuffer","makeJumpBuffer","makeTileJumpBuffer","contentAvailabilityBitstreams","contentMetadataTables","contentPropertyTableJson","contentMetadataClassName","contentMetadataClass","parseContentMetadataTables","contentJumpBuffers","contentJumpBuffer","makeContentJumpBuffers","metadataHeader","bufferResource","availabilityJson","Boolean","availability","bufferLength","jumpBuffer","tileMetadataTable","tileIsAvailableAtCoordinates","getTileIndex","contentIndex","childSubtreeIsAvailableAtCoordinates","getChildSubtreeIndex","mortonIndex","bitsPerLevel","localLevel","getSubtreeCoordinates","getOffsetCoordinates","getParentSubtreeCoordinates","getTileEntityId","getContentMetadataView","metadataTables","getContentEntityId","ImplicitSubtreeMetadata","ImplicitTileCoordinates","dimensionAtLevel","checkMatchingSubtreeShape","getDescendantCoordinates","offsetCoordinates","descendantLevel","descendantX","descendantY","descendantZ","getAncestorCoordinates","offsetLevels","ancestorLevel","ancestorX","ancestorY","ancestorZ","descendantCoordinates","isEqual","isAncestor","offsetLevel","dimensionAtOffsetLevel","offsetX","offsetY","offsetZ","levelDifference","isAncestorX","isAncestorY","isAncestorZ","otherCoordinates","isImplicitTilesetRoot","isSubtreeRoot","isBottomOfSubtree","scratchCoordinatesArray","fromMortonIndex","coordinatesArray","fromTileIndex","ImplicitTileset","implicitTiling","subtrees","gatherContentHeaders","contentHeader","contentResource","template","makeTileHeaderTemplate","availableLevels","InstanceAttributeSemantic","SCALE","FEATURE_ID","Instanced3DModel3DTileContent","_modelInstanceCollection","i3dm","instancesLength","getGlobalProperty","collectionOptions","basePath","_gltfUpAxis","opaquePass","pickIdLoaded","getPickIdCallback","showOutline","showCreditsOnScreen","gltfUrl","eastNorthUp","rtcCenter","rtcCenterArray","instancePosition","instancePositionArray","instanceNormalRight","instanceNormalUp","instanceNormalForward","instanceRotation","instanceQuaternion","instanceScale","instanceTranslationRotationScale","instanceTransform","propertyScratch1","positionQuantized","quantizedVolumeScale","normalUp","normalRight","propertyScratch2","hasCustomOrientation","octNormalUp","octNormalRight","nonUniformScale","activeAnimations","addAll","loop","getPickId","model","_model","setAllColor","commandStart","lightColor","tilesetClippingPlanes","referenceMatrix","clippingPlanesOriginMatrix","clippingPlanesDirty","_isClipped","addDerivedCommands","InvertClassification","previousFramebuffer","_previousFramebuffer","_depthStencilTexture","_depthStencilRenderbuffer","_fbo","_fboClassified","_rsUnclassified","_rsClassified","_unclassifiedCommand","_classifiedCommand","_translucentCommand","_clearColorCommand","classifiedTexture","unclassifiedCommand","isTranslucencySupported","fragmentDepth","rsUnclassified","rsClassified","rsDefault","stencilMask","globeFramebuffer","previousFramebufferChanged","samplesChanged","drawingBufferWidth","drawingBufferHeight","textureChanged","setDepthStencilRenderbuffer","_rsDefault","unclassifiedFSSource","classifiedFSSource","executeClassified","executeUnclassified","createFactory","Type","ImageryProviderMapping","ARCGIS_MAPSERVER","BING","GOOGLE_EARTH","MAPBOX","SINGLE_TILE","TMS","URL_TEMPLATE","WMS","WMTS","IonImageryProvider","assetId","_tileCredits","endpointResource","accessToken","server","_endpointCache","fetchJson","endpoint","externalType","factory","tileProviderError","innerCredits","AERIAL","AERIAL_WITH_LABELS","ROAD","JobTypeBudget","total","_total","usedThisFrame","stolenFromMeThisFrame","starvedThisFrame","starvedLastFrame","JobScheduler","budgets","jobBudgets","totalBudget","executedThisFrame","_totalBudget","_totalUsedThisFrame","_budgets","_executedThisFrame","getTimestamp","disableThisFrame","resetBudgets","budget","job","jobType","progressThisFrame","stolenBudget","startTime","duration","TEXTURE","PROGRAM","BUFFER","NUMBER_OF_JOB_TYPES"],"sourceRoot":""}