{"version":3,"file":"js/vender~21629454.12c38115.js","mappings":"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","sources":["webpack:///../../../node_modules/@babylonjs/core/Probes/reflectionProbe.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/depth.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/depthRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/mrtFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/geometry.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/geometryVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/geometryUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/geometry.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/geometryBufferRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/geometryBufferRendererSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/boundingBoxRendererFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/boundingBoxRendererUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/boundingBoxRenderer.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/boundingBoxRendererVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/boundingBoxRenderer.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/boundingBoxRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/depthRendererSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/oitFinal.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/oitBackBlend.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/depthPeelingRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/depthPeelingSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/line.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/line.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/edgesRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/prePassRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/prePassRendererSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/subSurfaceConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/subSurfaceSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/outline.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/outline.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/outlineRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/motionBlurConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/renderingGroup.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/renderingManager.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/screenSpaceReflectionsConfiguration.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/ssao2Configuration.js","webpack:///../../../node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimation.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/bonesVertex.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragment.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertex.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/instancesVertex.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/meshUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertex.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/sceneUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/ShadersWGSL/gpuUpdateParticles.compute.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingCompatibility.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVaryingDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/meshUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/packingFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentSoftTransparentShadow.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/anaglyph.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/background.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/backgroundVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/background.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/blackAndWhite.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/bloomMerge.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/chromaticAberration.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/circleOfConfusion.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/clearQuad.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/clearQuad.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/color.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/color.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/colorCorrection.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/convolution.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/default.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/default.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/depth.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/depthBoxBlur.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/depthOfField.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/depthOfFieldMerge.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/displayPass.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/extractHighlights.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/filter.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/fxaa.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/fxaa.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/glowBlurPostProcess.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/glowMapGeneration.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/glowMapGeneration.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/glowMapMerge.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/glowMapMerge.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration2.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/gpuRenderParticles.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration2.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/gpuRenderParticles.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/grain.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/hdrFiltering.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/hdrFiltering.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/highlights.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/imageProcessing.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurFragment2.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/kernelBlur.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/kernelBlurVertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/kernelBlur.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/layer.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/layer.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/lensFlare.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/lensFlare.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/lensHighlights.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/minmaxRedux.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/motionBlur.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/noise.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/particles.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/particles.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/pass.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/passCube.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrIBLFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockIridescence.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalGeometric.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalFinal.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockLightmapInit.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockGeometryInfo.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockDirectLighting.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalLitComponents.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalColorComposition.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockImageProcessing.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/pbr.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/pbr.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/postprocess.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/procedural.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/refraction.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/screenSpaceCurvature.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/screenSpaceReflection.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bayerDitherFunctions.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragmentExtraDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapFragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/shadowMap.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/meshVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapUboDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexExtraDeclaration.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexNormalBias.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowMapVertexMetric.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/shadowMap.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/sharpen.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ssao.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ssao2.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ssaoCombine.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/standard.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/stereoscopicInterlace.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fibonacci.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/ShadersInclude/diffusionProfile.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/subSurfaceScattering.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/tonemap.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/volumetricLightScattering.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/volumetricLightScatteringPass.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/volumetricLightScatteringPass.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/vrDistortionCorrection.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/vrMultiviewToSingleview.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/sprite.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/thinSprite.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/spriteSceneComponent.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/sprites.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/sprites.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/spriteRenderer.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/spriteManager.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/spriteMap.fragment.js","webpack:///../../../node_modules/@babylonjs/core/Shaders/spriteMap.vertex.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/spriteMap.js","webpack:///../../../node_modules/@babylonjs/core/Sprites/spritePackedManager.js","webpack:///../../../node_modules/@babylonjs/core/States/alphaCullingState.js","webpack:///../../../node_modules/@babylonjs/core/States/depthCullingState.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { serializeAsMeshReference, serializeAsVector3, SerializationHelper } from \"../Misc/decorators.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\n\nAbstractScene.prototype.removeReflectionProbe = function (toRemove) {\n    if (!this.reflectionProbes) {\n        return -1;\n    }\n    var index = this.reflectionProbes.indexOf(toRemove);\n    if (index !== -1) {\n        this.reflectionProbes.splice(index, 1);\n    }\n    return index;\n};\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe) {\n    if (!this.reflectionProbes) {\n        this.reflectionProbes = [];\n    }\n    this.reflectionProbes.push(newReflectionProbe);\n};\n/**\n * Class used to generate realtime reflection / refraction cube textures\n * @see https://doc.babylonjs.com/how_to/how_to_use_reflection_probes\n */\nvar ReflectionProbe = /** @class */ (function () {\n    /**\n     * Creates a new reflection probe\n     * @param name defines the name of the probe\n     * @param size defines the texture resolution (for each face)\n     * @param scene defines the hosting scene\n     * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\n     * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)\n     * @param linearSpace defines if the probe should be generated in linear space or not (false by default)\n     */\n    function ReflectionProbe(\n    /** defines the name of the probe */\n    name, size, scene, generateMipMaps, useFloat, linearSpace) {\n        if (generateMipMaps === void 0) { generateMipMaps = true; }\n        if (useFloat === void 0) { useFloat = false; }\n        if (linearSpace === void 0) { linearSpace = false; }\n        var _this = this;\n        this.name = name;\n        this._viewMatrix = Matrix.Identity();\n        this._target = Vector3.Zero();\n        this._add = Vector3.Zero();\n        this._invertYAxis = false;\n        /** Gets or sets probe position (center of the cube map) */\n        this.position = Vector3.Zero();\n        /** @hidden */\n        this._parentContainer = null;\n        this._scene = scene;\n        if (scene.getEngine().supportsUniformBuffers) {\n            this._sceneUBOs = [];\n            for (var i = 0; i < 6; ++i) {\n                this._sceneUBOs.push(scene.createSceneUniformBuffer(\"Scene for Reflection Probe (name \\\"\".concat(name, \"\\\") face #\").concat(i)));\n            }\n        }\n        // Create the scene field if not exist.\n        if (!this._scene.reflectionProbes) {\n            this._scene.reflectionProbes = new Array();\n        }\n        this._scene.reflectionProbes.push(this);\n        var textureType = 0;\n        if (useFloat) {\n            var caps = this._scene.getEngine().getCaps();\n            if (caps.textureHalfFloatRender) {\n                textureType = 2;\n            }\n            else if (caps.textureFloatRender) {\n                textureType = 1;\n            }\n        }\n        this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\n        this._renderTargetTexture.gammaSpace = !linearSpace;\n        var useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\n        this._renderTargetTexture.onBeforeRenderObservable.add(function (faceIndex) {\n            if (_this._sceneUBOs) {\n                scene.setSceneUniformBuffer(_this._sceneUBOs[faceIndex]);\n                scene.getSceneUniformBuffer().unbindEffect();\n            }\n            switch (faceIndex) {\n                case 0:\n                    _this._add.copyFromFloats(1, 0, 0);\n                    break;\n                case 1:\n                    _this._add.copyFromFloats(-1, 0, 0);\n                    break;\n                case 2:\n                    _this._add.copyFromFloats(0, _this._invertYAxis ? 1 : -1, 0);\n                    break;\n                case 3:\n                    _this._add.copyFromFloats(0, _this._invertYAxis ? -1 : 1, 0);\n                    break;\n                case 4:\n                    _this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);\n                    break;\n                case 5:\n                    _this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);\n                    break;\n            }\n            if (_this._attachedMesh) {\n                _this.position.copyFrom(_this._attachedMesh.getAbsolutePosition());\n            }\n            _this.position.addToRef(_this._add, _this._target);\n            var lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;\n            var perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;\n            lookAtFunction(_this.position, _this._target, Vector3.Up(), _this._viewMatrix);\n            if (scene.activeCamera) {\n                _this._projectionMatrix = perspectiveFunction(Math.PI / 2, 1, useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ, useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ, _this._scene.getEngine().isNDCHalfZRange);\n                scene.setTransformMatrix(_this._viewMatrix, _this._projectionMatrix);\n                if (scene.activeCamera.isRigCamera && !_this._renderTargetTexture.activeCamera) {\n                    _this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;\n                }\n            }\n            scene._forcedViewPosition = _this.position;\n        });\n        var currentApplyByPostProcess;\n        this._renderTargetTexture.onBeforeBindObservable.add(function () {\n            var _a, _b;\n            _this._currentSceneUBO = scene.getSceneUniformBuffer();\n            (_b = (_a = scene.getEngine())._debugPushGroup) === null || _b === void 0 ? void 0 : _b.call(_a, \"reflection probe generation for \".concat(name), 1);\n            currentApplyByPostProcess = _this._scene.imageProcessingConfiguration.applyByPostProcess;\n            if (linearSpace) {\n                scene.imageProcessingConfiguration.applyByPostProcess = true;\n            }\n        });\n        this._renderTargetTexture.onAfterUnbindObservable.add(function () {\n            var _a, _b;\n            scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;\n            scene._forcedViewPosition = null;\n            if (_this._sceneUBOs) {\n                scene.setSceneUniformBuffer(_this._currentSceneUBO);\n            }\n            scene.updateTransformMatrix(true);\n            (_b = (_a = scene.getEngine())._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(_a, 1);\n        });\n    }\n    Object.defineProperty(ReflectionProbe.prototype, \"samples\", {\n        /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\n        get: function () {\n            return this._renderTargetTexture.samples;\n        },\n        set: function (value) {\n            this._renderTargetTexture.samples = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ReflectionProbe.prototype, \"refreshRate\", {\n        /** Gets or sets the refresh rate to use (on every frame by default) */\n        get: function () {\n            return this._renderTargetTexture.refreshRate;\n        },\n        set: function (value) {\n            this._renderTargetTexture.refreshRate = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Gets the hosting scene\n     * @returns a Scene\n     */\n    ReflectionProbe.prototype.getScene = function () {\n        return this._scene;\n    };\n    Object.defineProperty(ReflectionProbe.prototype, \"cubeTexture\", {\n        /** Gets the internal CubeTexture used to render to */\n        get: function () {\n            return this._renderTargetTexture;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ReflectionProbe.prototype, \"renderList\", {\n        /** Gets the list of meshes to render */\n        get: function () {\n            return this._renderTargetTexture.renderList;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\n     * @param mesh defines the mesh to attach to\n     */\n    ReflectionProbe.prototype.attachToMesh = function (mesh) {\n        this._attachedMesh = mesh;\n    };\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     */\n    ReflectionProbe.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil) {\n        this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n    };\n    /**\n     * Clean all associated resources\n     */\n    ReflectionProbe.prototype.dispose = function () {\n        var index = this._scene.reflectionProbes.indexOf(this);\n        if (index !== -1) {\n            // Remove from the scene if found\n            this._scene.reflectionProbes.splice(index, 1);\n        }\n        if (this._parentContainer) {\n            var index_1 = this._parentContainer.reflectionProbes.indexOf(this);\n            if (index_1 > -1) {\n                this._parentContainer.reflectionProbes.splice(index_1, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (this._renderTargetTexture) {\n            this._renderTargetTexture.dispose();\n            this._renderTargetTexture = null;\n        }\n        if (this._sceneUBOs) {\n            for (var _i = 0, _a = this._sceneUBOs; _i < _a.length; _i++) {\n                var ubo = _a[_i];\n                ubo.dispose();\n            }\n            this._sceneUBOs = [];\n        }\n    };\n    /**\n     * Converts the reflection probe information to a readable string for debug purpose.\n     * @param fullDetails Supports for multiple levels of logging within scene loading\n     * @returns the human readable reflection probe info\n     */\n    ReflectionProbe.prototype.toString = function (fullDetails) {\n        var ret = \"Name: \" + this.name;\n        if (fullDetails) {\n            ret += \", position: \" + this.position.toString();\n            if (this._attachedMesh) {\n                ret += \", attached mesh: \" + this._attachedMesh.name;\n            }\n        }\n        return ret;\n    };\n    /**\n     * Get the class name of the refection probe.\n     * @returns \"ReflectionProbe\"\n     */\n    ReflectionProbe.prototype.getClassName = function () {\n        return \"ReflectionProbe\";\n    };\n    /**\n     * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.\n     * @returns The JSON representation of the texture\n     */\n    ReflectionProbe.prototype.serialize = function () {\n        var serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\n        serializationObject.isReflectionProbe = true;\n        return serializationObject;\n    };\n    /**\n     * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\n     * @param parsedReflectionProbe Define the JSON representation of the reflection probe\n     * @param scene Define the scene the parsed reflection probe should be instantiated in\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\n     * @returns The parsed reflection probe if successful\n     */\n    ReflectionProbe.Parse = function (parsedReflectionProbe, scene, rootUrl) {\n        var reflectionProbe = null;\n        if (scene.reflectionProbes) {\n            for (var index = 0; index < scene.reflectionProbes.length; index++) {\n                var rp = scene.reflectionProbes[index];\n                if (rp.name === parsedReflectionProbe.name) {\n                    reflectionProbe = rp;\n                    break;\n                }\n            }\n        }\n        reflectionProbe = SerializationHelper.Parse(function () { return reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps); }, parsedReflectionProbe, scene, rootUrl);\n        reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\n        if (parsedReflectionProbe._attachedMesh) {\n            reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));\n        }\n        return reflectionProbe;\n    };\n    __decorate([\n        serializeAsMeshReference()\n    ], ReflectionProbe.prototype, \"_attachedMesh\", void 0);\n    __decorate([\n        serializeAsVector3()\n    ], ReflectionProbe.prototype, \"position\", void 0);\n    return ReflectionProbe;\n}());\nexport { ReflectionProbe };\n//# sourceMappingURL=reflectionProbe.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/packingFunctions.js\";\nvar name = \"depthPixelShader\";\nvar shader = \"#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\nvarying float vDepthMetric;\\n#ifdef PACKED\\n#include<packingFunctions>\\n#endif\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\n#ifdef NONLINEARDEPTH\\n#ifdef PACKED\\ngl_FragColor=pack(gl_FragCoord.z);\\n#else\\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\\n#endif\\n#else\\n#ifdef PACKED\\ngl_FragColor=pack(vDepthMetric);\\n#else\\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\\n#endif\\n#endif\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var depthPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=depth.fragment.js.map","import { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { Camera } from \"../Cameras/camera.js\";\n\nimport \"../Shaders/depth.fragment.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\n/**\n * This represents a depth renderer in Babylon.\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\n */\nvar DepthRenderer = /** @class */ (function () {\n    /**\n     * Instantiates a depth renderer\n     * @param scene The scene the renderer belongs to\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\n     * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...)\n     */\n    function DepthRenderer(scene, type, camera, storeNonLinearDepth, samplingMode) {\n        if (type === void 0) { type = 1; }\n        if (camera === void 0) { camera = null; }\n        if (storeNonLinearDepth === void 0) { storeNonLinearDepth = false; }\n        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\n        var _this = this;\n        /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n        this.enabled = true;\n        /** Force writing the transparent objects into the depth map */\n        this.forceDepthWriteTransparentMeshes = false;\n        /**\n         * Specifies that the depth renderer will only be used within\n         * the camera it is created for.\n         * This can help forcing its rendering during the camera processing.\n         */\n        this.useOnlyInActiveCamera = false;\n        this._scene = scene;\n        this._storeNonLinearDepth = storeNonLinearDepth;\n        this.isPacked = type === 0;\n        if (this.isPacked) {\n            this._clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n        }\n        else {\n            this._clearColor = new Color4(1.0, 0.0, 0.0, 1.0);\n        }\n        DepthRenderer._SceneComponentInitialization(this._scene);\n        var engine = scene.getEngine();\n        this._camera = camera;\n        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\n            if (type === 1 && !engine._caps.textureFloatLinearFiltering) {\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\n            }\n            if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\n            }\n        }\n        // Render target\n        var format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;\n        this._depthMap = new RenderTargetTexture(\"DepthRenderer\", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, undefined, undefined, undefined, format);\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._depthMap.refreshRate = 1;\n        this._depthMap.renderParticles = false;\n        this._depthMap.renderList = null;\n        // Camera to get depth map from to support multiple concurrent cameras\n        this._depthMap.activeCamera = this._camera;\n        this._depthMap.ignoreCameraViewport = true;\n        this._depthMap.useCameraPostProcesses = false;\n        // set default depth value to 1.0 (far away)\n        this._depthMap.onClearObservable.add(function (engine) {\n            engine.clear(_this._clearColor, true, true, true);\n        });\n        this._depthMap.onBeforeBindObservable.add(function () {\n            var _a;\n            (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, \"depth renderer\", 1);\n        });\n        this._depthMap.onAfterUnbindObservable.add(function () {\n            var _a;\n            (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n        });\n        this._depthMap.customIsReadyFunction = function (mesh, refreshRate) {\n            if (!mesh.isReady(false)) {\n                return false;\n            }\n            if (refreshRate === 0 && mesh.subMeshes) {\n                // full check: check that the effects are ready\n                for (var i = 0; i < mesh.subMeshes.length; ++i) {\n                    var subMesh = mesh.subMeshes[i];\n                    var renderingMesh = subMesh.getRenderingMesh();\n                    var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n                    var hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n                        ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n                    if (!_this.isReady(subMesh, hardwareInstancedRendering)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        // Custom render function\n        var renderSubMesh = function (subMesh) {\n            var _a, _b;\n            var renderingMesh = subMesh.getRenderingMesh();\n            var effectiveMesh = subMesh.getEffectiveMesh();\n            var scene = _this._scene;\n            var engine = scene.getEngine();\n            var material = subMesh.getMaterial();\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n            if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n                return;\n            }\n            // Culling\n            var detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n            var sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n            if (detNeg) {\n                sideOrientation =\n                    sideOrientation === 0\n                        ? 1\n                        : 0;\n            }\n            var reverseSideOrientation = sideOrientation === 0;\n            engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, material.cullBackFaces);\n            // Managing instances\n            var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n            if (batch.mustReturn) {\n                return;\n            }\n            var hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n                ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\n            var camera = _this._camera || scene.activeCamera;\n            if (_this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n                subMesh._renderId = scene.getRenderId();\n                var renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];\n                var drawWrapper = subMesh._getDrawWrapper();\n                if (!drawWrapper && renderingMaterial) {\n                    drawWrapper = renderingMaterial._getDrawWrapper();\n                }\n                var cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n                if (!drawWrapper) {\n                    return;\n                }\n                var effect_1 = drawWrapper.effect;\n                engine.enableEffect(drawWrapper);\n                if (!hardwareInstancedRendering) {\n                    renderingMesh._bind(subMesh, effect_1, material.fillMode);\n                }\n                if (!renderingMaterial) {\n                    effect_1.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    effect_1.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n                }\n                else {\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n                }\n                var minZ = void 0, maxZ = void 0;\n                if (cameraIsOrtho) {\n                    minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                }\n                else {\n                    minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n                }\n                effect_1.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n                if (!renderingMaterial) {\n                    // Alpha test\n                    if (material && material.needAlphaTesting()) {\n                        var alphaTexture = material.getAlphaTestTexture();\n                        if (alphaTexture) {\n                            effect_1.setTexture(\"diffuseSampler\", alphaTexture);\n                            effect_1.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                        }\n                    }\n                    // Bones\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n                        var skeleton = renderingMesh.skeleton;\n                        if (skeleton.isUsingTextureForMatrices) {\n                            var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n                            if (!boneTexture) {\n                                return;\n                            }\n                            effect_1.setTexture(\"boneSampler\", boneTexture);\n                            effect_1.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n                        }\n                        else {\n                            effect_1.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n                        }\n                    }\n                    // Morph targets\n                    MaterialHelper.BindMorphTargetParameters(renderingMesh, effect_1);\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                        renderingMesh.morphTargetManager._bind(effect_1);\n                    }\n                }\n                // Draw\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect_1, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n                    return effect_1.setMatrix(\"world\", world);\n                });\n            }\n        };\n        this._depthMap.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n            var index;\n            if (depthOnlySubMeshes.length) {\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\n                }\n            }\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\n                renderSubMesh(opaqueSubMeshes.data[index]);\n            }\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                renderSubMesh(alphaTestSubMeshes.data[index]);\n            }\n            if (_this.forceDepthWriteTransparentMeshes) {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    renderSubMesh(transparentSubMeshes.data[index]);\n                }\n            }\n            else {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n                }\n            }\n        };\n    }\n    /**\n     * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\n     * @param mesh mesh or array of meshes\n     * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\n     */\n    DepthRenderer.prototype.setMaterialForRendering = function (mesh, material) {\n        this._depthMap.setMaterialForRendering(mesh, material);\n    };\n    /**\n     * Creates the depth rendering effect and checks if the effect is ready.\n     * @param subMesh The submesh to be used to render the depth map of\n     * @param useInstances If multiple world instances should be used\n     * @returns if the depth renderer is ready to render the depth map\n     */\n    DepthRenderer.prototype.isReady = function (subMesh, useInstances) {\n        var _a;\n        var engine = this._scene.getEngine();\n        var mesh = subMesh.getMesh();\n        var renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n        if (renderingMaterial) {\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n        }\n        var material = subMesh.getMaterial();\n        if (!material || material.disableDepthWrite) {\n            return false;\n        }\n        var defines = [];\n        var attribs = [VertexBuffer.PositionKind];\n        // Alpha test\n        if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\n            defines.push(\"#define ALPHATEST\");\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                attribs.push(VertexBuffer.UVKind);\n                defines.push(\"#define UV1\");\n            }\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                attribs.push(VertexBuffer.UV2Kind);\n                defines.push(\"#define UV2\");\n            }\n        }\n        // Bones\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n            var skeleton = subMesh.getRenderingMesh().skeleton;\n            if (skeleton === null || skeleton === void 0 ? void 0 : skeleton.isUsingTextureForMatrices) {\n                defines.push(\"#define BONETEXTURE\");\n            }\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n        // Morph targets\n        var morphTargetManager = mesh.morphTargetManager;\n        var numMorphInfluencers = 0;\n        if (morphTargetManager) {\n            if (morphTargetManager.numInfluencers > 0) {\n                numMorphInfluencers = morphTargetManager.numInfluencers;\n                defines.push(\"#define MORPHTARGETS\");\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n                if (morphTargetManager.isUsingTextureForTargets) {\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                }\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n            }\n        }\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            MaterialHelper.PushAttributesForInstances(attribs);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n        // None linear depth\n        if (this._storeNonLinearDepth) {\n            defines.push(\"#define NONLINEARDEPTH\");\n        }\n        // Float Mode\n        if (this.isPacked) {\n            defines.push(\"#define PACKED\");\n        }\n        // Get correct effect\n        var drawWrapper = subMesh._getDrawWrapper(undefined, true);\n        var cachedDefines = drawWrapper.defines;\n        var join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            drawWrapper.setEffect(engine.createEffect(\"depth\", attribs, [\n                \"world\",\n                \"mBones\",\n                \"boneTextureWidth\",\n                \"viewProjection\",\n                \"diffuseMatrix\",\n                \"depthValues\",\n                \"morphTargetInfluences\",\n                \"morphTargetTextureInfo\",\n                \"morphTargetTextureIndices\",\n            ], [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"], join, undefined, undefined, undefined, { maxSimultaneousMorphTargets: numMorphInfluencers }), join);\n        }\n        return drawWrapper.effect.isReady();\n    };\n    /**\n     * Gets the texture which the depth map will be written to.\n     * @returns The depth map texture\n     */\n    DepthRenderer.prototype.getDepthMap = function () {\n        return this._depthMap;\n    };\n    /**\n     * Disposes of the depth renderer.\n     */\n    DepthRenderer.prototype.dispose = function () {\n        var keysToDelete = [];\n        for (var key in this._scene._depthRenderer) {\n            var depthRenderer = this._scene._depthRenderer[key];\n            if (depthRenderer === this) {\n                keysToDelete.push(key);\n            }\n        }\n        if (keysToDelete.length > 0) {\n            this._depthMap.dispose();\n            for (var _i = 0, keysToDelete_1 = keysToDelete; _i < keysToDelete_1.length; _i++) {\n                var key = keysToDelete_1[_i];\n                delete this._scene._depthRenderer[key];\n            }\n        }\n    };\n    /**\n     * @param _\n     * @hidden\n     */\n    DepthRenderer._SceneComponentInitialization = function (_) {\n        throw _WarnImport(\"DepthRendererSceneComponent\");\n    };\n    return DepthRenderer;\n}());\nexport { DepthRenderer };\n//# sourceMappingURL=depthRenderer.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"mrtFragmentDeclaration\";\nvar shader = \"#if defined(WEBGL2) || defined(WEBGPU)\\nlayout(location=0) out vec4 glFragData[{X}];\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var mrtFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=mrtFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/mrtFragmentDeclaration.js\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentFunctions.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/bumpFragment.js\";\nvar name = \"geometryPixelShader\";\nvar shader = \"#extension GL_EXT_draw_buffers : require\\n#if defined(BUMP) || !defined(NORMAL)\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\nprecision highp float;\\n#ifdef BUMP\\nvarying mat4 vWorldView;\\nvarying vec3 vNormalW;\\n#else\\nvarying vec3 vNormalV;\\n#endif\\nvarying vec4 vViewPos;\\n#if defined(POSITION) || defined(BUMP)\\nvarying vec3 vPositionW;\\n#endif\\n#ifdef VELOCITY\\nvarying vec4 vCurrentPosition;\\nvarying vec4 vPreviousPosition;\\n#endif\\n#ifdef NEED_UV\\nvarying vec2 vUV;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform vec2 vTangentSpaceParams;\\n#endif\\n#if defined(REFLECTIVITY)\\nvarying vec2 vReflectivityUV;\\nvarying vec2 vAlbedoUV;\\nuniform sampler2D reflectivitySampler;\\nuniform sampler2D albedoSampler;\\nuniform vec3 reflectivityColor;\\nuniform vec3 albedoColor;\\nuniform float metallic;\\nuniform float glossiness;\\n#endif\\n#ifdef ALPHATEST\\nuniform sampler2D diffuseSampler;\\n#endif\\n#include<mrtFragmentDeclaration>[RENDER_TARGET_COUNT]\\n#include<bumpFragmentMainFunctions>\\n#include<bumpFragmentFunctions>\\n#include<helperFunctions>\\nvoid main() {\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\nvec3 normalOutput;\\n#ifdef BUMP\\nvec3 normalW=normalize(vNormalW);\\n#include<bumpFragment>\\nnormalOutput=normalize(vec3(vWorldView*vec4(normalW,0.0)));\\n#else\\nnormalOutput=normalize(vNormalV);\\n#endif\\n#ifdef PREPASS\\n#ifdef PREPASS_DEPTH\\ngl_FragData[DEPTH_INDEX]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\\n#endif\\n#ifdef PREPASS_NORMAL\\ngl_FragData[NORMAL_INDEX]=vec4(normalOutput,1.0);\\n#endif\\n#else\\ngl_FragData[0]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\\ngl_FragData[1]=vec4(normalOutput,1.0);\\n#endif\\n#ifdef POSITION\\ngl_FragData[POSITION_INDEX]=vec4(vPositionW,1.0);\\n#endif\\n#ifdef VELOCITY\\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\\nvec2 velocity=abs(a-b);\\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\\ngl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\\n#endif\\n#ifdef REFLECTIVITY\\nvec4 reflectivity=vec4(1.0,1.0,1.0,1.0);\\n#ifdef METALLICWORKFLOW\\nfloat metal=1.0;\\nfloat roughness=1.0;\\n#ifdef ORMTEXTURE\\nmetal*=texture2D(reflectivitySampler,vReflectivityUV).b;\\nroughness*=texture2D(reflectivitySampler,vReflectivityUV).g;\\n#endif\\n#ifdef METALLIC\\nmetal*=metallic;\\n#endif\\n#ifdef ROUGHNESS\\nroughness*=(1.0-glossiness); \\n#endif\\nreflectivity.a-=roughness;\\nvec3 color=vec3(1.0); \\n#ifdef ALBEDOTEXTURE \\ncolor=texture2D(albedoSampler,vAlbedoUV).rgb; \\n#ifdef GAMMAALBEDO\\ncolor=toLinearSpace(color);\\n#endif \\n#endif\\n#ifdef ALBEDOCOLOR \\ncolor*=albedoColor.xyz;\\n#endif\\nreflectivity.rgb=mix(vec3(0.04),color,metal);\\n#else\\n#ifdef SPECULARGLOSSINESSTEXTURE\\nreflectivity=texture2D(reflectivitySampler,vReflectivityUV); \\n#ifdef GAMMAREFLECTIVITYTEXTURE\\nreflectivity.rgb=toLinearSpace(reflectivity.rgb);\\n#endif \\n#ifdef GLOSSINESSS\\nreflectivity.a*=glossiness; \\n#endif\\n#else \\n#ifdef REFLECTIVITYTEXTURE \\nreflectivity.rbg=texture2D(reflectivitySampler,vReflectivityUV).rbg;\\n#ifdef GAMMAREFLECTIVITYTEXTURE\\nreflectivity.rgb=toLinearSpace(reflectivity.rgb);\\n#endif \\n#else \\n#ifdef REFLECTIVITYCOLOR\\nreflectivity.rgb=reflectivityColor.xyz;\\nreflectivity.a=1.0;\\n#endif \\n#endif \\n#ifdef GLOSSINESSS\\nreflectivity.a=glossiness; \\n#else\\nreflectivity.a=1.0; \\n#endif\\n#endif\\n#endif \\nreflectivity.rgb=toGammaSpace(reflectivity.rgb); \\ngl_FragData[REFLECTIVITY_INDEX]=reflectivity;\\n#endif\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var geometryPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=geometry.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"geometryVertexDeclaration\";\nvar shader = \"uniform mat4 viewProjection;\\nuniform mat4 view;\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var geometryVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=geometryVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nvar name = \"geometryUboDeclaration\";\nvar shader = \"#include<sceneUboDeclaration>\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var geometryUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=geometryUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/geometryVertexDeclaration.js\";\nimport \"./ShadersInclude/geometryUboDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/bumpVertex.js\";\nvar name = \"geometryVertexShader\";\nvar shader = \"precision highp float;\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#include<instancesDeclaration>\\n#include<__decl__geometryVertex>\\nattribute vec3 position;\\nattribute vec3 normal;\\n#ifdef NEED_UV\\nvarying vec2 vUV;\\n#ifdef ALPHATEST\\nuniform mat4 diffuseMatrix;\\n#endif\\n#ifdef BUMP\\nuniform mat4 bumpMatrix;\\nvarying vec2 vBumpUV;\\n#endif\\n#ifdef REFLECTIVITY\\nuniform mat4 reflectivityMatrix;\\nuniform mat4 albedoMatrix;\\nvarying vec2 vReflectivityUV;\\nvarying vec2 vAlbedoUV;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\n#ifdef BUMP\\nvarying mat4 vWorldView;\\n#endif\\n#ifdef BUMP\\nvarying vec3 vNormalW;\\n#else\\nvarying vec3 vNormalV;\\n#endif\\nvarying vec4 vViewPos;\\n#if defined(POSITION) || defined(BUMP)\\nvarying vec3 vPositionW;\\n#endif\\n#ifdef VELOCITY\\nuniform mat4 previousViewProjection;\\nvarying vec4 vCurrentPosition;\\nvarying vec4 vPreviousPosition;\\n#endif\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void)\\n{\\nvec3 positionUpdated=position;\\nvec3 normalUpdated=normal;\\n#ifdef UV1\\nvec2 uvUpdated=uv;\\n#endif\\n#include<morphTargetsVertexGlobal>\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#include<instancesVertex>\\n#if defined(VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\\n#endif\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\nvec4 pos=vec4(finalWorld*vec4(positionUpdated,1.0));\\n#ifdef BUMP\\nvWorldView=view*finalWorld;\\nvNormalW=normalUpdated;\\n#else\\nvNormalV=normalize(vec3((view*finalWorld)*vec4(normalUpdated,0.0)));\\n#endif\\nvViewPos=view*pos;\\n#if defined(VELOCITY) && defined(BONES_VELOCITY_ENABLED)\\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\n#if NUM_BONE_INFLUENCERS>0\\nmat4 previousInfluence;\\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif\\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\\n#else\\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\\n#endif\\n#endif\\n#if defined(POSITION) || defined(BUMP)\\nvPositionW=pos.xyz/pos.w;\\n#endif\\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\n#ifdef NEED_UV\\n#ifdef UV1\\n#if defined(ALPHATEST) && defined(ALPHATEST_UV1)\\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\\n#else\\nvUV=uv;\\n#endif\\n#ifdef BUMP_UV1\\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#ifdef REFLECTIVITY_UV1\\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#ifdef ALBEDO_UV1\\nvAlbedoUV=vec2(albedoMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#endif\\n#ifdef UV2\\n#if defined(ALPHATEST) && defined(ALPHATEST_UV2)\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#else\\nvUV=uv2;\\n#endif\\n#ifdef BUMP_UV2\\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#ifdef REFLECTIVITY_UV2\\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#ifdef ALBEDO_UV2\\nvAlbedoUV=vec2(albedoMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n#endif\\n#include<bumpVertex>\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var geometryVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=geometry.vertex.js.map","import { Matrix } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\n\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Material } from \"../Materials/material.js\";\nimport \"../Shaders/geometry.fragment.js\";\nimport \"../Shaders/geometry.vertex.js\";\nimport { MaterialFlags } from \"../Materials/materialFlags.js\";\n/**\n * This renderer is helpful to fill one of the render target with a geometry buffer.\n */\nvar GeometryBufferRenderer = /** @class */ (function () {\n    /**\n     * Creates a new G Buffer for the scene\n     * @param scene The scene the buffer belongs to\n     * @param ratio How big is the buffer related to the main canvas.\n     */\n    function GeometryBufferRenderer(scene, ratio) {\n        if (ratio === void 0) { ratio = 1; }\n        /**\n         * Dictionary used to store the previous transformation matrices of each rendered mesh\n         * in order to compute objects velocities when enableVelocity is set to \"true\"\n         * @hidden\n         */\n        this._previousTransformationMatrices = {};\n        /**\n         * Dictionary used to store the previous bones transformation matrices of each rendered mesh\n         * in order to compute objects velocities when enableVelocity is set to \"true\"\n         * @hidden\n         */\n        this._previousBonesTransformationMatrices = {};\n        /**\n         * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).\n         * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).\n         */\n        this.excludedSkinnedMeshesFromVelocity = [];\n        /** Gets or sets a boolean indicating if transparent meshes should be rendered */\n        this.renderTransparentMeshes = true;\n        this._resizeObserver = null;\n        this._enablePosition = false;\n        this._enableVelocity = false;\n        this._enableReflectivity = false;\n        this._positionIndex = -1;\n        this._velocityIndex = -1;\n        this._reflectivityIndex = -1;\n        this._depthIndex = -1;\n        this._normalIndex = -1;\n        this._linkedWithPrePass = false;\n        this._scene = scene;\n        this._ratio = ratio;\n        this._useUbo = scene.getEngine().supportsUniformBuffers;\n        GeometryBufferRenderer._SceneComponentInitialization(this._scene);\n        // Render target\n        this._createRenderTargets();\n    }\n    /**\n     * @param prePassRenderer\n     * @hidden\n     * Sets up internal structures to share outputs with PrePassRenderer\n     * This method should only be called by the PrePassRenderer itself\n     */\n    GeometryBufferRenderer.prototype._linkPrePassRenderer = function (prePassRenderer) {\n        this._linkedWithPrePass = true;\n        this._prePassRenderer = prePassRenderer;\n        if (this._multiRenderTarget) {\n            // prevents clearing of the RT since it's done by prepass\n            this._multiRenderTarget.onClearObservable.clear();\n            this._multiRenderTarget.onClearObservable.add(function () {\n                // pass\n            });\n        }\n    };\n    /**\n     * @hidden\n     * Separates internal structures from PrePassRenderer so the geometry buffer can now operate by itself.\n     * This method should only be called by the PrePassRenderer itself\n     */\n    GeometryBufferRenderer.prototype._unlinkPrePassRenderer = function () {\n        this._linkedWithPrePass = false;\n        this._createRenderTargets();\n    };\n    /**\n     * @hidden\n     * Resets the geometry buffer layout\n     */\n    GeometryBufferRenderer.prototype._resetLayout = function () {\n        this._enablePosition = false;\n        this._enableReflectivity = false;\n        this._enableVelocity = false;\n        this._attachments = [];\n    };\n    /**\n     * @param geometryBufferType\n     * @param index\n     * @hidden\n     * Replaces a texture in the geometry buffer renderer\n     * Useful when linking textures of the prepass renderer\n     */\n    GeometryBufferRenderer.prototype._forceTextureType = function (geometryBufferType, index) {\n        if (geometryBufferType === GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {\n            this._positionIndex = index;\n            this._enablePosition = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {\n            this._velocityIndex = index;\n            this._enableVelocity = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {\n            this._reflectivityIndex = index;\n            this._enableReflectivity = true;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.DEPTH_TEXTURE_TYPE) {\n            this._depthIndex = index;\n        }\n        else if (geometryBufferType === GeometryBufferRenderer.NORMAL_TEXTURE_TYPE) {\n            this._normalIndex = index;\n        }\n    };\n    /**\n     * @param attachments\n     * @hidden\n     * Sets texture attachments\n     * Useful when linking textures of the prepass renderer\n     */\n    GeometryBufferRenderer.prototype._setAttachments = function (attachments) {\n        this._attachments = attachments;\n    };\n    /**\n     * @param internalTexture\n     * @hidden\n     * Replaces the first texture which is hard coded as a depth texture in the geometry buffer\n     * Useful when linking textures of the prepass renderer\n     */\n    GeometryBufferRenderer.prototype._linkInternalTexture = function (internalTexture) {\n        this._multiRenderTarget.setInternalTexture(internalTexture, 0, false);\n    };\n    Object.defineProperty(GeometryBufferRenderer.prototype, \"renderList\", {\n        /**\n         * Gets the render list (meshes to be rendered) used in the G buffer.\n         */\n        get: function () {\n            return this._multiRenderTarget.renderList;\n        },\n        /**\n         * Set the render list (meshes to be rendered) used in the G buffer.\n         */\n        set: function (meshes) {\n            this._multiRenderTarget.renderList = meshes;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(GeometryBufferRenderer.prototype, \"isSupported\", {\n        /**\n         * Gets whether or not G buffer are supported by the running hardware.\n         * This requires draw buffer supports\n         */\n        get: function () {\n            return this._multiRenderTarget.isSupported;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the index of the given texture type in the G-Buffer textures array\n     * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX\n     * @returns the index of the given texture type in the G-Buffer textures array\n     */\n    GeometryBufferRenderer.prototype.getTextureIndex = function (textureType) {\n        switch (textureType) {\n            case GeometryBufferRenderer.POSITION_TEXTURE_TYPE:\n                return this._positionIndex;\n            case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE:\n                return this._velocityIndex;\n            case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE:\n                return this._reflectivityIndex;\n            default:\n                return -1;\n        }\n    };\n    Object.defineProperty(GeometryBufferRenderer.prototype, \"enablePosition\", {\n        /**\n         * Gets a boolean indicating if objects positions are enabled for the G buffer.\n         */\n        get: function () {\n            return this._enablePosition;\n        },\n        /**\n         * Sets whether or not objects positions are enabled for the G buffer.\n         */\n        set: function (enable) {\n            this._enablePosition = enable;\n            // PrePass handles index and texture links\n            if (!this._linkedWithPrePass) {\n                this.dispose();\n                this._createRenderTargets();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(GeometryBufferRenderer.prototype, \"enableVelocity\", {\n        /**\n         * Gets a boolean indicating if objects velocities are enabled for the G buffer.\n         */\n        get: function () {\n            return this._enableVelocity;\n        },\n        /**\n         * Sets whether or not objects velocities are enabled for the G buffer.\n         */\n        set: function (enable) {\n            this._enableVelocity = enable;\n            if (!enable) {\n                this._previousTransformationMatrices = {};\n            }\n            if (!this._linkedWithPrePass) {\n                this.dispose();\n                this._createRenderTargets();\n            }\n            this._scene.needsPreviousWorldMatrices = enable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(GeometryBufferRenderer.prototype, \"enableReflectivity\", {\n        /**\n         * Gets a boolean indicating if objects reflectivity are enabled in the G buffer.\n         */\n        get: function () {\n            return this._enableReflectivity;\n        },\n        /**\n         * Sets whether or not objects reflectivity are enabled for the G buffer.\n         * For Metallic-Roughness workflow with ORM texture, we assume that ORM texture is defined according to the default layout:\n         * pbr.useRoughnessFromMetallicTextureAlpha = false;\n         * pbr.useRoughnessFromMetallicTextureGreen = true;\n         * pbr.useMetallnessFromMetallicTextureBlue = true;\n         */\n        set: function (enable) {\n            this._enableReflectivity = enable;\n            if (!this._linkedWithPrePass) {\n                this.dispose();\n                this._createRenderTargets();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(GeometryBufferRenderer.prototype, \"scene\", {\n        /**\n         * Gets the scene associated with the buffer.\n         */\n        get: function () {\n            return this._scene;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(GeometryBufferRenderer.prototype, \"ratio\", {\n        /**\n         * Gets the ratio used by the buffer during its creation.\n         * How big is the buffer related to the main canvas.\n         */\n        get: function () {\n            return this._ratio;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Checks whether everything is ready to render a submesh to the G buffer.\n     * @param subMesh the submesh to check readiness for\n     * @param useInstances is the mesh drawn using instance or not\n     * @returns true if ready otherwise false\n     */\n    GeometryBufferRenderer.prototype.isReady = function (subMesh, useInstances) {\n        var material = subMesh.getMaterial();\n        if (material && material.disableDepthWrite) {\n            return false;\n        }\n        var defines = [];\n        var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n        var mesh = subMesh.getMesh();\n        // Alpha test\n        if (material) {\n            var needUv = false;\n            if (material.needAlphaTesting() && material.getAlphaTestTexture()) {\n                defines.push(\"#define ALPHATEST\");\n                defines.push(\"#define ALPHATEST_UV\".concat(material.getAlphaTestTexture().coordinatesIndex + 1));\n                needUv = true;\n            }\n            if (material.bumpTexture && MaterialFlags.BumpTextureEnabled) {\n                defines.push(\"#define BUMP\");\n                defines.push(\"#define BUMP_UV\".concat(material.bumpTexture.coordinatesIndex + 1));\n                needUv = true;\n            }\n            if (this._enableReflectivity) {\n                var metallicWorkflow = false;\n                // for PBR materials: cf. https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR\n                if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\n                    // if it is a PBR material in MetallicRoughness Mode:\n                    if (material.metallicRoughnessTexture !== null) {\n                        defines.push(\"#define ORMTEXTURE\");\n                        defines.push(\"#define REFLECTIVITY_UV\".concat(material.metallicRoughnessTexture.coordinatesIndex + 1));\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        needUv = true;\n                        metallicWorkflow = true;\n                    }\n                    if (material.metallic !== null) {\n                        defines.push(\"#define METALLIC\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (material.roughness !== null) {\n                        defines.push(\"#define ROUGHNESS\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (metallicWorkflow) {\n                        if (material.baseTexture !== null) {\n                            defines.push(\"#define ALBEDOTEXTURE\");\n                            defines.push(\"#define ALBEDO_UV\".concat(material.baseTexture.coordinatesIndex + 1));\n                            if (material.baseTexture.gammaSpace) {\n                                defines.push(\"#define GAMMAALBEDO\");\n                            }\n                            needUv = true;\n                        }\n                        if (material.baseColor !== null) {\n                            defines.push(\"#define ALBEDOCOLOR\");\n                        }\n                    }\n                }\n                else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\n                    // if it is a PBR material in Specular/Glossiness Mode:\n                    if (material.specularGlossinessTexture !== null) {\n                        defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\n                        defines.push(\"#define REFLECTIVITY_UV\".concat(material.specularGlossinessTexture.coordinatesIndex + 1));\n                        needUv = true;\n                        if (material.specularGlossinessTexture.gammaSpace) {\n                            defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n                        }\n                    }\n                    else {\n                        if (material.specularColor !== null) {\n                            defines.push(\"#define REFLECTIVITYCOLOR\");\n                        }\n                    }\n                    if (material.glossiness !== null) {\n                        defines.push(\"#define GLOSSINESSS\");\n                    }\n                }\n                else if (material.getClassName() === \"PBRMaterial\") {\n                    // if it is the bigger PBRMaterial\n                    if (material.metallicTexture !== null) {\n                        defines.push(\"#define ORMTEXTURE\");\n                        defines.push(\"#define REFLECTIVITY_UV\".concat(material.metallicTexture.coordinatesIndex + 1));\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        needUv = true;\n                        metallicWorkflow = true;\n                    }\n                    if (material.metallic !== null) {\n                        defines.push(\"#define METALLIC\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (material.roughness !== null) {\n                        defines.push(\"#define ROUGHNESS\");\n                        defines.push(\"#define METALLICWORKFLOW\");\n                        metallicWorkflow = true;\n                    }\n                    if (metallicWorkflow) {\n                        if (material.albedoTexture !== null) {\n                            defines.push(\"#define ALBEDOTEXTURE\");\n                            defines.push(\"#define ALBEDO_UV\".concat(material.albedoTexture.coordinatesIndex + 1));\n                            if (material.albedoTexture.gammaSpace) {\n                                defines.push(\"#define GAMMAALBEDO\");\n                            }\n                            needUv = true;\n                        }\n                        if (material.albedoColor !== null) {\n                            defines.push(\"#define ALBEDOCOLOR\");\n                        }\n                    }\n                    else {\n                        // SpecularGlossiness Model\n                        if (material.reflectivityTexture !== null) {\n                            defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\n                            defines.push(\"#define REFLECTIVITY_UV\".concat(material.reflectivityTexture.coordinatesIndex + 1));\n                            if (material.reflectivityTexture.gammaSpace) {\n                                defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n                            }\n                            needUv = true;\n                        }\n                        else if (material.reflectivityColor !== null) {\n                            defines.push(\"#define REFLECTIVITYCOLOR\");\n                        }\n                        if (material.microSurface !== null) {\n                            defines.push(\"#define GLOSSINESSS\");\n                        }\n                    }\n                }\n                else if (material.getClassName() === \"StandardMaterial\") {\n                    // if StandardMaterial:\n                    if (material.specularTexture !== null) {\n                        defines.push(\"#define REFLECTIVITYTEXTURE\");\n                        defines.push(\"#define REFLECTIVITY_UV\".concat(material.specularTexture.coordinatesIndex + 1));\n                        if (material.specularTexture.gammaSpace) {\n                            defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n                        }\n                        needUv = true;\n                    }\n                    if (material.specularColor !== null) {\n                        defines.push(\"#define REFLECTIVITYCOLOR\");\n                    }\n                }\n            }\n            if (needUv) {\n                defines.push(\"#define NEED_UV\");\n                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                    attribs.push(VertexBuffer.UVKind);\n                    defines.push(\"#define UV1\");\n                }\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                    attribs.push(VertexBuffer.UV2Kind);\n                    defines.push(\"#define UV2\");\n                }\n            }\n        }\n        // PrePass\n        if (this._linkedWithPrePass) {\n            defines.push(\"#define PREPASS\");\n            if (this._depthIndex !== -1) {\n                defines.push(\"#define DEPTH_INDEX \" + this._depthIndex);\n                defines.push(\"#define PREPASS_DEPTH\");\n            }\n            if (this._normalIndex !== -1) {\n                defines.push(\"#define NORMAL_INDEX \" + this._normalIndex);\n                defines.push(\"#define PREPASS_NORMAL\");\n            }\n        }\n        // Buffers\n        if (this._enablePosition) {\n            defines.push(\"#define POSITION\");\n            defines.push(\"#define POSITION_INDEX \" + this._positionIndex);\n        }\n        if (this._enableVelocity) {\n            defines.push(\"#define VELOCITY\");\n            defines.push(\"#define VELOCITY_INDEX \" + this._velocityIndex);\n            if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {\n                defines.push(\"#define BONES_VELOCITY_ENABLED\");\n            }\n        }\n        if (this._enableReflectivity) {\n            defines.push(\"#define REFLECTIVITY\");\n            defines.push(\"#define REFLECTIVITY_INDEX \" + this._reflectivityIndex);\n        }\n        // Bones\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n        // Morph targets\n        var morphTargetManager = mesh.morphTargetManager;\n        var numMorphInfluencers = 0;\n        if (morphTargetManager) {\n            if (morphTargetManager.numInfluencers > 0) {\n                numMorphInfluencers = morphTargetManager.numInfluencers;\n                defines.push(\"#define MORPHTARGETS\");\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n                if (morphTargetManager.isUsingTextureForTargets) {\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                }\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n            }\n        }\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            MaterialHelper.PushAttributesForInstances(attribs, this._enableVelocity);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n        // Setup textures count\n        if (this._linkedWithPrePass) {\n            defines.push(\"#define RENDER_TARGET_COUNT \" + this._attachments.length);\n        }\n        else {\n            defines.push(\"#define RENDER_TARGET_COUNT \" + this._multiRenderTarget.textures.length);\n        }\n        // Get correct effect\n        var drawWrapper = subMesh._getDrawWrapper(undefined, true);\n        var cachedDefines = drawWrapper.defines;\n        var join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            drawWrapper.setEffect(this._scene.getEngine().createEffect(\"geometry\", {\n                attributes: attribs,\n                uniformsNames: [\n                    \"world\",\n                    \"mBones\",\n                    \"viewProjection\",\n                    \"diffuseMatrix\",\n                    \"view\",\n                    \"previousWorld\",\n                    \"previousViewProjection\",\n                    \"mPreviousBones\",\n                    \"bumpMatrix\",\n                    \"reflectivityMatrix\",\n                    \"albedoMatrix\",\n                    \"reflectivityColor\",\n                    \"albedoColor\",\n                    \"metallic\",\n                    \"glossiness\",\n                    \"vTangentSpaceParams\",\n                    \"vBumpInfos\",\n                    \"morphTargetInfluences\",\n                    \"morphTargetTextureInfo\",\n                    \"morphTargetTextureIndices\",\n                ],\n                samplers: [\"diffuseSampler\", \"bumpSampler\", \"reflectivitySampler\", \"albedoSampler\", \"morphTargets\"],\n                defines: join,\n                onCompiled: null,\n                fallbacks: null,\n                onError: null,\n                uniformBuffersNames: [\"Scene\"],\n                indexParameters: { buffersCount: this._multiRenderTarget.textures.length - 1, maxSimultaneousMorphTargets: numMorphInfluencers },\n            }, this._scene.getEngine()), join);\n        }\n        return drawWrapper.effect.isReady();\n    };\n    /**\n     * Gets the current underlying G Buffer.\n     * @returns the buffer\n     */\n    GeometryBufferRenderer.prototype.getGBuffer = function () {\n        return this._multiRenderTarget;\n    };\n    Object.defineProperty(GeometryBufferRenderer.prototype, \"samples\", {\n        /**\n         * Gets the number of samples used to render the buffer (anti aliasing).\n         */\n        get: function () {\n            return this._multiRenderTarget.samples;\n        },\n        /**\n         * Sets the number of samples used to render the buffer (anti aliasing).\n         */\n        set: function (value) {\n            this._multiRenderTarget.samples = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Disposes the renderer and frees up associated resources.\n     */\n    GeometryBufferRenderer.prototype.dispose = function () {\n        if (this._resizeObserver) {\n            var engine = this._scene.getEngine();\n            engine.onResizeObservable.remove(this._resizeObserver);\n            this._resizeObserver = null;\n        }\n        this.getGBuffer().dispose();\n    };\n    GeometryBufferRenderer.prototype._assignRenderTargetIndices = function () {\n        var textureNames = [];\n        var count = 2;\n        textureNames.push(\"gBuffer_Depth\", \"gBuffer_Normal\");\n        if (this._enablePosition) {\n            this._positionIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Position\");\n        }\n        if (this._enableVelocity) {\n            this._velocityIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Velocity\");\n        }\n        if (this._enableReflectivity) {\n            this._reflectivityIndex = count;\n            count++;\n            textureNames.push(\"gBuffer_Reflectivity\");\n        }\n        return [count, textureNames];\n    };\n    GeometryBufferRenderer.prototype._createRenderTargets = function () {\n        var _this = this;\n        var engine = this._scene.getEngine();\n        var _a = this._assignRenderTargetIndices(), count = _a[0], textureNames = _a[1];\n        var type = 0;\n        if (engine._caps.textureFloat && engine._caps.textureFloatLinearFiltering) {\n            type = 1;\n        }\n        else if (engine._caps.textureHalfFloat && engine._caps.textureHalfFloatLinearFiltering) {\n            type = 2;\n        }\n        this._multiRenderTarget = new MultiRenderTarget(\"gBuffer\", { width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio }, count, this._scene, { generateMipMaps: false, generateDepthTexture: true, defaultType: type }, textureNames.concat(\"gBuffer_DepthBuffer\"));\n        if (!this.isSupported) {\n            return;\n        }\n        this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._multiRenderTarget.refreshRate = 1;\n        this._multiRenderTarget.renderParticles = false;\n        this._multiRenderTarget.renderList = null;\n        // set default depth value to 1.0 (far away)\n        this._multiRenderTarget.onClearObservable.add(function (engine) {\n            engine.clear(new Color4(0.0, 0.0, 0.0, 0.0), true, true, true);\n        });\n        this._resizeObserver = engine.onResizeObservable.add(function () {\n            if (_this._multiRenderTarget) {\n                _this._multiRenderTarget.resize({ width: engine.getRenderWidth() * _this._ratio, height: engine.getRenderHeight() * _this._ratio });\n            }\n        });\n        // Custom render function\n        var renderSubMesh = function (subMesh) {\n            var renderingMesh = subMesh.getRenderingMesh();\n            var effectiveMesh = subMesh.getEffectiveMesh();\n            var scene = _this._scene;\n            var engine = scene.getEngine();\n            var material = subMesh.getMaterial();\n            if (!material) {\n                return;\n            }\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n            // Velocity\n            if (_this._enableVelocity && !_this._previousTransformationMatrices[effectiveMesh.uniqueId]) {\n                _this._previousTransformationMatrices[effectiveMesh.uniqueId] = {\n                    world: Matrix.Identity(),\n                    viewProjection: scene.getTransformMatrix(),\n                };\n                if (renderingMesh.skeleton) {\n                    var bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);\n                    _this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = _this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));\n                }\n            }\n            // Managing instances\n            var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n            if (batch.mustReturn) {\n                return;\n            }\n            var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n            var world = effectiveMesh.getWorldMatrix();\n            if (_this.isReady(subMesh, hardwareInstancedRendering)) {\n                var drawWrapper = subMesh._getDrawWrapper();\n                if (!drawWrapper) {\n                    return;\n                }\n                var effect_1 = drawWrapper.effect;\n                engine.enableEffect(drawWrapper);\n                if (!hardwareInstancedRendering) {\n                    renderingMesh._bind(subMesh, effect_1, material.fillMode);\n                }\n                if (!_this._useUbo) {\n                    effect_1.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    effect_1.setMatrix(\"view\", scene.getViewMatrix());\n                }\n                else {\n                    MaterialHelper.BindSceneUniformBuffer(effect_1, _this._scene.getSceneUniformBuffer());\n                    _this._scene.finalizeSceneUbo();\n                }\n                if (material) {\n                    var sideOrientation = void 0;\n                    var instanceDataStorage = renderingMesh._instanceDataStorage;\n                    if (!instanceDataStorage.isFrozen && (material.backFaceCulling || renderingMesh.overrideMaterialSideOrientation !== null)) {\n                        var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n                        sideOrientation = renderingMesh.overrideMaterialSideOrientation;\n                        if (sideOrientation === null) {\n                            sideOrientation = material.sideOrientation;\n                        }\n                        if (mainDeterminant < 0) {\n                            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n                        }\n                    }\n                    else {\n                        sideOrientation = instanceDataStorage.sideOrientation;\n                    }\n                    material._preBind(drawWrapper, sideOrientation);\n                    // Alpha test\n                    if (material.needAlphaTesting()) {\n                        var alphaTexture = material.getAlphaTestTexture();\n                        if (alphaTexture) {\n                            effect_1.setTexture(\"diffuseSampler\", alphaTexture);\n                            effect_1.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                        }\n                    }\n                    // Bump\n                    if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled) {\n                        effect_1.setFloat3(\"vBumpInfos\", material.bumpTexture.coordinatesIndex, 1.0 / material.bumpTexture.level, material.parallaxScaleBias);\n                        effect_1.setMatrix(\"bumpMatrix\", material.bumpTexture.getTextureMatrix());\n                        effect_1.setTexture(\"bumpSampler\", material.bumpTexture);\n                        effect_1.setFloat2(\"vTangentSpaceParams\", material.invertNormalMapX ? -1.0 : 1.0, material.invertNormalMapY ? -1.0 : 1.0);\n                    }\n                    // Reflectivity\n                    if (_this._enableReflectivity) {\n                        // for PBR materials: cf. https://doc.babylonjs.com/divingDeeper/materials/using/masterPBR\n                        if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\n                            // if it is a PBR material in MetallicRoughness Mode:\n                            if (material.metallicRoughnessTexture !== null) {\n                                effect_1.setTexture(\"reflectivitySampler\", material.metallicRoughnessTexture);\n                                effect_1.setMatrix(\"reflectivityMatrix\", material.metallicRoughnessTexture.getTextureMatrix());\n                            }\n                            if (material.metallic !== null) {\n                                effect_1.setFloat(\"metallic\", material.metallic);\n                            }\n                            if (material.roughness !== null) {\n                                effect_1.setFloat(\"glossiness\", 1.0 - material.roughness);\n                            }\n                            if (material.baseTexture !== null) {\n                                effect_1.setTexture(\"albedoSampler\", material.baseTexture);\n                                effect_1.setMatrix(\"albedoMatrix\", material.baseTexture.getTextureMatrix());\n                            }\n                            if (material.baseColor !== null) {\n                                effect_1.setColor3(\"albedoColor\", material.baseColor);\n                            }\n                        }\n                        else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\n                            // if it is a PBR material in Specular/Glossiness Mode:\n                            if (material.specularGlossinessTexture !== null) {\n                                effect_1.setTexture(\"reflectivitySampler\", material.specularGlossinessTexture);\n                                effect_1.setMatrix(\"reflectivityMatrix\", material.specularGlossinessTexture.getTextureMatrix());\n                            }\n                            else {\n                                if (material.specularColor !== null) {\n                                    effect_1.setColor3(\"reflectivityColor\", material.specularColor);\n                                }\n                            }\n                            if (material.glossiness !== null) {\n                                effect_1.setFloat(\"glossiness\", material.glossiness);\n                            }\n                        }\n                        else if (material.getClassName() === \"PBRMaterial\") {\n                            // if it is the bigger PBRMaterial\n                            if (material.metallicTexture !== null) {\n                                effect_1.setTexture(\"reflectivitySampler\", material.metallicTexture);\n                                effect_1.setMatrix(\"reflectivityMatrix\", material.metallicTexture.getTextureMatrix());\n                            }\n                            if (material.metallic !== null) {\n                                effect_1.setFloat(\"metallic\", material.metallic);\n                            }\n                            if (material.roughness !== null) {\n                                effect_1.setFloat(\"glossiness\", 1.0 - material.roughness);\n                            }\n                            if (material.roughness !== null || material.metallic !== null || material.metallicTexture !== null) {\n                                // MetallicRoughness Model\n                                if (material.albedoTexture !== null) {\n                                    effect_1.setTexture(\"albedoSampler\", material.albedoTexture);\n                                    effect_1.setMatrix(\"albedoMatrix\", material.albedoTexture.getTextureMatrix());\n                                }\n                                if (material.albedoColor !== null) {\n                                    effect_1.setColor3(\"albedoColor\", material.albedoColor);\n                                }\n                            }\n                            else {\n                                // SpecularGlossiness Model\n                                if (material.reflectivityTexture !== null) {\n                                    effect_1.setTexture(\"reflectivitySampler\", material.reflectivityTexture);\n                                    effect_1.setMatrix(\"reflectivityMatrix\", material.reflectivityTexture.getTextureMatrix());\n                                }\n                                else if (material.reflectivityColor !== null) {\n                                    effect_1.setColor3(\"reflectivityColor\", material.reflectivityColor);\n                                }\n                                if (material.microSurface !== null) {\n                                    effect_1.setFloat(\"glossiness\", material.microSurface);\n                                }\n                            }\n                        }\n                        else if (material.getClassName() === \"StandardMaterial\") {\n                            // if StandardMaterial:\n                            if (material.specularTexture !== null) {\n                                effect_1.setTexture(\"reflectivitySampler\", material.specularTexture);\n                                effect_1.setMatrix(\"reflectivityMatrix\", material.specularTexture.getTextureMatrix());\n                            }\n                            if (material.specularColor !== null) {\n                                effect_1.setColor3(\"reflectivityColor\", material.specularColor);\n                            }\n                        }\n                    }\n                }\n                // Bones\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n                    effect_1.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n                    if (_this._enableVelocity) {\n                        effect_1.setMatrices(\"mPreviousBones\", _this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);\n                    }\n                }\n                // Morph targets\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect_1);\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                    renderingMesh.morphTargetManager._bind(effect_1);\n                }\n                // Velocity\n                if (_this._enableVelocity) {\n                    effect_1.setMatrix(\"previousWorld\", _this._previousTransformationMatrices[effectiveMesh.uniqueId].world);\n                    effect_1.setMatrix(\"previousViewProjection\", _this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);\n                }\n                if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\n                    effect_1.setMatrix(\"world\", world);\n                }\n                // Draw\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect_1, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, w) {\n                    if (!isInstance) {\n                        effect_1.setMatrix(\"world\", w);\n                    }\n                });\n            }\n            // Velocity\n            if (_this._enableVelocity) {\n                _this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();\n                _this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = _this._scene.getTransformMatrix().clone();\n                if (renderingMesh.skeleton) {\n                    _this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), _this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);\n                }\n            }\n        };\n        this._multiRenderTarget.customIsReadyFunction = function (mesh, refreshRate) {\n            if (!mesh.isReady(false)) {\n                return false;\n            }\n            if (refreshRate === 0 && mesh.subMeshes) {\n                // full check: check that the effects are ready\n                for (var i = 0; i < mesh.subMeshes.length; ++i) {\n                    var subMesh = mesh.subMeshes[i];\n                    var material = subMesh.getMaterial();\n                    var renderingMesh = subMesh.getRenderingMesh();\n                    if (!material) {\n                        continue;\n                    }\n                    var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n                    var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n                    if (!_this.isReady(subMesh, hardwareInstancedRendering)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        this._multiRenderTarget.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {\n            var index;\n            if (_this._linkedWithPrePass) {\n                if (!_this._prePassRenderer.enabled) {\n                    return;\n                }\n                _this._scene.getEngine().bindAttachments(_this._attachments);\n            }\n            if (depthOnlySubMeshes.length) {\n                engine.setColorWrite(false);\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\n                }\n                engine.setColorWrite(true);\n            }\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\n                renderSubMesh(opaqueSubMeshes.data[index]);\n            }\n            engine.setDepthWrite(false);\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                renderSubMesh(alphaTestSubMeshes.data[index]);\n            }\n            if (_this.renderTransparentMeshes) {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    renderSubMesh(transparentSubMeshes.data[index]);\n                }\n            }\n            engine.setDepthWrite(true);\n        };\n    };\n    // Copies the bones transformation matrices into the target array and returns the target's reference\n    GeometryBufferRenderer.prototype._copyBonesTransformationMatrices = function (source, target) {\n        for (var i = 0; i < source.length; i++) {\n            target[i] = source[i];\n        }\n        return target;\n    };\n    /**\n     * Constant used to retrieve the depth texture index in the G-Buffer textures array\n     * using getIndex(GeometryBufferRenderer.DEPTH_TEXTURE_INDEX)\n     */\n    GeometryBufferRenderer.DEPTH_TEXTURE_TYPE = 0;\n    /**\n     * Constant used to retrieve the normal texture index in the G-Buffer textures array\n     * using getIndex(GeometryBufferRenderer.NORMAL_TEXTURE_INDEX)\n     */\n    GeometryBufferRenderer.NORMAL_TEXTURE_TYPE = 1;\n    /**\n     * Constant used to retrieve the position texture index in the G-Buffer textures array\n     * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)\n     */\n    GeometryBufferRenderer.POSITION_TEXTURE_TYPE = 2;\n    /**\n     * Constant used to retrieve the velocity texture index in the G-Buffer textures array\n     * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)\n     */\n    GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 3;\n    /**\n     * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array\n     * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)\n     */\n    GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE = 4;\n    /**\n     * @param _\n     * @hidden\n     */\n    GeometryBufferRenderer._SceneComponentInitialization = function (_) {\n        throw _WarnImport(\"GeometryBufferRendererSceneComponent\");\n    };\n    return GeometryBufferRenderer;\n}());\nexport { GeometryBufferRenderer };\n//# sourceMappingURL=geometryBufferRenderer.js.map","import { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { GeometryBufferRenderer } from \"./geometryBufferRenderer.js\";\nObject.defineProperty(Scene.prototype, \"geometryBufferRenderer\", {\n    get: function () {\n        return this._geometryBufferRenderer;\n    },\n    set: function (value) {\n        if (value && value.isSupported) {\n            this._geometryBufferRenderer = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.enableGeometryBufferRenderer = function (ratio) {\n    if (ratio === void 0) { ratio = 1; }\n    if (this._geometryBufferRenderer) {\n        return this._geometryBufferRenderer;\n    }\n    this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio);\n    if (!this._geometryBufferRenderer.isSupported) {\n        this._geometryBufferRenderer = null;\n    }\n    return this._geometryBufferRenderer;\n};\nScene.prototype.disableGeometryBufferRenderer = function () {\n    if (!this._geometryBufferRenderer) {\n        return;\n    }\n    this._geometryBufferRenderer.dispose();\n    this._geometryBufferRenderer = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nvar GeometryBufferRendererSceneComponent = /** @class */ (function () {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    function GeometryBufferRendererSceneComponent(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    GeometryBufferRendererSceneComponent.prototype.register = function () {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);\n    };\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    GeometryBufferRendererSceneComponent.prototype.rebuild = function () {\n        // Nothing to do for this component\n    };\n    /**\n     * Disposes the component and the associated resources\n     */\n    GeometryBufferRendererSceneComponent.prototype.dispose = function () {\n        // Nothing to do for this component\n    };\n    GeometryBufferRendererSceneComponent.prototype._gatherRenderTargets = function (renderTargets) {\n        if (this.scene._geometryBufferRenderer) {\n            renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());\n        }\n    };\n    return GeometryBufferRendererSceneComponent;\n}());\nexport { GeometryBufferRendererSceneComponent };\nGeometryBufferRenderer._SceneComponentInitialization = function (scene) {\n    // Register the G Buffer component to the scene.\n    var component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER);\n    if (!component) {\n        component = new GeometryBufferRendererSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=geometryBufferRendererSceneComponent.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"boundingBoxRendererFragmentDeclaration\";\nvar shader = \"uniform vec4 color;\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var boundingBoxRendererFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=boundingBoxRendererFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"boundingBoxRendererUboDeclaration\";\nvar shader = \"#ifdef WEBGL2\\nuniform vec4 color;\\nuniform mat4 world;\\nuniform mat4 viewProjection;\\n#ifdef MULTIVIEW\\nuniform mat4 viewProjectionR;\\n#endif\\n#else\\nlayout(std140,column_major) uniform;\\nuniform BoundingBoxRenderer {\\nvec4 color;\\nmat4 world;\\nmat4 viewProjection;\\nmat4 viewProjectionR;\\n};\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var boundingBoxRendererUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=boundingBoxRendererUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/boundingBoxRendererFragmentDeclaration.js\";\nimport \"./ShadersInclude/boundingBoxRendererUboDeclaration.js\";\nvar name = \"boundingBoxRendererPixelShader\";\nvar shader = \"#include<__decl__boundingBoxRendererFragment>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\ngl_FragColor=color;\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var boundingBoxRendererPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=boundingBoxRenderer.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"boundingBoxRendererVertexDeclaration\";\nvar shader = \"uniform mat4 world;\\nuniform mat4 viewProjection;\\n#ifdef MULTIVIEW\\nuniform mat4 viewProjectionR;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var boundingBoxRendererVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=boundingBoxRendererVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/boundingBoxRendererVertexDeclaration.js\";\nimport \"./ShadersInclude/boundingBoxRendererUboDeclaration.js\";\nvar name = \"boundingBoxRendererVertexShader\";\nvar shader = \"attribute vec3 position;\\n#include<__decl__boundingBoxRendererVertex>\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec4 worldPos=world*vec4(position,1.0);\\n#ifdef MULTIVIEW\\nif (gl_ViewID_OVR==0u) {\\ngl_Position=viewProjection*worldPos;\\n} else {\\ngl_Position=viewProjectionR*worldPos;\\n}\\n#else\\ngl_Position=viewProjection*worldPos;\\n#endif\\n#define CUSTOM_VERTEX_MAIN_END\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var boundingBoxRendererVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=boundingBoxRenderer.vertex.js.map","import { Scene } from \"../scene.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Matrix } from \"../Maths/math.vector.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder.js\";\nimport \"../Shaders/boundingBoxRenderer.fragment.js\";\nimport \"../Shaders/boundingBoxRenderer.vertex.js\";\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\n    get: function () {\n        return this._forceShowBoundingBoxes || false;\n    },\n    set: function (value) {\n        this._forceShowBoundingBoxes = value;\n        // Lazyly creates a BB renderer if needed.\n        if (value) {\n            this.getBoundingBoxRenderer();\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.getBoundingBoxRenderer = function () {\n    if (!this._boundingBoxRenderer) {\n        this._boundingBoxRenderer = new BoundingBoxRenderer(this);\n    }\n    return this._boundingBoxRenderer;\n};\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\n    get: function () {\n        return this._showBoundingBox || false;\n    },\n    set: function (value) {\n        this._showBoundingBox = value;\n        // Lazyly creates a BB renderer if needed.\n        if (value) {\n            this.getScene().getBoundingBoxRenderer();\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * Component responsible of rendering the bounding box of the meshes in a scene.\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\n */\nvar BoundingBoxRenderer = /** @class */ (function () {\n    /**\n     * Instantiates a new bounding box renderer in a scene.\n     * @param scene the scene the  renderer renders in\n     */\n    function BoundingBoxRenderer(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\n        /**\n         * Color of the bounding box lines placed in front of an object\n         */\n        this.frontColor = new Color3(1, 1, 1);\n        /**\n         * Color of the bounding box lines placed behind an object\n         */\n        this.backColor = new Color3(0.1, 0.1, 0.1);\n        /**\n         * Defines if the renderer should show the back lines or not\n         */\n        this.showBackLines = true;\n        /**\n         * Observable raised before rendering a bounding box\n         */\n        this.onBeforeBoxRenderingObservable = new Observable();\n        /**\n         * Observable raised after rendering a bounding box\n         */\n        this.onAfterBoxRenderingObservable = new Observable();\n        /**\n         * Observable raised after resources are created\n         */\n        this.onResourcesReadyObservable = new Observable();\n        /**\n         * When false, no bounding boxes will be rendered\n         */\n        this.enabled = true;\n        /**\n         * @hidden\n         */\n        this.renderList = new SmartArray(32);\n        this._vertexBuffers = {};\n        this._fillIndexBuffer = null;\n        this._fillIndexData = null;\n        this.scene = scene;\n        scene._addComponent(this);\n        this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", !this.scene.getEngine().isWebGPU);\n        this._buildUniformLayout(this._uniformBufferFront);\n        this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", !this.scene.getEngine().isWebGPU);\n        this._buildUniformLayout(this._uniformBufferBack);\n    }\n    BoundingBoxRenderer.prototype._buildUniformLayout = function (ubo) {\n        ubo.addUniform(\"color\", 4);\n        ubo.addUniform(\"world\", 16);\n        ubo.addUniform(\"viewProjection\", 16);\n        ubo.addUniform(\"viewProjectionR\", 16);\n        ubo.create();\n    };\n    /**\n     * Registers the component in a given scene\n     */\n    BoundingBoxRenderer.prototype.register = function () {\n        this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\n        this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\n        this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\n    };\n    BoundingBoxRenderer.prototype._evaluateSubMesh = function (mesh, subMesh) {\n        if (mesh.showSubMeshesBoundingBox) {\n            var boundingInfo = subMesh.getBoundingInfo();\n            if (boundingInfo !== null && boundingInfo !== undefined) {\n                boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n                this.renderList.push(boundingInfo.boundingBox);\n            }\n        }\n    };\n    BoundingBoxRenderer.prototype._preActiveMesh = function (mesh) {\n        if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\n            var boundingInfo = mesh.getBoundingInfo();\n            boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n            this.renderList.push(boundingInfo.boundingBox);\n        }\n    };\n    BoundingBoxRenderer.prototype._prepareResources = function () {\n        if (this._colorShader) {\n            return;\n        }\n        this._colorShader = new ShaderMaterial(\"colorShader\", this.scene, \"boundingBoxRenderer\", {\n            attributes: [VertexBuffer.PositionKind],\n            uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n            uniformBuffers: [\"BoundingBoxRenderer\"],\n        }, false);\n        this._colorShader.reservedDataStore = {\n            hidden: true,\n        };\n        this._colorShaderForOcclusionQuery = new ShaderMaterial(\"colorShaderOccQuery\", this.scene, \"boundingBoxRenderer\", {\n            attributes: [VertexBuffer.PositionKind],\n            uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n            uniformBuffers: [\"BoundingBoxRenderer\"],\n        }, true);\n        this._colorShaderForOcclusionQuery.reservedDataStore = {\n            hidden: true,\n        };\n        var engine = this.scene.getEngine();\n        var boxdata = CreateBoxVertexData({ size: 1.0 });\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);\n        this._createIndexBuffer();\n        this._fillIndexData = boxdata.indices;\n        this.onResourcesReadyObservable.notifyObservers(this);\n    };\n    BoundingBoxRenderer.prototype._createIndexBuffer = function () {\n        var engine = this.scene.getEngine();\n        this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\n    };\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    BoundingBoxRenderer.prototype.rebuild = function () {\n        var vb = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (vb) {\n            vb._rebuild();\n        }\n        this._createIndexBuffer();\n    };\n    /**\n     * @hidden\n     */\n    BoundingBoxRenderer.prototype.reset = function () {\n        this.renderList.reset();\n    };\n    /**\n     * Render the bounding boxes of a specific rendering group\n     * @param renderingGroupId defines the rendering group to render\n     */\n    BoundingBoxRenderer.prototype.render = function (renderingGroupId) {\n        var _a, _b;\n        if (this.renderList.length === 0 || !this.enabled) {\n            return;\n        }\n        this._prepareResources();\n        if (!this._colorShader.isReady()) {\n            return;\n        }\n        var engine = this.scene.getEngine();\n        engine.setDepthWrite(false);\n        var frontColor = this.frontColor.toColor4();\n        var backColor = this.backColor.toColor4();\n        var transformMatrix = this.scene.getTransformMatrix();\n        for (var boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\n            var boundingBox = this.renderList.data[boundingBoxIndex];\n            if (boundingBox._tag !== renderingGroupId) {\n                continue;\n            }\n            this._createWrappersForBoundingBox(boundingBox);\n            this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\n            var min = boundingBox.minimum;\n            var max = boundingBox.maximum;\n            var diff = max.subtract(min);\n            var median = min.add(diff.scale(0.5));\n            var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n            var useReverseDepthBuffer = engine.useReverseDepthBuffer;\n            if (this.showBackLines) {\n                var drawWrapperBack = (_a = boundingBox._drawWrapperBack) !== null && _a !== void 0 ? _a : this._colorShader._getDrawWrapper();\n                this._colorShader._preBind(drawWrapperBack);\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n                // Back\n                if (useReverseDepthBuffer) {\n                    engine.setDepthFunctionToLessOrEqual();\n                }\n                else {\n                    engine.setDepthFunctionToGreaterOrEqual();\n                }\n                this._uniformBufferBack.bindToEffect(drawWrapperBack.effect, \"BoundingBoxRenderer\");\n                this._uniformBufferBack.updateDirectColor4(\"color\", backColor);\n                this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\n                this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\n                this._uniformBufferBack.update();\n                // Draw order\n                engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n            }\n            var drawWrapperFront = (_b = boundingBox._drawWrapperFront) !== null && _b !== void 0 ? _b : this._colorShader._getDrawWrapper();\n            this._colorShader._preBind(drawWrapperFront);\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n            // Front\n            if (useReverseDepthBuffer) {\n                engine.setDepthFunctionToGreater();\n            }\n            else {\n                engine.setDepthFunctionToLess();\n            }\n            this._uniformBufferFront.bindToEffect(drawWrapperFront.effect, \"BoundingBoxRenderer\");\n            this._uniformBufferFront.updateDirectColor4(\"color\", frontColor);\n            this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n            this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\n            this._uniformBufferFront.update();\n            // Draw order\n            engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n            this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\n        }\n        this._colorShader.unbind();\n        engine.setDepthFunctionToLessOrEqual();\n        engine.setDepthWrite(true);\n    };\n    BoundingBoxRenderer.prototype._createWrappersForBoundingBox = function (boundingBox) {\n        if (!boundingBox._drawWrapperFront) {\n            var engine = this.scene.getEngine();\n            boundingBox._drawWrapperFront = new DrawWrapper(engine);\n            boundingBox._drawWrapperBack = new DrawWrapper(engine);\n            boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\n            boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\n        }\n    };\n    /**\n     * In case of occlusion queries, we can render the occlusion bounding box through this method\n     * @param mesh Define the mesh to render the occlusion bounding box for\n     */\n    BoundingBoxRenderer.prototype.renderOcclusionBoundingBox = function (mesh) {\n        var engine = this.scene.getEngine();\n        if (this._renderPassIdForOcclusionQuery === undefined) {\n            this._renderPassIdForOcclusionQuery = engine.createRenderPassId(\"Render pass for occlusion query\");\n        }\n        var currentRenderPassId = engine.currentRenderPassId;\n        engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\n        this._prepareResources();\n        var subMesh = mesh.subMeshes[0];\n        if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\n            engine.currentRenderPassId = currentRenderPassId;\n            return;\n        }\n        if (!this._fillIndexBuffer) {\n            this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);\n        }\n        var useReverseDepthBuffer = engine.useReverseDepthBuffer;\n        engine.setDepthWrite(false);\n        engine.setColorWrite(false);\n        var boundingBox = mesh.getBoundingInfo().boundingBox;\n        var min = boundingBox.minimum;\n        var max = boundingBox.maximum;\n        var diff = max.subtract(min);\n        var median = min.add(diff.scale(0.5));\n        var worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n        var drawWrapper = subMesh._drawWrapper;\n        this._colorShaderForOcclusionQuery._preBind(drawWrapper);\n        engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, drawWrapper.effect);\n        if (useReverseDepthBuffer) {\n            engine.setDepthFunctionToGreater();\n        }\n        else {\n            engine.setDepthFunctionToLess();\n        }\n        this.scene.resetCachedMaterial();\n        this._uniformBufferFront.bindToEffect(drawWrapper.effect, \"BoundingBoxRenderer\");\n        this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n        this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\n        this._uniformBufferFront.update();\n        engine.drawElementsType(Material.TriangleFillMode, 0, 36);\n        this._colorShaderForOcclusionQuery.unbind();\n        engine.setDepthFunctionToLessOrEqual();\n        engine.setDepthWrite(true);\n        engine.setColorWrite(true);\n        engine.currentRenderPassId = currentRenderPassId;\n    };\n    /**\n     * Dispose and release the resources attached to this renderer.\n     */\n    BoundingBoxRenderer.prototype.dispose = function () {\n        if (this._renderPassIdForOcclusionQuery !== undefined) {\n            this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\n            this._renderPassIdForOcclusionQuery = undefined;\n        }\n        if (!this._colorShader) {\n            return;\n        }\n        this.onBeforeBoxRenderingObservable.clear();\n        this.onAfterBoxRenderingObservable.clear();\n        this.onResourcesReadyObservable.clear();\n        this.renderList.dispose();\n        this._colorShader.dispose();\n        this._colorShaderForOcclusionQuery.dispose();\n        this._uniformBufferFront.dispose();\n        this._uniformBufferBack.dispose();\n        var buffer = this._vertexBuffers[VertexBuffer.PositionKind];\n        if (buffer) {\n            buffer.dispose();\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\n        }\n        this.scene.getEngine()._releaseBuffer(this._indexBuffer);\n        if (this._fillIndexBuffer) {\n            this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\n            this._fillIndexBuffer = null;\n        }\n    };\n    return BoundingBoxRenderer;\n}());\nexport { BoundingBoxRenderer };\n//# sourceMappingURL=boundingBoxRenderer.js.map","import { Scene } from \"../scene.js\";\nimport { DepthRenderer } from \"./depthRenderer.js\";\n\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nScene.prototype.enableDepthRenderer = function (camera, storeNonLinearDepth, force32bitsFloat) {\n    if (storeNonLinearDepth === void 0) { storeNonLinearDepth = false; }\n    if (force32bitsFloat === void 0) { force32bitsFloat = false; }\n    camera = camera || this.activeCamera;\n    if (!camera) {\n        throw \"No camera available to enable depth renderer\";\n    }\n    if (!this._depthRenderer) {\n        this._depthRenderer = {};\n    }\n    if (!this._depthRenderer[camera.id]) {\n        var supportFullfloat = !!this.getEngine().getCaps().textureFloatRender;\n        var textureType = 0;\n        if (this.getEngine().getCaps().textureHalfFloatRender && (!force32bitsFloat || !supportFullfloat)) {\n            textureType = 2;\n        }\n        else if (supportFullfloat) {\n            textureType = 1;\n        }\n        else {\n            textureType = 0;\n        }\n        this._depthRenderer[camera.id] = new DepthRenderer(this, textureType, camera, storeNonLinearDepth);\n    }\n    return this._depthRenderer[camera.id];\n};\nScene.prototype.disableDepthRenderer = function (camera) {\n    camera = camera || this.activeCamera;\n    if (!camera || !this._depthRenderer || !this._depthRenderer[camera.id]) {\n        return;\n    }\n    this._depthRenderer[camera.id].dispose();\n};\n/**\n * Defines the Depth Renderer scene component responsible to manage a depth buffer useful\n * in several rendering techniques.\n */\nvar DepthRendererSceneComponent = /** @class */ (function () {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    function DepthRendererSceneComponent(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_DEPTHRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    DepthRendererSceneComponent.prototype.register = function () {\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER, this, this._gatherRenderTargets);\n        this.scene._gatherActiveCameraRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER, this, this._gatherActiveCameraRenderTargets);\n    };\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    DepthRendererSceneComponent.prototype.rebuild = function () {\n        // Nothing to do for this component\n    };\n    /**\n     * Disposes the component and the associated resources\n     */\n    DepthRendererSceneComponent.prototype.dispose = function () {\n        for (var key in this.scene._depthRenderer) {\n            this.scene._depthRenderer[key].dispose();\n        }\n    };\n    DepthRendererSceneComponent.prototype._gatherRenderTargets = function (renderTargets) {\n        if (this.scene._depthRenderer) {\n            for (var key in this.scene._depthRenderer) {\n                var depthRenderer = this.scene._depthRenderer[key];\n                if (depthRenderer.enabled && !depthRenderer.useOnlyInActiveCamera) {\n                    renderTargets.push(depthRenderer.getDepthMap());\n                }\n            }\n        }\n    };\n    DepthRendererSceneComponent.prototype._gatherActiveCameraRenderTargets = function (renderTargets) {\n        if (this.scene._depthRenderer) {\n            for (var key in this.scene._depthRenderer) {\n                var depthRenderer = this.scene._depthRenderer[key];\n                if (depthRenderer.enabled && depthRenderer.useOnlyInActiveCamera && this.scene.activeCamera.id === key) {\n                    renderTargets.push(depthRenderer.getDepthMap());\n                }\n            }\n        }\n    };\n    return DepthRendererSceneComponent;\n}());\nexport { DepthRendererSceneComponent };\nDepthRenderer._SceneComponentInitialization = function (scene) {\n    // Register the G Buffer component to the scene.\n    var component = scene._getComponent(SceneComponentConstants.NAME_DEPTHRENDERER);\n    if (!component) {\n        component = new DepthRendererSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=depthRendererSceneComponent.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"oitFinalPixelShader\";\nvar shader = \"precision highp float;\\nuniform sampler2D uFrontColor;\\nuniform sampler2D uBackColor;\\nvoid main() {\\nivec2 fragCoord=ivec2(gl_FragCoord.xy);\\nvec4 frontColor=texelFetch(uFrontColor,fragCoord,0);\\nvec4 backColor=texelFetch(uBackColor,fragCoord,0);\\nfloat alphaMultiplier=1.0-frontColor.a;\\nglFragColor=vec4(\\nfrontColor.rgb+alphaMultiplier*backColor.rgb,\\nfrontColor.a+backColor.a\\n);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var oitFinalPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=oitFinal.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"oitBackBlendPixelShader\";\nvar shader = \"precision highp float;\\nuniform sampler2D uBackColor;\\nvoid main() {\\nglFragColor=texelFetch(uBackColor,ivec2(gl_FragCoord.xy),0);\\nif (glFragColor.a==0.0) { \\ndiscard;\\n}\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var oitBackBlendPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=oitBackBlend.fragment.js.map","/**\n * Implementation based on https://medium.com/@shrekshao_71662/dual-depth-peeling-implementation-in-webgl-11baa061ba4b\n */\n\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { ThinTexture } from \"../Materials/Textures/thinTexture.js\";\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Material } from \"../Materials/material.js\";\nimport \"../Shaders/postprocess.vertex.js\";\nimport \"../Shaders/oitFinal.fragment.js\";\nimport \"../Shaders/oitBackBlend.fragment.js\";\nvar DepthPeelingEffectConfiguration = /** @class */ (function () {\n    function DepthPeelingEffectConfiguration() {\n        /**\n         * Is this effect enabled\n         */\n        this.enabled = true;\n        /**\n         * Name of the configuration\n         */\n        this.name = \"depthPeeling\";\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [4];\n    }\n    return DepthPeelingEffectConfiguration;\n}());\n/**\n * The depth peeling renderer that performs\n * Order independant transparency (OIT).\n * This should not be instanciated directly, as it is part of a scene component\n */\nvar DepthPeelingRenderer = /** @class */ (function () {\n    /**\n     * Instanciates the depth peeling renderer\n     * @param scene Scene to attach to\n     * @param passCount Number of depth layers to peel\n     * @returns The depth peeling renderer\n     */\n    function DepthPeelingRenderer(scene, passCount) {\n        if (passCount === void 0) { passCount = 5; }\n        this._thinTextures = [];\n        this._currentPingPongState = 0;\n        this._layoutCacheFormat = [[true], [true, true], [true, true, true]];\n        this._layoutCache = [];\n        this._candidateSubMeshes = new SmartArray(10);\n        this._excludedSubMeshes = new SmartArray(10);\n        this._colorCache = [\n            new Color4(DepthPeelingRenderer._DEPTH_CLEAR_VALUE, DepthPeelingRenderer._DEPTH_CLEAR_VALUE, 0, 0),\n            new Color4(-DepthPeelingRenderer._MIN_DEPTH, DepthPeelingRenderer._MAX_DEPTH, 0, 0),\n            new Color4(0, 0, 0, 0),\n        ];\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._passCount = passCount;\n        //  We need a depth texture for opaque\n        if (!scene.enablePrePassRenderer()) {\n            Logger.Warn(\"Depth peeling for order independant transparency could not enable PrePass, aborting.\");\n            return;\n        }\n        for (var i = 0; i < this._layoutCacheFormat.length; ++i) {\n            this._layoutCache[i] = this._engine.buildTextureLayout(this._layoutCacheFormat[i]);\n        }\n        this._renderPassIds = [];\n        this.useRenderPasses = false;\n        this._prePassEffectConfiguration = new DepthPeelingEffectConfiguration();\n        this._createTextures();\n        this._createEffects();\n    }\n    Object.defineProperty(DepthPeelingRenderer.prototype, \"passCount\", {\n        /**\n         * Number of depth peeling passes. As we are using dual depth peeling, each pass two levels of transparency are processed.\n         */\n        get: function () {\n            return this._passCount;\n        },\n        set: function (count) {\n            if (this._passCount === count) {\n                return;\n            }\n            this._passCount = count;\n            this._createRenderPassIds();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DepthPeelingRenderer.prototype, \"useRenderPasses\", {\n        /**\n         * Instructs the renderer to use render passes. It is an optimization that makes the rendering faster for some engines (like WebGPU) but that consumes more memory, so it is disabled by default.\n         */\n        get: function () {\n            return this._useRenderPasses;\n        },\n        set: function (usePasses) {\n            if (this._useRenderPasses === usePasses) {\n                return;\n            }\n            this._useRenderPasses = usePasses;\n            this._createRenderPassIds();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DepthPeelingRenderer.prototype._createRenderPassIds = function () {\n        this._releaseRenderPassIds();\n        if (this._useRenderPasses) {\n            for (var i = 0; i < this._passCount + 1; ++i) {\n                if (!this._renderPassIds[i]) {\n                    this._renderPassIds[i] = this._engine.createRenderPassId(\"DepthPeelingRenderer - pass #\".concat(i));\n                }\n            }\n        }\n    };\n    DepthPeelingRenderer.prototype._releaseRenderPassIds = function () {\n        for (var i = 0; i < this._renderPassIds.length; ++i) {\n            this._engine.releaseRenderPassId(this._renderPassIds[i]);\n        }\n        this._renderPassIds = [];\n    };\n    DepthPeelingRenderer.prototype._createTextures = function () {\n        var size = {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        };\n        // 2 for ping pong\n        this._depthMrts = [new MultiRenderTarget(\"depthPeelingDepth0\", size, 1, this._scene), new MultiRenderTarget(\"depthPeelingDepth1\", size, 1, this._scene)];\n        this._colorMrts = [\n            new MultiRenderTarget(\"depthPeelingColor0\", size, 1, this._scene, { generateDepthBuffer: false }),\n            new MultiRenderTarget(\"depthPeelingColor1\", size, 1, this._scene, { generateDepthBuffer: false }),\n        ];\n        this._blendBackMrt = new MultiRenderTarget(\"depthPeelingBack\", size, 1, this._scene, { generateDepthBuffer: false });\n        // 0 is a depth texture\n        // 1 is a color texture\n        var optionsArray = [\n            {\n                format: 7,\n                samplingMode: 1,\n                type: this._engine.getCaps().textureFloatLinearFiltering ? 1 : 2,\n            },\n            {\n                format: 5,\n                samplingMode: 1,\n                type: 2,\n            },\n        ];\n        for (var i = 0; i < 2; i++) {\n            var depthTexture = this._engine._createInternalTexture(size, optionsArray[0], false);\n            var frontColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);\n            var backColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);\n            this._depthMrts[i].setInternalTexture(depthTexture, 0);\n            this._depthMrts[i].setInternalTexture(frontColorTexture, 1);\n            this._depthMrts[i].setInternalTexture(backColorTexture, 2);\n            this._colorMrts[i].setInternalTexture(frontColorTexture, 0);\n            this._colorMrts[i].setInternalTexture(backColorTexture, 1);\n            this._thinTextures.push(new ThinTexture(depthTexture), new ThinTexture(frontColorTexture), new ThinTexture(backColorTexture));\n        }\n    };\n    DepthPeelingRenderer.prototype._disposeTextures = function () {\n        for (var i = 0; i < this._thinTextures.length; i++) {\n            if (i === 6) {\n                // Do not dispose the shared texture with the prepass\n                continue;\n            }\n            this._thinTextures[i].dispose();\n        }\n        for (var i = 0; i < 2; i++) {\n            this._depthMrts[i].dispose(true);\n            this._colorMrts[i].dispose(true);\n            this._blendBackMrt.dispose(true);\n        }\n        this._thinTextures = [];\n        this._colorMrts = [];\n        this._depthMrts = [];\n    };\n    DepthPeelingRenderer.prototype._updateTextures = function () {\n        if (this._depthMrts[0].getSize().width !== this._engine.getRenderWidth() || this._depthMrts[0].getSize().height !== this._engine.getRenderHeight()) {\n            this._disposeTextures();\n            this._createTextures();\n        }\n        return this._updateTextureReferences();\n    };\n    DepthPeelingRenderer.prototype._updateTextureReferences = function () {\n        var _a;\n        var prePassRenderer = this._scene.prePassRenderer;\n        if (!prePassRenderer) {\n            return false;\n        }\n        // Retrieve opaque color texture\n        var textureIndex = prePassRenderer.getIndex(4);\n        var prePassTexture = ((_a = prePassRenderer.defaultRT.textures) === null || _a === void 0 ? void 0 : _a.length) ? prePassRenderer.defaultRT.textures[textureIndex].getInternalTexture() : null;\n        if (!prePassTexture) {\n            return false;\n        }\n        if (this._blendBackTexture !== prePassTexture) {\n            this._blendBackTexture = prePassTexture;\n            this._blendBackMrt.setInternalTexture(this._blendBackTexture, 0);\n            if (this._thinTextures[6]) {\n                this._thinTextures[6].dispose();\n            }\n            this._thinTextures[6] = new ThinTexture(this._blendBackTexture);\n            prePassRenderer.defaultRT.renderTarget._shareDepth(this._depthMrts[0].renderTarget);\n        }\n        return true;\n    };\n    DepthPeelingRenderer.prototype._createEffects = function () {\n        this._blendBackEffectWrapper = new EffectWrapper({\n            fragmentShader: \"oitBackBlend\",\n            useShaderStore: true,\n            engine: this._engine,\n            samplerNames: [\"uBackColor\"],\n            uniformNames: [],\n        });\n        this._blendBackEffectWrapperPingPong = new EffectWrapper({\n            fragmentShader: \"oitBackBlend\",\n            useShaderStore: true,\n            engine: this._engine,\n            samplerNames: [\"uBackColor\"],\n            uniformNames: [],\n        });\n        this._finalEffectWrapper = new EffectWrapper({\n            fragmentShader: \"oitFinal\",\n            useShaderStore: true,\n            engine: this._engine,\n            samplerNames: [\"uFrontColor\", \"uBackColor\"],\n            uniformNames: [],\n        });\n        this._effectRenderer = new EffectRenderer(this._engine);\n    };\n    /**\n     * Links to the prepass renderer\n     * @param prePassRenderer The scene PrePassRenderer\n     */\n    DepthPeelingRenderer.prototype.setPrePassRenderer = function (prePassRenderer) {\n        prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\n    };\n    /**\n     * Binds depth peeling textures on an effect\n     * @param effect The effect to bind textures on\n     */\n    DepthPeelingRenderer.prototype.bind = function (effect) {\n        effect.setTexture(\"oitDepthSampler\", this._thinTextures[this._currentPingPongState * 3]);\n        effect.setTexture(\"oitFrontColorSampler\", this._thinTextures[this._currentPingPongState * 3 + 1]);\n    };\n    DepthPeelingRenderer.prototype._renderSubMeshes = function (transparentSubMeshes) {\n        var mapMaterialContext;\n        if (this._useRenderPasses) {\n            mapMaterialContext = {};\n        }\n        for (var j = 0; j < transparentSubMeshes.length; j++) {\n            var material = transparentSubMeshes.data[j].getMaterial();\n            var previousShaderHotSwapping = true;\n            var previousBFC = false;\n            var subMesh = transparentSubMeshes.data[j];\n            var drawWrapper = void 0;\n            var firstDraw = false;\n            if (this._useRenderPasses) {\n                drawWrapper = subMesh._getDrawWrapper();\n                firstDraw = !drawWrapper;\n            }\n            if (material) {\n                previousShaderHotSwapping = material.allowShaderHotSwapping;\n                previousBFC = material.backFaceCulling;\n                material.allowShaderHotSwapping = false;\n                material.backFaceCulling = false;\n            }\n            subMesh.render(false);\n            if (firstDraw) {\n                // first time we draw this submesh: we replace the material context\n                drawWrapper = subMesh._getDrawWrapper(); // we are sure it is now non empty as we just rendered the submesh\n                if (drawWrapper.materialContext) {\n                    var newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId];\n                    if (!newMaterialContext) {\n                        newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId] = this._engine.createMaterialContext();\n                    }\n                    subMesh._getDrawWrapper().materialContext = newMaterialContext;\n                }\n            }\n            if (material) {\n                material.allowShaderHotSwapping = previousShaderHotSwapping;\n                material.backFaceCulling = previousBFC;\n            }\n        }\n    };\n    DepthPeelingRenderer.prototype._finalCompose = function (writeId) {\n        this._engine.restoreDefaultFramebuffer();\n        this._engine.setAlphaMode(0);\n        this._engine.applyStates();\n        this._engine.enableEffect(this._finalEffectWrapper._drawWrapper);\n        this._finalEffectWrapper.effect.setTexture(\"uFrontColor\", this._thinTextures[writeId * 3 + 1]);\n        this._finalEffectWrapper.effect.setTexture(\"uBackColor\", this._thinTextures[6]);\n        this._effectRenderer.render(this._finalEffectWrapper);\n    };\n    /**\n     * Renders transparent submeshes with depth peeling\n     * @param transparentSubMeshes List of transparent meshes to render\n     * @returns The array of submeshes that could not be handled by this renderer\n     */\n    DepthPeelingRenderer.prototype.render = function (transparentSubMeshes) {\n        this._candidateSubMeshes.length = 0;\n        this._excludedSubMeshes.length = 0;\n        if (!this._blendBackEffectWrapper.effect.isReady() ||\n            !this._blendBackEffectWrapperPingPong.effect.isReady() ||\n            !this._finalEffectWrapper.effect.isReady() ||\n            !this._updateTextures()) {\n            return this._excludedSubMeshes;\n        }\n        for (var i = 0; i < transparentSubMeshes.length; i++) {\n            var material = transparentSubMeshes.data[i].getMaterial();\n            if (material &&\n                (material.fillMode === Material.TriangleFanDrawMode || material.fillMode === Material.TriangleFillMode || material.fillMode === Material.TriangleStripDrawMode)) {\n                this._candidateSubMeshes.push(transparentSubMeshes.data[i]);\n            }\n            else {\n                this._excludedSubMeshes.push(transparentSubMeshes.data[i]);\n            }\n        }\n        if (!this._candidateSubMeshes.length) {\n            this._finalCompose(1);\n            return this._excludedSubMeshes;\n        }\n        var currentRenderPassId = this._engine.currentRenderPassId;\n        this._scene.prePassRenderer._enabled = false;\n        if (this._useRenderPasses) {\n            this._engine.currentRenderPassId = this._renderPassIds[0];\n        }\n        // Clears\n        this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[0]);\n        this._engine.clear(this._colorCache[0], true, false, false);\n        this._engine.bindFramebuffer(this._depthMrts[1].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[0]);\n        this._engine.clear(this._colorCache[1], true, false, false);\n        this._engine.bindFramebuffer(this._colorMrts[0].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[1]);\n        this._engine.clear(this._colorCache[2], true, false, false);\n        this._engine.bindFramebuffer(this._colorMrts[1].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[1]);\n        this._engine.clear(this._colorCache[2], true, false, false);\n        // Draw depth for first pass\n        this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);\n        this._engine.bindAttachments(this._layoutCache[0]);\n        this._engine.setAlphaMode(11); // in WebGPU, when using MIN or MAX equation, the src / dst color factors should not use SRC_ALPHA and the src / dst alpha factors must be 1 else WebGPU will throw a validation error\n        this._engine.setAlphaEquation(3);\n        this._engine.depthCullingState.depthMask = false;\n        this._engine.depthCullingState.depthTest = true;\n        this._engine.applyStates();\n        this._currentPingPongState = 1;\n        // Render\n        this._renderSubMeshes(this._candidateSubMeshes);\n        this._scene.resetCachedMaterial();\n        // depth peeling ping-pong\n        var readId = 0;\n        var writeId = 0;\n        for (var i = 0; i < this._passCount; i++) {\n            readId = i % 2;\n            writeId = 1 - readId;\n            this._currentPingPongState = readId;\n            if (this._useRenderPasses) {\n                this._engine.currentRenderPassId = this._renderPassIds[i + 1];\n            }\n            // Clears\n            this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);\n            this._engine.bindAttachments(this._layoutCache[0]);\n            this._engine.clear(this._colorCache[0], true, false, false);\n            this._engine.bindFramebuffer(this._colorMrts[writeId].renderTarget);\n            this._engine.bindAttachments(this._layoutCache[1]);\n            this._engine.clear(this._colorCache[2], true, false, false);\n            this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);\n            this._engine.bindAttachments(this._layoutCache[2]);\n            this._engine.setAlphaMode(11); // the value does not matter (as MAX operation does not use them) but the src and dst color factors should not use SRC_ALPHA else WebGPU will throw a validation error\n            this._engine.setAlphaEquation(3);\n            this._engine.depthCullingState.depthTest = false;\n            this._engine.applyStates();\n            // Render\n            this._renderSubMeshes(this._candidateSubMeshes);\n            this._scene.resetCachedMaterial();\n            // Back color\n            this._engine.bindFramebuffer(this._blendBackMrt.renderTarget);\n            this._engine.bindAttachments(this._layoutCache[0]);\n            this._engine.setAlphaEquation(0);\n            this._engine.setAlphaMode(17);\n            this._engine.applyStates();\n            var blendBackEffectWrapper = writeId === 0 || !this._useRenderPasses ? this._blendBackEffectWrapper : this._blendBackEffectWrapperPingPong;\n            this._engine.enableEffect(blendBackEffectWrapper._drawWrapper);\n            blendBackEffectWrapper.effect.setTexture(\"uBackColor\", this._thinTextures[writeId * 3 + 2]);\n            this._effectRenderer.render(blendBackEffectWrapper);\n        }\n        this._engine.currentRenderPassId = currentRenderPassId;\n        // Final composition on default FB\n        this._finalCompose(writeId);\n        this._scene.prePassRenderer._enabled = true;\n        this._engine.depthCullingState.depthMask = true;\n        this._engine.depthCullingState.depthTest = true;\n        return this._excludedSubMeshes;\n    };\n    /**\n     * Disposes the depth peeling renderer and associated ressources\n     */\n    DepthPeelingRenderer.prototype.dispose = function () {\n        this._disposeTextures();\n        this._blendBackEffectWrapper.dispose();\n        this._finalEffectWrapper.dispose();\n        this._effectRenderer.dispose();\n        this._releaseRenderPassIds();\n    };\n    DepthPeelingRenderer._DEPTH_CLEAR_VALUE = -99999.0;\n    DepthPeelingRenderer._MIN_DEPTH = 0;\n    DepthPeelingRenderer._MAX_DEPTH = 1;\n    return DepthPeelingRenderer;\n}());\nexport { DepthPeelingRenderer };\n//# sourceMappingURL=depthPeelingRenderer.js.map","\nimport { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { DepthPeelingRenderer } from \"./depthPeelingRenderer.js\";\nObject.defineProperty(Scene.prototype, \"depthPeelingRenderer\", {\n    get: function () {\n        if (!this._depthPeelingRenderer) {\n            var component = this._getComponent(SceneComponentConstants.NAME_DEPTHPEELINGRENDERER);\n            if (!component) {\n                component = new DepthPeelingSceneComponent(this);\n                this._addComponent(component);\n            }\n        }\n        return this._depthPeelingRenderer;\n    },\n    set: function (value) {\n        this._depthPeelingRenderer = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"useOrderIndependentTransparency\", {\n    get: function () {\n        return this._useOrderIndependentTransparency;\n    },\n    set: function (value) {\n        var _a;\n        if (this._useOrderIndependentTransparency === value) {\n            return;\n        }\n        this._useOrderIndependentTransparency = value;\n        this.markAllMaterialsAsDirty(63);\n        (_a = this.prePassRenderer) === null || _a === void 0 ? void 0 : _a.markAsDirty();\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * Scene component to render order independent transparency with depth peeling\n */\nvar DepthPeelingSceneComponent = /** @class */ (function () {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    function DepthPeelingSceneComponent(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_DEPTHPEELINGRENDERER;\n        this.scene = scene;\n        scene.depthPeelingRenderer = new DepthPeelingRenderer(scene);\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    DepthPeelingSceneComponent.prototype.register = function () { };\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    DepthPeelingSceneComponent.prototype.rebuild = function () { };\n    /**\n     * Disposes the component and the associated resources.\n     */\n    DepthPeelingSceneComponent.prototype.dispose = function () {\n        var _a;\n        (_a = this.scene.depthPeelingRenderer) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.scene.depthPeelingRenderer = null;\n    };\n    return DepthPeelingSceneComponent;\n}());\nexport { DepthPeelingSceneComponent };\n//# sourceMappingURL=depthPeelingSceneComponent.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nvar name = \"linePixelShader\";\nvar shader = \"#include<clipPlaneFragmentDeclaration>\\nuniform vec4 color;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<clipPlaneFragment>\\ngl_FragColor=color;\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var linePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=line.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nvar name = \"lineVertexShader\";\nvar shader = \"#include<instancesDeclaration>\\n#include<clipPlaneVertexDeclaration>\\nattribute vec3 position;\\nattribute vec4 normal;\\nuniform mat4 viewProjection;\\nuniform float width;\\nuniform float aspectRatio;\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\n#include<instancesVertex>\\nmat4 worldViewProjection=viewProjection*finalWorld;\\nvec4 viewPosition=worldViewProjection*vec4(position,1.0);\\nvec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);\\nvec2 currentScreen=viewPosition.xy/viewPosition.w;\\nvec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;\\ncurrentScreen.x*=aspectRatio;\\nnextScreen.x*=aspectRatio;\\nvec2 dir=normalize(nextScreen-currentScreen);\\nvec2 normalDir=vec2(-dir.y,dir.x);\\nnormalDir*=width/2.0;\\nnormalDir.x/=aspectRatio;\\nvec4 offset=vec4(normalDir*normal.w,0.0,0.0);\\ngl_Position=viewPosition+offset;\\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\\nvec4 worldPos=finalWorld*vec4(position,1.0);\\n#include<clipPlaneVertex>\\n#endif\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var lineVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=line.vertex.js.map","import { __extends } from \"tslib\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { LinesMesh, InstancedLinesMesh } from \"../Meshes/linesMesh.js\";\nimport { Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Camera } from \"../Cameras/camera.js\";\n\nimport \"../Shaders/line.fragment.js\";\nimport \"../Shaders/line.vertex.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nAbstractMesh.prototype.disableEdgesRendering = function () {\n    if (this._edgesRenderer) {\n        this._edgesRenderer.dispose();\n        this._edgesRenderer = null;\n    }\n    return this;\n};\nAbstractMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices, options) {\n    if (epsilon === void 0) { epsilon = 0.95; }\n    if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }\n    this.disableEdgesRendering();\n    this._edgesRenderer = new EdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices, true, options);\n    return this;\n};\nObject.defineProperty(AbstractMesh.prototype, \"edgesRenderer\", {\n    get: function () {\n        return this._edgesRenderer;\n    },\n    enumerable: true,\n    configurable: true,\n});\nLinesMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices) {\n    if (epsilon === void 0) { epsilon = 0.95; }\n    if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }\n    this.disableEdgesRendering();\n    this._edgesRenderer = new LineEdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);\n    return this;\n};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nInstancedLinesMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices) {\n    if (epsilon === void 0) { epsilon = 0.95; }\n    if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }\n    LinesMesh.prototype.enableEdgesRendering.apply(this, arguments);\n    return this;\n};\n/**\n * FaceAdjacencies Helper class to generate edges\n */\nvar FaceAdjacencies = /** @class */ (function () {\n    function FaceAdjacencies() {\n        this.edges = new Array();\n        this.edgesConnectedCount = 0;\n    }\n    return FaceAdjacencies;\n}());\n/**\n * This class is used to generate edges of the mesh that could then easily be rendered in a scene.\n */\nvar EdgesRenderer = /** @class */ (function () {\n    /**\n     * Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.\n     * Beware when you use this class with complex objects as the adjacencies computation can be really long\n     * @param  source Mesh used to create edges\n     * @param  epsilon sum of angles in adjacency to check for edge\n     * @param  checkVerticesInsteadOfIndices bases the edges detection on vertices vs indices. Note that this parameter is not used if options.useAlternateEdgeFinder = true\n     * @param  generateEdgesLines - should generate Lines or only prepare resources.\n     * @param  options The options to apply when generating the edges\n     */\n    function EdgesRenderer(source, epsilon, checkVerticesInsteadOfIndices, generateEdgesLines, options) {\n        if (epsilon === void 0) { epsilon = 0.95; }\n        if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }\n        if (generateEdgesLines === void 0) { generateEdgesLines = true; }\n        var _this = this;\n        var _a;\n        /**\n         * Define the size of the edges with an orthographic camera\n         */\n        this.edgesWidthScalerForOrthographic = 1000.0;\n        /**\n         * Define the size of the edges with a perspective camera\n         */\n        this.edgesWidthScalerForPerspective = 50.0;\n        this._linesPositions = new Array();\n        this._linesNormals = new Array();\n        this._linesIndices = new Array();\n        this._buffers = {};\n        this._buffersForInstances = {};\n        this._checkVerticesInsteadOfIndices = false;\n        /** Gets or sets a boolean indicating if the edgesRenderer is active */\n        this.isEnabled = true;\n        /**\n         * List of instances to render in case the source mesh has instances\n         */\n        this.customInstances = new SmartArray(32);\n        this._source = source;\n        this._checkVerticesInsteadOfIndices = checkVerticesInsteadOfIndices;\n        this._options = options !== null && options !== void 0 ? options : null;\n        this._epsilon = epsilon;\n        if (this._source.getScene().getEngine().isWebGPU) {\n            this._drawWrapper = new DrawWrapper(source.getEngine());\n        }\n        this._prepareRessources();\n        if (generateEdgesLines) {\n            if ((_a = options === null || options === void 0 ? void 0 : options.useAlternateEdgeFinder) !== null && _a !== void 0 ? _a : true) {\n                this._generateEdgesLinesAlternate();\n            }\n            else {\n                this._generateEdgesLines();\n            }\n        }\n        this._meshRebuildObserver = this._source.onRebuildObservable.add(function () {\n            _this._rebuild();\n        });\n        this._meshDisposeObserver = this._source.onDisposeObservable.add(function () {\n            _this.dispose();\n        });\n    }\n    Object.defineProperty(EdgesRenderer.prototype, \"linesPositions\", {\n        /** Gets the vertices generated by the edge renderer */\n        get: function () {\n            return this._linesPositions;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EdgesRenderer.prototype, \"linesNormals\", {\n        /** Gets the normals generated by the edge renderer */\n        get: function () {\n            return this._linesNormals;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EdgesRenderer.prototype, \"linesIndices\", {\n        /** Gets the indices generated by the edge renderer */\n        get: function () {\n            return this._linesIndices;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EdgesRenderer.prototype, \"lineShader\", {\n        /**\n         * Gets or sets the shader used to draw the lines\n         */\n        get: function () {\n            return this._lineShader;\n        },\n        set: function (shader) {\n            this._lineShader = shader;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EdgesRenderer._GetShader = function (scene) {\n        if (!scene._edgeRenderLineShader) {\n            var shader = new ShaderMaterial(\"lineShader\", scene, \"line\", {\n                attributes: [\"position\", \"normal\"],\n                uniforms: [\"world\", \"viewProjection\", \"color\", \"width\", \"aspectRatio\"],\n            }, false);\n            shader.disableDepthWrite = true;\n            shader.backFaceCulling = false;\n            shader.checkReadyOnEveryCall = scene.getEngine().isWebGPU;\n            scene._edgeRenderLineShader = shader;\n        }\n        return scene._edgeRenderLineShader;\n    };\n    EdgesRenderer.prototype._prepareRessources = function () {\n        if (this._lineShader) {\n            return;\n        }\n        this._lineShader = EdgesRenderer._GetShader(this._source.getScene());\n    };\n    /** @hidden */\n    EdgesRenderer.prototype._rebuild = function () {\n        var buffer = this._buffers[VertexBuffer.PositionKind];\n        if (buffer) {\n            buffer._rebuild();\n        }\n        buffer = this._buffers[VertexBuffer.NormalKind];\n        if (buffer) {\n            buffer._rebuild();\n        }\n        var scene = this._source.getScene();\n        var engine = scene.getEngine();\n        this._ib = engine.createIndexBuffer(this._linesIndices);\n    };\n    /**\n     * Releases the required resources for the edges renderer\n     */\n    EdgesRenderer.prototype.dispose = function () {\n        var _a;\n        this._source.onRebuildObservable.remove(this._meshRebuildObserver);\n        this._source.onDisposeObservable.remove(this._meshDisposeObserver);\n        var buffer = this._buffers[VertexBuffer.PositionKind];\n        if (buffer) {\n            buffer.dispose();\n            this._buffers[VertexBuffer.PositionKind] = null;\n        }\n        buffer = this._buffers[VertexBuffer.NormalKind];\n        if (buffer) {\n            buffer.dispose();\n            this._buffers[VertexBuffer.NormalKind] = null;\n        }\n        if (this._ib) {\n            this._source.getScene().getEngine()._releaseBuffer(this._ib);\n        }\n        this._lineShader.dispose();\n        (_a = this._drawWrapper) === null || _a === void 0 ? void 0 : _a.dispose();\n    };\n    EdgesRenderer.prototype._processEdgeForAdjacencies = function (pa, pb, p0, p1, p2) {\n        if ((pa === p0 && pb === p1) || (pa === p1 && pb === p0)) {\n            return 0;\n        }\n        if ((pa === p1 && pb === p2) || (pa === p2 && pb === p1)) {\n            return 1;\n        }\n        if ((pa === p2 && pb === p0) || (pa === p0 && pb === p2)) {\n            return 2;\n        }\n        return -1;\n    };\n    EdgesRenderer.prototype._processEdgeForAdjacenciesWithVertices = function (pa, pb, p0, p1, p2) {\n        var eps = 1e-10;\n        if ((pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p1, eps)) || (pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p0, eps))) {\n            return 0;\n        }\n        if ((pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p2, eps)) || (pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p1, eps))) {\n            return 1;\n        }\n        if ((pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p0, eps)) || (pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p2, eps))) {\n            return 2;\n        }\n        return -1;\n    };\n    /**\n     * Checks if the pair of p0 and p1 is en edge\n     * @param faceIndex\n     * @param edge\n     * @param faceNormals\n     * @param  p0\n     * @param  p1\n     * @private\n     */\n    EdgesRenderer.prototype._checkEdge = function (faceIndex, edge, faceNormals, p0, p1) {\n        var needToCreateLine;\n        if (edge === undefined) {\n            needToCreateLine = true;\n        }\n        else {\n            var dotProduct = Vector3.Dot(faceNormals[faceIndex], faceNormals[edge]);\n            needToCreateLine = dotProduct < this._epsilon;\n        }\n        if (needToCreateLine) {\n            this.createLine(p0, p1, this._linesPositions.length / 3);\n        }\n    };\n    /**\n     * push line into the position, normal and index buffer\n     * @param p0\n     * @param p1\n     * @param offset\n     * @protected\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    EdgesRenderer.prototype.createLine = function (p0, p1, offset) {\n        // Positions\n        this._linesPositions.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p1.x, p1.y, p1.z);\n        // Normals\n        this._linesNormals.push(p1.x, p1.y, p1.z, -1, p1.x, p1.y, p1.z, 1, p0.x, p0.y, p0.z, -1, p0.x, p0.y, p0.z, 1);\n        // Indices\n        this._linesIndices.push(offset, offset + 1, offset + 2, offset, offset + 2, offset + 3);\n    };\n    /**\n     * See https://playground.babylonjs.com/#R3JR6V#1 for a visual display of the algorithm\n     * @param edgePoints\n     * @param indexTriangle\n     * @param indices\n     * @param remapVertexIndices\n     */\n    EdgesRenderer.prototype._tessellateTriangle = function (edgePoints, indexTriangle, indices, remapVertexIndices) {\n        var makePointList = function (edgePoints, pointIndices, firstIndex) {\n            if (firstIndex >= 0) {\n                pointIndices.push(firstIndex);\n            }\n            for (var i = 0; i < edgePoints.length; ++i) {\n                pointIndices.push(edgePoints[i][0]);\n            }\n        };\n        var startEdge = 0;\n        if (edgePoints[1].length >= edgePoints[0].length && edgePoints[1].length >= edgePoints[2].length) {\n            startEdge = 1;\n        }\n        else if (edgePoints[2].length >= edgePoints[0].length && edgePoints[2].length >= edgePoints[1].length) {\n            startEdge = 2;\n        }\n        for (var e = 0; e < 3; ++e) {\n            if (e === startEdge) {\n                edgePoints[e].sort(function (a, b) { return (a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0); });\n            }\n            else {\n                edgePoints[e].sort(function (a, b) { return (a[1] > b[1] ? -1 : a[1] < b[1] ? 1 : 0); });\n            }\n        }\n        var mainPointIndices = [], otherPointIndices = [];\n        makePointList(edgePoints[startEdge], mainPointIndices, -1);\n        var numMainPoints = mainPointIndices.length;\n        for (var i = startEdge + 2; i >= startEdge + 1; --i) {\n            makePointList(edgePoints[i % 3], otherPointIndices, i !== startEdge + 2 ? remapVertexIndices[indices[indexTriangle + ((i + 1) % 3)]] : -1);\n        }\n        var numOtherPoints = otherPointIndices.length;\n        var idxMain = 0;\n        var idxOther = 0;\n        indices.push(remapVertexIndices[indices[indexTriangle + startEdge]], mainPointIndices[0], otherPointIndices[0]);\n        indices.push(remapVertexIndices[indices[indexTriangle + ((startEdge + 1) % 3)]], otherPointIndices[numOtherPoints - 1], mainPointIndices[numMainPoints - 1]);\n        var bucketIsMain = numMainPoints <= numOtherPoints;\n        var bucketStep = bucketIsMain ? numMainPoints : numOtherPoints;\n        var bucketLimit = bucketIsMain ? numOtherPoints : numMainPoints;\n        var bucketIdxLimit = bucketIsMain ? numMainPoints - 1 : numOtherPoints - 1;\n        var winding = bucketIsMain ? 0 : 1;\n        var numTris = numMainPoints + numOtherPoints - 2;\n        var bucketIdx = bucketIsMain ? idxMain : idxOther;\n        var nbucketIdx = bucketIsMain ? idxOther : idxMain;\n        var bucketPoints = bucketIsMain ? mainPointIndices : otherPointIndices;\n        var nbucketPoints = bucketIsMain ? otherPointIndices : mainPointIndices;\n        var bucket = 0;\n        while (numTris-- > 0) {\n            if (winding) {\n                indices.push(bucketPoints[bucketIdx], nbucketPoints[nbucketIdx]);\n            }\n            else {\n                indices.push(nbucketPoints[nbucketIdx], bucketPoints[bucketIdx]);\n            }\n            bucket += bucketStep;\n            var lastIdx = void 0;\n            if (bucket >= bucketLimit && bucketIdx < bucketIdxLimit) {\n                lastIdx = bucketPoints[++bucketIdx];\n                bucket -= bucketLimit;\n            }\n            else {\n                lastIdx = nbucketPoints[++nbucketIdx];\n            }\n            indices.push(lastIdx);\n        }\n        indices[indexTriangle + 0] = indices[indices.length - 3];\n        indices[indexTriangle + 1] = indices[indices.length - 2];\n        indices[indexTriangle + 2] = indices[indices.length - 1];\n        indices.length = indices.length - 3;\n    };\n    EdgesRenderer.prototype._generateEdgesLinesAlternate = function () {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        var positions = this._source.getVerticesData(VertexBuffer.PositionKind);\n        var indices = this._source.getIndices();\n        if (!indices || !positions) {\n            return;\n        }\n        if (!Array.isArray(indices)) {\n            indices = Array.from(indices);\n        }\n        /**\n         * Find all vertices that are at the same location (with an epsilon) and remapp them on the same vertex\n         */\n        var useFastVertexMerger = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.useFastVertexMerger) !== null && _b !== void 0 ? _b : true;\n        var epsVertexMerge = useFastVertexMerger ? Math.round(-Math.log((_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.epsilonVertexMerge) !== null && _d !== void 0 ? _d : 1e-6) / Math.log(10)) : (_f = (_e = this._options) === null || _e === void 0 ? void 0 : _e.epsilonVertexMerge) !== null && _f !== void 0 ? _f : 1e-6;\n        var remapVertexIndices = [];\n        var uniquePositions = []; // list of unique index of vertices - needed for tessellation\n        if (useFastVertexMerger) {\n            var mapVertices = {};\n            for (var v1 = 0; v1 < positions.length; v1 += 3) {\n                var x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];\n                var key = x1.toFixed(epsVertexMerge) + \"|\" + y1.toFixed(epsVertexMerge) + \"|\" + z1.toFixed(epsVertexMerge);\n                if (mapVertices[key] !== undefined) {\n                    remapVertexIndices.push(mapVertices[key]);\n                }\n                else {\n                    var idx = v1 / 3;\n                    mapVertices[key] = idx;\n                    remapVertexIndices.push(idx);\n                    uniquePositions.push(idx);\n                }\n            }\n        }\n        else {\n            for (var v1 = 0; v1 < positions.length; v1 += 3) {\n                var x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];\n                var found = false;\n                for (var v2 = 0; v2 < v1 && !found; v2 += 3) {\n                    var x2 = positions[v2 + 0], y2 = positions[v2 + 1], z2 = positions[v2 + 2];\n                    if (Math.abs(x1 - x2) < epsVertexMerge && Math.abs(y1 - y2) < epsVertexMerge && Math.abs(z1 - z2) < epsVertexMerge) {\n                        remapVertexIndices.push(v2 / 3);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    remapVertexIndices.push(v1 / 3);\n                    uniquePositions.push(v1 / 3);\n                }\n            }\n        }\n        if ((_g = this._options) === null || _g === void 0 ? void 0 : _g.applyTessellation) {\n            /**\n             * Tessellate triangles if necessary:\n             *\n             *               A\n             *               +\n             *               |\\\n             *               | \\\n             *               |  \\\n             *             E +   \\\n             *              /|    \\\n             *             / |     \\\n             *            /  |      \\\n             *           +---+-------+ B\n             *           D   C\n             *\n             * For the edges to be rendered correctly, the ABC triangle has to be split into ABE and BCE, else AC is considered to be an edge, whereas only AE should be.\n             *\n             * The tessellation process looks for the vertices like E that are in-between two other vertices making of an edge and create new triangles as necessary\n             */\n            // First step: collect the triangles to tessellate\n            var epsVertexAligned = (_j = (_h = this._options) === null || _h === void 0 ? void 0 : _h.epsilonVertexAligned) !== null && _j !== void 0 ? _j : 1e-6;\n            var mustTesselate = []; // liste of triangles that must be tessellated\n            for (var index = 0; index < indices.length; index += 3) {\n                // loop over all triangles\n                var triangleToTessellate = void 0;\n                for (var i = 0; i < 3; ++i) {\n                    // loop over the 3 edges of the triangle\n                    var p0Index = remapVertexIndices[indices[index + i]];\n                    var p1Index = remapVertexIndices[indices[index + ((i + 1) % 3)]];\n                    var p2Index = remapVertexIndices[indices[index + ((i + 2) % 3)]];\n                    if (p0Index === p1Index) {\n                        continue;\n                    } // degenerated triangle - don't process\n                    var p0x = positions[p0Index * 3 + 0], p0y = positions[p0Index * 3 + 1], p0z = positions[p0Index * 3 + 2];\n                    var p1x = positions[p1Index * 3 + 0], p1y = positions[p1Index * 3 + 1], p1z = positions[p1Index * 3 + 2];\n                    var p0p1 = Math.sqrt((p1x - p0x) * (p1x - p0x) + (p1y - p0y) * (p1y - p0y) + (p1z - p0z) * (p1z - p0z));\n                    for (var v = 0; v < uniquePositions.length - 1; v++) {\n                        // loop over all (unique) vertices and look for the ones that would be in-between p0 and p1\n                        var vIndex = uniquePositions[v];\n                        if (vIndex === p0Index || vIndex === p1Index || vIndex === p2Index) {\n                            continue;\n                        } // don't handle the vertex if it is a vertex of the current triangle\n                        var x = positions[vIndex * 3 + 0], y = positions[vIndex * 3 + 1], z = positions[vIndex * 3 + 2];\n                        var p0p = Math.sqrt((x - p0x) * (x - p0x) + (y - p0y) * (y - p0y) + (z - p0z) * (z - p0z));\n                        var pp1 = Math.sqrt((x - p1x) * (x - p1x) + (y - p1y) * (y - p1y) + (z - p1z) * (z - p1z));\n                        if (Math.abs(p0p + pp1 - p0p1) < epsVertexAligned) {\n                            // vertices are aligned and p in-between p0 and p1 if distance(p0, p) + distance (p, p1) ~ distance(p0, p1)\n                            if (!triangleToTessellate) {\n                                triangleToTessellate = {\n                                    index: index,\n                                    edgesPoints: [[], [], []],\n                                };\n                                mustTesselate.push(triangleToTessellate);\n                            }\n                            triangleToTessellate.edgesPoints[i].push([vIndex, p0p]);\n                        }\n                    }\n                }\n            }\n            // Second step: tesselate the triangles\n            for (var t = 0; t < mustTesselate.length; ++t) {\n                var triangle = mustTesselate[t];\n                this._tessellateTriangle(triangle.edgesPoints, triangle.index, indices, remapVertexIndices);\n            }\n            mustTesselate = null;\n        }\n        /**\n         * Collect the edges to render\n         */\n        var edges = {};\n        for (var index = 0; index < indices.length; index += 3) {\n            var faceNormal = void 0;\n            for (var i = 0; i < 3; ++i) {\n                var p0Index = remapVertexIndices[indices[index + i]];\n                var p1Index = remapVertexIndices[indices[index + ((i + 1) % 3)]];\n                var p2Index = remapVertexIndices[indices[index + ((i + 2) % 3)]];\n                if (p0Index === p1Index || ((p0Index === p2Index || p1Index === p2Index) && ((_k = this._options) === null || _k === void 0 ? void 0 : _k.removeDegeneratedTriangles))) {\n                    continue;\n                }\n                TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n                TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n                TmpVectors.Vector3[2].copyFromFloats(positions[p2Index * 3 + 0], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);\n                if (!faceNormal) {\n                    TmpVectors.Vector3[1].subtractToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[3]);\n                    TmpVectors.Vector3[2].subtractToRef(TmpVectors.Vector3[1], TmpVectors.Vector3[4]);\n                    faceNormal = Vector3.Cross(TmpVectors.Vector3[3], TmpVectors.Vector3[4]);\n                    faceNormal.normalize();\n                }\n                if (p0Index > p1Index) {\n                    var tmp = p0Index;\n                    p0Index = p1Index;\n                    p1Index = tmp;\n                }\n                var key = p0Index + \"_\" + p1Index;\n                var ei = edges[key];\n                if (ei) {\n                    if (!ei.done) {\n                        var dotProduct = Vector3.Dot(faceNormal, ei.normal);\n                        if (dotProduct < this._epsilon) {\n                            this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);\n                        }\n                        ei.done = true;\n                    }\n                }\n                else {\n                    edges[key] = { normal: faceNormal, done: false, index: index, i: i };\n                }\n            }\n        }\n        for (var key in edges) {\n            var ei = edges[key];\n            if (!ei.done) {\n                // Orphaned edge - we must display it\n                var p0Index = remapVertexIndices[indices[ei.index + ei.i]];\n                var p1Index = remapVertexIndices[indices[ei.index + ((ei.i + 1) % 3)]];\n                TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n                TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n                this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);\n            }\n        }\n        /**\n         * Merge into a single mesh\n         */\n        var engine = this._source.getScene().getEngine();\n        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\n        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\n        this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];\n        this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];\n        this._ib = engine.createIndexBuffer(this._linesIndices);\n        this._indicesCount = this._linesIndices.length;\n    };\n    /**\n     * Generates lines edges from adjacencjes\n     * @private\n     */\n    EdgesRenderer.prototype._generateEdgesLines = function () {\n        var positions = this._source.getVerticesData(VertexBuffer.PositionKind);\n        var indices = this._source.getIndices();\n        if (!indices || !positions) {\n            return;\n        }\n        // First let's find adjacencies\n        var adjacencies = new Array();\n        var faceNormals = new Array();\n        var index;\n        var faceAdjacencies;\n        // Prepare faces\n        for (index = 0; index < indices.length; index += 3) {\n            faceAdjacencies = new FaceAdjacencies();\n            var p0Index = indices[index];\n            var p1Index = indices[index + 1];\n            var p2Index = indices[index + 2];\n            faceAdjacencies.p0 = new Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n            faceAdjacencies.p1 = new Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n            faceAdjacencies.p2 = new Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);\n            var faceNormal = Vector3.Cross(faceAdjacencies.p1.subtract(faceAdjacencies.p0), faceAdjacencies.p2.subtract(faceAdjacencies.p1));\n            faceNormal.normalize();\n            faceNormals.push(faceNormal);\n            adjacencies.push(faceAdjacencies);\n        }\n        // Scan\n        for (index = 0; index < adjacencies.length; index++) {\n            faceAdjacencies = adjacencies[index];\n            for (var otherIndex = index + 1; otherIndex < adjacencies.length; otherIndex++) {\n                var otherFaceAdjacencies = adjacencies[otherIndex];\n                if (faceAdjacencies.edgesConnectedCount === 3) {\n                    // Full\n                    break;\n                }\n                if (otherFaceAdjacencies.edgesConnectedCount === 3) {\n                    // Full\n                    continue;\n                }\n                var otherP0 = indices[otherIndex * 3];\n                var otherP1 = indices[otherIndex * 3 + 1];\n                var otherP2 = indices[otherIndex * 3 + 2];\n                for (var edgeIndex = 0; edgeIndex < 3; edgeIndex++) {\n                    var otherEdgeIndex = 0;\n                    if (faceAdjacencies.edges[edgeIndex] !== undefined) {\n                        continue;\n                    }\n                    switch (edgeIndex) {\n                        case 0:\n                            if (this._checkVerticesInsteadOfIndices) {\n                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p0, faceAdjacencies.p1, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n                            }\n                            else {\n                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3], indices[index * 3 + 1], otherP0, otherP1, otherP2);\n                            }\n                            break;\n                        case 1:\n                            if (this._checkVerticesInsteadOfIndices) {\n                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p1, faceAdjacencies.p2, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n                            }\n                            else {\n                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 1], indices[index * 3 + 2], otherP0, otherP1, otherP2);\n                            }\n                            break;\n                        case 2:\n                            if (this._checkVerticesInsteadOfIndices) {\n                                otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p2, faceAdjacencies.p0, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n                            }\n                            else {\n                                otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 2], indices[index * 3], otherP0, otherP1, otherP2);\n                            }\n                            break;\n                    }\n                    if (otherEdgeIndex === -1) {\n                        continue;\n                    }\n                    faceAdjacencies.edges[edgeIndex] = otherIndex;\n                    otherFaceAdjacencies.edges[otherEdgeIndex] = index;\n                    faceAdjacencies.edgesConnectedCount++;\n                    otherFaceAdjacencies.edgesConnectedCount++;\n                    if (faceAdjacencies.edgesConnectedCount === 3) {\n                        break;\n                    }\n                }\n            }\n        }\n        // Create lines\n        for (index = 0; index < adjacencies.length; index++) {\n            // We need a line when a face has no adjacency on a specific edge or if all the adjacencies has an angle greater than epsilon\n            var current = adjacencies[index];\n            this._checkEdge(index, current.edges[0], faceNormals, current.p0, current.p1);\n            this._checkEdge(index, current.edges[1], faceNormals, current.p1, current.p2);\n            this._checkEdge(index, current.edges[2], faceNormals, current.p2, current.p0);\n        }\n        // Merge into a single mesh\n        var engine = this._source.getScene().getEngine();\n        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\n        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\n        this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];\n        this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];\n        this._ib = engine.createIndexBuffer(this._linesIndices);\n        this._indicesCount = this._linesIndices.length;\n    };\n    /**\n     * Checks whether or not the edges renderer is ready to render.\n     * @return true if ready, otherwise false.\n     */\n    EdgesRenderer.prototype.isReady = function () {\n        return this._lineShader.isReady(this._source, (this._source.hasInstances && this.customInstances.length > 0) || this._source.hasThinInstances);\n    };\n    /**\n     * Renders the edges of the attached mesh,\n     */\n    EdgesRenderer.prototype.render = function () {\n        var scene = this._source.getScene();\n        var currentDrawWrapper = this._lineShader._getDrawWrapper();\n        if (this._drawWrapper) {\n            this._lineShader._setDrawWrapper(this._drawWrapper);\n        }\n        if (!this.isReady() || !scene.activeCamera) {\n            this._lineShader._setDrawWrapper(currentDrawWrapper);\n            return;\n        }\n        var hasInstances = this._source.hasInstances && this.customInstances.length > 0;\n        var useBuffersWithInstances = hasInstances || this._source.hasThinInstances;\n        var instanceCount = 0;\n        if (useBuffersWithInstances) {\n            this._buffersForInstances[\"world0\"] = this._source.getVertexBuffer(\"world0\");\n            this._buffersForInstances[\"world1\"] = this._source.getVertexBuffer(\"world1\");\n            this._buffersForInstances[\"world2\"] = this._source.getVertexBuffer(\"world2\");\n            this._buffersForInstances[\"world3\"] = this._source.getVertexBuffer(\"world3\");\n            if (hasInstances) {\n                var instanceStorage = this._source._instanceDataStorage;\n                instanceCount = this.customInstances.length;\n                if (!instanceStorage.instancesData) {\n                    if (!this._source.getScene()._activeMeshesFrozen) {\n                        this.customInstances.reset();\n                    }\n                    return;\n                }\n                if (!instanceStorage.isFrozen) {\n                    var offset = 0;\n                    for (var i = 0; i < instanceCount; ++i) {\n                        this.customInstances.data[i].copyToArray(instanceStorage.instancesData, offset);\n                        offset += 16;\n                    }\n                    instanceStorage.instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instanceCount);\n                }\n            }\n            else {\n                instanceCount = this._source.thinInstanceCount;\n            }\n        }\n        var engine = scene.getEngine();\n        this._lineShader._preBind();\n        if (this._source.edgesColor.a !== 1) {\n            engine.setAlphaMode(2);\n        }\n        else {\n            engine.setAlphaMode(0);\n        }\n        // VBOs\n        engine.bindBuffers(useBuffersWithInstances ? this._buffersForInstances : this._buffers, this._ib, this._lineShader.getEffect());\n        scene.resetCachedMaterial();\n        this._lineShader.setColor4(\"color\", this._source.edgesColor);\n        if (scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA) {\n            this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForOrthographic);\n        }\n        else {\n            this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForPerspective);\n        }\n        this._lineShader.setFloat(\"aspectRatio\", engine.getAspectRatio(scene.activeCamera));\n        this._lineShader.bind(this._source.getWorldMatrix());\n        // Draw order\n        engine.drawElementsType(Material.TriangleFillMode, 0, this._indicesCount, instanceCount);\n        this._lineShader.unbind();\n        if (useBuffersWithInstances) {\n            engine.unbindInstanceAttributes();\n        }\n        if (!this._source.getScene()._activeMeshesFrozen) {\n            this.customInstances.reset();\n        }\n        this._lineShader._setDrawWrapper(currentDrawWrapper);\n    };\n    return EdgesRenderer;\n}());\nexport { EdgesRenderer };\n/**\n * LineEdgesRenderer for LineMeshes to remove unnecessary triangulation\n */\nvar LineEdgesRenderer = /** @class */ (function (_super) {\n    __extends(LineEdgesRenderer, _super);\n    /**\n     * This constructor turns off auto generating edges line in Edges Renderer to make it here.\n     * @param  source LineMesh used to generate edges\n     * @param  epsilon not important (specified angle for edge detection)\n     * @param  checkVerticesInsteadOfIndices not important for LineMesh\n     */\n    function LineEdgesRenderer(source, epsilon, checkVerticesInsteadOfIndices) {\n        if (epsilon === void 0) { epsilon = 0.95; }\n        if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }\n        var _this = _super.call(this, source, epsilon, checkVerticesInsteadOfIndices, false) || this;\n        _this._generateEdgesLines();\n        return _this;\n    }\n    /**\n     * Generate edges for each line in LinesMesh. Every Line should be rendered as edge.\n     */\n    LineEdgesRenderer.prototype._generateEdgesLines = function () {\n        var positions = this._source.getVerticesData(VertexBuffer.PositionKind);\n        var indices = this._source.getIndices();\n        if (!indices || !positions) {\n            return;\n        }\n        var p0 = TmpVectors.Vector3[0];\n        var p1 = TmpVectors.Vector3[1];\n        var len = indices.length - 1;\n        for (var i = 0, offset = 0; i < len; i += 2, offset += 4) {\n            Vector3.FromArrayToRef(positions, 3 * indices[i], p0);\n            Vector3.FromArrayToRef(positions, 3 * indices[i + 1], p1);\n            this.createLine(p0, p1, offset);\n        }\n        // Merge into a single mesh\n        var engine = this._source.getScene().getEngine();\n        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);\n        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);\n        this._ib = engine.createIndexBuffer(this._linesIndices);\n        this._indicesCount = this._linesIndices.length;\n    };\n    return LineEdgesRenderer;\n}(EdgesRenderer));\nexport { LineEdgesRenderer };\n//# sourceMappingURL=edgesRenderer.js.map","import { PrePassRenderTarget } from \"../Materials/Textures/prePassRenderTarget.js\";\n\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\n/**\n * Renders a pre pass of the scene\n * This means every mesh in the scene will be rendered to a render target texture\n * And then this texture will be composited to the rendering canvas with post processes\n * It is necessary for effects like subsurface scattering or deferred shading\n */\nvar PrePassRenderer = /** @class */ (function () {\n    /**\n     * Instantiates a prepass renderer\n     * @param scene The scene\n     */\n    function PrePassRenderer(scene) {\n        /**\n         * To save performance, we can excluded skinned meshes from the prepass\n         */\n        this.excludedSkinnedMesh = [];\n        /**\n         * Force material to be excluded from the prepass\n         * Can be useful when `useGeometryBufferFallback` is set to `true`\n         * and you don't want a material to show in the effect.\n         */\n        this.excludedMaterials = [];\n        /**\n         * Number of textures in the multi render target texture where the scene is directly rendered\n         */\n        this.mrtCount = 0;\n        this._mrtFormats = [];\n        this._mrtLayout = [];\n        this._mrtNames = [];\n        this._textureIndices = [];\n        this._isDirty = true;\n        /**\n         * Configuration for prepass effects\n         */\n        this._effectConfigurations = [];\n        /**\n         * Prevents the PrePassRenderer from using the GeometryBufferRenderer as a fallback\n         */\n        this.doNotUseGeometryRendererFallback = true;\n        /**\n         * All the render targets generated by prepass\n         */\n        this.renderTargets = [];\n        this._clearColor = new Color4(0, 0, 0, 0);\n        this._enabled = false;\n        this._needsCompositionForThisPass = false;\n        /**\n         * Set to true to disable gamma transform in PrePass.\n         * Can be useful in case you already proceed to gamma transform on a material level\n         * and your post processes don't need to be in linear color space.\n         */\n        this.disableGammaTransform = false;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        PrePassRenderer._SceneComponentInitialization(this._scene);\n        this.defaultRT = this._createRenderTarget(\"sceneprePassRT\", null);\n        this._currentTarget = this.defaultRT;\n    }\n    /**\n     * Returns the index of a texture in the multi render target texture array.\n     * @param type Texture type\n     * @return The index\n     */\n    PrePassRenderer.prototype.getIndex = function (type) {\n        return this._textureIndices[type];\n    };\n    Object.defineProperty(PrePassRenderer.prototype, \"samples\", {\n        /**\n         * How many samples are used for MSAA of the scene render target\n         */\n        get: function () {\n            return this.defaultRT.samples;\n        },\n        set: function (n) {\n            this.defaultRT.samples = n;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * @return the prepass render target for the rendering pass.\n     * If we are currently rendering a render target, it returns the PrePassRenderTarget\n     * associated with that render target. Otherwise, it returns the scene default PrePassRenderTarget\n     */\n    PrePassRenderer.prototype.getRenderTarget = function () {\n        return this._currentTarget;\n    };\n    /**\n     * @hidden\n     * Managed by the scene component\n     * @param prePassRenderTarget\n     */\n    PrePassRenderer.prototype._setRenderTarget = function (prePassRenderTarget) {\n        if (prePassRenderTarget) {\n            this._currentTarget = prePassRenderTarget;\n        }\n        else {\n            this._currentTarget = this.defaultRT;\n        }\n        this._engine.currentRenderPassId = this._currentTarget.renderPassId;\n    };\n    Object.defineProperty(PrePassRenderer.prototype, \"currentRTisSceneRT\", {\n        /**\n         * Returns true if the currently rendered prePassRenderTarget is the one\n         * associated with the scene.\n         */\n        get: function () {\n            return this._currentTarget === this.defaultRT;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    PrePassRenderer.prototype._refreshGeometryBufferRendererLink = function () {\n        if (!this.doNotUseGeometryRendererFallback) {\n            this._geometryBuffer = this._scene.enableGeometryBufferRenderer();\n            if (!this._geometryBuffer) {\n                // Not supported\n                this.doNotUseGeometryRendererFallback = true;\n                return;\n            }\n            this._geometryBuffer._linkPrePassRenderer(this);\n        }\n        else {\n            if (this._geometryBuffer) {\n                this._geometryBuffer._unlinkPrePassRenderer();\n            }\n            this._geometryBuffer = null;\n            this._scene.disableGeometryBufferRenderer();\n        }\n    };\n    Object.defineProperty(PrePassRenderer.prototype, \"enabled\", {\n        /**\n         * Indicates if the prepass is enabled\n         */\n        get: function () {\n            return this._enabled;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Creates a new PrePassRenderTarget\n     * This should be the only way to instantiate a `PrePassRenderTarget`\n     * @param name Name of the `PrePassRenderTarget`\n     * @param renderTargetTexture RenderTarget the `PrePassRenderTarget` will be attached to.\n     * Can be `null` if the created `PrePassRenderTarget` is attached to the scene (default framebuffer).\n     * @hidden\n     */\n    PrePassRenderer.prototype._createRenderTarget = function (name, renderTargetTexture) {\n        var rt = new PrePassRenderTarget(name, renderTargetTexture, { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, 0, this._scene, {\n            generateMipMaps: false,\n            generateStencilBuffer: this._engine.isStencilEnable,\n            defaultType: 0,\n            types: [],\n            drawOnlyOnFirstAttachmentByDefault: true,\n        });\n        this.renderTargets.push(rt);\n        return rt;\n    };\n    Object.defineProperty(PrePassRenderer.prototype, \"isSupported\", {\n        /**\n         * Indicates if rendering a prepass is supported\n         */\n        get: function () {\n            return this._scene.getEngine().getCaps().drawBuffersExtension;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Sets the proper output textures to draw in the engine.\n     * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.\n     * @param subMesh Submesh on which the effect is applied\n     */\n    PrePassRenderer.prototype.bindAttachmentsForEffect = function (effect, subMesh) {\n        var material = subMesh.getMaterial();\n        var isPrePassCapable = material && material.isPrePassCapable;\n        var excluded = material && this.excludedMaterials.indexOf(material) !== -1;\n        if (this.enabled && this._currentTarget.enabled) {\n            if (effect._multiTarget && isPrePassCapable && !excluded) {\n                this._engine.bindAttachments(this._multiRenderAttachments);\n            }\n            else {\n                if (this._engine._currentRenderTarget) {\n                    this._engine.bindAttachments(this._defaultAttachments);\n                }\n                else {\n                    this._engine.restoreSingleAttachment();\n                }\n                if (this._geometryBuffer && this.currentRTisSceneRT && !excluded) {\n                    this._geometryBuffer.renderList.push(subMesh.getRenderingMesh());\n                }\n            }\n        }\n    };\n    PrePassRenderer.prototype._reinitializeAttachments = function () {\n        var multiRenderLayout = [];\n        var clearLayout = [false];\n        var defaultLayout = [true];\n        for (var i = 0; i < this.mrtCount; i++) {\n            multiRenderLayout.push(true);\n            if (i > 0) {\n                clearLayout.push(true);\n                defaultLayout.push(false);\n            }\n        }\n        this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);\n        this._clearAttachments = this._engine.buildTextureLayout(clearLayout);\n        this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);\n    };\n    PrePassRenderer.prototype._resetLayout = function () {\n        for (var i = 0; i < PrePassRenderer._TextureFormats.length; i++) {\n            this._textureIndices[PrePassRenderer._TextureFormats[i].type] = -1;\n        }\n        this._textureIndices[4] = 0;\n        this._mrtLayout = [4];\n        this._mrtFormats = [PrePassRenderer._TextureFormats[4].format];\n        this._mrtNames = [PrePassRenderer._TextureFormats[4].name];\n        this.mrtCount = 1;\n    };\n    PrePassRenderer.prototype._updateGeometryBufferLayout = function () {\n        this._refreshGeometryBufferRendererLink();\n        if (this._geometryBuffer) {\n            this._geometryBuffer._resetLayout();\n            var texturesActivated = [];\n            for (var i = 0; i < this._mrtLayout.length; i++) {\n                texturesActivated.push(false);\n            }\n            this._geometryBuffer._linkInternalTexture(this.defaultRT.getInternalTexture());\n            var matches = [\n                {\n                    prePassConstant: 5,\n                    geometryBufferConstant: GeometryBufferRenderer.DEPTH_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: 6,\n                    geometryBufferConstant: GeometryBufferRenderer.NORMAL_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: 1,\n                    geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: 3,\n                    geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: 2,\n                    geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE,\n                },\n            ];\n            // replace textures in the geometryBuffer RT\n            for (var i = 0; i < matches.length; i++) {\n                var index = this._mrtLayout.indexOf(matches[i].prePassConstant);\n                if (index !== -1) {\n                    this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);\n                    texturesActivated[index] = true;\n                }\n            }\n            this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));\n        }\n    };\n    /**\n     * Restores attachments for single texture draw.\n     */\n    PrePassRenderer.prototype.restoreAttachments = function () {\n        if (this.enabled && this._currentTarget.enabled && this._defaultAttachments) {\n            if (this._engine._currentRenderTarget) {\n                this._engine.bindAttachments(this._defaultAttachments);\n            }\n            else {\n                this._engine.restoreSingleAttachment();\n            }\n        }\n    };\n    /**\n     * @param camera\n     * @param faceIndex\n     * @param layer\n     * @hidden\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    PrePassRenderer.prototype._beforeDraw = function (camera, faceIndex, layer) {\n        // const previousEnabled = this._enabled && this._currentTarget.enabled;\n        if (this._isDirty) {\n            this._update();\n        }\n        if (!this._enabled || !this._currentTarget.enabled) {\n            return;\n        }\n        if (this._geometryBuffer) {\n            this._geometryBuffer.renderList = [];\n        }\n        this._setupOutputForThisPass(this._currentTarget, camera);\n    };\n    PrePassRenderer.prototype._prepareFrame = function (prePassRenderTarget, faceIndex, layer) {\n        if (prePassRenderTarget.renderTargetTexture) {\n            prePassRenderTarget.renderTargetTexture._prepareFrame(this._scene, faceIndex, layer, prePassRenderTarget.renderTargetTexture.useCameraPostProcesses);\n        }\n        else if (this._postProcessesSourceForThisPass.length) {\n            this._scene.postProcessManager._prepareFrame();\n        }\n        else {\n            this._engine.restoreDefaultFramebuffer();\n        }\n    };\n    PrePassRenderer.prototype._renderPostProcesses = function (prePassRenderTarget, faceIndex) {\n        var _a;\n        var firstPP = this._postProcessesSourceForThisPass[0];\n        var outputTexture = firstPP ? firstPP.inputTexture : prePassRenderTarget.renderTargetTexture ? prePassRenderTarget.renderTargetTexture.renderTarget : null;\n        // Build post process chain for this prepass post draw\n        var postProcessChain = this._currentTarget._beforeCompositionPostProcesses;\n        if (this._needsCompositionForThisPass) {\n            postProcessChain = postProcessChain.concat([this._currentTarget.imageProcessingPostProcess]);\n        }\n        // Activates and renders the chain\n        if (postProcessChain.length) {\n            this._scene.postProcessManager._prepareFrame((_a = this._currentTarget.renderTarget) === null || _a === void 0 ? void 0 : _a.texture, postProcessChain);\n            this._scene.postProcessManager.directRender(postProcessChain, outputTexture, false, faceIndex);\n        }\n    };\n    /**\n     * @param faceIndex\n     * @param layer\n     * @hidden\n     */\n    PrePassRenderer.prototype._afterDraw = function (faceIndex, layer) {\n        if (this._enabled && this._currentTarget.enabled) {\n            this._prepareFrame(this._currentTarget, faceIndex, layer);\n            this._renderPostProcesses(this._currentTarget, faceIndex);\n        }\n    };\n    /**\n     * Clears the current prepass render target (in the sense of settings pixels to the scene clear color value)\n     * @hidden\n     */\n    PrePassRenderer.prototype._clear = function () {\n        if (this._enabled && this._currentTarget.enabled) {\n            this._bindFrameBuffer(this._currentTarget);\n            // Clearing other attachment with 0 on all other attachments\n            this._engine.bindAttachments(this._clearAttachments);\n            this._engine.clear(this._clearColor, true, false, false);\n            // Regular clear color with the scene clear color of the 1st attachment\n            this._engine.bindAttachments(this._defaultAttachments);\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    PrePassRenderer.prototype._bindFrameBuffer = function (prePassRenderTarget) {\n        if (this._enabled && this._currentTarget.enabled) {\n            this._currentTarget._checkSize();\n            var internalTexture = this._currentTarget.renderTarget;\n            if (internalTexture) {\n                this._engine.bindFramebuffer(internalTexture);\n            }\n        }\n    };\n    PrePassRenderer.prototype._setEnabled = function (enabled) {\n        this._enabled = enabled;\n    };\n    PrePassRenderer.prototype._setRenderTargetEnabled = function (prePassRenderTarget, enabled) {\n        prePassRenderTarget.enabled = enabled;\n        if (!enabled) {\n            this._unlinkInternalTexture(prePassRenderTarget);\n        }\n    };\n    /**\n     * Adds an effect configuration to the prepass render target.\n     * If an effect has already been added, it won't add it twice and will return the configuration\n     * already present.\n     * @param cfg the effect configuration\n     * @return the effect configuration now used by the prepass\n     */\n    PrePassRenderer.prototype.addEffectConfiguration = function (cfg) {\n        // Do not add twice\n        for (var i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].name === cfg.name) {\n                return this._effectConfigurations[i];\n            }\n        }\n        this._effectConfigurations.push(cfg);\n        return cfg;\n    };\n    PrePassRenderer.prototype._enable = function () {\n        var previousMrtCount = this.mrtCount;\n        for (var i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].enabled) {\n                this._enableTextures(this._effectConfigurations[i].texturesRequired);\n            }\n        }\n        for (var i = 0; i < this.renderTargets.length; i++) {\n            if (this.mrtCount !== previousMrtCount || this.renderTargets[i].count !== this.mrtCount) {\n                this.renderTargets[i].updateCount(this.mrtCount, { types: this._mrtFormats }, this._mrtNames.concat(\"prePass_DepthBuffer\"));\n            }\n            this.renderTargets[i]._resetPostProcessChain();\n            for (var j = 0; j < this._effectConfigurations.length; j++) {\n                if (this._effectConfigurations[j].enabled) {\n                    // TODO : subsurface scattering has 1 scene-wide effect configuration\n                    // solution : do not stock postProcess on effectConfiguration, but in the prepassRenderTarget (hashmap configuration => postProcess)\n                    // And call createPostProcess whenever the post process does not exist in the RT\n                    if (!this._effectConfigurations[j].postProcess && this._effectConfigurations[j].createPostProcess) {\n                        this._effectConfigurations[j].createPostProcess();\n                    }\n                    if (this._effectConfigurations[j].postProcess) {\n                        this.renderTargets[i]._beforeCompositionPostProcesses.push(this._effectConfigurations[j].postProcess);\n                    }\n                }\n            }\n        }\n        this._reinitializeAttachments();\n        this._setEnabled(true);\n        this._updateGeometryBufferLayout();\n    };\n    PrePassRenderer.prototype._disable = function () {\n        this._setEnabled(false);\n        for (var i = 0; i < this.renderTargets.length; i++) {\n            this._setRenderTargetEnabled(this.renderTargets[i], false);\n        }\n        this._resetLayout();\n        for (var i = 0; i < this._effectConfigurations.length; i++) {\n            this._effectConfigurations[i].enabled = false;\n        }\n    };\n    PrePassRenderer.prototype._getPostProcessesSource = function (prePassRenderTarget, camera) {\n        if (camera) {\n            return camera._postProcesses;\n        }\n        else if (prePassRenderTarget.renderTargetTexture) {\n            if (prePassRenderTarget.renderTargetTexture.useCameraPostProcesses) {\n                var camera_1 = prePassRenderTarget.renderTargetTexture.activeCamera ? prePassRenderTarget.renderTargetTexture.activeCamera : this._scene.activeCamera;\n                return camera_1 ? camera_1._postProcesses : [];\n            }\n            else if (prePassRenderTarget.renderTargetTexture.postProcesses) {\n                return prePassRenderTarget.renderTargetTexture.postProcesses;\n            }\n            else {\n                return [];\n            }\n        }\n        else {\n            return this._scene.activeCamera ? this._scene.activeCamera._postProcesses : [];\n        }\n    };\n    PrePassRenderer.prototype._setupOutputForThisPass = function (prePassRenderTarget, camera) {\n        // Order is : draw ===> prePassRenderTarget._postProcesses ==> ipp ==> camera._postProcesses\n        var secondaryCamera = camera && this._scene.activeCameras && !!this._scene.activeCameras.length && this._scene.activeCameras.indexOf(camera) !== 0;\n        this._postProcessesSourceForThisPass = this._getPostProcessesSource(prePassRenderTarget, camera);\n        this._postProcessesSourceForThisPass = this._postProcessesSourceForThisPass.filter(function (pp) {\n            return pp != null;\n        });\n        this._scene.autoClear = true;\n        var cameraHasImageProcessing = this._hasImageProcessing(this._postProcessesSourceForThisPass);\n        this._needsCompositionForThisPass = !cameraHasImageProcessing && !this.disableGammaTransform && this._needsImageProcessing() && !secondaryCamera;\n        var firstCameraPP = this._getFirstPostProcess(this._postProcessesSourceForThisPass);\n        var firstPrePassPP = prePassRenderTarget._beforeCompositionPostProcesses && prePassRenderTarget._beforeCompositionPostProcesses[0];\n        var firstPP = null;\n        // Setting the scene-wide post process configuration\n        this._scene.imageProcessingConfiguration.applyByPostProcess = this._needsCompositionForThisPass || cameraHasImageProcessing;\n        // Create composition effect if needed\n        if (this._needsCompositionForThisPass && !prePassRenderTarget.imageProcessingPostProcess) {\n            prePassRenderTarget._createCompositionEffect();\n        }\n        // Setting the prePassRenderTarget as input texture of the first PP\n        if (firstPrePassPP) {\n            firstPP = firstPrePassPP;\n        }\n        else if (this._needsCompositionForThisPass) {\n            firstPP = prePassRenderTarget.imageProcessingPostProcess;\n        }\n        else if (firstCameraPP) {\n            firstPP = firstCameraPP;\n        }\n        this._bindFrameBuffer(prePassRenderTarget);\n        this._linkInternalTexture(prePassRenderTarget, firstPP);\n    };\n    PrePassRenderer.prototype._linkInternalTexture = function (prePassRenderTarget, postProcess) {\n        if (postProcess) {\n            postProcess.autoClear = false;\n            postProcess.inputTexture = prePassRenderTarget.renderTarget;\n        }\n        if (prePassRenderTarget._outputPostProcess !== postProcess) {\n            if (prePassRenderTarget._outputPostProcess) {\n                this._unlinkInternalTexture(prePassRenderTarget);\n            }\n            prePassRenderTarget._outputPostProcess = postProcess;\n        }\n        if (prePassRenderTarget._internalTextureDirty) {\n            this._updateGeometryBufferLayout();\n            prePassRenderTarget._internalTextureDirty = false;\n        }\n    };\n    /**\n     * @param prePassRenderTarget\n     * @hidden\n     */\n    PrePassRenderer.prototype._unlinkInternalTexture = function (prePassRenderTarget) {\n        if (prePassRenderTarget._outputPostProcess) {\n            prePassRenderTarget._outputPostProcess.autoClear = true;\n            prePassRenderTarget._outputPostProcess.restoreDefaultInputTexture();\n            prePassRenderTarget._outputPostProcess = null;\n        }\n    };\n    PrePassRenderer.prototype._needsImageProcessing = function () {\n        for (var i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].enabled && this._effectConfigurations[i].needsImageProcessing) {\n                return true;\n            }\n        }\n        return false;\n    };\n    PrePassRenderer.prototype._hasImageProcessing = function (postProcesses) {\n        var _a;\n        var isIPPAlreadyPresent = false;\n        if (postProcesses) {\n            for (var i = 0; i < postProcesses.length; i++) {\n                if (((_a = postProcesses[i]) === null || _a === void 0 ? void 0 : _a.getClassName()) === \"ImageProcessingPostProcess\") {\n                    isIPPAlreadyPresent = true;\n                    break;\n                }\n            }\n        }\n        return isIPPAlreadyPresent;\n    };\n    /**\n     * Internal, gets the first post proces.\n     * @param postProcesses\n     * @returns the first post process to be run on this camera.\n     */\n    PrePassRenderer.prototype._getFirstPostProcess = function (postProcesses) {\n        for (var ppIndex = 0; ppIndex < postProcesses.length; ppIndex++) {\n            if (postProcesses[ppIndex] !== null) {\n                return postProcesses[ppIndex];\n            }\n        }\n        return null;\n    };\n    /**\n     * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.\n     */\n    PrePassRenderer.prototype.markAsDirty = function () {\n        this._isDirty = true;\n    };\n    /**\n     * Enables a texture on the MultiRenderTarget for prepass\n     * @param types\n     */\n    PrePassRenderer.prototype._enableTextures = function (types) {\n        // For velocity : enable storage of previous matrices for instances\n        this._scene.needsPreviousWorldMatrices = false;\n        for (var i = 0; i < types.length; i++) {\n            var type = types[i];\n            if (this._textureIndices[type] === -1) {\n                this._textureIndices[type] = this._mrtLayout.length;\n                this._mrtLayout.push(type);\n                this._mrtFormats.push(PrePassRenderer._TextureFormats[type].format);\n                this._mrtNames.push(PrePassRenderer._TextureFormats[type].name);\n                this.mrtCount++;\n            }\n            if (type === 2) {\n                this._scene.needsPreviousWorldMatrices = true;\n            }\n        }\n    };\n    PrePassRenderer.prototype._update = function () {\n        this._disable();\n        var enablePrePass = false;\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n        if (this._scene._depthPeelingRenderer && this._scene.useOrderIndependentTransparency) {\n            this._scene._depthPeelingRenderer.setPrePassRenderer(this);\n            enablePrePass = true;\n        }\n        for (var i = 0; i < this._scene.materials.length; i++) {\n            if (this._scene.materials[i].setPrePassRenderer(this)) {\n                enablePrePass = true;\n            }\n        }\n        if (enablePrePass) {\n            this._setRenderTargetEnabled(this.defaultRT, true);\n        }\n        var postProcesses;\n        for (var i = 0; i < this.renderTargets.length; i++) {\n            if (this.renderTargets[i].renderTargetTexture) {\n                postProcesses = this._getPostProcessesSource(this.renderTargets[i]);\n            }\n            else {\n                var camera = this._scene.activeCamera;\n                if (!camera) {\n                    continue;\n                }\n                postProcesses = camera._postProcesses;\n            }\n            if (!postProcesses) {\n                continue;\n            }\n            postProcesses = postProcesses.filter(function (pp) {\n                return pp != null;\n            });\n            if (postProcesses) {\n                for (var j = 0; j < postProcesses.length; j++) {\n                    if (postProcesses[j].setPrePassRenderer(this)) {\n                        this._setRenderTargetEnabled(this.renderTargets[i], true);\n                        enablePrePass = true;\n                    }\n                }\n                if (this._hasImageProcessing(postProcesses)) {\n                    this._scene.imageProcessingConfiguration.applyByPostProcess = true;\n                }\n            }\n        }\n        this._markAllMaterialsAsPrePassDirty();\n        this._isDirty = false;\n        if (enablePrePass) {\n            this._enable();\n        }\n    };\n    PrePassRenderer.prototype._markAllMaterialsAsPrePassDirty = function () {\n        var materials = this._scene.materials;\n        for (var i = 0; i < materials.length; i++) {\n            materials[i].markAsDirty(Material.PrePassDirtyFlag);\n        }\n    };\n    /**\n     * Disposes the prepass renderer.\n     */\n    PrePassRenderer.prototype.dispose = function () {\n        for (var i = this.renderTargets.length - 1; i >= 0; i--) {\n            this.renderTargets[i].dispose();\n        }\n        for (var i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].dispose) {\n                this._effectConfigurations[i].dispose();\n            }\n        }\n    };\n    /**\n     * @param _\n     * @hidden\n     */\n    PrePassRenderer._SceneComponentInitialization = function (_) {\n        throw _WarnImport(\"PrePassRendererSceneComponent\");\n    };\n    PrePassRenderer._TextureFormats = [\n        {\n            type: 0,\n            format: 2,\n            name: \"prePass_Irradiance\",\n        },\n        {\n            type: 1,\n            format: 2,\n            name: \"prePass_Position\",\n        },\n        {\n            type: 2,\n            format: 0,\n            name: \"prePass_Velocity\",\n        },\n        {\n            type: 3,\n            format: 0,\n            name: \"prePass_Reflectivity\",\n        },\n        {\n            type: 4,\n            format: 2,\n            name: \"prePass_Color\",\n        },\n        {\n            type: 5,\n            format: 2,\n            name: \"prePass_Depth\",\n        },\n        {\n            type: 6,\n            format: 2,\n            name: \"prePass_Normal\",\n        },\n        {\n            type: 7,\n            format: 0,\n            name: \"prePass_Albedo\",\n        },\n    ];\n    return PrePassRenderer;\n}());\nexport { PrePassRenderer };\n//# sourceMappingURL=prePassRenderer.js.map","import { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { PrePassRenderer } from \"./prePassRenderer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\n    get: function () {\n        return this._prePassRenderer;\n    },\n    set: function (value) {\n        if (value && value.isSupported) {\n            this._prePassRenderer = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.enablePrePassRenderer = function () {\n    if (this._prePassRenderer) {\n        return this._prePassRenderer;\n    }\n    this._prePassRenderer = new PrePassRenderer(this);\n    if (!this._prePassRenderer.isSupported) {\n        this._prePassRenderer = null;\n        Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\n    }\n    return this._prePassRenderer;\n};\nScene.prototype.disablePrePassRenderer = function () {\n    if (!this._prePassRenderer) {\n        return;\n    }\n    this._prePassRenderer.dispose();\n    this._prePassRenderer = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nvar PrePassRendererSceneComponent = /** @class */ (function () {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    function PrePassRendererSceneComponent(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    PrePassRendererSceneComponent.prototype.register = function () {\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS, this, this._beforeRenderTargetDraw);\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterRenderTargetDraw);\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PREPASS, this, this._beforeClearStage);\n        this.scene._beforeRenderTargetClearStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS, this, this._beforeRenderTargetClearStage);\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\n    };\n    PrePassRendererSceneComponent.prototype._beforeRenderTargetDraw = function (renderTarget, faceIndex, layer) {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n            this.scene.prePassRenderer._beforeDraw(undefined, faceIndex, layer);\n        }\n    };\n    PrePassRendererSceneComponent.prototype._afterRenderTargetDraw = function (renderTarget, faceIndex, layer) {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._afterDraw(faceIndex, layer);\n        }\n    };\n    PrePassRendererSceneComponent.prototype._beforeRenderTargetClearStage = function (renderTarget) {\n        if (this.scene.prePassRenderer) {\n            if (!renderTarget._prePassRenderTarget) {\n                renderTarget._prePassRenderTarget = this.scene.prePassRenderer._createRenderTarget(renderTarget.name + \"_prePassRTT\", renderTarget);\n            }\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n            this.scene.prePassRenderer._clear();\n        }\n    };\n    PrePassRendererSceneComponent.prototype._beforeCameraDraw = function (camera) {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._setRenderTarget(null);\n            this.scene.prePassRenderer._beforeDraw(camera);\n        }\n    };\n    PrePassRendererSceneComponent.prototype._afterCameraDraw = function () {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._afterDraw();\n        }\n    };\n    PrePassRendererSceneComponent.prototype._beforeClearStage = function () {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._setRenderTarget(null);\n            this.scene.prePassRenderer._clear();\n        }\n    };\n    PrePassRendererSceneComponent.prototype._beforeRenderingMeshStage = function (mesh, subMesh, batch, effect) {\n        if (!effect) {\n            return;\n        }\n        // Render to MRT\n        var scene = mesh.getScene();\n        if (scene.prePassRenderer) {\n            scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\n        }\n    };\n    PrePassRendererSceneComponent.prototype._afterRenderingMeshStage = function (mesh) {\n        var scene = mesh.getScene();\n        if (scene.prePassRenderer) {\n            scene.prePassRenderer.restoreAttachments();\n        }\n    };\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    PrePassRendererSceneComponent.prototype.rebuild = function () {\n        // Release textures first\n        this.scene.disablePrePassRenderer();\n        // Re-enable\n        this.scene.enablePrePassRenderer();\n    };\n    /**\n     * Disposes the component and the associated resources\n     */\n    PrePassRendererSceneComponent.prototype.dispose = function () {\n        this.scene.disablePrePassRenderer();\n    };\n    return PrePassRendererSceneComponent;\n}());\nexport { PrePassRendererSceneComponent };\nPrePassRenderer._SceneComponentInitialization = function (scene) {\n    // Register the G Buffer component to the scene.\n    var component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);\n    if (!component) {\n        component = new PrePassRendererSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=prePassRendererSceneComponent.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { SubSurfaceScatteringPostProcess } from \"../PostProcesses/subSurfaceScatteringPostProcess.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\n\n/**\n * Contains all parameters needed for the prepass to perform\n * screen space subsurface scattering\n */\nvar SubSurfaceConfiguration = /** @class */ (function () {\n    /**\n     * Builds a subsurface configuration object\n     * @param scene The scene\n     */\n    function SubSurfaceConfiguration(scene) {\n        this._ssDiffusionS = [];\n        this._ssFilterRadii = [];\n        this._ssDiffusionD = [];\n        /**\n         * Is subsurface enabled\n         */\n        this.enabled = false;\n        /**\n         * Does the output of this prepass need to go through imageprocessing\n         */\n        this.needsImageProcessing = true;\n        /**\n         * Name of the configuration\n         */\n        this.name = SceneComponentConstants.NAME_SUBSURFACE;\n        /**\n         * Diffusion profile colors for subsurface scattering\n         * You can add one diffusion color using `addDiffusionProfile` on `scene.prePassRenderer`\n         * See ...\n         * Note that you can only store up to 5 of them\n         */\n        this.ssDiffusionProfileColors = [];\n        /**\n         * Defines the ratio real world => scene units.\n         * Used for subsurface scattering\n         */\n        this.metersPerUnit = 1;\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [\n            5,\n            7,\n            4,\n            0,\n        ];\n        // Adding default diffusion profile\n        this.addDiffusionProfile(new Color3(1, 1, 1));\n        this._scene = scene;\n        SubSurfaceConfiguration._SceneComponentInitialization(this._scene);\n    }\n    Object.defineProperty(SubSurfaceConfiguration.prototype, \"ssDiffusionS\", {\n        /**\n         * Diffusion profile color for subsurface scattering\n         */\n        get: function () {\n            return this._ssDiffusionS;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SubSurfaceConfiguration.prototype, \"ssDiffusionD\", {\n        /**\n         * Diffusion profile max color channel value for subsurface scattering\n         */\n        get: function () {\n            return this._ssDiffusionD;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SubSurfaceConfiguration.prototype, \"ssFilterRadii\", {\n        /**\n         * Diffusion profile filter radius for subsurface scattering\n         */\n        get: function () {\n            return this._ssFilterRadii;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Adds a new diffusion profile.\n     * Useful for more realistic subsurface scattering on diverse materials.\n     * @param color The color of the diffusion profile. Should be the average color of the material.\n     * @return The index of the diffusion profile for the material subsurface configuration\n     */\n    SubSurfaceConfiguration.prototype.addDiffusionProfile = function (color) {\n        if (this.ssDiffusionD.length >= 5) {\n            // We only suppport 5 diffusion profiles\n            Logger.Error(\"You already reached the maximum number of diffusion profiles.\");\n            return 0; // default profile\n        }\n        // Do not add doubles\n        for (var i = 0; i < this._ssDiffusionS.length / 3; i++) {\n            if (this._ssDiffusionS[i * 3] === color.r && this._ssDiffusionS[i * 3 + 1] === color.g && this._ssDiffusionS[i * 3 + 2] === color.b) {\n                return i;\n            }\n        }\n        this._ssDiffusionS.push(color.r, color.b, color.g);\n        this._ssDiffusionD.push(Math.max(Math.max(color.r, color.b), color.g));\n        this._ssFilterRadii.push(this.getDiffusionProfileParameters(color));\n        this.ssDiffusionProfileColors.push(color);\n        return this._ssDiffusionD.length - 1;\n    };\n    /**\n     * Creates the sss post process\n     * @return The created post process\n     */\n    SubSurfaceConfiguration.prototype.createPostProcess = function () {\n        this.postProcess = new SubSurfaceScatteringPostProcess(\"subSurfaceScattering\", this._scene, 1, null, undefined, this._scene.getEngine());\n        this.postProcess.autoClear = false;\n        return this.postProcess;\n    };\n    /**\n     * Deletes all diffusion profiles.\n     * Note that in order to render subsurface scattering, you should have at least 1 diffusion profile.\n     */\n    SubSurfaceConfiguration.prototype.clearAllDiffusionProfiles = function () {\n        this._ssDiffusionD = [];\n        this._ssDiffusionS = [];\n        this._ssFilterRadii = [];\n        this.ssDiffusionProfileColors = [];\n    };\n    /**\n     * Disposes this object\n     */\n    SubSurfaceConfiguration.prototype.dispose = function () {\n        this.clearAllDiffusionProfiles();\n        if (this.postProcess) {\n            this.postProcess.dispose();\n        }\n    };\n    /**\n     * @param color\n     * @hidden\n     * https://zero-radiance.github.io/post/sampling-diffusion/\n     *\n     * Importance sample the normalized diffuse reflectance profile for the computed value of 's'.\n     * ------------------------------------------------------------------------------------\n     * R[r, phi, s]   = s * (Exp[-r * s] + Exp[-r * s / 3]) / (8 * Pi * r)\n     * PDF[r, phi, s] = r * R[r, phi, s]\n     * CDF[r, s]      = 1 - 1/4 * Exp[-r * s] - 3/4 * Exp[-r * s / 3]\n     * ------------------------------------------------------------------------------------\n     * We importance sample the color channel with the widest scattering distance.\n     */\n    SubSurfaceConfiguration.prototype.getDiffusionProfileParameters = function (color) {\n        var cdf = 0.997;\n        var maxScatteringDistance = Math.max(color.r, color.g, color.b);\n        return this._sampleBurleyDiffusionProfile(cdf, maxScatteringDistance);\n    };\n    /**\n     * Performs sampling of a Normalized Burley diffusion profile in polar coordinates.\n     * 'u' is the random number (the value of the CDF): [0, 1).\n     * rcp(s) = 1 / ShapeParam = ScatteringDistance.\n     * Returns the sampled radial distance, s.t. (u = 0 -> r = 0) and (u = 1 -> r = Inf).\n     * @param u\n     * @param rcpS\n     */\n    SubSurfaceConfiguration.prototype._sampleBurleyDiffusionProfile = function (u, rcpS) {\n        u = 1 - u; // Convert CDF to CCDF\n        var g = 1 + 4 * u * (2 * u + Math.sqrt(1 + 4 * u * u));\n        var n = Math.pow(g, -1.0 / 3.0); // g^(-1/3)\n        var p = g * n * n; // g^(+1/3)\n        var c = 1 + p + n; // 1 + g^(+1/3) + g^(-1/3)\n        var x = 3 * Math.log(c / (4 * u));\n        return x * rcpS;\n    };\n    /**\n     * @param _\n     * @hidden\n     */\n    SubSurfaceConfiguration._SceneComponentInitialization = function (_) {\n        throw _WarnImport(\"SubSurfaceSceneComponent\");\n    };\n    return SubSurfaceConfiguration;\n}());\nexport { SubSurfaceConfiguration };\n//# sourceMappingURL=subSurfaceConfiguration.js.map","import { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { SubSurfaceConfiguration } from \"./subSurfaceConfiguration.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_SUBSURFACE, function (parsedData, scene) {\n    // Diffusion profiles\n    if (parsedData.ssDiffusionProfileColors !== undefined && parsedData.ssDiffusionProfileColors !== null) {\n        scene.enableSubSurfaceForPrePass();\n        if (scene.subSurfaceConfiguration) {\n            for (var index = 0, cache = parsedData.ssDiffusionProfileColors.length; index < cache; index++) {\n                var color = parsedData.ssDiffusionProfileColors[index];\n                scene.subSurfaceConfiguration.addDiffusionProfile(new Color3(color.r, color.g, color.b));\n            }\n        }\n    }\n});\nObject.defineProperty(Scene.prototype, \"subSurfaceConfiguration\", {\n    get: function () {\n        return this._subSurfaceConfiguration;\n    },\n    set: function (value) {\n        if (value) {\n            if (this.enablePrePassRenderer()) {\n                this._subSurfaceConfiguration = value;\n            }\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.enableSubSurfaceForPrePass = function () {\n    if (this._subSurfaceConfiguration) {\n        return this._subSurfaceConfiguration;\n    }\n    var prePassRenderer = this.enablePrePassRenderer();\n    if (prePassRenderer) {\n        this._subSurfaceConfiguration = new SubSurfaceConfiguration(this);\n        prePassRenderer.addEffectConfiguration(this._subSurfaceConfiguration);\n        return this._subSurfaceConfiguration;\n    }\n    return null;\n};\nScene.prototype.disableSubSurfaceForPrePass = function () {\n    if (!this._subSurfaceConfiguration) {\n        return;\n    }\n    this._subSurfaceConfiguration.dispose();\n    this._subSurfaceConfiguration = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nvar SubSurfaceSceneComponent = /** @class */ (function () {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    function SubSurfaceSceneComponent(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    SubSurfaceSceneComponent.prototype.register = function () { };\n    /**\n     * Serializes the component data to the specified json object\n     * @param serializationObject The object to serialize to\n     */\n    SubSurfaceSceneComponent.prototype.serialize = function (serializationObject) {\n        if (!this.scene.subSurfaceConfiguration) {\n            return;\n        }\n        var ssDiffusionProfileColors = this.scene.subSurfaceConfiguration.ssDiffusionProfileColors;\n        serializationObject.ssDiffusionProfileColors = [];\n        for (var i = 0; i < ssDiffusionProfileColors.length; i++) {\n            serializationObject.ssDiffusionProfileColors.push({\n                r: ssDiffusionProfileColors[i].r,\n                g: ssDiffusionProfileColors[i].g,\n                b: ssDiffusionProfileColors[i].b,\n            });\n        }\n    };\n    /**\n     * Adds all the elements from the container to the scene\n     */\n    SubSurfaceSceneComponent.prototype.addFromContainer = function () {\n        // Nothing to do\n    };\n    /**\n     * Removes all the elements in the container from the scene\n     */\n    SubSurfaceSceneComponent.prototype.removeFromContainer = function () {\n        // Make sure nothing will be serialized\n        if (!this.scene.prePassRenderer) {\n            return;\n        }\n        if (this.scene.subSurfaceConfiguration) {\n            this.scene.subSurfaceConfiguration.clearAllDiffusionProfiles();\n        }\n    };\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    SubSurfaceSceneComponent.prototype.rebuild = function () {\n        // Nothing to do for this component\n    };\n    /**\n     * Disposes the component and the associated resources\n     */\n    SubSurfaceSceneComponent.prototype.dispose = function () {\n        // Nothing to do for this component\n    };\n    return SubSurfaceSceneComponent;\n}());\nexport { SubSurfaceSceneComponent };\nSubSurfaceConfiguration._SceneComponentInitialization = function (scene) {\n    // Register the G Buffer component to the scene.\n    var component = scene._getComponent(SceneComponentConstants.NAME_SUBSURFACE);\n    if (!component) {\n        component = new SubSurfaceSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=subSurfaceSceneComponent.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/logDepthFragment.js\";\nvar name = \"outlinePixelShader\";\nvar shader = \"#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\nuniform vec4 color;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\n#include<clipPlaneFragmentDeclaration>\\n#include<logDepthDeclaration>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<clipPlaneFragment>\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\n#include<logDepthFragment>\\ngl_FragColor=color;\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var outlinePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=outline.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/logDepthVertex.js\";\nvar name = \"outlineVertexShader\";\nvar shader = \"attribute vec3 position;\\nattribute vec3 normal;\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#include<clipPlaneVertexDeclaration>\\nuniform float offset;\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\n#include<logDepthDeclaration>\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void)\\n{\\nvec3 positionUpdated=position;\\nvec3 normalUpdated=normal;\\n#ifdef UV1\\nvec2 uvUpdated=uv;\\n#endif\\n#include<morphTargetsVertexGlobal>\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\nvec3 offsetPosition=positionUpdated+(normalUpdated*offset);\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\nvec4 worldPos=finalWorld*vec4(offsetPosition,1.0);\\ngl_Position=viewProjection*worldPos;\\n#ifdef ALPHATEST\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n#include<clipPlaneVertex>\\n#include<logDepthVertex>\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var outlineVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=outline.vertex.js.map","import { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Scene } from \"../scene.js\";\n\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Shaders/outline.fragment.js\";\nimport \"../Shaders/outline.vertex.js\";\n/**\n * Gets the outline renderer associated with the scene\n * @returns a OutlineRenderer\n */\nScene.prototype.getOutlineRenderer = function () {\n    if (!this._outlineRenderer) {\n        this._outlineRenderer = new OutlineRenderer(this);\n    }\n    return this._outlineRenderer;\n};\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\n    get: function () {\n        return this._renderOutline;\n    },\n    set: function (value) {\n        if (value) {\n            // Lazy Load the component.\n            this.getScene().getOutlineRenderer();\n        }\n        this._renderOutline = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\n    get: function () {\n        return this._renderOverlay;\n    },\n    set: function (value) {\n        if (value) {\n            // Lazy Load the component.\n            this.getScene().getOutlineRenderer();\n        }\n        this._renderOverlay = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * This class is responsible to draw the outline/overlay of meshes.\n * It should not be used directly but through the available method on mesh.\n */\nvar OutlineRenderer = /** @class */ (function () {\n    /**\n     * Instantiates a new outline renderer. (There could be only one per scene).\n     * @param scene Defines the scene it belongs to\n     */\n    function OutlineRenderer(scene) {\n        /**\n         * The name of the component. Each component must have a unique name.\n         */\n        this.name = SceneComponentConstants.NAME_OUTLINERENDERER;\n        /**\n         * Defines a zOffset default Factor to prevent zFighting between the overlay and the mesh.\n         */\n        this.zOffset = 1;\n        /**\n         * Defines a zOffset default Unit to prevent zFighting between the overlay and the mesh.\n         */\n        this.zOffsetUnits = 4; // 4 to account for projection a bit by default\n        this.scene = scene;\n        this._engine = scene.getEngine();\n        this.scene._addComponent(this);\n        this._passIdForDrawWrapper = [];\n        for (var i = 0; i < 4; ++i) {\n            this._passIdForDrawWrapper[i] = this._engine.createRenderPassId(\"Outline Renderer (\".concat(i, \")\"));\n        }\n    }\n    /**\n     * Register the component to one instance of a scene.\n     */\n    OutlineRenderer.prototype.register = function () {\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\n    };\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    OutlineRenderer.prototype.rebuild = function () {\n        // Nothing to do here.\n    };\n    /**\n     * Disposes the component and the associated resources.\n     */\n    OutlineRenderer.prototype.dispose = function () {\n        for (var i = 0; i < this._passIdForDrawWrapper.length; ++i) {\n            this._engine.releaseRenderPassId(this._passIdForDrawWrapper[i]);\n        }\n    };\n    /**\n     * Renders the outline in the canvas.\n     * @param subMesh Defines the sumesh to render\n     * @param batch Defines the batch of meshes in case of instances\n     * @param useOverlay Defines if the rendering is for the overlay or the outline\n     * @param renderPassId Render pass id to use to render the mesh\n     */\n    OutlineRenderer.prototype.render = function (subMesh, batch, useOverlay, renderPassId) {\n        if (useOverlay === void 0) { useOverlay = false; }\n        renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];\n        var scene = this.scene;\n        var engine = scene.getEngine();\n        var hardwareInstancedRendering = engine.getCaps().instancedArrays &&\n            ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || subMesh.getRenderingMesh().hasThinInstances);\n        if (!this.isReady(subMesh, hardwareInstancedRendering, renderPassId)) {\n            return;\n        }\n        var ownerMesh = subMesh.getMesh();\n        var replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\n        var renderingMesh = subMesh.getRenderingMesh();\n        var effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\n        var material = subMesh.getMaterial();\n        if (!material || !scene.activeCamera) {\n            return;\n        }\n        var drawWrapper = subMesh._getDrawWrapper(renderPassId);\n        var effect = DrawWrapper.GetEffect(drawWrapper);\n        engine.enableEffect(drawWrapper);\n        // Logarithmic depth\n        if (material.useLogarithmicDepth) {\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n        }\n        effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\n        effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\n        effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        // Bones\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n        }\n        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n            renderingMesh.morphTargetManager._bind(effect);\n        }\n        // Morph targets\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n        if (!hardwareInstancedRendering) {\n            renderingMesh._bind(subMesh, effect, material.fillMode);\n        }\n        // Alpha test\n        if (material && material.needAlphaTesting()) {\n            var alphaTexture = material.getAlphaTestTexture();\n            if (alphaTexture) {\n                effect.setTexture(\"diffuseSampler\", alphaTexture);\n                effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n        }\n        // Clip plane\n        MaterialHelper.BindClipPlane(effect, scene);\n        engine.setZOffset(-this.zOffset);\n        engine.setZOffsetUnits(-this.zOffsetUnits);\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) {\n            effect.setMatrix(\"world\", world);\n        });\n        engine.setZOffset(0);\n        engine.setZOffsetUnits(0);\n    };\n    /**\n     * Returns whether or not the outline renderer is ready for a given submesh.\n     * All the dependencies e.g. submeshes, texture, effect... mus be ready\n     * @param subMesh Defines the submesh to check readiness for\n     * @param useInstances Defines whether wee are trying to render instances or not\n     * @param renderPassId Render pass id to use to render the mesh\n     * @returns true if ready otherwise false\n     */\n    OutlineRenderer.prototype.isReady = function (subMesh, useInstances, renderPassId) {\n        renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];\n        var defines = [];\n        var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n        var mesh = subMesh.getMesh();\n        var material = subMesh.getMaterial();\n        var scene = mesh.getScene();\n        if (material) {\n            // Alpha test\n            if (material.needAlphaTesting()) {\n                defines.push(\"#define ALPHATEST\");\n                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                    attribs.push(VertexBuffer.UVKind);\n                    defines.push(\"#define UV1\");\n                }\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                    attribs.push(VertexBuffer.UV2Kind);\n                    defines.push(\"#define UV2\");\n                }\n            }\n            //Logarithmic depth\n            if (material.useLogarithmicDepth) {\n                defines.push(\"#define LOGARITHMICDEPTH\");\n            }\n        }\n        // Bones\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n        // Morph targets\n        var morphTargetManager = mesh.morphTargetManager;\n        var numMorphInfluencers = 0;\n        if (morphTargetManager) {\n            if (morphTargetManager.numInfluencers > 0) {\n                numMorphInfluencers = morphTargetManager.numInfluencers;\n                defines.push(\"#define MORPHTARGETS\");\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n                if (morphTargetManager.isUsingTextureForTargets) {\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                }\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n            }\n        }\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            MaterialHelper.PushAttributesForInstances(attribs);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n        // Clip planes\n        if (scene.clipPlane) {\n            defines.push(\"#define CLIPPLANE\");\n        }\n        if (scene.clipPlane2) {\n            defines.push(\"#define CLIPPLANE2\");\n        }\n        if (scene.clipPlane3) {\n            defines.push(\"#define CLIPPLANE3\");\n        }\n        if (scene.clipPlane4) {\n            defines.push(\"#define CLIPPLANE4\");\n        }\n        if (scene.clipPlane5) {\n            defines.push(\"#define CLIPPLANE5\");\n        }\n        if (scene.clipPlane6) {\n            defines.push(\"#define CLIPPLANE6\");\n        }\n        // Get correct effect\n        var drawWrapper = subMesh._getDrawWrapper(renderPassId, true);\n        var cachedDefines = drawWrapper.defines;\n        var join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            drawWrapper.setEffect(this.scene\n                .getEngine()\n                .createEffect(\"outline\", attribs, [\n                \"world\",\n                \"mBones\",\n                \"viewProjection\",\n                \"diffuseMatrix\",\n                \"offset\",\n                \"color\",\n                \"logarithmicDepthConstant\",\n                \"morphTargetInfluences\",\n                \"morphTargetTextureInfo\",\n                \"morphTargetTextureIndices\",\n                \"vClipPlane\",\n                \"vClipPlane2\",\n                \"vClipPlane3\",\n                \"vClipPlane4\",\n                \"vClipPlane5\",\n                \"vClipPlane6\",\n            ], [\"diffuseSampler\", \"morphTargets\"], join, undefined, undefined, undefined, { maxSimultaneousMorphTargets: numMorphInfluencers }), join);\n        }\n        return drawWrapper.effect.isReady();\n    };\n    OutlineRenderer.prototype._beforeRenderingMesh = function (mesh, subMesh, batch) {\n        // Outline - step 1\n        this._savedDepthWrite = this._engine.getDepthWrite();\n        if (mesh.renderOutline) {\n            var material = subMesh.getMaterial();\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\n                this._engine.cacheStencilState();\n                // Draw only to stencil buffer for the original mesh\n                // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\n                this._engine.setDepthWrite(false);\n                this._engine.setColorWrite(false);\n                this._engine.setStencilBuffer(true);\n                this._engine.setStencilOperationPass(7681);\n                this._engine.setStencilFunction(519);\n                this._engine.setStencilMask(OutlineRenderer._StencilReference);\n                this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\n                this._engine.stencilStateComposer.useStencilGlobalOnly = true;\n                this.render(subMesh, batch, /* This sets offset to 0 */ true, this._passIdForDrawWrapper[1]);\n                this._engine.setColorWrite(true);\n                this._engine.setStencilFunction(517);\n            }\n            // Draw the outline using the above stencil if needed to avoid drawing within the mesh\n            this._engine.setDepthWrite(false);\n            this.render(subMesh, batch, false, this._passIdForDrawWrapper[0]);\n            this._engine.setDepthWrite(this._savedDepthWrite);\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\n                this._engine.stencilStateComposer.useStencilGlobalOnly = false;\n                this._engine.restoreStencilState();\n            }\n        }\n    };\n    OutlineRenderer.prototype._afterRenderingMesh = function (mesh, subMesh, batch) {\n        // Overlay\n        if (mesh.renderOverlay) {\n            var currentMode = this._engine.getAlphaMode();\n            var alphaBlendState = this._engine.alphaState.alphaBlend;\n            this._engine.setAlphaMode(2);\n            this.render(subMesh, batch, true, this._passIdForDrawWrapper[3]);\n            this._engine.setAlphaMode(currentMode);\n            this._engine.setDepthWrite(this._savedDepthWrite);\n            this._engine.alphaState.alphaBlend = alphaBlendState;\n        }\n        // Outline - step 2\n        if (mesh.renderOutline && this._savedDepthWrite) {\n            this._engine.setDepthWrite(true);\n            this._engine.setColorWrite(false);\n            this.render(subMesh, batch, false, this._passIdForDrawWrapper[2]);\n            this._engine.setColorWrite(true);\n        }\n    };\n    /**\n     * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\n     */\n    OutlineRenderer._StencilReference = 0x04;\n    return OutlineRenderer;\n}());\nexport { OutlineRenderer };\n//# sourceMappingURL=outlineRenderer.js.map","\n/**\n * Contains all parameters needed for the prepass to perform\n * motion blur\n */\nvar MotionBlurConfiguration = /** @class */ (function () {\n    function MotionBlurConfiguration() {\n        /**\n         * Is motion blur enabled\n         */\n        this.enabled = false;\n        /**\n         * Name of the configuration\n         */\n        this.name = \"motionBlur\";\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [2];\n    }\n    return MotionBlurConfiguration;\n}());\nexport { MotionBlurConfiguration };\n//# sourceMappingURL=motionBlurConfiguration.js.map","import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n\n/**\n * This represents the object necessary to create a rendering group.\n * This is exclusively used and created by the rendering manager.\n * To modify the behavior, you use the available helpers in your scene or meshes.\n * @hidden\n */\nvar RenderingGroup = /** @class */ (function () {\n    /**\n     * Creates a new rendering group.\n     * @param index The rendering group index\n     * @param scene\n     * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\n     * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\n     * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\n     */\n    function RenderingGroup(index, scene, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n        if (opaqueSortCompareFn === void 0) { opaqueSortCompareFn = null; }\n        if (alphaTestSortCompareFn === void 0) { alphaTestSortCompareFn = null; }\n        if (transparentSortCompareFn === void 0) { transparentSortCompareFn = null; }\n        this.index = index;\n        this._opaqueSubMeshes = new SmartArray(256);\n        this._transparentSubMeshes = new SmartArray(256);\n        this._alphaTestSubMeshes = new SmartArray(256);\n        this._depthOnlySubMeshes = new SmartArray(256);\n        this._particleSystems = new SmartArray(256);\n        this._spriteManagers = new SmartArray(256);\n        /** @hidden */\n        this._empty = true;\n        /** @hidden */\n        this._edgesRenderers = new SmartArrayNoDuplicate(16);\n        this._scene = scene;\n        this.opaqueSortCompareFn = opaqueSortCompareFn;\n        this.alphaTestSortCompareFn = alphaTestSortCompareFn;\n        this.transparentSortCompareFn = transparentSortCompareFn;\n    }\n    Object.defineProperty(RenderingGroup.prototype, \"opaqueSortCompareFn\", {\n        /**\n         * Set the opaque sort comparison function.\n         * If null the sub meshes will be render in the order they were created\n         */\n        set: function (value) {\n            if (value) {\n                this._opaqueSortCompareFn = value;\n            }\n            else {\n                this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\n            }\n            this._renderOpaque = this._renderOpaqueSorted;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RenderingGroup.prototype, \"alphaTestSortCompareFn\", {\n        /**\n         * Set the alpha test sort comparison function.\n         * If null the sub meshes will be render in the order they were created\n         */\n        set: function (value) {\n            if (value) {\n                this._alphaTestSortCompareFn = value;\n            }\n            else {\n                this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\n            }\n            this._renderAlphaTest = this._renderAlphaTestSorted;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(RenderingGroup.prototype, \"transparentSortCompareFn\", {\n        /**\n         * Set the transparent sort comparison function.\n         * If null the sub meshes will be render in the order they were created\n         */\n        set: function (value) {\n            if (value) {\n                this._transparentSortCompareFn = value;\n            }\n            else {\n                this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\n            }\n            this._renderTransparent = this._renderTransparentSorted;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Render all the sub meshes contained in the group.\n     * @param customRenderFunction Used to override the default render behaviour of the group.\n     * @param renderSprites\n     * @param renderParticles\n     * @param activeMeshes\n     * @returns true if rendered some submeshes.\n     */\n    RenderingGroup.prototype.render = function (customRenderFunction, renderSprites, renderParticles, activeMeshes) {\n        if (customRenderFunction) {\n            customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\n            return;\n        }\n        var engine = this._scene.getEngine();\n        // Depth only\n        if (this._depthOnlySubMeshes.length !== 0) {\n            engine.setColorWrite(false);\n            this._renderAlphaTest(this._depthOnlySubMeshes);\n            engine.setColorWrite(true);\n        }\n        // Opaque\n        if (this._opaqueSubMeshes.length !== 0) {\n            this._renderOpaque(this._opaqueSubMeshes);\n        }\n        // Alpha test\n        if (this._alphaTestSubMeshes.length !== 0) {\n            this._renderAlphaTest(this._alphaTestSubMeshes);\n        }\n        var stencilState = engine.getStencilBuffer();\n        engine.setStencilBuffer(false);\n        // Sprites\n        if (renderSprites) {\n            this._renderSprites();\n        }\n        // Particles\n        if (renderParticles) {\n            this._renderParticles(activeMeshes);\n        }\n        if (this.onBeforeTransparentRendering) {\n            this.onBeforeTransparentRendering();\n        }\n        // Transparent\n        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\n            engine.setStencilBuffer(stencilState);\n            if (this._scene.useOrderIndependentTransparency) {\n                var excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);\n                if (excludedMeshes.length) {\n                    // Render leftover meshes that could not be processed by depth peeling\n                    this._renderTransparent(excludedMeshes);\n                }\n            }\n            else {\n                this._renderTransparent(this._transparentSubMeshes);\n            }\n            engine.setAlphaMode(0);\n        }\n        // Set back stencil to false in case it changes before the edge renderer.\n        engine.setStencilBuffer(false);\n        // Edges\n        if (this._edgesRenderers.length) {\n            for (var edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\n                this._edgesRenderers.data[edgesRendererIndex].render();\n            }\n            engine.setAlphaMode(0);\n        }\n        // Restore Stencil state.\n        engine.setStencilBuffer(stencilState);\n    };\n    /**\n     * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\n     * @param subMeshes The submeshes to render\n     */\n    RenderingGroup.prototype._renderOpaqueSorted = function (subMeshes) {\n        return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\n    };\n    /**\n     * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\n     * @param subMeshes The submeshes to render\n     */\n    RenderingGroup.prototype._renderAlphaTestSorted = function (subMeshes) {\n        return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\n    };\n    /**\n     * Renders the opaque submeshes in the order from the transparentSortCompareFn.\n     * @param subMeshes The submeshes to render\n     */\n    RenderingGroup.prototype._renderTransparentSorted = function (subMeshes) {\n        return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\n    };\n    /**\n     * Renders the submeshes in a specified order.\n     * @param subMeshes The submeshes to sort before render\n     * @param sortCompareFn The comparison function use to sort\n     * @param camera The camera position use to preprocess the submeshes to help sorting\n     * @param transparent Specifies to activate blending if true\n     */\n    RenderingGroup._RenderSorted = function (subMeshes, sortCompareFn, camera, transparent) {\n        var subIndex = 0;\n        var subMesh;\n        var cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\n        if (transparent) {\n            for (; subIndex < subMeshes.length; subIndex++) {\n                subMesh = subMeshes.data[subIndex];\n                subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\n                subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n            }\n        }\n        var sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\n        if (sortCompareFn) {\n            sortedArray.sort(sortCompareFn);\n        }\n        var scene = sortedArray[0].getMesh().getScene();\n        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\n            subMesh = sortedArray[subIndex];\n            if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\n                continue;\n            }\n            if (transparent) {\n                var material = subMesh.getMaterial();\n                if (material && material.needDepthPrePass) {\n                    var engine = material.getScene().getEngine();\n                    engine.setColorWrite(false);\n                    engine.setAlphaMode(0);\n                    subMesh.render(false);\n                    engine.setColorWrite(true);\n                }\n            }\n            subMesh.render(transparent);\n        }\n    };\n    /**\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n     * are rendered back to front if in the same alpha index.\n     *\n     * @param a The first submesh\n     * @param b The second submesh\n     * @returns The result of the comparison\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    RenderingGroup.defaultTransparentSortCompare = function (a, b) {\n        // Alpha index first\n        if (a._alphaIndex > b._alphaIndex) {\n            return 1;\n        }\n        if (a._alphaIndex < b._alphaIndex) {\n            return -1;\n        }\n        // Then distance to camera\n        return RenderingGroup.backToFrontSortCompare(a, b);\n    };\n    /**\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n     * are rendered back to front.\n     *\n     * @param a The first submesh\n     * @param b The second submesh\n     * @returns The result of the comparison\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    RenderingGroup.backToFrontSortCompare = function (a, b) {\n        // Then distance to camera\n        if (a._distanceToCamera < b._distanceToCamera) {\n            return 1;\n        }\n        if (a._distanceToCamera > b._distanceToCamera) {\n            return -1;\n        }\n        return 0;\n    };\n    /**\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n     * are rendered front to back (prevent overdraw).\n     *\n     * @param a The first submesh\n     * @param b The second submesh\n     * @returns The result of the comparison\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    RenderingGroup.frontToBackSortCompare = function (a, b) {\n        // Then distance to camera\n        if (a._distanceToCamera < b._distanceToCamera) {\n            return -1;\n        }\n        if (a._distanceToCamera > b._distanceToCamera) {\n            return 1;\n        }\n        return 0;\n    };\n    /**\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n     * are grouped by material then geometry.\n     *\n     * @param a The first submesh\n     * @param b The second submesh\n     * @returns The result of the comparison\n     */\n    RenderingGroup.PainterSortCompare = function (a, b) {\n        var meshA = a.getMesh();\n        var meshB = b.getMesh();\n        if (meshA.material && meshB.material) {\n            return meshA.material.uniqueId - meshB.material.uniqueId;\n        }\n        return meshA.uniqueId - meshB.uniqueId;\n    };\n    /**\n     * Resets the different lists of submeshes to prepare a new frame.\n     */\n    RenderingGroup.prototype.prepare = function () {\n        this._opaqueSubMeshes.reset();\n        this._transparentSubMeshes.reset();\n        this._alphaTestSubMeshes.reset();\n        this._depthOnlySubMeshes.reset();\n        this._particleSystems.reset();\n        this._spriteManagers.reset();\n        this._edgesRenderers.reset();\n        this._empty = true;\n    };\n    RenderingGroup.prototype.dispose = function () {\n        this._opaqueSubMeshes.dispose();\n        this._transparentSubMeshes.dispose();\n        this._alphaTestSubMeshes.dispose();\n        this._depthOnlySubMeshes.dispose();\n        this._particleSystems.dispose();\n        this._spriteManagers.dispose();\n        this._edgesRenderers.dispose();\n    };\n    /**\n     * Inserts the submesh in its correct queue depending on its material.\n     * @param subMesh The submesh to dispatch\n     * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n     * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n     */\n    RenderingGroup.prototype.dispatch = function (subMesh, mesh, material) {\n        // Get mesh and materials if not provided\n        if (mesh === undefined) {\n            mesh = subMesh.getMesh();\n        }\n        if (material === undefined) {\n            material = subMesh.getMaterial();\n        }\n        if (material === null || material === undefined) {\n            return;\n        }\n        if (material.needAlphaBlendingForMesh(mesh)) {\n            // Transparent\n            this._transparentSubMeshes.push(subMesh);\n        }\n        else if (material.needAlphaTesting()) {\n            // Alpha test\n            if (material.needDepthPrePass) {\n                this._depthOnlySubMeshes.push(subMesh);\n            }\n            this._alphaTestSubMeshes.push(subMesh);\n        }\n        else {\n            if (material.needDepthPrePass) {\n                this._depthOnlySubMeshes.push(subMesh);\n            }\n            this._opaqueSubMeshes.push(subMesh); // Opaque\n        }\n        mesh._renderingGroup = this;\n        if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\n            this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\n        }\n        this._empty = false;\n    };\n    RenderingGroup.prototype.dispatchSprites = function (spriteManager) {\n        this._spriteManagers.push(spriteManager);\n        this._empty = false;\n    };\n    RenderingGroup.prototype.dispatchParticles = function (particleSystem) {\n        this._particleSystems.push(particleSystem);\n        this._empty = false;\n    };\n    RenderingGroup.prototype._renderParticles = function (activeMeshes) {\n        if (this._particleSystems.length === 0) {\n            return;\n        }\n        // Particles\n        var activeCamera = this._scene.activeCamera;\n        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\n        for (var particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\n            var particleSystem = this._particleSystems.data[particleIndex];\n            if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\n                continue;\n            }\n            var emitter = particleSystem.emitter;\n            if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\n                this._scene._activeParticles.addCount(particleSystem.render(), false);\n            }\n        }\n        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\n    };\n    RenderingGroup.prototype._renderSprites = function () {\n        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\n            return;\n        }\n        // Sprites\n        var activeCamera = this._scene.activeCamera;\n        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\n        for (var id = 0; id < this._spriteManagers.length; id++) {\n            var spriteManager = this._spriteManagers.data[id];\n            if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\n                spriteManager.render();\n            }\n        }\n        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\n    };\n    RenderingGroup._ZeroVector = Vector3.Zero();\n    return RenderingGroup;\n}());\nexport { RenderingGroup };\n//# sourceMappingURL=renderingGroup.js.map","import { RenderingGroup } from \"./renderingGroup.js\";\n/**\n * This class is used by the onRenderingGroupObservable\n */\nvar RenderingGroupInfo = /** @class */ (function () {\n    function RenderingGroupInfo() {\n    }\n    return RenderingGroupInfo;\n}());\nexport { RenderingGroupInfo };\n/**\n * This is the manager responsible of all the rendering for meshes sprites and particles.\n * It is enable to manage the different groups as well as the different necessary sort functions.\n * This should not be used directly aside of the few static configurations\n */\nvar RenderingManager = /** @class */ (function () {\n    /**\n     * Instantiates a new rendering group for a particular scene\n     * @param scene Defines the scene the groups belongs to\n     */\n    function RenderingManager(scene) {\n        /**\n         * @hidden\n         */\n        this._useSceneAutoClearSetup = false;\n        this._renderingGroups = new Array();\n        this._autoClearDepthStencil = {};\n        this._customOpaqueSortCompareFn = {};\n        this._customAlphaTestSortCompareFn = {};\n        this._customTransparentSortCompareFn = {};\n        this._renderingGroupInfo = new RenderingGroupInfo();\n        this._scene = scene;\n        for (var i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n            this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\n        }\n    }\n    RenderingManager.prototype._clearDepthStencilBuffer = function (depth, stencil) {\n        if (depth === void 0) { depth = true; }\n        if (stencil === void 0) { stencil = true; }\n        if (this._depthStencilBufferAlreadyCleaned) {\n            return;\n        }\n        this._scene.getEngine().clear(null, false, depth, stencil);\n        this._depthStencilBufferAlreadyCleaned = true;\n    };\n    /**\n     * Renders the entire managed groups. This is used by the scene or the different render targets.\n     * @param customRenderFunction\n     * @param activeMeshes\n     * @param renderParticles\n     * @param renderSprites\n     * @hidden\n     */\n    RenderingManager.prototype.render = function (customRenderFunction, activeMeshes, renderParticles, renderSprites) {\n        // Update the observable context (not null as it only goes away on dispose)\n        var info = this._renderingGroupInfo;\n        info.scene = this._scene;\n        info.camera = this._scene.activeCamera;\n        // Dispatch sprites\n        if (this._scene.spriteManagers && renderSprites) {\n            for (var index = 0; index < this._scene.spriteManagers.length; index++) {\n                var manager = this._scene.spriteManagers[index];\n                this.dispatchSprites(manager);\n            }\n        }\n        // Render\n        for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n            this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\n            var renderingGroup = this._renderingGroups[index];\n            if (!renderingGroup || renderingGroup._empty) {\n                continue;\n            }\n            var renderingGroupMask = Math.pow(2, index);\n            info.renderingGroupId = index;\n            // Before Observable\n            this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n            // Clear depth/stencil if needed\n            if (RenderingManager.AUTOCLEAR) {\n                var autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\n                if (autoClear && autoClear.autoClear) {\n                    this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\n                }\n            }\n            // Render\n            for (var _i = 0, _a = this._scene._beforeRenderingGroupDrawStage; _i < _a.length; _i++) {\n                var step = _a[_i];\n                step.action(index);\n            }\n            renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\n            for (var _b = 0, _c = this._scene._afterRenderingGroupDrawStage; _b < _c.length; _b++) {\n                var step = _c[_b];\n                step.action(index);\n            }\n            // After Observable\n            this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n        }\n    };\n    /**\n     * Resets the different information of the group to prepare a new frame\n     * @hidden\n     */\n    RenderingManager.prototype.reset = function () {\n        for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n            var renderingGroup = this._renderingGroups[index];\n            if (renderingGroup) {\n                renderingGroup.prepare();\n            }\n        }\n    };\n    /**\n     * Dispose and release the group and its associated resources.\n     * @hidden\n     */\n    RenderingManager.prototype.dispose = function () {\n        this.freeRenderingGroups();\n        this._renderingGroups.length = 0;\n        this._renderingGroupInfo = null;\n    };\n    /**\n     * Clear the info related to rendering groups preventing retention points during dispose.\n     */\n    RenderingManager.prototype.freeRenderingGroups = function () {\n        for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n            var renderingGroup = this._renderingGroups[index];\n            if (renderingGroup) {\n                renderingGroup.dispose();\n            }\n        }\n    };\n    RenderingManager.prototype._prepareRenderingGroup = function (renderingGroupId) {\n        if (this._renderingGroups[renderingGroupId] === undefined) {\n            this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);\n        }\n    };\n    /**\n     * Add a sprite manager to the rendering manager in order to render it this frame.\n     * @param spriteManager Define the sprite manager to render\n     */\n    RenderingManager.prototype.dispatchSprites = function (spriteManager) {\n        var renderingGroupId = spriteManager.renderingGroupId || 0;\n        this._prepareRenderingGroup(renderingGroupId);\n        this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);\n    };\n    /**\n     * Add a particle system to the rendering manager in order to render it this frame.\n     * @param particleSystem Define the particle system to render\n     */\n    RenderingManager.prototype.dispatchParticles = function (particleSystem) {\n        var renderingGroupId = particleSystem.renderingGroupId || 0;\n        this._prepareRenderingGroup(renderingGroupId);\n        this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);\n    };\n    /**\n     * Add a submesh to the manager in order to render it this frame\n     * @param subMesh The submesh to dispatch\n     * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n     * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n     */\n    RenderingManager.prototype.dispatch = function (subMesh, mesh, material) {\n        if (mesh === undefined) {\n            mesh = subMesh.getMesh();\n        }\n        var renderingGroupId = mesh.renderingGroupId || 0;\n        this._prepareRenderingGroup(renderingGroupId);\n        this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);\n    };\n    /**\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\n     * This allowed control for front to back rendering or reversely depending of the special needs.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n     */\n    RenderingManager.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n        if (opaqueSortCompareFn === void 0) { opaqueSortCompareFn = null; }\n        if (alphaTestSortCompareFn === void 0) { alphaTestSortCompareFn = null; }\n        if (transparentSortCompareFn === void 0) { transparentSortCompareFn = null; }\n        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\n        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\n        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\n        if (this._renderingGroups[renderingGroupId]) {\n            var group = this._renderingGroups[renderingGroupId];\n            group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\n            group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\n            group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\n        }\n    };\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n     */\n    RenderingManager.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil, depth, stencil) {\n        if (depth === void 0) { depth = true; }\n        if (stencil === void 0) { stencil = true; }\n        this._autoClearDepthStencil[renderingGroupId] = {\n            autoClear: autoClearDepthStencil,\n            depth: depth,\n            stencil: stencil,\n        };\n    };\n    /**\n     * Gets the current auto clear configuration for one rendering group of the rendering\n     * manager.\n     * @param index the rendering group index to get the information for\n     * @returns The auto clear setup for the requested rendering group\n     */\n    RenderingManager.prototype.getAutoClearDepthStencilSetup = function (index) {\n        return this._autoClearDepthStencil[index];\n    };\n    /**\n     * The max id used for rendering groups (not included)\n     */\n    RenderingManager.MAX_RENDERINGGROUPS = 4;\n    /**\n     * The min id used for rendering groups (included)\n     */\n    RenderingManager.MIN_RENDERINGGROUPS = 0;\n    /**\n     * Used to globally prevent autoclearing scenes.\n     */\n    RenderingManager.AUTOCLEAR = true;\n    return RenderingManager;\n}());\nexport { RenderingManager };\n//# sourceMappingURL=renderingManager.js.map","\n/**\n * Contains all parameters needed for the prepass to perform\n * screen space reflections\n */\nvar ScreenSpaceReflectionsConfiguration = /** @class */ (function () {\n    function ScreenSpaceReflectionsConfiguration() {\n        /**\n         * Is ssr enabled\n         */\n        this.enabled = false;\n        /**\n         * Name of the configuration\n         */\n        this.name = \"screenSpaceReflections\";\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [6, 3, 1];\n    }\n    return ScreenSpaceReflectionsConfiguration;\n}());\nexport { ScreenSpaceReflectionsConfiguration };\n//# sourceMappingURL=screenSpaceReflectionsConfiguration.js.map","\n/**\n * Contains all parameters needed for the prepass to perform\n * screen space subsurface scattering\n */\nvar SSAO2Configuration = /** @class */ (function () {\n    function SSAO2Configuration() {\n        /**\n         * Is subsurface enabled\n         */\n        this.enabled = false;\n        /**\n         * Name of the configuration\n         */\n        this.name = \"ssao2\";\n        /**\n         * Textures that should be present in the MRT for this effect to work\n         */\n        this.texturesRequired = [6, 5];\n    }\n    return SSAO2Configuration;\n}());\nexport { SSAO2Configuration };\n//# sourceMappingURL=ssao2Configuration.js.map","import { Scene } from \"../scene.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * Renders a layer on top of an existing scene\n */\nvar UtilityLayerRenderer = /** @class */ (function () {\n    /**\n     * Instantiates a UtilityLayerRenderer\n     * @param originalScene the original scene that will be rendered on top of\n     * @param handleEvents boolean indicating if the utility layer should handle events\n     */\n    function UtilityLayerRenderer(\n    /** the original scene that will be rendered on top of */\n    originalScene, handleEvents) {\n        if (handleEvents === void 0) { handleEvents = true; }\n        var _this = this;\n        this.originalScene = originalScene;\n        this._pointerCaptures = {};\n        this._lastPointerEvents = {};\n        this._sharedGizmoLight = null;\n        this._renderCamera = null;\n        /**\n         * If the picking should be done on the utility layer prior to the actual scene (Default: true)\n         */\n        this.pickUtilitySceneFirst = true;\n        /**\n         *  If the utility layer should automatically be rendered on top of existing scene\n         */\n        this.shouldRender = true;\n        /**\n         * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\n         */\n        this.onlyCheckPointerDownEvents = true;\n        /**\n         * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\n         */\n        this.processAllEvents = false;\n        /**\n         * Set to false to disable picking\n         */\n        this.pickingEnabled = true;\n        /**\n         * Observable raised when the pointer moves from the utility layer scene to the main scene\n         */\n        this.onPointerOutObservable = new Observable();\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\n        this.utilityLayerScene._allowPostProcessClearColor = false;\n        // Deactivate post processes\n        this.utilityLayerScene.postProcessesEnabled = false;\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\n        this.utilityLayerScene.detachControl();\n        if (handleEvents) {\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add(function (prePointerInfo) {\n                if (!_this.utilityLayerScene.activeCamera) {\n                    return;\n                }\n                if (!_this.pickingEnabled) {\n                    return;\n                }\n                if (!_this.processAllEvents) {\n                    if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\n                        return;\n                    }\n                }\n                _this.utilityLayerScene.pointerX = originalScene.pointerX;\n                _this.utilityLayerScene.pointerY = originalScene.pointerY;\n                var pointerEvent = prePointerInfo.event;\n                if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {\n                    _this._pointerCaptures[pointerEvent.pointerId] = false;\n                    return;\n                }\n                var getNearPickDataForScene = function (scene) {\n                    var scenePick = null;\n                    if (prePointerInfo.nearInteractionPickingInfo) {\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\n                        }\n                        else {\n                            scenePick = new PickingInfo();\n                        }\n                    }\n                    else {\n                        var previousActiveCamera = null;\n                        // If a camera is set for rendering with this layer\n                        // it will also be used for the ray computation\n                        // To preserve back compat and because scene.pick always use activeCamera\n                        // it's substituted temporarily and a new scenePick is forced.\n                        // otherwise, the ray with previously active camera is always used.\n                        // It's set back to previous activeCamera after operation.\n                        if (_this._renderCamera) {\n                            previousActiveCamera = scene._activeCamera;\n                            scene._activeCamera = _this._renderCamera;\n                            prePointerInfo.ray = null;\n                        }\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\n                        if (previousActiveCamera) {\n                            scene._activeCamera = previousActiveCamera;\n                        }\n                    }\n                    return scenePick;\n                };\n                var utilityScenePick = getNearPickDataForScene(_this.utilityLayerScene);\n                if (!prePointerInfo.ray && utilityScenePick) {\n                    prePointerInfo.ray = utilityScenePick.ray;\n                }\n                // always fire the prepointer observable\n                _this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\n                // allow every non pointer down event to flow to the utility layer\n                if (_this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\n                    if (!prePointerInfo.skipOnPointerObservable) {\n                        _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n                    }\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent.pointerId]) {\n                        _this._pointerCaptures[pointerEvent.pointerId] = false;\n                    }\n                    return;\n                }\n                if (_this.utilityLayerScene.autoClearDepthAndStencil || _this.pickUtilitySceneFirst) {\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\n                    if (utilityScenePick && utilityScenePick.hit) {\n                        if (!prePointerInfo.skipOnPointerObservable) {\n                            _this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n                        }\n                        prePointerInfo.skipOnPointerObservable = true;\n                    }\n                }\n                else {\n                    var originalScenePick = getNearPickDataForScene(originalScene);\n                    var pointerEvent_1 = prePointerInfo.event;\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\n                    if (originalScenePick && utilityScenePick) {\n                        // No pick in utility scene\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\n                            if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                                // We touched an utility mesh present in the main scene\n                                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n                                prePointerInfo.skipOnPointerObservable = true;\n                            }\n                            else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\n                                _this._pointerCaptures[pointerEvent_1.pointerId] = true;\n                            }\n                            else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                                if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                                    _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);\n                                    delete _this._lastPointerEvents[pointerEvent_1.pointerId];\n                                }\n                                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n                            }\n                        }\n                        else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\n                            _this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent_1);\n                            // If a previous utility layer set this, do not unset this\n                            if (!prePointerInfo.skipOnPointerObservable) {\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\n                            }\n                        }\n                        else if (!_this._pointerCaptures[pointerEvent_1.pointerId] && utilityScenePick.distance > originalScenePick.distance) {\n                            // We have a pick in both scenes but main is closer than utility\n                            // We touched an utility mesh present in the main scene\n                            if (_this.mainSceneTrackerPredicate && _this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                                _this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent_1);\n                                prePointerInfo.skipOnPointerObservable = true;\n                            }\n                            else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                                if (_this._lastPointerEvents[pointerEvent_1.pointerId]) {\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                                    _this.onPointerOutObservable.notifyObservers(pointerEvent_1.pointerId);\n                                    delete _this._lastPointerEvents[pointerEvent_1.pointerId];\n                                }\n                                _this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent_1);\n                            }\n                        }\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && _this._pointerCaptures[pointerEvent_1.pointerId]) {\n                            _this._pointerCaptures[pointerEvent_1.pointerId] = false;\n                        }\n                    }\n                }\n            });\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\n            if (this._originalPointerObserver) {\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\n            }\n        }\n        // Render directly on top of existing scene without clearing\n        this.utilityLayerScene.autoClear = false;\n        this._afterRenderObserver = this.originalScene.onAfterCameraRenderObservable.add(function (camera) {\n            // Only render when the render camera finishes rendering\n            if (_this.shouldRender && camera == _this.getRenderCamera()) {\n                _this.render();\n            }\n        });\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(function () {\n            _this.dispose();\n        });\n        this._updateCamera();\n    }\n    /**\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\n     * @returns the camera that is used when rendering the utility layer\n     */\n    UtilityLayerRenderer.prototype.getRenderCamera = function (getRigParentIfPossible) {\n        if (this._renderCamera) {\n            return this._renderCamera;\n        }\n        else {\n            var activeCam = void 0;\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\n            }\n            else {\n                activeCam = this.originalScene.activeCamera;\n            }\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\n                return activeCam.rigParent;\n            }\n            return activeCam;\n        }\n    };\n    /**\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\n     * @param cam the camera that should be used when rendering the utility layer\n     */\n    UtilityLayerRenderer.prototype.setRenderCamera = function (cam) {\n        this._renderCamera = cam;\n    };\n    /**\n     * @hidden\n     * Light which used by gizmos to get light shading\n     */\n    UtilityLayerRenderer.prototype._getSharedGizmoLight = function () {\n        if (!this._sharedGizmoLight) {\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\n            this._sharedGizmoLight.intensity = 2;\n            this._sharedGizmoLight.groundColor = Color3.Gray();\n        }\n        return this._sharedGizmoLight;\n    };\n    Object.defineProperty(UtilityLayerRenderer, \"DefaultUtilityLayer\", {\n        /**\n         * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\n         */\n        get: function () {\n            if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\n                return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);\n            }\n            return UtilityLayerRenderer._DefaultUtilityLayer;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Creates an utility layer, and set it as a default utility layer\n     * @param scene associated scene\n     * @hidden\n     */\n    UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene = function (scene) {\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(function () {\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\n        });\n        return UtilityLayerRenderer._DefaultUtilityLayer;\n    };\n    Object.defineProperty(UtilityLayerRenderer, \"DefaultKeepDepthUtilityLayer\", {\n        /**\n         * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\n         */\n        get: function () {\n            if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(function () {\n                    UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n                });\n            }\n            return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    UtilityLayerRenderer.prototype._notifyObservers = function (prePointerInfo, pickInfo, pointerEvent) {\n        if (!prePointerInfo.skipOnPointerObservable) {\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\n        }\n    };\n    /**\n     * Renders the utility layers scene on top of the original scene\n     */\n    UtilityLayerRenderer.prototype.render = function () {\n        this._updateCamera();\n        if (this.utilityLayerScene.activeCamera) {\n            // Set the camera's scene to utility layers scene\n            var oldScene = this.utilityLayerScene.activeCamera.getScene();\n            var camera = this.utilityLayerScene.activeCamera;\n            camera._scene = this.utilityLayerScene;\n            if (camera.leftCamera) {\n                camera.leftCamera._scene = this.utilityLayerScene;\n            }\n            if (camera.rightCamera) {\n                camera.rightCamera._scene = this.utilityLayerScene;\n            }\n            this.utilityLayerScene.render(false);\n            // Reset camera's scene back to original\n            camera._scene = oldScene;\n            if (camera.leftCamera) {\n                camera.leftCamera._scene = oldScene;\n            }\n            if (camera.rightCamera) {\n                camera.rightCamera._scene = oldScene;\n            }\n        }\n    };\n    /**\n     * Disposes of the renderer\n     */\n    UtilityLayerRenderer.prototype.dispose = function () {\n        this.onPointerOutObservable.clear();\n        if (this._afterRenderObserver) {\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\n        }\n        if (this._sceneDisposeObserver) {\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\n        }\n        if (this._originalPointerObserver) {\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\n        }\n        this.utilityLayerScene.dispose();\n    };\n    UtilityLayerRenderer.prototype._updateCamera = function () {\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\n    };\n    /** @hidden */\n    UtilityLayerRenderer._DefaultUtilityLayer = null;\n    /** @hidden */\n    UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n    return UtilityLayerRenderer;\n}());\nexport { UtilityLayerRenderer };\n//# sourceMappingURL=utilityLayerRenderer.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bakedVertexAnimation\";\nvar shader = \"#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\\n{\\n#ifdef INSTANCES\\nlet VATStartFrame: f32=bakedVertexAnimationSettingsInstanced.x;\\nlet VATEndFrame: f32=bakedVertexAnimationSettingsInstanced.y;\\nlet VATOffsetFrame: f32=bakedVertexAnimationSettingsInstanced.z;\\nlet VATSpeed: f32=bakedVertexAnimationSettingsInstanced.w;\\n#else\\nlet VATStartFrame: f32=uniforms.bakedVertexAnimationSettings.x;\\nlet VATEndFrame: f32=uniforms.bakedVertexAnimationSettings.y;\\nlet VATOffsetFrame: f32=uniforms.bakedVertexAnimationSettings.z;\\nlet VATSpeed: f32=uniforms.bakedVertexAnimationSettings.w;\\n#endif\\nlet totalFrames: f32=VATEndFrame-VATStartFrame+1.0;\\nlet time: f32=uniforms.bakedVertexAnimationTime*VATSpeed/totalFrames;\\nlet frameCorrection: f32=select(1.0,0.0,time<1.0);\\nlet numOfFrames: f32=totalFrames-frameCorrection;\\nvar VATFrameNum: f32=fract(time)*numOfFrames;\\nVATFrameNum=(VATFrameNum+VATOffsetFrame) % numOfFrames;\\nVATFrameNum=floor(VATFrameNum);\\nVATFrameNum=VATFrameNum+VATStartFrame+frameCorrection;\\nvar VATInfluence : mat4x4<f32>;\\nVATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\nVATInfluence=VATInfluence+readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\\n#endif\\nfinalWorld=finalWorld*VATInfluence;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var bakedVertexAnimation = { name: name, shader: shader };\n//# sourceMappingURL=bakedVertexAnimation.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bakedVertexAnimationDeclaration\";\nvar shader = \"#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\\nuniform bakedVertexAnimationTime: f32;\\nuniform bakedVertexAnimationTextureSizeInverted: vec2<f32>;\\nuniform bakedVertexAnimationSettings: vec4<f32>;\\nvar bakedVertexAnimationTexture : texture_2d<f32>;\\n#ifdef INSTANCES\\nattribute bakedVertexAnimationSettingsInstanced : vec4<f32>;\\n#endif\\nfn readMatrixFromRawSamplerVAT(smp : texture_2d<f32>,index : f32,frame : f32)->mat4x4<f32>\\n{\\nlet offset=i32(index)*4;\\nlet frameUV=i32(frame);\\nlet m0=textureLoad(smp,vec2<i32>(offset+0,frameUV),0);\\nlet m1=textureLoad(smp,vec2<i32>(offset+1,frameUV),0);\\nlet m2=textureLoad(smp,vec2<i32>(offset+2,frameUV),0);\\nlet m3=textureLoad(smp,vec2<i32>(offset+3,frameUV),0);\\nreturn mat4x4<f32>(m0,m1,m2,m3);\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var bakedVertexAnimationDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=bakedVertexAnimationDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bonesDeclaration\";\nvar shader = \"#if NUM_BONE_INFLUENCERS>0\\nattribute matricesIndices : vec4<f32>;\\nattribute matricesWeights : vec4<f32>;\\n#if NUM_BONE_INFLUENCERS>4\\nattribute matricesIndicesExtra : vec4<f32>;\\nattribute matricesWeightsExtra : vec4<f32>;\\n#endif\\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\\n#ifdef BONETEXTURE\\nvar boneSampler : texture_2d<f32>;\\nuniform boneTextureWidth : f32;\\n#else\\nuniform mBones : array<mat4x4,BonesPerMesh>;\\n#ifdef BONES_VELOCITY_ENABLED\\nuniform mPreviousBones : array<mat4x4,BonesPerMesh>;\\n#endif\\n#endif\\n#ifdef BONETEXTURE\\nfn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>\\n{\\nlet offset=i32(index) *4; \\nlet m0=textureLoad(smp,vec2<i32>(offset+0,0),0);\\nlet m1=textureLoad(smp,vec2<i32>(offset+1,0),0);\\nlet m2=textureLoad(smp,vec2<i32>(offset+2,0),0);\\nlet m3=textureLoad(smp,vec2<i32>(offset+3,0),0);\\nreturn mat4x4<f32>(m0,m1,m2,m3);\\n}\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var bonesDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=bonesDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bonesVertex\";\nvar shader = \"#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\\n#if NUM_BONE_INFLUENCERS>0\\nvar influence : mat4x4<f32>;\\n#ifdef BONETEXTURE\\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>2\\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>3\\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\\n#endif \\n#if NUM_BONE_INFLUENCERS>4\\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\\n#endif \\n#if NUM_BONE_INFLUENCERS>5\\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>6\\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>7\\ninfluence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\\n#endif \\n#else \\ninfluence=uniforms.mBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence=influence+uniforms.mBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>2\\ninfluence=influence+uniforms.mBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>3\\ninfluence=influence+uniforms.mBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif \\n#if NUM_BONE_INFLUENCERS>4\\ninfluence=influence+uniforms.mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif \\n#if NUM_BONE_INFLUENCERS>5\\ninfluence=influence+uniforms.mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>6\\ninfluence=influence+uniforms.mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>7\\ninfluence=influence+uniforms.mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif \\n#endif\\nfinalWorld=finalWorld*influence;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var bonesVertex = { name: name, shader: shader };\n//# sourceMappingURL=bonesVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneFragment\";\nvar shader = \"#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\\nif (false) {}\\n#endif\\n#ifdef CLIPPLANE\\nelse if (fClipDistance>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE2\\nelse if (fClipDistance2>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE3\\nelse if (fClipDistance3>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE4\\nelse if (fClipDistance4>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE5\\nelse if (fClipDistance5>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE6\\nelse if (fClipDistance6>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var clipPlaneFragment = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneFragmentDeclaration\";\nvar shader = \"#ifdef CLIPPLANE\\nvarying fClipDistance: f32;\\n#endif\\n#ifdef CLIPPLANE2\\nvarying fClipDistance2: f32;\\n#endif\\n#ifdef CLIPPLANE3\\nvarying fClipDistance3: f32;\\n#endif\\n#ifdef CLIPPLANE4\\nvarying fClipDistance4: f32;\\n#endif\\n#ifdef CLIPPLANE5\\nvarying fClipDistance5: f32;\\n#endif\\n#ifdef CLIPPLANE6\\nvarying fClipDistance6: f32;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var clipPlaneFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneVertex\";\nvar shader = \"#ifdef CLIPPLANE\\nfClipDistance=dot(worldPos,uniforms.vClipPlane);\\n#endif\\n#ifdef CLIPPLANE2\\nfClipDistance2=dot(worldPos,uniforms.vClipPlane2);\\n#endif\\n#ifdef CLIPPLANE3\\nfClipDistance3=dot(worldPos,uniforms.vClipPlane3);\\n#endif\\n#ifdef CLIPPLANE4\\nfClipDistance4=dot(worldPos,uniforms.vClipPlane4);\\n#endif\\n#ifdef CLIPPLANE5\\nfClipDistance5=dot(worldPos,uniforms.vClipPlane5);\\n#endif\\n#ifdef CLIPPLANE6\\nfClipDistance6=dot(worldPos,uniforms.vClipPlane6);\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var clipPlaneVertex = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneVertexDeclaration\";\nvar shader = \"#ifdef CLIPPLANE\\nuniform vClipPlane: vec4<f32>;\\nvarying fClipDistance: f32;\\n#endif\\n#ifdef CLIPPLANE2\\nuniform vClipPlane2: vec4<f32>;\\nvarying fClipDistance2: f32;\\n#endif\\n#ifdef CLIPPLANE3\\nuniform vClipPlane3: vec4<f32>;\\nvarying fClipDistance3: f32;\\n#endif\\n#ifdef CLIPPLANE4\\nuniform vClipPlane4: vec4<f32>;\\nvarying fClipDistance4: f32;\\n#endif\\n#ifdef CLIPPLANE5\\nuniform vClipPlane5: vec4<f32>;\\nvarying fClipDistance5: f32;\\n#endif\\n#ifdef CLIPPLANE6\\nuniform vClipPlane6: vec4<f32>;\\nvarying fClipDistance6: f32;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var clipPlaneVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"instancesDeclaration\";\nvar shader = \"#ifdef INSTANCES\\nattribute world0 : vec4<f32>;\\nattribute world1 : vec4<f32>;\\nattribute world2 : vec4<f32>;\\nattribute world3 : vec4<f32>;\\n#ifdef INSTANCESCOLOR\\nattribute instanceColor : vec4<f32>;\\n#endif\\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\\nuniform world : mat4x4<f32>;\\n#endif\\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\\nattribute previousWorld0 : vec4<f32>;\\nattribute previousWorld1 : vec4<f32>;\\nattribute previousWorld2 : vec4<f32>;\\nattribute previousWorld3 : vec4<f32>;\\n#ifdef THIN_INSTANCES\\nuniform previousWorld : mat4x4<f32>;\\n#endif\\n#endif\\n#else\\n#if !defined(WORLD_UBO)\\nuniform world : mat4x4<f32>;\\n#endif\\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\\nuniform previousWorld : mat4x4<f32>;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var instancesDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=instancesDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"instancesVertex\";\nvar shader = \"#ifdef INSTANCES\\nvar finalWorld=mat4x4<f32>(world0,world1,world2,world3);\\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\\nvar finalPreviousWorld=mat4x4<f32>(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\\n#endif\\n#ifdef THIN_INSTANCES\\n#if !defined(WORLD_UBO)\\nfinalWorld=uniforms.world*finalWorld;\\n#else\\nfinalWorld=mesh.world*finalWorld;\\n#endif\\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\\n#endif\\n#endif\\n#else\\n#if !defined(WORLD_UBO)\\nvar finalWorld=uniforms.world;\\n#else\\nvar finalWorld=mesh.world;\\n#endif\\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\\nvar finalPreviousWorld=previousWorld;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var instancesVertex = { name: name, shader: shader };\n//# sourceMappingURL=instancesVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"meshUboDeclaration\";\nvar shader = \"struct Mesh {\\nworld : mat4x4<f32>,\\nvisibility : f32,\\n};\\nvar<uniform> mesh : Mesh;\\n#define WORLD_UBO\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var meshUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=meshUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"morphTargetsVertex\";\nvar shader = \"#ifdef MORPHTARGETS\\n#ifdef MORPHTARGETS_TEXTURE \\nvertexID=f32(gl_VertexID)*uniforms.morphTargetTextureInfo.x;\\npositionUpdated=positionUpdated+(readVector3FromRawSampler({X},vertexID)-position)*uniforms.morphTargetInfluences[{X}];\\nvertexID=vertexID+1.0;\\n#ifdef MORPHTARGETS_NORMAL\\nnormalUpdated=normalUpdated+(readVector3FromRawSampler({X},vertexID) -normal)*uniforms.morphTargetInfluences[{X}];\\nvertexID=vertexID+1.0;\\n#endif\\n#ifdef MORPHTARGETS_UV\\nuvUpdated=uvUpdated+(readVector3FromRawSampler({X},vertexID).xy-uv)*uniforms.morphTargetInfluences[{X}];\\nvertexID=vertexID+1.0;\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\ntangentUpdated.xyz=tangentUpdated.xyz+(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*uniforms.morphTargetInfluences[{X}];\\n#endif\\n#else\\npositionUpdated=positionUpdated+(position{X}-position)*uniforms.morphTargetInfluences[{X}];\\n#ifdef MORPHTARGETS_NORMAL\\nnormalUpdated+=(normal{X}-normal)*uniforms.morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\ntangentUpdated.xyz=tangentUpdated.xyz+(tangent{X}-tangent.xyz)*uniforms.morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_UV\\nuvUpdated=uvUpdated+(uv_{X}-uv)*uniforms.morphTargetInfluences[{X}];\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var morphTargetsVertex = { name: name, shader: shader };\n//# sourceMappingURL=morphTargetsVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"morphTargetsVertexDeclaration\";\nvar shader = \"#ifdef MORPHTARGETS\\n#ifndef MORPHTARGETS_TEXTURE\\nattribute position{X} : vec3<f32>;\\n#ifdef MORPHTARGETS_NORMAL\\nattribute normal{X} : vec3<f32>;\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\nattribute tangent{X} : vec3<f32>;\\n#endif\\n#ifdef MORPHTARGETS_UV\\nattribute uv_{X} : vec2<f32>;\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var morphTargetsVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=morphTargetsVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"morphTargetsVertexGlobal\";\nvar shader = \"#ifdef MORPHTARGETS\\n#ifdef MORPHTARGETS_TEXTURE\\nvar vertexID : f32;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var morphTargetsVertexGlobal = { name: name, shader: shader };\n//# sourceMappingURL=morphTargetsVertexGlobal.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"morphTargetsVertexGlobalDeclaration\";\nvar shader = \"#ifdef MORPHTARGETS\\nuniform morphTargetInfluences : array<f32,NUM_MORPH_INFLUENCERS>;\\n#ifdef MORPHTARGETS_TEXTURE \\nuniform morphTargetTextureIndices : array<f32,NUM_MORPH_INFLUENCERS>;\\nuniform morphTargetTextureInfo : vec3<f32>;\\nvar morphTargets : texture_2d_array<f32>;\\nvar morphTargetsSampler : sampler;\\nfn readVector3FromRawSampler(targetIndex : i32,vertexIndex : f32)->vec3<f32>\\n{ \\nlet y=floor(vertexIndex/uniforms.morphTargetTextureInfo.y);\\nlet x=vertexIndex-y*uniforms.morphTargetTextureInfo.y;\\nlet textureUV=vec2<f32>((x+0.5)/uniforms.morphTargetTextureInfo.y,(y+0.5)/uniforms.morphTargetTextureInfo.z);\\nreturn textureSampleLevel(morphTargets,morphTargetsSampler,textureUV,i32(uniforms.morphTargetTextureIndices[targetIndex]),0.0).xyz;\\n}\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var morphTargetsVertexGlobalDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=morphTargetsVertexGlobalDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"sceneUboDeclaration\";\nvar shader = \"struct Scene {\\nviewProjection : mat4x4<f32>,\\n#ifdef MULTIVIEW\\nviewProjectionR : mat4x4<f32>,\\n#endif \\nview : mat4x4<f32>,\\nprojection : mat4x4<f32>,\\nvEyePosition : vec4<f32>,\\n};\\nvar<uniform> scene : Scene;\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var sceneUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=sceneUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"gpuUpdateParticlesComputeShader\";\nvar shader = \"struct Particle {\\nposition : vec3<f32>,\\nage : f32,\\nsize : vec3<f32>,\\nlife : f32,\\nseed : vec4<f32>,\\ndirection : vec3<f32>,\\ndummy0: f32,\\n#ifdef CUSTOMEMITTER\\ninitialPosition : vec3<f32>,\\ndummy1: f32,\\n#endif\\n#ifndef COLORGRADIENTS\\ncolor : vec4<f32>,\\n#endif\\n#ifndef BILLBOARD\\ninitialDirection : vec3<f32>,\\ndummy2: f32,\\n#endif\\n#ifdef NOISE\\nnoiseCoordinates1 : vec3<f32>,\\ndummy3: f32,\\nnoiseCoordinates2 : vec3<f32>,\\ndummy4: f32,\\n#endif\\n#ifdef ANGULARSPEEDGRADIENTS\\nangle : f32,\\n#else\\nangle : vec2<f32>,\\n#endif\\n#ifdef ANIMATESHEET\\ncellIndex : f32,\\n#ifdef ANIMATESHEETRANDOMSTART\\ncellStartOffset : f32,\\n#endif\\n#endif\\n};\\nstruct Particles {\\nparticles : array<Particle>,\\n};\\nstruct SimParams {\\ncurrentCount : f32,\\ntimeDelta : f32,\\nstopFactor : f32,\\nrandomTextureSize: i32,\\nlifeTime : vec2<f32>,\\nemitPower : vec2<f32>,\\n#ifndef COLORGRADIENTS\\ncolor1 : vec4<f32>,\\ncolor2 : vec4<f32>,\\n#endif\\nsizeRange : vec2<f32>,\\nscaleRange : vec4<f32>,\\nangleRange : vec4<f32>,\\ngravity : vec3<f32>,\\n#ifdef LIMITVELOCITYGRADIENTS\\nlimitVelocityDamping : f32,\\n#endif\\n#ifdef ANIMATESHEET\\ncellInfos : vec4<f32>,\\n#endif\\n#ifdef NOISE\\nnoiseStrength : vec3<f32>,\\n#endif\\n#ifndef LOCAL\\nemitterWM : mat4x4<f32>,\\n#endif\\n#ifdef BOXEMITTER\\ndirection1 : vec3<f32>,\\ndirection2 : vec3<f32>,\\nminEmitBox : vec3<f32>,\\nmaxEmitBox : vec3<f32>,\\n#endif\\n#ifdef CONEEMITTER\\nradius : vec2<f32>,\\nconeAngle : f32,\\nheight : vec2<f32>,\\ndirectionRandomizer : f32,\\n#endif\\n#ifdef CYLINDEREMITTER\\nradius : f32,\\nheight : f32,\\nradiusRange : f32,\\n#ifdef DIRECTEDCYLINDEREMITTER\\ndirection1 : vec3<f32>,\\ndirection2 : vec3<f32>,\\n#else\\ndirectionRandomizer : f32,\\n#endif\\n#endif\\n#ifdef HEMISPHERICEMITTER\\nradius : f32,\\nradiusRange : f32,\\ndirectionRandomizer : f32,\\n#endif\\n#ifdef POINTEMITTER\\ndirection1 : vec3<f32>,\\ndirection2 : vec3<f32>,\\n#endif\\n#ifdef SPHEREEMITTER\\nradius : f32,\\nradiusRange : f32,\\n#ifdef DIRECTEDSPHEREEMITTER\\ndirection1 : vec3<f32>,\\ndirection2 : vec3<f32>,\\n#else\\ndirectionRandomizer : f32,\\n#endif\\n#endif\\n};\\n@binding(0) @group(0) var<uniform> params : SimParams;\\n@binding(1) @group(0) var<storage,read> particlesIn : Particles;\\n@binding(2) @group(0) var<storage,read_write> particlesOut : Particles;\\n@binding(3) @group(0) var randomTexture : texture_2d<f32>;\\n@binding(4) @group(0) var randomTexture2 : texture_2d<f32>;\\n#ifdef SIZEGRADIENTS\\n@binding(0) @group(1) var sizeGradientSampler : sampler;\\n@binding(1) @group(1) var sizeGradientTexture : texture_2d<f32>;\\n#endif \\n#ifdef ANGULARSPEEDGRADIENTS\\n@binding(2) @group(1) var angularSpeedGradientSampler : sampler;\\n@binding(3) @group(1) var angularSpeedGradientTexture : texture_2d<f32>;\\n#endif \\n#ifdef VELOCITYGRADIENTS\\n@binding(4) @group(1) var velocityGradientSampler : sampler;\\n@binding(5) @group(1) var velocityGradientTexture : texture_2d<f32>;\\n#endif\\n#ifdef LIMITVELOCITYGRADIENTS\\n@binding(6) @group(1) var limitVelocityGradientSampler : sampler;\\n@binding(7) @group(1) var limitVelocityGradientTexture : texture_2d<f32>;\\n#endif\\n#ifdef DRAGGRADIENTS\\n@binding(8) @group(1) var dragGradientSampler : sampler;\\n@binding(9) @group(1) var dragGradientTexture : texture_2d<f32>;\\n#endif\\n#ifdef NOISE\\n@binding(10) @group(1) var noiseSampler : sampler;\\n@binding(11) @group(1) var noiseTexture : texture_2d<f32>;\\n#endif\\nfn getRandomVec3(offset : f32,vertexID : f32)->vec3<f32> {\\nreturn textureLoad(randomTexture2,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0).rgb;\\n}\\nfn getRandomVec4(offset : f32,vertexID : f32)->vec4<f32> {\\nreturn textureLoad(randomTexture,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0);\\n}\\n@stage(compute) @workgroup_size(64)\\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\\nlet index : u32=GlobalInvocationID.x;\\nlet vertexID : f32=f32(index);\\nif (index>=u32(params.currentCount)) {\\nreturn;\\n}\\nlet PI : f32=3.14159;\\nlet timeDelta : f32=params.timeDelta;\\nlet newAge : f32=particlesIn.particles[index].age+timeDelta;\\nlet life : f32=particlesIn.particles[index].life;\\nlet seed : vec4<f32>=particlesIn.particles[index].seed;\\nlet direction : vec3<f32>=particlesIn.particles[index].direction;\\nif (newAge>=life && params.stopFactor != 0.) {\\nvar newPosition : vec3<f32>;\\nvar newDirection : vec3<f32>;\\nlet randoms : vec4<f32>=getRandomVec4(seed.x,vertexID);\\nlet outLife : f32=params.lifeTime.x+(params.lifeTime.y-params.lifeTime.x)*randoms.r;\\nparticlesOut.particles[index].life=outLife;\\nparticlesOut.particles[index].age=newAge-life;\\nparticlesOut.particles[index].seed=seed;\\nvar sizex : f32;\\n#ifdef SIZEGRADIENTS \\nsizex=textureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(0.,0.),0.).r;\\n#else\\nsizex=params.sizeRange.x+(params.sizeRange.y-params.sizeRange.x)*randoms.g;\\n#endif\\nparticlesOut.particles[index].size=vec3<f32>(\\nsizex,\\nparams.scaleRange.x+(params.scaleRange.y-params.scaleRange.x)*randoms.b,\\nparams.scaleRange.z+(params.scaleRange.w-params.scaleRange.z)*randoms.a);\\n#ifndef COLORGRADIENTS\\nparticlesOut.particles[index].color=params.color1+(params.color2-params.color1)*randoms.b;\\n#endif\\n#ifndef ANGULARSPEEDGRADIENTS \\nparticlesOut.particles[index].angle=vec2<f32>(\\nparams.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r,\\nparams.angleRange.x+(params.angleRange.y-params.angleRange.x)*randoms.a);\\n#else\\nparticlesOut.particles[index].angle=params.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r;\\n#endif \\n#if defined(POINTEMITTER)\\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\\nlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\\nnewPosition=vec3<f32>(0.,0.,0.);\\nnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\\n#elif defined(BOXEMITTER)\\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\\nlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\\nnewPosition=params.minEmitBox+(params.maxEmitBox-params.minEmitBox)*randoms2;\\nnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3; \\n#elif defined(HEMISPHERICEMITTER)\\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\\nlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\\nlet phi : f32=2.0*PI*randoms2.x;\\nlet theta : f32=acos(-1.0+2.0*randoms2.y);\\nlet randX : f32=cos(phi)*sin(theta);\\nlet randY : f32=cos(theta);\\nlet randZ : f32=sin(phi)*sin(theta);\\nnewPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,abs(randY),randZ);\\nnewDirection=normalize(newPosition+params.directionRandomizer*randoms3);\\n#elif defined(SPHEREEMITTER)\\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\\nlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\\nlet phi : f32=2.0*PI*randoms2.x;\\nlet theta : f32=acos(-1.0+2.0*randoms2.y);\\nlet randX : f32=cos(phi)*sin(theta);\\nlet randY : f32=cos(theta);\\nlet randZ : f32=sin(phi)*sin(theta);\\nnewPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,randY,randZ);\\n#ifdef DIRECTEDSPHEREEMITTER\\nnewDirection=normalize(params.direction1+(params.direction2-params.direction1)*randoms3);\\n#else\\nnewDirection=normalize(newPosition+params.directionRandomizer*randoms3);\\n#endif\\n#elif defined(CYLINDEREMITTER)\\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\\nlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\\nlet yPos : f32=(-0.5+randoms2.x)*params.height;\\nvar angle : f32=randoms2.y*PI*2.;\\nlet inverseRadiusRangeSquared : f32=(1.-params.radiusRange)*(1.-params.radiusRange);\\nlet positionRadius : f32=params.radius*sqrt(inverseRadiusRangeSquared+randoms2.z*(1.-inverseRadiusRangeSquared));\\nlet xPos : f32=positionRadius*cos(angle);\\nlet zPos : f32=positionRadius*sin(angle);\\nnewPosition=vec3<f32>(xPos,yPos,zPos);\\n#ifdef DIRECTEDCYLINDEREMITTER\\nnewDirection=params.direction1+(params.direction2-params.direction1)*randoms3;\\n#else\\nangle=angle+(-0.5+randoms3.x)*PI*params.directionRandomizer;\\nnewDirection=vec3<f32>(cos(angle),(-0.5+randoms3.y)*params.directionRandomizer,sin(angle));\\nnewDirection=normalize(newDirection);\\n#endif\\n#elif defined(CONEEMITTER)\\nlet randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);\\nlet s : f32=2.0*PI*randoms2.x;\\n#ifdef CONEEMITTERSPAWNPOINT\\nlet h : f32=0.0001;\\n#else\\nvar h : f32=randoms2.y*params.height.y;\\nh=1.-h*h; \\n#endif\\nvar lRadius : f32=params.radius.x-params.radius.x*randoms2.z*params.radius.y;\\nlRadius=lRadius*h;\\nlet randX : f32=lRadius*sin(s);\\nlet randZ : f32=lRadius*cos(s);\\nlet randY : f32=h *params.height.x;\\nnewPosition=vec3<f32>(randX,randY,randZ); \\nif (abs(cos(params.coneAngle))==1.0) {\\nnewDirection=vec3<f32>(0.,1.0,0.);\\n} else {\\nlet randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);\\nnewDirection=normalize(newPosition+params.directionRandomizer*randoms3); \\n}\\n#elif defined(CUSTOMEMITTER)\\nnewPosition=particlesIn.particles[index].initialPosition;\\nparticlesOut.particles[index].initialPosition=newPosition;\\n#else \\nnewPosition=vec3<f32>(0.,0.,0.);\\nnewDirection=2.0*(getRandomVec3(seed.w,vertexID)-vec3<f32>(0.5,0.5,0.5));\\n#endif\\nlet power : f32=params.emitPower.x+(params.emitPower.y-params.emitPower.x)*randoms.a;\\n#ifdef LOCAL\\nparticlesOut.particles[index].position=newPosition;\\n#else\\nparticlesOut.particles[index].position=(params.emitterWM*vec4<f32>(newPosition,1.)).xyz;\\n#endif\\n#ifdef CUSTOMEMITTER\\nparticlesOut.particles[index].direction=direction;\\n#ifndef BILLBOARD \\nparticlesOut.particles[index].initialDirection=direction;\\n#endif\\n#else\\n#ifdef LOCAL\\nlet initial : vec3<f32>=newDirection;\\n#else \\nlet initial : vec3<f32>=(params.emitterWM*vec4<f32>(newDirection,0.)).xyz;\\n#endif\\nparticlesOut.particles[index].direction=initial*power;\\n#ifndef BILLBOARD \\nparticlesOut.particles[index].initialDirection=initial;\\n#endif\\n#endif\\n#ifdef ANIMATESHEET \\nparticlesOut.particles[index].cellIndex=params.cellInfos.x;\\n#ifdef ANIMATESHEETRANDOMSTART\\nparticlesOut.particles[index].cellStartOffset=randoms.a*outLife;\\n#endif \\n#endif\\n#ifdef NOISE\\nparticlesOut.particles[index].noiseCoordinates1=particlesIn.particles[index].noiseCoordinates1;\\nparticlesOut.particles[index].noiseCoordinates2=particlesIn.particles[index].noiseCoordinates2;\\n#endif\\n} else {\\nvar directionScale : f32=timeDelta;\\nparticlesOut.particles[index].age=newAge;\\nlet ageGradient : f32=newAge/life;\\n#ifdef VELOCITYGRADIENTS\\ndirectionScale=directionScale*textureSampleLevel(velocityGradientTexture,velocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\\n#endif\\n#ifdef DRAGGRADIENTS\\ndirectionScale=directionScale*(1.0-textureSampleLevel(dragGradientTexture,dragGradientSampler,vec2<f32>(ageGradient,0.),0.).r);\\n#endif\\nlet position : vec3<f32>=particlesIn.particles[index].position;\\n#if defined(CUSTOMEMITTER)\\nparticlesOut.particles[index].position=position+(direction-position)*ageGradient; \\nparticlesOut.particles[index].initialPosition=particlesIn.particles[index].initialPosition;\\n#else\\nparticlesOut.particles[index].position=position+direction*directionScale;\\n#endif\\nparticlesOut.particles[index].life=life;\\nparticlesOut.particles[index].seed=seed;\\n#ifndef COLORGRADIENTS \\nparticlesOut.particles[index].color=particlesIn.particles[index].color;\\n#endif\\n#ifdef SIZEGRADIENTS\\nparticlesOut.particles[index].size=vec3<f32>(\\ntextureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(ageGradient,0.),0.).r,\\nparticlesIn.particles[index].size.yz);\\n#else\\nparticlesOut.particles[index].size=particlesIn.particles[index].size;\\n#endif \\n#ifndef BILLBOARD \\nparticlesOut.particles[index].initialDirection=particlesIn.particles[index].initialDirection;\\n#endif\\n#ifdef CUSTOMEMITTER\\nparticlesOut.particles[index].direction=direction;\\n#else\\nvar updatedDirection : vec3<f32>=direction+params.gravity*timeDelta;\\n#ifdef LIMITVELOCITYGRADIENTS\\nlet limitVelocity : f32=textureSampleLevel(limitVelocityGradientTexture,limitVelocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\\nlet currentVelocity : f32=length(updatedDirection);\\nif (currentVelocity>limitVelocity) {\\nupdatedDirection=updatedDirection*params.limitVelocityDamping;\\n}\\n#endif\\nparticlesOut.particles[index].direction=updatedDirection;\\n#ifdef NOISE\\nlet noiseCoordinates1 : vec3<f32>=particlesIn.particles[index].noiseCoordinates1;\\nlet noiseCoordinates2 : vec3<f32>=particlesIn.particles[index].noiseCoordinates2;\\nlet fetchedR : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.x,noiseCoordinates1.y)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;\\nlet fetchedG : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.z,noiseCoordinates2.x)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;\\nlet fetchedB : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates2.y,noiseCoordinates2.z)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;\\nlet force : vec3<f32>=vec3<f32>(-1.+2.*fetchedR,-1.+2.*fetchedG,-1.+2.*fetchedB)*params.noiseStrength;\\nparticlesOut.particles[index].direction=particlesOut.particles[index].direction+force*timeDelta;\\nparticlesOut.particles[index].noiseCoordinates1=noiseCoordinates1;\\nparticlesOut.particles[index].noiseCoordinates2=noiseCoordinates2;\\n#endif \\n#endif \\n#ifdef ANGULARSPEEDGRADIENTS\\nlet angularSpeed : f32=textureSampleLevel(angularSpeedGradientTexture,angularSpeedGradientSampler,vec2<f32>(ageGradient,0.),0.).r;\\nparticlesOut.particles[index].angle=particlesIn.particles[index].angle+angularSpeed*timeDelta;\\n#else\\nlet angle : vec2<f32>=particlesIn.particles[index].angle;\\nparticlesOut.particles[index].angle=vec2<f32>(angle.x+angle.y*timeDelta,angle.y);\\n#endif\\n#ifdef ANIMATESHEET \\nvar offsetAge : f32=particlesOut.particles[index].age;\\nlet dist : f32=params.cellInfos.y-params.cellInfos.x;\\n#ifdef ANIMATESHEETRANDOMSTART\\nlet cellStartOffset : f32=particlesIn.particles[index].cellStartOffset;\\nparticlesOut.particles[index].cellStartOffset=cellStartOffset;\\noffsetAge=offsetAge+cellStartOffset;\\n#else\\nlet cellStartOffset : f32=0.;\\n#endif \\nvar ratio : f32;\\nif (params.cellInfos.w==1.0) {\\nratio=clamp(((cellStartOffset+params.cellInfos.z*offsetAge) % life)/life,0.,1.0);\\n}\\nelse {\\nratio=clamp((cellStartOffset+params.cellInfos.z*offsetAge)/life,0.,1.0);\\n}\\nparticlesOut.particles[index].cellIndex=f32(i32(params.cellInfos.x+ratio*dist));\\n#endif\\n}\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStoreWGSL[name] = shader;\n/** @hidden */\nexport var gpuUpdateParticlesComputeShader = { name: name, shader: shader };\n//# sourceMappingURL=gpuUpdateParticles.compute.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nvar name = \"backgroundUboDeclaration\";\nvar shader = \"layout(std140,column_major) uniform;\\nuniform Material\\n{\\nuniform vec4 vPrimaryColor;\\nuniform vec4 vPrimaryColorShadow;\\nuniform vec2 vDiffuseInfos;\\nuniform vec2 vReflectionInfos;\\nuniform mat4 diffuseMatrix;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\nuniform float fFovMultiplier;\\nuniform float pointSize;\\nuniform float shadowLevel;\\nuniform float alpha;\\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\\nuniform vec3 vBackgroundCenter;\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nuniform vec4 vReflectionControl;\\n#endif\\n};\\n#include<sceneUboDeclaration>\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var backgroundUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=backgroundUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bakedVertexAnimation\";\nvar shader = \"#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\\n{\\n#ifdef INSTANCES\\n#define BVASNAME bakedVertexAnimationSettingsInstanced\\n#else\\n#define BVASNAME bakedVertexAnimationSettings\\n#endif\\nfloat VATStartFrame=BVASNAME.x;\\nfloat VATEndFrame=BVASNAME.y;\\nfloat VATOffsetFrame=BVASNAME.z;\\nfloat VATSpeed=BVASNAME.w;\\nfloat totalFrames=VATEndFrame-VATStartFrame+1.0;\\nfloat time=bakedVertexAnimationTime*VATSpeed/totalFrames;\\nfloat frameCorrection=time<1.0 ? 0.0 : 1.0;\\nfloat numOfFrames=totalFrames-frameCorrection;\\nfloat VATFrameNum=fract(time)*numOfFrames;\\nVATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);\\nVATFrameNum=floor(VATFrameNum);\\nVATFrameNum+=VATStartFrame+frameCorrection;\\nmat4 VATInfluence;\\nVATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\\n#endif\\nfinalWorld=finalWorld*VATInfluence;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bakedVertexAnimation = { name: name, shader: shader };\n//# sourceMappingURL=bakedVertexAnimation.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bakedVertexAnimationDeclaration\";\nvar shader = \"#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\\nuniform float bakedVertexAnimationTime;\\nuniform vec2 bakedVertexAnimationTextureSizeInverted;\\nuniform vec4 bakedVertexAnimationSettings;\\nuniform sampler2D bakedVertexAnimationTexture;\\n#ifdef INSTANCES\\nattribute vec4 bakedVertexAnimationSettingsInstanced;\\n#endif\\n#define inline\\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\\n{\\nfloat offset=index*4.0;\\nfloat frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;\\nfloat dx=bakedVertexAnimationTextureSizeInverted.x;\\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));\\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));\\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));\\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));\\nreturn mat4(m0,m1,m2,m3);\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bakedVertexAnimationDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=bakedVertexAnimationDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bonesDeclaration\";\nvar shader = \"#if NUM_BONE_INFLUENCERS>0\\nattribute vec4 matricesIndices;\\nattribute vec4 matricesWeights;\\n#if NUM_BONE_INFLUENCERS>4\\nattribute vec4 matricesIndicesExtra;\\nattribute vec4 matricesWeightsExtra;\\n#endif\\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\\n#ifdef BONETEXTURE\\nuniform sampler2D boneSampler;\\nuniform float boneTextureWidth;\\n#else\\nuniform mat4 mBones[BonesPerMesh];\\n#ifdef BONES_VELOCITY_ENABLED\\nuniform mat4 mPreviousBones[BonesPerMesh];\\n#endif\\n#endif\\n#ifdef BONETEXTURE\\n#define inline\\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\\n{\\nfloat offset=index *4.0;\\nfloat dx=1.0/boneTextureWidth;\\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));\\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));\\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));\\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));\\nreturn mat4(m0,m1,m2,m3);\\n}\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bonesDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=bonesDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bonesVertex\";\nvar shader = \"#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\\n#if NUM_BONE_INFLUENCERS>0\\nmat4 influence;\\n#ifdef BONETEXTURE\\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\\n#endif\\n#else\\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>2\\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>3\\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif\\n#if NUM_BONE_INFLUENCERS>5\\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif\\n#if NUM_BONE_INFLUENCERS>6\\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif\\n#if NUM_BONE_INFLUENCERS>7\\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif\\n#endif\\nfinalWorld=finalWorld*influence;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bonesVertex = { name: name, shader: shader };\n//# sourceMappingURL=bonesVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bumpFragment\";\nvar shader = \"vec2 uvOffset=vec2(0.0,0.0);\\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\\n#ifdef NORMALXYSCALE\\nfloat normalScale=1.0;\\n#elif defined(BUMP)\\nfloat normalScale=vBumpInfos.y;\\n#else\\nfloat normalScale=1.0;\\n#endif\\n#if defined(TANGENT) && defined(NORMAL)\\nmat3 TBN=vTBN;\\n#elif defined(BUMP)\\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;\\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\\n#else\\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;\\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\\n#endif\\n#elif defined(ANISOTROPIC)\\n#if defined(TANGENT) && defined(NORMAL)\\nmat3 TBN=vTBN;\\n#else\\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;\\nmat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\\n#endif\\n#endif\\n#ifdef PARALLAX\\nmat3 invTBN=transposeMat3(TBN);\\n#ifdef PARALLAXOCCLUSION\\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\\n#else\\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\\n#endif\\n#endif\\n#ifdef DETAIL\\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\\nvec2 detailNormalRG=detailColor.wy*2.0-1.0;\\nfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\\nvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\\n#endif\\n#ifdef BUMP\\n#ifdef OBJECTSPACE_NORMALMAP\\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);\\nnormalW=normalize(mat3(normalMatrix)*normalW);\\n#elif !defined(DETAIL)\\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\\n#else\\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\\n#if DETAIL_NORMALBLENDMETHOD==0 \\ndetailNormal.xy*=vDetailInfos.z;\\nvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\\n#elif DETAIL_NORMALBLENDMETHOD==1 \\ndetailNormal.xy*=vDetailInfos.z;\\nbumpNormal+=vec3(0.0,0.0,1.0);\\ndetailNormal*=vec3(-1.0,-1.0,1.0);\\nvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\\n#endif\\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\\n#endif\\n#elif defined(DETAIL)\\ndetailNormal.xy*=vDetailInfos.z;\\nnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpFragment = { name: name, shader: shader };\n//# sourceMappingURL=bumpFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./samplerFragmentDeclaration.js\";\nvar name = \"bumpFragmentFunctions\";\nvar shader = \"#if defined(BUMP)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\\n#endif\\n#if defined(DETAIL)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\\n#endif\\n#if defined(BUMP) && defined(PARALLAX)\\nconst float minSamples=4.;\\nconst float maxSamples=15.;\\nconst int iMaxSamples=15;\\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\\nparallaxLimit*=parallaxScale;\\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\\nfloat stepSize=1.0/numSamples;\\nfloat currRayHeight=1.0;\\nvec2 vCurrOffset=vec2(0,0);\\nvec2 vLastOffset=vec2(0,0);\\nfloat lastSampledHeight=1.0;\\nfloat currSampledHeight=1.0;\\nfor (int i=0; i<iMaxSamples; i++)\\n{\\ncurrSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;\\nif (currSampledHeight>currRayHeight)\\n{\\nfloat delta1=currSampledHeight-currRayHeight;\\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\\nfloat ratio=delta1/(delta1+delta2);\\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\\nbreak;\\n}\\nelse\\n{\\ncurrRayHeight-=stepSize;\\nvLastOffset=vCurrOffset;\\nvCurrOffset+=stepSize*vMaxOffset;\\nlastSampledHeight=currSampledHeight;\\n}\\n}\\nreturn vCurrOffset;\\n}\\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\\n{\\nfloat height=texture2D(bumpSampler,vBumpUV).w;\\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\\nreturn -texCoordOffset;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpFragmentFunctions = { name: name, shader: shader };\n//# sourceMappingURL=bumpFragmentFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bumpFragmentMainFunctions\";\nvar shader = \"#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\\n#if defined(TANGENT) && defined(NORMAL) \\nvarying mat3 vTBN;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\nuniform mat4 normalMatrix;\\n#endif\\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\\n{\\n#ifdef NORMALXYSCALE\\nnormal=normalize(normal*vec3(scale,scale,1.0));\\n#endif\\nreturn normalize(cotangentFrame*normal);\\n}\\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\\n{\\nreturn perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);\\n}\\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\\n{\\nvec3 dp1=dFdx(p);\\nvec3 dp2=dFdy(p);\\nvec2 duv1=dFdx(uv);\\nvec2 duv2=dFdy(uv);\\nvec3 dp2perp=cross(dp2,normal);\\nvec3 dp1perp=cross(normal,dp1);\\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\\nvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\\ntangent*=tangentSpaceParams.x;\\nbitangent*=tangentSpaceParams.y;\\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));\\nreturn mat3(tangent*invmax,bitangent*invmax,normal);\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpFragmentMainFunctions = { name: name, shader: shader };\n//# sourceMappingURL=bumpFragmentMainFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bumpVertex\";\nvar shader = \"#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\\n#if defined(TANGENT) && defined(NORMAL)\\nvec3 tbnNormal=normalize(normalUpdated);\\nvec3 tbnTangent=normalize(tangentUpdated.xyz);\\nvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\\nvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpVertex = { name: name, shader: shader };\n//# sourceMappingURL=bumpVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bumpVertexDeclaration\";\nvar shader = \"#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\\n#if defined(TANGENT) && defined(NORMAL) \\nvarying mat3 vTBN;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bumpVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=bumpVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneFragment\";\nvar shader = \"#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\\nif (false) {}\\n#endif\\n#ifdef CLIPPLANE\\nelse if (fClipDistance>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE2\\nelse if (fClipDistance2>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE3\\nelse if (fClipDistance3>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE4\\nelse if (fClipDistance4>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE5\\nelse if (fClipDistance5>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE6\\nelse if (fClipDistance6>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneFragment = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneFragmentDeclaration\";\nvar shader = \"#ifdef CLIPPLANE\\nvarying float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nvarying float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nvarying float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nvarying float fClipDistance4;\\n#endif\\n#ifdef CLIPPLANE5\\nvarying float fClipDistance5;\\n#endif\\n#ifdef CLIPPLANE6\\nvarying float fClipDistance6;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneVertex\";\nvar shader = \"#ifdef CLIPPLANE\\nfClipDistance=dot(worldPos,vClipPlane);\\n#endif\\n#ifdef CLIPPLANE2\\nfClipDistance2=dot(worldPos,vClipPlane2);\\n#endif\\n#ifdef CLIPPLANE3\\nfClipDistance3=dot(worldPos,vClipPlane3);\\n#endif\\n#ifdef CLIPPLANE4\\nfClipDistance4=dot(worldPos,vClipPlane4);\\n#endif\\n#ifdef CLIPPLANE5\\nfClipDistance5=dot(worldPos,vClipPlane5);\\n#endif\\n#ifdef CLIPPLANE6\\nfClipDistance6=dot(worldPos,vClipPlane6);\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneVertex = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneVertexDeclaration\";\nvar shader = \"#ifdef CLIPPLANE\\nuniform vec4 vClipPlane;\\nvarying float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nuniform vec4 vClipPlane2;\\nvarying float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nuniform vec4 vClipPlane3;\\nvarying float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nuniform vec4 vClipPlane4;\\nvarying float fClipDistance4;\\n#endif\\n#ifdef CLIPPLANE5\\nuniform vec4 vClipPlane5;\\nvarying float fClipDistance5;\\n#endif\\n#ifdef CLIPPLANE6\\nuniform vec4 vClipPlane6;\\nvarying float fClipDistance6;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nimport \"./meshUboDeclaration.js\";\nvar name = \"defaultUboDeclaration\";\nvar shader = \"layout(std140,column_major) uniform;\\nuniform Material\\n{\\nvec4 diffuseLeftColor;\\nvec4 diffuseRightColor;\\nvec4 opacityParts;\\nvec4 reflectionLeftColor;\\nvec4 reflectionRightColor;\\nvec4 refractionLeftColor;\\nvec4 refractionRightColor;\\nvec4 emissiveLeftColor;\\nvec4 emissiveRightColor;\\nvec2 vDiffuseInfos;\\nvec2 vAmbientInfos;\\nvec2 vOpacityInfos;\\nvec2 vReflectionInfos;\\nvec3 vReflectionPosition;\\nvec3 vReflectionSize;\\nvec2 vEmissiveInfos;\\nvec2 vLightmapInfos;\\nvec2 vSpecularInfos;\\nvec3 vBumpInfos;\\nmat4 diffuseMatrix;\\nmat4 ambientMatrix;\\nmat4 opacityMatrix;\\nmat4 reflectionMatrix;\\nmat4 emissiveMatrix;\\nmat4 lightmapMatrix;\\nmat4 specularMatrix;\\nmat4 bumpMatrix;\\nvec2 vTangentSpaceParams;\\nfloat pointSize;\\nfloat alphaCutOff;\\nmat4 refractionMatrix;\\nvec4 vRefractionInfos;\\nvec3 vRefractionPosition;\\nvec3 vRefractionSize;\\nvec4 vSpecularColor;\\nvec3 vEmissiveColor;\\nvec4 vDiffuseColor;\\nvec3 vAmbientColor;\\n#define ADDITIONAL_UBO_DECLARATION\\n};\\n#include<sceneUboDeclaration>\\n#include<meshUboDeclaration>\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var defaultUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=defaultUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"depthPrePass\";\nvar shader = \"#ifdef DEPTHPREPASS\\ngl_FragColor=vec4(0.,0.,0.,1.0);\\nreturn;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var depthPrePass = { name: name, shader: shader };\n//# sourceMappingURL=depthPrePass.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"fogFragment\";\nvar shader = \"#ifdef FOG\\nfloat fog=CalcFogFactor();\\n#ifdef PBR\\nfog=toLinearSpace(fog);\\n#endif\\ncolor.rgb=mix(vFogColor,color.rgb,fog);\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fogFragment = { name: name, shader: shader };\n//# sourceMappingURL=fogFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"fogFragmentDeclaration\";\nvar shader = \"#ifdef FOG\\n#define FOGMODE_NONE 0.\\n#define FOGMODE_EXP 1.\\n#define FOGMODE_EXP2 2.\\n#define FOGMODE_LINEAR 3.\\n#define E 2.71828\\nuniform vec4 vFogInfos;\\nuniform vec3 vFogColor;\\nvarying vec3 vFogDistance;\\nfloat CalcFogFactor()\\n{\\nfloat fogCoeff=1.0;\\nfloat fogStart=vFogInfos.y;\\nfloat fogEnd=vFogInfos.z;\\nfloat fogDensity=vFogInfos.w;\\nfloat fogDistance=length(vFogDistance);\\nif (FOGMODE_LINEAR==vFogInfos.x)\\n{\\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\\n}\\nelse if (FOGMODE_EXP==vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\\n}\\nelse if (FOGMODE_EXP2==vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\\n}\\nreturn clamp(fogCoeff,0.0,1.0);\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fogFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=fogFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"fogVertex\";\nvar shader = \"#ifdef FOG\\nvFogDistance=(view*worldPos).xyz;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fogVertex = { name: name, shader: shader };\n//# sourceMappingURL=fogVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"fogVertexDeclaration\";\nvar shader = \"#ifdef FOG\\nvarying vec3 vFogDistance;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fogVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=fogVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"fresnelFunction\";\nvar shader = \"#ifdef FRESNEL\\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\\n{\\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\\nreturn clamp(fresnelTerm,0.,1.);\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fresnelFunction = { name: name, shader: shader };\n//# sourceMappingURL=fresnelFunction.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"harmonicsFunctions\";\nvar shader = \"#ifdef USESPHERICALFROMREFLECTIONMAP\\n#ifdef SPHERICAL_HARMONICS\\nvec3 computeEnvironmentIrradiance(vec3 normal) {\\nreturn vSphericalL00\\n+ vSphericalL1_1*(normal.y)\\n+ vSphericalL10*(normal.z)\\n+ vSphericalL11*(normal.x)\\n+ vSphericalL2_2*(normal.y*normal.x)\\n+ vSphericalL2_1*(normal.y*normal.z)\\n+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)\\n+ vSphericalL21*(normal.z*normal.x)\\n+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));\\n}\\n#else\\nvec3 computeEnvironmentIrradiance(vec3 normal) {\\nfloat Nx=normal.x;\\nfloat Ny=normal.y;\\nfloat Nz=normal.z;\\nvec3 C1=vSphericalZZ.rgb;\\nvec3 Cx=vSphericalX.rgb;\\nvec3 Cy=vSphericalY.rgb;\\nvec3 Cz=vSphericalZ.rgb;\\nvec3 Cxx_zz=vSphericalXX_ZZ.rgb;\\nvec3 Cyy_zz=vSphericalYY_ZZ.rgb;\\nvec3 Cxy=vSphericalXY.rgb;\\nvec3 Cyz=vSphericalYZ.rgb;\\nvec3 Czx=vSphericalZX.rgb;\\nvec3 a1=Cyy_zz*Ny+Cy;\\nvec3 a2=Cyz*Nz+a1;\\nvec3 b1=Czx*Nz+Cx;\\nvec3 b2=Cxy*Ny+b1;\\nvec3 b3=Cxx_zz*Nx+b2;\\nvec3 t1=Cz *Nz+C1;\\nvec3 t2=a2 *Ny+t1;\\nvec3 t3=b3 *Nx+t2;\\nreturn t3;\\n}\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var harmonicsFunctions = { name: name, shader: shader };\n//# sourceMappingURL=harmonicsFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"hdrFilteringFunctions\";\nvar shader = \"#ifdef NUM_SAMPLES\\n#if NUM_SAMPLES>0\\n#if defined(WEBGL2) || defined(WEBGPU)\\nfloat radicalInverse_VdC(uint bits) \\n{\\nbits=(bits<<16u) | (bits>>16u);\\nbits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);\\nbits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);\\nbits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);\\nbits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);\\nreturn float(bits)*2.3283064365386963e-10; \\n}\\nvec2 hammersley(uint i,uint N)\\n{\\nreturn vec2(float(i)/float(N),radicalInverse_VdC(i));\\n}\\n#else\\nfloat vanDerCorpus(int n,int base)\\n{\\nfloat invBase=1.0/float(base);\\nfloat denom =1.0;\\nfloat result =0.0;\\nfor(int i=0; i<32; ++i)\\n{\\nif(n>0)\\n{\\ndenom =mod(float(n),2.0);\\nresult+=denom*invBase;\\ninvBase=invBase/2.0;\\nn =int(float(n)/2.0);\\n}\\n}\\nreturn result;\\n}\\nvec2 hammersley(int i,int N)\\n{\\nreturn vec2(float(i)/float(N),vanDerCorpus(i,2));\\n}\\n#endif\\nfloat log4(float x) {\\nreturn log2(x)/2.;\\n}\\nconst float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);\\nconst float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;\\nconst float K=4.;\\n#define inline\\nvec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\\n{\\nvec3 n=normalize(inputN);\\nvec3 result=vec3(0.0);\\nvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\\ntangent=normalize(cross(tangent,n));\\nvec3 bitangent=cross(n,tangent);\\nmat3 tbn=mat3(tangent,bitangent,n);\\nfloat maxLevel=filteringInfo.y;\\nfloat dim0=filteringInfo.x;\\nfloat omegaP=(4.*PI)/(6.*dim0*dim0);\\n#if defined(WEBGL2) || defined(WEBGPU)\\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\\n#else\\nfor(int i=0; i<NUM_SAMPLES; ++i)\\n#endif\\n{\\nvec2 Xi=hammersley(i,NUM_SAMPLES);\\nvec3 Ls=hemisphereCosSample(Xi);\\nLs=normalize(Ls);\\nvec3 Ns=vec3(0.,0.,1.);\\nfloat NoL=dot(Ns,Ls);\\nif (NoL>0.) {\\nfloat pdf_inversed=PI/NoL;\\nfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\\nfloat l=log4(omegaS)-log4(omegaP)+log4(K);\\nfloat mipLevel=clamp(l,0.0,maxLevel);\\nvec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;\\n#ifdef GAMMA_INPUT\\nc=toLinearSpace(c);\\n#endif\\nresult+=c;\\n}\\n}\\nresult=result*NUM_SAMPLES_FLOAT_INVERSED;\\nreturn result;\\n}\\n#define inline\\nvec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)\\n{\\nvec3 n=normalize(inputN);\\nif (alphaG==0.) {\\nvec3 c=textureCube(inputTexture,n).rgb;\\n#ifdef GAMMA_INPUT\\nc=toLinearSpace(c);\\n#endif\\nreturn c;\\n} else {\\nvec3 result=vec3(0.);\\nvec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\\ntangent=normalize(cross(tangent,n));\\nvec3 bitangent=cross(n,tangent);\\nmat3 tbn=mat3(tangent,bitangent,n);\\nfloat maxLevel=filteringInfo.y;\\nfloat dim0=filteringInfo.x;\\nfloat omegaP=(4.*PI)/(6.*dim0*dim0);\\nfloat weight=0.;\\n#if defined(WEBGL2) || defined(WEBGPU)\\nfor(uint i=0u; i<NUM_SAMPLES; ++i)\\n#else\\nfor(int i=0; i<NUM_SAMPLES; ++i)\\n#endif\\n{\\nvec2 Xi=hammersley(i,NUM_SAMPLES);\\nvec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);\\nfloat NoV=1.;\\nfloat NoH=H.z;\\nfloat NoH2=H.z*H.z;\\nfloat NoL=2.*NoH2-1.;\\nvec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);\\nL=normalize(L);\\nif (NoL>0.) {\\nfloat pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);\\nfloat omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;\\nfloat l=log4(omegaS)-log4(omegaP)+log4(K);\\nfloat mipLevel=clamp(float(l),0.0,maxLevel);\\nweight+=NoL;\\nvec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;\\n#ifdef GAMMA_INPUT\\nc=toLinearSpace(c);\\n#endif\\nresult+=c*NoL;\\n}\\n}\\nresult=result/weight;\\nreturn result;\\n}\\n}\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var hdrFilteringFunctions = { name: name, shader: shader };\n//# sourceMappingURL=hdrFilteringFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"helperFunctions\";\nvar shader = \"const float PI=3.1415926535897932384626433832795;\\nconst float HALF_MIN=5.96046448e-08; \\nconst float LinearEncodePowerApprox=2.2;\\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\\nconst float Epsilon=0.0000001;\\n#define saturate(x) clamp(x,0.0,1.0)\\n#define absEps(x) abs(x)+Epsilon\\n#define maxEps(x) max(x,Epsilon)\\n#define saturateEps(x) clamp(x,Epsilon,1.0)\\nmat3 transposeMat3(mat3 inMatrix) {\\nvec3 i0=inMatrix[0];\\nvec3 i1=inMatrix[1];\\nvec3 i2=inMatrix[2];\\nmat3 outMatrix=mat3(\\nvec3(i0.x,i1.x,i2.x),\\nvec3(i0.y,i1.y,i2.y),\\nvec3(i0.z,i1.z,i2.z)\\n);\\nreturn outMatrix;\\n}\\nmat3 inverseMat3(mat3 inMatrix) {\\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\\nfloat b01=a22*a11-a12*a21;\\nfloat b11=-a22*a10+a12*a20;\\nfloat b21=a21*a10-a11*a20;\\nfloat det=a00*b01+a01*b11+a02*b21;\\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\\n}\\nfloat toLinearSpace(float color)\\n{\\nreturn pow(color,LinearEncodePowerApprox);\\n}\\nvec3 toLinearSpace(vec3 color)\\n{\\nreturn pow(color,vec3(LinearEncodePowerApprox));\\n}\\nvec4 toLinearSpace(vec4 color)\\n{\\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\\n}\\nvec3 toGammaSpace(vec3 color)\\n{\\nreturn pow(color,vec3(GammaEncodePowerApprox));\\n}\\nvec4 toGammaSpace(vec4 color)\\n{\\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\\n}\\nfloat toGammaSpace(float color)\\n{\\nreturn pow(color,GammaEncodePowerApprox);\\n}\\nfloat square(float value)\\n{\\nreturn value*value;\\n}\\nvec3 square(vec3 value)\\n{\\nreturn value*value;\\n}\\nfloat pow5(float value) {\\nfloat sq=value*value;\\nreturn sq*sq*value;\\n}\\nfloat getLuminance(vec3 color)\\n{\\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\\n}\\nfloat getRand(vec2 seed) {\\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\\n}\\nfloat dither(vec2 seed,float varianceAmount) {\\nfloat rand=getRand(seed);\\nfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\\nreturn dither;\\n}\\nconst float rgbdMaxRange=255.0;\\nvec4 toRGBD(vec3 color) {\\nfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\\nfloat D =max(rgbdMaxRange/maxRGB,1.);\\nD =clamp(floor(D)/255.0,0.,1.);\\nvec3 rgb=color.rgb*D;\\nrgb=toGammaSpace(rgb);\\nreturn vec4(clamp(rgb,0.,1.),D); \\n}\\nvec3 fromRGBD(vec4 rgbd) {\\nrgbd.rgb=toLinearSpace(rgbd.rgb);\\nreturn rgbd.rgb/rgbd.a;\\n}\\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\\nvec3 halfSize=cubeSize*0.5;\\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\\nvec3 intersectPositionWS=vertexPos+origVec*distance;\\nreturn intersectPositionWS-cubePos;\\n}\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var helperFunctions = { name: name, shader: shader };\n//# sourceMappingURL=helperFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"imageProcessingCompatibility\";\nvar shader = \"#ifdef IMAGEPROCESSINGPOSTPROCESS\\ngl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var imageProcessingCompatibility = { name: name, shader: shader };\n//# sourceMappingURL=imageProcessingCompatibility.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"imageProcessingDeclaration\";\nvar shader = \"#ifdef EXPOSURE\\nuniform float exposureLinear;\\n#endif\\n#ifdef CONTRAST\\nuniform float contrast;\\n#endif\\n#ifdef VIGNETTE\\nuniform vec2 vInverseScreenSize;\\nuniform vec4 vignetteSettings1;\\nuniform vec4 vignetteSettings2;\\n#endif\\n#ifdef COLORCURVES\\nuniform vec4 vCameraColorCurveNegative;\\nuniform vec4 vCameraColorCurveNeutral;\\nuniform vec4 vCameraColorCurvePositive;\\n#endif\\n#ifdef COLORGRADING\\n#ifdef COLORGRADING3D\\nuniform highp sampler3D txColorTransform;\\n#else\\nuniform sampler2D txColorTransform;\\n#endif\\nuniform vec4 colorTransformSettings;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var imageProcessingDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=imageProcessingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"imageProcessingFunctions\";\nvar shader = \"#if defined(COLORGRADING) && !defined(COLORGRADING3D)\\n/** \\n* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\\n* sampler3dSetting.x=textureOffset (0.5/textureSize).\\n* sampler3dSetting.y=textureSize.\\n*/\\n#define inline\\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\\n{\\nfloat sliceSize=2.0*sampler3dSetting.x; \\n#ifdef SAMPLER3DGREENDEPTH\\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\\n#else\\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\\n#endif\\nfloat sliceInteger=floor(sliceContinuous);\\nfloat sliceFraction=sliceContinuous-sliceInteger;\\n#ifdef SAMPLER3DGREENDEPTH\\nvec2 sliceUV=color.rb;\\n#else\\nvec2 sliceUV=color.rg;\\n#endif\\nsliceUV.x*=sliceSize;\\nsliceUV.x+=sliceInteger*sliceSize;\\nsliceUV=saturate(sliceUV);\\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\\nsliceUV.x+=sliceSize;\\nsliceUV=saturate(sliceUV);\\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\\n#ifdef SAMPLER3DBGRMAP\\ncolor.rgb=result.rgb;\\n#else\\ncolor.rgb=result.bgr;\\n#endif\\nreturn color;\\n}\\n#endif\\n#ifdef TONEMAPPING_ACES\\nconst mat3 ACESInputMat=mat3(\\nvec3(0.59719,0.07600,0.02840),\\nvec3(0.35458,0.90834,0.13383),\\nvec3(0.04823,0.01566,0.83777)\\n);\\nconst mat3 ACESOutputMat=mat3(\\nvec3( 1.60475,-0.10208,-0.00327),\\nvec3(-0.53108, 1.10813,-0.07276),\\nvec3(-0.07367,-0.00605, 1.07602)\\n);\\nvec3 RRTAndODTFit(vec3 v)\\n{\\nvec3 a=v*(v+0.0245786)-0.000090537;\\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\\nreturn a/b;\\n}\\nvec3 ACESFitted(vec3 color)\\n{\\ncolor=ACESInputMat*color;\\ncolor=RRTAndODTFit(color);\\ncolor=ACESOutputMat*color;\\ncolor=saturate(color);\\nreturn color;\\n}\\n#endif\\nvec4 applyImageProcessing(vec4 result) {\\n#ifdef EXPOSURE\\nresult.rgb*=exposureLinear;\\n#endif\\n#ifdef VIGNETTE\\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\\nviewportXY=viewportXY*2.0-1.0;\\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\\nvec3 vignetteColor=vignetteSettings2.rgb;\\n#ifdef VIGNETTEBLENDMODEMULTIPLY\\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\\nresult.rgb*=vignetteColorMultiplier;\\n#endif\\n#ifdef VIGNETTEBLENDMODEOPAQUE\\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\\n#endif\\n#endif\\n#ifdef TONEMAPPING\\n#ifdef TONEMAPPING_ACES\\nresult.rgb=ACESFitted(result.rgb);\\n#else\\nconst float tonemappingCalibration=1.590579;\\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\\n#endif\\n#endif\\nresult.rgb=toGammaSpace(result.rgb);\\nresult.rgb=saturate(result.rgb);\\n#ifdef CONTRAST\\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\\nif (contrast<1.0) {\\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\\n} else {\\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\\n}\\n#endif\\n#ifdef COLORGRADING\\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\\n#ifdef COLORGRADING3D\\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\\n#else\\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\\n#endif\\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\\n#endif\\n#ifdef COLORCURVES\\nfloat luma=getLuminance(result.rgb);\\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\\nresult.rgb*=colorCurve.rgb;\\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\\n#endif\\nreturn result;\\n}\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var imageProcessingFunctions = { name: name, shader: shader };\n//# sourceMappingURL=imageProcessingFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"importanceSampling\";\nvar shader = \"vec3 hemisphereCosSample(vec2 u) {\\nfloat phi=2.*PI*u.x;\\nfloat cosTheta2=1.-u.y;\\nfloat cosTheta=sqrt(cosTheta2);\\nfloat sinTheta=sqrt(1.-cosTheta2);\\nreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\\n}\\nvec3 hemisphereImportanceSampleDggx(vec2 u,float a) {\\nfloat phi=2.*PI*u.x;\\nfloat cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));\\nfloat cosTheta=sqrt(cosTheta2);\\nfloat sinTheta=sqrt(1.-cosTheta2);\\nreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\\n}\\nvec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { \\nfloat phi=2.*PI*u.x;\\nfloat sinTheta=pow(u.y,a/(2.*a+1.));\\nfloat cosTheta=sqrt(1.-sinTheta*sinTheta);\\nreturn vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);\\n}\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var importanceSampling = { name: name, shader: shader };\n//# sourceMappingURL=importanceSampling.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"instancesDeclaration\";\nvar shader = \"#ifdef INSTANCES\\nattribute vec4 world0;\\nattribute vec4 world1;\\nattribute vec4 world2;\\nattribute vec4 world3;\\n#ifdef INSTANCESCOLOR\\nattribute vec4 instanceColor;\\n#endif\\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\\nuniform mat4 world;\\n#endif\\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\\nattribute vec4 previousWorld0;\\nattribute vec4 previousWorld1;\\nattribute vec4 previousWorld2;\\nattribute vec4 previousWorld3;\\n#ifdef THIN_INSTANCES\\nuniform mat4 previousWorld;\\n#endif\\n#endif\\n#else\\n#if !defined(WORLD_UBO)\\nuniform mat4 world;\\n#endif\\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\\nuniform mat4 previousWorld;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var instancesDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=instancesDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"instancesVertex\";\nvar shader = \"#ifdef INSTANCES\\nmat4 finalWorld=mat4(world0,world1,world2,world3);\\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\\n#endif\\n#ifdef THIN_INSTANCES\\nfinalWorld=world*finalWorld;\\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\\n#endif\\n#endif\\n#else\\nmat4 finalWorld=world;\\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\\nmat4 finalPreviousWorld=previousWorld;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var instancesVertex = { name: name, shader: shader };\n//# sourceMappingURL=instancesVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"kernelBlurVaryingDeclaration\";\nvar shader = \"varying vec2 sampleCoord{X};\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var kernelBlurVaryingDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=kernelBlurVaryingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"lightFragment\";\nvar shader = \"#ifdef LIGHT{X}\\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\\n#else\\n#ifdef PBR\\n#ifdef SPOTLIGHT{X}\\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#elif defined(POINTLIGHT{X})\\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#elif defined(HEMILIGHT{X})\\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#elif defined(DIRLIGHT{X})\\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\\n#endif\\npreInfo.NdotV=NdotV;\\n#ifdef SPOTLIGHT{X}\\n#ifdef LIGHT_FALLOFF_GLTF{X}\\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\\npreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\\npreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\\npreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\\n#else\\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\\npreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\\n#endif\\n#elif defined(POINTLIGHT{X})\\n#ifdef LIGHT_FALLOFF_GLTF{X}\\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\\n#else\\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\\n#endif\\n#else\\npreInfo.attenuation=1.0;\\n#endif\\n#ifdef HEMILIGHT{X}\\npreInfo.roughness=roughness;\\n#else\\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\\n#endif\\n#ifdef IRIDESCENCE\\npreInfo.iridescenceIntensity=iridescenceIntensity;\\n#endif\\n#ifdef HEMILIGHT{X}\\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\\n#elif defined(SS_TRANSLUCENCY)\\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\\n#else\\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\\n#endif\\n#ifdef SPECULARTERM\\n#ifdef ANISOTROPIC\\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\\n#else\\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\\n#endif\\n#endif\\n#ifdef SHEEN\\n#ifdef SHEEN_LINKWITHALBEDO\\npreInfo.roughness=sheenOut.sheenIntensity;\\n#else\\n#ifdef HEMILIGHT{X}\\npreInfo.roughness=sheenOut.sheenRoughness;\\n#else\\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\\n#endif\\n#endif\\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\\n#endif\\n#ifdef CLEARCOAT\\n#ifdef HEMILIGHT{X}\\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\\n#else\\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\\n#endif\\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\\n#ifdef CLEARCOAT_TINT\\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\\ninfo.diffuse*=absorption;\\n#ifdef SPECULARTERM\\ninfo.specular*=absorption;\\n#endif\\n#endif\\ninfo.diffuse*=info.clearCoat.w;\\n#ifdef SPECULARTERM\\ninfo.specular*=info.clearCoat.w;\\n#endif\\n#ifdef SHEEN\\ninfo.sheen*=info.clearCoat.w;\\n#endif\\n#endif\\n#else\\n#ifdef SPOTLIGHT{X}\\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\\n#elif defined(HEMILIGHT{X})\\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\\n#endif\\n#endif\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\\n#endif\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \\n{\\n#ifdef SHADOWCSM_RIGHTHANDED{X}\\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\\n#else\\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\\n#endif\\nif (diff{X}>=0.) {\\nindex{X}=i;\\nbreak;\\n}\\n}\\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\\nif (index{X}>=0)\\n#endif\\n{\\n#if defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#else\\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#endif\\n#else\\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#ifdef SHADOWCSMDEBUG{X}\\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\\n#endif\\n#ifndef SHADOWCSMNOBLEND{X}\\nfloat frustumLength=frustumLengths{X}[index{X}];\\nfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\\nif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\\n{\\nindex{X}+=1;\\nfloat nextShadow=0.;\\n#if defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#else\\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\\n#endif\\n#else\\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\nshadow=mix(nextShadow,shadow,diffRatio);\\n#ifdef SHADOWCSMDEBUG{X}\\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\\n#endif\\n}\\n#endif\\n}\\n#elif defined(SHADOWCLOSEESM{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWESM{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPOISSON{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#else\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#endif\\n#ifdef SHADOWONLY\\n#ifndef SHADOWINUSE\\n#define SHADOWINUSE\\n#endif\\nglobalShadow+=shadow;\\nshadowLightCount+=1.0;\\n#endif\\n#else\\nshadow=1.;\\n#endif\\n#ifndef SHADOWONLY\\n#ifdef CUSTOMUSERLIGHTING\\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\\n#ifdef SPECULARTERM\\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\\n#endif\\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\\ndiffuseBase+=lightmapColor.rgb*shadow;\\n#ifdef SPECULARTERM\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\\n#endif\\n#endif\\n#ifdef CLEARCOAT\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\\n#endif\\n#endif\\n#ifdef SHEEN\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nsheenBase+=info.sheen.rgb*shadow;\\n#endif\\n#endif\\n#else\\n#ifdef SHADOWCSMDEBUG{X}\\ndiffuseBase+=info.diffuse*shadowDebug{X};\\n#else \\ndiffuseBase+=info.diffuse*shadow;\\n#endif\\n#ifdef SPECULARTERM\\nspecularBase+=info.specular*shadow;\\n#endif\\n#ifdef CLEARCOAT\\nclearCoatBase+=info.clearCoat.rgb*shadow;\\n#endif\\n#ifdef SHEEN\\nsheenBase+=info.sheen.rgb*shadow;\\n#endif\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightFragment = { name: name, shader: shader };\n//# sourceMappingURL=lightFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"lightFragmentDeclaration\";\nvar shader = \"#ifdef LIGHT{X}\\nuniform vec4 vLightData{X};\\nuniform vec4 vLightDiffuse{X};\\n#ifdef SPECULARTERM\\nuniform vec4 vLightSpecular{X};\\n#else\\nvec4 vLightSpecular{X}=vec4(0.);\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float cascadeBlendFactor{X};\\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromCamera{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\nuniform highp sampler2DArray depthSampler{X};\\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float penumbraDarkness{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\n#else\\nuniform highp sampler2DArray shadowSampler{X};\\n#endif\\n#ifdef SHADOWCSMDEBUG{X}\\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\\n(\\nvec3 ( 1.5,0.0,0.0 ),\\nvec3 ( 0.0,1.5,0.0 ),\\nvec3 ( 0.0,0.0,5.5 ),\\nvec3 ( 1.5,0.0,5.5 ),\\nvec3 ( 1.5,1.5,0.0 ),\\nvec3 ( 1.0,1.0,1.0 ),\\nvec3 ( 0.0,1.0,5.5 ),\\nvec3 ( 0.5,3.5,0.75 )\\n);\\nvec3 shadowDebug{X};\\n#endif\\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\\nint index{X}=-1;\\n#else\\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\\n#endif\\nfloat diff{X}=0.;\\n#elif defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X};\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\nuniform highp sampler2D depthSampler{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\n#else\\nuniform sampler2D shadowSampler{X};\\n#endif\\nuniform mat4 lightMatrix{X};\\n#endif\\nuniform vec4 shadowsInfo{X};\\nuniform vec2 depthValues{X};\\n#endif\\n#ifdef SPOTLIGHT{X}\\nuniform vec4 vLightDirection{X};\\nuniform vec4 vLightFalloff{X};\\n#elif defined(POINTLIGHT{X})\\nuniform vec4 vLightFalloff{X};\\n#elif defined(HEMILIGHT{X})\\nuniform vec3 vLightGround{X};\\n#endif\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\nuniform mat4 textureProjectionMatrix{X};\\nuniform sampler2D projectionLightSampler{X};\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=lightFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"lightUboDeclaration\";\nvar shader = \"#ifdef LIGHT{X}\\nuniform Light{X}\\n{\\nvec4 vLightData;\\nvec4 vLightDiffuse;\\nvec4 vLightSpecular;\\n#ifdef SPOTLIGHT{X}\\nvec4 vLightDirection;\\nvec4 vLightFalloff;\\n#elif defined(POINTLIGHT{X})\\nvec4 vLightFalloff;\\n#elif defined(HEMILIGHT{X})\\nvec3 vLightGround;\\n#endif\\nvec4 shadowsInfo;\\nvec2 depthValues;\\n} light{X};\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\nuniform mat4 textureProjectionMatrix{X};\\nuniform sampler2D projectionLightSampler{X};\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float cascadeBlendFactor{X};\\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromCamera{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\nuniform highp sampler2DArray depthSampler{X};\\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\\nuniform float penumbraDarkness{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DArrayShadow shadowSampler{X};\\n#else\\nuniform highp sampler2DArray shadowSampler{X};\\n#endif\\n#ifdef SHADOWCSMDEBUG{X}\\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\\n(\\nvec3 ( 1.5,0.0,0.0 ),\\nvec3 ( 0.0,1.5,0.0 ),\\nvec3 ( 0.0,0.0,5.5 ),\\nvec3 ( 1.5,0.0,5.5 ),\\nvec3 ( 1.5,1.5,0.0 ),\\nvec3 ( 1.0,1.0,1.0 ),\\nvec3 ( 0.0,1.0,5.5 ),\\nvec3 ( 0.5,3.5,0.75 )\\n);\\nvec3 shadowDebug{X};\\n#endif\\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\\nint index{X}=-1;\\n#else\\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\\n#endif\\nfloat diff{X}=0.;\\n#elif defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X}; \\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\nuniform highp sampler2D depthSampler{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\n#else\\nuniform sampler2D shadowSampler{X};\\n#endif\\nuniform mat4 lightMatrix{X};\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=lightUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"lightVxFragmentDeclaration\";\nvar shader = \"#ifdef LIGHT{X}\\nuniform vec4 vLightData{X};\\nuniform vec4 vLightDiffuse{X};\\n#ifdef SPECULARTERM\\nuniform vec4 vLightSpecular{X};\\n#else\\nvec4 vLightSpecular{X}=vec4(0.);\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromCamera{X};\\n#elif defined(SHADOWCUBE{X})\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\nuniform mat4 lightMatrix{X};\\n#endif\\nuniform vec4 shadowsInfo{X};\\nuniform vec2 depthValues{X};\\n#endif\\n#ifdef SPOTLIGHT{X}\\nuniform vec4 vLightDirection{X};\\nuniform vec4 vLightFalloff{X};\\n#elif defined(POINTLIGHT{X})\\nuniform vec4 vLightFalloff{X};\\n#elif defined(HEMILIGHT{X})\\nuniform vec3 vLightGround{X};\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightVxFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=lightVxFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"lightVxUboDeclaration\";\nvar shader = \"#ifdef LIGHT{X}\\nuniform Light{X}\\n{\\nvec4 vLightData;\\nvec4 vLightDiffuse;\\nvec4 vLightSpecular;\\n#ifdef SPOTLIGHT{X}\\nvec4 vLightDirection;\\nvec4 vLightFalloff;\\n#elif defined(POINTLIGHT{X})\\nvec4 vLightFalloff;\\n#elif defined(HEMILIGHT{X})\\nvec3 vLightGround;\\n#endif\\nvec4 shadowsInfo;\\nvec2 depthValues;\\n} light{X};\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCSM{X}\\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\\nvarying vec4 vPositionFromCamera{X};\\n#elif defined(SHADOWCUBE{X})\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\nuniform mat4 lightMatrix{X};\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightVxUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=lightVxUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"lightsFragmentFunctions\";\nvar shader = \"struct lightingInfo\\n{\\nvec3 diffuse;\\n#ifdef SPECULARTERM\\nvec3 specular;\\n#endif\\n#ifdef NDOTL\\nfloat ndl;\\n#endif\\n};\\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 lightVectorW;\\nfloat attenuation=1.0;\\nif (lightData.w==0.)\\n{\\nvec3 direction=lightData.xyz-vPositionW;\\nattenuation=max(0.,1.0-length(direction)/range);\\nlightVectorW=normalize(direction);\\n}\\nelse\\n{\\nlightVectorW=normalize(-lightData.xyz);\\n}\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 direction=lightData.xyz-vPositionW;\\nvec3 lightVectorW=normalize(direction);\\nfloat attenuation=max(0.,1.0-length(direction)/range);\\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\\nif (cosAngle>=lightDirection.w)\\n{\\ncosAngle=max(0.,pow(cosAngle,lightData.w));\\nattenuation*=cosAngle;\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nresult.diffuse=vec3(0.);\\n#ifdef SPECULARTERM\\nresult.specular=vec3(0.);\\n#endif\\n#ifdef NDOTL\\nresult.ndl=0.;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\\nlightingInfo result;\\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\\n#ifdef SPECULARTERM\\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor;\\n#endif\\nreturn result;\\n}\\n#define inline\\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\\nstrq/=strq.w;\\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\\nreturn textureColor;\\n}\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var lightsFragmentFunctions = { name: name, shader: shader };\n//# sourceMappingURL=lightsFragmentFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"logDepthDeclaration\";\nvar shader = \"#ifdef LOGARITHMICDEPTH\\nuniform float logarithmicDepthConstant;\\nvarying float vFragmentDepth;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var logDepthDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=logDepthDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"logDepthFragment\";\nvar shader = \"#ifdef LOGARITHMICDEPTH\\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var logDepthFragment = { name: name, shader: shader };\n//# sourceMappingURL=logDepthFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"logDepthVertex\";\nvar shader = \"#ifdef LOGARITHMICDEPTH\\nvFragmentDepth=1.0+gl_Position.w;\\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var logDepthVertex = { name: name, shader: shader };\n//# sourceMappingURL=logDepthVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"mainUVVaryingDeclaration\";\nvar shader = \"#ifdef MAINUV{X}\\nvarying vec2 vMainUV{X};\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var mainUVVaryingDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=mainUVVaryingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"meshUboDeclaration\";\nvar shader = \"#ifdef WEBGL2\\nuniform mat4 world;\\nuniform float visibility;\\n#else\\nlayout(std140,column_major) uniform;\\nuniform Mesh\\n{\\nmat4 world;\\nfloat visibility;\\n};\\n#endif\\n#define WORLD_UBO\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var meshUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=meshUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"morphTargetsVertex\";\nvar shader = \"#ifdef MORPHTARGETS\\n#ifdef MORPHTARGETS_TEXTURE \\nvertexID=float(gl_VertexID)*morphTargetTextureInfo.x;\\npositionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];\\nvertexID+=1.0;\\n#ifdef MORPHTARGETS_NORMAL\\nnormalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];\\nvertexID+=1.0;\\n#endif\\n#ifdef MORPHTARGETS_UV\\nuvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];\\nvertexID+=1.0;\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\ntangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];\\n#endif\\n#else\\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\\n#ifdef MORPHTARGETS_NORMAL\\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_UV\\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var morphTargetsVertex = { name: name, shader: shader };\n//# sourceMappingURL=morphTargetsVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"morphTargetsVertexDeclaration\";\nvar shader = \"#ifdef MORPHTARGETS\\n#ifndef MORPHTARGETS_TEXTURE\\nattribute vec3 position{X};\\n#ifdef MORPHTARGETS_NORMAL\\nattribute vec3 normal{X};\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\nattribute vec3 tangent{X};\\n#endif\\n#ifdef MORPHTARGETS_UV\\nattribute vec2 uv_{X};\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var morphTargetsVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=morphTargetsVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"morphTargetsVertexGlobal\";\nvar shader = \"#ifdef MORPHTARGETS\\n#ifdef MORPHTARGETS_TEXTURE\\nfloat vertexID;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var morphTargetsVertexGlobal = { name: name, shader: shader };\n//# sourceMappingURL=morphTargetsVertexGlobal.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"morphTargetsVertexGlobalDeclaration\";\nvar shader = \"#ifdef MORPHTARGETS\\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\\n#ifdef MORPHTARGETS_TEXTURE \\nprecision mediump sampler2DArray; \\nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];\\nuniform vec3 morphTargetTextureInfo;\\nuniform sampler2DArray morphTargets;\\nvec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\\n{ \\nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);\\nfloat x=vertexIndex-y*morphTargetTextureInfo.y;\\nvec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);\\nreturn texture(morphTargets,textureUV).xyz;\\n}\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var morphTargetsVertexGlobalDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=morphTargetsVertexGlobalDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"oitDeclaration\";\nvar shader = \"#ifdef ORDER_INDEPENDENT_TRANSPARENCY\\n#extension GL_EXT_draw_buffers : require\\nlayout(location=0) out vec2 depth; \\nlayout(location=1) out vec4 frontColor;\\nlayout(location=2) out vec4 backColor;\\n#define MAX_DEPTH 99999.0\\nhighp vec4 gl_FragColor;\\nuniform sampler2D oitDepthSampler;\\nuniform sampler2D oitFrontColorSampler;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var oitDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=oitDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"oitFragment\";\nvar shader = \"#ifdef ORDER_INDEPENDENT_TRANSPARENCY\\nfloat fragDepth=gl_FragCoord.z; \\n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\\nuint halfFloat=packHalf2x16(vec2(fragDepth));\\nvec2 full=unpackHalf2x16(halfFloat);\\nfragDepth=full.x;\\n#endif\\nivec2 fragCoord=ivec2(gl_FragCoord.xy);\\nvec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;\\nvec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);\\ndepth.rg=vec2(-MAX_DEPTH);\\nfrontColor=lastFrontColor;\\nbackColor=vec4(0.0);\\n#ifdef USE_REVERSE_DEPTHBUFFER\\nfloat furthestDepth=-lastDepth.x;\\nfloat nearestDepth=lastDepth.y;\\n#else\\nfloat nearestDepth=-lastDepth.x;\\nfloat furthestDepth=lastDepth.y;\\n#endif\\nfloat alphaMultiplier=1.0-lastFrontColor.a;\\n#ifdef USE_REVERSE_DEPTHBUFFER\\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\\n#else\\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\\n#endif\\nreturn;\\n}\\n#ifdef USE_REVERSE_DEPTHBUFFER\\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\\n#else\\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\\n#endif\\ndepth.rg=vec2(-fragDepth,fragDepth);\\nreturn;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var oitFragment = { name: name, shader: shader };\n//# sourceMappingURL=oitFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"packingFunctions\";\nvar shader = \"vec4 pack(float depth)\\n{\\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\\nvec4 res=fract(depth*bit_shift);\\nres-=res.xxyz*bit_mask;\\nreturn res;\\n}\\nfloat unpack(vec4 color)\\n{\\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\\nreturn dot(color,bit_shift);\\n}\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var packingFunctions = { name: name, shader: shader };\n//# sourceMappingURL=packingFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBRDFFunctions\";\nvar shader = \"#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\\n#ifdef MS_BRDF_ENERGY_CONSERVATION\\nvec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\\nreturn 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);\\n}\\n#endif\\n#ifdef ENVIRONMENTBRDF\\nvec3 getBRDFLookup(float NdotV,float perceptualRoughness) {\\nvec2 UV=vec2(NdotV,perceptualRoughness);\\nvec4 brdfLookup=texture2D(environmentBrdfSampler,UV);\\n#ifdef ENVIRONMENTBRDF_RGBD\\nbrdfLookup.rgb=fromRGBD(brdfLookup.rgba);\\n#endif\\nreturn brdfLookup.rgb;\\n}\\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {\\n#ifdef BRDF_V_HEIGHT_CORRELATED\\nvec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;\\n#else\\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;\\n#endif\\nreturn reflectance;\\n}\\nvec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {\\n#ifdef BRDF_V_HEIGHT_CORRELATED\\nvec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);\\n#else\\nvec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\\n#endif\\nreturn reflectance;\\n}\\n#endif\\n/* NOT USED\\n#if defined(SHEEN) && defined(SHEEN_SOFTER)\\nfloat getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)\\n{\\nfloat c=1.0-NdotV;\\nfloat c3=c*c*c;\\nreturn 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));\\n}\\n#endif\\n*/\\n#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)\\nvec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\\n{\\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));\\n}\\n#endif\\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\\n/**\\n* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.\\n* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table\\n*/\\nvec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {\\nvec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;\\nreturn sheenEnvironmentReflectance;\\n}\\n#endif\\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\\n{\\nreturn reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);\\n}\\nfloat fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)\\n{\\nreturn reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);\\n}\\n#ifdef CLEARCOAT\\nvec3 getR0RemappedForClearCoat(vec3 f0) {\\n#ifdef CLEARCOAT_DEFAULTIOR\\n#ifdef MOBILE\\nreturn saturate(f0*(f0*0.526868+0.529324)-0.0482256);\\n#else\\nreturn saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);\\n#endif\\n#else\\nvec3 s=sqrt(f0);\\nvec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);\\nreturn square(t);\\n#endif\\n}\\n#endif\\n#ifdef IRIDESCENCE\\nconst mat3 XYZ_TO_REC709=mat3(\\n3.2404542,-0.9692660, 0.0556434,\\n-1.5371385, 1.8760108,-0.2040259,\\n-0.4985314, 0.0415560, 1.0572252\\n);\\nvec3 getIORTfromAirToSurfaceR0(vec3 f0) {\\nvec3 sqrtF0=sqrt(f0);\\nreturn (1.+sqrtF0)/(1.-sqrtF0);\\n}\\nvec3 getR0fromIORs(vec3 iorT,float iorI) {\\nreturn square((iorT-vec3(iorI))/(iorT+vec3(iorI)));\\n}\\nfloat getR0fromIORs(float iorT,float iorI) {\\nreturn square((iorT-iorI)/(iorT+iorI));\\n}\\nvec3 evalSensitivity(float opd,vec3 shift) {\\nfloat phase=2.0*PI*opd*1.0e-9;\\nconst vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);\\nconst vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);\\nconst vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);\\nvec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);\\nxyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));\\nxyz/=1.0685e-7;\\nvec3 srgb=XYZ_TO_REC709*xyz;\\nreturn srgb;\\n}\\nvec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {\\nvec3 I=vec3(1.0);\\nfloat iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));\\nfloat sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));\\nfloat cosTheta2Sq=1.0-sinTheta2Sq;\\nif (cosTheta2Sq<0.0) {\\nreturn I;\\n}\\nfloat cosTheta2=sqrt(cosTheta2Sq);\\nfloat R0=getR0fromIORs(iridescenceIOR,outsideIOR);\\nfloat R12=fresnelSchlickGGX(cosTheta1,R0,1.);\\nfloat R21=R12;\\nfloat T121=1.0-R12;\\nfloat phi12=0.0;\\nif (iridescenceIOR<outsideIOR) phi12=PI;\\nfloat phi21=PI-phi12;\\nvec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); \\nvec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);\\nvec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));\\nvec3 phi23=vec3(0.0);\\nif (baseIOR[0]<iridescenceIOR) phi23[0]=PI;\\nif (baseIOR[1]<iridescenceIOR) phi23[1]=PI;\\nif (baseIOR[2]<iridescenceIOR) phi23[2]=PI;\\nfloat opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;\\nvec3 phi=vec3(phi21)+phi23;\\nvec3 R123=clamp(R12*R23,1e-5,0.9999);\\nvec3 r123=sqrt(R123);\\nvec3 Rs=square(T121)*R23/(vec3(1.0)-R123);\\nvec3 C0=R12+Rs;\\nI=C0;\\nvec3 Cm=Rs-T121;\\nfor (int m=1; m<=2; ++m)\\n{\\nCm*=r123;\\nvec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);\\nI+=Cm*Sm;\\n}\\nreturn max(I,vec3(0.0));\\n}\\n#endif\\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\\n{\\nfloat a2=square(alphaG);\\nfloat d=NdotH*NdotH*(a2-1.0)+1.0;\\nreturn a2/(PI*d*d);\\n}\\n#ifdef SHEEN\\nfloat normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)\\n{\\nfloat invR=1./alphaG;\\nfloat cos2h=NdotH*NdotH;\\nfloat sin2h=1.-cos2h;\\nreturn (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);\\n}\\n#endif\\n#ifdef ANISOTROPIC\\nfloat normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {\\nfloat a2=alphaTB.x*alphaTB.y;\\nvec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);\\nfloat v2=dot(v,v);\\nfloat w2=a2/v2;\\nreturn a2*w2*w2*RECIPROCAL_PI;\\n}\\n#endif\\n#ifdef BRDF_V_HEIGHT_CORRELATED\\nfloat smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {\\n#ifdef MOBILE\\nfloat GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);\\nfloat GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);\\nreturn 0.5/(GGXV+GGXL);\\n#else\\nfloat a2=alphaG*alphaG;\\nfloat GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);\\nfloat GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);\\nreturn 0.5/(GGXV+GGXL);\\n#endif\\n}\\n#else\\nfloat smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)\\n{\\n#ifdef MOBILE\\nreturn 1.0/(dot+alphaG+(1.0-alphaG)*dot ));\\n#else\\nfloat alphaSquared=alphaG*alphaG;\\nreturn 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));\\n#endif\\n}\\nfloat smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)\\n{\\nfloat visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);\\nreturn visibility;\\n}\\n#endif\\n#ifdef ANISOTROPIC\\nfloat smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {\\nfloat lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));\\nfloat lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));\\nfloat v=0.5/(lambdaV+lambdaL);\\nreturn v;\\n}\\n#endif\\n#ifdef CLEARCOAT\\nfloat visibility_Kelemen(float VdotH) {\\nreturn 0.25/(VdotH*VdotH); \\n}\\n#endif\\n#ifdef SHEEN\\nfloat visibility_Ashikhmin(float NdotL,float NdotV)\\n{\\nreturn 1./(4.*(NdotL+NdotV-NdotL*NdotV));\\n}\\n/* NOT USED\\n#ifdef SHEEN_SOFTER\\nfloat l(float x,float alphaG)\\n{\\nfloat oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);\\nfloat a=mix(21.5473,25.3245,oneMinusAlphaSq);\\nfloat b=mix(3.82987,3.32435,oneMinusAlphaSq);\\nfloat c=mix(0.19823,0.16801,oneMinusAlphaSq);\\nfloat d=mix(-1.97760,-1.27393,oneMinusAlphaSq);\\nfloat e=mix(-4.32054,-4.85967,oneMinusAlphaSq);\\nreturn a/(1.0+b*pow(x,c))+d*x+e;\\n}\\nfloat lambdaSheen(float cosTheta,float alphaG)\\n{\\nreturn abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));\\n}\\nfloat visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)\\n{\\nfloat G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));\\nreturn G/(4.0*NdotV*NdotL);\\n}\\n#endif\\n*/\\n#endif\\nfloat diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {\\nfloat diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));\\nfloat diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));\\nfloat diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;\\nfloat fresnel =\\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\\nreturn fresnel/PI;\\n}\\n#ifdef SS_TRANSLUCENCY\\nvec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {\\nvec3 S=1./maxEps(diffusionDistance);\\nvec3 temp=exp((-0.333333333*thickness)*S);\\nreturn tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);\\n}\\nfloat computeWrappedDiffuseNdotL(float NdotL,float w) {\\nfloat t=1.0+w;\\nfloat invt2=1.0/square(t);\\nreturn saturate((NdotL+w)*invt2);\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBRDFFunctions = { name: name, shader: shader };\n//# sourceMappingURL=pbrBRDFFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nimport \"./meshUboDeclaration.js\";\nvar name = \"pbrUboDeclaration\";\nvar shader = \"layout(std140,column_major) uniform;\\nuniform Material {\\nvec2 vAlbedoInfos;\\nvec4 vAmbientInfos;\\nvec2 vOpacityInfos;\\nvec2 vEmissiveInfos;\\nvec2 vLightmapInfos;\\nvec3 vReflectivityInfos;\\nvec2 vMicroSurfaceSamplerInfos;\\nvec2 vReflectionInfos;\\nvec2 vReflectionFilteringInfo;\\nvec3 vReflectionPosition;\\nvec3 vReflectionSize;\\nvec3 vBumpInfos;\\nmat4 albedoMatrix;\\nmat4 ambientMatrix;\\nmat4 opacityMatrix;\\nmat4 emissiveMatrix;\\nmat4 lightmapMatrix;\\nmat4 reflectivityMatrix;\\nmat4 microSurfaceSamplerMatrix;\\nmat4 bumpMatrix;\\nvec2 vTangentSpaceParams;\\nmat4 reflectionMatrix;\\nvec3 vReflectionColor;\\nvec4 vAlbedoColor;\\nvec4 vLightingIntensity;\\nvec3 vReflectionMicrosurfaceInfos;\\nfloat pointSize;\\nvec4 vReflectivityColor;\\nvec3 vEmissiveColor;\\nvec3 vAmbientColor;\\nvec2 vDebugMode;\\nvec4 vMetallicReflectanceFactors;\\nvec2 vMetallicReflectanceInfos;\\nmat4 metallicReflectanceMatrix;\\nvec2 vReflectanceInfos;\\nmat4 reflectanceMatrix;\\nvec3 vSphericalL00;\\nvec3 vSphericalL1_1;\\nvec3 vSphericalL10;\\nvec3 vSphericalL11;\\nvec3 vSphericalL2_2;\\nvec3 vSphericalL2_1;\\nvec3 vSphericalL20;\\nvec3 vSphericalL21;\\nvec3 vSphericalL22;\\nvec3 vSphericalX;\\nvec3 vSphericalY;\\nvec3 vSphericalZ;\\nvec3 vSphericalXX_ZZ;\\nvec3 vSphericalYY_ZZ;\\nvec3 vSphericalZZ;\\nvec3 vSphericalXY;\\nvec3 vSphericalYZ;\\nvec3 vSphericalZX;\\n#define ADDITIONAL_UBO_DECLARATION\\n};\\n#include<sceneUboDeclaration>\\n#include<meshUboDeclaration>\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=pbrUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"prePassDeclaration\";\nvar shader = \"#ifdef PREPASS\\n#extension GL_EXT_draw_buffers : require\\nlayout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;\\n#ifdef PREPASS_DEPTH\\nvarying highp vec3 vViewPos;\\n#endif\\n#ifdef PREPASS_VELOCITY\\nvarying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var prePassDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=prePassDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"prePassVertex\";\nvar shader = \"#ifdef PREPASS_DEPTH\\nvViewPos=(view*worldPos).rgb;\\n#endif\\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\\nvCurrentPosition=viewProjection*worldPos;\\n#if NUM_BONE_INFLUENCERS>0\\nmat4 previousInfluence;\\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>2\\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>3\\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif\\n#if NUM_BONE_INFLUENCERS>4\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif \\n#if NUM_BONE_INFLUENCERS>5\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>6\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>7\\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif\\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\\n#else\\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var prePassVertex = { name: name, shader: shader };\n//# sourceMappingURL=prePassVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"prePassVertexDeclaration\";\nvar shader = \"#ifdef PREPASS\\n#ifdef PREPASS_DEPTH\\nvarying vec3 vViewPos;\\n#endif\\n#ifdef PREPASS_VELOCITY\\nuniform mat4 previousViewProjection;\\nvarying vec4 vCurrentPosition;\\nvarying vec4 vPreviousPosition;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var prePassVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=prePassVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"reflectionFunction\";\nvar shader = \"vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\\n{\\nfloat lon=atan(direction.z,direction.x);\\nfloat lat=acos(direction.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y;\\nreturn vec3(s,t,0); \\n}\\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\\n{\\nfloat lon=atan(direction.z,direction.x);\\nfloat lat=acos(direction.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y;\\nreturn vec3(1.0-s,t,0); \\n}\\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\\n{\\nvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\\nr=vec3(reflectionMatrix*vec4(r,0));\\nfloat lon=atan(r.z,r.x);\\nfloat lat=acos(r.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y;\\nreturn vec3(s,t,0);\\n}\\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\\n{\\nvec3 viewDir=normalize(vec3(view*worldPos));\\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\\nvec3 r=reflect(viewDir,viewNormal);\\nr=vec3(reflectionMatrix*vec4(r,0));\\nr.z=r.z-1.0;\\nfloat m=2.0*length(r);\\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\\n}\\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\\n{\\nvec3 viewDir=worldPos.xyz-eyePosition;\\nvec3 coords=normalize(reflect(viewDir,worldNormal));\\nreturn vec3(reflectionMatrix*vec4(coords,1));\\n}\\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\\n{\\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\\nvec3 coords=reflect(viewDir,worldNormal);\\ncoords=vec3(reflectionMatrix*vec4(coords,0));\\n#ifdef INVERTCUBICMAP\\ncoords.y*=-1.0;\\n#endif\\nreturn coords;\\n}\\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\\n{\\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\\nvec3 coords=reflect(viewDir,worldNormal);\\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\\ncoords=vec3(reflectionMatrix*vec4(coords,0));\\n#ifdef INVERTCUBICMAP\\ncoords.y*=-1.0;\\n#endif\\nreturn coords;\\n}\\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\\n{\\nreturn vec3(reflectionMatrix*(view*worldPos));\\n}\\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\\n{\\nreturn vec3(reflectionMatrix*vec4(positionW,1.));\\n}\\n#ifdef REFLECTION\\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\\n{\\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\\nvec3 direction=normalize(vDirectionW);\\nreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\\n#endif\\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\\nvec3 direction=normalize(vDirectionW);\\nreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\\n#endif\\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_SPHERICAL\\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_PLANAR\\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_CUBIC\\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\\n#else\\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_PROJECTION\\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\\n#endif\\n#ifdef REFLECTIONMAP_EXPLICIT\\nreturn vec3(0,0,0);\\n#endif\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var reflectionFunction = { name: name, shader: shader };\n//# sourceMappingURL=reflectionFunction.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"samplerFragmentDeclaration\";\nvar shader = \"#ifdef _DEFINENAME_\\n#if _DEFINENAME_DIRECTUV==1\\n#define v_VARYINGNAME_UV vMainUV1\\n#elif _DEFINENAME_DIRECTUV==2\\n#define v_VARYINGNAME_UV vMainUV2\\n#elif _DEFINENAME_DIRECTUV==3\\n#define v_VARYINGNAME_UV vMainUV3\\n#elif _DEFINENAME_DIRECTUV==4\\n#define v_VARYINGNAME_UV vMainUV4\\n#elif _DEFINENAME_DIRECTUV==5\\n#define v_VARYINGNAME_UV vMainUV5\\n#elif _DEFINENAME_DIRECTUV==6\\n#define v_VARYINGNAME_UV vMainUV6\\n#else\\nvarying vec2 v_VARYINGNAME_UV;\\n#endif\\nuniform sampler2D _SAMPLERNAME_Sampler;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var samplerFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=samplerFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"samplerVertexDeclaration\";\nvar shader = \"#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\\nvarying vec2 v_VARYINGNAME_UV;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var samplerVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=samplerVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"samplerVertexImplementation\";\nvar shader = \"#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\\nif (v_INFONAME_==0.)\\n{\\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));\\n}\\n#ifdef UV2\\nelse if (v_INFONAME_==1.)\\n{\\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#ifdef UV3\\nelse if (v_INFONAME_==2.)\\n{\\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));\\n}\\n#endif\\n#ifdef UV4\\nelse if (v_INFONAME_==3.)\\n{\\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));\\n}\\n#endif\\n#ifdef UV5\\nelse if (v_INFONAME_==4.)\\n{\\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));\\n}\\n#endif\\n#ifdef UV6\\nelse if (v_INFONAME_==5.)\\n{\\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));\\n}\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var samplerVertexImplementation = { name: name, shader: shader };\n//# sourceMappingURL=samplerVertexImplementation.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"sceneUboDeclaration\";\nvar shader = \"layout(std140,column_major) uniform;\\nuniform Scene {\\nmat4 viewProjection;\\n#ifdef MULTIVIEW\\nmat4 viewProjectionR;\\n#endif \\nmat4 view;\\nmat4 projection;\\nvec4 vEyePosition;\\n};\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var sceneUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=sceneUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"shadowMapFragmentSoftTransparentShadow\";\nvar shader = \"#if SM_SOFTTRANSPARENTSHADOW==1\\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapFragmentSoftTransparentShadow = { name: name, shader: shader };\n//# sourceMappingURL=shadowMapFragmentSoftTransparentShadow.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"shadowsFragmentFunctions\";\nvar shader = \"#ifdef SHADOWS\\n#ifndef SHADOWFLOAT\\nfloat unpack(vec4 color)\\n{\\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\\nreturn dot(color,bit_shift);\\n}\\n#endif\\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\\n{\\nfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\\nreturn mix(value,1.0,mask);\\n}\\n#define inline\\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nreturn depth>shadow ? darkness : 1.0;\\n}\\n#define inline\\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\nfloat visibility=1.;\\nvec3 poissonDisk[4];\\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\\n#ifndef SHADOWFLOAT\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\\n#else\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\\n#endif\\nreturn min(1.0,visibility+darkness);\\n}\\n#define inline\\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); \\nreturn esm;\\n}\\n#define inline\\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\nreturn esm;\\n}\\n#if defined(WEBGL2) || defined(WEBGPU)\\n#define inline\\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nvec3 uvLayer=vec3(uv.x,uv.y,layer);\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\\n#else\\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\\n#endif\\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\\n}\\n#endif\\n#define inline\\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadow=texture2D(shadowSampler,uv).x;\\n#endif\\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\\n}\\n}\\n#define inline\\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\nfloat visibility=1.;\\nvec2 poissonDisk[4];\\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\\npoissonDisk[3]=vec2(0.34495938,0.29387760);\\n#ifndef SHADOWFLOAT\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\\n#else\\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\n#endif\\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#define inline\\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#define inline\\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0); \\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#ifdef IS_NDC_HALF_ZRANGE\\n#define ZINCLIP clipSpace.z\\n#else\\n#define ZINCLIP uvDepth.z\\n#endif\\n#if defined(WEBGL2) || defined(WEBGPU)\\n#define GREATEST_LESS_THAN_ONE 0.99999994\\n#define inline\\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\\nfloat shadow=texture2D(shadowSampler,uvDepthLayer);\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \\nuv+=0.5; \\nvec2 st=fract(uv); \\nvec2 base_uv=floor(uv)-0.5; \\nbase_uv*=shadowMapSizeAndInverse.y; \\nvec2 uvw0=3.-2.*st;\\nvec2 uvw1=1.+2.*st;\\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\\nshadow=shadow/16.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \\nuv+=0.5; \\nvec2 st=fract(uv); \\nvec2 base_uv=floor(uv)-0.5; \\nbase_uv*=shadowMapSizeAndInverse.y; \\nvec2 uvw0=4.-3.*st;\\nvec2 uvw1=vec2(7.);\\nvec2 uvw2=1.+3.*st;\\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\\nshadow=shadow/144.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n#define inline\\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=ZINCLIP;\\nfloat shadow=texture2D(shadowSampler,uvDepth);\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#define inline\\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=ZINCLIP;\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \\nuv+=0.5; \\nvec2 st=fract(uv); \\nvec2 base_uv=floor(uv)-0.5; \\nbase_uv*=shadowMapSizeAndInverse.y; \\nvec2 uvw0=3.-2.*st;\\nvec2 uvw1=1.+2.*st;\\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\\nshadow=shadow/16.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#define inline\\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=ZINCLIP;\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \\nuv+=0.5; \\nvec2 st=fract(uv); \\nvec2 base_uv=floor(uv)-0.5; \\nbase_uv*=shadowMapSizeAndInverse.y; \\nvec2 uvw0=4.-3.*st;\\nvec2 uvw1=vec2(7.);\\nvec2 uvw2=1.+3.*st;\\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));\\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));\\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));\\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));\\nshadow=shadow/144.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\nconst vec3 PoissonSamplers32[64]=vec3[64](\\nvec3(0.06407013,0.05409927,0.),\\nvec3(0.7366577,0.5789394,0.),\\nvec3(-0.6270542,-0.5320278,0.),\\nvec3(-0.4096107,0.8411095,0.),\\nvec3(0.6849564,-0.4990818,0.),\\nvec3(-0.874181,-0.04579735,0.),\\nvec3(0.9989998,0.0009880066,0.),\\nvec3(-0.004920578,-0.9151649,0.),\\nvec3(0.1805763,0.9747483,0.),\\nvec3(-0.2138451,0.2635818,0.),\\nvec3(0.109845,0.3884785,0.),\\nvec3(0.06876755,-0.3581074,0.),\\nvec3(0.374073,-0.7661266,0.),\\nvec3(0.3079132,-0.1216763,0.),\\nvec3(-0.3794335,-0.8271583,0.),\\nvec3(-0.203878,-0.07715034,0.),\\nvec3(0.5912697,0.1469799,0.),\\nvec3(-0.88069,0.3031784,0.),\\nvec3(0.5040108,0.8283722,0.),\\nvec3(-0.5844124,0.5494877,0.),\\nvec3(0.6017799,-0.1726654,0.),\\nvec3(-0.5554981,0.1559997,0.),\\nvec3(-0.3016369,-0.3900928,0.),\\nvec3(-0.5550632,-0.1723762,0.),\\nvec3(0.925029,0.2995041,0.),\\nvec3(-0.2473137,0.5538505,0.),\\nvec3(0.9183037,-0.2862392,0.),\\nvec3(0.2469421,0.6718712,0.),\\nvec3(0.3916397,-0.4328209,0.),\\nvec3(-0.03576927,-0.6220032,0.),\\nvec3(-0.04661255,0.7995201,0.),\\nvec3(0.4402924,0.3640312,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.)\\n);\\nconst vec3 PoissonSamplers64[64]=vec3[64](\\nvec3(-0.613392,0.617481,0.),\\nvec3(0.170019,-0.040254,0.),\\nvec3(-0.299417,0.791925,0.),\\nvec3(0.645680,0.493210,0.),\\nvec3(-0.651784,0.717887,0.),\\nvec3(0.421003,0.027070,0.),\\nvec3(-0.817194,-0.271096,0.),\\nvec3(-0.705374,-0.668203,0.),\\nvec3(0.977050,-0.108615,0.),\\nvec3(0.063326,0.142369,0.),\\nvec3(0.203528,0.214331,0.),\\nvec3(-0.667531,0.326090,0.),\\nvec3(-0.098422,-0.295755,0.),\\nvec3(-0.885922,0.215369,0.),\\nvec3(0.566637,0.605213,0.),\\nvec3(0.039766,-0.396100,0.),\\nvec3(0.751946,0.453352,0.),\\nvec3(0.078707,-0.715323,0.),\\nvec3(-0.075838,-0.529344,0.),\\nvec3(0.724479,-0.580798,0.),\\nvec3(0.222999,-0.215125,0.),\\nvec3(-0.467574,-0.405438,0.),\\nvec3(-0.248268,-0.814753,0.),\\nvec3(0.354411,-0.887570,0.),\\nvec3(0.175817,0.382366,0.),\\nvec3(0.487472,-0.063082,0.),\\nvec3(-0.084078,0.898312,0.),\\nvec3(0.488876,-0.783441,0.),\\nvec3(0.470016,0.217933,0.),\\nvec3(-0.696890,-0.549791,0.),\\nvec3(-0.149693,0.605762,0.),\\nvec3(0.034211,0.979980,0.),\\nvec3(0.503098,-0.308878,0.),\\nvec3(-0.016205,-0.872921,0.),\\nvec3(0.385784,-0.393902,0.),\\nvec3(-0.146886,-0.859249,0.),\\nvec3(0.643361,0.164098,0.),\\nvec3(0.634388,-0.049471,0.),\\nvec3(-0.688894,0.007843,0.),\\nvec3(0.464034,-0.188818,0.),\\nvec3(-0.440840,0.137486,0.),\\nvec3(0.364483,0.511704,0.),\\nvec3(0.034028,0.325968,0.),\\nvec3(0.099094,-0.308023,0.),\\nvec3(0.693960,-0.366253,0.),\\nvec3(0.678884,-0.204688,0.),\\nvec3(0.001801,0.780328,0.),\\nvec3(0.145177,-0.898984,0.),\\nvec3(0.062655,-0.611866,0.),\\nvec3(0.315226,-0.604297,0.),\\nvec3(-0.780145,0.486251,0.),\\nvec3(-0.371868,0.882138,0.),\\nvec3(0.200476,0.494430,0.),\\nvec3(-0.494552,-0.711051,0.),\\nvec3(0.612476,0.705252,0.),\\nvec3(-0.578845,-0.768792,0.),\\nvec3(-0.772454,-0.090976,0.),\\nvec3(0.504440,0.372295,0.),\\nvec3(0.155736,0.065157,0.),\\nvec3(0.391522,0.849605,0.),\\nvec3(-0.620106,-0.328104,0.),\\nvec3(0.789239,-0.419965,0.),\\nvec3(-0.545396,0.538133,0.),\\nvec3(-0.178564,-0.596057,0.)\\n);\\n#define inline\\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\\nfloat blockerDepth=0.0;\\nfloat sumBlockerDepth=0.0;\\nfloat numBlocker=0.0;\\nfor (int i=0; i<searchTapCount; i ++) {\\nblockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\\nif (blockerDepth<depthMetric) {\\nsumBlockerDepth+=blockerDepth;\\nnumBlocker++;\\n}\\n}\\nif (numBlocker<1.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\\nfloat AAOffset=shadowMapSizeInverse*10.;\\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\\nvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\\nfloat random=getRand(vPositionFromLight.xy);\\nfloat rotationAngle=random*3.1415926;\\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\\nfloat shadow=0.;\\nfor (int i=0; i<pcfTapCount; i++) {\\nvec4 offset=vec4(poissonSamplers[i],0.);\\noffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\\nshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\\n}\\nshadow/=float(pcfTapCount);\\nshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n#define inline\\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nuvDepth.z=ZINCLIP;\\nfloat blockerDepth=0.0;\\nfloat sumBlockerDepth=0.0;\\nfloat numBlocker=0.0;\\nfor (int i=0; i<searchTapCount; i ++) {\\nblockerDepth=texture2D(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;\\nif (blockerDepth<depthMetric) {\\nsumBlockerDepth+=blockerDepth;\\nnumBlocker++;\\n}\\n}\\nif (numBlocker<1.0) {\\nreturn 1.0;\\n}\\nelse\\n{\\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\\nfloat AAOffset=shadowMapSizeInverse*10.;\\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\\nfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\\nfloat random=getRand(vPositionFromLight.xy);\\nfloat rotationAngle=random*3.1415926;\\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\\nfloat shadow=0.;\\nfor (int i=0; i<pcfTapCount; i++) {\\nvec3 offset=poissonSamplers[i];\\noffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\\nshadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);\\n}\\nshadow/=float(pcfTapCount);\\nshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n}\\n}\\n#define inline\\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\\n}\\n#define inline\\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\\n}\\n#define inline\\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\\n}\\n#define inline\\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\\n{\\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\\n}\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowsFragmentFunctions = { name: name, shader: shader };\n//# sourceMappingURL=shadowsFragmentFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"shadowsVertex\";\nvar shader = \"#ifdef SHADOWS\\n#if defined(SHADOWCSM{X})\\nvPositionFromCamera{X}=view*worldPos;\\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {\\nvPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\\n#ifdef USE_REVERSE_DEPTHBUFFER\\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\\n#else\\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\\n#endif\\n}\\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\\n#ifdef USE_REVERSE_DEPTHBUFFER\\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\\n#else\\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowsVertex = { name: name, shader: shader };\n//# sourceMappingURL=shadowsVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"subSurfaceScatteringFunctions\";\nvar shader = \"bool testLightingForSSS(float diffusionProfile)\\n{\\nreturn diffusionProfile<1.;\\n}\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var subSurfaceScatteringFunctions = { name: name, shader: shader };\n//# sourceMappingURL=subSurfaceScatteringFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"uvAttributeDeclaration\";\nvar shader = \"#ifdef UV{X}\\nattribute vec2 uv{X};\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var uvAttributeDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=uvAttributeDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"uvVariableDeclaration\";\nvar shader = \"#if !defined(UV{X}) && defined(MAINUV{X})\\nvec2 uv{X}=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV{X}\\nvMainUV{X}=uv{X};\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var uvVariableDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=uvVariableDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"vertexColorMixing\";\nvar shader = \"#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\nvColor=vec4(1.0);\\n#ifdef VERTEXCOLOR\\n#ifdef VERTEXALPHA\\nvColor*=color;\\n#else\\nvColor.rgb*=color.rgb;\\n#endif\\n#endif\\n#ifdef INSTANCESCOLOR\\nvColor*=instanceColor;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var vertexColorMixing = { name: name, shader: shader };\n//# sourceMappingURL=vertexColorMixing.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"anaglyphPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D leftSampler;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec4 leftFrag=texture2D(leftSampler,vUV);\\nleftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);\\nvec4 rightFrag=texture2D(textureSampler,vUV);\\nrightFrag=vec4(rightFrag.r,1.0,1.0,1.0);\\ngl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var anaglyphPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=anaglyph.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"backgroundFragmentDeclaration\";\nvar shader = \"uniform vec4 vEyePosition;\\nuniform vec4 vPrimaryColor;\\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\\nuniform vec4 vPrimaryColorShadow;\\n#endif\\nuniform float shadowLevel;\\nuniform float alpha;\\n#ifdef DIFFUSE\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\n#endif\\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\\nuniform vec3 vBackgroundCenter;\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nuniform vec4 vReflectionControl;\\n#endif\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\\nuniform mat4 view;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var backgroundFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=backgroundFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/backgroundFragmentDeclaration.js\";\nimport \"./ShadersInclude/backgroundUboDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/reflectionFunction.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/lightFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightUboDeclaration.js\";\nimport \"./ShadersInclude/lightsFragmentFunctions.js\";\nimport \"./ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/fogFragmentDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/lightFragment.js\";\nimport \"./ShadersInclude/fogFragment.js\";\nvar name = \"backgroundPixelShader\";\nvar shader = \"#ifdef TEXTURELODSUPPORT\\n#extension GL_EXT_shader_texture_lod : enable\\n#endif\\nprecision highp float;\\n#include<__decl__backgroundFragment>\\n#include<helperFunctions>\\n#define RECIPROCAL_PI2 0.15915494\\nvarying vec3 vPositionW;\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif \\n#ifdef MAINUV2 \\nvarying vec2 vMainUV2; \\n#endif \\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef DIFFUSE\\n#if DIFFUSEDIRECTUV==1\\n#define vDiffuseUV vMainUV1\\n#elif DIFFUSEDIRECTUV==2\\n#define vDiffuseUV vMainUV2\\n#else\\nvarying vec2 vDiffuseUV;\\n#endif\\nuniform sampler2D diffuseSampler;\\n#endif\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\n#define sampleReflection(s,c) textureCube(s,c)\\nuniform samplerCube reflectionSampler;\\n#ifdef TEXTURELODSUPPORT\\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\\n#else\\nuniform samplerCube reflectionSamplerLow;\\nuniform samplerCube reflectionSamplerHigh;\\n#endif\\n#else\\n#define sampleReflection(s,c) texture2D(s,c)\\nuniform sampler2D reflectionSampler;\\n#ifdef TEXTURELODSUPPORT\\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\\n#else\\nuniform samplerCube reflectionSamplerLow;\\nuniform samplerCube reflectionSamplerHigh;\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#include<reflectionFunction>\\n#endif\\n#ifndef FROMLINEARSPACE\\n#define FROMLINEARSPACE;\\n#endif\\n#ifndef SHADOWONLY\\n#define SHADOWONLY;\\n#endif\\n#include<imageProcessingDeclaration>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<lightsFragmentFunctions>\\n#include<shadowsFragmentFunctions>\\n#include<imageProcessingFunctions>\\n#include<clipPlaneFragmentDeclaration>\\n#include<fogFragmentDeclaration>\\n#ifdef REFLECTIONFRESNEL\\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\\nvec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\\n{\\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));\\n}\\n#endif\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<clipPlaneFragment>\\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=vec3(0.0,1.0,0.0);\\n#endif\\nfloat shadow=1.;\\nfloat globalShadow=0.;\\nfloat shadowLightCount=0.;\\n#include<lightFragment>[0..maxSimultaneousLights]\\n#ifdef SHADOWINUSE\\nglobalShadow/=shadowLightCount;\\n#else\\nglobalShadow=1.0;\\n#endif\\n#ifndef BACKMAT_SHADOWONLY\\nvec4 reflectionColor=vec4(1.,1.,1.,1.);\\n#ifdef REFLECTION\\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nreflectionVector.z*=-1.0;\\n#endif\\n#ifdef REFLECTIONMAP_3D\\nvec3 reflectionCoords=reflectionVector;\\n#else\\nvec2 reflectionCoords=reflectionVector.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\nreflectionCoords/=reflectionVector.z;\\n#endif\\nreflectionCoords.y=1.0-reflectionCoords.y;\\n#endif\\n#ifdef REFLECTIONBLUR\\nfloat reflectionLOD=vReflectionInfos.y;\\n#ifdef TEXTURELODSUPPORT\\nreflectionLOD=reflectionLOD*log2(vReflectionMicrosurfaceInfos.x)*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\\nreflectionColor=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\\n#else\\nfloat lodReflectionNormalized=saturate(reflectionLOD);\\nfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\\nvec4 reflectionSpecularMid=sampleReflection(reflectionSampler,reflectionCoords);\\nif(lodReflectionNormalizedDoubled<1.0){\\nreflectionColor=mix(\\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\\nreflectionSpecularMid,\\nlodReflectionNormalizedDoubled\\n);\\n} else {\\nreflectionColor=mix(\\nreflectionSpecularMid,\\nsampleReflection(reflectionSamplerLow,reflectionCoords),\\nlodReflectionNormalizedDoubled-1.0\\n);\\n}\\n#endif\\n#else\\nvec4 reflectionSample=sampleReflection(reflectionSampler,reflectionCoords);\\nreflectionColor=reflectionSample;\\n#endif\\n#ifdef RGBDREFLECTION\\nreflectionColor.rgb=fromRGBD(reflectionColor);\\n#endif\\n#ifdef GAMMAREFLECTION\\nreflectionColor.rgb=toLinearSpace(reflectionColor.rgb);\\n#endif\\n#ifdef REFLECTIONBGR\\nreflectionColor.rgb=reflectionColor.bgr;\\n#endif\\nreflectionColor.rgb*=vReflectionInfos.x;\\n#endif\\nvec3 diffuseColor=vec3(1.,1.,1.);\\nfloat finalAlpha=alpha;\\n#ifdef DIFFUSE\\nvec4 diffuseMap=texture2D(diffuseSampler,vDiffuseUV);\\n#ifdef GAMMADIFFUSE\\ndiffuseMap.rgb=toLinearSpace(diffuseMap.rgb);\\n#endif\\ndiffuseMap.rgb*=vDiffuseInfos.y;\\n#ifdef DIFFUSEHASALPHA\\nfinalAlpha*=diffuseMap.a;\\n#endif\\ndiffuseColor=diffuseMap.rgb;\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nvec3 colorBase=diffuseColor;\\n#else\\nvec3 colorBase=reflectionColor.rgb*diffuseColor;\\n#endif\\ncolorBase=max(colorBase,0.0);\\n#ifdef USERGBCOLOR\\nvec3 finalColor=colorBase;\\n#else\\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\\nvec3 mainColor=mix(vPrimaryColorShadow.rgb,vPrimaryColor.rgb,colorBase);\\n#else\\nvec3 mainColor=vPrimaryColor.rgb;\\n#endif\\nvec3 finalColor=colorBase*mainColor;\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nvec3 reflectionAmount=vReflectionControl.xxx;\\nvec3 reflectionReflectance0=vReflectionControl.yyy;\\nvec3 reflectionReflectance90=vReflectionControl.zzz;\\nfloat VdotN=dot(normalize(vEyePosition.xyz),normalW);\\nvec3 planarReflectionFresnel=fresnelSchlickEnvironmentGGX(saturate(VdotN),reflectionReflectance0,reflectionReflectance90,1.0);\\nreflectionAmount*=planarReflectionFresnel;\\n#ifdef REFLECTIONFALLOFF\\nfloat reflectionDistanceFalloff=1.0-saturate(length(vPositionW.xyz-vBackgroundCenter)*vReflectionControl.w);\\nreflectionDistanceFalloff*=reflectionDistanceFalloff;\\nreflectionAmount*=reflectionDistanceFalloff;\\n#endif\\nfinalColor=mix(finalColor,reflectionColor.rgb,saturate(reflectionAmount));\\n#endif\\n#ifdef OPACITYFRESNEL\\nfloat viewAngleToFloor=dot(normalW,normalize(vEyePosition.xyz-vBackgroundCenter));\\nconst float startAngle=0.1;\\nfloat fadeFactor=saturate(viewAngleToFloor/startAngle);\\nfinalAlpha*=fadeFactor*fadeFactor;\\n#endif\\n#ifdef SHADOWINUSE\\nfinalColor=mix(finalColor*shadowLevel,finalColor,globalShadow);\\n#endif\\nvec4 color=vec4(finalColor,finalAlpha);\\n#else\\nvec4 color=vec4(vPrimaryColor.rgb,(1.0-clamp(globalShadow,0.,1.))*alpha);\\n#endif\\n#include<fogFragment>\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\n#if !defined(SKIPFINALCOLORCLAMP)\\ncolor.rgb=clamp(color.rgb,0.,30.0);\\n#endif\\n#else\\ncolor=applyImageProcessing(color);\\n#endif\\n#ifdef PREMULTIPLYALPHA\\ncolor.rgb*=color.a;\\n#endif\\n#ifdef NOISE\\ncolor.rgb+=dither(vPositionW.xy,0.5);\\ncolor=max(color,0.0);\\n#endif\\ngl_FragColor=color;\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var backgroundPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=background.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"backgroundVertexDeclaration\";\nvar shader = \"uniform mat4 view;\\nuniform mat4 viewProjection;\\nuniform float shadowLevel;\\n#ifdef DIFFUSE\\nuniform mat4 diffuseMatrix;\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\nuniform float fFovMultiplier;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var backgroundVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=backgroundVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/backgroundVertexDeclaration.js\";\nimport \"./ShadersInclude/backgroundUboDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/fogVertexDeclaration.js\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightVxUboDeclaration.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/fogVertex.js\";\nimport \"./ShadersInclude/shadowsVertex.js\";\nvar name = \"backgroundVertexShader\";\nvar shader = \"precision highp float;\\n#include<__decl__backgroundVertex>\\n#include<helperFunctions>\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<instancesDeclaration>\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\\nvarying vec2 vDiffuseUV;\\n#endif\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\n#ifdef REFLECTIONMAP_SKYBOX\\nvPositionUVW=position;\\n#endif\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\n#ifdef MULTIVIEW\\nif (gl_ViewID_OVR==0u) {\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n} else {\\ngl_Position=viewProjectionR*finalWorld*vec4(position,1.0);\\n}\\n#else\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n#endif\\nvec4 worldPos=finalWorld*vec4(position,1.0);\\nvPositionW=vec3(worldPos);\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvNormalW=normalize(normalWorld*normal);\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\\n#ifdef EQUIRECTANGULAR_RELFECTION_FOV\\nmat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));\\nvec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));\\nif (fFovMultiplier<=1.0) {\\nvDirectionW=normalize(segment);\\n} else {\\nvDirectionW=normalize(vDirectionW+(vDirectionW-segment));\\n}\\n#endif\\n#endif\\n#ifndef UV1\\nvec2 uv=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uv;\\n#endif\\n#ifdef MAINUV2\\nvMainUV2=uv2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0\\nif (vDiffuseInfos.x==0.)\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#include<clipPlaneVertex>\\n#include<fogVertex>\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n#ifdef VERTEXCOLOR\\nvColor=color;\\n#endif\\n#if defined(POINTSIZE) && !defined(WEBGPU)\\ngl_PointSize=pointSize;\\n#endif\\n#define CUSTOM_VERTEX_MAIN_END\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var backgroundVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=background.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"blackAndWhitePixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform float degree;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\nvec3 color=texture2D(textureSampler,vUV).rgb;\\nfloat luminance=dot(color,vec3(0.3,0.59,0.11)); \\nvec3 blackAndWhite=vec3(luminance,luminance,luminance);\\ngl_FragColor=vec4(color-((color-blackAndWhite)*degree),1.0);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var blackAndWhitePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=blackAndWhite.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"bloomMergePixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\nuniform sampler2D bloomBlur;\\nvarying vec2 vUV;\\nuniform float bloomWeight;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(textureSampler,vUV);\\nvec3 blurred=texture2D(bloomBlur,vUV).rgb;\\ngl_FragColor.rgb=gl_FragColor.rgb+(blurred.rgb*bloomWeight); \\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var bloomMergePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=bloomMerge.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"chromaticAberrationPixelShader\";\nvar shader = \"uniform sampler2D textureSampler; \\nuniform float chromatic_aberration;\\nuniform float radialIntensity;\\nuniform vec2 direction;\\nuniform vec2 centerPosition;\\nuniform float screen_width;\\nuniform float screen_height;\\nvarying vec2 vUV;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec2 centered_screen_pos=vec2(vUV.x-centerPosition.x,vUV.y-centerPosition.y);\\nvec2 directionOfEffect=direction;\\nif(directionOfEffect.x==0. && directionOfEffect.y==0.){\\ndirectionOfEffect=normalize(centered_screen_pos);\\n}\\nfloat radius2=centered_screen_pos.x*centered_screen_pos.x\\n+ centered_screen_pos.y*centered_screen_pos.y;\\nfloat radius=sqrt(radius2);\\nvec4 original=texture2D(textureSampler,vUV);\\nvec3 ref_indices=vec3(-0.3,0.0,0.3);\\nfloat ref_shiftX=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.x/screen_width;\\nfloat ref_shiftY=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.y/screen_height;\\nvec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);\\nvec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);\\nvec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);\\noriginal.r=texture2D(textureSampler,ref_coords_r).r;\\noriginal.g=texture2D(textureSampler,ref_coords_g).g;\\noriginal.b=texture2D(textureSampler,ref_coords_b).b;\\noriginal.a=clamp(texture2D(textureSampler,ref_coords_r).a+texture2D(textureSampler,ref_coords_g).a+texture2D(textureSampler,ref_coords_b).a,0.,1.);\\ngl_FragColor=original;\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var chromaticAberrationPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=chromaticAberration.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"circleOfConfusionPixelShader\";\nvar shader = \"uniform sampler2D depthSampler;\\nvarying vec2 vUV;\\nuniform vec2 cameraMinMaxZ;\\nuniform float focusDistance;\\nuniform float cocPrecalculation;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nfloat depth=texture2D(depthSampler,vUV).r;\\nfloat pixelDistance=(cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth)*1000.0; \\nfloat coc=abs(cocPrecalculation* ((focusDistance-pixelDistance)/pixelDistance));\\ncoc=clamp(coc,0.0,1.0);\\ngl_FragColor=vec4(coc,depth,coc,1.0);\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var circleOfConfusionPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=circleOfConfusion.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"clearQuadPixelShader\";\nvar shader = \"uniform vec4 color;\\nvoid main() {\\ngl_FragColor=color;\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var clearQuadPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=clearQuad.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"clearQuadVertexShader\";\nvar shader = \"uniform float depthValue;\\nconst vec2 pos[4]={\\nvec2(-1.0,1.0),\\nvec2(1.0,1.0),\\nvec2(-1.0,-1.0),\\nvec2(1.0,-1.0)\\n};\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\ngl_Position=vec4(pos[gl_VertexID],depthValue,1.0);\\n#define CUSTOM_VERTEX_MAIN_END\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var clearQuadVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=clearQuad.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nvar name = \"colorPixelShader\";\nvar shader = \"#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\nvarying vec4 vColor;\\n#else\\nuniform vec4 color;\\n#endif\\n#include<clipPlaneFragmentDeclaration>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<clipPlaneFragment>\\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\ngl_FragColor=vColor;\\n#else\\ngl_FragColor=color;\\n#endif\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var colorPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=color.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/vertexColorMixing.js\";\nvar name = \"colorVertexShader\";\nvar shader = \"attribute vec3 position;\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\n#ifdef MULTIVIEW\\nuniform mat4 viewProjectionR;\\n#endif\\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\nvarying vec4 vColor;\\n#endif\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\nvec4 worldPos=finalWorld*vec4(position,1.0);\\n#ifdef MULTIVIEW\\nif (gl_ViewID_OVR==0u) {\\ngl_Position=viewProjection*worldPos;\\n} else {\\ngl_Position=viewProjectionR*worldPos;\\n}\\n#else\\ngl_Position=viewProjection*worldPos;\\n#endif\\n#include<clipPlaneVertex>\\n#include<vertexColorMixing>\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var colorVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=color.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"colorCorrectionPixelShader\";\nvar shader = \"uniform sampler2D textureSampler; \\nuniform sampler2D colorTable; \\nvarying vec2 vUV;\\nconst float SLICE_COUNT=16.0; \\nvec4 sampleAs3DTexture(sampler2D textureSampler,vec3 uv,float width) {\\nfloat sliceSize=1.0/width; \\nfloat slicePixelSize=sliceSize/width; \\nfloat sliceInnerSize=slicePixelSize*(width-1.0); \\nfloat zSlice0=min(floor(uv.z*width),width-1.0);\\nfloat zSlice1=min(zSlice0+1.0,width-1.0);\\nfloat xOffset=slicePixelSize*0.5+uv.x*sliceInnerSize;\\nfloat s0=xOffset+(zSlice0*sliceSize);\\nfloat s1=xOffset+(zSlice1*sliceSize);\\nvec4 slice0Color=texture2D(textureSampler,vec2(s0,uv.y));\\nvec4 slice1Color=texture2D(textureSampler,vec2(s1,uv.y));\\nfloat zOffset=mod(uv.z*width,1.0);\\nvec4 result=mix(slice0Color,slice1Color,zOffset);\\nreturn result;\\n}\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec4 screen_color=texture2D(textureSampler,vUV);\\ngl_FragColor=sampleAs3DTexture(colorTable,screen_color.rgb,SLICE_COUNT);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var colorCorrectionPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=colorCorrection.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"convolutionPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 screenSize;\\nuniform float kernel[9];\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\\nvec4 colorSum =\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,-1))*kernel[0] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,-1))*kernel[1] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,-1))*kernel[2] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0))*kernel[3] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,0))*kernel[4] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0))*kernel[5] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,1))*kernel[6] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1))*kernel[7] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,1))*kernel[8];\\nfloat kernelWeight =\\nkernel[0] +\\nkernel[1] +\\nkernel[2] +\\nkernel[3] +\\nkernel[4] +\\nkernel[5] +\\nkernel[6] +\\nkernel[7] +\\nkernel[8];\\nif (kernelWeight<=0.0) {\\nkernelWeight=1.0;\\n}\\ngl_FragColor=vec4((colorSum/kernelWeight).rgb,1);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var convolutionPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=convolution.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"defaultFragmentDeclaration\";\nvar shader = \"uniform vec4 vEyePosition;\\nuniform vec4 vDiffuseColor;\\n#ifdef SPECULARTERM\\nuniform vec4 vSpecularColor;\\n#endif\\nuniform vec3 vEmissiveColor;\\nuniform vec3 vAmbientColor;\\nuniform float visibility;\\n#ifdef DIFFUSE\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY \\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform vec2 vTangentSpaceParams;\\n#endif\\n#ifdef ALPHATEST\\nuniform float alphaCutOff;\\n#endif\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\\nuniform mat4 view;\\n#endif\\n#ifdef REFRACTION\\nuniform vec4 vRefractionInfos;\\n#ifndef REFRACTIONMAP_3D\\nuniform mat4 refractionMatrix;\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nuniform vec4 refractionLeftColor;\\nuniform vec4 refractionRightColor;\\n#endif\\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\\nuniform vec3 vRefractionPosition;\\nuniform vec3 vRefractionSize; \\n#endif\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\n#endif\\n#ifdef DIFFUSEFRESNEL\\nuniform vec4 diffuseLeftColor;\\nuniform vec4 diffuseRightColor;\\n#endif\\n#ifdef OPACITYFRESNEL\\nuniform vec4 opacityParts;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nuniform vec4 emissiveLeftColor;\\nuniform vec4 emissiveRightColor;\\n#endif\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\\nuniform mat4 reflectionMatrix;\\n#endif\\n#ifndef REFLECTIONMAP_SKYBOX\\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\\nuniform vec3 vReflectionPosition;\\nuniform vec3 vReflectionSize; \\n#endif\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nuniform vec4 reflectionLeftColor;\\nuniform vec4 reflectionRightColor;\\n#endif\\n#endif\\n#ifdef DETAIL\\nuniform vec4 vDetailInfos;\\n#endif\\n#define ADDITIONAL_FRAGMENT_DECLARATION\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var defaultFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=defaultFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/defaultFragmentDeclaration.js\";\nimport \"./ShadersInclude/defaultUboDeclaration.js\";\nimport \"./ShadersInclude/prePassDeclaration.js\";\nimport \"./ShadersInclude/oitDeclaration.js\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/lightFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightUboDeclaration.js\";\nimport \"./ShadersInclude/lightsFragmentFunctions.js\";\nimport \"./ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"./ShadersInclude/samplerFragmentDeclaration.js\";\nimport \"./ShadersInclude/fresnelFunction.js\";\nimport \"./ShadersInclude/reflectionFunction.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/fogFragmentDeclaration.js\";\nimport \"./ShadersInclude/oitFragment.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/bumpFragment.js\";\nimport \"./ShadersInclude/depthPrePass.js\";\nimport \"./ShadersInclude/lightFragment.js\";\nimport \"./ShadersInclude/logDepthFragment.js\";\nimport \"./ShadersInclude/fogFragment.js\";\nvar name = \"defaultPixelShader\";\nvar shader = \"#include<__decl__defaultFragment>\\n#if defined(BUMP) || !defined(NORMAL)\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\\n#include<oitDeclaration>\\n#define CUSTOM_FRAGMENT_BEGIN\\n#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\n#define RECIPROCAL_PI2 0.15915494\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\nvarying vec4 vColor;\\n#endif\\n#include<mainUVVaryingDeclaration>[1..7]\\n#include<helperFunctions>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<lightsFragmentFunctions>\\n#include<shadowsFragmentFunctions>\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\\n#ifdef REFRACTION\\n#ifdef REFRACTIONMAP_3D\\nuniform samplerCube refractionCubeSampler;\\n#else\\nuniform sampler2D refraction2DSampler;\\n#endif\\n#endif\\n#if defined(SPECULARTERM)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\\n#endif\\n#include<fresnelFunction>\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\nuniform samplerCube reflectionCubeSampler;\\n#else\\nuniform sampler2D reflection2DSampler;\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#include<reflectionFunction>\\n#endif\\n#include<imageProcessingDeclaration>\\n#include<imageProcessingFunctions>\\n#include<bumpFragmentMainFunctions>\\n#include<bumpFragmentFunctions>\\n#include<clipPlaneFragmentDeclaration>\\n#include<logDepthDeclaration>\\n#include<fogFragmentDeclaration>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<oitFragment>\\n#include<clipPlaneFragment>\\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\\nvec4 baseColor=vec4(1.,1.,1.,1.);\\nvec3 diffuseColor=vDiffuseColor.rgb;\\nfloat alpha=vDiffuseColor.a;\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\\n#endif\\n#include<bumpFragment>\\n#ifdef TWOSIDEDLIGHTING\\nnormalW=gl_FrontFacing ? normalW : -normalW;\\n#endif\\n#ifdef DIFFUSE\\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\\nif (baseColor.a<alphaCutOff)\\ndiscard;\\n#endif\\n#ifdef ALPHAFROMDIFFUSE\\nalpha*=baseColor.a;\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\\nbaseColor.rgb*=vDiffuseInfos.y;\\n#endif\\n#include<depthPrePass>\\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\nbaseColor.rgb*=vColor.rgb;\\n#endif\\n#ifdef DETAIL\\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\\nvec3 baseAmbientColor=vec3(1.,1.,1.);\\n#ifdef AMBIENT\\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\\n#ifdef SPECULARTERM\\nfloat glossiness=vSpecularColor.a;\\nvec3 specularColor=vSpecularColor.rgb;\\n#ifdef SPECULAR\\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\\nspecularColor=specularMapColor.rgb;\\n#ifdef GLOSSINESS\\nglossiness=glossiness*specularMapColor.a;\\n#endif\\n#endif\\n#else\\nfloat glossiness=0.;\\n#endif\\nvec3 diffuseBase=vec3(0.,0.,0.);\\nlightingInfo info;\\n#ifdef SPECULARTERM\\nvec3 specularBase=vec3(0.,0.,0.);\\n#endif\\nfloat shadow=1.;\\n#ifdef LIGHTMAP\\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\\n#ifdef RGBDLIGHTMAP\\nlightmapColor.rgb=fromRGBD(lightmapColor);\\n#endif\\nlightmapColor.rgb*=vLightmapInfos.y;\\n#endif\\n#include<lightFragment>[0..maxSimultaneousLights]\\nvec4 refractionColor=vec4(0.,0.,0.,1.);\\n#ifdef REFRACTION\\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\\n#ifdef REFRACTIONMAP_3D\\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\\n#endif\\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\\nif (dot(refractionVector,viewDirectionW)<1.0) {\\nrefractionColor=textureCube(refractionCubeSampler,refractionVector);\\n}\\n#else\\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\\nrefractionCoords.y=1.0-refractionCoords.y;\\nrefractionColor=texture2D(refraction2DSampler,refractionCoords);\\n#endif\\n#ifdef RGBDREFRACTION\\nrefractionColor.rgb=fromRGBD(refractionColor);\\n#endif\\n#ifdef IS_REFRACTION_LINEAR\\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\\n#endif\\nrefractionColor.rgb*=vRefractionInfos.x;\\n#endif\\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\\n#ifdef REFLECTION\\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nvReflectionUVW.z*=-1.0;\\n#endif\\n#ifdef REFLECTIONMAP_3D\\n#ifdef ROUGHNESS\\nfloat bias=vReflectionInfos.y;\\n#ifdef SPECULARTERM\\n#ifdef SPECULAR\\n#ifdef GLOSSINESS\\nbias*=(1.0-specularMapColor.a);\\n#endif\\n#endif\\n#endif\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\\n#else\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\\n#endif\\n#else\\nvec2 coords=vReflectionUVW.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\ncoords/=vReflectionUVW.z;\\n#endif\\ncoords.y=1.0-coords.y;\\nreflectionColor=texture2D(reflection2DSampler,coords);\\n#endif\\n#ifdef RGBDREFLECTION\\nreflectionColor.rgb=fromRGBD(reflectionColor);\\n#endif\\n#ifdef IS_REFLECTION_LINEAR\\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\\n#endif\\nreflectionColor.rgb*=vReflectionInfos.x;\\n#ifdef REFLECTIONFRESNEL\\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\\n#ifdef REFLECTIONFRESNELFROMSPECULAR\\n#ifdef SPECULARTERM\\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#else\\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#else\\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#endif\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\\nrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\\n#endif\\n#ifdef OPACITY\\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\\n#ifdef OPACITYRGB\\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\\n#else\\nalpha*=opacityMap.a*vOpacityInfos.y;\\n#endif\\n#endif\\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR)\\nalpha*=vColor.a;\\n#endif\\n#ifdef OPACITYFRESNEL\\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\\n#endif\\n#ifdef ALPHATEST\\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\\nif (alpha<alphaCutOff)\\ndiscard;\\n#endif\\n#ifndef ALPHABLEND\\nalpha=1.0;\\n#endif\\n#endif\\nvec3 emissiveColor=vEmissiveColor;\\n#ifdef EMISSIVE\\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\\n#endif\\n#ifdef DIFFUSEFRESNEL\\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\\n#endif\\n#ifdef EMISSIVEASILLUMINATION\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\n#ifdef LINKEMISSIVEWITHDIFFUSE\\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#endif\\n#endif\\n#ifdef SPECULARTERM\\nvec3 finalSpecular=specularBase*specularColor;\\n#ifdef SPECULAROVERALPHA\\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n#else\\nvec3 finalSpecular=vec3(0.0);\\n#endif\\n#ifdef REFLECTIONOVERALPHA\\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n#ifdef EMISSIVEASILLUMINATION\\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\\n#else\\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\\n#endif\\n#ifdef LIGHTMAP\\n#ifndef LIGHTMAPEXCLUDED\\n#ifdef USELIGHTMAPASSHADOWMAP\\ncolor.rgb*=lightmapColor.rgb;\\n#else\\ncolor.rgb+=lightmapColor.rgb;\\n#endif\\n#endif\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_FOG\\ncolor.rgb=max(color.rgb,0.);\\n#include<logDepthFragment>\\n#include<fogFragment>\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\ncolor.rgb=toLinearSpace(color.rgb);\\n#else\\n#ifdef IMAGEPROCESSING\\ncolor.rgb=toLinearSpace(color.rgb);\\ncolor=applyImageProcessing(color);\\n#endif\\n#endif\\ncolor.a*=visibility;\\n#ifdef PREMULTIPLYALPHA\\ncolor.rgb*=color.a;\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\\n#ifdef PREPASS\\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;\\ngl_FragData[0]=color; \\n#ifdef PREPASS_POSITION\\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\\n#endif\\n#ifdef PREPASS_VELOCITY\\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\\nvec2 velocity=abs(a-b);\\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\\n#endif\\n#ifdef PREPASS_IRRADIANCE\\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \\n#endif\\n#ifdef PREPASS_DEPTH\\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \\n#endif\\n#ifdef PREPASS_NORMAL\\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4((view*vec4(normalW,0.0)).rgb,writeGeometryInfo); \\n#endif\\n#ifdef PREPASS_ALBEDO_SQRT\\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \\n#endif\\n#ifdef PREPASS_REFLECTIVITY\\n#if defined(SPECULARTERM)\\n#if defined(SPECULAR)\\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularMapColor)*writeGeometryInfo; \\n#else\\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularColor,1.0)*writeGeometryInfo;\\n#endif\\n#else\\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;\\n#endif\\n#endif\\n#endif\\n#if !defined(PREPASS) || defined(WEBGL2)\\ngl_FragColor=color;\\n#endif\\n#if ORDER_INDEPENDENT_TRANSPARENCY\\nif (fragDepth==nearestDepth) {\\nfrontColor.rgb+=color.rgb*color.a*alphaMultiplier;\\nfrontColor.a=1.0-alphaMultiplier*(1.0-color.a);\\n} else {\\nbackColor+=color;\\n}\\n#endif\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var defaultPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=default.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"defaultVertexDeclaration\";\nvar shader = \"uniform mat4 viewProjection;\\nuniform mat4 view;\\n#ifdef DIFFUSE\\nuniform mat4 diffuseMatrix;\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform mat4 ambientMatrix;\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform mat4 opacityMatrix;\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\nuniform mat4 emissiveMatrix;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\nuniform mat4 lightmapMatrix;\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\nuniform mat4 specularMatrix;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform mat4 bumpMatrix;\\n#endif\\n#ifdef REFLECTION\\nuniform mat4 reflectionMatrix;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n#ifdef DETAIL\\nuniform vec4 vDetailInfos;\\nuniform mat4 detailMatrix;\\n#endif\\n#define ADDITIONAL_VERTEX_DECLARATION\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var defaultVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=defaultVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pointCloudVertex\";\nvar shader = \"#if defined(POINTSIZE) && !defined(WEBGPU)\\ngl_PointSize=pointSize;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pointCloudVertex = { name: name, shader: shader };\n//# sourceMappingURL=pointCloudVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/defaultVertexDeclaration.js\";\nimport \"./ShadersInclude/defaultUboDeclaration.js\";\nimport \"./ShadersInclude/uvAttributeDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/prePassVertexDeclaration.js\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration.js\";\nimport \"./ShadersInclude/samplerVertexDeclaration.js\";\nimport \"./ShadersInclude/bumpVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/fogVertexDeclaration.js\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightVxUboDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/prePassVertex.js\";\nimport \"./ShadersInclude/uvVariableDeclaration.js\";\nimport \"./ShadersInclude/samplerVertexImplementation.js\";\nimport \"./ShadersInclude/bumpVertex.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/fogVertex.js\";\nimport \"./ShadersInclude/shadowsVertex.js\";\nimport \"./ShadersInclude/vertexColorMixing.js\";\nimport \"./ShadersInclude/pointCloudVertex.js\";\nimport \"./ShadersInclude/logDepthVertex.js\";\nvar name = \"defaultVertexShader\";\nvar shader = \"#include<__decl__defaultVertex>\\n#define CUSTOM_VERTEX_BEGIN\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#ifdef TANGENT\\nattribute vec4 tangent;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#include<uvAttributeDeclaration>[2..7]\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<helperFunctions>\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<instancesDeclaration>\\n#include<prePassVertexDeclaration>\\n#include<mainUVVaryingDeclaration>[1..7]\\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\\n#if defined(SPECULARTERM)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\\n#endif\\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\nvarying vec4 vColor;\\n#endif\\n#include<bumpVertexDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#include<logDepthDeclaration>\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec3 positionUpdated=position;\\n#ifdef NORMAL\\nvec3 normalUpdated=normal;\\n#endif\\n#ifdef TANGENT\\nvec4 tangentUpdated=tangent;\\n#endif\\n#ifdef UV1\\nvec2 uvUpdated=uv;\\n#endif\\n#include<morphTargetsVertexGlobal>\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvPositionUVW=positionUpdated;\\n#endif\\n#define CUSTOM_VERTEX_UPDATE_POSITION\\n#define CUSTOM_VERTEX_UPDATE_NORMAL\\n#include<instancesVertex>\\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\\n#endif\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\\nvNormalW=normalize(normalWorld*vNormalW);\\n#else\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvNormalW=normalize(normalWorld*normalUpdated);\\n#endif\\n#endif\\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\\n#ifdef MULTIVIEW\\nif (gl_ViewID_OVR==0u) {\\ngl_Position=viewProjection*worldPos;\\n} else {\\ngl_Position=viewProjectionR*worldPos;\\n}\\n#else\\ngl_Position=viewProjection*worldPos;\\n#endif\\nvPositionW=vec3(worldPos);\\n#include<prePassVertex>\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\\n#endif\\n#ifndef UV1\\nvec2 uvUpdated=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uvUpdated;\\n#endif\\n#include<uvVariableDeclaration>[2..7]\\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\\n#if defined(SPECULARTERM)\\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\\n#endif\\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\\n#include<bumpVertex>\\n#include<clipPlaneVertex>\\n#include<fogVertex>\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n#include<vertexColorMixing>\\n#include<pointCloudVertex>\\n#include<logDepthVertex>\\n#define CUSTOM_VERTEX_MAIN_END\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var defaultVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=default.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nvar name = \"depthVertexShader\";\nvar shader = \"attribute vec3 position;\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\nuniform vec2 depthValues;\\n#if defined(ALPHATEST) || defined(NEED_UV)\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\nvarying float vDepthMetric;\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void)\\n{\\nvec3 positionUpdated=position;\\n#ifdef UV1\\nvec2 uvUpdated=uv;\\n#endif\\n#include<morphTargetsVertexGlobal>\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\n#ifdef USE_REVERSE_DEPTHBUFFER\\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\\n#else\\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\\n#endif\\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var depthVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=depth.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"depthBoxBlurPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 screenSize;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec4 colorDepth=vec4(0.0);\\nfor (int x=-OFFSET; x<=OFFSET; x++)\\nfor (int y=-OFFSET; y<=OFFSET; y++)\\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);\\ngl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var depthBoxBlurPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=depthBoxBlur.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"depthOfFieldPixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\nuniform sampler2D highlightsSampler;\\nuniform sampler2D depthSampler;\\nuniform sampler2D grainSampler;\\nuniform float grain_amount;\\nuniform bool blur_noise;\\nuniform float screen_width;\\nuniform float screen_height;\\nuniform float distortion;\\nuniform bool dof_enabled;\\nuniform float screen_distance; \\nuniform float aperture;\\nuniform float darken;\\nuniform float edge_blur;\\nuniform bool highlights;\\nuniform float near;\\nuniform float far;\\nvarying vec2 vUV;\\n#define PI 3.14159265\\n#define TWOPI 6.28318530\\n#define inverse_focal_length 0.1 \\nvec2 centered_screen_pos;\\nvec2 distorted_coords;\\nfloat radius2;\\nfloat radius;\\nvec2 rand(vec2 co)\\n{\\nfloat noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));\\nfloat noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));\\nreturn clamp(vec2(noise1,noise2),0.0,1.0);\\n}\\nvec2 getDistortedCoords(vec2 coords) {\\nif (distortion==0.0) { return coords; }\\nvec2 direction=1.0*normalize(centered_screen_pos);\\nvec2 dist_coords=vec2(0.5,0.5);\\ndist_coords.x=0.5+direction.x*radius2*1.0;\\ndist_coords.y=0.5+direction.y*radius2*1.0;\\nfloat dist_amount=clamp(distortion*0.23,0.0,1.0);\\ndist_coords=mix(coords,dist_coords,dist_amount);\\nreturn dist_coords;\\n}\\nfloat sampleScreen(inout vec4 color,in vec2 offset,in float weight) {\\nvec2 coords=distorted_coords;\\nfloat angle=rand(coords*100.0).x*TWOPI;\\ncoords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));\\ncolor+=texture2D(textureSampler,coords)*weight;\\nreturn weight;\\n}\\nfloat getBlurLevel(float size) {\\nreturn min(3.0,ceil(size/1.0));\\n}\\nvec4 getBlurColor(float size) {\\nvec4 col=texture2D(textureSampler,distorted_coords);\\nfloat blur_level=getBlurLevel(size);\\nfloat w=(size/screen_width);\\nfloat h=(size/screen_height);\\nfloat total_weight=1.0;\\nvec2 sample_coords;\\ntotal_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);\\ntotal_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);\\ntotal_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);\\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);\\ntotal_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);\\ntotal_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);\\ntotal_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);\\ntotal_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);\\ntotal_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);\\ntotal_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);\\nif (blur_level>1.0) {\\ntotal_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);\\ntotal_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);\\ntotal_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);\\ntotal_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);\\ntotal_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);\\ntotal_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);\\ntotal_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);\\ntotal_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);\\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);\\ntotal_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);\\n}\\nif (blur_level>2.0) {\\ntotal_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);\\ntotal_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);\\ntotal_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);\\ntotal_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);\\ntotal_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);\\ntotal_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);\\ntotal_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);\\ntotal_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);\\ntotal_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);\\n}\\ncol/=total_weight; \\nif (darken>0.0) {\\ncol.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);\\n}\\nreturn col;\\n}\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\ncentered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);\\nradius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;\\nradius=sqrt(radius2);\\ndistorted_coords=getDistortedCoords(vUV); \\nvec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height); \\nfloat depth=texture2D(depthSampler,distorted_coords).r; \\nfloat distance=near+(far-near)*depth; \\nvec4 color=texture2D(textureSampler,vUV); \\nfloat coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));\\nif (dof_enabled==false || coc<0.07) { coc=0.0; }\\nfloat edge_blur_amount=0.0;\\nif (edge_blur>0.0) {\\nedge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;\\n}\\nfloat blur_amount=max(edge_blur_amount,coc);\\nif (blur_amount==0.0) {\\ngl_FragColor=texture2D(textureSampler,distorted_coords);\\n}\\nelse {\\ngl_FragColor=getBlurColor(blur_amount*1.7);\\nif (highlights) {\\ngl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;\\n}\\nif (blur_noise) {\\nvec2 noise=rand(distorted_coords)*0.01*blur_amount;\\nvec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);\\ngl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;\\n}\\n}\\nif (grain_amount>0.0) {\\nvec4 grain_color=texture2D(grainSampler,texels_coords*0.003);\\ngl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;\\n}\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var depthOfFieldPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=depthOfField.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"depthOfFieldMergePixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\nvarying vec2 vUV;\\nuniform sampler2D circleOfConfusionSampler;\\nuniform sampler2D blurStep0;\\n#if BLUR_LEVEL>0\\nuniform sampler2D blurStep1;\\n#endif\\n#if BLUR_LEVEL>1\\nuniform sampler2D blurStep2;\\n#endif\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nfloat coc=texture2D(circleOfConfusionSampler,vUV).r;\\n#if BLUR_LEVEL==0\\nvec4 original=texture2D(textureSampler,vUV);\\nvec4 blurred0=texture2D(blurStep0,vUV);\\ngl_FragColor=mix(original,blurred0,coc);\\n#endif\\n#if BLUR_LEVEL==1\\nif(coc<0.5){\\nvec4 original=texture2D(textureSampler,vUV);\\nvec4 blurred1=texture2D(blurStep1,vUV);\\ngl_FragColor=mix(original,blurred1,coc/0.5);\\n}else{\\nvec4 blurred0=texture2D(blurStep0,vUV); \\nvec4 blurred1=texture2D(blurStep1,vUV);\\ngl_FragColor=mix(blurred1,blurred0,(coc-0.5)/0.5);\\n}\\n#endif\\n#if BLUR_LEVEL==2\\nif(coc<0.33){\\nvec4 original=texture2D(textureSampler,vUV);\\nvec4 blurred2=texture2D(blurStep2,vUV);\\ngl_FragColor=mix(original,blurred2,coc/0.33);\\n}else if(coc<0.66){\\nvec4 blurred1=texture2D(blurStep1,vUV);\\nvec4 blurred2=texture2D(blurStep2,vUV);\\ngl_FragColor=mix(blurred2,blurred1,(coc-0.33)/0.33);\\n}else{\\nvec4 blurred0=texture2D(blurStep0,vUV);\\nvec4 blurred1=texture2D(blurStep1,vUV);\\ngl_FragColor=mix(blurred1,blurred0,(coc-0.66)/0.34);\\n}\\n#endif\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var depthOfFieldMergePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=depthOfFieldMerge.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"displayPassPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D passSampler;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(passSampler,vUV);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var displayPassPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=displayPass.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nvar name = \"extractHighlightsPixelShader\";\nvar shader = \"#include<helperFunctions>\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform float threshold;\\nuniform float exposure;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\ngl_FragColor=texture2D(textureSampler,vUV);\\nfloat luma=dot(LuminanceEncodeApprox,gl_FragColor.rgb*exposure);\\ngl_FragColor.rgb=step(threshold,luma)*gl_FragColor.rgb;\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var extractHighlightsPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=extractHighlights.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"filterPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform mat4 kernelMatrix;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec3 baseColor=texture2D(textureSampler,vUV).rgb;\\nvec3 updatedColor=(kernelMatrix*vec4(baseColor,1.0)).rgb;\\ngl_FragColor=vec4(updatedColor,1.0);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var filterPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=filter.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"fxaaPixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\nuniform vec2 texelSize;\\nvarying vec2 vUV;\\nvarying vec2 sampleCoordS;\\nvarying vec2 sampleCoordE;\\nvarying vec2 sampleCoordN;\\nvarying vec2 sampleCoordW;\\nvarying vec2 sampleCoordNW;\\nvarying vec2 sampleCoordSE;\\nvarying vec2 sampleCoordNE;\\nvarying vec2 sampleCoordSW;\\nconst float fxaaQualitySubpix=1.0;\\nconst float fxaaQualityEdgeThreshold=0.166;\\nconst float fxaaQualityEdgeThresholdMin=0.0833;\\nconst vec3 kLumaCoefficients=vec3(0.2126,0.7152,0.0722);\\n#define FxaaLuma(rgba) dot(rgba.rgb,kLumaCoefficients)\\nvoid main(){\\nvec2 posM;\\nposM.x=vUV.x;\\nposM.y=vUV.y;\\nvec4 rgbyM=texture2D(textureSampler,vUV,0.0);\\nfloat lumaM=FxaaLuma(rgbyM);\\nfloat lumaS=FxaaLuma(texture2D(textureSampler,sampleCoordS,0.0));\\nfloat lumaE=FxaaLuma(texture2D(textureSampler,sampleCoordE,0.0));\\nfloat lumaN=FxaaLuma(texture2D(textureSampler,sampleCoordN,0.0));\\nfloat lumaW=FxaaLuma(texture2D(textureSampler,sampleCoordW,0.0));\\nfloat maxSM=max(lumaS,lumaM);\\nfloat minSM=min(lumaS,lumaM);\\nfloat maxESM=max(lumaE,maxSM);\\nfloat minESM=min(lumaE,minSM);\\nfloat maxWN=max(lumaN,lumaW);\\nfloat minWN=min(lumaN,lumaW);\\nfloat rangeMax=max(maxWN,maxESM);\\nfloat rangeMin=min(minWN,minESM);\\nfloat rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;\\nfloat range=rangeMax-rangeMin;\\nfloat rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);\\n#ifndef MALI\\nif(range<rangeMaxClamped) \\n{\\ngl_FragColor=rgbyM;\\nreturn;\\n}\\n#endif\\nfloat lumaNW=FxaaLuma(texture2D(textureSampler,sampleCoordNW,0.0));\\nfloat lumaSE=FxaaLuma(texture2D(textureSampler,sampleCoordSE,0.0));\\nfloat lumaNE=FxaaLuma(texture2D(textureSampler,sampleCoordNE,0.0));\\nfloat lumaSW=FxaaLuma(texture2D(textureSampler,sampleCoordSW,0.0));\\nfloat lumaNS=lumaN+lumaS;\\nfloat lumaWE=lumaW+lumaE;\\nfloat subpixRcpRange=1.0/range;\\nfloat subpixNSWE=lumaNS+lumaWE;\\nfloat edgeHorz1=(-2.0*lumaM)+lumaNS;\\nfloat edgeVert1=(-2.0*lumaM)+lumaWE;\\nfloat lumaNESE=lumaNE+lumaSE;\\nfloat lumaNWNE=lumaNW+lumaNE;\\nfloat edgeHorz2=(-2.0*lumaE)+lumaNESE;\\nfloat edgeVert2=(-2.0*lumaN)+lumaNWNE;\\nfloat lumaNWSW=lumaNW+lumaSW;\\nfloat lumaSWSE=lumaSW+lumaSE;\\nfloat edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);\\nfloat edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);\\nfloat edgeHorz3=(-2.0*lumaW)+lumaNWSW;\\nfloat edgeVert3=(-2.0*lumaS)+lumaSWSE;\\nfloat edgeHorz=abs(edgeHorz3)+edgeHorz4;\\nfloat edgeVert=abs(edgeVert3)+edgeVert4;\\nfloat subpixNWSWNESE=lumaNWSW+lumaNESE;\\nfloat lengthSign=texelSize.x;\\nbool horzSpan=edgeHorz>=edgeVert;\\nfloat subpixA=subpixNSWE*2.0+subpixNWSWNESE;\\nif (!horzSpan)\\n{\\nlumaN=lumaW;\\n}\\nif (!horzSpan) \\n{\\nlumaS=lumaE;\\n}\\nif (horzSpan) \\n{\\nlengthSign=texelSize.y;\\n}\\nfloat subpixB=(subpixA*(1.0/12.0))-lumaM;\\nfloat gradientN=lumaN-lumaM;\\nfloat gradientS=lumaS-lumaM;\\nfloat lumaNN=lumaN+lumaM;\\nfloat lumaSS=lumaS+lumaM;\\nbool pairN=abs(gradientN)>=abs(gradientS);\\nfloat gradient=max(abs(gradientN),abs(gradientS));\\nif (pairN)\\n{\\nlengthSign=-lengthSign;\\n}\\nfloat subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);\\nvec2 posB;\\nposB.x=posM.x;\\nposB.y=posM.y;\\nvec2 offNP;\\noffNP.x=(!horzSpan) ? 0.0 : texelSize.x;\\noffNP.y=(horzSpan) ? 0.0 : texelSize.y;\\nif (!horzSpan) \\n{\\nposB.x+=lengthSign*0.5;\\n}\\nif (horzSpan)\\n{\\nposB.y+=lengthSign*0.5;\\n}\\nvec2 posN;\\nposN.x=posB.x-offNP.x*1.5;\\nposN.y=posB.y-offNP.y*1.5;\\nvec2 posP;\\nposP.x=posB.x+offNP.x*1.5;\\nposP.y=posB.y+offNP.y*1.5;\\nfloat subpixD=((-2.0)*subpixC)+3.0;\\nfloat lumaEndN=FxaaLuma(texture2D(textureSampler,posN,0.0));\\nfloat subpixE=subpixC*subpixC;\\nfloat lumaEndP=FxaaLuma(texture2D(textureSampler,posP,0.0));\\nif (!pairN) \\n{\\nlumaNN=lumaSS;\\n}\\nfloat gradientScaled=gradient*1.0/4.0;\\nfloat lumaMM=lumaM-lumaNN*0.5;\\nfloat subpixF=subpixD*subpixE;\\nbool lumaMLTZero=lumaMM<0.0;\\nlumaEndN-=lumaNN*0.5;\\nlumaEndP-=lumaNN*0.5;\\nbool doneN=abs(lumaEndN)>=gradientScaled;\\nbool doneP=abs(lumaEndP)>=gradientScaled;\\nif (!doneN) \\n{\\nposN.x-=offNP.x*3.0;\\n}\\nif (!doneN) \\n{\\nposN.y-=offNP.y*3.0;\\n}\\nbool doneNP=(!doneN) || (!doneP);\\nif (!doneP) \\n{\\nposP.x+=offNP.x*3.0;\\n}\\nif (!doneP)\\n{\\nposP.y+=offNP.y*3.0;\\n}\\nif (doneNP)\\n{\\nif (!doneN) lumaEndN=FxaaLuma(texture2D(textureSampler,posN.xy,0.0));\\nif (!doneP) lumaEndP=FxaaLuma(texture2D(textureSampler,posP.xy,0.0));\\nif (!doneN) lumaEndN=lumaEndN-lumaNN*0.5;\\nif (!doneP) lumaEndP=lumaEndP-lumaNN*0.5;\\ndoneN=abs(lumaEndN)>=gradientScaled;\\ndoneP=abs(lumaEndP)>=gradientScaled;\\nif (!doneN) posN.x-=offNP.x*12.0;\\nif (!doneN) posN.y-=offNP.y*12.0;\\ndoneNP=(!doneN) || (!doneP);\\nif (!doneP) posP.x+=offNP.x*12.0;\\nif (!doneP) posP.y+=offNP.y*12.0;\\n}\\nfloat dstN=posM.x-posN.x;\\nfloat dstP=posP.x-posM.x;\\nif (!horzSpan)\\n{\\ndstN=posM.y-posN.y;\\n}\\nif (!horzSpan) \\n{\\ndstP=posP.y-posM.y;\\n}\\nbool goodSpanN=(lumaEndN<0.0) != lumaMLTZero;\\nfloat spanLength=(dstP+dstN);\\nbool goodSpanP=(lumaEndP<0.0) != lumaMLTZero;\\nfloat spanLengthRcp=1.0/spanLength;\\nbool directionN=dstN<dstP;\\nfloat dst=min(dstN,dstP);\\nbool goodSpan=directionN ? goodSpanN : goodSpanP;\\nfloat subpixG=subpixF*subpixF;\\nfloat pixelOffset=(dst*(-spanLengthRcp))+0.5;\\nfloat subpixH=subpixG*fxaaQualitySubpix;\\nfloat pixelOffsetGood=goodSpan ? pixelOffset : 0.0;\\nfloat pixelOffsetSubpix=max(pixelOffsetGood,subpixH);\\nif (!horzSpan)\\n{\\nposM.x+=pixelOffsetSubpix*lengthSign;\\n}\\nif (horzSpan)\\n{\\nposM.y+=pixelOffsetSubpix*lengthSign;\\n}\\n#ifdef MALI\\nif(range<rangeMaxClamped) \\n{\\ngl_FragColor=rgbyM;\\n}\\nelse\\n{\\ngl_FragColor=texture2D(textureSampler,posM,0.0);\\n}\\n#else\\ngl_FragColor=texture2D(textureSampler,posM,0.0);\\n#endif\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var fxaaPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=fxaa.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"fxaaVertexShader\";\nvar shader = \"attribute vec2 position;\\nuniform vec2 texelSize;\\nvarying vec2 vUV;\\nvarying vec2 sampleCoordS;\\nvarying vec2 sampleCoordE;\\nvarying vec2 sampleCoordN;\\nvarying vec2 sampleCoordW;\\nvarying vec2 sampleCoordNW;\\nvarying vec2 sampleCoordSE;\\nvarying vec2 sampleCoordNE;\\nvarying vec2 sampleCoordSW;\\nconst vec2 madd=vec2(0.5,0.5);\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvUV=(position*madd+madd);\\nsampleCoordS=vUV+vec2( 0.0,1.0)*texelSize;\\nsampleCoordE=vUV+vec2( 1.0,0.0)*texelSize;\\nsampleCoordN=vUV+vec2( 0.0,-1.0)*texelSize;\\nsampleCoordW=vUV+vec2(-1.0,0.0)*texelSize;\\nsampleCoordNW=vUV+vec2(-1.0,-1.0)*texelSize;\\nsampleCoordSE=vUV+vec2( 1.0,1.0)*texelSize;\\nsampleCoordNE=vUV+vec2( 1.0,-1.0)*texelSize;\\nsampleCoordSW=vUV+vec2(-1.0,1.0)*texelSize;\\ngl_Position=vec4(position,0.0,1.0);\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var fxaaVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=fxaa.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"glowBlurPostProcessPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 screenSize;\\nuniform vec2 direction;\\nuniform float blurWidth;\\nfloat getLuminance(vec3 color)\\n{\\nreturn dot(color,vec3(0.2126,0.7152,0.0722));\\n}\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nfloat weights[7];\\nweights[0]=0.05;\\nweights[1]=0.1;\\nweights[2]=0.2;\\nweights[3]=0.3;\\nweights[4]=0.2;\\nweights[5]=0.1;\\nweights[6]=0.05;\\nvec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);\\nvec2 texelStep=texelSize*direction*blurWidth;\\nvec2 start=vUV-3.0*texelStep;\\nvec4 baseColor=vec4(0.,0.,0.,0.);\\nvec2 texelOffset=vec2(0.,0.);\\nfor (int i=0; i<7; i++)\\n{\\nvec4 texel=texture2D(textureSampler,start+texelOffset);\\nbaseColor.a+=texel.a*weights[i];\\nfloat luminance=getLuminance(baseColor.rgb);\\nfloat luminanceTexel=getLuminance(texel.rgb);\\nfloat choice=step(luminanceTexel,luminance);\\nbaseColor.rgb=choice*baseColor.rgb+(1.0-choice)*texel.rgb;\\ntexelOffset+=texelStep;\\n}\\ngl_FragColor=baseColor;\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var glowBlurPostProcessPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=glowBlurPostProcess.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nvar name = \"glowMapGenerationPixelShader\";\nvar shader = \"#if defined(DIFFUSE_ISLINEAR) || defined(EMISSIVE_ISLINEAR)\\n#include<helperFunctions>\\n#endif\\n#ifdef DIFFUSE\\nvarying vec2 vUVDiffuse;\\nuniform sampler2D diffuseSampler;\\n#endif\\n#ifdef OPACITY\\nvarying vec2 vUVOpacity;\\nuniform sampler2D opacitySampler;\\nuniform float opacityIntensity;\\n#endif\\n#ifdef EMISSIVE\\nvarying vec2 vUVEmissive;\\nuniform sampler2D emissiveSampler;\\n#endif\\n#ifdef VERTEXALPHA\\nvarying vec4 vColor;\\n#endif\\nuniform vec4 glowColor;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec4 finalColor=glowColor;\\n#ifdef DIFFUSE\\nvec4 albedoTexture=texture2D(diffuseSampler,vUVDiffuse);\\n#ifdef DIFFUSE_ISLINEAR\\nalbedoTexture=toGammaSpace(albedoTexture);\\n#endif\\n#ifdef GLOW\\nfinalColor.a*=albedoTexture.a;\\n#endif\\n#ifdef HIGHLIGHT\\nfinalColor.a=albedoTexture.a;\\n#endif\\n#endif\\n#ifdef OPACITY\\nvec4 opacityMap=texture2D(opacitySampler,vUVOpacity);\\n#ifdef OPACITYRGB\\nfinalColor.a*=getLuminance(opacityMap.rgb);\\n#else\\nfinalColor.a*=opacityMap.a;\\n#endif\\nfinalColor.a*=opacityIntensity;\\n#endif\\n#ifdef VERTEXALPHA\\nfinalColor.a*=vColor.a;\\n#endif\\n#ifdef ALPHATEST\\nif (finalColor.a<ALPHATESTVALUE)\\ndiscard;\\n#endif\\n#ifdef EMISSIVE\\nvec4 emissive=texture2D(emissiveSampler,vUVEmissive);\\n#ifdef EMISSIVE_ISLINEAR\\nemissive=toGammaSpace(emissive);\\n#endif\\ngl_FragColor=emissive*finalColor;\\n#else\\ngl_FragColor=finalColor;\\n#endif\\n#ifdef HIGHLIGHT\\ngl_FragColor.a=glowColor.a;\\n#endif\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var glowMapGenerationPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=glowMapGeneration.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nvar name = \"glowMapGenerationVertexShader\";\nvar shader = \"attribute vec3 position;\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\nvarying vec4 vPosition;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef DIFFUSE\\nvarying vec2 vUVDiffuse;\\nuniform mat4 diffuseMatrix;\\n#endif\\n#ifdef OPACITY\\nvarying vec2 vUVOpacity;\\nuniform mat4 opacityMatrix;\\n#endif\\n#ifdef EMISSIVE\\nvarying vec2 vUVEmissive;\\nuniform mat4 emissiveMatrix;\\n#endif\\n#ifdef VERTEXALPHA\\nattribute vec4 color;\\nvarying vec4 vColor;\\n#endif\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void)\\n{\\nvec3 positionUpdated=position;\\n#ifdef UV1\\nvec2 uvUpdated=uv;\\n#endif\\n#include<morphTargetsVertexGlobal>\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\n#ifdef CUBEMAP\\nvPosition=finalWorld*vec4(positionUpdated,1.0);\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n#else\\nvPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\ngl_Position=vPosition;\\n#endif\\n#ifdef DIFFUSE\\n#ifdef DIFFUSEUV1\\nvUVDiffuse=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#ifdef DIFFUSEUV2\\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n#ifdef OPACITY\\n#ifdef OPACITYUV1\\nvUVOpacity=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#ifdef OPACITYUV2\\nvUVOpacity=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n#ifdef EMISSIVE\\n#ifdef EMISSIVEUV1\\nvUVEmissive=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#ifdef EMISSIVEUV2\\nvUVEmissive=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n#ifdef VERTEXALPHA\\nvColor=color;\\n#endif\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var glowMapGenerationVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=glowMapGeneration.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"glowMapMergePixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#ifdef EMISSIVE\\nuniform sampler2D textureSampler2;\\n#endif\\nuniform float offset;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\nvec4 baseColor=texture2D(textureSampler,vUV);\\n#ifdef EMISSIVE\\nbaseColor+=texture2D(textureSampler2,vUV);\\nbaseColor*=offset;\\n#else\\nbaseColor.a=abs(offset-baseColor.a);\\n#ifdef STROKE\\nfloat alpha=smoothstep(.0,.1,baseColor.a);\\nbaseColor.a=alpha;\\nbaseColor.rgb=baseColor.rgb*alpha;\\n#endif\\n#endif\\n#if LDR\\nbaseColor=clamp(baseColor,0.,1.0);\\n#endif\\ngl_FragColor=baseColor;\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var glowMapMergePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=glowMapMerge.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"glowMapMergeVertexShader\";\nvar shader = \"attribute vec2 position;\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvUV=position*madd+madd;\\ngl_Position=vec4(position,0.0,1.0);\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var glowMapMergeVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=glowMapMerge.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneFragmentDeclaration2\";\nvar shader = \"#ifdef CLIPPLANE\\nin float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nin float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nin float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nin float fClipDistance4;\\n#endif\\n#ifdef CLIPPLANE5\\nin float fClipDistance5;\\n#endif\\n#ifdef CLIPPLANE6\\nin float fClipDistance6;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneFragmentDeclaration2 = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneFragmentDeclaration2.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration2.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nvar name = \"gpuRenderParticlesPixelShader\";\nvar shader = \"precision highp float;\\nuniform sampler2D diffuseSampler;\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n#include<clipPlaneFragmentDeclaration2> \\n#include<imageProcessingDeclaration>\\n#include<helperFunctions>\\n#include<imageProcessingFunctions>\\nvoid main() {\\n#include<clipPlaneFragment> \\nvec4 textureColor=texture2D(diffuseSampler,vUV);\\ngl_FragColor=textureColor*vColor;\\n#ifdef BLENDMULTIPLYMODE\\nfloat alpha=vColor.a*textureColor.a;\\ngl_FragColor.rgb=gl_FragColor.rgb*alpha+vec3(1.0)*(1.0-alpha);\\n#endif \\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\ngl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);\\n#else\\n#ifdef IMAGEPROCESSING\\ngl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);\\ngl_FragColor=applyImageProcessing(gl_FragColor);\\n#endif\\n#endif\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var gpuRenderParticlesPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=gpuRenderParticles.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"clipPlaneVertexDeclaration2\";\nvar shader = \"#ifdef CLIPPLANE\\nuniform vec4 vClipPlane;\\nout float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nuniform vec4 vClipPlane2;\\nout float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nuniform vec4 vClipPlane3;\\nout float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nuniform vec4 vClipPlane4;\\nout float fClipDistance4;\\n#endif\\n#ifdef CLIPPLANE5\\nuniform vec4 vClipPlane5;\\nout float fClipDistance5;\\n#endif\\n#ifdef CLIPPLANE6\\nuniform vec4 vClipPlane6;\\nout float fClipDistance6;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var clipPlaneVertexDeclaration2 = { name: name, shader: shader };\n//# sourceMappingURL=clipPlaneVertexDeclaration2.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration2.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nvar name = \"gpuRenderParticlesVertexShader\";\nvar shader = \"precision highp float;\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform vec2 translationPivot;\\nuniform vec3 worldOffset;\\n#ifdef LOCAL\\nuniform mat4 emitterWM;\\n#endif\\nattribute vec3 position;\\nattribute float age;\\nattribute float life;\\nattribute vec3 size;\\n#ifndef BILLBOARD\\nattribute vec3 initialDirection;\\n#endif\\n#ifdef BILLBOARDSTRETCHED\\nattribute vec3 direction;\\n#endif\\nattribute float angle;\\n#ifdef ANIMATESHEET\\nattribute float cellIndex;\\n#endif\\nattribute vec2 offset;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\nvarying vec3 vPositionW;\\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\\nuniform mat4 invView;\\n#endif\\n#include<clipPlaneVertexDeclaration2>\\n#ifdef COLORGRADIENTS\\nuniform sampler2D colorGradientSampler;\\n#else\\nuniform vec4 colorDead;\\nattribute vec4 color;\\n#endif\\n#ifdef ANIMATESHEET\\nuniform vec3 sheetInfos;\\n#endif\\n#ifdef BILLBOARD\\nuniform vec3 eyePosition;\\n#endif\\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\\nvec3 zaxis=normalize(cross(yaxis,xaxis));\\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\\nmat3 rotMatrix= mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\n#ifdef LOCAL\\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\\n#else\\nreturn (position+worldOffset)+alignedCorner;\\n#endif\\n}\\n#ifdef BILLBOARDSTRETCHED\\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\\nvec3 normalizedToCamera=normalize(toCamera);\\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\\nmat3 rotMatrix= mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\n#ifdef LOCAL\\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\\n#else\\nreturn (position+worldOffset)+alignedCorner;\\n#endif\\n}\\n#endif\\nvoid main() {\\n#ifdef ANIMATESHEET\\nfloat rowOffset=floor(cellIndex/sheetInfos.z);\\nfloat columnOffset=cellIndex-rowOffset*sheetInfos.z;\\nvec2 uvScale=sheetInfos.xy;\\nvec2 uvOffset=vec2(uv.x ,1.0-uv.y);\\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\\n#else\\nvUV=uv;\\n#endif\\nfloat ratio=age/life;\\n#ifdef COLORGRADIENTS\\nvColor=texture2D(colorGradientSampler,vec2(ratio,0));\\n#else\\nvColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);\\n#endif\\nvec2 cornerPos=(offset-translationPivot)*size.yz*size.x+translationPivot;\\n#ifdef BILLBOARD\\nvec4 rotatedCorner;\\nrotatedCorner.w=0.;\\n#ifdef BILLBOARDY\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.y=0.;\\nvec3 yaxis=(position+worldOffset)-eyePosition;\\nyaxis.y=0.;\\nvPositionW=rotate(normalize(yaxis),rotatedCorner.xyz);\\nvec4 viewPosition=(view*vec4(vPositionW,1.0));\\n#elif defined(BILLBOARDSTRETCHED)\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\nvec3 toCamera=(position+worldOffset)-eyePosition;\\nvPositionW=rotateAlign(toCamera,rotatedCorner.xyz);\\nvec4 viewPosition=(view*vec4(vPositionW,1.0));\\n#else\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\n#ifdef LOCAL\\nvec4 viewPosition=view*vec4(((emitterWM*vec4(position,1.0)).xyz+worldOffset),1.0)+rotatedCorner;\\n#else\\nvec4 viewPosition=view*vec4((position+worldOffset),1.0)+rotatedCorner;\\n#endif\\nvPositionW=(invView*viewPosition).xyz;\\n#endif\\n#else\\nvec3 rotatedCorner;\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=0.;\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nvec3 yaxis=normalize(initialDirection);\\nvPositionW=rotate(yaxis,rotatedCorner);\\nvec4 viewPosition=view*vec4(vPositionW,1.0);\\n#endif\\ngl_Position=projection*viewPosition;\\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\\nvec4 worldPos=vec4(vPositionW,1.0);\\n#endif\\n#include<clipPlaneVertex>\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var gpuRenderParticlesVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=gpuRenderParticles.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"gpuUpdateParticlesPixelShader\";\nvar shader = \"#version 300 es\\nvoid main() {\\ndiscard;\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var gpuUpdateParticlesPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=gpuUpdateParticles.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"gpuUpdateParticlesVertexShader\";\nvar shader = \"#version 300 es\\n#define PI 3.14159\\nuniform float currentCount;\\nuniform float timeDelta;\\nuniform float stopFactor;\\n#ifndef LOCAL\\nuniform mat4 emitterWM;\\n#endif\\nuniform vec2 lifeTime;\\nuniform vec2 emitPower;\\nuniform vec2 sizeRange;\\nuniform vec4 scaleRange;\\n#ifndef COLORGRADIENTS\\nuniform vec4 color1;\\nuniform vec4 color2;\\n#endif\\nuniform vec3 gravity;\\nuniform sampler2D randomSampler;\\nuniform sampler2D randomSampler2;\\nuniform vec4 angleRange;\\n#ifdef BOXEMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\nuniform vec3 minEmitBox;\\nuniform vec3 maxEmitBox;\\n#endif\\n#ifdef POINTEMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\n#endif\\n#ifdef HEMISPHERICEMITTER\\nuniform float radius;\\nuniform float radiusRange;\\nuniform float directionRandomizer;\\n#endif\\n#ifdef SPHEREEMITTER\\nuniform float radius;\\nuniform float radiusRange;\\n#ifdef DIRECTEDSPHEREEMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\n#else\\nuniform float directionRandomizer;\\n#endif\\n#endif\\n#ifdef CYLINDEREMITTER\\nuniform float radius;\\nuniform float height;\\nuniform float radiusRange;\\n#ifdef DIRECTEDCYLINDEREMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\n#else\\nuniform float directionRandomizer;\\n#endif\\n#endif\\n#ifdef CONEEMITTER\\nuniform vec2 radius;\\nuniform float coneAngle;\\nuniform vec2 height;\\nuniform float directionRandomizer;\\n#endif\\nin vec3 position;\\n#ifdef CUSTOMEMITTER\\nin vec3 initialPosition;\\n#endif\\nin float age;\\nin float life;\\nin vec4 seed;\\nin vec3 size;\\n#ifndef COLORGRADIENTS\\nin vec4 color;\\n#endif\\nin vec3 direction;\\n#ifndef BILLBOARD\\nin vec3 initialDirection;\\n#endif\\n#ifdef ANGULARSPEEDGRADIENTS\\nin float angle;\\n#else\\nin vec2 angle;\\n#endif\\n#ifdef ANIMATESHEET\\nin float cellIndex;\\n#ifdef ANIMATESHEETRANDOMSTART\\nin float cellStartOffset;\\n#endif\\n#endif\\n#ifdef NOISE\\nin vec3 noiseCoordinates1;\\nin vec3 noiseCoordinates2;\\n#endif\\nout vec3 outPosition;\\n#ifdef CUSTOMEMITTER\\nout vec3 outInitialPosition;\\n#endif\\nout float outAge;\\nout float outLife;\\nout vec4 outSeed;\\nout vec3 outSize;\\n#ifndef COLORGRADIENTS\\nout vec4 outColor;\\n#endif\\nout vec3 outDirection;\\n#ifndef BILLBOARD\\nout vec3 outInitialDirection;\\n#endif\\n#ifdef ANGULARSPEEDGRADIENTS\\nout float outAngle;\\n#else\\nout vec2 outAngle;\\n#endif\\n#ifdef ANIMATESHEET\\nout float outCellIndex;\\n#ifdef ANIMATESHEETRANDOMSTART\\nout float outCellStartOffset;\\n#endif\\n#endif\\n#ifdef NOISE\\nout vec3 outNoiseCoordinates1;\\nout vec3 outNoiseCoordinates2;\\n#endif\\n#ifdef SIZEGRADIENTS\\nuniform sampler2D sizeGradientSampler;\\n#endif \\n#ifdef ANGULARSPEEDGRADIENTS\\nuniform sampler2D angularSpeedGradientSampler;\\n#endif \\n#ifdef VELOCITYGRADIENTS\\nuniform sampler2D velocityGradientSampler;\\n#endif\\n#ifdef LIMITVELOCITYGRADIENTS\\nuniform sampler2D limitVelocityGradientSampler;\\nuniform float limitVelocityDamping;\\n#endif\\n#ifdef DRAGGRADIENTS\\nuniform sampler2D dragGradientSampler;\\n#endif\\n#ifdef NOISE\\nuniform vec3 noiseStrength;\\nuniform sampler2D noiseSampler;\\n#endif\\n#ifdef ANIMATESHEET\\nuniform vec4 cellInfos;\\n#endif\\nvec3 getRandomVec3(float offset) {\\nreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\\n}\\nvec4 getRandomVec4(float offset) {\\nreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\\n}\\nvoid main() {\\nfloat newAge=age+timeDelta; \\nif (newAge>=life && stopFactor != 0.) {\\nvec3 newPosition;\\nvec3 newDirection;\\nvec4 randoms=getRandomVec4(seed.x);\\noutLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\\noutAge=newAge-life;\\noutSeed=seed;\\n#ifdef SIZEGRADIENTS \\noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\\n#else\\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\\n#endif\\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\\noutSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; \\n#ifndef COLORGRADIENTS\\noutColor=color1+(color2-color1)*randoms.b;\\n#endif\\n#ifndef ANGULARSPEEDGRADIENTS \\noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\\noutAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\\n#else\\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\\n#endif \\n#ifdef POINTEMITTER\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\nnewPosition=vec3(0,0,0);\\nnewDirection=direction1+(direction2-direction1)*randoms3;\\n#elif defined(BOXEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\nnewPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\\nnewDirection=direction1+(direction2-direction1)*randoms3; \\n#elif defined(HEMISPHERICEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\nfloat phi=2.0*PI*randoms2.x;\\nfloat theta=acos(2.0*randoms2.y-1.0);\\nfloat randX=cos(phi)*sin(theta);\\nfloat randY=cos(theta);\\nfloat randZ=sin(phi)*sin(theta);\\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\\nnewDirection=newPosition+directionRandomizer*randoms3; \\n#elif defined(SPHEREEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\nfloat phi=2.0*PI*randoms2.x;\\nfloat theta=acos(2.0*randoms2.y-1.0);\\nfloat randX=cos(phi)*sin(theta);\\nfloat randY=cos(theta);\\nfloat randZ=sin(phi)*sin(theta);\\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\\n#ifdef DIRECTEDSPHEREEMITTER\\nnewDirection=normalize(direction1+(direction2-direction1)*randoms3);\\n#else\\nnewDirection=normalize(newPosition+directionRandomizer*randoms3);\\n#endif\\n#elif defined(CYLINDEREMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\nfloat yPos=(randoms2.x-0.5)*height;\\nfloat angle=randoms2.y*PI*2.;\\nfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\\nfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\\nfloat xPos=positionRadius*cos(angle);\\nfloat zPos=positionRadius*sin(angle);\\nnewPosition=vec3(xPos,yPos,zPos);\\n#ifdef DIRECTEDCYLINDEREMITTER\\nnewDirection=direction1+(direction2-direction1)*randoms3;\\n#else\\nangle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;\\nnewDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));\\nnewDirection=normalize(newDirection);\\n#endif\\n#elif defined(CONEEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nfloat s=2.0*PI*randoms2.x;\\n#ifdef CONEEMITTERSPAWNPOINT\\nfloat h=0.0001;\\n#else\\nfloat h=randoms2.y*height.y;\\nh=1.-h*h; \\n#endif\\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\\nlRadius=lRadius*h;\\nfloat randX=lRadius*sin(s);\\nfloat randZ=lRadius*cos(s);\\nfloat randY=h *height.x;\\nnewPosition=vec3(randX,randY,randZ); \\nif (abs(cos(coneAngle))==1.0) {\\nnewDirection=vec3(0.,1.0,0.);\\n} else {\\nvec3 randoms3=getRandomVec3(seed.z);\\nnewDirection=normalize(newPosition+directionRandomizer*randoms3); \\n}\\n#elif defined(CUSTOMEMITTER)\\nnewPosition=initialPosition;\\noutInitialPosition=initialPosition;\\n#else \\nnewPosition=vec3(0.,0.,0.);\\nnewDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\\n#endif\\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\\n#ifdef LOCAL\\noutPosition=newPosition;\\n#else\\noutPosition=(emitterWM*vec4(newPosition,1.)).xyz;\\n#endif\\n#ifdef CUSTOMEMITTER\\noutDirection=direction;\\n#ifndef BILLBOARD \\noutInitialDirection=direction;\\n#endif\\n#else\\n#ifdef LOCAL\\nvec3 initial=newDirection;\\n#else \\nvec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;\\n#endif\\noutDirection=initial*power;\\n#ifndef BILLBOARD \\noutInitialDirection=initial;\\n#endif\\n#endif\\n#ifdef ANIMATESHEET \\noutCellIndex=cellInfos.x;\\n#ifdef ANIMATESHEETRANDOMSTART\\noutCellStartOffset=randoms.a*outLife;\\n#endif \\n#endif\\n#ifdef NOISE\\noutNoiseCoordinates1=noiseCoordinates1;\\noutNoiseCoordinates2=noiseCoordinates2;\\n#endif\\n} else {\\nfloat directionScale=timeDelta;\\noutAge=newAge;\\nfloat ageGradient=newAge/life;\\n#ifdef VELOCITYGRADIENTS\\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\\n#endif\\n#ifdef DRAGGRADIENTS\\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\\n#endif\\n#if defined(CUSTOMEMITTER)\\noutPosition=position+(direction-position)*ageGradient; \\noutInitialPosition=initialPosition;\\n#else\\noutPosition=position+direction*directionScale;\\n#endif\\noutLife=life;\\noutSeed=seed;\\n#ifndef COLORGRADIENTS \\noutColor=color;\\n#endif\\n#ifdef SIZEGRADIENTS\\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\\noutSize.yz=size.yz;\\n#else\\noutSize=size;\\n#endif \\n#ifndef BILLBOARD \\noutInitialDirection=initialDirection;\\n#endif\\n#ifdef CUSTOMEMITTER\\noutDirection=direction;\\n#else\\nvec3 updatedDirection=direction+gravity*timeDelta;\\n#ifdef LIMITVELOCITYGRADIENTS\\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\\nfloat currentVelocity=length(updatedDirection);\\nif (currentVelocity>limitVelocity) {\\nupdatedDirection=updatedDirection*limitVelocityDamping;\\n}\\n#endif\\noutDirection=updatedDirection;\\n#ifdef NOISE\\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\\nfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\\nfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\\nvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\\noutDirection=outDirection+force*timeDelta;\\noutNoiseCoordinates1=noiseCoordinates1;\\noutNoiseCoordinates2=noiseCoordinates2;\\n#endif \\n#endif \\n#ifdef ANGULARSPEEDGRADIENTS\\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\\noutAngle=angle+angularSpeed*timeDelta;\\n#else\\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\\n#endif\\n#ifdef ANIMATESHEET \\nfloat offsetAge=outAge;\\nfloat dist=cellInfos.y-cellInfos.x;\\n#ifdef ANIMATESHEETRANDOMSTART\\noutCellStartOffset=cellStartOffset;\\noffsetAge+=cellStartOffset;\\n#else\\nfloat cellStartOffset=0.;\\n#endif \\nfloat ratio=0.;\\nif (cellInfos.w==1.0) {\\nratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);\\n}\\nelse {\\nratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);\\n}\\noutCellIndex=float(int(cellInfos.x+ratio*dist));\\n#endif\\n}\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var gpuUpdateParticlesVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=gpuUpdateParticles.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nvar name = \"grainPixelShader\";\nvar shader = \"#include<helperFunctions>\\nuniform sampler2D textureSampler; \\nuniform float intensity;\\nuniform float animatedSeed;\\nvarying vec2 vUV;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(textureSampler,vUV);\\nvec2 seed=vUV*(animatedSeed);\\nfloat grain=dither(seed,intensity);\\nfloat lum=getLuminance(gl_FragColor.rgb);\\nfloat grainAmount=(cos(-PI+(lum*PI*2.))+1.)/2.;\\ngl_FragColor.rgb+=grain*grainAmount;\\ngl_FragColor.rgb=max(gl_FragColor.rgb,0.0);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var grainPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=grain.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/importanceSampling.js\";\nimport \"./ShadersInclude/pbrBRDFFunctions.js\";\nimport \"./ShadersInclude/hdrFilteringFunctions.js\";\nvar name = \"hdrFilteringPixelShader\";\nvar shader = \"#include<helperFunctions>\\n#include<importanceSampling>\\n#include<pbrBRDFFunctions>\\n#include<hdrFilteringFunctions>\\nuniform float alphaG;\\nuniform samplerCube inputTexture;\\nuniform vec2 vFilteringInfo;\\nuniform float hdrScale;\\nvarying vec3 direction;\\nvoid main() {\\nvec3 color=radiance(alphaG,inputTexture,direction,vFilteringInfo);\\ngl_FragColor=vec4(color*hdrScale,1.0);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var hdrFilteringPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=hdrFiltering.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"hdrFilteringVertexShader\";\nvar shader = \"attribute vec2 position;\\nvarying vec3 direction;\\nuniform vec3 up;\\nuniform vec3 right;\\nuniform vec3 front;\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nmat3 view=mat3(up,right,front);\\ndirection=view*vec3(position,1.0);\\ngl_Position=vec4(position,0.0,1.0);\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var hdrFilteringVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=hdrFiltering.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"highlightsPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nconst vec3 RGBLuminanceCoefficients=vec3(0.2126,0.7152,0.0722);\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\nvec4 tex=texture2D(textureSampler,vUV);\\nvec3 c=tex.rgb;\\nfloat luma=dot(c.rgb,RGBLuminanceCoefficients);\\ngl_FragColor=vec4(pow(c,vec3(25.0-luma*15.0)),tex.a); \\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var highlightsPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=highlights.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nvar name = \"imageProcessingPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#include<imageProcessingDeclaration>\\n#include<helperFunctions>\\n#include<imageProcessingFunctions>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec4 result=texture2D(textureSampler,vUV);\\n#ifdef IMAGEPROCESSING\\n#ifndef FROMLINEARSPACE\\nresult.rgb=toLinearSpace(result.rgb);\\n#endif\\nresult=applyImageProcessing(result);\\n#else\\n#ifdef FROMLINEARSPACE\\nresult=applyImageProcessing(result);\\n#endif\\n#endif\\ngl_FragColor=result;\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var imageProcessingPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=imageProcessing.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"kernelBlurFragment\";\nvar shader = \"#ifdef DOF\\nfactor=sampleCoC(sampleCoord{X}); \\ncomputedWeight=KERNEL_WEIGHT{X}*factor;\\nsumOfWeights+=computedWeight;\\n#else\\ncomputedWeight=KERNEL_WEIGHT{X};\\n#endif\\n#ifdef PACKEDFLOAT\\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;\\n#else\\nblend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var kernelBlurFragment = { name: name, shader: shader };\n//# sourceMappingURL=kernelBlurFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"kernelBlurFragment2\";\nvar shader = \"#ifdef DOF\\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});\\ncomputedWeight=KERNEL_DEP_WEIGHT{X}*factor;\\nsumOfWeights+=computedWeight;\\n#else\\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\\n#endif\\n#ifdef PACKEDFLOAT\\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\\n#else\\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var kernelBlurFragment2 = { name: name, shader: shader };\n//# sourceMappingURL=kernelBlurFragment2.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration.js\";\nimport \"./ShadersInclude/packingFunctions.js\";\nimport \"./ShadersInclude/kernelBlurFragment.js\";\nimport \"./ShadersInclude/kernelBlurFragment2.js\";\nvar name = \"kernelBlurPixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\nuniform vec2 delta;\\nvarying vec2 sampleCenter;\\n#ifdef DOF\\nuniform sampler2D circleOfConfusionSampler;\\nuniform vec2 cameraMinMaxZ;\\nfloat sampleDistance(in vec2 offset) {\\nfloat depth=texture2D(circleOfConfusionSampler,offset).g; \\nreturn cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth; \\n}\\nfloat sampleCoC(in vec2 offset) {\\nfloat coc=texture2D(circleOfConfusionSampler,offset).r; \\nreturn coc; \\n}\\n#endif\\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\\n#ifdef PACKEDFLOAT\\n#include<packingFunctions>\\n#endif\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nfloat computedWeight=0.0;\\n#ifdef PACKEDFLOAT \\nfloat blend=0.;\\n#else\\nvec4 blend=vec4(0.);\\n#endif\\n#ifdef DOF\\nfloat sumOfWeights=CENTER_WEIGHT; \\nfloat factor=0.0;\\n#ifdef PACKEDFLOAT\\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\\n#else\\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\\n#endif\\n#endif\\n#include<kernelBlurFragment>[0..varyingCount]\\n#include<kernelBlurFragment2>[0..depCount]\\n#ifdef PACKEDFLOAT\\ngl_FragColor=pack(blend);\\n#else\\ngl_FragColor=blend;\\n#endif\\n#ifdef DOF\\ngl_FragColor/=sumOfWeights;\\n#endif\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var kernelBlurPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=kernelBlur.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"kernelBlurVertex\";\nvar shader = \"sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var kernelBlurVertex = { name: name, shader: shader };\n//# sourceMappingURL=kernelBlurVertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration.js\";\nimport \"./ShadersInclude/kernelBlurVertex.js\";\nvar name = \"kernelBlurVertexShader\";\nvar shader = \"attribute vec2 position;\\nuniform vec2 delta;\\nvarying vec2 sampleCenter;\\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\\nconst vec2 madd=vec2(0.5,0.5);\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nsampleCenter=(position*madd+madd);\\n#include<kernelBlurVertex>[0..varyingCount]\\ngl_Position=vec4(position,0.0,1.0);\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var kernelBlurVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=kernelBlur.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nvar name = \"layerPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec4 color;\\n#include<helperFunctions>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\nvec4 baseColor=texture2D(textureSampler,vUV);\\n#ifdef LINEAR\\nbaseColor.rgb=toGammaSpace(baseColor.rgb);\\n#endif\\n#ifdef ALPHATEST\\nif (baseColor.a<0.4)\\ndiscard;\\n#endif\\ngl_FragColor=baseColor*color;\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var layerPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=layer.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"layerVertexShader\";\nvar shader = \"attribute vec2 position;\\nuniform vec2 scale;\\nuniform vec2 offset;\\nuniform mat4 textureMatrix;\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec2 shiftedPosition=position*scale+offset;\\nvUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));\\ngl_Position=vec4(shiftedPosition,0.0,1.0);\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var layerVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=layer.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"lensFlarePixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec4 color;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\nvec4 baseColor=texture2D(textureSampler,vUV);\\ngl_FragColor=baseColor*color;\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var lensFlarePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=lensFlare.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"lensFlareVertexShader\";\nvar shader = \"attribute vec2 position;\\nuniform mat4 viewportMatrix;\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvUV=position*madd+madd;\\ngl_Position=viewportMatrix*vec4(position,0.0,1.0);\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var lensFlareVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=lensFlare.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"lensHighlightsPixelShader\";\nvar shader = \"uniform sampler2D textureSampler; \\nuniform float gain;\\nuniform float threshold;\\nuniform float screen_width;\\nuniform float screen_height;\\nvarying vec2 vUV;\\nvec4 highlightColor(vec4 color) {\\nvec4 highlight=color;\\nfloat luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));\\nfloat lum_threshold;\\nif (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }\\nelse { lum_threshold=0.5+0.44*threshold; }\\nluminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);\\nhighlight*=luminance*gain;\\nhighlight.a=1.0;\\nreturn highlight;\\n}\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec4 original=texture2D(textureSampler,vUV);\\nif (gain==-1.0) {\\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\\nreturn;\\n}\\nfloat w=2.0/screen_width;\\nfloat h=2.0/screen_height;\\nfloat weight=1.0;\\nvec4 blurred=vec4(0.0,0.0,0.0,0.0);\\n#ifdef PENTAGON\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));\\n#else\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));\\n#endif\\nblurred/=39.0;\\ngl_FragColor=blurred;\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var lensHighlightsPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=lensHighlights.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"minmaxReduxPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#if defined(INITIAL)\\nuniform sampler2D sourceTexture;\\nuniform vec2 texSize;\\nvoid main(void)\\n{\\nivec2 coord=ivec2(vUV*(texSize-1.0));\\nfloat f1=texelFetch(sourceTexture,coord,0).r;\\nfloat f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;\\nfloat f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;\\nfloat f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;\\nfloat minz=min(min(min(f1,f2),f3),f4);\\n#ifdef DEPTH_REDUX\\nfloat maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\\n#else\\nfloat maxz=max(max(max(f1,f2),f3),f4);\\n#endif\\nglFragColor=vec4(minz,maxz,0.,0.);\\n}\\n#elif defined(MAIN)\\nuniform vec2 texSize;\\nvoid main(void)\\n{\\nivec2 coord=ivec2(vUV*(texSize-1.0));\\nvec2 f1=texelFetch(textureSampler,coord,0).rg;\\nvec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;\\nvec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;\\nvec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;\\nfloat minz=min(min(min(f1.x,f2.x),f3.x),f4.x);\\nfloat maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);\\nglFragColor=vec4(minz,maxz,0.,0.);\\n}\\n#elif defined(ONEBEFORELAST)\\nuniform ivec2 texSize;\\nvoid main(void)\\n{\\nivec2 coord=ivec2(vUV*vec2(texSize-1));\\nvec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;\\nvec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;\\nvec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;\\nvec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;\\nfloat minz=min(f1.x,f2.x);\\nfloat maxz=max(f1.y,f2.y);\\nglFragColor=vec4(minz,maxz,0.,0.);\\n}\\n#elif defined(LAST)\\nvoid main(void)\\n{\\nglFragColor=vec4(0.);\\nif (true) { \\ndiscard;\\n}\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var minmaxReduxPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=minmaxRedux.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"motionBlurPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform float motionStrength;\\nuniform float motionScale;\\nuniform vec2 screenSize;\\n#ifdef OBJECT_BASED\\nuniform sampler2D velocitySampler;\\n#else\\nuniform sampler2D depthSampler;\\nuniform mat4 inverseViewProjection;\\nuniform mat4 prevViewProjection;\\n#endif\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\n#ifdef GEOMETRY_SUPPORTED\\n#ifdef OBJECT_BASED\\nvec2 texelSize=1.0/screenSize;\\nvec4 velocityColor=texture2D(velocitySampler,vUV);\\nvelocityColor.rg=velocityColor.rg*2.0-vec2(1.0);\\nvec2 velocity=vec2(pow(velocityColor.r,3.0),pow(velocityColor.g,3.0))*velocityColor.a;\\nvelocity*=motionScale*motionStrength;\\nfloat speed=length(velocity/texelSize);\\nint samplesCount=int(clamp(speed,1.0,SAMPLES));\\nvelocity=normalize(velocity)*texelSize;\\nfloat hlim=float(-samplesCount)*0.5+0.5;\\nvec4 result=texture2D(textureSampler,vUV);\\nfor (int i=1; i<int(SAMPLES); ++i)\\n{\\nif (i>=samplesCount)\\nbreak;\\nvec2 offset=vUV+velocity*(hlim+float(i));\\nresult+=texture2D(textureSampler,offset);\\n}\\ngl_FragColor=result/float(samplesCount);\\ngl_FragColor.a=1.0;\\n#else\\nvec2 texelSize=1.0/screenSize;\\nfloat depth=texture2D(depthSampler,vUV).r;\\nvec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);\\ncpos=cpos*inverseViewProjection;\\nvec4 ppos=cpos*prevViewProjection;\\nppos.xyz/=ppos.w;\\nppos.xy=ppos.xy*0.5+0.5;\\nvec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;\\nfloat speed=length(velocity/texelSize);\\nint nSamples=int(clamp(speed,1.0,SAMPLES));\\nvec4 result=texture2D(textureSampler,vUV);\\nfor (int i=1; i<int(SAMPLES); ++i) {\\nif (i>=nSamples)\\nbreak;\\nvec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);\\nresult+=texture2D(textureSampler,offset1);\\n}\\ngl_FragColor=result/float(nSamples);\\n#endif\\n#else\\ngl_FragColor=texture2D(textureSampler,vUV);\\n#endif\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var motionBlurPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=motionBlur.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"noisePixelShader\";\nvar shader = \"uniform float brightness;\\nuniform float persistence;\\nuniform float timeScale;\\nvarying vec2 vUV;\\nvec2 hash22(vec2 p)\\n{\\np=p*mat2(127.1,311.7,269.5,183.3);\\np=-1.0+2.0*fract(sin(p)*43758.5453123);\\nreturn sin(p*6.283+timeScale);\\n}\\nfloat interpolationNoise(vec2 p)\\n{\\nvec2 pi=floor(p);\\nvec2 pf=p-pi;\\nvec2 w=pf*pf*(3.-2.*pf);\\nfloat f00=dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\\nfloat f01=dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\\nfloat f10=dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\\nfloat f11=dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\\nfloat xm1=mix(f00,f10,w.x);\\nfloat xm2=mix(f01,f11,w.x);\\nfloat ym=mix(xm1,xm2,w.y); \\nreturn ym;\\n}\\nfloat perlinNoise2D(float x,float y)\\n{\\nfloat sum=0.0;\\nfloat frequency=0.0;\\nfloat amplitude=0.0;\\nfor(int i=0; i<OCTAVES; i++)\\n{\\nfrequency=pow(2.0,float(i));\\namplitude=pow(persistence,float(i));\\nsum=sum+interpolationNoise(vec2(x*frequency,y*frequency))*amplitude;\\n}\\nreturn sum;\\n}\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nfloat x=abs(vUV.x);\\nfloat y=abs(vUV.y);\\nfloat noise=brightness+(1.0-brightness)*perlinNoise2D(x,y);\\ngl_FragColor=vec4(noise,noise,noise,1.0);\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var noisePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=noise.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nvar name = \"particlesPixelShader\";\nvar shader = \"varying vec2 vUV;\\nvarying vec4 vColor;\\nuniform vec4 textureMask;\\nuniform sampler2D diffuseSampler;\\n#include<clipPlaneFragmentDeclaration>\\n#include<imageProcessingDeclaration>\\n#include<helperFunctions>\\n#include<imageProcessingFunctions>\\n#ifdef RAMPGRADIENT\\nvarying vec4 remapRanges;\\nuniform sampler2D rampSampler;\\n#endif\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<clipPlaneFragment>\\nvec4 textureColor=texture2D(diffuseSampler,vUV);\\nvec4 baseColor=(textureColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;\\n#ifdef RAMPGRADIENT\\nfloat alpha=baseColor.a;\\nfloat remappedColorIndex=clamp((alpha-remapRanges.x)/remapRanges.y,0.0,1.0);\\nvec4 rampColor=texture2D(rampSampler,vec2(1.0-remappedColorIndex,0.));\\nbaseColor.rgb*=rampColor.rgb;\\nfloat finalAlpha=baseColor.a;\\nbaseColor.a=clamp((alpha*rampColor.a-remapRanges.z)/remapRanges.w,0.0,1.0);\\n#endif\\n#ifdef BLENDMULTIPLYMODE\\nfloat sourceAlpha=vColor.a*textureColor.a;\\nbaseColor.rgb=baseColor.rgb*sourceAlpha+vec3(1.0)*(1.0-sourceAlpha);\\n#endif\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\\n#else\\n#ifdef IMAGEPROCESSING\\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\\nbaseColor=applyImageProcessing(baseColor);\\n#endif\\n#endif\\ngl_FragColor=baseColor;\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var particlesPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=particles.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nvar name = \"particlesVertexShader\";\nvar shader = \"attribute vec3 position;\\nattribute vec4 color;\\nattribute float angle;\\nattribute vec2 size;\\n#ifdef ANIMATESHEET\\nattribute float cellIndex;\\n#endif\\n#ifndef BILLBOARD\\nattribute vec3 direction;\\n#endif\\n#ifdef BILLBOARDSTRETCHED\\nattribute vec3 direction;\\n#endif\\n#ifdef RAMPGRADIENT\\nattribute vec4 remapData;\\n#endif\\nattribute vec2 offset;\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform vec2 translationPivot;\\n#ifdef ANIMATESHEET\\nuniform vec3 particlesInfos; \\n#endif\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\nvarying vec3 vPositionW;\\n#ifdef RAMPGRADIENT\\nvarying vec4 remapRanges;\\n#endif\\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\\nuniform mat4 invView;\\n#endif\\n#include<clipPlaneVertexDeclaration>\\n#ifdef BILLBOARD\\nuniform vec3 eyePosition;\\n#endif\\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\\nvec3 zaxis=normalize(cross(yaxis,xaxis));\\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\\nmat3 rotMatrix= mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\nreturn position+alignedCorner;\\n}\\n#ifdef BILLBOARDSTRETCHED\\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\\nvec3 normalizedToCamera=normalize(toCamera);\\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\\nmat3 rotMatrix= mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\nreturn position+alignedCorner;\\n}\\n#endif\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec2 cornerPos;\\ncornerPos=(vec2(offset.x-0.5,offset.y -0.5)-translationPivot)*size+translationPivot;\\n#ifdef BILLBOARD\\nvec3 rotatedCorner;\\n#ifdef BILLBOARDY\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.y=0.;\\nvec3 yaxis=position-eyePosition;\\nyaxis.y=0.;\\nvPositionW=rotate(normalize(yaxis),rotatedCorner);\\nvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\\n#elif defined(BILLBOARDSTRETCHED)\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\nvec3 toCamera=position-eyePosition;\\nvPositionW=rotateAlign(toCamera,rotatedCorner);\\nvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\\n#else\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\nvec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;\\nvPositionW=(invView*vec4(viewPos,1)).xyz;\\n#endif\\n#ifdef RAMPGRADIENT\\nremapRanges=remapData;\\n#endif\\ngl_Position=projection*vec4(viewPos,1.0);\\n#else\\nvec3 rotatedCorner;\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.y=0.;\\nvec3 yaxis=normalize(direction);\\nvPositionW=rotate(yaxis,rotatedCorner);\\ngl_Position=projection*view*vec4(vPositionW,1.0);\\n#endif\\nvColor=color;\\n#ifdef ANIMATESHEET\\nfloat rowOffset=floor(cellIndex*particlesInfos.z);\\nfloat columnOffset=cellIndex-rowOffset/particlesInfos.z;\\nvec2 uvScale=particlesInfos.xy;\\nvec2 uvOffset=vec2(offset.x ,1.0-offset.y);\\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\\n#else\\nvUV=offset;\\n#endif\\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\\nvec4 worldPos=vec4(vPositionW,1.0);\\n#endif\\n#include<clipPlaneVertex>\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var particlesVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=particles.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"passPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\ngl_FragColor=texture2D(textureSampler,vUV);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var passPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=pass.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"passCubePixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform samplerCube textureSampler;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\nvec2 uv=vUV*2.0-1.0;\\n#ifdef POSITIVEX\\ngl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));\\n#endif\\n#ifdef NEGATIVEX\\ngl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));\\n#endif\\n#ifdef POSITIVEY\\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));\\n#endif\\n#ifdef NEGATIVEY\\ngl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));\\n#endif\\n#ifdef POSITIVEZ\\ngl_FragColor=textureCube(textureSampler,vec3(uv,1.001));\\n#endif\\n#ifdef NEGATIVEZ\\ngl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));\\n#endif\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var passCubePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=passCube.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrFragmentDeclaration\";\nvar shader = \"uniform vec4 vEyePosition;\\nuniform vec3 vReflectionColor;\\nuniform vec4 vAlbedoColor;\\nuniform vec4 vLightingIntensity;\\nuniform vec4 vReflectivityColor;\\nuniform vec4 vMetallicReflectanceFactors;\\nuniform vec3 vEmissiveColor;\\nuniform float visibility;\\nuniform vec3 vAmbientColor;\\n#ifdef ALBEDO\\nuniform vec2 vAlbedoInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform vec4 vAmbientInfos;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform vec2 vTangentSpaceParams;\\n#endif\\n#ifdef OPACITY\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\n#endif\\n#ifdef REFLECTIVITY\\nuniform vec3 vReflectivityInfos;\\n#endif\\n#ifdef MICROSURFACEMAP\\nuniform vec2 vMicroSurfaceSamplerInfos;\\n#endif\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)\\nuniform mat4 view;\\n#endif\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\n#ifdef REALTIME_FILTERING\\nuniform vec2 vReflectionFilteringInfo;\\n#endif\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\\nuniform vec3 vReflectionPosition;\\nuniform vec3 vReflectionSize; \\n#endif\\n#endif\\n#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)\\nuniform vec3 vRefractionPosition;\\nuniform vec3 vRefractionSize; \\n#endif\\n#ifdef CLEARCOAT\\nuniform vec2 vClearCoatParams;\\nuniform vec4 vClearCoatRefractionParams;\\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\\nuniform vec4 vClearCoatInfos;\\n#endif\\n#ifdef CLEARCOAT_TEXTURE\\nuniform mat4 clearCoatMatrix;\\n#endif\\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\\nuniform mat4 clearCoatRoughnessMatrix;\\n#endif\\n#ifdef CLEARCOAT_BUMP\\nuniform vec2 vClearCoatBumpInfos;\\nuniform vec2 vClearCoatTangentSpaceParams;\\nuniform mat4 clearCoatBumpMatrix;\\n#endif\\n#ifdef CLEARCOAT_TINT\\nuniform vec4 vClearCoatTintParams;\\nuniform float clearCoatColorAtDistance;\\n#ifdef CLEARCOAT_TINT_TEXTURE\\nuniform vec2 vClearCoatTintInfos;\\nuniform mat4 clearCoatTintMatrix;\\n#endif\\n#endif\\n#endif\\n#ifdef IRIDESCENCE\\nuniform vec4 vIridescenceParams;\\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\\nuniform vec4 vIridescenceInfos;\\n#endif\\n#ifdef IRIDESCENCE_TEXTURE\\nuniform mat4 iridescenceMatrix;\\n#endif\\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\\nuniform mat4 iridescenceThicknessMatrix;\\n#endif\\n#endif\\n#ifdef ANISOTROPIC\\nuniform vec3 vAnisotropy;\\n#ifdef ANISOTROPIC_TEXTURE\\nuniform vec2 vAnisotropyInfos;\\nuniform mat4 anisotropyMatrix;\\n#endif\\n#endif\\n#ifdef SHEEN\\nuniform vec4 vSheenColor;\\n#ifdef SHEEN_ROUGHNESS\\nuniform float vSheenRoughness;\\n#endif\\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\\nuniform vec4 vSheenInfos;\\n#endif\\n#ifdef SHEEN_TEXTURE\\nuniform mat4 sheenMatrix;\\n#endif\\n#ifdef SHEEN_TEXTURE_ROUGHNESS\\nuniform mat4 sheenRoughnessMatrix;\\n#endif\\n#endif\\n#ifdef SUBSURFACE\\n#ifdef SS_REFRACTION\\nuniform vec4 vRefractionMicrosurfaceInfos;\\nuniform vec4 vRefractionInfos;\\nuniform mat4 refractionMatrix;\\n#ifdef REALTIME_FILTERING\\nuniform vec2 vRefractionFilteringInfo;\\n#endif\\n#endif\\n#ifdef SS_THICKNESSANDMASK_TEXTURE\\nuniform vec2 vThicknessInfos;\\nuniform mat4 thicknessMatrix;\\n#endif\\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\\nuniform vec2 vRefractionIntensityInfos;\\nuniform mat4 refractionIntensityMatrix;\\n#endif\\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\\nuniform vec2 vTranslucencyIntensityInfos;\\nuniform mat4 translucencyIntensityMatrix;\\n#endif\\nuniform vec2 vThicknessParam;\\nuniform vec3 vDiffusionDistance;\\nuniform vec4 vTintColor;\\nuniform vec3 vSubSurfaceIntensity;\\n#endif\\n#ifdef PREPASS\\n#ifdef SS_SCATTERING\\nuniform float scatteringDiffusionProfile;\\n#endif\\n#endif\\n#if DEBUGMODE>0\\nuniform vec2 vDebugMode;\\n#endif\\n#ifdef DETAIL\\nuniform vec4 vDetailInfos;\\n#endif\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#ifdef SPHERICAL_HARMONICS\\nuniform vec3 vSphericalL00;\\nuniform vec3 vSphericalL1_1;\\nuniform vec3 vSphericalL10;\\nuniform vec3 vSphericalL11;\\nuniform vec3 vSphericalL2_2;\\nuniform vec3 vSphericalL2_1;\\nuniform vec3 vSphericalL20;\\nuniform vec3 vSphericalL21;\\nuniform vec3 vSphericalL22;\\n#else\\nuniform vec3 vSphericalX;\\nuniform vec3 vSphericalY;\\nuniform vec3 vSphericalZ;\\nuniform vec3 vSphericalXX_ZZ;\\nuniform vec3 vSphericalYY_ZZ;\\nuniform vec3 vSphericalZZ;\\nuniform vec3 vSphericalXY;\\nuniform vec3 vSphericalYZ;\\nuniform vec3 vSphericalZX;\\n#endif\\n#endif\\n#define ADDITIONAL_FRAGMENT_DECLARATION\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrFragmentDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=pbrFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./mainUVVaryingDeclaration.js\";\nvar name = \"pbrFragmentExtraDeclaration\";\nvar shader = \"varying vec3 vPositionW;\\n#if DEBUGMODE>0\\nvarying vec4 vClipSpacePosition;\\n#endif\\n#include<mainUVVaryingDeclaration>[1..7]\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\\nvarying vec3 vEnvironmentIrradiance;\\n#endif\\n#endif\\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\nvarying vec4 vColor;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrFragmentExtraDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=pbrFragmentExtraDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"samplerFragmentAlternateDeclaration\";\nvar shader = \"#ifdef _DEFINENAME_\\n#if _DEFINENAME_DIRECTUV==1\\n#define v_VARYINGNAME_UV vMainUV1\\n#elif _DEFINENAME_DIRECTUV==2\\n#define v_VARYINGNAME_UV vMainUV2\\n#elif _DEFINENAME_DIRECTUV==3\\n#define v_VARYINGNAME_UV vMainUV3\\n#elif _DEFINENAME_DIRECTUV==4\\n#define v_VARYINGNAME_UV vMainUV4\\n#elif _DEFINENAME_DIRECTUV==5\\n#define v_VARYINGNAME_UV vMainUV5\\n#elif _DEFINENAME_DIRECTUV==6\\n#define v_VARYINGNAME_UV vMainUV6\\n#else\\nvarying vec2 v_VARYINGNAME_UV;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var samplerFragmentAlternateDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=samplerFragmentAlternateDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./samplerFragmentDeclaration.js\";\nimport \"./samplerFragmentAlternateDeclaration.js\";\nvar name = \"pbrFragmentSamplersDeclaration\";\nvar shader = \"#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)\\n#ifdef CLEARCOAT\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)\\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)\\nuniform sampler2D clearCoatRoughnessSampler;\\n#endif\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)\\n#endif\\n#ifdef IRIDESCENCE\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)\\n#endif\\n#ifdef SHEEN\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)\\n#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)\\nuniform sampler2D sheenRoughnessSampler;\\n#endif\\n#endif\\n#ifdef ANISOTROPIC\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)\\n#endif\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\n#define sampleReflection(s,c) textureCube(s,c)\\nuniform samplerCube reflectionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\\n#else\\nuniform samplerCube reflectionSamplerLow;\\nuniform samplerCube reflectionSamplerHigh;\\n#endif\\n#ifdef USEIRRADIANCEMAP\\nuniform samplerCube irradianceSampler;\\n#endif\\n#else\\n#define sampleReflection(s,c) texture2D(s,c)\\nuniform sampler2D reflectionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\\n#else\\nuniform sampler2D reflectionSamplerLow;\\nuniform sampler2D reflectionSamplerHigh;\\n#endif\\n#ifdef USEIRRADIANCEMAP\\nuniform sampler2D irradianceSampler;\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#endif\\n#ifdef ENVIRONMENTBRDF\\nuniform sampler2D environmentBrdfSampler;\\n#endif\\n#ifdef SUBSURFACE\\n#ifdef SS_REFRACTION\\n#ifdef SS_REFRACTIONMAP_3D\\n#define sampleRefraction(s,c) textureCube(s,c)\\nuniform samplerCube refractionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)\\n#else\\nuniform samplerCube refractionSamplerLow;\\nuniform samplerCube refractionSamplerHigh;\\n#endif\\n#else\\n#define sampleRefraction(s,c) texture2D(s,c)\\nuniform sampler2D refractionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)\\n#else\\nuniform sampler2D refractionSamplerLow;\\nuniform sampler2D refractionSamplerHigh;\\n#endif\\n#endif\\n#endif\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)\\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrFragmentSamplersDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=pbrFragmentSamplersDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrHelperFunctions\";\nvar shader = \"#define RECIPROCAL_PI2 0.15915494\\n#define RECIPROCAL_PI 0.31830988618\\n#define MINIMUMVARIANCE 0.0005\\nfloat convertRoughnessToAverageSlope(float roughness)\\n{\\nreturn square(roughness)+MINIMUMVARIANCE;\\n}\\nfloat fresnelGrazingReflectance(float reflectance0) {\\nfloat reflectance90=saturate(reflectance0*25.0);\\nreturn reflectance90;\\n}\\nvec2 getAARoughnessFactors(vec3 normalVector) {\\n#ifdef SPECULARAA\\nvec3 nDfdx=dFdx(normalVector.xyz);\\nvec3 nDfdy=dFdy(normalVector.xyz);\\nfloat slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));\\nfloat geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);\\nfloat geometricAlphaGFactor=sqrt(slopeSquare);\\ngeometricAlphaGFactor*=0.75;\\nreturn vec2(geometricRoughnessFactor,geometricAlphaGFactor);\\n#else\\nreturn vec2(0.);\\n#endif\\n}\\n#ifdef ANISOTROPIC\\nvec2 getAnisotropicRoughness(float alphaG,float anisotropy) {\\nfloat alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);\\nfloat alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);\\nreturn vec2(alphaT,alphaB);\\n}\\nvec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy) {\\nvec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;\\nvec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);\\nvec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);\\nvec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));\\nreturn anisotropicNormal;\\n}\\n#endif\\n#if defined(CLEARCOAT) || defined(SS_REFRACTION)\\nvec3 cocaLambert(vec3 alpha,float distance) {\\nreturn exp(-alpha*distance);\\n}\\nvec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {\\nreturn cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));\\n}\\nvec3 computeColorAtDistanceInMedia(vec3 color,float distance) {\\nreturn -log(color)/distance;\\n}\\nvec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\\nvec3 clearCoatAbsorption=mix(vec3(1.0),\\ncocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),\\nclearCoatIntensity);\\nreturn clearCoatAbsorption;\\n}\\n#endif\\n#ifdef MICROSURFACEAUTOMATIC\\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\\n{\\nconst float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\\nfloat reflectivityLuminance=getLuminance(reflectivityColor);\\nfloat reflectivityLuma=sqrt(reflectivityLuminance);\\nmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\\nreturn microSurface;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrHelperFunctions = { name: name, shader: shader };\n//# sourceMappingURL=pbrHelperFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrDirectLightingSetupFunctions\";\nvar shader = \"struct preLightingInfo\\n{\\nvec3 lightOffset;\\nfloat lightDistanceSquared;\\nfloat lightDistance;\\nfloat attenuation;\\nvec3 L;\\nvec3 H;\\nfloat NdotV;\\nfloat NdotLUnclamped;\\nfloat NdotL;\\nfloat VdotH;\\nfloat roughness;\\n#ifdef IRIDESCENCE\\nfloat iridescenceIntensity;\\n#endif\\n};\\npreLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {\\npreLightingInfo result;\\nresult.lightOffset=lightData.xyz-vPositionW;\\nresult.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);\\nresult.lightDistance=sqrt(result.lightDistanceSquared);\\nresult.L=normalize(result.lightOffset);\\nresult.H=normalize(V+result.L);\\nresult.VdotH=saturate(dot(V,result.H));\\nresult.NdotLUnclamped=dot(N,result.L);\\nresult.NdotL=saturateEps(result.NdotLUnclamped);\\nreturn result;\\n}\\npreLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {\\npreLightingInfo result;\\nresult.lightDistance=length(-lightData.xyz);\\nresult.L=normalize(-lightData.xyz);\\nresult.H=normalize(V+result.L);\\nresult.VdotH=saturate(dot(V,result.H));\\nresult.NdotLUnclamped=dot(N,result.L);\\nresult.NdotL=saturateEps(result.NdotLUnclamped);\\nreturn result;\\n}\\npreLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {\\npreLightingInfo result;\\nresult.NdotL=dot(N,lightData.xyz)*0.5+0.5;\\nresult.NdotL=saturateEps(result.NdotL);\\nresult.NdotLUnclamped=result.NdotL;\\n#ifdef SPECULARTERM\\nresult.L=normalize(lightData.xyz);\\nresult.H=normalize(V+result.L);\\nresult.VdotH=saturate(dot(V,result.H));\\n#endif\\nreturn result;\\n}\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrDirectLightingSetupFunctions = { name: name, shader: shader };\n//# sourceMappingURL=pbrDirectLightingSetupFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrDirectLightingFalloffFunctions\";\nvar shader = \"float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)\\n{\\nreturn max(0.,1.0-length(lightOffset)/range);\\n}\\nfloat computeDistanceLightFalloff_Physical(float lightDistanceSquared)\\n{\\nreturn 1.0/maxEps(lightDistanceSquared);\\n}\\nfloat computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)\\n{\\nfloat lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);\\nfloat factor=lightDistanceSquared*inverseSquaredRange;\\nfloat attenuation=saturate(1.0-factor*factor);\\nattenuation*=attenuation;\\nlightDistanceFalloff*=attenuation;\\nreturn lightDistanceFalloff;\\n}\\nfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)\\n{\\n#ifdef USEPHYSICALLIGHTFALLOFF\\nreturn computeDistanceLightFalloff_Physical(lightDistanceSquared);\\n#elif defined(USEGLTFLIGHTFALLOFF)\\nreturn computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);\\n#else\\nreturn computeDistanceLightFalloff_Standard(lightOffset,range);\\n#endif\\n}\\nfloat computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)\\n{\\nfloat falloff=0.0;\\nfloat cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));\\nif (cosAngle>=cosHalfAngle)\\n{\\nfalloff=max(0.,pow(cosAngle,exponent));\\n}\\nreturn falloff;\\n}\\nfloat computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)\\n{\\nconst float kMinusLog2ConeAngleIntensityRatio=6.64385618977; \\nfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);\\nvec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);\\nfloat falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));\\nreturn falloff;\\n}\\nfloat computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)\\n{\\nfloat cd=dot(-lightDirection,directionToLightCenterW);\\nfloat falloff=saturate(cd*lightAngleScale+lightAngleOffset);\\nfalloff*=falloff;\\nreturn falloff;\\n}\\nfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)\\n{\\n#ifdef USEPHYSICALLIGHTFALLOFF\\nreturn computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);\\n#elif defined(USEGLTFLIGHTFALLOFF)\\nreturn computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);\\n#else\\nreturn computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);\\n#endif\\n}\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrDirectLightingFalloffFunctions = { name: name, shader: shader };\n//# sourceMappingURL=pbrDirectLightingFalloffFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrDirectLightingFunctions\";\nvar shader = \"#define CLEARCOATREFLECTANCE90 1.0\\nstruct lightingInfo\\n{\\nvec3 diffuse;\\n#ifdef SPECULARTERM\\nvec3 specular;\\n#endif\\n#ifdef CLEARCOAT\\nvec4 clearCoat;\\n#endif\\n#ifdef SHEEN\\nvec3 sheen;\\n#endif\\n};\\nfloat adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {\\n#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)\\nfloat lightRoughness=lightRadius/lightDistance;\\nfloat totalRoughness=saturate(lightRoughness+roughness);\\nreturn totalRoughness;\\n#else\\nreturn roughness;\\n#endif\\n}\\nvec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {\\nreturn mix(groundColor,lightColor,info.NdotL);\\n}\\nvec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {\\nfloat diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);\\nreturn diffuseTerm*info.attenuation*info.NdotL*lightColor;\\n}\\n#define inline\\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\\nstrq/=strq.w;\\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\\nreturn toLinearSpace(textureColor);\\n}\\n#ifdef SS_TRANSLUCENCY\\nvec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {\\nfloat NdotL=absEps(info.NdotLUnclamped);\\nfloat wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);\\nfloat trAdapt=step(0.,info.NdotLUnclamped);\\nvec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);\\nfloat diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);\\nreturn diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;\\n}\\n#endif\\n#ifdef SPECULARTERM\\nvec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {\\nfloat NdotH=saturateEps(dot(N,info.H));\\nfloat roughness=max(info.roughness,geometricRoughnessFactor);\\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\\nvec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\\n#ifdef IRIDESCENCE\\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\\n#endif\\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\\n#ifdef BRDF_V_HEIGHT_CORRELATED\\nfloat smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);\\n#else\\nfloat smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);\\n#endif\\nvec3 specTerm=fresnel*distribution*smithVisibility;\\nreturn specTerm*info.attenuation*info.NdotL*lightColor;\\n}\\n#endif\\n#ifdef ANISOTROPIC\\nvec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {\\nfloat NdotH=saturateEps(dot(N,info.H));\\nfloat TdotH=dot(T,info.H);\\nfloat BdotH=dot(B,info.H);\\nfloat TdotV=dot(T,V);\\nfloat BdotV=dot(B,V);\\nfloat TdotL=dot(T,info.L);\\nfloat BdotL=dot(B,info.L);\\nfloat alphaG=convertRoughnessToAverageSlope(info.roughness);\\nvec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);\\nalphaTB=max(alphaTB,square(geometricRoughnessFactor));\\nvec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);\\n#ifdef IRIDESCENCE\\nfresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);\\n#endif\\nfloat distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);\\nfloat smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);\\nvec3 specTerm=fresnel*distribution*smithVisibility;\\nreturn specTerm*info.attenuation*info.NdotL*lightColor;\\n}\\n#endif\\n#ifdef CLEARCOAT\\nvec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {\\nfloat NccdotL=saturateEps(dot(Ncc,info.L));\\nfloat NccdotH=saturateEps(dot(Ncc,info.H));\\nfloat clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);\\nfloat alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\\nfloat fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);\\nfresnel*=clearCoatIntensity;\\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);\\nfloat kelemenVisibility=visibility_Kelemen(info.VdotH);\\nfloat clearCoatTerm=fresnel*distribution*kelemenVisibility;\\nreturn vec4(\\nclearCoatTerm*info.attenuation*NccdotL*lightColor,\\n1.0-fresnel\\n);\\n}\\nvec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {\\nvec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);\\nfloat NdotLRefract=saturateEps(dot(Ncc,LRefract));\\nvec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);\\nreturn absorption;\\n}\\n#endif\\n#ifdef SHEEN\\nvec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {\\nfloat NdotH=saturateEps(dot(N,info.H));\\nfloat roughness=max(info.roughness,geometricRoughnessFactor);\\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\\nfloat fresnel=1.;\\nfloat distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);\\n/*#ifdef SHEEN_SOFTER\\nfloat visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);\\n#else */\\nfloat visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);\\n/* #endif */\\nfloat sheenTerm=fresnel*distribution*visibility;\\nreturn sheenTerm*info.attenuation*info.NdotL*lightColor;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrDirectLightingFunctions = { name: name, shader: shader };\n//# sourceMappingURL=pbrDirectLightingFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrIBLFunctions\";\nvar shader = \"#if defined(REFLECTION) || defined(SS_REFRACTION)\\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {\\nfloat microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;\\nfloat lod=log2(microsurfaceAverageSlopeTexels);\\nreturn lod;\\n}\\nfloat getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {\\nfloat lod=log2(cubeMapDimensionPixels)*roughness;\\nreturn lod;\\n}\\n#endif\\n#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)\\nfloat environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {\\nfloat temp=NdotVUnclamped+ambientOcclusion;\\nreturn saturate(square(temp)-1.0+ambientOcclusion);\\n}\\n#endif\\n#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)\\nfloat environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {\\nvec3 reflection=reflect(view,normal);\\nfloat temp=saturate(1.0+1.1*dot(reflection,geometricNormal));\\nreturn square(temp);\\n}\\n#endif\\n#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)\\n#define UNPACK_LOD(x) (1.0-x)*255.0\\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {\\nfloat microsurfaceAverageSlope=alphaG;\\nmicrosurfaceAverageSlope*=sqrt(abs(NdotV));\\nreturn getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrIBLFunctions = { name: name, shader: shader };\n//# sourceMappingURL=pbrIBLFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockAlbedoOpacity\";\nvar shader = \"struct albedoOpacityOutParams\\n{\\nvec3 surfaceAlbedo;\\nfloat alpha;\\n};\\n#define pbr_inline\\nvoid albedoOpacityBlock(\\nin vec4 vAlbedoColor,\\n#ifdef ALBEDO\\nin vec4 albedoTexture,\\nin vec2 albedoInfos,\\n#endif\\n#ifdef OPACITY\\nin vec4 opacityMap,\\nin vec2 vOpacityInfos,\\n#endif\\n#ifdef DETAIL\\nin vec4 detailColor,\\nin vec4 vDetailInfos,\\n#endif\\nout albedoOpacityOutParams outParams\\n)\\n{\\nvec3 surfaceAlbedo=vAlbedoColor.rgb;\\nfloat alpha=vAlbedoColor.a;\\n#ifdef ALBEDO\\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\\nalpha*=albedoTexture.a;\\n#endif\\n#ifdef GAMMAALBEDO\\nsurfaceAlbedo*=toLinearSpace(albedoTexture.rgb);\\n#else\\nsurfaceAlbedo*=albedoTexture.rgb;\\n#endif\\nsurfaceAlbedo*=albedoInfos.y;\\n#endif\\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\nsurfaceAlbedo*=vColor.rgb;\\n#endif\\n#ifdef DETAIL\\nfloat detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);\\nsurfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; \\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_ALBEDO\\n#ifdef OPACITY\\n#ifdef OPACITYRGB\\nalpha=getLuminance(opacityMap.rgb);\\n#else\\nalpha*=opacityMap.a;\\n#endif\\nalpha*=vOpacityInfos.y;\\n#endif\\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR)\\nalpha*=vColor.a;\\n#endif\\n#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\\n#ifdef ALPHATEST\\nif (alpha<ALPHATESTVALUE)\\ndiscard;\\n#ifndef ALPHABLEND\\nalpha=1.0;\\n#endif\\n#endif\\n#endif\\noutParams.surfaceAlbedo=surfaceAlbedo;\\noutParams.alpha=alpha;\\n}\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockAlbedoOpacity = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockAlbedoOpacity.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockReflectivity\";\nvar shader = \"struct reflectivityOutParams\\n{\\nfloat microSurface;\\nfloat roughness;\\nvec3 surfaceReflectivityColor;\\n#ifdef METALLICWORKFLOW\\nvec3 surfaceAlbedo;\\n#endif\\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\\nvec3 ambientOcclusionColor;\\n#endif\\n#if DEBUGMODE>0\\nvec4 surfaceMetallicColorMap;\\nvec4 surfaceReflectivityColorMap;\\nvec2 metallicRoughness;\\nvec3 metallicF0;\\n#endif\\n};\\n#define pbr_inline\\nvoid reflectivityBlock(\\nin vec4 vReflectivityColor,\\n#ifdef METALLICWORKFLOW\\nin vec3 surfaceAlbedo,\\nin vec4 metallicReflectanceFactors,\\n#endif\\n#ifdef REFLECTIVITY\\nin vec3 reflectivityInfos,\\nin vec4 surfaceMetallicOrReflectivityColorMap,\\n#endif\\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\\nin vec3 ambientOcclusionColorIn,\\n#endif\\n#ifdef MICROSURFACEMAP\\nin vec4 microSurfaceTexel,\\n#endif\\n#ifdef DETAIL\\nin vec4 detailColor,\\nin vec4 vDetailInfos,\\n#endif\\nout reflectivityOutParams outParams\\n)\\n{\\nfloat microSurface=vReflectivityColor.a;\\nvec3 surfaceReflectivityColor=vReflectivityColor.rgb;\\n#ifdef METALLICWORKFLOW\\nvec2 metallicRoughness=surfaceReflectivityColor.rg;\\n#ifdef REFLECTIVITY\\n#if DEBUGMODE>0\\noutParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;\\n#endif\\n#ifdef AOSTOREINMETALMAPRED\\nvec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);\\noutParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);\\n#endif\\n#ifdef METALLNESSSTOREINMETALMAPBLUE\\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;\\n#else\\nmetallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;\\n#endif\\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;\\n#else\\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\\nmetallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;\\n#endif\\n#endif\\n#endif\\n#ifdef DETAIL\\nfloat detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);\\nfloat loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);\\nfloat hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);\\nmetallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));\\n#endif\\n#ifdef MICROSURFACEMAP\\nmetallicRoughness.g*=microSurfaceTexel.r;\\n#endif\\n#if DEBUGMODE>0\\noutParams.metallicRoughness=metallicRoughness;\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS\\nmicroSurface=1.0-metallicRoughness.g;\\nvec3 baseColor=surfaceAlbedo;\\n#ifdef FROSTBITE_REFLECTANCE\\noutParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);\\nsurfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);\\n#else\\nvec3 metallicF0=metallicReflectanceFactors.rgb;\\n#if DEBUGMODE>0\\noutParams.metallicF0=metallicF0;\\n#endif\\noutParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);\\nsurfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);\\n#endif\\n#else\\n#ifdef REFLECTIVITY\\nsurfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;\\n#if DEBUGMODE>0\\noutParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;\\n#endif\\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\\nmicroSurface*=surfaceMetallicOrReflectivityColorMap.a;\\nmicroSurface*=reflectivityInfos.z;\\n#else\\n#ifdef MICROSURFACEAUTOMATIC\\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\\n#endif\\n#ifdef MICROSURFACEMAP\\nmicroSurface*=microSurfaceTexel.r;\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE\\n#endif\\n#endif\\n#endif\\nmicroSurface=saturate(microSurface);\\nfloat roughness=1.-microSurface;\\noutParams.microSurface=microSurface;\\noutParams.roughness=roughness;\\noutParams.surfaceReflectivityColor=surfaceReflectivityColor;\\n}\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockReflectivity = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockReflectivity.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockAmbientOcclusion\";\nvar shader = \"struct ambientOcclusionOutParams\\n{\\nvec3 ambientOcclusionColor;\\n#if DEBUGMODE>0\\nvec3 ambientOcclusionColorMap;\\n#endif\\n};\\n#define pbr_inline\\nvoid ambientOcclusionBlock(\\n#ifdef AMBIENT\\nin vec3 ambientOcclusionColorMap_,\\nin vec4 vAmbientInfos,\\n#endif\\nout ambientOcclusionOutParams outParams\\n)\\n{\\nvec3 ambientOcclusionColor=vec3(1.,1.,1.);\\n#ifdef AMBIENT\\nvec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;\\n#ifdef AMBIENTINGRAYSCALE\\nambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\\n#endif\\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\\n#if DEBUGMODE>0\\noutParams.ambientOcclusionColorMap=ambientOcclusionColorMap;\\n#endif\\n#endif\\noutParams.ambientOcclusionColor=ambientOcclusionColor;\\n}\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockAmbientOcclusion = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockAmbientOcclusion.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockAlphaFresnel\";\nvar shader = \"#ifdef ALPHAFRESNEL\\n#if defined(ALPHATEST) || defined(ALPHABLEND)\\nstruct alphaFresnelOutParams\\n{\\nfloat alpha;\\n};\\n#define pbr_inline\\nvoid alphaFresnelBlock(\\nin vec3 normalW,\\nin vec3 viewDirectionW,\\nin float alpha,\\nin float microSurface,\\nout alphaFresnelOutParams outParams\\n)\\n{\\nfloat opacityPerceptual=alpha;\\n#ifdef LINEARALPHAFRESNEL\\nfloat opacity0=opacityPerceptual;\\n#else\\nfloat opacity0=opacityPerceptual*opacityPerceptual;\\n#endif\\nfloat opacity90=fresnelGrazingReflectance(opacity0);\\nvec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);\\noutParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;\\n#ifdef ALPHATEST\\nif (outParams.alpha<ALPHATESTVALUE)\\ndiscard;\\n#ifndef ALPHABLEND\\noutParams.alpha=1.0;\\n#endif\\n#endif\\n}\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockAlphaFresnel = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockAlphaFresnel.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockAnisotropic\";\nvar shader = \"#ifdef ANISOTROPIC\\nstruct anisotropicOutParams\\n{\\nfloat anisotropy;\\nvec3 anisotropicTangent;\\nvec3 anisotropicBitangent;\\nvec3 anisotropicNormal;\\n#if DEBUGMODE>0\\nvec3 anisotropyMapData;\\n#endif\\n};\\n#define pbr_inline\\nvoid anisotropicBlock(\\nin vec3 vAnisotropy,\\n#ifdef ANISOTROPIC_TEXTURE\\nin vec3 anisotropyMapData,\\n#endif\\nin mat3 TBN,\\nin vec3 normalW,\\nin vec3 viewDirectionW,\\nout anisotropicOutParams outParams\\n)\\n{\\nfloat anisotropy=vAnisotropy.b;\\nvec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);\\n#ifdef ANISOTROPIC_TEXTURE\\nanisotropy*=anisotropyMapData.b;\\nanisotropyDirection.rg*=anisotropyMapData.rg*2.0-1.0;\\n#if DEBUGMODE>0\\noutParams.anisotropyMapData=anisotropyMapData;\\n#endif\\n#endif\\nmat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));\\nvec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);\\nvec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));\\noutParams.anisotropy=anisotropy;\\noutParams.anisotropicTangent=anisotropicTangent;\\noutParams.anisotropicBitangent=anisotropicBitangent;\\noutParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy);\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockAnisotropic = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockAnisotropic.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockReflection\";\nvar shader = \"#ifdef REFLECTION\\nstruct reflectionOutParams\\n{\\nvec4 environmentRadiance;\\nvec3 environmentIrradiance;\\n#ifdef REFLECTIONMAP_3D\\nvec3 reflectionCoords;\\n#else\\nvec2 reflectionCoords;\\n#endif\\n#ifdef SS_TRANSLUCENCY\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\\nvec3 irradianceVector;\\n#endif\\n#endif\\n#endif\\n};\\n#define pbr_inline\\nvoid createReflectionCoords(\\nin vec3 vPositionW,\\nin vec3 normalW,\\n#ifdef ANISOTROPIC\\nin anisotropicOutParams anisotropicOut,\\n#endif\\n#ifdef REFLECTIONMAP_3D\\nout vec3 reflectionCoords\\n#else\\nout vec2 reflectionCoords\\n#endif\\n)\\n{\\n#ifdef ANISOTROPIC\\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);\\n#else\\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#endif\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nreflectionVector.z*=-1.0;\\n#endif\\n#ifdef REFLECTIONMAP_3D\\nreflectionCoords=reflectionVector;\\n#else\\nreflectionCoords=reflectionVector.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\nreflectionCoords/=reflectionVector.z;\\n#endif\\nreflectionCoords.y=1.0-reflectionCoords.y;\\n#endif\\n}\\n#define pbr_inline\\n#define inline\\nvoid sampleReflectionTexture(\\nin float alphaG,\\nin vec3 vReflectionMicrosurfaceInfos,\\nin vec2 vReflectionInfos,\\nin vec3 vReflectionColor,\\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\\nin float NdotVUnclamped,\\n#endif\\n#ifdef LINEARSPECULARREFLECTION\\nin float roughness,\\n#endif\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube reflectionSampler,\\nconst vec3 reflectionCoords,\\n#else\\nin sampler2D reflectionSampler,\\nconst vec2 reflectionCoords,\\n#endif\\n#ifndef LODBASEDMICROSFURACE\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube reflectionSamplerLow,\\nin samplerCube reflectionSamplerHigh,\\n#else\\nin sampler2D reflectionSamplerLow,\\nin sampler2D reflectionSamplerHigh,\\n#endif\\n#endif\\n#ifdef REALTIME_FILTERING\\nin vec2 vReflectionFilteringInfo,\\n#endif\\nout vec4 environmentRadiance\\n)\\n{\\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\\n#elif defined(LINEARSPECULARREFLECTION)\\nfloat reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);\\n#else\\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);\\n#endif\\n#ifdef LODBASEDMICROSFURACE\\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\\n#ifdef LODINREFLECTIONALPHA\\nfloat automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);\\nfloat requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);\\n#else\\nfloat requestedReflectionLOD=reflectionLOD;\\n#endif\\n#ifdef REALTIME_FILTERING\\nenvironmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);\\n#else\\nenvironmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\\n#endif\\n#else\\nfloat lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));\\nfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\\nvec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);\\nif (lodReflectionNormalizedDoubled<1.0){\\nenvironmentRadiance=mix(\\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\\nenvironmentMid,\\nlodReflectionNormalizedDoubled\\n);\\n} else {\\nenvironmentRadiance=mix(\\nenvironmentMid,\\nsampleReflection(reflectionSamplerLow,reflectionCoords),\\nlodReflectionNormalizedDoubled-1.0\\n);\\n}\\n#endif\\n#ifdef RGBDREFLECTION\\nenvironmentRadiance.rgb=fromRGBD(environmentRadiance);\\n#endif\\n#ifdef GAMMAREFLECTION\\nenvironmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);\\n#endif\\nenvironmentRadiance.rgb*=vReflectionInfos.x;\\nenvironmentRadiance.rgb*=vReflectionColor.rgb;\\n}\\n#define pbr_inline\\n#define inline\\nvoid reflectionBlock(\\nin vec3 vPositionW,\\nin vec3 normalW,\\nin float alphaG,\\nin vec3 vReflectionMicrosurfaceInfos,\\nin vec2 vReflectionInfos,\\nin vec3 vReflectionColor,\\n#ifdef ANISOTROPIC\\nin anisotropicOutParams anisotropicOut,\\n#endif\\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\\nin float NdotVUnclamped,\\n#endif\\n#ifdef LINEARSPECULARREFLECTION\\nin float roughness,\\n#endif\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube reflectionSampler,\\n#else\\nin sampler2D reflectionSampler,\\n#endif\\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\\nin vec3 vEnvironmentIrradiance,\\n#endif\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\\nin mat4 reflectionMatrix,\\n#endif\\n#endif\\n#ifdef USEIRRADIANCEMAP\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube irradianceSampler,\\n#else\\nin sampler2D irradianceSampler,\\n#endif\\n#endif\\n#ifndef LODBASEDMICROSFURACE\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube reflectionSamplerLow,\\nin samplerCube reflectionSamplerHigh,\\n#else\\nin sampler2D reflectionSamplerLow,\\nin sampler2D reflectionSamplerHigh,\\n#endif\\n#endif\\n#ifdef REALTIME_FILTERING\\nin vec2 vReflectionFilteringInfo,\\n#endif\\nout reflectionOutParams outParams\\n)\\n{\\nvec4 environmentRadiance=vec4(0.,0.,0.,0.);\\n#ifdef REFLECTIONMAP_3D\\nvec3 reflectionCoords=vec3(0.);\\n#else\\nvec2 reflectionCoords=vec2(0.);\\n#endif\\ncreateReflectionCoords(\\nvPositionW,\\nnormalW,\\n#ifdef ANISOTROPIC\\nanisotropicOut,\\n#endif\\nreflectionCoords\\n);\\nsampleReflectionTexture(\\nalphaG,\\nvReflectionMicrosurfaceInfos,\\nvReflectionInfos,\\nvReflectionColor,\\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\\nNdotVUnclamped,\\n#endif\\n#ifdef LINEARSPECULARREFLECTION\\nroughness,\\n#endif\\n#ifdef REFLECTIONMAP_3D\\nreflectionSampler,\\nreflectionCoords,\\n#else\\nreflectionSampler,\\nreflectionCoords,\\n#endif\\n#ifndef LODBASEDMICROSFURACE\\nreflectionSamplerLow,\\nreflectionSamplerHigh,\\n#endif\\n#ifdef REALTIME_FILTERING\\nvReflectionFilteringInfo,\\n#endif\\nenvironmentRadiance\\n);\\nvec3 environmentIrradiance=vec3(0.,0.,0.);\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\\nenvironmentIrradiance=vEnvironmentIrradiance;\\n#else\\n#ifdef ANISOTROPIC\\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;\\n#else\\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\\n#endif\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nirradianceVector.z*=-1.0;\\n#endif\\n#ifdef INVERTCUBICMAP\\nirradianceVector.y*=-1.0;\\n#endif\\n#if defined(REALTIME_FILTERING)\\nenvironmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);\\n#else\\nenvironmentIrradiance=computeEnvironmentIrradiance(irradianceVector);\\n#endif\\n#ifdef SS_TRANSLUCENCY\\noutParams.irradianceVector=irradianceVector;\\n#endif\\n#endif\\n#elif defined(USEIRRADIANCEMAP)\\nvec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);\\nenvironmentIrradiance=environmentIrradiance4.rgb;\\n#ifdef RGBDREFLECTION\\nenvironmentIrradiance.rgb=fromRGBD(environmentIrradiance4);\\n#endif\\n#ifdef GAMMAREFLECTION\\nenvironmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);\\n#endif\\n#endif\\nenvironmentIrradiance*=vReflectionColor.rgb;\\noutParams.environmentRadiance=environmentRadiance;\\noutParams.environmentIrradiance=environmentIrradiance;\\noutParams.reflectionCoords=reflectionCoords;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockReflection = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockReflection.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockSheen\";\nvar shader = \"#ifdef SHEEN\\nstruct sheenOutParams\\n{\\nfloat sheenIntensity;\\nvec3 sheenColor;\\nfloat sheenRoughness;\\n#ifdef SHEEN_LINKWITHALBEDO\\nvec3 surfaceAlbedo;\\n#endif\\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\\nfloat sheenAlbedoScaling;\\n#endif\\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\\nvec3 finalSheenRadianceScaled;\\n#endif\\n#if DEBUGMODE>0\\nvec4 sheenMapData;\\nvec3 sheenEnvironmentReflectance;\\n#endif\\n};\\n#define pbr_inline\\n#define inline\\nvoid sheenBlock(\\nin vec4 vSheenColor,\\n#ifdef SHEEN_ROUGHNESS\\nin float vSheenRoughness,\\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\\nin vec4 sheenMapRoughnessData,\\n#endif\\n#endif\\nin float roughness,\\n#ifdef SHEEN_TEXTURE\\nin vec4 sheenMapData,\\nin float sheenMapLevel,\\n#endif\\nin float reflectance,\\n#ifdef SHEEN_LINKWITHALBEDO\\nin vec3 baseColor,\\nin vec3 surfaceAlbedo,\\n#endif\\n#ifdef ENVIRONMENTBRDF\\nin float NdotV,\\nin vec3 environmentBrdf,\\n#endif\\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\\nin vec2 AARoughnessFactors,\\nin vec3 vReflectionMicrosurfaceInfos,\\nin vec2 vReflectionInfos,\\nin vec3 vReflectionColor,\\nin vec4 vLightingIntensity,\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube reflectionSampler,\\nin vec3 reflectionCoords,\\n#else\\nin sampler2D reflectionSampler,\\nin vec2 reflectionCoords,\\n#endif\\nin float NdotVUnclamped,\\n#ifndef LODBASEDMICROSFURACE\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube reflectionSamplerLow,\\nin samplerCube reflectionSamplerHigh,\\n#else\\nin sampler2D reflectionSamplerLow,\\nin sampler2D reflectionSamplerHigh,\\n#endif\\n#endif\\n#ifdef REALTIME_FILTERING\\nin vec2 vReflectionFilteringInfo,\\n#endif\\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\\nin float seo,\\n#endif\\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\\nin float eho,\\n#endif\\n#endif\\nout sheenOutParams outParams\\n)\\n{\\nfloat sheenIntensity=vSheenColor.a;\\n#ifdef SHEEN_TEXTURE\\n#if DEBUGMODE>0\\noutParams.sheenMapData=sheenMapData;\\n#endif\\n#endif\\n#ifdef SHEEN_LINKWITHALBEDO\\nfloat sheenFactor=pow5(1.0-sheenIntensity);\\nvec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);\\nfloat sheenRoughness=sheenIntensity;\\noutParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;\\n#ifdef SHEEN_TEXTURE\\nsheenIntensity*=sheenMapData.a;\\n#endif\\n#else\\nvec3 sheenColor=vSheenColor.rgb;\\n#ifdef SHEEN_TEXTURE\\n#ifdef SHEEN_GAMMATEXTURE\\nsheenColor.rgb*=toLinearSpace(sheenMapData.rgb);\\n#else\\nsheenColor.rgb*=sheenMapData.rgb;\\n#endif\\nsheenColor.rgb*=sheenMapLevel;\\n#endif\\n#ifdef SHEEN_ROUGHNESS\\nfloat sheenRoughness=vSheenRoughness;\\n#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE\\n#if defined(SHEEN_TEXTURE)\\nsheenRoughness*=sheenMapData.a;\\n#endif\\n#elif defined(SHEEN_TEXTURE_ROUGHNESS)\\n#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL\\nsheenRoughness*=sheenMapData.a;\\n#else\\nsheenRoughness*=sheenMapRoughnessData.a;\\n#endif\\n#endif\\n#else\\nfloat sheenRoughness=roughness;\\n#ifdef SHEEN_TEXTURE\\nsheenIntensity*=sheenMapData.a;\\n#endif\\n#endif\\n#if !defined(SHEEN_ALBEDOSCALING)\\nsheenIntensity*=(1.-reflectance);\\n#endif\\nsheenColor*=sheenIntensity;\\n#endif\\n#ifdef ENVIRONMENTBRDF\\n/*#ifdef SHEEN_SOFTER\\nvec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));\\n#else*/\\n#ifdef SHEEN_ROUGHNESS\\nvec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);\\n#else\\nvec3 environmentSheenBrdf=environmentBrdf;\\n#endif\\n/*#endif*/\\n#endif\\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\\nfloat sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);\\n#ifdef SPECULARAA\\nsheenAlphaG+=AARoughnessFactors.y;\\n#endif\\nvec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);\\nsampleReflectionTexture(\\nsheenAlphaG,\\nvReflectionMicrosurfaceInfos,\\nvReflectionInfos,\\nvReflectionColor,\\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\\nNdotVUnclamped,\\n#endif\\n#ifdef LINEARSPECULARREFLECTION\\nsheenRoughness,\\n#endif\\nreflectionSampler,\\nreflectionCoords,\\n#ifndef LODBASEDMICROSFURACE\\nreflectionSamplerLow,\\nreflectionSamplerHigh,\\n#endif\\n#ifdef REALTIME_FILTERING\\nvReflectionFilteringInfo,\\n#endif\\nenvironmentSheenRadiance\\n);\\nvec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);\\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\\nsheenEnvironmentReflectance*=seo;\\n#endif\\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\\nsheenEnvironmentReflectance*=eho;\\n#endif\\n#if DEBUGMODE>0\\noutParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;\\n#endif\\noutParams.finalSheenRadianceScaled=\\nenvironmentSheenRadiance.rgb *\\nsheenEnvironmentReflectance *\\nvLightingIntensity.z;\\n#endif\\n#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\\noutParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;\\n#endif\\noutParams.sheenIntensity=sheenIntensity;\\noutParams.sheenColor=sheenColor;\\noutParams.sheenRoughness=sheenRoughness;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockSheen = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockSheen.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockClearcoat\";\nvar shader = \"struct clearcoatOutParams\\n{\\nvec3 specularEnvironmentR0;\\nfloat conservationFactor;\\nvec3 clearCoatNormalW;\\nvec2 clearCoatAARoughnessFactors;\\nfloat clearCoatIntensity;\\nfloat clearCoatRoughness;\\n#ifdef REFLECTION\\nvec3 finalClearCoatRadianceScaled;\\n#endif\\n#ifdef CLEARCOAT_TINT\\nvec3 absorption;\\nfloat clearCoatNdotVRefract;\\nvec3 clearCoatColor;\\nfloat clearCoatThickness;\\n#endif\\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\\nvec3 energyConservationFactorClearCoat;\\n#endif\\n#if DEBUGMODE>0\\nmat3 TBNClearCoat;\\nvec2 clearCoatMapData;\\nvec4 clearCoatTintMapData;\\nvec4 environmentClearCoatRadiance;\\nfloat clearCoatNdotV;\\nvec3 clearCoatEnvironmentReflectance;\\n#endif\\n};\\n#ifdef CLEARCOAT\\n#define pbr_inline\\n#define inline\\nvoid clearcoatBlock(\\nin vec3 vPositionW,\\nin vec3 geometricNormalW,\\nin vec3 viewDirectionW,\\nin vec2 vClearCoatParams,\\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\\nin vec4 clearCoatMapRoughnessData,\\n#endif\\nin vec3 specularEnvironmentR0,\\n#ifdef CLEARCOAT_TEXTURE\\nin vec2 clearCoatMapData,\\n#endif\\n#ifdef CLEARCOAT_TINT\\nin vec4 vClearCoatTintParams,\\nin float clearCoatColorAtDistance,\\nin vec4 vClearCoatRefractionParams,\\n#ifdef CLEARCOAT_TINT_TEXTURE\\nin vec4 clearCoatTintMapData,\\n#endif\\n#endif\\n#ifdef CLEARCOAT_BUMP\\nin vec2 vClearCoatBumpInfos,\\nin vec4 clearCoatBumpMapData,\\nin vec2 vClearCoatBumpUV,\\n#if defined(TANGENT) && defined(NORMAL)\\nin mat3 vTBN,\\n#else\\nin vec2 vClearCoatTangentSpaceParams,\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\nin mat4 normalMatrix,\\n#endif\\n#endif\\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\\nin vec3 faceNormal,\\n#endif\\n#ifdef REFLECTION\\nin vec3 vReflectionMicrosurfaceInfos,\\nin vec2 vReflectionInfos,\\nin vec3 vReflectionColor,\\nin vec4 vLightingIntensity,\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube reflectionSampler,\\n#else\\nin sampler2D reflectionSampler,\\n#endif\\n#ifndef LODBASEDMICROSFURACE\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube reflectionSamplerLow,\\nin samplerCube reflectionSamplerHigh,\\n#else\\nin sampler2D reflectionSamplerLow,\\nin sampler2D reflectionSamplerHigh,\\n#endif\\n#endif\\n#ifdef REALTIME_FILTERING\\nin vec2 vReflectionFilteringInfo,\\n#endif\\n#endif\\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\\n#ifdef RADIANCEOCCLUSION\\nin float ambientMonochrome,\\n#endif\\n#endif\\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\\nin float frontFacingMultiplier,\\n#endif\\nout clearcoatOutParams outParams\\n)\\n{\\nfloat clearCoatIntensity=vClearCoatParams.x;\\nfloat clearCoatRoughness=vClearCoatParams.y;\\n#ifdef CLEARCOAT_TEXTURE\\nclearCoatIntensity*=clearCoatMapData.x;\\n#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\\nclearCoatRoughness*=clearCoatMapData.y;\\n#endif\\n#if DEBUGMODE>0\\noutParams.clearCoatMapData=clearCoatMapData;\\n#endif\\n#endif\\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL\\nclearCoatRoughness*=clearCoatMapData.y;\\n#else\\nclearCoatRoughness*=clearCoatMapRoughnessData.y;\\n#endif\\n#endif\\noutParams.clearCoatIntensity=clearCoatIntensity;\\noutParams.clearCoatRoughness=clearCoatRoughness;\\n#ifdef CLEARCOAT_TINT\\nvec3 clearCoatColor=vClearCoatTintParams.rgb;\\nfloat clearCoatThickness=vClearCoatTintParams.a;\\n#ifdef CLEARCOAT_TINT_TEXTURE\\n#ifdef CLEARCOAT_TINT_GAMMATEXTURE\\nclearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);\\n#else\\nclearCoatColor*=clearCoatTintMapData.rgb;\\n#endif\\nclearCoatThickness*=clearCoatTintMapData.a;\\n#if DEBUGMODE>0\\noutParams.clearCoatTintMapData=clearCoatTintMapData;\\n#endif\\n#endif\\noutParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);\\noutParams.clearCoatThickness=clearCoatThickness;\\n#endif\\n#ifdef CLEARCOAT_REMAP_F0\\nvec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);\\n#else\\nvec3 specularEnvironmentR0Updated=specularEnvironmentR0;\\n#endif\\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);\\nvec3 clearCoatNormalW=geometricNormalW;\\n#ifdef CLEARCOAT_BUMP\\n#ifdef NORMALXYSCALE\\nfloat clearCoatNormalScale=1.0;\\n#else\\nfloat clearCoatNormalScale=vClearCoatBumpInfos.y;\\n#endif\\n#if defined(TANGENT) && defined(NORMAL)\\nmat3 TBNClearCoat=vTBN;\\n#else\\nvec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;\\nmat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);\\n#endif\\n#if DEBUGMODE>0\\noutParams.TBNClearCoat=TBNClearCoat;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\nclearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);\\nclearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);\\n#else\\nclearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);\\n#endif\\n#endif\\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\\nclearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));\\n#endif\\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\\nclearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;\\n#endif\\noutParams.clearCoatNormalW=clearCoatNormalW;\\noutParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);\\nfloat clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);\\nfloat clearCoatNdotV=absEps(clearCoatNdotVUnclamped);\\n#if DEBUGMODE>0\\noutParams.clearCoatNdotV=clearCoatNdotV;\\n#endif\\n#ifdef CLEARCOAT_TINT\\nvec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);\\noutParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));\\n#endif\\n#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))\\nvec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);\\n#endif\\n#if defined(REFLECTION)\\nfloat clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);\\n#ifdef SPECULARAA\\nclearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;\\n#endif\\nvec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);\\nvec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nclearCoatReflectionVector.z*=-1.0;\\n#endif\\n#ifdef REFLECTIONMAP_3D\\nvec3 clearCoatReflectionCoords=clearCoatReflectionVector;\\n#else\\nvec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\nclearCoatReflectionCoords/=clearCoatReflectionVector.z;\\n#endif\\nclearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;\\n#endif\\nsampleReflectionTexture(\\nclearCoatAlphaG,\\nvReflectionMicrosurfaceInfos,\\nvReflectionInfos,\\nvReflectionColor,\\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\\nclearCoatNdotVUnclamped,\\n#endif\\n#ifdef LINEARSPECULARREFLECTION\\nclearCoatRoughness,\\n#endif\\nreflectionSampler,\\nclearCoatReflectionCoords,\\n#ifndef LODBASEDMICROSFURACE\\nreflectionSamplerLow,\\nreflectionSamplerHigh,\\n#endif\\n#ifdef REALTIME_FILTERING\\nvReflectionFilteringInfo,\\n#endif\\nenvironmentClearCoatRadiance\\n);\\n#if DEBUGMODE>0\\noutParams.environmentClearCoatRadiance=environmentClearCoatRadiance;\\n#endif\\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);\\n#ifdef RADIANCEOCCLUSION\\nfloat clearCoatSeo=environmentRadianceOcclusion(ambientMonochrome,clearCoatNdotVUnclamped);\\nclearCoatEnvironmentReflectance*=clearCoatSeo;\\n#endif\\n#ifdef HORIZONOCCLUSION\\n#ifdef BUMP\\n#ifdef REFLECTIONMAP_3D\\nfloat clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);\\nclearCoatEnvironmentReflectance*=clearCoatEho;\\n#endif\\n#endif\\n#endif\\n#else\\nvec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));\\n#endif\\nclearCoatEnvironmentReflectance*=clearCoatIntensity;\\n#if DEBUGMODE>0\\noutParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;\\n#endif\\noutParams.finalClearCoatRadianceScaled=\\nenvironmentClearCoatRadiance.rgb *\\nclearCoatEnvironmentReflectance *\\nvLightingIntensity.z;\\n#endif\\n#if defined(CLEARCOAT_TINT)\\noutParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);\\n#endif\\nfloat fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);\\nfresnelIBLClearCoat*=clearCoatIntensity;\\noutParams.conservationFactor=(1.-fresnelIBLClearCoat);\\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\\noutParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);\\n#endif\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockClearcoat = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockClearcoat.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockIridescence\";\nvar shader = \"struct iridescenceOutParams\\n{\\nfloat iridescenceIntensity;\\nfloat iridescenceIOR;\\nfloat iridescenceThickness;\\nvec3 specularEnvironmentR0;\\n};\\n#ifdef IRIDESCENCE\\n#define pbr_inline\\n#define inline\\nvoid iridescenceBlock(\\nin vec4 vIridescenceParams,\\nin float viewAngle,\\nin vec3 specularEnvironmentR0,\\n#ifdef IRIDESCENCE_TEXTURE\\nin vec2 iridescenceMapData,\\n#endif\\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\\nin vec2 iridescenceThicknessMapData,\\n#endif\\n#ifdef CLEARCOAT\\nin float NdotVUnclamped,\\n#ifdef CLEARCOAT_TEXTURE\\nin vec2 clearCoatMapData,\\n#endif\\n#endif\\nout iridescenceOutParams outParams\\n)\\n{\\nfloat iridescenceIntensity=vIridescenceParams.x;\\nfloat iridescenceIOR=vIridescenceParams.y;\\nfloat iridescenceThicknessMin=vIridescenceParams.z;\\nfloat iridescenceThicknessMax=vIridescenceParams.w;\\nfloat iridescenceThicknessWeight=1.;\\n#ifdef IRIDESCENCE_TEXTURE\\niridescenceIntensity*=iridescenceMapData.x;\\n#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE\\niridescenceThicknessWeight=iridescenceMapData.g;\\n#endif\\n#endif\\n#if defined(IRIDESCENCE_THICKNESS_TEXTURE)\\niridescenceThicknessWeight=iridescenceThicknessMapData.g;\\n#endif\\nfloat iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);\\nfloat topIor=1.; \\n#ifdef CLEARCOAT\\nfloat clearCoatIntensity=vClearCoatParams.x;\\n#ifdef CLEARCOAT_TEXTURE\\nclearCoatIntensity*=clearCoatMapData.x;\\n#endif\\ntopIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);\\nviewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));\\n#endif\\nvec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);\\noutParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);\\noutParams.iridescenceIntensity=iridescenceIntensity;\\noutParams.iridescenceThickness=iridescenceThickness;\\noutParams.iridescenceIOR=iridescenceIOR;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockIridescence = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockIridescence.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockSubSurface\";\nvar shader = \"struct subSurfaceOutParams\\n{\\nvec3 specularEnvironmentReflectance;\\n#ifdef SS_REFRACTION\\nvec3 finalRefraction;\\nvec3 surfaceAlbedo;\\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\\nfloat alpha;\\n#endif\\n#ifdef REFLECTION\\nfloat refractionFactorForIrradiance;\\n#endif\\n#endif\\n#ifdef SS_TRANSLUCENCY\\nvec3 transmittance;\\nfloat translucencyIntensity;\\n#ifdef REFLECTION\\nvec3 refractionIrradiance;\\n#endif\\n#endif\\n#if DEBUGMODE>0\\nvec4 thicknessMap;\\nvec4 environmentRefraction;\\nvec3 refractionTransmittance;\\n#endif\\n};\\n#ifdef SUBSURFACE\\n#define pbr_inline\\n#define inline\\nvoid subSurfaceBlock(\\nin vec3 vSubSurfaceIntensity,\\nin vec2 vThicknessParam,\\nin vec4 vTintColor,\\nin vec3 normalW,\\nin vec3 specularEnvironmentReflectance,\\n#ifdef SS_THICKNESSANDMASK_TEXTURE\\nin vec4 thicknessMap,\\n#endif\\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\\nin vec4 refractionIntensityMap,\\n#endif\\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\\nin vec4 translucencyIntensityMap,\\n#endif\\n#ifdef REFLECTION\\n#ifdef SS_TRANSLUCENCY\\nin mat4 reflectionMatrix,\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\\nin vec3 irradianceVector_,\\n#endif\\n#if defined(REALTIME_FILTERING)\\nin samplerCube reflectionSampler,\\nin vec2 vReflectionFilteringInfo,\\n#endif\\n#endif\\n#ifdef USEIRRADIANCEMAP\\n#ifdef REFLECTIONMAP_3D\\nin samplerCube irradianceSampler,\\n#else\\nin sampler2D irradianceSampler,\\n#endif\\n#endif\\n#endif\\n#endif\\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\\nin vec3 surfaceAlbedo,\\n#endif\\n#ifdef SS_REFRACTION\\nin vec3 vPositionW,\\nin vec3 viewDirectionW,\\nin mat4 view,\\nin vec4 vRefractionInfos,\\nin mat4 refractionMatrix,\\nin vec4 vRefractionMicrosurfaceInfos,\\nin vec4 vLightingIntensity,\\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\\nin float alpha,\\n#endif\\n#ifdef SS_LODINREFRACTIONALPHA\\nin float NdotVUnclamped,\\n#endif\\n#ifdef SS_LINEARSPECULARREFRACTION\\nin float roughness,\\n#endif\\nin float alphaG,\\n#ifdef SS_REFRACTIONMAP_3D\\nin samplerCube refractionSampler,\\n#ifndef LODBASEDMICROSFURACE\\nin samplerCube refractionSamplerLow,\\nin samplerCube refractionSamplerHigh,\\n#endif\\n#else\\nin sampler2D refractionSampler,\\n#ifndef LODBASEDMICROSFURACE\\nin sampler2D refractionSamplerLow,\\nin sampler2D refractionSamplerHigh,\\n#endif\\n#endif\\n#ifdef ANISOTROPIC\\nin anisotropicOutParams anisotropicOut,\\n#endif\\n#ifdef REALTIME_FILTERING\\nin vec2 vRefractionFilteringInfo,\\n#endif\\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\\nin vec3 refractionPosition,\\nin vec3 refractionSize,\\n#endif\\n#endif\\n#ifdef SS_TRANSLUCENCY\\nin vec3 vDiffusionDistance,\\n#endif\\nout subSurfaceOutParams outParams\\n)\\n{\\noutParams.specularEnvironmentReflectance=specularEnvironmentReflectance;\\n#ifdef SS_REFRACTION\\nfloat refractionIntensity=vSubSurfaceIntensity.x;\\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\\nrefractionIntensity*=(1.0-alpha);\\noutParams.alpha=1.0;\\n#endif\\n#endif\\n#ifdef SS_TRANSLUCENCY\\nfloat translucencyIntensity=vSubSurfaceIntensity.y;\\n#endif\\n#ifdef SS_THICKNESSANDMASK_TEXTURE\\n#if defined(SS_USE_GLTF_TEXTURES)\\nfloat thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;\\n#else\\nfloat thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;\\n#endif\\n#if DEBUGMODE>0\\noutParams.thicknessMap=thicknessMap;\\n#endif\\n#ifdef SS_MASK_FROM_THICKNESS_TEXTURE\\n#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)\\n#if defined(SS_USE_GLTF_TEXTURES)\\nrefractionIntensity*=thicknessMap.r;\\n#else\\nrefractionIntensity*=thicknessMap.g;\\n#endif\\n#endif\\n#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)\\ntranslucencyIntensity*=thicknessMap.b;\\n#endif\\n#endif\\n#else\\nfloat thickness=vThicknessParam.y;\\n#endif\\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\\n#ifdef SS_USE_GLTF_TEXTURES\\nrefractionIntensity*=refractionIntensityMap.r;\\n#else\\nrefractionIntensity*=refractionIntensityMap.g;\\n#endif\\n#endif\\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\\ntranslucencyIntensity*=translucencyIntensityMap.b;\\n#endif\\n#ifdef SS_TRANSLUCENCY\\nthickness=maxEps(thickness);\\nvec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);\\ntransmittance*=translucencyIntensity;\\noutParams.transmittance=transmittance;\\noutParams.translucencyIntensity=translucencyIntensity;\\n#endif\\n#ifdef SS_REFRACTION\\nvec4 environmentRefraction=vec4(0.,0.,0.,0.);\\n#ifdef ANISOTROPIC\\nvec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,vRefractionInfos.y);\\n#else\\nvec3 refractionVector=refract(-viewDirectionW,normalW,vRefractionInfos.y);\\n#endif\\n#ifdef SS_REFRACTIONMAP_OPPOSITEZ\\nrefractionVector.z*=-1.0;\\n#endif\\n#ifdef SS_REFRACTIONMAP_3D\\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);\\n#endif\\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\\nvec3 refractionCoords=refractionVector;\\nrefractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));\\n#else\\n#ifdef SS_USE_THICKNESS_AS_DEPTH\\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));\\n#else\\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\\n#endif\\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\\nrefractionCoords.y=1.0-refractionCoords.y;\\n#endif\\n#ifdef SS_HAS_THICKNESS\\nfloat ior=vRefractionInfos.y;\\n#else\\nfloat ior=vRefractionMicrosurfaceInfos.w;\\n#endif\\n#ifdef SS_LODINREFRACTIONALPHA\\nfloat refractionAlphaG=alphaG;\\nrefractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));\\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);\\n#elif defined(SS_LINEARSPECULARREFRACTION)\\nfloat refractionRoughness=alphaG;\\nrefractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));\\nfloat refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);\\n#else\\nfloat refractionAlphaG=alphaG;\\nrefractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));\\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);\\n#endif\\n#ifdef LODBASEDMICROSFURACE\\nrefractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\\n#ifdef SS_LODINREFRACTIONALPHA\\nfloat automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);\\nfloat requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);\\n#else\\nfloat requestedRefractionLOD=refractionLOD;\\n#endif\\n#ifdef REALTIME_FILTERING\\nenvironmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);\\n#else\\nenvironmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);\\n#endif\\n#else\\nfloat lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));\\nfloat lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;\\nvec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);\\nif (lodRefractionNormalizedDoubled<1.0){\\nenvironmentRefraction=mix(\\nsampleRefraction(refractionSamplerHigh,refractionCoords),\\nenvironmentRefractionMid,\\nlodRefractionNormalizedDoubled\\n);\\n} else {\\nenvironmentRefraction=mix(\\nenvironmentRefractionMid,\\nsampleRefraction(refractionSamplerLow,refractionCoords),\\nlodRefractionNormalizedDoubled-1.0\\n);\\n}\\n#endif\\n#ifdef SS_RGBDREFRACTION\\nenvironmentRefraction.rgb=fromRGBD(environmentRefraction);\\n#endif\\n#ifdef SS_GAMMAREFRACTION\\nenvironmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);\\n#endif\\nenvironmentRefraction.rgb*=vRefractionInfos.x;\\n#endif\\n#ifdef SS_REFRACTION\\nvec3 refractionTransmittance=vec3(refractionIntensity);\\n#ifdef SS_THICKNESSANDMASK_TEXTURE\\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);\\nrefractionTransmittance*=cocaLambert(volumeAlbedo,thickness);\\n#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)\\nfloat maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);\\nvec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);\\nenvironmentRefraction.rgb*=volumeAlbedo;\\n#else\\nvec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);\\nrefractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);\\n#endif\\n#ifdef SS_ALBEDOFORREFRACTIONTINT\\nenvironmentRefraction.rgb*=surfaceAlbedo.rgb;\\n#endif\\noutParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);\\n#ifdef REFLECTION\\noutParams.refractionFactorForIrradiance=(1.-refractionIntensity);\\n#endif\\n#ifdef UNUSED_MULTIPLEBOUNCES\\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);\\noutParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);\\n#endif\\nrefractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;\\n#if DEBUGMODE>0\\noutParams.refractionTransmittance=refractionTransmittance;\\n#endif\\noutParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;\\n#if DEBUGMODE>0\\noutParams.environmentRefraction=environmentRefraction;\\n#endif\\n#endif\\n#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)\\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)\\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nirradianceVector.z*=-1.0;\\n#endif\\n#ifdef INVERTCUBICMAP\\nirradianceVector.y*=-1.0;\\n#endif\\n#else\\nvec3 irradianceVector=irradianceVector_;\\n#endif\\n#if defined(USESPHERICALFROMREFLECTIONMAP)\\n#if defined(REALTIME_FILTERING)\\nvec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);\\n#else\\nvec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);\\n#endif\\n#elif defined(USEIRRADIANCEMAP)\\n#ifdef REFLECTIONMAP_3D\\nvec3 irradianceCoords=irradianceVector;\\n#else\\nvec2 irradianceCoords=irradianceVector.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\nirradianceCoords/=irradianceVector.z;\\n#endif\\nirradianceCoords.y=1.0-irradianceCoords.y;\\n#endif\\nvec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);\\n#ifdef RGBDREFLECTION\\nrefractionIrradiance.rgb=fromRGBD(refractionIrradiance);\\n#endif\\n#ifdef GAMMAREFLECTION\\nrefractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);\\n#endif\\n#else\\nvec4 refractionIrradiance=vec4(0.);\\n#endif\\nrefractionIrradiance.rgb*=transmittance;\\n#ifdef SS_ALBEDOFORTRANSLUCENCYTINT\\nrefractionIrradiance.rgb*=surfaceAlbedo.rgb;\\n#endif\\noutParams.refractionIrradiance=refractionIrradiance.rgb;\\n#endif\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockSubSurface = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockSubSurface.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockNormalGeometric\";\nvar shader = \"vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\\n#endif\\nvec3 geometricNormalW=normalW;\\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\\ngeometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockNormalGeometric = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockNormalGeometric.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockNormalFinal\";\nvar shader = \"#if defined(FORCENORMALFORWARD) && defined(NORMAL)\\nvec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\\n#if defined(TWOSIDEDLIGHTING)\\nfaceNormal=gl_FrontFacing ? faceNormal : -faceNormal;\\n#endif\\nnormalW*=sign(dot(normalW,faceNormal));\\n#endif\\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\\nnormalW=gl_FrontFacing ? normalW : -normalW;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockNormalFinal = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockNormalFinal.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockLightmapInit\";\nvar shader = \"#ifdef LIGHTMAP\\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\\n#ifdef RGBDLIGHTMAP\\nlightmapColor.rgb=fromRGBD(lightmapColor);\\n#endif\\n#ifdef GAMMALIGHTMAP\\nlightmapColor.rgb=toLinearSpace(lightmapColor.rgb);\\n#endif\\nlightmapColor.rgb*=vLightmapInfos.y;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockLightmapInit = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockLightmapInit.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockGeometryInfo\";\nvar shader = \"float NdotVUnclamped=dot(normalW,viewDirectionW);\\nfloat NdotV=absEps(NdotVUnclamped);\\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\\nvec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);\\n#ifdef SPECULARAA\\nalphaG+=AARoughnessFactors.y;\\n#endif\\n#if defined(ENVIRONMENTBRDF)\\nvec3 environmentBrdf=getBRDFLookup(NdotV,roughness);\\n#endif\\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\\n#ifdef RADIANCEOCCLUSION\\n#ifdef AMBIENTINGRAYSCALE\\nfloat ambientMonochrome=aoOut.ambientOcclusionColor.r;\\n#else\\nfloat ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);\\n#endif\\nfloat seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);\\n#endif\\n#ifdef HORIZONOCCLUSION\\n#ifdef BUMP\\n#ifdef REFLECTIONMAP_3D\\nfloat eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);\\n#endif\\n#endif\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockGeometryInfo = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockGeometryInfo.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockReflectance0\";\nvar shader = \"float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);\\nvec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;\\n#ifdef METALLICWORKFLOW\\nvec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);\\n#else \\nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);\\n#endif\\n#ifdef ALPHAFRESNEL\\nfloat reflectance90=fresnelGrazingReflectance(reflectance);\\nspecularEnvironmentR90=specularEnvironmentR90*reflectance90;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockReflectance0 = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockReflectance0.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockReflectance\";\nvar shader = \"#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\\nvec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);\\n#ifdef RADIANCEOCCLUSION\\nspecularEnvironmentReflectance*=seo;\\n#endif\\n#ifdef HORIZONOCCLUSION\\n#ifdef BUMP\\n#ifdef REFLECTIONMAP_3D\\nspecularEnvironmentReflectance*=eho;\\n#endif\\n#endif\\n#endif\\n#else\\nvec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\\n#endif\\n#ifdef CLEARCOAT\\nspecularEnvironmentReflectance*=clearcoatOut.conservationFactor;\\n#if defined(CLEARCOAT_TINT)\\nspecularEnvironmentReflectance*=clearcoatOut.absorption;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockReflectance = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockReflectance.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockDirectLighting\";\nvar shader = \"vec3 diffuseBase=vec3(0.,0.,0.);\\n#ifdef SPECULARTERM\\nvec3 specularBase=vec3(0.,0.,0.);\\n#endif\\n#ifdef CLEARCOAT\\nvec3 clearCoatBase=vec3(0.,0.,0.);\\n#endif\\n#ifdef SHEEN\\nvec3 sheenBase=vec3(0.,0.,0.);\\n#endif\\npreLightingInfo preInfo;\\nlightingInfo info;\\nfloat shadow=1.; \\n#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\\nvec3 absorption=vec3(0.);\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockDirectLighting = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockDirectLighting.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockFinalLitComponents\";\nvar shader = \"#if defined(ENVIRONMENTBRDF)\\n#ifdef MS_BRDF_ENERGY_CONSERVATION\\nvec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);\\n#endif\\n#endif\\n#ifndef METALLICWORKFLOW\\n#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION\\nsurfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;\\n#endif\\n#endif\\n#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)\\nsurfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;\\n#endif\\n#ifdef REFLECTION\\nvec3 finalIrradiance=reflectionOut.environmentIrradiance;\\n#if defined(CLEARCOAT)\\nfinalIrradiance*=clearcoatOut.conservationFactor;\\n#if defined(CLEARCOAT_TINT)\\nfinalIrradiance*=clearcoatOut.absorption;\\n#endif\\n#endif\\n#if defined(SS_REFRACTION)\\nfinalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;\\n#endif\\n#if defined(SS_TRANSLUCENCY)\\nfinalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);\\nfinalIrradiance+=subSurfaceOut.refractionIrradiance;\\n#endif\\nfinalIrradiance*=surfaceAlbedo.rgb;\\nfinalIrradiance*=vLightingIntensity.z;\\nfinalIrradiance*=aoOut.ambientOcclusionColor;\\n#endif\\n#ifdef SPECULARTERM\\nvec3 finalSpecular=specularBase;\\nfinalSpecular=max(finalSpecular,0.0);\\nvec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;\\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\\nfinalSpecularScaled*=energyConservationFactor;\\n#endif\\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\\nfinalSpecularScaled*=sheenOut.sheenAlbedoScaling;\\n#endif\\n#endif\\n#ifdef REFLECTION\\nvec3 finalRadiance=reflectionOut.environmentRadiance.rgb;\\nfinalRadiance*=subSurfaceOut.specularEnvironmentReflectance;\\nvec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;\\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\\nfinalRadianceScaled*=energyConservationFactor;\\n#endif\\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)\\nfinalRadianceScaled*=sheenOut.sheenAlbedoScaling;\\n#endif\\n#endif\\n#ifdef SHEEN\\nvec3 finalSheen=sheenBase*sheenOut.sheenColor;\\nfinalSheen=max(finalSheen,0.0);\\nvec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;\\n#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)\\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;\\n#if defined(CLEARCOAT_TINT)\\nsheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;\\n#endif\\n#endif\\n#endif\\n#ifdef CLEARCOAT\\nvec3 finalClearCoat=clearCoatBase;\\nfinalClearCoat=max(finalClearCoat,0.0);\\nvec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;\\n#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)\\nfinalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;\\n#endif\\n#ifdef SS_REFRACTION\\nsubSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;\\n#ifdef CLEARCOAT_TINT\\nsubSurfaceOut.finalRefraction*=clearcoatOut.absorption;\\n#endif\\n#endif\\n#endif\\n#ifdef ALPHABLEND\\nfloat luminanceOverAlpha=0.0;\\n#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)\\nluminanceOverAlpha+=getLuminance(finalRadianceScaled);\\n#if defined(CLEARCOAT)\\nluminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);\\n#endif\\n#endif\\n#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\\nluminanceOverAlpha+=getLuminance(finalSpecularScaled);\\n#endif\\n#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)\\nluminanceOverAlpha+=getLuminance(finalClearCoatScaled);\\n#endif\\n#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)\\nalpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockFinalLitComponents = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockFinalLitComponents.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockFinalUnlitComponents\";\nvar shader = \"vec3 finalDiffuse=diffuseBase;\\nfinalDiffuse*=surfaceAlbedo.rgb;\\nfinalDiffuse=max(finalDiffuse,0.0);\\nfinalDiffuse*=vLightingIntensity.x;\\nvec3 finalAmbient=vAmbientColor;\\nfinalAmbient*=surfaceAlbedo.rgb;\\nvec3 finalEmissive=vEmissiveColor;\\n#ifdef EMISSIVE\\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\\n#ifdef GAMMAEMISSIVE\\nfinalEmissive*=toLinearSpace(emissiveColorTex.rgb);\\n#else\\nfinalEmissive*=emissiveColorTex.rgb;\\n#endif\\nfinalEmissive*= vEmissiveInfos.y;\\n#endif\\nfinalEmissive*=vLightingIntensity.y;\\n#ifdef AMBIENT\\nvec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);\\n#else\\nvec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;\\n#endif\\nfinalAmbient*=aoOut.ambientOcclusionColor;\\nfinalDiffuse*=ambientOcclusionForDirectDiffuse;\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockFinalUnlitComponents = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockFinalUnlitComponents.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockFinalColorComposition\";\nvar shader = \"vec4 finalColor=vec4(\\nfinalAmbient +\\nfinalDiffuse +\\n#ifndef UNLIT\\n#ifdef REFLECTION\\nfinalIrradiance +\\n#endif\\n#ifdef SPECULARTERM\\nfinalSpecularScaled +\\n#endif\\n#ifdef SHEEN\\nfinalSheenScaled +\\n#endif\\n#ifdef CLEARCOAT\\nfinalClearCoatScaled +\\n#endif\\n#ifdef REFLECTION\\nfinalRadianceScaled +\\n#if defined(SHEEN) && defined(ENVIRONMENTBRDF)\\nsheenOut.finalSheenRadianceScaled +\\n#endif\\n#ifdef CLEARCOAT\\nclearcoatOut.finalClearCoatRadianceScaled +\\n#endif\\n#endif\\n#ifdef SS_REFRACTION\\nsubSurfaceOut.finalRefraction +\\n#endif\\n#endif\\nfinalEmissive,\\nalpha);\\n#ifdef LIGHTMAP\\n#ifndef LIGHTMAPEXCLUDED\\n#ifdef USELIGHTMAPASSHADOWMAP\\nfinalColor.rgb*=lightmapColor.rgb;\\n#else\\nfinalColor.rgb+=lightmapColor.rgb;\\n#endif\\n#endif\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_FOG\\nfinalColor=max(finalColor,0.0);\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockFinalColorComposition = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockFinalColorComposition.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrBlockImageProcessing\";\nvar shader = \"#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)\\n#if !defined(SKIPFINALCOLORCLAMP)\\nfinalColor.rgb=clamp(finalColor.rgb,0.,30.0);\\n#endif\\n#else\\nfinalColor=applyImageProcessing(finalColor);\\n#endif\\nfinalColor.a*=visibility;\\n#ifdef PREMULTIPLYALPHA\\nfinalColor.rgb*=finalColor.a;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrBlockImageProcessing = { name: name, shader: shader };\n//# sourceMappingURL=pbrBlockImageProcessing.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrDebug\";\nvar shader = \"#if DEBUGMODE>0\\nif (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {\\n#if DEBUGMODE==1\\ngl_FragColor.rgb=vPositionW.rgb;\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==2 && defined(NORMAL)\\ngl_FragColor.rgb=vNormalW.rgb;\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)\\ngl_FragColor.rgb=TBN[0];\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)\\ngl_FragColor.rgb=TBN[1];\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==5\\ngl_FragColor.rgb=normalW;\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==6 && defined(MAINUV1)\\ngl_FragColor.rgb=vec3(vMainUV1,0.0);\\n#elif DEBUGMODE==7 && defined(MAINUV2)\\ngl_FragColor.rgb=vec3(vMainUV2,0.0);\\n#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)\\ngl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==10 && defined(CLEARCOAT)\\ngl_FragColor.rgb=clearcoatOut.clearCoatNormalW;\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==11 && defined(ANISOTROPIC)\\ngl_FragColor.rgb=anisotropicOut.anisotropicNormal;\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==12 && defined(ANISOTROPIC)\\ngl_FragColor.rgb=anisotropicOut.anisotropicTangent;\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==13 && defined(ANISOTROPIC)\\ngl_FragColor.rgb=anisotropicOut.anisotropicBitangent;\\n#define DEBUGMODE_NORMALIZE\\n#elif DEBUGMODE==20 && defined(ALBEDO)\\ngl_FragColor.rgb=albedoTexture.rgb;\\n#elif DEBUGMODE==21 && defined(AMBIENT)\\ngl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;\\n#elif DEBUGMODE==22 && defined(OPACITY)\\ngl_FragColor.rgb=opacityMap.rgb;\\n#elif DEBUGMODE==23 && defined(EMISSIVE)\\ngl_FragColor.rgb=emissiveColorTex.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==24 && defined(LIGHTMAP)\\ngl_FragColor.rgb=lightmapColor.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)\\ngl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;\\n#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)\\ngl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)\\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);\\n#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\\ngl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;\\n#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)\\ngl_FragColor.rgb=sheenOut.sheenMapData.rgb;\\n#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)\\ngl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;\\n#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)\\ngl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;\\n#elif DEBUGMODE==40 && defined(SS_REFRACTION)\\ngl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==41 && defined(REFLECTION)\\ngl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)\\ngl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==50\\ngl_FragColor.rgb=diffuseBase.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==51 && defined(SPECULARTERM)\\ngl_FragColor.rgb=specularBase.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==52 && defined(CLEARCOAT)\\ngl_FragColor.rgb=clearCoatBase.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==53 && defined(SHEEN)\\ngl_FragColor.rgb=sheenBase.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==54 && defined(REFLECTION)\\ngl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==60\\ngl_FragColor.rgb=surfaceAlbedo.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==61\\ngl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)\\ngl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);\\n#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)\\ngl_FragColor.rgb=reflectivityOut.metallicF0;\\n#elif DEBUGMODE==63\\ngl_FragColor.rgb=vec3(roughness);\\n#elif DEBUGMODE==64\\ngl_FragColor.rgb=vec3(alphaG);\\n#elif DEBUGMODE==65\\ngl_FragColor.rgb=vec3(NdotV);\\n#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)\\ngl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==67 && defined(CLEARCOAT)\\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);\\n#elif DEBUGMODE==68 && defined(CLEARCOAT)\\ngl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);\\n#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)\\ngl_FragColor.rgb=subSurfaceOut.transmittance;\\n#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)\\ngl_FragColor.rgb=subSurfaceOut.refractionTransmittance;\\n#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)\\ngl_FragColor.rgb=vec3(seo);\\n#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION)\\ngl_FragColor.rgb=vec3(eho);\\n#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)\\ngl_FragColor.rgb=vec3(energyConservationFactor);\\n#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\\ngl_FragColor.rgb=specularEnvironmentReflectance;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\\ngl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)\\ngl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;\\n#define DEBUGMODE_GAMMA\\n#elif DEBUGMODE==86 && defined(ALPHABLEND)\\ngl_FragColor.rgb=vec3(luminanceOverAlpha);\\n#elif DEBUGMODE==87\\ngl_FragColor.rgb=vec3(alpha);\\n#endif\\ngl_FragColor.rgb*=vDebugMode.y;\\n#ifdef DEBUGMODE_NORMALIZE\\ngl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;\\n#endif\\n#ifdef DEBUGMODE_GAMMA\\ngl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);\\n#endif\\ngl_FragColor.a=1.0;\\n#ifdef PREPASS\\ngl_FragData[0]=toLinearSpace(gl_FragColor); \\ngl_FragData[1]=vec4(0.,0.,0.,0.); \\n#endif\\nreturn;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrDebug = { name: name, shader: shader };\n//# sourceMappingURL=pbrDebug.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/prePassDeclaration.js\";\nimport \"./ShadersInclude/oitDeclaration.js\";\nimport \"./ShadersInclude/pbrFragmentDeclaration.js\";\nimport \"./ShadersInclude/pbrUboDeclaration.js\";\nimport \"./ShadersInclude/pbrFragmentExtraDeclaration.js\";\nimport \"./ShadersInclude/lightFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightUboDeclaration.js\";\nimport \"./ShadersInclude/pbrFragmentSamplersDeclaration.js\";\nimport \"./ShadersInclude/imageProcessingDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/fogFragmentDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions.js\";\nimport \"./ShadersInclude/importanceSampling.js\";\nimport \"./ShadersInclude/pbrHelperFunctions.js\";\nimport \"./ShadersInclude/imageProcessingFunctions.js\";\nimport \"./ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"./ShadersInclude/harmonicsFunctions.js\";\nimport \"./ShadersInclude/pbrDirectLightingSetupFunctions.js\";\nimport \"./ShadersInclude/pbrDirectLightingFalloffFunctions.js\";\nimport \"./ShadersInclude/pbrBRDFFunctions.js\";\nimport \"./ShadersInclude/hdrFilteringFunctions.js\";\nimport \"./ShadersInclude/pbrDirectLightingFunctions.js\";\nimport \"./ShadersInclude/pbrIBLFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions.js\";\nimport \"./ShadersInclude/bumpFragmentFunctions.js\";\nimport \"./ShadersInclude/reflectionFunction.js\";\nimport \"./ShadersInclude/pbrBlockAlbedoOpacity.js\";\nimport \"./ShadersInclude/pbrBlockReflectivity.js\";\nimport \"./ShadersInclude/pbrBlockAmbientOcclusion.js\";\nimport \"./ShadersInclude/pbrBlockAlphaFresnel.js\";\nimport \"./ShadersInclude/pbrBlockAnisotropic.js\";\nimport \"./ShadersInclude/pbrBlockReflection.js\";\nimport \"./ShadersInclude/pbrBlockSheen.js\";\nimport \"./ShadersInclude/pbrBlockClearcoat.js\";\nimport \"./ShadersInclude/pbrBlockIridescence.js\";\nimport \"./ShadersInclude/pbrBlockSubSurface.js\";\nimport \"./ShadersInclude/oitFragment.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/pbrBlockNormalGeometric.js\";\nimport \"./ShadersInclude/bumpFragment.js\";\nimport \"./ShadersInclude/pbrBlockNormalFinal.js\";\nimport \"./ShadersInclude/depthPrePass.js\";\nimport \"./ShadersInclude/pbrBlockLightmapInit.js\";\nimport \"./ShadersInclude/pbrBlockGeometryInfo.js\";\nimport \"./ShadersInclude/pbrBlockReflectance0.js\";\nimport \"./ShadersInclude/pbrBlockReflectance.js\";\nimport \"./ShadersInclude/pbrBlockDirectLighting.js\";\nimport \"./ShadersInclude/lightFragment.js\";\nimport \"./ShadersInclude/pbrBlockFinalLitComponents.js\";\nimport \"./ShadersInclude/pbrBlockFinalUnlitComponents.js\";\nimport \"./ShadersInclude/pbrBlockFinalColorComposition.js\";\nimport \"./ShadersInclude/logDepthFragment.js\";\nimport \"./ShadersInclude/fogFragment.js\";\nimport \"./ShadersInclude/pbrBlockImageProcessing.js\";\nimport \"./ShadersInclude/pbrDebug.js\";\nvar name = \"pbrPixelShader\";\nvar shader = \"#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n#ifdef LODBASEDMICROSFURACE\\n#extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#define CUSTOM_FRAGMENT_BEGIN\\n#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\\nprecision highp float;\\n#include<oitDeclaration>\\n#ifndef FROMLINEARSPACE\\n#define FROMLINEARSPACE\\n#endif\\n#include<__decl__pbrFragment>\\n#include<pbrFragmentExtraDeclaration>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<pbrFragmentSamplersDeclaration>\\n#include<imageProcessingDeclaration>\\n#include<clipPlaneFragmentDeclaration>\\n#include<logDepthDeclaration>\\n#include<fogFragmentDeclaration>\\n#include<helperFunctions>\\n#include<subSurfaceScatteringFunctions>\\n#include<importanceSampling>\\n#include<pbrHelperFunctions>\\n#include<imageProcessingFunctions>\\n#include<shadowsFragmentFunctions>\\n#include<harmonicsFunctions>\\n#include<pbrDirectLightingSetupFunctions>\\n#include<pbrDirectLightingFalloffFunctions>\\n#include<pbrBRDFFunctions>\\n#include<hdrFilteringFunctions>\\n#include<pbrDirectLightingFunctions>\\n#include<pbrIBLFunctions>\\n#include<bumpFragmentMainFunctions>\\n#include<bumpFragmentFunctions>\\n#ifdef REFLECTION\\n#include<reflectionFunction>\\n#endif\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\n#include<pbrBlockAlbedoOpacity>\\n#include<pbrBlockReflectivity>\\n#include<pbrBlockAmbientOcclusion>\\n#include<pbrBlockAlphaFresnel>\\n#include<pbrBlockAnisotropic>\\n#include<pbrBlockReflection>\\n#include<pbrBlockSheen>\\n#include<pbrBlockClearcoat>\\n#include<pbrBlockIridescence>\\n#include<pbrBlockSubSurface>\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<oitFragment>\\n#include<clipPlaneFragment>\\n#include<pbrBlockNormalGeometric>\\n#include<bumpFragment>\\n#include<pbrBlockNormalFinal>\\nalbedoOpacityOutParams albedoOpacityOut;\\n#ifdef ALBEDO\\nvec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);\\n#endif\\n#ifdef OPACITY\\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\\n#endif\\nalbedoOpacityBlock(\\nvAlbedoColor,\\n#ifdef ALBEDO\\nalbedoTexture,\\nvAlbedoInfos,\\n#endif\\n#ifdef OPACITY\\nopacityMap,\\nvOpacityInfos,\\n#endif\\n#ifdef DETAIL\\ndetailColor,\\nvDetailInfos,\\n#endif\\nalbedoOpacityOut\\n);\\nvec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;\\nfloat alpha=albedoOpacityOut.alpha;\\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\\n#include<depthPrePass>\\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\\nambientOcclusionOutParams aoOut;\\n#ifdef AMBIENT\\nvec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;\\n#endif\\nambientOcclusionBlock(\\n#ifdef AMBIENT\\nambientOcclusionColorMap,\\nvAmbientInfos,\\n#endif\\naoOut\\n);\\n#include<pbrBlockLightmapInit>\\n#ifdef UNLIT\\nvec3 diffuseBase=vec3(1.,1.,1.);\\n#else\\nvec3 baseColor=surfaceAlbedo;\\nreflectivityOutParams reflectivityOut;\\n#if defined(REFLECTIVITY)\\nvec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\\nvec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;\\n#ifndef METALLICWORKFLOW\\n#ifdef REFLECTIVITY_GAMMA\\nsurfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);\\n#endif\\nsurfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;\\n#endif\\n#endif\\n#if defined(MICROSURFACEMAP)\\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\\n#endif\\n#ifdef METALLICWORKFLOW\\nvec4 metallicReflectanceFactors=vMetallicReflectanceFactors;\\n#ifdef REFLECTANCE\\nvec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);\\n#ifdef REFLECTANCE_GAMMA\\nreflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);\\n#endif\\nmetallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;\\n#endif\\n#ifdef METALLIC_REFLECTANCE\\nvec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);\\n#ifdef METALLIC_REFLECTANCE_GAMMA\\nmetallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);\\n#endif\\n#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY\\nmetallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;\\n#endif\\nmetallicReflectanceFactors*=metallicReflectanceFactorsMap.a;\\n#endif\\n#endif\\nreflectivityBlock(\\nvReflectivityColor,\\n#ifdef METALLICWORKFLOW\\nsurfaceAlbedo,\\nmetallicReflectanceFactors,\\n#endif\\n#ifdef REFLECTIVITY\\nvReflectivityInfos,\\nsurfaceMetallicOrReflectivityColorMap,\\n#endif\\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\\naoOut.ambientOcclusionColor,\\n#endif\\n#ifdef MICROSURFACEMAP\\nmicroSurfaceTexel,\\n#endif\\n#ifdef DETAIL\\ndetailColor,\\nvDetailInfos,\\n#endif\\nreflectivityOut\\n);\\nfloat microSurface=reflectivityOut.microSurface;\\nfloat roughness=reflectivityOut.roughness;\\n#ifdef METALLICWORKFLOW\\nsurfaceAlbedo=reflectivityOut.surfaceAlbedo;\\n#endif\\n#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\\naoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;\\n#endif\\n#ifdef ALPHAFRESNEL\\n#if defined(ALPHATEST) || defined(ALPHABLEND)\\nalphaFresnelOutParams alphaFresnelOut;\\nalphaFresnelBlock(\\nnormalW,\\nviewDirectionW,\\nalpha,\\nmicroSurface,\\nalphaFresnelOut\\n);\\nalpha=alphaFresnelOut.alpha;\\n#endif\\n#endif\\n#include<pbrBlockGeometryInfo>\\n#ifdef ANISOTROPIC\\nanisotropicOutParams anisotropicOut;\\n#ifdef ANISOTROPIC_TEXTURE\\nvec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;\\n#endif\\nanisotropicBlock(\\nvAnisotropy,\\n#ifdef ANISOTROPIC_TEXTURE\\nanisotropyMapData,\\n#endif\\nTBN,\\nnormalW,\\nviewDirectionW,\\nanisotropicOut\\n);\\n#endif\\n#ifdef REFLECTION\\nreflectionOutParams reflectionOut;\\n#ifndef USE_CUSTOM_REFLECTION\\nreflectionBlock(\\nvPositionW,\\nnormalW,\\nalphaG,\\nvReflectionMicrosurfaceInfos,\\nvReflectionInfos,\\nvReflectionColor,\\n#ifdef ANISOTROPIC\\nanisotropicOut,\\n#endif\\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\\nNdotVUnclamped,\\n#endif\\n#ifdef LINEARSPECULARREFLECTION\\nroughness,\\n#endif\\nreflectionSampler,\\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\\nvEnvironmentIrradiance,\\n#endif\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\\nreflectionMatrix,\\n#endif\\n#endif\\n#ifdef USEIRRADIANCEMAP\\nirradianceSampler,\\n#endif\\n#ifndef LODBASEDMICROSFURACE\\nreflectionSamplerLow,\\nreflectionSamplerHigh,\\n#endif\\n#ifdef REALTIME_FILTERING\\nvReflectionFilteringInfo,\\n#endif\\nreflectionOut\\n);\\n#else\\n#define CUSTOM_REFLECTION\\n#endif\\n#endif\\n#include<pbrBlockReflectance0>\\n#ifdef SHEEN\\nsheenOutParams sheenOut;\\n#ifdef SHEEN_TEXTURE\\nvec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);\\n#endif\\n#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\\nvec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;\\n#endif\\nsheenBlock(\\nvSheenColor,\\n#ifdef SHEEN_ROUGHNESS\\nvSheenRoughness,\\n#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)\\nsheenMapRoughnessData,\\n#endif\\n#endif\\nroughness,\\n#ifdef SHEEN_TEXTURE\\nsheenMapData,\\nvSheenInfos.y,\\n#endif\\nreflectance,\\n#ifdef SHEEN_LINKWITHALBEDO\\nbaseColor,\\nsurfaceAlbedo,\\n#endif\\n#ifdef ENVIRONMENTBRDF\\nNdotV,\\nenvironmentBrdf,\\n#endif\\n#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)\\nAARoughnessFactors,\\nvReflectionMicrosurfaceInfos,\\nvReflectionInfos,\\nvReflectionColor,\\nvLightingIntensity,\\nreflectionSampler,\\nreflectionOut.reflectionCoords,\\nNdotVUnclamped,\\n#ifndef LODBASEDMICROSFURACE\\nreflectionSamplerLow,\\nreflectionSamplerHigh,\\n#endif\\n#ifdef REALTIME_FILTERING\\nvReflectionFilteringInfo,\\n#endif\\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)\\nseo,\\n#endif\\n#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)\\neho,\\n#endif\\n#endif\\nsheenOut\\n);\\n#ifdef SHEEN_LINKWITHALBEDO\\nsurfaceAlbedo=sheenOut.surfaceAlbedo;\\n#endif\\n#endif\\n#ifdef CLEARCOAT\\n#ifdef CLEARCOAT_TEXTURE\\nvec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;\\n#endif\\n#endif\\n#ifdef IRIDESCENCE\\niridescenceOutParams iridescenceOut;\\n#ifdef IRIDESCENCE_TEXTURE\\nvec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;\\n#endif\\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\\nvec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;\\n#endif\\niridescenceBlock(\\nvIridescenceParams,\\nNdotV,\\nspecularEnvironmentR0,\\n#ifdef IRIDESCENCE_TEXTURE\\niridescenceMapData,\\n#endif\\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\\niridescenceThicknessMapData,\\n#endif\\n#ifdef CLEARCOAT\\nNdotVUnclamped,\\n#ifdef CLEARCOAT_TEXTURE\\nclearCoatMapData,\\n#endif\\n#endif\\niridescenceOut\\n);\\nfloat iridescenceIntensity=iridescenceOut.iridescenceIntensity;\\nspecularEnvironmentR0=iridescenceOut.specularEnvironmentR0;\\n#endif\\nclearcoatOutParams clearcoatOut;\\n#ifdef CLEARCOAT\\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\\nvec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;\\n#endif\\n#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)\\nvec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);\\n#endif\\n#ifdef CLEARCOAT_BUMP\\nvec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);\\n#endif\\nclearcoatBlock(\\nvPositionW,\\ngeometricNormalW,\\nviewDirectionW,\\nvClearCoatParams,\\n#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)\\nclearCoatMapRoughnessData,\\n#endif\\nspecularEnvironmentR0,\\n#ifdef CLEARCOAT_TEXTURE\\nclearCoatMapData,\\n#endif\\n#ifdef CLEARCOAT_TINT\\nvClearCoatTintParams,\\nclearCoatColorAtDistance,\\nvClearCoatRefractionParams,\\n#ifdef CLEARCOAT_TINT_TEXTURE\\nclearCoatTintMapData,\\n#endif\\n#endif\\n#ifdef CLEARCOAT_BUMP\\nvClearCoatBumpInfos,\\nclearCoatBumpMapData,\\nvClearCoatBumpUV,\\n#if defined(TANGENT) && defined(NORMAL)\\nvTBN,\\n#else\\nvClearCoatTangentSpaceParams,\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\nnormalMatrix,\\n#endif\\n#endif\\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\\nfaceNormal,\\n#endif\\n#ifdef REFLECTION\\nvReflectionMicrosurfaceInfos,\\nvReflectionInfos,\\nvReflectionColor,\\nvLightingIntensity,\\nreflectionSampler,\\n#ifndef LODBASEDMICROSFURACE\\nreflectionSamplerLow,\\nreflectionSamplerHigh,\\n#endif\\n#ifdef REALTIME_FILTERING\\nvReflectionFilteringInfo,\\n#endif\\n#endif\\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\\n#ifdef RADIANCEOCCLUSION\\nambientMonochrome,\\n#endif\\n#endif\\n#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\\n(gl_FrontFacing ? 1. : -1.),\\n#endif\\nclearcoatOut\\n);\\n#else\\nclearcoatOut.specularEnvironmentR0=specularEnvironmentR0;\\n#endif\\n#include<pbrBlockReflectance>\\nsubSurfaceOutParams subSurfaceOut;\\n#ifdef SUBSURFACE\\n#ifdef SS_THICKNESSANDMASK_TEXTURE\\nvec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);\\n#endif\\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\\nvec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);\\n#endif\\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\\nvec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);\\n#endif\\nsubSurfaceBlock(\\nvSubSurfaceIntensity,\\nvThicknessParam,\\nvTintColor,\\nnormalW,\\nspecularEnvironmentReflectance,\\n#ifdef SS_THICKNESSANDMASK_TEXTURE\\nthicknessMap,\\n#endif\\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\\nrefractionIntensityMap,\\n#endif\\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\\ntranslucencyIntensityMap,\\n#endif\\n#ifdef REFLECTION\\n#ifdef SS_TRANSLUCENCY\\nreflectionMatrix,\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\\nreflectionOut.irradianceVector,\\n#endif\\n#if defined(REALTIME_FILTERING)\\nreflectionSampler,\\nvReflectionFilteringInfo,\\n#endif\\n#endif\\n#ifdef USEIRRADIANCEMAP\\nirradianceSampler,\\n#endif\\n#endif\\n#endif\\n#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\\nsurfaceAlbedo,\\n#endif\\n#ifdef SS_REFRACTION\\nvPositionW,\\nviewDirectionW,\\nview,\\nvRefractionInfos,\\nrefractionMatrix,\\nvRefractionMicrosurfaceInfos,\\nvLightingIntensity,\\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\\nalpha,\\n#endif\\n#ifdef SS_LODINREFRACTIONALPHA\\nNdotVUnclamped,\\n#endif\\n#ifdef SS_LINEARSPECULARREFRACTION\\nroughness,\\n#endif\\nalphaG,\\nrefractionSampler,\\n#ifndef LODBASEDMICROSFURACE\\nrefractionSamplerLow,\\nrefractionSamplerHigh,\\n#endif\\n#ifdef ANISOTROPIC\\nanisotropicOut,\\n#endif\\n#ifdef REALTIME_FILTERING\\nvRefractionFilteringInfo,\\n#endif\\n#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\\nvRefractionPosition,\\nvRefractionSize,\\n#endif\\n#endif\\n#ifdef SS_TRANSLUCENCY\\nvDiffusionDistance,\\n#endif\\nsubSurfaceOut\\n);\\n#ifdef SS_REFRACTION\\nsurfaceAlbedo=subSurfaceOut.surfaceAlbedo;\\n#ifdef SS_LINKREFRACTIONTOTRANSPARENCY\\nalpha=subSurfaceOut.alpha;\\n#endif\\n#endif\\n#else\\nsubSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;\\n#endif\\n#include<pbrBlockDirectLighting>\\n#include<lightFragment>[0..maxSimultaneousLights]\\n#include<pbrBlockFinalLitComponents>\\n#endif \\n#include<pbrBlockFinalUnlitComponents>\\n#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\\n#include<pbrBlockFinalColorComposition>\\n#include<logDepthFragment>\\n#include<fogFragment>(color,finalColor)\\n#include<pbrBlockImageProcessing>\\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\\n#ifdef PREPASS\\nfloat writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;\\n#ifdef PREPASS_POSITION\\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\\n#endif\\n#ifdef PREPASS_VELOCITY\\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\\nvec2 velocity=abs(a-b);\\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\\n#endif\\n#ifdef PREPASS_ALBEDO_SQRT\\nvec3 sqAlbedo=sqrt(surfaceAlbedo); \\n#endif\\n#ifdef PREPASS_IRRADIANCE\\nvec3 irradiance=finalDiffuse;\\n#ifndef UNLIT\\n#ifdef REFLECTION\\nirradiance+=finalIrradiance;\\n#endif\\n#endif\\n#ifdef SS_SCATTERING\\ngl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); \\nirradiance/=sqAlbedo;\\n#else\\ngl_FragData[0]=finalColor; \\nfloat scatteringDiffusionProfile=255.;\\n#endif\\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); \\n#else\\ngl_FragData[0]=vec4(finalColor.rgb,finalColor.a);\\n#endif\\n#ifdef PREPASS_DEPTH\\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \\n#endif\\n#ifdef PREPASS_NORMAL\\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4((view*vec4(normalW,0.0)).rgb,writeGeometryInfo); \\n#endif\\n#ifdef PREPASS_ALBEDO_SQRT\\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); \\n#endif\\n#ifdef PREPASS_REFLECTIVITY\\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toGammaSpace(specularEnvironmentR0),microSurface)*writeGeometryInfo;\\n#endif\\n#endif\\n#if !defined(PREPASS) || defined(WEBGL2)\\ngl_FragColor=finalColor;\\n#endif\\n#if ORDER_INDEPENDENT_TRANSPARENCY\\nif (fragDepth==nearestDepth) {\\nfrontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;\\nfrontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);\\n} else {\\nbackColor+=finalColor;\\n}\\n#endif\\n#include<pbrDebug>\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var pbrPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=pbr.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"pbrVertexDeclaration\";\nvar shader = \"uniform mat4 view;\\nuniform mat4 viewProjection;\\n#ifdef ALBEDO\\nuniform mat4 albedoMatrix;\\nuniform vec2 vAlbedoInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform mat4 ambientMatrix;\\nuniform vec4 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform mat4 opacityMatrix;\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\nuniform mat4 emissiveMatrix;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\nuniform mat4 lightmapMatrix;\\n#endif\\n#ifdef REFLECTIVITY \\nuniform vec3 vReflectivityInfos;\\nuniform mat4 reflectivityMatrix;\\n#endif\\n#ifdef METALLIC_REFLECTANCE\\nuniform vec2 vMetallicReflectanceInfos;\\nuniform mat4 metallicReflectanceMatrix;\\n#endif\\n#ifdef REFLECTANCE\\nuniform vec2 vReflectanceInfos;\\nuniform mat4 reflectanceMatrix;\\n#endif\\n#ifdef MICROSURFACEMAP\\nuniform vec2 vMicroSurfaceSamplerInfos;\\nuniform mat4 microSurfaceSamplerMatrix;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform mat4 bumpMatrix;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\nuniform mat4 reflectionMatrix;\\n#endif\\n#ifdef CLEARCOAT\\n#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)\\nuniform vec4 vClearCoatInfos;\\n#endif\\n#ifdef CLEARCOAT_TEXTURE\\nuniform mat4 clearCoatMatrix;\\n#endif\\n#ifdef CLEARCOAT_TEXTURE_ROUGHNESS\\nuniform mat4 clearCoatRoughnessMatrix;\\n#endif\\n#ifdef CLEARCOAT_BUMP\\nuniform vec2 vClearCoatBumpInfos;\\nuniform mat4 clearCoatBumpMatrix;\\n#endif\\n#ifdef CLEARCOAT_TINT_TEXTURE\\nuniform vec2 vClearCoatTintInfos;\\nuniform mat4 clearCoatTintMatrix;\\n#endif\\n#endif\\n#ifdef IRIDESCENCE\\n#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)\\nuniform vec4 vIridescenceInfos;\\n#endif\\n#ifdef IRIDESCENCE_TEXTURE\\nuniform mat4 iridescenceMatrix;\\n#endif\\n#ifdef IRIDESCENCE_THICKNESS_TEXTURE\\nuniform mat4 iridescenceThicknessMatrix;\\n#endif\\n#endif\\n#ifdef ANISOTROPIC\\n#ifdef ANISOTROPIC_TEXTURE\\nuniform vec2 vAnisotropyInfos;\\nuniform mat4 anisotropyMatrix;\\n#endif\\n#endif\\n#ifdef SHEEN\\n#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)\\nuniform vec4 vSheenInfos;\\n#endif\\n#ifdef SHEEN_TEXTURE\\nuniform mat4 sheenMatrix;\\n#endif\\n#ifdef SHEEN_TEXTURE_ROUGHNESS\\nuniform mat4 sheenRoughnessMatrix;\\n#endif\\n#endif\\n#ifdef SUBSURFACE\\n#ifdef SS_REFRACTION\\nuniform vec4 vRefractionInfos;\\nuniform mat4 refractionMatrix;\\n#endif\\n#ifdef SS_THICKNESSANDMASK_TEXTURE\\nuniform vec2 vThicknessInfos;\\nuniform mat4 thicknessMatrix;\\n#endif\\n#ifdef SS_REFRACTIONINTENSITY_TEXTURE\\nuniform vec2 vRefractionIntensityInfos;\\nuniform mat4 refractionIntensityMatrix;\\n#endif\\n#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE\\nuniform vec2 vTranslucencyIntensityInfos;\\nuniform mat4 translucencyIntensityMatrix;\\n#endif\\n#endif\\n#ifdef NORMAL\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#ifdef SPHERICAL_HARMONICS\\nuniform vec3 vSphericalL00;\\nuniform vec3 vSphericalL1_1;\\nuniform vec3 vSphericalL10;\\nuniform vec3 vSphericalL11;\\nuniform vec3 vSphericalL2_2;\\nuniform vec3 vSphericalL2_1;\\nuniform vec3 vSphericalL20;\\nuniform vec3 vSphericalL21;\\nuniform vec3 vSphericalL22;\\n#else\\nuniform vec3 vSphericalX;\\nuniform vec3 vSphericalY;\\nuniform vec3 vSphericalZ;\\nuniform vec3 vSphericalXX_ZZ;\\nuniform vec3 vSphericalYY_ZZ;\\nuniform vec3 vSphericalZZ;\\nuniform vec3 vSphericalXY;\\nuniform vec3 vSphericalYZ;\\nuniform vec3 vSphericalZX;\\n#endif\\n#endif\\n#endif\\n#endif\\n#ifdef DETAIL\\nuniform vec4 vDetailInfos;\\nuniform mat4 detailMatrix;\\n#endif\\n#define ADDITIONAL_VERTEX_DECLARATION\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var pbrVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=pbrVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/pbrVertexDeclaration.js\";\nimport \"./ShadersInclude/pbrUboDeclaration.js\";\nimport \"./ShadersInclude/uvAttributeDeclaration.js\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/prePassVertexDeclaration.js\";\nimport \"./ShadersInclude/samplerVertexDeclaration.js\";\nimport \"./ShadersInclude/harmonicsFunctions.js\";\nimport \"./ShadersInclude/bumpVertexDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/fogVertexDeclaration.js\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"./ShadersInclude/lightVxUboDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/logDepthDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/prePassVertex.js\";\nimport \"./ShadersInclude/uvVariableDeclaration.js\";\nimport \"./ShadersInclude/samplerVertexImplementation.js\";\nimport \"./ShadersInclude/bumpVertex.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nimport \"./ShadersInclude/fogVertex.js\";\nimport \"./ShadersInclude/shadowsVertex.js\";\nimport \"./ShadersInclude/vertexColorMixing.js\";\nimport \"./ShadersInclude/logDepthVertex.js\";\nvar name = \"pbrVertexShader\";\nvar shader = \"precision highp float;\\n#include<__decl__pbrVertex>\\n#define CUSTOM_VERTEX_BEGIN\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#ifdef TANGENT\\nattribute vec4 tangent;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#include<uvAttributeDeclaration>[2..7]\\n#include<mainUVVaryingDeclaration>[1..7]\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<helperFunctions>\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<instancesDeclaration>\\n#include<prePassVertexDeclaration>\\n#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\\n#ifdef CLEARCOAT\\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)\\n#endif\\n#ifdef IRIDESCENCE\\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)\\n#endif\\n#ifdef SHEEN\\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)\\n#endif\\n#ifdef ANISOTROPIC\\n#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)\\n#endif\\n#ifdef SUBSURFACE\\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)\\n#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)\\n#endif\\nvarying vec3 vPositionW;\\n#if DEBUGMODE>0\\nvarying vec4 vClipSpacePosition;\\n#endif\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\\nvarying vec3 vEnvironmentIrradiance;\\n#include<harmonicsFunctions>\\n#endif\\n#endif\\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\\nvarying vec4 vColor;\\n#endif\\n#include<bumpVertexDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#include<logDepthDeclaration>\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec3 positionUpdated=position;\\n#ifdef NORMAL\\nvec3 normalUpdated=normal;\\n#endif\\n#ifdef TANGENT\\nvec4 tangentUpdated=tangent;\\n#endif\\n#ifdef UV1\\nvec2 uvUpdated=uv;\\n#endif\\n#include<morphTargetsVertexGlobal>\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvPositionUVW=positionUpdated;\\n#endif\\n#define CUSTOM_VERTEX_UPDATE_POSITION\\n#define CUSTOM_VERTEX_UPDATE_NORMAL\\n#include<instancesVertex>\\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\\n#endif\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\nvPositionW=vec3(worldPos);\\n#include<prePassVertex>\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\\nvNormalW=normalize(normalWorld*vNormalW);\\n#else\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvNormalW=normalize(normalWorld*normalUpdated);\\n#endif\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\\nvec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nreflectionVector.z*=-1.0;\\n#endif\\nvEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);\\n#endif\\n#endif\\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\\n#ifdef MULTIVIEW\\nif (gl_ViewID_OVR==0u) {\\ngl_Position=viewProjection*worldPos;\\n} else {\\ngl_Position=viewProjectionR*worldPos;\\n}\\n#else\\ngl_Position=viewProjection*worldPos;\\n#endif\\n#if DEBUGMODE>0\\nvClipSpacePosition=gl_Position;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\\n#endif\\n#ifndef UV1\\nvec2 uvUpdated=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uvUpdated;\\n#endif\\n#include<uvVariableDeclaration>[2..7]\\n#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\\n#ifdef CLEARCOAT\\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)\\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)\\n#endif\\n#ifdef IRIDESCENCE\\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)\\n#endif\\n#ifdef SHEEN\\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.z)\\n#endif\\n#ifdef ANISOTROPIC\\n#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)\\n#endif\\n#ifdef SUBSURFACE\\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)\\n#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)\\n#endif\\n#include<bumpVertex>\\n#include<clipPlaneVertex>\\n#include<fogVertex>\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n#include<vertexColorMixing>\\n#if defined(POINTSIZE) && !defined(WEBGPU)\\ngl_PointSize=pointSize;\\n#endif\\n#include<logDepthVertex>\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var pbrVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=pbr.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"postprocessVertexShader\";\nvar shader = \"attribute vec2 position;\\nuniform vec2 scale;\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvUV=(position*madd+madd)*scale;\\ngl_Position=vec4(position,0.0,1.0);\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var postprocessVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=postprocess.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"proceduralVertexShader\";\nvar shader = \"attribute vec2 position;\\nvarying vec2 vPosition;\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvPosition=position;\\nvUV=position*madd+madd;\\ngl_Position=vec4(position,0.0,1.0);\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var proceduralVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=procedural.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"refractionPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D refractionSampler;\\nuniform vec3 baseColor;\\nuniform float depth;\\nuniform float colorLevel;\\nvoid main() {\\nfloat ref=1.0-texture2D(refractionSampler,vUV).r;\\nvec2 uv=vUV-vec2(0.5);\\nvec2 offset=uv*depth*ref;\\nvec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;\\ngl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var refractionPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=refraction.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nvar name = \"rgbdDecodePixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#include<helperFunctions>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\ngl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var rgbdDecodePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=rgbdDecode.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nvar name = \"rgbdEncodePixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#include<helperFunctions>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\ngl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var rgbdEncodePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=rgbdEncode.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"screenSpaceCurvaturePixelShader\";\nvar shader = \"precision highp float;\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D normalSampler;\\nuniform float curvature_ridge;\\nuniform float curvature_valley;\\n#ifndef CURVATURE_OFFSET\\n#define CURVATURE_OFFSET 1\\n#endif\\nfloat curvature_soft_clamp(float curvature,float control)\\n{\\nif (curvature<0.5/control)\\nreturn curvature*(1.0-curvature*control);\\nreturn 0.25/control;\\n}\\nfloat calculate_curvature(ivec2 texel,float ridge,float valley)\\n{\\nvec2 normal_up =texelFetch(normalSampler,texel+ivec2(0, CURVATURE_OFFSET),0).rb;\\nvec2 normal_down =texelFetch(normalSampler,texel+ivec2(0,-CURVATURE_OFFSET),0).rb;\\nvec2 normal_left =texelFetch(normalSampler,texel+ivec2(-CURVATURE_OFFSET,0),0).rb;\\nvec2 normal_right=texelFetch(normalSampler,texel+ivec2( CURVATURE_OFFSET,0),0).rb;\\nfloat normal_diff=((normal_up.g-normal_down.g)+(normal_right.r-normal_left.r));\\nif (normal_diff<0.0)\\nreturn -2.0*curvature_soft_clamp(-normal_diff,valley);\\nreturn 2.0*curvature_soft_clamp(normal_diff,ridge);\\n}\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\nivec2 texel=ivec2(gl_FragCoord.xy);\\nvec4 baseColor=texture2D(textureSampler,vUV);\\nfloat curvature=calculate_curvature(texel,curvature_ridge,curvature_valley);\\nbaseColor.rgb*=curvature+1.0;\\ngl_FragColor=baseColor;\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var screenSpaceCurvaturePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=screenSpaceCurvature.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"screenSpaceReflectionPixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\n#ifdef SSR_SUPPORTED\\nuniform sampler2D reflectivitySampler;\\nuniform sampler2D normalSampler;\\nuniform sampler2D positionSampler;\\n#endif\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform float stepSize;\\nuniform float strength;\\nuniform float threshold;\\nuniform float roughnessFactor;\\nuniform float reflectionSpecularFalloffExponent;\\nvarying vec2 vUV;\\n#ifdef SSR_SUPPORTED\\nstruct ReflectionInfo {\\nvec3 color;\\nvec4 coords;\\n};\\n/**\\n* According to specular,see https:\\n*/\\nvec3 fresnelSchlick(float cosTheta,vec3 F0)\\n{\\nreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\\n}\\n/**\\n* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit\\n* by sampling multiple reflection pixels.\\n*/\\nReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)\\n{\\nReflectionInfo info;\\ninfo.color=vec3(0.0);\\nvec4 projectedCoord;\\nfloat sampledDepth;\\nfor(int i=0; i<SMOOTH_STEPS; i++)\\n{\\nprojectedCoord=projection*vec4(hitCoord,1.0);\\nprojectedCoord.xy/=projectedCoord.w;\\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\\nsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\\nfloat depth=sampledDepth-hitCoord.z;\\ndir*=0.5;\\nif(depth>0.0)\\nhitCoord-=dir;\\nelse\\nhitCoord+=dir;\\ninfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\\n}\\nprojectedCoord=projection*vec4(hitCoord,1.0);\\nprojectedCoord.xy/=projectedCoord.w;\\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,1.0);\\ninfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\\ninfo.color/=float(SMOOTH_STEPS+1);\\nreturn info;\\n}\\n/**\\n* Tests the given world position (hitCoord) according to the given reflection vector (dir)\\n* until it finds a collision (means that depth is enough close to say \\\"it's the pixel to sample!\\\").\\n*/\\nReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)\\n{\\nReflectionInfo info;\\nvec4 projectedCoord;\\nfloat sampledDepth;\\ndir*=stepSize;\\nfor(int i=0; i<REFLECTION_SAMPLES; i++)\\n{\\nhitCoord+=dir;\\nprojectedCoord=projection*vec4(hitCoord,1.0);\\nprojectedCoord.xy/=projectedCoord.w;\\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\\nsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\\nfloat depth=sampledDepth-hitCoord.z;\\n#ifdef RIGHT_HANDED_SCENE\\ndepth*=-1.0;\\n#endif\\nif(((depth-dir.z)<threshold) && depth<=0.0)\\n{\\n#ifdef ENABLE_SMOOTH_REFLECTIONS\\nreturn smoothReflectionInfo(dir,hitCoord);\\n#else\\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\\nreturn info;\\n#endif\\n}\\n}\\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\\nreturn info;\\n}\\nvec3 hash(vec3 a)\\n{\\na=fract(a*0.8);\\na+=dot(a,a.yxz+19.19);\\nreturn fract((a.xxy+a.yxx)*a.zyx);\\n}\\n#endif\\nvoid main()\\n{\\n#ifdef SSR_SUPPORTED\\nvec4 albedoFull=texture2D(textureSampler,vUV);\\nvec3 albedo=albedoFull.rgb;\\nfloat spec=texture2D(reflectivitySampler,vUV).r;\\nif (spec==0.0) {\\ngl_FragColor=albedoFull;\\nreturn;\\n}\\nvec3 normal=(texture2D(normalSampler,vUV)).xyz;\\nvec3 position=(view*texture2D(positionSampler,vUV)).xyz;\\nvec3 reflected=normalize(reflect(normalize(position),normalize(normal)));\\nfloat roughness=1.0-texture2D(reflectivitySampler,vUV).a;\\nvec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;\\nReflectionInfo info=getReflectionInfo(jitt+reflected,position);\\nvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));\\nfloat screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\\nvec3 F0=vec3(0.04);\\nF0 =mix(F0,albedo,spec);\\nvec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);\\n#ifdef RIGHT_HANDED_SCENE\\nreflected.z*=-1.0;\\n#endif\\nfloat reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);\\nfloat albedoMultiplier=1.0-reflectionMultiplier;\\nvec3 SSR=info.color*fresnel;\\ngl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);\\n#else\\ngl_FragColor=texture2D(textureSampler,vUV);\\n#endif\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var screenSpaceReflectionPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=screenSpaceReflection.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"bayerDitherFunctions\";\nvar shader = \"float bayerDither2(vec2 _P) {\\nreturn mod(2.0*_P.y+_P.x+1.0,4.0);\\n}\\nfloat bayerDither4(vec2 _P) {\\nvec2 P1=mod(_P,2.0); \\nvec2 P2=floor(0.5*mod(_P,4.0)); \\nreturn 4.0*bayerDither2(P1)+bayerDither2(P2);\\n}\\nfloat bayerDither8(vec2 _P) {\\nvec2 P1=mod(_P,2.0); \\nvec2 P2=floor(0.5 *mod(_P,4.0)); \\nvec2 P4=floor(0.25*mod(_P,8.0)); \\nreturn 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);\\n}\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var bayerDitherFunctions = { name: name, shader: shader };\n//# sourceMappingURL=bayerDitherFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./packingFunctions.js\";\nimport \"./bayerDitherFunctions.js\";\nvar name = \"shadowMapFragmentExtraDeclaration\";\nvar shader = \"#if SM_FLOAT==0\\n#include<packingFunctions>\\n#endif\\n#if SM_SOFTTRANSPARENTSHADOW==1\\n#include<bayerDitherFunctions>\\nuniform float softTransparentShadowSM;\\n#endif\\nvarying float vDepthMetricSM;\\n#if SM_USEDISTANCE==1\\nuniform vec3 lightDataSM;\\nvarying vec3 vPositionWSM;\\n#endif\\nuniform vec3 biasAndScaleSM;\\nuniform vec2 depthValuesSM;\\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\\nvarying float zSM;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapFragmentExtraDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=shadowMapFragmentExtraDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"shadowMapFragment\";\nvar shader = \"float depthSM=vDepthMetricSM;\\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\\n#if SM_USEDISTANCE==1\\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\\n#else\\n#ifdef USE_REVERSE_DEPTHBUFFER\\ndepthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\\n#else\\ndepthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\\n#endif\\n#endif\\n#ifdef USE_REVERSE_DEPTHBUFFER\\ngl_FragDepth=clamp(1.0-depthSM,0.0,1.0);\\n#else\\ngl_FragDepth=clamp(depthSM,0.0,1.0); \\n#endif\\n#elif SM_USEDISTANCE==1\\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\\n#endif\\n#if SM_ESM==1\\ndepthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);\\n#endif\\n#if SM_FLOAT==1\\ngl_FragColor=vec4(depthSM,1.0,1.0,1.0);\\n#else\\ngl_FragColor=pack(depthSM);\\n#endif\\nreturn;\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapFragment = { name: name, shader: shader };\n//# sourceMappingURL=shadowMapFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/shadowMapFragmentExtraDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneFragment.js\";\nimport \"./ShadersInclude/shadowMapFragment.js\";\nvar name = \"shadowMapPixelShader\";\nvar shader = \"#include<shadowMapFragmentExtraDeclaration>\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\n#include<clipPlaneFragmentDeclaration>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\n#include<clipPlaneFragment>\\n#ifdef ALPHATEST\\nfloat alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;\\nif (alphaFromAlphaTexture<ALPHATESTVALUE)\\ndiscard;\\n#endif\\n#if SM_SOFTTRANSPARENTSHADOW==1\\n#ifdef ALPHATEST\\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;\\n#else\\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;\\n#endif\\n#endif\\n#include<shadowMapFragment>\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=shadowMap.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"sceneVertexDeclaration\";\nvar shader = \"uniform mat4 viewProjection;\\n#ifdef MULTIVIEW\\nuniform mat4 viewProjectionR;\\n#endif\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform vec4 vEyePosition;\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var sceneVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=sceneVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"meshVertexDeclaration\";\nvar shader = \"uniform mat4 world;\\nuniform float visibility;\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var meshVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=meshVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneVertexDeclaration.js\";\nimport \"./meshVertexDeclaration.js\";\nvar name = \"shadowMapVertexDeclaration\";\nvar shader = \"#include<sceneVertexDeclaration>\\n#include<meshVertexDeclaration>\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapVertexDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=shadowMapVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nimport \"./sceneUboDeclaration.js\";\nimport \"./meshUboDeclaration.js\";\nvar name = \"shadowMapUboDeclaration\";\nvar shader = \"layout(std140,column_major) uniform;\\n#include<sceneUboDeclaration>\\n#include<meshUboDeclaration>\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapUboDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=shadowMapUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"shadowMapVertexExtraDeclaration\";\nvar shader = \"#if SM_NORMALBIAS==1\\nuniform vec3 lightDataSM;\\n#endif\\nuniform vec3 biasAndScaleSM;\\nuniform vec2 depthValuesSM;\\nvarying float vDepthMetricSM;\\n#if SM_USEDISTANCE==1\\nvarying vec3 vPositionWSM;\\n#endif\\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\\nvarying float zSM;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapVertexExtraDeclaration = { name: name, shader: shader };\n//# sourceMappingURL=shadowMapVertexExtraDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"shadowMapVertexNormalBias\";\nvar shader = \"#if SM_NORMALBIAS==1\\n#if SM_DIRECTIONINLIGHTDATA==1\\nvec3 worldLightDirSM=normalize(-lightDataSM.xyz);\\n#else\\nvec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;\\nvec3 worldLightDirSM=normalize(directionToLightSM);\\n#endif\\nfloat ndlSM=dot(vNormalW,worldLightDirSM);\\nfloat sinNLSM=sqrt(1.0-ndlSM*ndlSM);\\nfloat normalBiasSM=biasAndScaleSM.y*sinNLSM;\\nworldPos.xyz-=vNormalW*normalBiasSM;\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapVertexNormalBias = { name: name, shader: shader };\n//# sourceMappingURL=shadowMapVertexNormalBias.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"shadowMapVertexMetric\";\nvar shader = \"#if SM_USEDISTANCE==1\\nvPositionWSM=worldPos.xyz;\\n#endif\\n#if SM_DEPTHTEXTURE==1\\n#ifdef IS_NDC_HALF_ZRANGE\\n#define BIASFACTOR 0.5\\n#else\\n#define BIASFACTOR 1.0\\n#endif\\n#ifdef USE_REVERSE_DEPTHBUFFER\\ngl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\\n#else\\ngl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\\n#endif\\n#endif\\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\\nzSM=gl_Position.z;\\ngl_Position.z=0.0;\\n#elif SM_USEDISTANCE==0\\n#ifdef USE_REVERSE_DEPTHBUFFER\\nvDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\\n#else\\nvDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\\n#endif\\n#endif\\n\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapVertexMetric = { name: name, shader: shader };\n//# sourceMappingURL=shadowMapVertexMetric.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/shadowMapVertexDeclaration.js\";\nimport \"./ShadersInclude/shadowMapUboDeclaration.js\";\nimport \"./ShadersInclude/shadowMapVertexExtraDeclaration.js\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nimport \"./ShadersInclude/shadowMapVertexNormalBias.js\";\nimport \"./ShadersInclude/shadowMapVertexMetric.js\";\nimport \"./ShadersInclude/clipPlaneVertex.js\";\nvar name = \"shadowMapVertexShader\";\nvar shader = \"attribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#ifdef INSTANCES\\nattribute vec4 world0;\\nattribute vec4 world1;\\nattribute vec4 world2;\\nattribute vec4 world3;\\n#endif\\n#include<helperFunctions>\\n#include<__decl__shadowMapVertex>\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\n#include<shadowMapVertexExtraDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void)\\n{\\nvec3 positionUpdated=position;\\n#ifdef UV1\\nvec2 uvUpdated=uv;\\n#endif\\n#ifdef NORMAL\\nvec3 normalUpdated=normal;\\n#endif\\n#include<morphTargetsVertexGlobal>\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\n#ifdef NORMAL\\nmat3 normWorldSM=mat3(finalWorld);\\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\\nvec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));\\nvNormalW=normalize(normWorldSM*vNormalW);\\n#else\\n#ifdef NONUNIFORMSCALING\\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\\n#endif\\nvec3 vNormalW=normalize(normWorldSM*normalUpdated);\\n#endif\\n#endif\\n#include<shadowMapVertexNormalBias>\\ngl_Position=viewProjection*worldPos;\\n#include<shadowMapVertexMetric>\\n#ifdef ALPHATEST\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n#include<clipPlaneVertex>\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var shadowMapVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=shadowMap.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"sharpenPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 screenSize;\\nuniform vec2 sharpnessAmounts;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\\nvec4 color=texture2D(textureSampler,vUV);\\nvec4 edgeDetection=texture2D(textureSampler,vUV+onePixel*vec2(0,-1)) +\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0)) +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0)) +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1)) -\\ncolor*4.0;\\ngl_FragColor=max(vec4(color.rgb*sharpnessAmounts.y,color.a)-(sharpnessAmounts.x*vec4(edgeDetection.rgb,0)),0.);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var sharpenPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=sharpen.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"ssaoPixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\nvarying vec2 vUV;\\n#ifdef SSAO\\nuniform sampler2D randomSampler;\\nuniform float randTextureTiles;\\nuniform float samplesFactor;\\nuniform vec3 sampleSphere[SAMPLES];\\nuniform float totalStrength;\\nuniform float radius;\\nuniform float area;\\nuniform float fallOff;\\nuniform float base;\\nvec3 normalFromDepth(float depth,vec2 coords)\\n{\\nvec2 offset1=vec2(0.0,radius);\\nvec2 offset2=vec2(radius,0.0);\\nfloat depth1=texture2D(textureSampler,coords+offset1).r;\\nfloat depth2=texture2D(textureSampler,coords+offset2).r;\\nvec3 p1=vec3(offset1,depth1-depth);\\nvec3 p2=vec3(offset2,depth2-depth);\\nvec3 normal=cross(p1,p2);\\nnormal.z=-normal.z;\\nreturn normalize(normal);\\n}\\nvoid main()\\n{\\nvec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);\\nfloat depth=texture2D(textureSampler,vUV).r;\\nvec3 position=vec3(vUV,depth);\\nvec3 normal=normalFromDepth(depth,vUV);\\nfloat radiusDepth=radius/depth;\\nfloat occlusion=0.0;\\nvec3 ray;\\nvec3 hemiRay;\\nfloat occlusionDepth;\\nfloat difference;\\nfor (int i=0; i<SAMPLES; i++)\\n{\\nray=radiusDepth*reflect(sampleSphere[i],random);\\nhemiRay=position+sign(dot(ray,normal))*ray;\\nocclusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;\\ndifference=depth-occlusionDepth;\\nocclusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));\\n}\\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\\nfloat result=clamp(ao+base,0.0,1.0);\\ngl_FragColor.r=result;\\ngl_FragColor.g=result;\\ngl_FragColor.b=result;\\ngl_FragColor.a=1.0;\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var ssaoPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=ssao.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"ssao2PixelShader\";\nvar shader = \"precision highp float;\\nuniform sampler2D textureSampler;\\nuniform float near;\\nuniform float far;\\nuniform float radius;\\nfloat scales[16]=float[16](\\n0.1,\\n0.11406250000000001,\\n0.131640625,\\n0.15625,\\n0.187890625,\\n0.2265625,\\n0.272265625,\\n0.325,\\n0.384765625,\\n0.4515625,\\n0.525390625,\\n0.60625,\\n0.694140625,\\n0.7890625,\\n0.891015625,\\n1.0\\n);\\nvarying vec2 vUV;\\nfloat perspectiveDepthToViewZ(in float invClipZ,in float near,in float far ) {\\nreturn ( near*far )/( ( far-near )*invClipZ-far );\\n}\\nfloat viewZToPerspectiveDepth( in float viewZ,in float near,in float far ) {\\nreturn ( near*far/viewZ+far)/( far-near );\\n}\\nfloat viewZToOrthographicDepth( in float viewZ,in float near,in float far ) {\\nreturn ( viewZ+near )/( near-far );\\n}\\n#ifdef SSAO\\nuniform sampler2D randomSampler;\\nuniform sampler2D depthSampler;\\nuniform sampler2D normalSampler;\\nuniform float randTextureTiles;\\nuniform float samplesFactor;\\nuniform vec3 sampleSphere[SAMPLES];\\nuniform float totalStrength;\\nuniform float base;\\nuniform float xViewport;\\nuniform float yViewport;\\nuniform mat3 depthProjection;\\nuniform float maxZ;\\nuniform float minZAspect;\\nuniform vec2 texelSize;\\nuniform mat4 projection;\\nvoid main()\\n{\\nvec3 random=texture2D(randomSampler,vUV*randTextureTiles).rgb;\\nfloat depth=texture2D(depthSampler,vUV).r;\\nfloat depthSign=depth/abs(depth);\\ndepth=depth*depthSign;\\nvec3 normal=texture2D(normalSampler,vUV).rgb;\\nfloat occlusion=0.0;\\nfloat correctedRadius=min(radius,minZAspect*depth/near);\\nvec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);\\nvec3 vDepthFactor=depthProjection*vec3(1.0,1.0,depth);\\nvec3 origin=vViewRay*vDepthFactor;\\nvec3 rvec=random*2.0-1.0;\\nrvec.z=0.0;\\nfloat dotProduct=dot(rvec,normal);\\nrvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);\\nvec3 tangent=normalize(rvec-normal*dot(rvec,normal));\\nvec3 bitangent=cross(normal,tangent);\\nmat3 tbn=mat3(tangent,bitangent,normal);\\nfloat difference;\\nfor (int i=0; i<SAMPLES; ++i) {\\nvec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];\\nsamplePosition=samplePosition*correctedRadius+origin;\\nvec4 offset=vec4(samplePosition,1.0);\\noffset=projection*offset;\\noffset.xyz/=offset.w;\\noffset.xy=offset.xy*0.5+0.5;\\nif (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {\\ncontinue;\\n}\\nfloat sampleDepth=abs(texture2D(depthSampler,offset.xy).r);\\ndifference=depthSign*samplePosition.z-sampleDepth;\\nfloat rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);\\nocclusion+=(difference>=0.0 ? 1.0 : 0.0)*rangeCheck;\\n}\\nocclusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));\\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\\nfloat result=clamp(ao+base,0.0,1.0);\\ngl_FragColor=vec4(vec3(result),1.0);\\n}\\n#endif\\n#ifdef BILATERAL_BLUR\\nuniform sampler2D depthSampler;\\nuniform float outSize;\\nuniform float samplerOffsets[SAMPLES];\\nvec4 blur9(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.3846153846)*direction;\\nvec2 off2=vec2(3.2307692308)*direction;\\ncolor+=texture2D(image,uv)*0.2270270270;\\ncolor+=texture2D(image,uv+(off1/resolution))*0.3162162162;\\ncolor+=texture2D(image,uv-(off1/resolution))*0.3162162162;\\ncolor+=texture2D(image,uv+(off2/resolution))*0.0702702703;\\ncolor+=texture2D(image,uv-(off2/resolution))*0.0702702703;\\nreturn color;\\n}\\nvec4 blur13(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.411764705882353)*direction;\\nvec2 off2=vec2(3.2941176470588234)*direction;\\nvec2 off3=vec2(5.176470588235294)*direction;\\ncolor+=texture2D(image,uv)*0.1964825501511404;\\ncolor+=texture2D(image,uv+(off1/resolution))*0.2969069646728344;\\ncolor+=texture2D(image,uv-(off1/resolution))*0.2969069646728344;\\ncolor+=texture2D(image,uv+(off2/resolution))*0.09447039785044732;\\ncolor+=texture2D(image,uv-(off2/resolution))*0.09447039785044732;\\ncolor+=texture2D(image,uv+(off3/resolution))*0.010381362401148057;\\ncolor+=texture2D(image,uv-(off3/resolution))*0.010381362401148057;\\nreturn color;\\n}\\nvec4 blur13Bilateral(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.411764705882353)*direction;\\nvec2 off2=vec2(3.2941176470588234)*direction;\\nvec2 off3=vec2(5.176470588235294)*direction;\\nfloat compareDepth=abs(texture2D(depthSampler,uv).r);\\nfloat sampleDepth;\\nfloat weight;\\nfloat weightSum=30.0;\\ncolor+=texture2D(image,uv)*30.0;\\nsampleDepth=abs(texture2D(depthSampler,uv+(off1/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+= weight;\\ncolor+=texture2D(image,uv+(off1/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv-(off1/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+= weight;\\ncolor+=texture2D(image,uv-(off1/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv+(off2/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off2/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv-(off2/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off2/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv+(off3/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off3/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv-(off3/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off3/resolution))*weight;\\nreturn color/weightSum;\\n}\\nvoid main()\\n{\\n#if EXPENSIVE\\nfloat compareDepth=abs(texture2D(depthSampler,vUV).r);\\nfloat texelsize=1.0/outSize;\\nfloat result=0.0;\\nfloat weightSum=0.0;\\nfor (int i=0; i<SAMPLES; ++i)\\n{\\n#ifdef BILATERAL_BLUR_H\\nvec2 direction=vec2(1.0,0.0);\\nvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\\n#else\\nvec2 direction=vec2(0.0,1.0);\\nvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\\n#endif\\nvec2 samplePos=vUV+sampleOffset;\\nfloat sampleDepth=abs(texture2D(depthSampler,samplePos).r);\\nfloat weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30000.0);\\nresult+=texture2D(textureSampler,samplePos).r*weight;\\nweightSum+=weight;\\n}\\nresult/=weightSum;\\ngl_FragColor.rgb=vec3(result);\\ngl_FragColor.a=1.0;\\n#else\\nvec4 color;\\n#ifdef BILATERAL_BLUR_H\\nvec2 direction=vec2(1.0,0.0);\\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\\n#else\\nvec2 direction=vec2(0.0,1.0);\\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\\n#endif\\ngl_FragColor.rgb=vec3(color.r);\\ngl_FragColor.a=1.0;\\n#endif\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var ssao2PixelShader = { name: name, shader: shader };\n//# sourceMappingURL=ssao2.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"ssaoCombinePixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\nuniform sampler2D originalColor;\\nuniform vec4 viewport;\\nvarying vec2 vUV;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\nvec4 ssaoColor=texture2D(textureSampler,viewport.xy+vUV*viewport.zw);\\nvec4 sceneColor=texture2D(originalColor,vUV);\\ngl_FragColor=sceneColor*ssaoColor;\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var ssaoCombinePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=ssaoCombine.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/packingFunctions.js\";\nvar name = \"standardPixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\nvarying vec2 vUV;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\n#if defined(PASS_POST_PROCESS)\\nvoid main(void)\\n{\\nvec4 color=texture2D(textureSampler,vUV);\\ngl_FragColor=color;\\n}\\n#endif\\n#if defined(DOWN_SAMPLE_X4)\\nuniform vec2 dsOffsets[16];\\nvoid main(void)\\n{\\nvec4 average=vec4(0.0,0.0,0.0,0.0);\\naverage=texture2D(textureSampler,vUV+dsOffsets[0]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[1]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[2]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[3]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[4]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[5]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[6]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[7]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[8]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[9]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[10]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[11]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[12]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[13]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[14]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[15]);\\naverage/=16.0;\\ngl_FragColor=average;\\n}\\n#endif\\n#if defined(BRIGHT_PASS)\\nuniform vec2 dsOffsets[4];\\nuniform float brightThreshold;\\nvoid main(void)\\n{\\nvec4 average=vec4(0.0,0.0,0.0,0.0);\\naverage=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));\\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));\\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));\\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));\\naverage*=0.25;\\nfloat luminance=length(average.rgb);\\nif (luminance<brightThreshold) {\\naverage=vec4(0.0,0.0,0.0,1.0);\\n}\\ngl_FragColor=average;\\n}\\n#endif\\n#if defined(TEXTURE_ADDER)\\nuniform sampler2D otherSampler;\\nuniform sampler2D lensSampler;\\nuniform float exposure;\\nvoid main(void)\\n{\\nvec3 colour=texture2D(textureSampler,vUV).rgb;\\ncolour*=exposure;\\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\\ncolour=retColor*retColor;\\ncolour+=colour*texture2D(lensSampler,vUV).rgb;\\nvec4 finalColor=vec4(colour.rgb,1.0)+texture2D(otherSampler,vUV);\\ngl_FragColor=finalColor;\\n}\\n#endif\\n#if defined(VLS)\\n#define PI 3.1415926535897932384626433832795\\nuniform mat4 shadowViewProjection;\\nuniform mat4 lightWorld;\\nuniform vec3 cameraPosition;\\nuniform vec3 sunDirection;\\nuniform vec3 sunColor;\\nuniform vec2 depthValues;\\nuniform float scatteringCoefficient;\\nuniform float scatteringPower;\\nuniform sampler2D shadowMapSampler;\\nuniform sampler2D positionSampler;\\nfloat computeScattering(float lightDotView)\\n{\\nfloat result=1.0-scatteringCoefficient*scatteringCoefficient;\\nresult/=(4.0*PI*pow(1.0+scatteringCoefficient*scatteringCoefficient-(2.0*scatteringCoefficient)*lightDotView,1.5));\\nreturn result;\\n}\\nvoid main(void)\\n{\\nvec3 worldPos=texture2D(positionSampler,vUV).rgb;\\nvec3 startPosition=cameraPosition;\\nvec3 rayVector=worldPos-startPosition;\\nfloat rayLength=length(rayVector);\\nvec3 rayDirection=rayVector/rayLength;\\nfloat stepLength=rayLength/NB_STEPS;\\nvec3 stepL=rayDirection*stepLength;\\nvec3 currentPosition=startPosition;\\nvec3 accumFog=vec3(0.0);\\nfor (int i=0; i<int(NB_STEPS); i++)\\n{\\nvec4 worldInShadowCameraSpace=shadowViewProjection*vec4(currentPosition,1.0);\\nfloat depthMetric= (worldInShadowCameraSpace.z+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depthMetric,0.0,1.0);\\nworldInShadowCameraSpace.xyz/=worldInShadowCameraSpace.w;\\nworldInShadowCameraSpace.xyz=0.5*worldInShadowCameraSpace.xyz+vec3(0.5);\\nfloat shadowMapValue=texture2D(shadowMapSampler,worldInShadowCameraSpace.xy).r;\\nif (shadowMapValue>shadowPixelDepth)\\naccumFog+=sunColor*computeScattering(dot(rayDirection,sunDirection));\\ncurrentPosition+=stepL;\\n}\\naccumFog/=NB_STEPS;\\nvec3 color=accumFog*scatteringPower;\\ngl_FragColor=vec4(color*exp(color) ,1.0);\\n}\\n#endif\\n#if defined(VLSMERGE)\\nuniform sampler2D originalSampler;\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(originalSampler,vUV)+texture2D(textureSampler,vUV);\\n}\\n#endif\\n#if defined(LUMINANCE)\\nuniform vec2 lumOffsets[4];\\nvoid main()\\n{\\nfloat average=0.0;\\nvec4 color=vec4(0.0);\\nfloat maximum=-1e20;\\nvec3 weight=vec3(0.299,0.587,0.114);\\nfor (int i=0; i<4; i++)\\n{\\ncolor=texture2D(textureSampler,vUV+ lumOffsets[i]);\\nfloat GreyValue=dot(color.rgb,vec3(0.33,0.33,0.33));\\n#ifdef WEIGHTED_AVERAGE\\nfloat GreyValue=dot(color.rgb,weight);\\n#endif\\n#ifdef BRIGHTNESS\\nfloat GreyValue=max(color.r,max(color.g,color.b));\\n#endif\\n#ifdef HSL_COMPONENT\\nfloat GreyValue=0.5*(max(color.r,max(color.g,color.b))+min(color.r,min(color.g,color.b)));\\n#endif\\n#ifdef MAGNITUDE\\nfloat GreyValue=length(color.rgb);\\n#endif\\nmaximum=max(maximum,GreyValue);\\naverage+=(0.25*log(1e-5+GreyValue));\\n}\\naverage=exp(average);\\ngl_FragColor=vec4(average,maximum,0.0,1.0);\\n}\\n#endif\\n#if defined(LUMINANCE_DOWN_SAMPLE)\\nuniform vec2 dsOffsets[9];\\nuniform float halfDestPixelSize;\\n#ifdef FINAL_DOWN_SAMPLER\\n#include<packingFunctions>\\n#endif\\nvoid main()\\n{\\nvec4 color=vec4(0.0);\\nfloat average=0.0;\\nfor (int i=0; i<9; i++)\\n{\\ncolor=texture2D(textureSampler,vUV+vec2(halfDestPixelSize,halfDestPixelSize)+dsOffsets[i]);\\naverage+=color.r;\\n}\\naverage/=9.0;\\n#ifdef FINAL_DOWN_SAMPLER\\ngl_FragColor=pack(average);\\n#else\\ngl_FragColor=vec4(average,average,0.0,1.0);\\n#endif\\n}\\n#endif\\n#if defined(HDR)\\nuniform sampler2D textureAdderSampler;\\nuniform float averageLuminance;\\nvoid main()\\n{\\nvec4 color=texture2D(textureAdderSampler,vUV);\\n#ifndef AUTO_EXPOSURE\\nvec4 adjustedColor=color/averageLuminance;\\ncolor=adjustedColor;\\ncolor.a=1.0;\\n#endif\\ngl_FragColor=color;\\n}\\n#endif\\n#if defined(LENS_FLARE)\\n#define GHOSTS 3\\nuniform sampler2D lensColorSampler;\\nuniform float strength;\\nuniform float ghostDispersal;\\nuniform float haloWidth;\\nuniform vec2 resolution;\\nuniform float distortionStrength;\\nfloat hash(vec2 p)\\n{\\nfloat h=dot(p,vec2(127.1,311.7));\\nreturn -1.0+2.0*fract(sin(h)*43758.5453123);\\n}\\nfloat noise(in vec2 p)\\n{\\nvec2 i=floor(p);\\nvec2 f=fract(p);\\nvec2 u=f*f*(3.0-2.0*f);\\nreturn mix(mix(hash(i+vec2(0.0,0.0)),\\nhash(i+vec2(1.0,0.0)),u.x),\\nmix(hash(i+vec2(0.0,1.0)),\\nhash(i+vec2(1.0,1.0)),u.x),u.y);\\n}\\nfloat fbm(vec2 p)\\n{\\nfloat f=0.0;\\nf+=0.5000*noise(p); p*=2.02;\\nf+=0.2500*noise(p); p*=2.03;\\nf+=0.1250*noise(p); p*=2.01;\\nf+=0.0625*noise(p); p*=2.04;\\nf/=0.9375;\\nreturn f;\\n}\\nvec3 pattern(vec2 uv)\\n{\\nvec2 p=-1.0+2.0*uv;\\nfloat p2=dot(p,p);\\nfloat f=fbm(vec2(15.0*p2))/2.0;\\nfloat r=0.2+0.6*sin(12.5*length(uv-vec2(0.5)));\\nfloat g=0.2+0.6*sin(20.5*length(uv-vec2(0.5)));\\nfloat b=0.2+0.6*sin(17.2*length(uv-vec2(0.5)));\\nreturn (1.0-f)*vec3(r,g,b);\\n}\\nfloat luminance(vec3 color)\\n{\\nreturn dot(color.rgb,vec3(0.2126,0.7152,0.0722));\\n}\\nvec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion)\\n{\\nreturn vec4(\\ntexture2D(tex,texcoord+direction*distortion.r).r,\\ntexture2D(tex,texcoord+direction*distortion.g).g,\\ntexture2D(tex,texcoord+direction*distortion.b).b,\\n1.0\\n);\\n}\\nvoid main(void)\\n{\\nvec2 uv=-vUV+vec2(1.0);\\nvec2 ghostDir=(vec2(0.5)-uv)*ghostDispersal;\\nvec2 texelSize=1.0/resolution;\\nvec3 distortion=vec3(-texelSize.x*distortionStrength,0.0,texelSize.x*distortionStrength);\\nvec4 result=vec4(0.0);\\nfloat ghostIndice=1.0;\\nfor (int i=0; i<GHOSTS; ++i)\\n{\\nvec2 offset=fract(uv+ghostDir*ghostIndice);\\nfloat weight=length(vec2(0.5)-offset)/length(vec2(0.5));\\nweight=pow(1.0-weight,10.0);\\nresult+=textureDistorted(textureSampler,offset,normalize(ghostDir),distortion)*weight*strength;\\nghostIndice+=1.0;\\n}\\nvec2 haloVec=normalize(ghostDir)*haloWidth;\\nfloat weight=length(vec2(0.5)-fract(uv+haloVec))/length(vec2(0.5));\\nweight=pow(1.0-weight,10.0);\\nresult+=textureDistorted(textureSampler,fract(uv+haloVec),normalize(ghostDir),distortion)*weight*strength;\\nresult*=texture2D(lensColorSampler,vec2(length(vec2(0.5)-uv)/length(vec2(0.5))));\\ngl_FragColor=result;\\n}\\n#endif\\n#if defined(LENS_FLARE_COMPOSE)\\nuniform sampler2D otherSampler;\\nuniform sampler2D lensDirtSampler;\\nuniform sampler2D lensStarSampler;\\nuniform mat4 lensStarMatrix;\\nvoid main(void)\\n{\\nvec2 lensFlareCoords=(lensStarMatrix*vec4(vUV,1.0,1.0)).xy;\\nvec4 lensMod=texture2D(lensDirtSampler,vUV);\\nlensMod+=texture2D(lensStarSampler,vUV/*lensFlareCoords*/);\\nvec4 result=texture2D(textureSampler,vUV)*lensMod;\\ngl_FragColor=texture2D(otherSampler,vUV)+result;\\n}\\n#endif\\n#if defined(DEPTH_OF_FIELD)\\nuniform sampler2D otherSampler;\\nuniform sampler2D depthSampler;\\nuniform float distance;\\nvoid main(void)\\n{\\nvec4 sharp=texture2D(otherSampler,vUV);\\nvec4 blur=texture2D(textureSampler,vUV);\\nfloat dist=clamp(texture2D(depthSampler,vUV).r*distance,0.0,1.0);\\nfloat factor=0.0;\\nif (dist<0.05)\\nfactor=1.0;\\nelse if (dist<0.1)\\nfactor=20.0*(0.1-dist);\\nelse if (dist<0.5)\\nfactor=0.0;\\nelse\\nfactor=2.0*(dist-0.5);\\nfactor=clamp(factor,0.0,0.90);\\ngl_FragColor=mix(sharp,blur,factor);\\n}\\n#endif\\n#if defined(MOTION_BLUR)\\nuniform mat4 inverseViewProjection;\\nuniform mat4 prevViewProjection;\\nuniform vec2 screenSize;\\nuniform float motionScale;\\nuniform float motionStrength;\\nuniform sampler2D depthSampler;\\nvoid main(void)\\n{\\nvec2 texelSize=1.0/screenSize;\\nfloat depth=texture2D(depthSampler,vUV).r;\\nvec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);\\ncpos=cpos*inverseViewProjection;\\nvec4 ppos=cpos*prevViewProjection;\\nppos.xyz/=ppos.w;\\nppos.xy=ppos.xy*0.5+0.5;\\nvec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;\\nfloat speed=length(velocity/texelSize);\\nint nSamples=int(clamp(speed,1.0,MAX_MOTION_SAMPLES));\\nvec4 result=texture2D(textureSampler,vUV);\\nfor (int i=1; i<int(MAX_MOTION_SAMPLES); ++i) {\\nif (i>=nSamples)\\nbreak;\\nvec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);\\nresult+=texture2D(textureSampler,offset1);\\n}\\ngl_FragColor=result/float(nSamples);\\n}\\n#endif\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var standardPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=standard.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"stereoscopicInterlacePixelShader\";\nvar shader = \"const vec3 TWO=vec3(2.0,2.0,2.0);\\nvarying vec2 vUV;\\nuniform sampler2D camASampler;\\nuniform sampler2D textureSampler;\\nuniform vec2 stepSize;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nbool useCamA;\\nbool useCamB;\\nvec2 texCoord1;\\nvec2 texCoord2;\\nvec3 frag1;\\nvec3 frag2;\\n#ifdef IS_STEREOSCOPIC_HORIZ\\nuseCamB=vUV.x>0.5;\\nuseCamA=!useCamB;\\ntexCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);\\ntexCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\\n#else\\n#ifdef IS_STEREOSCOPIC_INTERLACED\\nfloat rowNum=floor(vUV.y/stepSize.y);\\nuseCamA=mod(rowNum,2.0)==1.0;\\nuseCamB=mod(rowNum,2.0)==0.0;\\ntexCoord1=vec2(vUV.x,vUV.y);\\ntexCoord2=vec2(vUV.x,vUV.y);\\n#else\\nuseCamB=vUV.y>0.5;\\nuseCamA=!useCamB;\\ntexCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);\\ntexCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\\n#endif\\n#endif\\nif (useCamB){\\nfrag1=texture2D(textureSampler,texCoord1).rgb;\\nfrag2=texture2D(textureSampler,texCoord2).rgb;\\n}else if (useCamA){\\nfrag1=texture2D(camASampler ,texCoord1).rgb;\\nfrag2=texture2D(camASampler ,texCoord2).rgb;\\n}else {\\ndiscard;\\n}\\ngl_FragColor=vec4((frag1+frag2)/TWO,1.0);\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var stereoscopicInterlacePixelShader = { name: name, shader: shader };\n//# sourceMappingURL=stereoscopicInterlace.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"fibonacci\";\nvar shader = \"#define rcp(x) 1./x\\n#define GOLDEN_RATIO 1.618033988749895\\n#define TWO_PI 6.2831855\\nvec2 Golden2dSeq(int i,float n)\\n{\\nreturn vec2(float(i)/n+(0.5/n),fract(float(i)*rcp(GOLDEN_RATIO)));\\n}\\nvec2 SampleDiskGolden(int i,int sampleCount)\\n{\\nvec2 f=Golden2dSeq(i,float(sampleCount));\\nreturn vec2(sqrt(f.x),TWO_PI*f.y);\\n}\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var fibonacci = { name: name, shader: shader };\n//# sourceMappingURL=fibonacci.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nvar name = \"diffusionProfile\";\nvar shader = \"uniform vec3 diffusionS[5];\\nuniform float diffusionD[5];\\nuniform float filterRadii[5];\";\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @hidden */\nexport var diffusionProfile = { name: name, shader: shader };\n//# sourceMappingURL=diffusionProfile.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/fibonacci.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions.js\";\nimport \"./ShadersInclude/diffusionProfile.js\";\nvar name = \"subSurfaceScatteringPixelShader\";\nvar shader = \"#include<fibonacci>\\n#include<helperFunctions>\\n#include<subSurfaceScatteringFunctions>\\n#include<diffusionProfile>\\nvarying vec2 vUV;\\nuniform vec2 texelSize;\\nuniform sampler2D textureSampler;\\nuniform sampler2D irradianceSampler;\\nuniform sampler2D depthSampler;\\nuniform sampler2D albedoSampler;\\nuniform vec2 viewportSize;\\nuniform float metersPerUnit;\\nconst float LOG2_E=1.4426950408889634;\\nconst float SSS_PIXELS_PER_SAMPLE=4.;\\nconst int _SssSampleBudget=40;\\n#define rcp(x) 1./x\\n#define Sq(x) x*x\\n#define SSS_BILATERAL_FILTER true\\nvec3 EvalBurleyDiffusionProfile(float r,vec3 S)\\n{\\nvec3 exp_13=exp2(((LOG2_E*(-1.0/3.0))*r)*S); \\nvec3 expSum=exp_13*(1.+exp_13*exp_13); \\nreturn (S*rcp(8.*PI))*expSum; \\n}\\nvec2 SampleBurleyDiffusionProfile(float u,float rcpS)\\n{\\nu=1.-u; \\nfloat g=1.+(4.*u)*(2.*u+sqrt(1.+(4.*u)*u));\\nfloat n=exp2(log2(g)*(-1.0/3.0)); \\nfloat p=(g*n)*n; \\nfloat c=1.+p+n; \\nfloat d=(3./LOG2_E*2.)+(3./LOG2_E)*log2(u); \\nfloat x=(3./LOG2_E)*log2(c)-d; \\nfloat rcpExp=((c*c)*c)*rcp((4.*u)*((c*c)+(4.*u)*(4.*u)));\\nfloat r=x*rcpS;\\nfloat rcpPdf=(8.*PI*rcpS)*rcpExp; \\nreturn vec2(r,rcpPdf);\\n}\\nvec3 ComputeBilateralWeight(float xy2,float z,float mmPerUnit,vec3 S,float rcpPdf)\\n{\\n#ifndef SSS_BILATERAL_FILTER\\nz=0.;\\n#endif\\nfloat r=sqrt(xy2+(z*mmPerUnit)*(z*mmPerUnit));\\nfloat area=rcpPdf;\\n#if SSS_CLAMP_ARTIFACT\\nreturn clamp(EvalBurleyDiffusionProfile(r,S)*area,0.0,1.0);\\n#else\\nreturn EvalBurleyDiffusionProfile(r,S)*area;\\n#endif\\n}\\nvoid EvaluateSample(int i,int n,vec3 S,float d,vec3 centerPosVS,float mmPerUnit,float pixelsPerMm,\\nfloat phase,inout vec3 totalIrradiance,inout vec3 totalWeight)\\n{\\nfloat scale =rcp(float(n));\\nfloat offset=rcp(float(n))*0.5;\\nfloat sinPhase,cosPhase;\\nsinPhase=sin(phase);\\ncosPhase=cos(phase);\\nvec2 bdp=SampleBurleyDiffusionProfile(float(i)*scale+offset,d);\\nfloat r=bdp.x;\\nfloat rcpPdf=bdp.y;\\nfloat phi=SampleDiskGolden(i,n).y;\\nfloat sinPhi,cosPhi;\\nsinPhi=sin(phi);\\ncosPhi=cos(phi);\\nfloat sinPsi=cosPhase*sinPhi+sinPhase*cosPhi; \\nfloat cosPsi=cosPhase*cosPhi-sinPhase*sinPhi; \\nvec2 vec=r*vec2(cosPsi,sinPsi);\\nvec2 position; \\nfloat xy2;\\nposition=vUV+round((pixelsPerMm*r)*vec2(cosPsi,sinPsi))*texelSize;\\nxy2 =r*r;\\nvec4 textureSample=texture2D(irradianceSampler,position);\\nfloat viewZ=texture2D(depthSampler,position).r;\\nvec3 irradiance =textureSample.rgb;\\nif (testLightingForSSS(textureSample.a))\\n{\\nfloat relZ=viewZ-centerPosVS.z;\\nvec3 weight=ComputeBilateralWeight(xy2,relZ,mmPerUnit,S,rcpPdf);\\ntotalIrradiance+=weight*irradiance;\\ntotalWeight +=weight;\\n}\\nelse\\n{\\n}\\n}\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\nvec4 irradianceAndDiffusionProfile =texture2D(irradianceSampler,vUV);\\nvec3 centerIrradiance=irradianceAndDiffusionProfile.rgb;\\nint diffusionProfileIndex=int(round(irradianceAndDiffusionProfile.a*255.));\\nfloat centerDepth =0.;\\nvec4 inputColor=texture2D(textureSampler,vUV);\\nbool passedStencilTest=testLightingForSSS(irradianceAndDiffusionProfile.a);\\nif (passedStencilTest)\\n{\\ncenterDepth=texture2D(depthSampler,vUV).r;\\n}\\nif (!passedStencilTest) { \\ngl_FragColor=inputColor;\\nreturn;\\n}\\nfloat distScale =1.;\\nvec3 S =diffusionS[diffusionProfileIndex];\\nfloat d =diffusionD[diffusionProfileIndex];\\nfloat filterRadius=filterRadii[diffusionProfileIndex];\\nvec2 centerPosNDC=vUV;\\nvec2 cornerPosNDC=vUV+0.5*texelSize;\\nvec3 centerPosVS =vec3(centerPosNDC*viewportSize,1.0)*centerDepth; \\nvec3 cornerPosVS =vec3(cornerPosNDC*viewportSize,1.0)*centerDepth; \\nfloat mmPerUnit =1000.*(metersPerUnit*rcp(distScale));\\nfloat unitsPerMm=rcp(mmPerUnit);\\nfloat unitsPerPixel=2.*abs(cornerPosVS.x-centerPosVS.x);\\nfloat pixelsPerMm =rcp(unitsPerPixel)*unitsPerMm;\\nfloat filterArea =PI*Sq(filterRadius*pixelsPerMm);\\nint sampleCount =int(filterArea*rcp(SSS_PIXELS_PER_SAMPLE));\\nint sampleBudget=_SssSampleBudget;\\nint texturingMode=0;\\nvec3 albedo =texture2D(albedoSampler,vUV).rgb;\\nif (distScale==0. || sampleCount<1)\\n{\\n#ifdef DEBUG_SSS_SAMPLES\\nvec3 green=vec3(0.,1.,0.);\\ngl_FragColor=vec4(green,1.0);\\nreturn;\\n#endif\\ngl_FragColor=vec4(inputColor.rgb+albedo*centerIrradiance,1.0);\\nreturn;\\n}\\n#ifdef DEBUG_SSS_SAMPLES\\nvec3 red =vec3(1.,0.,0.);\\nvec3 blue=vec3(0.,0.,1.);\\ngl_FragColor=vec4(mix(blue,red,clamp(float(sampleCount)/float(sampleBudget),0.0,1.0)),1.0);\\nreturn;\\n#endif\\nfloat phase=0.;\\nint n=min(sampleCount,sampleBudget);\\nvec3 centerWeight =vec3(0.); \\nvec3 totalIrradiance=vec3(0.);\\nvec3 totalWeight =vec3(0.);\\nfor (int i=0; i<n; i++)\\n{\\nEvaluateSample(i,n,S,d,centerPosVS,mmPerUnit,pixelsPerMm,\\nphase,totalIrradiance,totalWeight);\\n}\\ntotalWeight=max(totalWeight,HALF_MIN);\\ngl_FragColor=vec4(inputColor.rgb+albedo*max(totalIrradiance/totalWeight,vec3(0.0)),1.);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var subSurfaceScatteringPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=subSurfaceScattering.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"tonemapPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform float _ExposureAdjustment;\\n#if defined(HABLE_TONEMAPPING)\\nconst float A=0.15;\\nconst float B=0.50;\\nconst float C=0.10;\\nconst float D=0.20;\\nconst float E=0.02;\\nconst float F=0.30;\\nconst float W=11.2;\\n#endif\\nfloat Luminance(vec3 c)\\n{\\nreturn dot(c,vec3(0.22,0.707,0.071));\\n}\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) \\n{\\nvec3 colour=texture2D(textureSampler,vUV).rgb;\\n#if defined(REINHARD_TONEMAPPING)\\nfloat lum=Luminance(colour.rgb); \\nfloat lumTm=lum*_ExposureAdjustment;\\nfloat scale=lumTm/(1.0+lumTm); \\ncolour*=scale/lum;\\n#elif defined(HABLE_TONEMAPPING)\\ncolour*=_ExposureAdjustment;\\nconst float ExposureBias=2.0;\\nvec3 x=ExposureBias*colour;\\nvec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\\nx=vec3(W,W,W);\\nvec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);\\ncolour=curr*whiteScale;\\n#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\\ncolour*=_ExposureAdjustment;\\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\\ncolour=retColor*retColor;\\n#elif defined(PHOTOGRAPHIC_TONEMAPPING)\\ncolour= vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);\\n#endif\\ngl_FragColor=vec4(colour.rgb,1.0);\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var tonemapPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=tonemap.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"volumetricLightScatteringPixelShader\";\nvar shader = \"uniform sampler2D textureSampler;\\nuniform sampler2D lightScatteringSampler;\\nuniform float decay;\\nuniform float exposure;\\nuniform float weight;\\nuniform float density;\\nuniform vec2 meshPositionOnScreen;\\nvarying vec2 vUV;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\nvec2 tc=vUV;\\nvec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);\\ndeltaTexCoord*=1.0/float(NUM_SAMPLES)*density;\\nfloat illuminationDecay=1.0;\\nvec4 color=texture2D(lightScatteringSampler,tc)*0.4;\\nfor(int i=0; i<NUM_SAMPLES; i++) {\\ntc-=deltaTexCoord;\\nvec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;\\ndataSample*=illuminationDecay*weight;\\ncolor+=dataSample;\\nilluminationDecay*=decay;\\n}\\nvec4 realColor=texture2D(textureSampler,vUV);\\ngl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),1))+(realColor*(1.5-0.4)));\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var volumetricLightScatteringPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=volumetricLightScattering.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"volumetricLightScatteringPassPixelShader\";\nvar shader = \"#if defined(ALPHATEST) || defined(NEED_UV)\\nvarying vec2 vUV;\\n#endif\\n#if defined(ALPHATEST)\\nuniform sampler2D diffuseSampler;\\n#endif\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\n#if defined(ALPHATEST)\\nvec4 diffuseColor=texture2D(diffuseSampler,vUV);\\nif (diffuseColor.a<0.4)\\ndiscard;\\n#endif\\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var volumetricLightScatteringPassPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=volumetricLightScatteringPass.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/instancesDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/instancesVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nvar name = \"volumetricLightScatteringPassVertexShader\";\nvar shader = \"attribute vec3 position;\\n#include<bonesDeclaration>\\n#include<bakedVertexAnimationDeclaration>\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\nuniform vec2 depthValues;\\n#if defined(ALPHATEST) || defined(NEED_UV)\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void)\\n{\\nvec3 positionUpdated=position;\\n#if (defined(ALPHATEST) || defined(NEED_UV)) && defined(UV1)\\nvec2 uvUpdated=uv;\\n#endif\\n#include<morphTargetsVertexGlobal>\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#include<bakedVertexAnimation>\\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\\n\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var volumetricLightScatteringPassVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=volumetricLightScatteringPass.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"vrDistortionCorrectionPixelShader\";\nvar shader = \"varying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 LensCenter;\\nuniform vec2 Scale;\\nuniform vec2 ScaleIn;\\nuniform vec4 HmdWarpParam;\\nvec2 HmdWarp(vec2 in01) {\\nvec2 theta=(in01-LensCenter)*ScaleIn; \\nfloat rSq=theta.x*theta.x+theta.y*theta.y;\\nvec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);\\nreturn LensCenter+Scale*rvector;\\n}\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\nvec2 tc=HmdWarp(vUV);\\nif (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\\ngl_FragColor=vec4(0.0,0.0,0.0,0.0);\\nelse{\\ngl_FragColor=texture2D(textureSampler,tc);\\n}\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var vrDistortionCorrectionPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=vrDistortionCorrection.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"vrMultiviewToSingleviewPixelShader\";\nvar shader = \"precision mediump sampler2DArray;\\nvarying vec2 vUV;\\nuniform sampler2DArray multiviewSampler;\\nuniform int imageIndex;\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(multiviewSampler,vec3(vUV,imageIndex));\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var vrMultiviewToSingleviewPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=vrMultiviewToSingleview.fragment.js.map","import { __extends } from \"tslib\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { ThinSprite } from \"./thinSprite.js\";\n/**\n * Class used to represent a sprite\n * @see https://doc.babylonjs.com/babylon101/sprites\n */\nvar Sprite = /** @class */ (function (_super) {\n    __extends(Sprite, _super);\n    /**\n     * Creates a new Sprite\n     * @param name defines the name\n     * @param manager defines the manager\n     */\n    function Sprite(\n    /** defines the name */\n    name, manager) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        /** Gets the list of attached animations */\n        _this.animations = new Array();\n        /** Gets or sets a boolean indicating if the sprite can be picked */\n        _this.isPickable = false;\n        /** Gets or sets a boolean indicating that sprite texture alpha will be used for precise picking (false by default) */\n        _this.useAlphaForPicking = false;\n        /**\n         * An event triggered when the control has been disposed\n         */\n        _this.onDisposeObservable = new Observable();\n        _this._onAnimationEnd = null;\n        _this._endAnimation = function () {\n            if (_this._onAnimationEnd) {\n                _this._onAnimationEnd();\n            }\n            if (_this.disposeWhenFinishedAnimating) {\n                _this.dispose();\n            }\n        };\n        _this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n        _this.position = Vector3.Zero();\n        _this._manager = manager;\n        _this._manager.sprites.push(_this);\n        _this.uniqueId = _this._manager.scene.getUniqueId();\n        return _this;\n    }\n    Object.defineProperty(Sprite.prototype, \"size\", {\n        /**\n         * Gets or sets the sprite size\n         */\n        get: function () {\n            return this.width;\n        },\n        set: function (value) {\n            this.width = value;\n            this.height = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Sprite.prototype, \"manager\", {\n        /**\n         * Gets the manager of this sprite\n         */\n        get: function () {\n            return this._manager;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the string \"Sprite\"\n     * @returns \"Sprite\"\n     */\n    Sprite.prototype.getClassName = function () {\n        return \"Sprite\";\n    };\n    Object.defineProperty(Sprite.prototype, \"fromIndex\", {\n        /** Gets or sets the initial key for the animation (setting it will restart the animation)  */\n        get: function () {\n            return this._fromIndex;\n        },\n        set: function (value) {\n            this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Sprite.prototype, \"toIndex\", {\n        /** Gets or sets the end key for the animation (setting it will restart the animation)  */\n        get: function () {\n            return this._toIndex;\n        },\n        set: function (value) {\n            this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Sprite.prototype, \"loopAnimation\", {\n        /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\n        get: function () {\n            return this._loopAnimation;\n        },\n        set: function (value) {\n            this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Sprite.prototype, \"delay\", {\n        /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\n        get: function () {\n            return Math.max(this._delay, 1);\n        },\n        set: function (value) {\n            this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Starts an animation\n     * @param from defines the initial key\n     * @param to defines the end key\n     * @param loop defines if the animation must loop\n     * @param delay defines the start delay (in ms)\n     * @param onAnimationEnd defines a callback to call when animation ends\n     */\n    Sprite.prototype.playAnimation = function (from, to, loop, delay, onAnimationEnd) {\n        if (onAnimationEnd === void 0) { onAnimationEnd = null; }\n        this._onAnimationEnd = onAnimationEnd;\n        _super.prototype.playAnimation.call(this, from, to, loop, delay, this._endAnimation);\n    };\n    /** Release associated resources */\n    Sprite.prototype.dispose = function () {\n        for (var i = 0; i < this._manager.sprites.length; i++) {\n            if (this._manager.sprites[i] == this) {\n                this._manager.sprites.splice(i, 1);\n            }\n        }\n        // Callback\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n    };\n    /**\n     * Serializes the sprite to a JSON object\n     * @returns the JSON object\n     */\n    Sprite.prototype.serialize = function () {\n        var serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.position = this.position.asArray();\n        serializationObject.color = this.color.asArray();\n        serializationObject.width = this.width;\n        serializationObject.height = this.height;\n        serializationObject.angle = this.angle;\n        serializationObject.cellIndex = this.cellIndex;\n        serializationObject.cellRef = this.cellRef;\n        serializationObject.invertU = this.invertU;\n        serializationObject.invertV = this.invertV;\n        serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;\n        serializationObject.isPickable = this.isPickable;\n        serializationObject.isVisible = this.isVisible;\n        serializationObject.useAlphaForPicking = this.useAlphaForPicking;\n        serializationObject.animationStarted = this.animationStarted;\n        serializationObject.fromIndex = this.fromIndex;\n        serializationObject.toIndex = this.toIndex;\n        serializationObject.loopAnimation = this.loopAnimation;\n        serializationObject.delay = this.delay;\n        return serializationObject;\n    };\n    /**\n     * Parses a JSON object to create a new sprite\n     * @param parsedSprite The JSON object to parse\n     * @param manager defines the hosting manager\n     * @returns the new sprite\n     */\n    Sprite.Parse = function (parsedSprite, manager) {\n        var sprite = new Sprite(parsedSprite.name, manager);\n        sprite.position = Vector3.FromArray(parsedSprite.position);\n        sprite.color = Color4.FromArray(parsedSprite.color);\n        sprite.width = parsedSprite.width;\n        sprite.height = parsedSprite.height;\n        sprite.angle = parsedSprite.angle;\n        sprite.cellIndex = parsedSprite.cellIndex;\n        sprite.cellRef = parsedSprite.cellRef;\n        sprite.invertU = parsedSprite.invertU;\n        sprite.invertV = parsedSprite.invertV;\n        sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;\n        sprite.isPickable = parsedSprite.isPickable;\n        sprite.isVisible = parsedSprite.isVisible;\n        sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;\n        sprite.fromIndex = parsedSprite.fromIndex;\n        sprite.toIndex = parsedSprite.toIndex;\n        sprite.loopAnimation = parsedSprite.loopAnimation;\n        sprite.delay = parsedSprite.delay;\n        if (parsedSprite.animationStarted) {\n            sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);\n        }\n        return sprite;\n    };\n    return Sprite;\n}(ThinSprite));\nexport { Sprite };\n//# sourceMappingURL=sprite.js.map","/**\n * ThinSprite Class used to represent a thin sprite\n * This is the base class for sprites but can also directly be used with ThinEngine\n * @see https://doc.babylonjs.com/babylon101/sprites\n */\nvar ThinSprite = /** @class */ (function () {\n    /**\n     * Creates a new Thin Sprite\n     */\n    function ThinSprite() {\n        /** Gets or sets the width */\n        this.width = 1.0;\n        /** Gets or sets the height */\n        this.height = 1.0;\n        /** Gets or sets rotation angle */\n        this.angle = 0;\n        /** Gets or sets a boolean indicating if UV coordinates should be inverted in U axis */\n        this.invertU = false;\n        /** Gets or sets a boolean indicating if UV coordinates should be inverted in B axis */\n        this.invertV = false;\n        /** Gets or sets a boolean indicating if the sprite is visible (renderable). Default is true */\n        this.isVisible = true;\n        this._animationStarted = false;\n        this._loopAnimation = false;\n        this._fromIndex = 0;\n        this._toIndex = 0;\n        this._delay = 0;\n        this._direction = 1;\n        this._time = 0;\n        this._onBaseAnimationEnd = null;\n        this.position = { x: 1.0, y: 1.0, z: 1.0 };\n        this.color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n    }\n    Object.defineProperty(ThinSprite.prototype, \"animationStarted\", {\n        /**\n         * Returns a boolean indicating if the animation is started\n         */\n        get: function () {\n            return this._animationStarted;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThinSprite.prototype, \"fromIndex\", {\n        /** Gets the initial key for the animation (setting it will restart the animation)  */\n        get: function () {\n            return this._fromIndex;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThinSprite.prototype, \"toIndex\", {\n        /** Gets or sets the end key for the animation (setting it will restart the animation)  */\n        get: function () {\n            return this._toIndex;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThinSprite.prototype, \"loopAnimation\", {\n        /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\n        get: function () {\n            return this._loopAnimation;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThinSprite.prototype, \"delay\", {\n        /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\n        get: function () {\n            return Math.max(this._delay, 1);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Starts an animation\n     * @param from defines the initial key\n     * @param to defines the end key\n     * @param loop defines if the animation must loop\n     * @param delay defines the start delay (in ms)\n     * @param onAnimationEnd defines a callback for when the animation ends\n     */\n    ThinSprite.prototype.playAnimation = function (from, to, loop, delay, onAnimationEnd) {\n        this._fromIndex = from;\n        this._toIndex = to;\n        this._loopAnimation = loop;\n        this._delay = delay || 1;\n        this._animationStarted = true;\n        this._onBaseAnimationEnd = onAnimationEnd;\n        if (from < to) {\n            this._direction = 1;\n        }\n        else {\n            this._direction = -1;\n            this._toIndex = from;\n            this._fromIndex = to;\n        }\n        this.cellIndex = from;\n        this._time = 0;\n    };\n    /** Stops current animation (if any) */\n    ThinSprite.prototype.stopAnimation = function () {\n        this._animationStarted = false;\n    };\n    /**\n     * @param deltaTime\n     * @hidden\n     */\n    ThinSprite.prototype._animate = function (deltaTime) {\n        if (!this._animationStarted) {\n            return;\n        }\n        this._time += deltaTime;\n        if (this._time > this._delay) {\n            this._time = this._time % this._delay;\n            this.cellIndex += this._direction;\n            if ((this._direction > 0 && this.cellIndex > this._toIndex) || (this._direction < 0 && this.cellIndex < this._fromIndex)) {\n                if (this._loopAnimation) {\n                    this.cellIndex = this._direction > 0 ? this._fromIndex : this._toIndex;\n                }\n                else {\n                    this.cellIndex = this._toIndex;\n                    this._animationStarted = false;\n                    if (this._onBaseAnimationEnd) {\n                        this._onBaseAnimationEnd();\n                    }\n                }\n            }\n        }\n    };\n    return ThinSprite;\n}());\nexport { ThinSprite };\n//# sourceMappingURL=thinSprite.js.map","import { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { ActionEvent } from \"../Actions/actionEvent.js\";\n\nScene.prototype._internalPickSprites = function (ray, predicate, fastCheck, camera) {\n    if (!PickingInfo) {\n        return null;\n    }\n    var pickingInfo = null;\n    if (!camera) {\n        if (!this.activeCamera) {\n            return null;\n        }\n        camera = this.activeCamera;\n    }\n    if (this.spriteManagers.length > 0) {\n        for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n            var spriteManager = this.spriteManagers[spriteIndex];\n            if (!spriteManager.isPickable) {\n                continue;\n            }\n            var result = spriteManager.intersects(ray, camera, predicate, fastCheck);\n            if (!result || !result.hit) {\n                continue;\n            }\n            if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n                continue;\n            }\n            pickingInfo = result;\n            if (fastCheck) {\n                break;\n            }\n        }\n    }\n    return pickingInfo || new PickingInfo();\n};\nScene.prototype._internalMultiPickSprites = function (ray, predicate, camera) {\n    if (!PickingInfo) {\n        return null;\n    }\n    var pickingInfos = new Array();\n    if (!camera) {\n        if (!this.activeCamera) {\n            return null;\n        }\n        camera = this.activeCamera;\n    }\n    if (this.spriteManagers.length > 0) {\n        for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n            var spriteManager = this.spriteManagers[spriteIndex];\n            if (!spriteManager.isPickable) {\n                continue;\n            }\n            var results = spriteManager.multiIntersects(ray, camera, predicate);\n            if (results !== null) {\n                pickingInfos = pickingInfos.concat(results);\n            }\n        }\n    }\n    return pickingInfos;\n};\nScene.prototype.pickSprite = function (x, y, predicate, fastCheck, camera) {\n    if (!this._tempSpritePickingRay) {\n        return null;\n    }\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n    var result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n    if (result) {\n        result.ray = this.createPickingRayInCameraSpace(x, y, camera);\n    }\n    return result;\n};\nScene.prototype.pickSpriteWithRay = function (ray, predicate, fastCheck, camera) {\n    if (!this._tempSpritePickingRay) {\n        return null;\n    }\n    if (!camera) {\n        if (!this.activeCamera) {\n            return null;\n        }\n        camera = this.activeCamera;\n    }\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n    var result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n    if (result) {\n        result.ray = ray;\n    }\n    return result;\n};\nScene.prototype.multiPickSprite = function (x, y, predicate, camera) {\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n    return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\nScene.prototype.multiPickSpriteWithRay = function (ray, predicate, camera) {\n    if (!this._tempSpritePickingRay) {\n        return null;\n    }\n    if (!camera) {\n        if (!this.activeCamera) {\n            return null;\n        }\n        camera = this.activeCamera;\n    }\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n    return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\nScene.prototype.setPointerOverSprite = function (sprite) {\n    if (this._pointerOverSprite === sprite) {\n        return;\n    }\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n        this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n    }\n    this._pointerOverSprite = sprite;\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n        this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n    }\n};\nScene.prototype.getPointerOverSprite = function () {\n    return this._pointerOverSprite;\n};\n/**\n * Defines the sprite scene component responsible to manage sprites\n * in a given scene.\n */\nvar SpriteSceneComponent = /** @class */ (function () {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    function SpriteSceneComponent(scene) {\n        /**\n         * The component name helpfull to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_SPRITE;\n        this.scene = scene;\n        this.scene.spriteManagers = new Array();\n        this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\n        this.scene.onBeforeSpritesRenderingObservable = new Observable();\n        this.scene.onAfterSpritesRenderingObservable = new Observable();\n        this._spritePredicate = function (sprite) {\n            if (!sprite.actionManager) {\n                return false;\n            }\n            return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\n        };\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    SpriteSceneComponent.prototype.register = function () {\n        this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\n        this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\n        this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\n    };\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    SpriteSceneComponent.prototype.rebuild = function () {\n        /** Nothing to do for sprites */\n    };\n    /**\n     * Disposes the component and the associated resources.\n     */\n    SpriteSceneComponent.prototype.dispose = function () {\n        this.scene.onBeforeSpritesRenderingObservable.clear();\n        this.scene.onAfterSpritesRenderingObservable.clear();\n        var spriteManagers = this.scene.spriteManagers;\n        while (spriteManagers.length) {\n            spriteManagers[0].dispose();\n        }\n    };\n    SpriteSceneComponent.prototype._pickSpriteButKeepRay = function (originalPointerInfo, x, y, fastCheck, camera) {\n        var result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\n        if (result) {\n            result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\n        }\n        return result;\n    };\n    SpriteSceneComponent.prototype._pointerMove = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {\n        var scene = this.scene;\n        if (isMeshPicked) {\n            scene.setPointerOverSprite(null);\n        }\n        else {\n            pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n                scene.setPointerOverSprite(pickResult.pickedSprite);\n                if (!scene.doNotHandleCursors && element) {\n                    if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\n                        element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\n                    }\n                    else {\n                        element.style.cursor = scene.hoverCursor;\n                    }\n                }\n            }\n            else {\n                scene.setPointerOverSprite(null);\n            }\n        }\n        return pickResult;\n    };\n    SpriteSceneComponent.prototype._pointerDown = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n        var scene = this.scene;\n        scene._pickedDownSprite = null;\n        if (scene.spriteManagers.length > 0) {\n            pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n                if (pickResult.pickedSprite.actionManager) {\n                    scene._pickedDownSprite = pickResult.pickedSprite;\n                    switch (evt.button) {\n                        case 0:\n                            pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n                            break;\n                        case 1:\n                            pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n                            break;\n                        case 2:\n                            pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n                            break;\n                    }\n                    if (pickResult.pickedSprite.actionManager) {\n                        pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n                    }\n                }\n            }\n        }\n        return pickResult;\n    };\n    SpriteSceneComponent.prototype._pointerUp = function (unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n        var scene = this.scene;\n        if (scene.spriteManagers.length > 0) {\n            var spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n            if (spritePickResult) {\n                if (spritePickResult.hit && spritePickResult.pickedSprite) {\n                    if (spritePickResult.pickedSprite.actionManager) {\n                        spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n                        if (spritePickResult.pickedSprite.actionManager) {\n                            if (!this.scene._inputManager._isPointerSwiping()) {\n                                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n                            }\n                        }\n                    }\n                }\n                if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\n                    scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\n                }\n            }\n        }\n        return pickResult;\n    };\n    return SpriteSceneComponent;\n}());\nexport { SpriteSceneComponent };\n//# sourceMappingURL=spriteSceneComponent.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/fogFragmentDeclaration.js\";\nimport \"./ShadersInclude/fogFragment.js\";\nimport \"./ShadersInclude/imageProcessingCompatibility.js\";\nvar name = \"spritesPixelShader\";\nvar shader = \"uniform bool alphaTest;\\nvarying vec4 vColor;\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#include<fogFragmentDeclaration>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\nvec4 color=texture2D(diffuseSampler,vUV);\\nif (alphaTest) \\n{\\nif (color.a<0.95)\\ndiscard;\\n}\\ncolor*=vColor;\\n#include<fogFragment>\\ngl_FragColor=color;\\n#include<imageProcessingCompatibility>\\n#define CUSTOM_FRAGMENT_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var spritesPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=sprites.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/fogVertexDeclaration.js\";\nvar name = \"spritesVertexShader\";\nvar shader = \"attribute vec4 position;\\nattribute vec2 options;\\nattribute vec2 offsets;\\nattribute vec2 inverts;\\nattribute vec4 cellInfo;\\nattribute vec4 color;\\nuniform mat4 view;\\nuniform mat4 projection;\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n#include<fogVertexDeclaration>\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec3 viewPos=(view*vec4(position.xyz,1.0)).xyz; \\nvec2 cornerPos;\\nfloat angle=position.w;\\nvec2 size=vec2(options.x,options.y);\\nvec2 offset=offsets.xy;\\ncornerPos=vec2(offset.x-0.5,offset.y -0.5)*size;\\nvec3 rotatedCorner;\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\nviewPos+=rotatedCorner;\\ngl_Position=projection*vec4(viewPos,1.0); \\nvColor=color;\\nvec2 uvOffset=vec2(abs(offset.x-inverts.x),abs(1.0-offset.y-inverts.y));\\nvec2 uvPlace=cellInfo.xy;\\nvec2 uvSize=cellInfo.zw;\\nvUV.x=uvPlace.x+uvSize.x*uvOffset.x;\\nvUV.y=uvPlace.y+uvSize.y*uvOffset.y;\\n#ifdef FOG\\nvFogDistance=viewPos;\\n#endif\\n#define CUSTOM_VERTEX_MAIN_END\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var spritesVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=sprites.vertex.js.map","\nimport { Buffer, VertexBuffer } from \"../Buffers/buffer.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Engines/Extensions/engine.alpha.js\";\nimport \"../Engines/Extensions/engine.dynamicBuffer.js\";\nimport \"../Shaders/sprites.fragment.js\";\nimport \"../Shaders/sprites.vertex.js\";\n/**\n * Class used to render sprites.\n *\n * It can be used either to render Sprites or ThinSprites with ThinEngine only.\n */\nvar SpriteRenderer = /** @class */ (function () {\n    /**\n     * Creates a new sprite Renderer\n     * @param engine defines the engine the renderer works with\n     * @param capacity defines the maximum allowed number of sprites\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\n     * @param scene defines the hosting scene\n     */\n    function SpriteRenderer(engine, capacity, epsilon, scene) {\n        if (epsilon === void 0) { epsilon = 0.01; }\n        if (scene === void 0) { scene = null; }\n        /**\n         * Blend mode use to render the particle, it can be any of\n         * the static undefined properties provided in this class.\n         * Default value is 2\n         */\n        this.blendMode = 2;\n        /**\n         * Gets or sets a boolean indicating if alpha mode is automatically\n         * reset.\n         */\n        this.autoResetAlpha = true;\n        /**\n         * Disables writing to the depth buffer when rendering the sprites.\n         * It can be handy to disable depth writing when using textures without alpha channel\n         * and setting some specific blend modes.\n         */\n        this.disableDepthWrite = false;\n        /**\n         * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\n         */\n        this.fogEnabled = true;\n        this._useVAO = false;\n        this._useInstancing = false;\n        this._vertexBuffers = {};\n        this._capacity = capacity;\n        this._epsilon = epsilon;\n        this._engine = engine;\n        this._useInstancing = engine.getCaps().instancedArrays;\n        this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\n        this._scene = scene;\n        this._drawWrapperBase = new DrawWrapper(engine);\n        this._drawWrapperFog = new DrawWrapper(engine);\n        this._drawWrapperDepth = new DrawWrapper(engine, false);\n        this._drawWrapperFogDepth = new DrawWrapper(engine, false);\n        if (!this._useInstancing) {\n            this._buildIndexBuffer();\n        }\n        if (this._drawWrapperBase.drawContext) {\n            this._drawWrapperBase.drawContext.useInstancing = this._useInstancing;\n        }\n        if (this._drawWrapperFog.drawContext) {\n            this._drawWrapperFog.drawContext.useInstancing = this._useInstancing;\n        }\n        if (this._drawWrapperDepth.drawContext) {\n            this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing;\n        }\n        if (this._drawWrapperFogDepth.drawContext) {\n            this._drawWrapperFogDepth.drawContext.useInstancing = this._useInstancing;\n        }\n        // VBO\n        // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\n        // 16 when using instances\n        this._vertexBufferSize = this._useInstancing ? 16 : 18;\n        this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\n        this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\n        var positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\n        var options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\n        var offset = 6;\n        var offsets;\n        if (this._useInstancing) {\n            var spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n            offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\n        }\n        else {\n            offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\n            offset += 2;\n        }\n        var inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\n        var cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\n        var colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n        this._vertexBuffers[\"options\"] = options;\n        this._vertexBuffers[\"offsets\"] = offsets;\n        this._vertexBuffers[\"inverts\"] = inverts;\n        this._vertexBuffers[\"cellInfo\"] = cellInfo;\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n        // Effects\n        this._drawWrapperBase.effect = this._engine.createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"], [\"diffuseSampler\"], \"\");\n        this._drawWrapperDepth.effect = this._drawWrapperBase.effect;\n        this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext;\n        if (this._scene) {\n            this._drawWrapperFog.effect = this._scene\n                .getEngine()\n                .createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"], [\"diffuseSampler\"], \"#define FOG\");\n            this._drawWrapperFogDepth.effect = this._drawWrapperFog.effect;\n            this._drawWrapperFogDepth.materialContext = this._drawWrapperFog.materialContext;\n        }\n    }\n    Object.defineProperty(SpriteRenderer.prototype, \"capacity\", {\n        /**\n         * Gets the capacity of the manager\n         */\n        get: function () {\n            return this._capacity;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Render all child sprites\n     * @param sprites defines the list of sprites to render\n     * @param deltaTime defines the time since last frame\n     * @param viewMatrix defines the viewMatrix to use to render the sprites\n     * @param projectionMatrix defines the projectionMatrix to use to render the sprites\n     * @param customSpriteUpdate defines a custom function to update the sprites data before they render\n     */\n    SpriteRenderer.prototype.render = function (sprites, deltaTime, viewMatrix, projectionMatrix, customSpriteUpdate) {\n        if (customSpriteUpdate === void 0) { customSpriteUpdate = null; }\n        if (!this.texture || !this.texture.isReady() || !sprites.length) {\n            return;\n        }\n        var drawWrapper = this._drawWrapperBase;\n        var drawWrapperDepth = this._drawWrapperDepth;\n        var shouldRenderFog = false;\n        if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\n            drawWrapper = this._drawWrapperFog;\n            drawWrapperDepth = this._drawWrapperFogDepth;\n            shouldRenderFog = true;\n        }\n        var effect = drawWrapper.effect;\n        // Check\n        if (!effect.isReady()) {\n            return;\n        }\n        var engine = this._engine;\n        var useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\n        var baseSize = this.texture.getBaseSize();\n        // Sprites\n        var max = Math.min(this._capacity, sprites.length);\n        var offset = 0;\n        var noSprite = true;\n        for (var index = 0; index < max; index++) {\n            var sprite = sprites[index];\n            if (!sprite || !sprite.isVisible) {\n                continue;\n            }\n            noSprite = false;\n            sprite._animate(deltaTime);\n            this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n            if (!this._useInstancing) {\n                this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n                this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n                this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n            }\n        }\n        if (noSprite) {\n            return;\n        }\n        this._buffer.update(this._vertexData);\n        var culling = !!engine.depthCullingState.cull;\n        var zOffset = engine.depthCullingState.zOffset;\n        var zOffsetUnits = engine.depthCullingState.zOffsetUnits;\n        engine.setState(culling, zOffset, false, false, undefined, undefined, zOffsetUnits);\n        // Render\n        engine.enableEffect(drawWrapper);\n        effect.setTexture(\"diffuseSampler\", this.texture);\n        effect.setMatrix(\"view\", viewMatrix);\n        effect.setMatrix(\"projection\", projectionMatrix);\n        // Scene Info\n        if (shouldRenderFog) {\n            var scene = this._scene;\n            // Fog\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n            effect.setColor3(\"vFogColor\", scene.fogColor);\n        }\n        if (this._useVAO) {\n            if (!this._vertexArrayObject) {\n                this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n            }\n            engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n        }\n        else {\n            // VBOs\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n        }\n        // Draw order\n        engine.depthCullingState.depthFunc = engine.useReverseDepthBuffer ? 518 : 515;\n        if (!this.disableDepthWrite) {\n            effect.setBool(\"alphaTest\", true);\n            engine.setColorWrite(false);\n            engine.enableEffect(drawWrapperDepth);\n            if (this._useInstancing) {\n                engine.drawArraysType(7, 0, 4, offset);\n            }\n            else {\n                engine.drawElementsType(0, 0, (offset / 4) * 6);\n            }\n            engine.enableEffect(drawWrapper);\n            engine.setColorWrite(true);\n            effect.setBool(\"alphaTest\", false);\n        }\n        engine.setAlphaMode(this.blendMode);\n        if (this._useInstancing) {\n            engine.drawArraysType(7, 0, 4, offset);\n        }\n        else {\n            engine.drawElementsType(0, 0, (offset / 4) * 6);\n        }\n        if (this.autoResetAlpha) {\n            engine.setAlphaMode(0);\n        }\n        // Restore Right Handed\n        if (useRightHandedSystem) {\n            this._scene.getEngine().setState(culling, zOffset, false, true, undefined, undefined, zOffsetUnits);\n        }\n        engine.unbindInstanceAttributes();\n    };\n    SpriteRenderer.prototype._appendSpriteVertex = function (index, sprite, offsetX, offsetY, baseSize, useRightHandedSystem, customSpriteUpdate) {\n        var arrayOffset = index * this._vertexBufferSize;\n        if (offsetX === 0) {\n            offsetX = this._epsilon;\n        }\n        else if (offsetX === 1) {\n            offsetX = 1 - this._epsilon;\n        }\n        if (offsetY === 0) {\n            offsetY = this._epsilon;\n        }\n        else if (offsetY === 1) {\n            offsetY = 1 - this._epsilon;\n        }\n        if (customSpriteUpdate) {\n            customSpriteUpdate(sprite, baseSize);\n        }\n        else {\n            if (!sprite.cellIndex) {\n                sprite.cellIndex = 0;\n            }\n            var rowSize = baseSize.width / this.cellWidth;\n            var offset = (sprite.cellIndex / rowSize) >> 0;\n            sprite._xOffset = ((sprite.cellIndex - offset * rowSize) * this.cellWidth) / baseSize.width;\n            sprite._yOffset = (offset * this.cellHeight) / baseSize.height;\n            sprite._xSize = this.cellWidth;\n            sprite._ySize = this.cellHeight;\n        }\n        // Positions\n        this._vertexData[arrayOffset] = sprite.position.x;\n        this._vertexData[arrayOffset + 1] = sprite.position.y;\n        this._vertexData[arrayOffset + 2] = sprite.position.z;\n        this._vertexData[arrayOffset + 3] = sprite.angle;\n        // Options\n        this._vertexData[arrayOffset + 4] = sprite.width;\n        this._vertexData[arrayOffset + 5] = sprite.height;\n        if (!this._useInstancing) {\n            this._vertexData[arrayOffset + 6] = offsetX;\n            this._vertexData[arrayOffset + 7] = offsetY;\n        }\n        else {\n            arrayOffset -= 2;\n        }\n        // Inverts according to Right Handed\n        if (useRightHandedSystem) {\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\n        }\n        else {\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\n        }\n        this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\n        this._vertexData[arrayOffset + 10] = sprite._xOffset;\n        this._vertexData[arrayOffset + 11] = sprite._yOffset;\n        this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\n        this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;\n        // Color\n        this._vertexData[arrayOffset + 14] = sprite.color.r;\n        this._vertexData[arrayOffset + 15] = sprite.color.g;\n        this._vertexData[arrayOffset + 16] = sprite.color.b;\n        this._vertexData[arrayOffset + 17] = sprite.color.a;\n    };\n    SpriteRenderer.prototype._buildIndexBuffer = function () {\n        var indices = [];\n        var index = 0;\n        for (var count = 0; count < this._capacity; count++) {\n            indices.push(index);\n            indices.push(index + 1);\n            indices.push(index + 2);\n            indices.push(index);\n            indices.push(index + 2);\n            indices.push(index + 3);\n            index += 4;\n        }\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\n    };\n    /**\n     * Rebuilds the renderer (after a context lost, for eg)\n     */\n    SpriteRenderer.prototype.rebuild = function () {\n        var _a;\n        if (this._indexBuffer) {\n            this._buildIndexBuffer();\n        }\n        if (this._useVAO) {\n            this._vertexArrayObject = undefined;\n        }\n        this._buffer._rebuild();\n        for (var key in this._vertexBuffers) {\n            var vertexBuffer = this._vertexBuffers[key];\n            vertexBuffer._rebuild();\n        }\n        (_a = this._spriteBuffer) === null || _a === void 0 ? void 0 : _a._rebuild();\n    };\n    /**\n     * Release associated resources\n     */\n    SpriteRenderer.prototype.dispose = function () {\n        if (this._buffer) {\n            this._buffer.dispose();\n            this._buffer = null;\n        }\n        if (this._spriteBuffer) {\n            this._spriteBuffer.dispose();\n            this._spriteBuffer = null;\n        }\n        if (this._indexBuffer) {\n            this._engine._releaseBuffer(this._indexBuffer);\n            this._indexBuffer = null;\n        }\n        if (this._vertexArrayObject) {\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n            this._vertexArrayObject = null;\n        }\n        if (this.texture) {\n            this.texture.dispose();\n            this.texture = null;\n        }\n        this._drawWrapperBase.dispose();\n        this._drawWrapperFog.dispose();\n        this._drawWrapperDepth.dispose();\n        this._drawWrapperFogDepth.dispose();\n    };\n    return SpriteRenderer;\n}());\nexport { SpriteRenderer };\n//# sourceMappingURL=spriteRenderer.js.map","import { Observable } from \"../Misc/observable.js\";\nimport { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Sprite } from \"./sprite.js\";\nimport { SpriteSceneComponent } from \"./spriteSceneComponent.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\nimport { SpriteRenderer } from \"./spriteRenderer.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n\n/**\n * Class used to manage multiple sprites on the same spritesheet\n * @see https://doc.babylonjs.com/babylon101/sprites\n */\nvar SpriteManager = /** @class */ (function () {\n    /**\n     * Creates a new sprite manager\n     * @param name defines the manager's name\n     * @param imgUrl defines the sprite sheet url\n     * @param capacity defines the maximum allowed number of sprites\n     * @param cellSize defines the size of a sprite cell\n     * @param scene defines the hosting scene\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\n     * @param samplingMode defines the sampling mode to use with spritesheet\n     * @param fromPacked set to false; do not alter\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\n     */\n    function SpriteManager(\n    /** defines the manager's name */\n    name, imgUrl, capacity, cellSize, scene, epsilon, samplingMode, fromPacked, spriteJSON) {\n        if (epsilon === void 0) { epsilon = 0.01; }\n        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\n        if (fromPacked === void 0) { fromPacked = false; }\n        if (spriteJSON === void 0) { spriteJSON = null; }\n        var _this = this;\n        this.name = name;\n        /** Gets the list of sprites */\n        this.sprites = new Array();\n        /** Gets or sets the rendering group id (0 by default) */\n        this.renderingGroupId = 0;\n        /** Gets or sets camera layer mask */\n        this.layerMask = 0x0fffffff;\n        /** Gets or sets a boolean indicating if the sprites are pickable */\n        this.isPickable = false;\n        /**\n         * An event triggered when the manager is disposed.\n         */\n        this.onDisposeObservable = new Observable();\n        this._disableDepthWrite = false;\n        /** True when packed cell data from JSON file is ready*/\n        this._packedAndReady = false;\n        this._customUpdate = function (sprite, baseSize) {\n            if (!sprite.cellRef) {\n                sprite.cellIndex = 0;\n            }\n            var num = sprite.cellIndex;\n            if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\n                sprite.cellRef = _this._spriteMap[sprite.cellIndex];\n            }\n            sprite._xOffset = _this._cellData[sprite.cellRef].frame.x / baseSize.width;\n            sprite._yOffset = _this._cellData[sprite.cellRef].frame.y / baseSize.height;\n            sprite._xSize = _this._cellData[sprite.cellRef].frame.w;\n            sprite._ySize = _this._cellData[sprite.cellRef].frame.h;\n        };\n        if (!scene) {\n            scene = EngineStore.LastCreatedScene;\n        }\n        if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\n            scene._addComponent(new SpriteSceneComponent(scene));\n        }\n        this._fromPacked = fromPacked;\n        this._scene = scene;\n        var engine = this._scene.getEngine();\n        this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\n        if (cellSize.width && cellSize.height) {\n            this.cellWidth = cellSize.width;\n            this.cellHeight = cellSize.height;\n        }\n        else if (cellSize !== undefined) {\n            this.cellWidth = cellSize;\n            this.cellHeight = cellSize;\n        }\n        else {\n            this._spriteRenderer = null;\n            return;\n        }\n        this._scene.spriteManagers.push(this);\n        this.uniqueId = this.scene.getUniqueId();\n        if (imgUrl) {\n            this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\n        }\n        if (this._fromPacked) {\n            this._makePacked(imgUrl, spriteJSON);\n        }\n    }\n    Object.defineProperty(SpriteManager.prototype, \"onDispose\", {\n        /**\n         * Callback called when the manager is disposed\n         */\n        set: function (callback) {\n            if (this._onDisposeObserver) {\n                this.onDisposeObservable.remove(this._onDisposeObserver);\n            }\n            this._onDisposeObserver = this.onDisposeObservable.add(callback);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteManager.prototype, \"children\", {\n        /**\n         * Gets the array of sprites\n         */\n        get: function () {\n            return this.sprites;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteManager.prototype, \"scene\", {\n        /**\n         * Gets the hosting scene\n         */\n        get: function () {\n            return this._scene;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteManager.prototype, \"capacity\", {\n        /**\n         * Gets the capacity of the manager\n         */\n        get: function () {\n            return this._spriteRenderer.capacity;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteManager.prototype, \"texture\", {\n        /**\n         * Gets or sets the spritesheet texture\n         */\n        get: function () {\n            return this._spriteRenderer.texture;\n        },\n        set: function (value) {\n            value.wrapU = Texture.CLAMP_ADDRESSMODE;\n            value.wrapV = Texture.CLAMP_ADDRESSMODE;\n            this._spriteRenderer.texture = value;\n            this._textureContent = null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteManager.prototype, \"cellWidth\", {\n        /** Defines the default width of a cell in the spritesheet */\n        get: function () {\n            return this._spriteRenderer.cellWidth;\n        },\n        set: function (value) {\n            this._spriteRenderer.cellWidth = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteManager.prototype, \"cellHeight\", {\n        /** Defines the default height of a cell in the spritesheet */\n        get: function () {\n            return this._spriteRenderer.cellHeight;\n        },\n        set: function (value) {\n            this._spriteRenderer.cellHeight = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteManager.prototype, \"fogEnabled\", {\n        /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\n        get: function () {\n            return this._spriteRenderer.fogEnabled;\n        },\n        set: function (value) {\n            this._spriteRenderer.fogEnabled = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteManager.prototype, \"blendMode\", {\n        /**\n         * Blend mode use to render the particle, it can be any of\n         * the static undefined properties provided in this class.\n         * Default value is 2\n         */\n        get: function () {\n            return this._spriteRenderer.blendMode;\n        },\n        set: function (blendMode) {\n            this._spriteRenderer.blendMode = blendMode;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteManager.prototype, \"disableDepthWrite\", {\n        /** Disables writing to the depth buffer when rendering the sprites.\n         *  It can be handy to disable depth writing when using textures without alpha channel\n         *  and setting some specific blend modes.\n         */\n        get: function () {\n            return this._disableDepthWrite;\n        },\n        set: function (value) {\n            this._disableDepthWrite = value;\n            this._spriteRenderer.disableDepthWrite = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the string \"SpriteManager\"\n     * @returns \"SpriteManager\"\n     */\n    SpriteManager.prototype.getClassName = function () {\n        return \"SpriteManager\";\n    };\n    SpriteManager.prototype._makePacked = function (imgUrl, spriteJSON) {\n        var _this = this;\n        if (spriteJSON !== null) {\n            try {\n                //Get the JSON and Check its structure.  If its an array parse it if its a JSON string etc...\n                var celldata = void 0;\n                if (typeof spriteJSON === \"string\") {\n                    celldata = JSON.parse(spriteJSON);\n                }\n                else {\n                    celldata = spriteJSON;\n                }\n                if (celldata.frames.length) {\n                    var frametemp = {};\n                    for (var i = 0; i < celldata.frames.length; i++) {\n                        var _f = celldata.frames[i];\n                        if (typeof Object.keys(_f)[0] !== \"string\") {\n                            throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\n                        }\n                        var name_1 = _f[Object.keys(_f)[0]];\n                        frametemp[name_1] = _f;\n                    }\n                    celldata.frames = frametemp;\n                }\n                var spritemap = Reflect.ownKeys(celldata.frames);\n                this._spriteMap = spritemap;\n                this._packedAndReady = true;\n                this._cellData = celldata.frames;\n            }\n            catch (e) {\n                this._fromPacked = false;\n                this._packedAndReady = false;\n                throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\n            }\n        }\n        else {\n            var re = /\\./g;\n            var li = void 0;\n            do {\n                li = re.lastIndex;\n                re.test(imgUrl);\n            } while (re.lastIndex > 0);\n            var jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\n            var onerror_1 = function () {\n                Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\n                _this._fromPacked = false;\n                _this._packedAndReady = false;\n            };\n            var onload_1 = function (data) {\n                try {\n                    var celldata = JSON.parse(data);\n                    var spritemap = Reflect.ownKeys(celldata.frames);\n                    _this._spriteMap = spritemap;\n                    _this._packedAndReady = true;\n                    _this._cellData = celldata.frames;\n                }\n                catch (e) {\n                    _this._fromPacked = false;\n                    _this._packedAndReady = false;\n                    throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\n                }\n            };\n            Tools.LoadFile(jsonUrl, onload_1, undefined, undefined, false, onerror_1);\n        }\n    };\n    SpriteManager.prototype._checkTextureAlpha = function (sprite, ray, distance, min, max) {\n        if (!sprite.useAlphaForPicking || !this.texture) {\n            return true;\n        }\n        var textureSize = this.texture.getSize();\n        if (!this._textureContent) {\n            this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\n            this.texture.readPixels(0, 0, this._textureContent);\n        }\n        var contactPoint = TmpVectors.Vector3[0];\n        contactPoint.copyFrom(ray.direction);\n        contactPoint.normalize();\n        contactPoint.scaleInPlace(distance);\n        contactPoint.addInPlace(ray.origin);\n        var contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;\n        var contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5;\n        // Rotate\n        var angle = sprite.angle;\n        var rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));\n        var rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));\n        var u = (sprite._xOffset * textureSize.width + rotatedU * sprite._xSize) | 0;\n        var v = (sprite._yOffset * textureSize.height + rotatedV * sprite._ySize) | 0;\n        var alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];\n        return alpha > 0.5;\n    };\n    /**\n     * Intersects the sprites with a ray\n     * @param ray defines the ray to intersect with\n     * @param camera defines the current active camera\n     * @param predicate defines a predicate used to select candidate sprites\n     * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\n     * @returns null if no hit or a PickingInfo\n     */\n    SpriteManager.prototype.intersects = function (ray, camera, predicate, fastCheck) {\n        var count = Math.min(this.capacity, this.sprites.length);\n        var min = Vector3.Zero();\n        var max = Vector3.Zero();\n        var distance = Number.MAX_VALUE;\n        var currentSprite = null;\n        var pickedPoint = TmpVectors.Vector3[0];\n        var cameraSpacePosition = TmpVectors.Vector3[1];\n        var cameraView = camera.getViewMatrix();\n        var activeRay = ray;\n        var pickedRay = ray;\n        for (var index = 0; index < count; index++) {\n            var sprite = this.sprites[index];\n            if (!sprite) {\n                continue;\n            }\n            if (predicate) {\n                if (!predicate(sprite)) {\n                    continue;\n                }\n            }\n            else if (!sprite.isPickable) {\n                continue;\n            }\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n            if (sprite.angle) {\n                // Create a rotation matrix to rotate the ray to the sprite's rotation\n                Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);\n                Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);\n                Matrix.RotationZToRef(sprite.angle, TmpVectors.Matrix[3]);\n                // inv translation x rotation x translation\n                TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);\n                TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);\n                activeRay = ray.clone();\n                Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);\n                Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);\n            }\n            else {\n                activeRay = ray;\n            }\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n            if (activeRay.intersectsBoxMinMax(min, max)) {\n                var currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);\n                if (distance > currentDistance) {\n                    if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {\n                        continue;\n                    }\n                    pickedRay = activeRay;\n                    distance = currentDistance;\n                    currentSprite = sprite;\n                    if (fastCheck) {\n                        break;\n                    }\n                }\n            }\n        }\n        if (currentSprite) {\n            var result = new PickingInfo();\n            cameraView.invertToRef(TmpVectors.Matrix[0]);\n            result.hit = true;\n            result.pickedSprite = currentSprite;\n            result.distance = distance;\n            // Get picked point\n            var direction = TmpVectors.Vector3[2];\n            direction.copyFrom(pickedRay.direction);\n            direction.normalize();\n            direction.scaleInPlace(distance);\n            pickedRay.origin.addToRef(direction, pickedPoint);\n            result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n            return result;\n        }\n        return null;\n    };\n    /**\n     * Intersects the sprites with a ray\n     * @param ray defines the ray to intersect with\n     * @param camera defines the current active camera\n     * @param predicate defines a predicate used to select candidate sprites\n     * @returns null if no hit or a PickingInfo array\n     */\n    SpriteManager.prototype.multiIntersects = function (ray, camera, predicate) {\n        var count = Math.min(this.capacity, this.sprites.length);\n        var min = Vector3.Zero();\n        var max = Vector3.Zero();\n        var distance;\n        var results = [];\n        var pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\n        var cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\n        var cameraView = camera.getViewMatrix();\n        for (var index = 0; index < count; index++) {\n            var sprite = this.sprites[index];\n            if (!sprite) {\n                continue;\n            }\n            if (predicate) {\n                if (!predicate(sprite)) {\n                    continue;\n                }\n            }\n            else if (!sprite.isPickable) {\n                continue;\n            }\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n            if (ray.intersectsBoxMinMax(min, max)) {\n                distance = Vector3.Distance(cameraSpacePosition, ray.origin);\n                if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\n                    continue;\n                }\n                var result = new PickingInfo();\n                results.push(result);\n                cameraView.invertToRef(TmpVectors.Matrix[0]);\n                result.hit = true;\n                result.pickedSprite = sprite;\n                result.distance = distance;\n                // Get picked point\n                var direction = TmpVectors.Vector3[2];\n                direction.copyFrom(ray.direction);\n                direction.normalize();\n                direction.scaleInPlace(distance);\n                ray.origin.addToRef(direction, pickedPoint);\n                result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n            }\n        }\n        return results;\n    };\n    /**\n     * Render all child sprites\n     */\n    SpriteManager.prototype.render = function () {\n        // Check\n        if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\n            return;\n        }\n        var engine = this._scene.getEngine();\n        var deltaTime = engine.getDeltaTime();\n        if (this._packedAndReady) {\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\n        }\n        else {\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\n        }\n    };\n    /**\n     * Rebuilds the manager (after a context lost, for eg)\n     */\n    SpriteManager.prototype.rebuild = function () {\n        var _a;\n        (_a = this._spriteRenderer) === null || _a === void 0 ? void 0 : _a.rebuild();\n    };\n    /**\n     * Release associated resources\n     */\n    SpriteManager.prototype.dispose = function () {\n        if (this._spriteRenderer) {\n            this._spriteRenderer.dispose();\n            this._spriteRenderer = null;\n        }\n        this._textureContent = null;\n        // Remove from scene\n        var index = this._scene.spriteManagers.indexOf(this);\n        this._scene.spriteManagers.splice(index, 1);\n        // Callback\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n    };\n    /**\n     * Serializes the sprite manager to a JSON object\n     * @param serializeTexture defines if the texture must be serialized as well\n     * @returns the JSON object\n     */\n    SpriteManager.prototype.serialize = function (serializeTexture) {\n        if (serializeTexture === void 0) { serializeTexture = false; }\n        var serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.capacity = this.capacity;\n        serializationObject.cellWidth = this.cellWidth;\n        serializationObject.cellHeight = this.cellHeight;\n        if (this.texture) {\n            if (serializeTexture) {\n                serializationObject.texture = this.texture.serialize();\n            }\n            else {\n                serializationObject.textureUrl = this.texture.name;\n                serializationObject.invertY = this.texture._invertY;\n            }\n        }\n        serializationObject.sprites = [];\n        for (var _i = 0, _a = this.sprites; _i < _a.length; _i++) {\n            var sprite = _a[_i];\n            serializationObject.sprites.push(sprite.serialize());\n        }\n        return serializationObject;\n    };\n    /**\n     * Parses a JSON object to create a new sprite manager.\n     * @param parsedManager The JSON object to parse\n     * @param scene The scene to create the sprite manager\n     * @param rootUrl The root url to use to load external dependencies like texture\n     * @returns the new sprite manager\n     */\n    SpriteManager.Parse = function (parsedManager, scene, rootUrl) {\n        var manager = new SpriteManager(parsedManager.name, \"\", parsedManager.capacity, {\n            width: parsedManager.cellWidth,\n            height: parsedManager.cellHeight,\n        }, scene);\n        if (parsedManager.texture) {\n            manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);\n        }\n        else if (parsedManager.textureName) {\n            manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\n        }\n        for (var _i = 0, _a = parsedManager.sprites; _i < _a.length; _i++) {\n            var parsedSprite = _a[_i];\n            Sprite.Parse(parsedSprite, manager);\n        }\n        return manager;\n    };\n    /**\n     * Creates a sprite manager from a snippet saved in a remote file\n     * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\n     * @param url defines the url to load from\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new sprite manager\n     */\n    SpriteManager.ParseFromFileAsync = function (name, url, scene, rootUrl) {\n        if (rootUrl === void 0) { rootUrl = \"\"; }\n        return new Promise(function (resolve, reject) {\n            var request = new WebRequest();\n            request.addEventListener(\"readystatechange\", function () {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        var serializationObject = JSON.parse(request.responseText);\n                        var output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n                        if (name) {\n                            output.name = name;\n                        }\n                        resolve(output);\n                    }\n                    else {\n                        reject(\"Unable to load the sprite manager\");\n                    }\n                }\n            });\n            request.open(\"GET\", url);\n            request.send();\n        });\n    };\n    /**\n     * Creates a sprite manager from a snippet saved by the sprite editor\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new sprite manager\n     */\n    SpriteManager.CreateFromSnippetAsync = function (snippetId, scene, rootUrl) {\n        var _this = this;\n        if (rootUrl === void 0) { rootUrl = \"\"; }\n        if (snippetId === \"_BLANK\") {\n            return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\n        }\n        return new Promise(function (resolve, reject) {\n            var request = new WebRequest();\n            request.addEventListener(\"readystatechange\", function () {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n                        var serializationObject = JSON.parse(snippet.spriteManager);\n                        var output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n                        output.snippetId = snippetId;\n                        resolve(output);\n                    }\n                    else {\n                        reject(\"Unable to load the snippet \" + snippetId);\n                    }\n                }\n            });\n            request.open(\"GET\", _this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n            request.send();\n        });\n    };\n    /** Define the Url to load snippets */\n    SpriteManager.SnippetUrl = `https://snippet.babylonjs.com`;\n    return SpriteManager;\n}());\nexport { SpriteManager };\n//# sourceMappingURL=spriteManager.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"spriteMapPixelShader\";\nvar shader = \"precision highp float;\\nvarying vec3 vPosition;\\nvarying vec2 vUV;\\nvarying vec2 tUV;\\nuniform float time;\\nuniform float spriteCount;\\nuniform sampler2D spriteSheet;\\nuniform vec2 spriteMapSize;\\nuniform vec2 outputSize;\\nuniform vec2 stageSize;\\nuniform sampler2D frameMap;\\nuniform sampler2D tileMaps[LAYERS];\\nuniform sampler2D animationMap;\\nuniform vec3 colorMul;\\nfloat mt;\\nconst float fdStep=1./4.;\\nconst float aFrameSteps=1./MAX_ANIMATION_FRAMES;\\nmat4 getFrameData(float frameID){\\nfloat fX=frameID/spriteCount;\\nreturn mat4(\\ntexture2D(frameMap,vec2(fX,0.),0.),\\ntexture2D(frameMap,vec2(fX,fdStep*1.),0.),\\ntexture2D(frameMap,vec2(fX,fdStep*2.),0.),\\nvec4(0.)\\n);\\n}\\nvoid main(){\\nvec4 color=vec4(0.);\\nvec2 tileUV=fract(tUV);\\n#ifdef FLIPU\\ntileUV.y=1.0-tileUV.y;\\n#endif\\nvec2 tileID=floor(tUV);\\nvec2 sheetUnits=1./spriteMapSize;\\nfloat spriteUnits=1./spriteCount;\\nvec2 stageUnits=1./stageSize;\\nfor(int i=0; i<LAYERS; i++) {\\nfloat frameID;\\n#define LAYER_ID_SWITCH\\nvec4 animationData=texture2D(animationMap,vec2((frameID+0.5)/spriteCount,0.),0.);\\nif(animationData.y>0.) {\\nmt=mod(time*animationData.z,1.0);\\nfor(float f=0.; f<MAX_ANIMATION_FRAMES; f++){\\nif(animationData.y>mt){\\nframeID=animationData.x;\\nbreak;\\n}\\nanimationData=texture2D(animationMap,vec2((frameID+0.5)/spriteCount,aFrameSteps*f),0.);\\n}\\n}\\nmat4 frameData=getFrameData(frameID+0.5);\\nvec2 frameSize=(frameData[0].zw)/spriteMapSize;\\nvec2 offset=frameData[0].xy*sheetUnits;\\nvec2 ratio=frameData[2].xy/frameData[0].zw;\\nif (frameData[2].z==1.){\\ntileUV.xy=tileUV.yx;\\n}\\nif (i==0){\\ncolor=texture2D(spriteSheet,tileUV*frameSize+offset);\\n} else {\\nvec4 nc=texture2D(spriteSheet,tileUV*frameSize+offset);\\nfloat alpha=min(color.a+nc.a,1.0);\\nvec3 mixed=mix(color.xyz,nc.xyz,nc.a);\\ncolor=vec4(mixed,alpha);\\n}\\n}\\ncolor.xyz*=colorMul;\\ngl_FragColor=color;\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var spriteMapPixelShader = { name: name, shader: shader };\n//# sourceMappingURL=spriteMap.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nvar name = \"spriteMapVertexShader\";\nvar shader = \"precision highp float;\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec2 uv;\\nvarying vec3 vPosition;\\nvarying vec2 vUV;\\nvarying vec2 tUV;\\nvarying vec2 stageUnits;\\nvarying vec2 levelUnits;\\nvarying vec2 tileID;\\nuniform float time;\\nuniform mat4 worldViewProjection;\\nuniform vec2 outputSize;\\nuniform vec2 stageSize;\\nuniform vec2 spriteMapSize;\\nuniform float stageScale;\\nvoid main() {\\nvec4 p=vec4( position,1. );\\nvPosition=p.xyz;\\nvUV=uv;\\ntUV=uv*stageSize; \\ngl_Position=worldViewProjection*p;\\n}\";\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @hidden */\nexport var spriteMapVertexShader = { name: name, shader: shader };\n//# sourceMappingURL=spriteMap.vertex.js.map","import { Engine } from \"../Engines/engine.js\";\nimport { Vector2, Vector3 } from \"../Maths/math.vector.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/spriteMap.fragment.js\";\nimport \"../Shaders/spriteMap.vertex.js\";\n/**\n * Class used to manage a grid restricted sprite deployment on an Output plane.\n */\nvar SpriteMap = /** @class */ (function () {\n    /**\n     * Creates a new SpriteMap\n     * @param name defines the SpriteMaps Name\n     * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\n     * @param spriteSheet is the Texture that the Sprites are on.\n     * @param options a basic deployment configuration\n     * @param scene The Scene that the map is deployed on\n     */\n    function SpriteMap(name, atlasJSON, spriteSheet, options, scene) {\n        var _this = this;\n        this.name = name;\n        this.sprites = [];\n        this.atlasJSON = atlasJSON;\n        this.sprites = this.atlasJSON[\"frames\"];\n        this.spriteSheet = spriteSheet;\n        /**\n         * Run through the options and set what ever defaults are needed that where not declared.\n         */\n        this.options = options;\n        options.stageSize = options.stageSize || new Vector2(1, 1);\n        options.outputSize = options.outputSize || options.stageSize;\n        options.outputPosition = options.outputPosition || Vector3.Zero();\n        options.outputRotation = options.outputRotation || Vector3.Zero();\n        options.layerCount = options.layerCount || 1;\n        options.maxAnimationFrames = options.maxAnimationFrames || 0;\n        options.baseTile = options.baseTile || 0;\n        options.flipU = options.flipU || false;\n        options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\n        this._scene = scene;\n        this._frameMap = this._createFrameBuffer();\n        this._tileMaps = new Array();\n        for (var i = 0; i < options.layerCount; i++) {\n            this._tileMaps.push(this._createTileBuffer(null, i));\n        }\n        this._animationMap = this._createTileAnimationBuffer(null);\n        var defines = [];\n        defines.push(\"#define LAYERS \" + options.layerCount);\n        if (options.flipU) {\n            defines.push(\"#define FLIPU\");\n        }\n        defines.push(\"#define MAX_ANIMATION_FRAMES \".concat(options.maxAnimationFrames, \".0\"));\n        var shaderString = Effect.ShadersStore[\"spriteMapPixelShader\"];\n        var layerSampleString;\n        if (!scene.getEngine()._features.supportSwitchCaseInShader) {\n            layerSampleString = \"\";\n            for (var i = 0; i < options.layerCount; i++) {\n                layerSampleString += \"if (\".concat(i, \" == i) { frameID = texture2D(tileMaps[\").concat(i, \"], (tileID + 0.5) / stageSize, 0.).x; }\");\n            }\n        }\n        else {\n            layerSampleString = \"switch(i) {\";\n            for (var i = 0; i < options.layerCount; i++) {\n                layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\n                layerSampleString += \"break;\";\n            }\n            layerSampleString += \"}\";\n        }\n        Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\n        this._material = new ShaderMaterial(\"spriteMap:\" + this.name, this._scene, {\n            vertex: \"spriteMap\",\n            fragment: \"spriteMap\" + this.name,\n        }, {\n            defines: defines,\n            attributes: [\"position\", \"normal\", \"uv\"],\n            uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\n            samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\n            needAlphaBlending: true,\n        });\n        this._time = 0;\n        this._material.setFloat(\"spriteCount\", this.spriteCount);\n        this._material.setVector2(\"stageSize\", options.stageSize);\n        this._material.setVector2(\"outputSize\", options.outputSize);\n        this._material.setTexture(\"spriteSheet\", this.spriteSheet);\n        this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\n        var tickSave = 0;\n        var bindSpriteTexture = function () {\n            if (_this.spriteSheet && _this.spriteSheet.isReady()) {\n                if (_this.spriteSheet._texture) {\n                    _this._material.setVector2(\"spriteMapSize\", new Vector2(_this.spriteSheet._texture.baseWidth || 1, _this.spriteSheet._texture.baseHeight || 1));\n                    return;\n                }\n            }\n            if (tickSave < 100) {\n                setTimeout(function () {\n                    tickSave++;\n                    bindSpriteTexture();\n                }, 100);\n            }\n        };\n        bindSpriteTexture();\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\n        this._material.setTexture(\"frameMap\", this._frameMap);\n        this._material.setTextureArray(\"tileMaps\", this._tileMaps);\n        this._material.setTexture(\"animationMap\", this._animationMap);\n        this._material.setFloat(\"time\", this._time);\n        this._output = CreatePlane(name + \":output\", { size: 1, updatable: true }, scene);\n        this._output.scaling.x = options.outputSize.x;\n        this._output.scaling.y = options.outputSize.y;\n        this.position = options.outputPosition;\n        this.rotation = options.outputRotation;\n        var obfunction = function () {\n            _this._time += _this._scene.getEngine().getDeltaTime();\n            _this._material.setFloat(\"time\", _this._time);\n        };\n        this._scene.onBeforeRenderObservable.add(obfunction);\n        this._output.material = this._material;\n    }\n    Object.defineProperty(SpriteMap.prototype, \"spriteCount\", {\n        /** Returns the Number of Sprites in the System */\n        get: function () {\n            return this.sprites.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteMap.prototype, \"position\", {\n        /** Returns the Position of Output Plane*/\n        get: function () {\n            return this._output.position;\n        },\n        /** Returns the Position of Output Plane*/\n        set: function (v) {\n            this._output.position = v;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteMap.prototype, \"rotation\", {\n        /** Returns the Rotation of Output Plane*/\n        get: function () {\n            return this._output.rotation;\n        },\n        /** Returns the Rotation of Output Plane*/\n        set: function (v) {\n            this._output.rotation = v;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpriteMap.prototype, \"animationMap\", {\n        /** Sets the AnimationMap*/\n        get: function () {\n            return this._animationMap;\n        },\n        /** Sets the AnimationMap*/\n        set: function (v) {\n            var buffer = v._texture._bufferView;\n            var am = this._createTileAnimationBuffer(buffer);\n            this._animationMap.dispose();\n            this._animationMap = am;\n            this._material.setTexture(\"animationMap\", this._animationMap);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns tileID location\n     * @returns Vector2 the cell position ID\n     */\n    SpriteMap.prototype.getTileID = function () {\n        var p = this.getMousePosition();\n        p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\n        p.x = Math.floor(p.x);\n        p.y = Math.floor(p.y);\n        return p;\n    };\n    /**\n     * Gets the UV location of the mouse over the SpriteMap.\n     * @returns Vector2 the UV position of the mouse interaction\n     */\n    SpriteMap.prototype.getMousePosition = function () {\n        var out = this._output;\n        var pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, function (mesh) {\n            if (mesh !== out) {\n                return false;\n            }\n            return true;\n        });\n        if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\n            return new Vector2(-1, -1);\n        }\n        var coords = pickinfo.getTextureCoordinates();\n        if (coords) {\n            return coords;\n        }\n        return new Vector2(-1, -1);\n    };\n    /**\n     * Creates the \"frame\" texture Buffer\n     * -------------------------------------\n     * Structure of frames\n     *  \"filename\": \"Falling-Water-2.png\",\n     * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\n     * \"rotated\": true,\n     * \"trimmed\": true,\n     * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\n     * \"sourceSize\": {\"w\":32,\"h\":32}\n     * @returns RawTexture of the frameMap\n     */\n    SpriteMap.prototype._createFrameBuffer = function () {\n        var data = new Array();\n        //Do two Passes\n        for (var i = 0; i < this.spriteCount; i++) {\n            data.push(0, 0, 0, 0); //frame\n            data.push(0, 0, 0, 0); //spriteSourceSize\n            data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\n            data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\n        }\n        //Second Pass\n        for (var i = 0; i < this.spriteCount; i++) {\n            var f = this.sprites[i][\"frame\"];\n            var sss = this.sprites[i][\"spriteSourceSize\"];\n            var ss = this.sprites[i][\"sourceSize\"];\n            var r = this.sprites[i][\"rotated\"] ? 1 : 0;\n            var t_1 = this.sprites[i][\"trimmed\"] ? 1 : 0;\n            //frame\n            data[i * 4] = f.x;\n            data[i * 4 + 1] = f.y;\n            data[i * 4 + 2] = f.w;\n            data[i * 4 + 3] = f.h;\n            //spriteSourceSize\n            data[i * 4 + this.spriteCount * 4] = sss.x;\n            data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\n            data[i * 4 + 3 + this.spriteCount * 4] = sss.h;\n            //sourceSize, rotated, trimmed\n            data[i * 4 + this.spriteCount * 8] = ss.w;\n            data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\n            data[i * 4 + 2 + this.spriteCount * 8] = r;\n            data[i * 4 + 3 + this.spriteCount * 8] = t_1;\n        }\n        var floatArray = new Float32Array(data);\n        var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n        return t;\n    };\n    /**\n     * Creates the tileMap texture Buffer\n     * @param buffer normally and array of numbers, or a false to generate from scratch\n     * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\n     * @returns RawTexture of the tileMap\n     */\n    SpriteMap.prototype._createTileBuffer = function (buffer, _layer) {\n        if (_layer === void 0) { _layer = 0; }\n        var data = new Array();\n        var _ty = this.options.stageSize.y || 0;\n        var _tx = this.options.stageSize.x || 0;\n        if (!buffer) {\n            var bt = this.options.baseTile;\n            if (_layer != 0) {\n                bt = 0;\n            }\n            for (var y = 0; y < _ty; y++) {\n                for (var x = 0; x < _tx * 4; x += 4) {\n                    data.push(bt, 0, 0, 0);\n                }\n            }\n        }\n        else {\n            data = buffer;\n        }\n        var floatArray = new Float32Array(data);\n        var t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n        return t;\n    };\n    /**\n     * Modifies the data of the tileMaps\n     * @param _layer is the ID of the layer you want to edit on the SpriteMap\n     * @param pos is the iVector2 Coordinates of the Tile\n     * @param tile The SpriteIndex of the new Tile\n     */\n    SpriteMap.prototype.changeTiles = function (_layer, pos, tile) {\n        if (_layer === void 0) { _layer = 0; }\n        if (tile === void 0) { tile = 0; }\n        var buffer = this._tileMaps[_layer]._texture._bufferView;\n        if (buffer === null) {\n            return;\n        }\n        var p = new Array();\n        if (pos instanceof Vector2) {\n            p.push(pos);\n        }\n        else {\n            p = pos;\n        }\n        var _tx = this.options.stageSize.x || 0;\n        for (var i = 0; i < p.length; i++) {\n            var _p = p[i];\n            _p.x = Math.floor(_p.x);\n            _p.y = Math.floor(_p.y);\n            var id = _p.x * 4 + _p.y * (_tx * 4);\n            buffer[id] = tile;\n        }\n        var t = this._createTileBuffer(buffer);\n        this._tileMaps[_layer].dispose();\n        this._tileMaps[_layer] = t;\n        this._material.setTextureArray(\"tileMap\", this._tileMaps);\n    };\n    /**\n     * Creates the animationMap texture Buffer\n     * @param buffer normally and array of numbers, or a false to generate from scratch\n     * @returns RawTexture of the animationMap\n     */\n    SpriteMap.prototype._createTileAnimationBuffer = function (buffer) {\n        var data = new Array();\n        var floatArray;\n        if (!buffer) {\n            for (var i = 0; i < this.spriteCount; i++) {\n                data.push(0, 0, 0, 0);\n                var count = 1;\n                while (count < (this.options.maxAnimationFrames || 4)) {\n                    data.push(0, 0, 0, 0);\n                    count++;\n                }\n            }\n            floatArray = new Float32Array(data);\n        }\n        else {\n            floatArray = buffer;\n        }\n        var t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n        return t;\n    };\n    /**\n     * Modifies the data of the animationMap\n     * @param cellID is the Index of the Sprite\n     * @param _frame is the target Animation frame\n     * @param toCell is the Target Index of the next frame of the animation\n     * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\n     * @param speed is a global scalar of the time variable on the map.\n     */\n    SpriteMap.prototype.addAnimationToTile = function (cellID, _frame, toCell, time, speed) {\n        if (cellID === void 0) { cellID = 0; }\n        if (_frame === void 0) { _frame = 0; }\n        if (toCell === void 0) { toCell = 0; }\n        if (time === void 0) { time = 0; }\n        if (speed === void 0) { speed = 1; }\n        var buffer = this._animationMap._texture._bufferView;\n        var id = cellID * 4 + this.spriteCount * 4 * _frame;\n        if (!buffer) {\n            return;\n        }\n        buffer[id] = toCell;\n        buffer[id + 1] = time;\n        buffer[id + 2] = speed;\n        var t = this._createTileAnimationBuffer(buffer);\n        this._animationMap.dispose();\n        this._animationMap = t;\n        this._material.setTexture(\"animationMap\", this._animationMap);\n    };\n    /**\n     * Exports the .tilemaps file\n     */\n    SpriteMap.prototype.saveTileMaps = function () {\n        var maps = \"\";\n        for (var i = 0; i < this._tileMaps.length; i++) {\n            if (i > 0) {\n                maps += \"\\n\\r\";\n            }\n            maps += this._tileMaps[i]._texture._bufferView.toString();\n        }\n        var hiddenElement = document.createElement(\"a\");\n        hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\n        hiddenElement.target = \"_blank\";\n        hiddenElement.download = this.name + \".tilemaps\";\n        hiddenElement.click();\n        hiddenElement.remove();\n    };\n    /**\n     * Imports the .tilemaps file\n     * @param url of the .tilemaps file\n     */\n    SpriteMap.prototype.loadTileMaps = function (url) {\n        var _this = this;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url);\n        var _lc = this.options.layerCount || 0;\n        xhr.onload = function () {\n            var data = xhr.response.split(\"\\n\\r\");\n            for (var i = 0; i < _lc; i++) {\n                var d = data[i].split(\",\").map(Number);\n                var t = _this._createTileBuffer(d);\n                _this._tileMaps[i].dispose();\n                _this._tileMaps[i] = t;\n            }\n            _this._material.setTextureArray(\"tileMap\", _this._tileMaps);\n        };\n        xhr.send();\n    };\n    /**\n     * Release associated resources\n     */\n    SpriteMap.prototype.dispose = function () {\n        this._output.dispose();\n        this._material.dispose();\n        this._animationMap.dispose();\n        this._tileMaps.forEach(function (tm) {\n            tm.dispose();\n        });\n        this._frameMap.dispose();\n    };\n    return SpriteMap;\n}());\nexport { SpriteMap };\n//# sourceMappingURL=spriteMap.js.map","import { __extends } from \"tslib\";\nimport { SpriteManager } from \"./spriteManager.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\n/**\n * Class used to manage multiple sprites of different sizes on the same spritesheet\n * @see https://doc.babylonjs.com/babylon101/sprites\n */\nvar SpritePackedManager = /** @class */ (function (_super) {\n    __extends(SpritePackedManager, _super);\n    /**\n     * Creates a new sprite manager from a packed sprite sheet\n     * @param name defines the manager's name\n     * @param imgUrl defines the sprite sheet url\n     * @param capacity defines the maximum allowed number of sprites\n     * @param scene defines the hosting scene\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\n     * @param samplingMode defines the sampling mode to use with spritesheet\n     * @param fromPacked set to true; do not alter\n     */\n    function SpritePackedManager(\n    /** defines the packed manager's name */\n    name, imgUrl, capacity, scene, spriteJSON, epsilon, samplingMode) {\n        if (spriteJSON === void 0) { spriteJSON = null; }\n        if (epsilon === void 0) { epsilon = 0.01; }\n        if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\n        var _this = \n        //the cellSize parameter is not used when built from JSON which provides individual cell data, defaults to 64 if JSON load fails\n        _super.call(this, name, imgUrl, capacity, 64, scene, epsilon, samplingMode, true, spriteJSON) || this;\n        _this.name = name;\n        return _this;\n    }\n    return SpritePackedManager;\n}(SpriteManager));\nexport { SpritePackedManager };\n//# sourceMappingURL=spritePackedManager.js.map","/**\n * @hidden\n **/\nvar AlphaState = /** @class */ (function () {\n    /**\n     * Initializes the state.\n     */\n    function AlphaState() {\n        this._blendFunctionParameters = new Array(4);\n        this._blendEquationParameters = new Array(2);\n        this._blendConstants = new Array(4);\n        this._isBlendConstantsDirty = false;\n        this._alphaBlend = false;\n        this._isAlphaBlendDirty = false;\n        this._isBlendFunctionParametersDirty = false;\n        this._isBlendEquationParametersDirty = false;\n        this.reset();\n    }\n    Object.defineProperty(AlphaState.prototype, \"isDirty\", {\n        get: function () {\n            return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AlphaState.prototype, \"alphaBlend\", {\n        get: function () {\n            return this._alphaBlend;\n        },\n        set: function (value) {\n            if (this._alphaBlend === value) {\n                return;\n            }\n            this._alphaBlend = value;\n            this._isAlphaBlendDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    AlphaState.prototype.setAlphaBlendConstants = function (r, g, b, a) {\n        if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {\n            return;\n        }\n        this._blendConstants[0] = r;\n        this._blendConstants[1] = g;\n        this._blendConstants[2] = b;\n        this._blendConstants[3] = a;\n        this._isBlendConstantsDirty = true;\n    };\n    AlphaState.prototype.setAlphaBlendFunctionParameters = function (value0, value1, value2, value3) {\n        if (this._blendFunctionParameters[0] === value0 &&\n            this._blendFunctionParameters[1] === value1 &&\n            this._blendFunctionParameters[2] === value2 &&\n            this._blendFunctionParameters[3] === value3) {\n            return;\n        }\n        this._blendFunctionParameters[0] = value0;\n        this._blendFunctionParameters[1] = value1;\n        this._blendFunctionParameters[2] = value2;\n        this._blendFunctionParameters[3] = value3;\n        this._isBlendFunctionParametersDirty = true;\n    };\n    AlphaState.prototype.setAlphaEquationParameters = function (rgb, alpha) {\n        if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {\n            return;\n        }\n        this._blendEquationParameters[0] = rgb;\n        this._blendEquationParameters[1] = alpha;\n        this._isBlendEquationParametersDirty = true;\n    };\n    AlphaState.prototype.reset = function () {\n        this._alphaBlend = false;\n        this._blendFunctionParameters[0] = null;\n        this._blendFunctionParameters[1] = null;\n        this._blendFunctionParameters[2] = null;\n        this._blendFunctionParameters[3] = null;\n        this._blendEquationParameters[0] = null;\n        this._blendEquationParameters[1] = null;\n        this._blendConstants[0] = null;\n        this._blendConstants[1] = null;\n        this._blendConstants[2] = null;\n        this._blendConstants[3] = null;\n        this._isAlphaBlendDirty = true;\n        this._isBlendFunctionParametersDirty = false;\n        this._isBlendEquationParametersDirty = false;\n        this._isBlendConstantsDirty = false;\n    };\n    AlphaState.prototype.apply = function (gl) {\n        if (!this.isDirty) {\n            return;\n        }\n        // Alpha blend\n        if (this._isAlphaBlendDirty) {\n            if (this._alphaBlend) {\n                gl.enable(gl.BLEND);\n            }\n            else {\n                gl.disable(gl.BLEND);\n            }\n            this._isAlphaBlendDirty = false;\n        }\n        // Alpha function\n        if (this._isBlendFunctionParametersDirty) {\n            gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);\n            this._isBlendFunctionParametersDirty = false;\n        }\n        // Alpha equation\n        if (this._isBlendEquationParametersDirty) {\n            gl.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]);\n            this._isBlendEquationParametersDirty = false;\n        }\n        // Constants\n        if (this._isBlendConstantsDirty) {\n            gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);\n            this._isBlendConstantsDirty = false;\n        }\n    };\n    return AlphaState;\n}());\nexport { AlphaState };\n//# sourceMappingURL=alphaCullingState.js.map","/**\n * @hidden\n **/\nvar DepthCullingState = /** @class */ (function () {\n    /**\n     * Initializes the state.\n     * @param reset\n     */\n    function DepthCullingState(reset) {\n        if (reset === void 0) { reset = true; }\n        this._isDepthTestDirty = false;\n        this._isDepthMaskDirty = false;\n        this._isDepthFuncDirty = false;\n        this._isCullFaceDirty = false;\n        this._isCullDirty = false;\n        this._isZOffsetDirty = false;\n        this._isFrontFaceDirty = false;\n        if (reset) {\n            this.reset();\n        }\n    }\n    Object.defineProperty(DepthCullingState.prototype, \"isDirty\", {\n        get: function () {\n            return (this._isDepthFuncDirty ||\n                this._isDepthTestDirty ||\n                this._isDepthMaskDirty ||\n                this._isCullFaceDirty ||\n                this._isCullDirty ||\n                this._isZOffsetDirty ||\n                this._isFrontFaceDirty);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DepthCullingState.prototype, \"zOffset\", {\n        get: function () {\n            return this._zOffset;\n        },\n        set: function (value) {\n            if (this._zOffset === value) {\n                return;\n            }\n            this._zOffset = value;\n            this._isZOffsetDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DepthCullingState.prototype, \"zOffsetUnits\", {\n        get: function () {\n            return this._zOffsetUnits;\n        },\n        set: function (value) {\n            if (this._zOffsetUnits === value) {\n                return;\n            }\n            this._zOffsetUnits = value;\n            this._isZOffsetDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DepthCullingState.prototype, \"cullFace\", {\n        get: function () {\n            return this._cullFace;\n        },\n        set: function (value) {\n            if (this._cullFace === value) {\n                return;\n            }\n            this._cullFace = value;\n            this._isCullFaceDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DepthCullingState.prototype, \"cull\", {\n        get: function () {\n            return this._cull;\n        },\n        set: function (value) {\n            if (this._cull === value) {\n                return;\n            }\n            this._cull = value;\n            this._isCullDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DepthCullingState.prototype, \"depthFunc\", {\n        get: function () {\n            return this._depthFunc;\n        },\n        set: function (value) {\n            if (this._depthFunc === value) {\n                return;\n            }\n            this._depthFunc = value;\n            this._isDepthFuncDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DepthCullingState.prototype, \"depthMask\", {\n        get: function () {\n            return this._depthMask;\n        },\n        set: function (value) {\n            if (this._depthMask === value) {\n                return;\n            }\n            this._depthMask = value;\n            this._isDepthMaskDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DepthCullingState.prototype, \"depthTest\", {\n        get: function () {\n            return this._depthTest;\n        },\n        set: function (value) {\n            if (this._depthTest === value) {\n                return;\n            }\n            this._depthTest = value;\n            this._isDepthTestDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DepthCullingState.prototype, \"frontFace\", {\n        get: function () {\n            return this._frontFace;\n        },\n        set: function (value) {\n            if (this._frontFace === value) {\n                return;\n            }\n            this._frontFace = value;\n            this._isFrontFaceDirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DepthCullingState.prototype.reset = function () {\n        this._depthMask = true;\n        this._depthTest = true;\n        this._depthFunc = null;\n        this._cullFace = null;\n        this._cull = null;\n        this._zOffset = 0;\n        this._zOffsetUnits = 0;\n        this._frontFace = null;\n        this._isDepthTestDirty = true;\n        this._isDepthMaskDirty = true;\n        this._isDepthFuncDirty = false;\n        this._isCullFaceDirty = false;\n        this._isCullDirty = false;\n        this._isZOffsetDirty = true;\n        this._isFrontFaceDirty = false;\n    };\n    DepthCullingState.prototype.apply = function (gl) {\n        if (!this.isDirty) {\n            return;\n        }\n        // Cull\n        if (this._isCullDirty) {\n            if (this.cull) {\n                gl.enable(gl.CULL_FACE);\n            }\n            else {\n                gl.disable(gl.CULL_FACE);\n            }\n            this._isCullDirty = false;\n        }\n        // Cull face\n        if (this._isCullFaceDirty) {\n            gl.cullFace(this.cullFace);\n            this._isCullFaceDirty = false;\n        }\n        // Depth mask\n        if (this._isDepthMaskDirty) {\n            gl.depthMask(this.depthMask);\n            this._isDepthMaskDirty = false;\n        }\n        // Depth test\n        if (this._isDepthTestDirty) {\n            if (this.depthTest) {\n                gl.enable(gl.DEPTH_TEST);\n            }\n            else {\n                gl.disable(gl.DEPTH_TEST);\n            }\n            this._isDepthTestDirty = false;\n        }\n        // Depth func\n        if (this._isDepthFuncDirty) {\n            gl.depthFunc(this.depthFunc);\n            this._isDepthFuncDirty = false;\n        }\n        // zOffset\n        if (this._isZOffsetDirty) {\n            if (this.zOffset || this.zOffsetUnits) {\n                gl.enable(gl.POLYGON_OFFSET_FILL);\n                gl.polygonOffset(this.zOffset, this.zOffsetUnits);\n            }\n            else {\n                gl.disable(gl.POLYGON_OFFSET_FILL);\n            }\n            this._isZOffsetDirty = false;\n        }\n        // Front face\n        if (this._isFrontFaceDirty) {\n            gl.frontFace(this.frontFace);\n            this._isFrontFaceDirty = false;\n        }\n    };\n    return DepthCullingState;\n}());\nexport { DepthCullingState };\n//# sourceMappingURL=depthCullingState.js.map"],"names":["toRemove","this","reflectionProbes","index","indexOf","splice","newReflectionProbe","push","ReflectionProbe","name","size","scene","generateMipMaps","useFloat","linearSpace","_this","_viewMatrix","_target","_add","_invertYAxis","position","_parentContainer","_scene","getEngine","supportsUniformBuffers","_sceneUBOs","i","createSceneUniformBuffer","concat","Array","textureType","caps","getCaps","textureHalfFloatRender","textureFloatRender","_renderTargetTexture","gammaSpace","currentApplyByPostProcess","useReverseDepthBuffer","onBeforeRenderObservable","add","faceIndex","setSceneUniformBuffer","getSceneUniformBuffer","unbindEffect","copyFromFloats","useRightHandedSystem","_attachedMesh","copyFrom","getAbsolutePosition","addToRef","lookAtFunction","perspectiveFunction","activeCamera","_projectionMatrix","Math","PI","maxZ","minZ","isNDCHalfZRange","setTransformMatrix","isRigCamera","rigParent","_forcedViewPosition","onBeforeBindObservable","_a","_b","_currentSceneUBO","_debugPushGroup","call","imageProcessingConfiguration","applyByPostProcess","onAfterUnbindObservable","updateTransformMatrix","_debugPopGroup","Object","defineProperty","prototype","get","samples","set","value","enumerable","configurable","refreshRate","getScene","renderList","attachToMesh","mesh","setRenderingAutoClearDepthStencil","renderingGroupId","autoClearDepthStencil","dispose","index_1","_i","length","toString","fullDetails","ret","getClassName","serialize","serializationObject","isReflectionProbe","Parse","parsedReflectionProbe","rootUrl","reflectionProbe","rp","renderTargetSize","_generateMipMaps","cubeTexture","_waitingRenderList","getMeshById","shader","DepthRenderer","type","camera","storeNonLinearDepth","samplingMode","enabled","forceDepthWriteTransparentMeshes","useOnlyInActiveCamera","_storeNonLinearDepth","isPacked","_clearColor","_SceneComponentInitialization","engine","_camera","_caps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","format","_features","supportExtendedTextureFormats","_depthMap","width","getRenderWidth","height","getRenderHeight","undefined","wrapU","wrapV","renderParticles","ignoreCameraViewport","useCameraPostProcesses","onClearObservable","clear","customIsReadyFunction","isReady","subMeshes","subMesh","renderingMesh","getRenderingMesh","batch","_getInstancesRenderList","_id","getReplacementMesh","hardwareInstancedRendering","instancedArrays","visibleInstances","hasThinInstances","renderSubMesh","effectiveMesh","getEffectiveMesh","material","getMaterial","_internalAbstractMeshDataInfo","_isActiveIntermediate","infiniteDistance","disableDepthWrite","verticesCount","_renderId","getRenderId","detNeg","_getWorldMatrixDeterminant","sideOrientation","overrideMaterialSideOrientation","reverseSideOrientation","setState","backFaceCulling","cullBackFaces","mustReturn","renderingMaterial","_materialForRenderPass","currentRenderPassId","drawWrapper","_getDrawWrapper","cameraIsOrtho","mode","effect_1","effect","enableEffect","_bind","fillMode","bindForSubMesh","getWorldMatrix","setMatrix","getTransformMatrix","setFloat2","needAlphaTesting","alphaTexture","getAlphaTestTexture","setTexture","getTextureMatrix","useBones","computeBonesUsingShaders","skeleton","isUsingTextureForMatrices","boneTexture","getTransformMatrixTexture","setFloat","bones","setMatrices","getTransformMatrices","morphTargetManager","isUsingTextureForTargets","_processRendering","isInstance","world","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","data","setMaterialForRendering","useInstances","getMesh","isReadyForSubMesh","defines","attribs","isVerticesDataPresent","numBoneInfluencers","numMorphInfluencers","numInfluencers","cachedDefines","join","setEffect","createEffect","maxSimultaneousMorphTargets","getDepthMap","keysToDelete","key","_depthRenderer","keysToDelete_1","_","GeometryBufferRenderer","ratio","_previousTransformationMatrices","_previousBonesTransformationMatrices","excludedSkinnedMeshesFromVelocity","renderTransparentMeshes","_resizeObserver","_enablePosition","_enableVelocity","_enableReflectivity","_positionIndex","_velocityIndex","_reflectivityIndex","_depthIndex","_normalIndex","_linkedWithPrePass","_ratio","_useUbo","_createRenderTargets","_linkPrePassRenderer","prePassRenderer","_prePassRenderer","_multiRenderTarget","_unlinkPrePassRenderer","_resetLayout","_attachments","_forceTextureType","geometryBufferType","POSITION_TEXTURE_TYPE","VELOCITY_TEXTURE_TYPE","REFLECTIVITY_TEXTURE_TYPE","DEPTH_TEXTURE_TYPE","NORMAL_TEXTURE_TYPE","_setAttachments","attachments","_linkInternalTexture","internalTexture","setInternalTexture","meshes","isSupported","getTextureIndex","enable","needsPreviousWorldMatrices","needUv","coordinatesIndex","bumpTexture","metallicWorkflow","metallicRoughnessTexture","metallic","roughness","baseTexture","baseColor","specularGlossinessTexture","specularColor","glossiness","metallicTexture","albedoTexture","albedoColor","reflectivityTexture","reflectivityColor","microSurface","specularTexture","textures","attributes","uniformsNames","samplers","onCompiled","fallbacks","onError","uniformBuffersNames","indexParameters","buffersCount","getGBuffer","onResizeObservable","remove","_assignRenderTargetIndices","textureNames","count","textureFloat","textureHalfFloat","generateDepthTexture","defaultType","resize","uniqueId","viewProjection","bonesTransformations","_copyBonesTransformationMatrices","Float32Array","finalizeSceneUbo","getViewMatrix","instanceDataStorage","_instanceDataStorage","isFrozen","mainDeterminant","_preBind","standardDerivatives","setFloat3","level","parallaxScaleBias","invertNormalMapX","invertNormalMapY","setColor3","w","clone","bindAttachments","setColorWrite","setDepthWrite","source","target","_geometryBufferRenderer","GeometryBufferRendererSceneComponent","register","_gatherRenderTargetsStage","registerStep","_gatherRenderTargets","rebuild","renderTargets","component","_getComponent","_addComponent","_forceShowBoundingBoxes","getBoundingBoxRenderer","_boundingBoxRenderer","BoundingBoxRenderer","_showBoundingBox","frontColor","backColor","showBackLines","onBeforeBoxRenderingObservable","onAfterBoxRenderingObservable","onResourcesReadyObservable","_vertexBuffers","_fillIndexBuffer","_fillIndexData","_uniformBufferFront","isWebGPU","_buildUniformLayout","_uniformBufferBack","ubo","addUniform","create","_beforeEvaluateActiveMeshStage","reset","_preActiveMeshStage","_preActiveMesh","_evaluateSubMeshStage","_evaluateSubMesh","_afterRenderingGroupDrawStage","render","showSubMeshesBoundingBox","boundingInfo","getBoundingInfo","boundingBox","_tag","showBoundingBox","forceShowBoundingBoxes","_prepareResources","_colorShader","uniforms","uniformBuffers","reservedDataStore","hidden","_colorShaderForOcclusionQuery","boxdata","positions","_createIndexBuffer","indices","notifyObservers","_indexBuffer","createIndexBuffer","vb","_rebuild","toColor4","transformMatrix","boundingBoxIndex","_createWrappersForBoundingBox","min","minimum","diff","maximum","subtract","median","scale","worldMatrix","x","y","z","multiply","drawWrapperBack","_drawWrapperBack","bindBuffers","getEffect","setDepthFunctionToLessOrEqual","setDepthFunctionToGreaterOrEqual","bindToEffect","updateDirectColor4","updateMatrix","update","drawElementsType","drawWrapperFront","_drawWrapperFront","setDepthFunctionToGreater","setDepthFunctionToLess","unbind","renderOcclusionBoundingBox","_renderPassIdForOcclusionQuery","createRenderPassId","hasBoundingInfo","_drawWrapper","resetCachedMaterial","releaseRenderPassId","buffer","_releaseBuffer","force32bitsFloat","id","supportFullfloat","DepthRendererSceneComponent","_gatherActiveCameraRenderTargetsStage","_gatherActiveCameraRenderTargets","depthRenderer","DepthPeelingEffectConfiguration","texturesRequired","DepthPeelingRenderer","passCount","_thinTextures","_currentPingPongState","_layoutCacheFormat","_layoutCache","_candidateSubMeshes","_excludedSubMeshes","_colorCache","_DEPTH_CLEAR_VALUE","_MIN_DEPTH","_MAX_DEPTH","_engine","_passCount","enablePrePassRenderer","buildTextureLayout","_renderPassIds","useRenderPasses","_prePassEffectConfiguration","_createTextures","_createEffects","_createRenderPassIds","_useRenderPasses","usePasses","_releaseRenderPassIds","_depthMrts","_colorMrts","generateDepthBuffer","_blendBackMrt","optionsArray","depthTexture","_createInternalTexture","frontColorTexture","backColorTexture","_disposeTextures","_updateTextures","getSize","_updateTextureReferences","textureIndex","getIndex","prePassTexture","defaultRT","getInternalTexture","_blendBackTexture","renderTarget","_shareDepth","_blendBackEffectWrapper","fragmentShader","useShaderStore","samplerNames","uniformNames","_blendBackEffectWrapperPingPong","_finalEffectWrapper","_effectRenderer","setPrePassRenderer","addEffectConfiguration","bind","_renderSubMeshes","mapMaterialContext","j","previousShaderHotSwapping","previousBFC","firstDraw","allowShaderHotSwapping","materialContext","newMaterialContext","createMaterialContext","_finalCompose","writeId","restoreDefaultFramebuffer","setAlphaMode","applyStates","_enabled","bindFramebuffer","setAlphaEquation","depthCullingState","depthMask","depthTest","readId","blendBackEffectWrapper","_depthPeelingRenderer","DepthPeelingSceneComponent","_useOrderIndependentTransparency","markAllMaterialsAsDirty","markAsDirty","depthPeelingRenderer","_edgesRenderer","epsilon","checkVerticesInsteadOfIndices","options","disableEdgesRendering","EdgesRenderer","LineEdgesRenderer","arguments","FaceAdjacencies","edges","edgesConnectedCount","generateEdgesLines","edgesWidthScalerForOrthographic","edgesWidthScalerForPerspective","_linesPositions","_linesNormals","_linesIndices","_buffers","_buffersForInstances","_checkVerticesInsteadOfIndices","isEnabled","customInstances","_source","_options","_epsilon","_prepareRessources","useAlternateEdgeFinder","_generateEdgesLinesAlternate","_generateEdgesLines","_meshRebuildObserver","onRebuildObservable","_meshDisposeObserver","onDisposeObservable","_lineShader","_GetShader","_edgeRenderLineShader","checkReadyOnEveryCall","_ib","_processEdgeForAdjacencies","pa","pb","p0","p1","p2","_processEdgeForAdjacenciesWithVertices","eps","equalsWithEpsilon","_checkEdge","edge","faceNormals","needToCreateLine","createLine","offset","_tessellateTriangle","edgePoints","indexTriangle","remapVertexIndices","makePointList","pointIndices","firstIndex","startEdge","e","sort","a","b","mainPointIndices","otherPointIndices","numMainPoints","numOtherPoints","bucketIsMain","bucketStep","bucketLimit","bucketIdxLimit","winding","numTris","bucketIdx","nbucketIdx","bucketPoints","nbucketPoints","bucket","lastIdx","_c","_d","_e","_f","_g","_h","_j","_k","getVerticesData","getIndices","isArray","from","useFastVertexMerger","epsVertexMerge","round","log","epsilonVertexMerge","uniquePositions","mapVertices","v1","x1","y1","z1","toFixed","idx","found","v2","x2","y2","z2","abs","applyTessellation","epsVertexAligned","epsilonVertexAligned","mustTesselate","triangleToTessellate","p0Index","p1Index","p2Index","p0x","p0y","p0z","p1x","p1y","p1z","p0p1","sqrt","v","vIndex","p0p","pp1","edgesPoints","t","triangle","faceNormal","removeDegeneratedTriangles","normalize","tmp","ei","done","normal","_indicesCount","faceAdjacencies","adjacencies","otherIndex","otherFaceAdjacencies","otherP0","otherP1","otherP2","edgeIndex","otherEdgeIndex","current","hasInstances","currentDrawWrapper","_setDrawWrapper","useBuffersWithInstances","instanceCount","getVertexBuffer","instanceStorage","instancesData","_activeMeshesFrozen","copyToArray","instancesBuffer","updateDirectly","thinInstanceCount","edgesColor","setColor4","edgesWidth","getAspectRatio","unbindInstanceAttributes","_super","len","PrePassRenderer","excludedSkinnedMesh","excludedMaterials","mrtCount","_mrtFormats","_mrtLayout","_mrtNames","_textureIndices","_isDirty","_effectConfigurations","doNotUseGeometryRendererFallback","_needsCompositionForThisPass","disableGammaTransform","_createRenderTarget","_currentTarget","n","getRenderTarget","_setRenderTarget","prePassRenderTarget","renderPassId","_refreshGeometryBufferRendererLink","_geometryBuffer","disableGeometryBufferRenderer","enableGeometryBufferRenderer","renderTargetTexture","rt","generateStencilBuffer","isStencilEnable","types","drawOnlyOnFirstAttachmentByDefault","drawBuffersExtension","bindAttachmentsForEffect","isPrePassCapable","excluded","_multiTarget","_multiRenderAttachments","_currentRenderTarget","_defaultAttachments","restoreSingleAttachment","currentRTisSceneRT","_reinitializeAttachments","multiRenderLayout","clearLayout","defaultLayout","_clearAttachments","_TextureFormats","_updateGeometryBufferLayout","texturesActivated","matches","prePassConstant","geometryBufferConstant","restoreAttachments","_beforeDraw","layer","_update","_setupOutputForThisPass","_prepareFrame","_postProcessesSourceForThisPass","postProcessManager","_renderPostProcesses","firstPP","outputTexture","inputTexture","postProcessChain","_beforeCompositionPostProcesses","imageProcessingPostProcess","texture","directRender","_afterDraw","_clear","_bindFrameBuffer","_checkSize","_setEnabled","_setRenderTargetEnabled","_unlinkInternalTexture","cfg","_enable","previousMrtCount","_enableTextures","updateCount","_resetPostProcessChain","postProcess","createPostProcess","_disable","_getPostProcessesSource","_postProcesses","camera_1","postProcesses","secondaryCamera","activeCameras","filter","pp","autoClear","cameraHasImageProcessing","_hasImageProcessing","_needsImageProcessing","firstCameraPP","_getFirstPostProcess","firstPrePassPP","_createCompositionEffect","_outputPostProcess","_internalTextureDirty","restoreDefaultInputTexture","needsImageProcessing","isIPPAlreadyPresent","ppIndex","enablePrePass","useOrderIndependentTransparency","materials","_markAllMaterialsAsPrePassDirty","PrePassRendererSceneComponent","_beforeCameraDrawStage","_beforeCameraDraw","_afterCameraDrawStage","_afterCameraDraw","_beforeRenderTargetDrawStage","_beforeRenderTargetDraw","_afterRenderTargetDrawStage","_afterRenderTargetDraw","_beforeClearStage","_beforeRenderTargetClearStage","_beforeRenderingMeshStage","_afterRenderingMeshStage","_prePassRenderTarget","disablePrePassRenderer","SubSurfaceConfiguration","_ssDiffusionS","_ssFilterRadii","_ssDiffusionD","ssDiffusionProfileColors","metersPerUnit","addDiffusionProfile","color","ssDiffusionD","r","g","max","getDiffusionProfileParameters","clearAllDiffusionProfiles","maxScatteringDistance","_sampleBurleyDiffusionProfile","u","rcpS","pow","c","parsedData","enableSubSurfaceForPrePass","subSurfaceConfiguration","cache","_subSurfaceConfiguration","SubSurfaceSceneComponent","addFromContainer","removeFromContainer","_outlineRenderer","OutlineRenderer","_renderOutline","getOutlineRenderer","_renderOverlay","zOffset","zOffsetUnits","_passIdForDrawWrapper","_beforeRenderingMesh","_afterRenderingMesh","useOverlay","ownerMesh","replacementMesh","_actAsRegularMesh","useLogarithmicDepth","LN2","outlineWidth","overlayColor","outlineColor","overlayAlpha","alpha","setZOffset","setZOffsetUnits","clipPlane","clipPlane2","clipPlane3","clipPlane4","clipPlane5","clipPlane6","_savedDepthWrite","getDepthWrite","renderOutline","needAlphaBlendingForMesh","cacheStencilState","setStencilBuffer","setStencilOperationPass","setStencilFunction","setStencilMask","_StencilReference","setStencilFunctionReference","stencilStateComposer","useStencilGlobalOnly","restoreStencilState","renderOverlay","currentMode","getAlphaMode","alphaBlendState","alphaState","alphaBlend","MotionBlurConfiguration","RenderingGroup","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","_opaqueSubMeshes","_transparentSubMeshes","_alphaTestSubMeshes","_depthOnlySubMeshes","_particleSystems","_spriteManagers","_empty","_edgesRenderers","_opaqueSortCompareFn","PainterSortCompare","_renderOpaque","_renderOpaqueSorted","_alphaTestSortCompareFn","_renderAlphaTest","_renderAlphaTestSorted","_transparentSortCompareFn","defaultTransparentSortCompare","_renderTransparent","_renderTransparentSorted","renderSprites","activeMeshes","stencilState","getStencilBuffer","_renderSprites","_renderParticles","onBeforeTransparentRendering","excludedMeshes","edgesRendererIndex","_RenderSorted","sortCompareFn","transparent","subIndex","cameraPosition","globalPosition","_ZeroVector","_alphaIndex","alphaIndex","_distanceToCamera","boundingSphere","centerWorld","sortedArray","slice","_activeMeshesFrozenButKeepClipping","isInFrustum","_frustumPlanes","needDepthPrePass","backToFrontSortCompare","frontToBackSortCompare","meshA","meshB","prepare","dispatch","_renderingGroup","pushNoDuplicate","dispatchSprites","spriteManager","dispatchParticles","particleSystem","onBeforeParticlesRenderingObservable","particleIndex","layerMask","emitter","_activeParticles","addCount","onAfterParticlesRenderingObservable","spritesEnabled","onBeforeSpritesRenderingObservable","onAfterSpritesRenderingObservable","RenderingGroupInfo","RenderingManager","_useSceneAutoClearSetup","_renderingGroups","_autoClearDepthStencil","_customOpaqueSortCompareFn","_customAlphaTestSortCompareFn","_customTransparentSortCompareFn","_renderingGroupInfo","MIN_RENDERINGGROUPS","MAX_RENDERINGGROUPS","depth","stencil","_clearDepthStencilBuffer","_depthStencilBufferAlreadyCleaned","info","spriteManagers","manager","renderingGroup","renderingGroupMask","onBeforeRenderingGroupObservable","AUTOCLEAR","getAutoClearDepthStencilSetup","_beforeRenderingGroupDrawStage","action","onAfterRenderingGroupObservable","freeRenderingGroups","_prepareRenderingGroup","setRenderingOrder","group","ScreenSpaceReflectionsConfiguration","SSAO2Configuration","UtilityLayerRenderer","originalScene","handleEvents","_pointerCaptures","_lastPointerEvents","_sharedGizmoLight","_renderCamera","pickUtilitySceneFirst","shouldRender","onlyCheckPointerDownEvents","processAllEvents","pickingEnabled","onPointerOutObservable","utilityLayerScene","virtual","_allowPostProcessClearColor","postProcessesEnabled","detachControl","_originalPointerObserver","onPrePointerObservable","prePointerInfo","pointerX","pointerY","pointerEvent","event","isPointerCaptured","pointerId","getNearPickDataForScene","scenePick","nearInteractionPickingInfo","pickedMesh","previousActiveCamera","_activeCamera","ray","pickWithRay","pick","utilityScenePick","skipOnPointerObservable","onPointerObservable","autoClearDepthAndStencil","hit","originalScenePick","pointerEvent_1","distance","mainSceneTrackerPredicate","_notifyObservers","makeObserverTopPriority","_afterRenderObserver","onAfterCameraRenderObservable","getRenderCamera","_sceneDisposeObserver","_updateCamera","getRigParentIfPossible","activeCam","setRenderCamera","cam","_getSharedGizmoLight","intensity","groundColor","_DefaultUtilityLayer","_CreateDefaultUtilityLayerFromScene","addOnce","_DefaultKeepDepthUtilityLayer","pickInfo","oldScene","leftCamera","rightCamera","cameraToUseForPointers","Sprite","animations","isPickable","useAlphaForPicking","_onAnimationEnd","_endAnimation","disposeWhenFinishedAnimating","_manager","sprites","getUniqueId","_fromIndex","playAnimation","_toIndex","_loopAnimation","_delay","to","loop","delay","onAnimationEnd","asArray","angle","cellIndex","cellRef","invertU","invertV","isVisible","animationStarted","fromIndex","toIndex","loopAnimation","parsedSprite","sprite","ThinSprite","_animationStarted","_direction","_time","_onBaseAnimationEnd","stopAnimation","_animate","deltaTime","predicate","fastCheck","pickingInfo","spriteIndex","result","intersects","pickingInfos","results","multiIntersects","_tempSpritePickingRay","createPickingRayInCameraSpaceToRef","_internalPickSprites","createPickingRayInCameraSpace","_internalMultiPickSprites","_pointerOverSprite","actionManager","processTrigger","SpriteSceneComponent","_spritePredicate","hasPointerTriggers","_pointerMoveStage","_pointerMove","_pointerDownStage","_pointerDown","_pointerUpStage","_pointerUp","_pickSpriteButKeepRay","originalPointerInfo","pickSprite","unTranslatedPointerX","unTranslatedPointerY","pickResult","isMeshPicked","element","setPointerOverSprite","pickedSprite","doNotHandleCursors","hoverCursor","style","cursor","evt","_pickedDownSprite","button","spritePickResult","_inputManager","_isPointerSwiping","SpriteRenderer","capacity","blendMode","autoResetAlpha","fogEnabled","_useVAO","_useInstancing","_capacity","vertexArrayObject","disableVertexArrayObjects","_drawWrapperBase","_drawWrapperFog","_drawWrapperDepth","_drawWrapperFogDepth","_buildIndexBuffer","drawContext","useInstancing","_vertexBufferSize","_vertexData","_buffer","offsets","createVertexBuffer","spriteData","_spriteBuffer","inverts","cellInfo","colors","viewMatrix","projectionMatrix","customSpriteUpdate","drawWrapperDepth","shouldRenderFog","fogMode","baseSize","getBaseSize","noSprite","_appendSpriteVertex","culling","cull","setFloat4","fogStart","fogEnd","fogDensity","fogColor","_vertexArrayObject","recordVertexArrayObject","bindVertexArrayObject","depthFunc","setBool","drawArraysType","offsetX","offsetY","arrayOffset","rowSize","cellWidth","_xOffset","_yOffset","cellHeight","_xSize","_ySize","releaseVertexArrayObject","SpriteManager","imgUrl","cellSize","fromPacked","spriteJSON","_disableDepthWrite","_packedAndReady","_customUpdate","num","isFinite","floor","_spriteMap","_cellData","frame","h","_fromPacked","_spriteRenderer","_makePacked","callback","_onDisposeObserver","_textureContent","celldata","JSON","parse","frames","frametemp","keys","Error","spritemap","Reflect","ownKeys","re","li","lastIndex","test","jsonUrl","substring","_checkTextureAlpha","textureSize","Uint8Array","readPixels","contactPoint","direction","scaleInPlace","addInPlace","origin","contactPointU","contactPointV","rotatedU","cos","sin","rotatedV","Number","MAX_VALUE","currentSprite","pickedPoint","cameraSpacePosition","cameraView","activeRay","pickedRay","intersectsBoxMinMax","currentDistance","invertToRef","getDeltaTime","getProjectionMatrix","serializeTexture","textureUrl","invertY","_invertY","parsedManager","textureName","ParseFromFileAsync","url","Promise","resolve","reject","request","addEventListener","readyState","status","responseText","output","open","send","CreateFromSnippetAsync","snippetId","snippet","jsonPayload","SnippetUrl","replace","SpriteMap","atlasJSON","spriteSheet","stageSize","outputSize","outputPosition","outputRotation","layerCount","maxAnimationFrames","baseTile","flipU","colorMultiply","_frameMap","_createFrameBuffer","_tileMaps","_createTileBuffer","_animationMap","_createTileAnimationBuffer","layerSampleString","shaderString","supportSwitchCaseInShader","_material","vertex","fragment","needAlphaBlending","spriteCount","setVector2","setVector3","tickSave","bindSpriteTexture","_texture","baseWidth","baseHeight","setTimeout","setTextureArray","_output","updatable","scaling","rotation","_bufferView","am","getTileID","p","getMousePosition","multiplyInPlace","out","pickinfo","getTextureCoordinates","coords","f","sss","ss","t_1","floatArray","_layer","_ty","_tx","bt","changeTiles","pos","tile","_p","addAnimationToTile","cellID","_frame","toCell","time","speed","saveTileMaps","maps","hiddenElement","document","createElement","href","encodeURI","download","click","loadTileMaps","xhr","XMLHttpRequest","_lc","onload","response","split","d","map","forEach","tm","SpritePackedManager","AlphaState","_blendFunctionParameters","_blendEquationParameters","_blendConstants","_isBlendConstantsDirty","_alphaBlend","_isAlphaBlendDirty","_isBlendFunctionParametersDirty","_isBlendEquationParametersDirty","setAlphaBlendConstants","setAlphaBlendFunctionParameters","value0","value1","value2","value3","setAlphaEquationParameters","rgb","apply","gl","isDirty","BLEND","disable","blendFuncSeparate","blendEquationSeparate","blendColor","DepthCullingState","_isDepthTestDirty","_isDepthMaskDirty","_isDepthFuncDirty","_isCullFaceDirty","_isCullDirty","_isZOffsetDirty","_isFrontFaceDirty","_zOffset","_zOffsetUnits","_cullFace","_cull","_depthFunc","_depthMask","_depthTest","_frontFace","CULL_FACE","cullFace","DEPTH_TEST","POLYGON_OFFSET_FILL","polygonOffset","frontFace"],"sourceRoot":""}