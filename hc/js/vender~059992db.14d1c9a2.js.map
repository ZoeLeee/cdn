{"version":3,"file":"js/vender~059992db.14d1c9a2.js","mappings":"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/BoC,EAAKiwC,EAAa7uB,GAAM60B,EAAOp4C,EAC/By5C,EAAKrH,EAAa5uB,GAAM40B,EAAOn4C,EACrCo4C,EAAcC,GAAiBp2C,EAAKC,EAAKs3C,EAAK,aAAsB,EAAI,EA0FtEC,CACElM,EACAjqB,EACAC,EACA40B,EACAx2C,EACAu3C,EAAkBv3C,YAAY3C,OAC9Bq5C,IAIA,OAAQ/8C,IACVm9C,GACElL,EACAjqB,EACAC,EACA40B,EACA78C,EACA49C,EAAkBz9C,QAAQuD,OAC1Bq5C,GACA,IAIA,OAAQ98C,IACVk9C,GACElL,EACAjqB,EACAC,EACA40B,EACA58C,EACA29C,EAAkBx9C,UAAUsD,OAC5Bq5C,GACA,IAIA,OAAQY,IACVP,GACEnL,EACAjqB,EACAC,EACA40B,EACAc,EACAC,EAAkBj6C,GAAGD,OACrBq5C,GAIAe,EAAyB,EAC3B,IAAK,IAAIz+C,EAAI,EAAGA,EAAIy+C,EAAwBz+C,IAAK,CAC/C,MAAMyzC,EAAgB+K,EAAqBx+C,GAC3C++C,GACEnM,EACAjqB,EACAC,EACA40B,EACAE,EACAgB,EAAcjL,GACd8K,EAAkB9K,MAM1B,SAASsL,GACPnM,EACAjqB,EACAC,EACA40B,EACAE,EACAsB,EACAC,GAEA,MAAM76C,EAAyB46C,EAAgB56C,uBACzCozC,EAAewH,EAAgB36C,OAC/Bo5C,EAAgBwB,EAAiB56C,OACvC,OAAQD,GACN,KAAK,EACHy5C,GACEjL,EACAjqB,EACAC,EACA40B,EACAhG,EACAiG,EACAC,GACA,GAEF,MACF,KAAK,EACHI,GACElL,EACAjqB,EACAC,EACA40B,EACAhG,EACAiG,EACAC,GACA,GAEF,MACF,KAAK,EACHK,GACEnL,EACAjqB,EACAC,EACA40B,EACAhG,EACAiG,EACAC,GACA,GAEF,MACF,QACED,EAAcC,GACZlG,EAAa5E,GAAM4K,EAAOr4C,EAC1BqyC,EAAa7uB,GAAM60B,EAAOp4C,EAC1BoyC,EAAa5uB,GAAM40B,EAAOn4C,GAIlC,SAAS65C,GACPX,EACAY,EACAC,EACAv8C,EACAqyC,EACAmJ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Az9C,EACA7C,EACAi8C,GAEFiE,GACEtN,EACAjqB,EACAszB,EACAn8C,EACAu/C,EACAe,EACAp5C,GAGFq4C,EAAcH,GACZkB,EACAC,EACAC,EACAz9C,GACC,EACD89C,GAEFT,GACEtN,EACAjqB,EACAg4B,EACA7gD,EACAu/C,EACAe,EACAp5C,GAGF,WAAkBoyB,EAAQA,GAC1B,QAAesnB,EAActnB,EAAQunB,GACrCtB,EAAcH,GACZqB,EACAC,EACAC,EACA59C,GACC,EACD89C,GAEFT,GACEtN,EACAjqB,EACAg4B,EACA7gD,EACAu/C,EACAkB,EACAv5C,GAGFq4C,EAAcH,GACZqB,EACAC,EACAC,EACA59C,EACA7C,EAAI,EACJ47C,GAEFsE,GACEtN,EACAjqB,EACAizB,EACA97C,EACAu/C,EACAkB,EACAv5C,OAEG,CACL,IAAIu3C,EACAY,EACAC,EAEAnD,EAAG72C,EAAI,GACTm5C,EAAoBtB,EAAa17C,WACjC49C,EAAiBlC,EAAap6C,QAC9Bu8C,EAAkBK,IAElBlB,EAAoBrB,EAAa37C,WACjC49C,EAAiBjC,EAAar6C,QAC9Bu8C,EAAkBM,GAGpBL,EAAcH,GACZX,EACAY,EACAC,EACAv8C,EACA7C,EACAi8C,GAEFiE,GACEtN,EACAjqB,EACAszB,EACAn8C,EACAu/C,EACAd,EACAv3C,GAGFq4C,EAAcH,GACZX,EACAY,EACAC,EACAv8C,EACA7C,EAAI,EACJ47C,GAEFsE,GACEtN,EACAjqB,EACAizB,EACA97C,EACAu/C,EACAd,EACAv3C,IAKNg2C,GAAyBrG,EAAUsG,EAAcC,GAGnD,MAAM0D,GAAqB,IAAI,IACzBC,GAAqB,IAAI,IAEzBC,GAAqB,IAAI,IACzBC,GAAqB,IAAI,IACzBC,GAAqB,IAAI,IACzBC,GAAqB,IAAI,IACzBC,GAAqB,IAAI,IACzBC,GAAqB,IAAI,IAEzBC,GAAqB,IAAI,IAE/B,SAASC,GAA0B92B,GACjC,MAAMhpB,EAAagpB,EAAShpB,WACtBzB,EAAYyB,EAAW2C,SAASG,OAChCi9C,EAAgB//C,EAAWq1C,aAAav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","sources":["webpack:///../../../node_modules/cesium/Source/Core/CornerType.js","webpack:///../../../node_modules/cesium/Source/Core/CorridorGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/CorridorGeometryLibrary.js","webpack:///../../../node_modules/cesium/Source/Core/CorridorOutlineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/Credit.js","webpack:///../../../node_modules/cesium/Source/Core/CubicRealPolynomial.js","webpack:///../../../node_modules/cesium/Source/Core/CullingVolume.js","webpack:///../../../node_modules/cesium/Source/Core/CustomHeightmapTerrainProvider.js","webpack:///../../../node_modules/cesium/Source/Core/CylinderGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/CylinderGeometryLibrary.js","webpack:///../../../node_modules/cesium/Source/Core/CylinderOutlineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/DefaultProxy.js","webpack:///../../../node_modules/cesium/Source/Core/DeveloperError.js","webpack:///../../../node_modules/cesium/Source/Core/DistanceDisplayCondition.js","webpack:///../../../node_modules/cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js","webpack:///../../../node_modules/cesium/Source/Core/DoubleEndedPriorityQueue.js","webpack:///../../../node_modules/cesium/Source/Core/DoublyLinkedList.js","webpack:///../../../node_modules/cesium/Source/Core/EarthOrientationParameters.js","webpack:///../../../node_modules/cesium/Source/Core/EarthOrientationParametersSample.js","webpack:///../../../node_modules/cesium/Source/Core/EasingFunction.js","webpack:///../../../node_modules/cesium/Source/Core/EllipseGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/EllipseGeometryLibrary.js","webpack:///../../../node_modules/cesium/Source/Core/EllipseOutlineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/Ellipsoid.js","webpack:///../../../node_modules/cesium/Source/Core/EllipsoidGeodesic.js","webpack:///../../../node_modules/cesium/Source/Core/EllipsoidGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/EllipsoidOutlineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/EllipsoidRhumbLine.js","webpack:///../../../node_modules/cesium/Source/Core/EllipsoidTangentPlane.js","webpack:///../../../node_modules/cesium/Source/Core/EllipsoidTerrainProvider.js","webpack:///../../../node_modules/cesium/Source/Core/EllipsoidalOccluder.js","webpack:///../../../node_modules/cesium/Source/Core/EncodedCartesian3.js","webpack:///../../../node_modules/cesium/Source/Core/Event.js","webpack:///../../../node_modules/cesium/Source/Core/EventHelper.js","webpack:///../../../node_modules/cesium/Source/Core/ExperimentalFeatures.js","webpack:///../../../node_modules/cesium/Source/Core/ExtrapolationType.js","webpack:///../../../node_modules/cesium/Source/Core/FeatureDetection.js","webpack:///../../../node_modules/cesium/Source/Core/FrustumGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/FrustumOutlineGeometry.js","webpack:///../../../node_modules/cesium/Source/Core/Fullscreen.js","webpack:///../../../node_modules/cesium/Source/Core/GeocodeType.js","webpack:///../../../node_modules/cesium/Source/Core/GeocoderService.js","webpack:///../../../node_modules/cesium/Source/Core/GeographicProjection.js","webpack:///../../../node_modules/cesium/Source/Core/GeographicTilingScheme.js","webpack:///../../../node_modules/cesium/Source/Core/Geometry.js","webpack:///../../../node_modules/cesium/Source/Core/GeometryAttribute.js","webpack:///../../../node_modules/cesium/Source/Core/GeometryAttributes.js","webpack:///../../../node_modules/cesium/Source/Core/GeometryFactory.js","webpack:///../../../node_modules/cesium/Source/Core/GeometryInstance.js","webpack:///../../../node_modules/cesium/Source/Core/GeometryInstanceAttribute.js","webpack:///../../../node_modules/cesium/Source/Core/GeometryOffsetAttribute.js","webpack:///../../../node_modules/cesium/Source/Core/GeometryPipeline.js","webpack:///../../../node_modules/cesium/Source/Core/GeometryType.js"],"sourcesContent":["/**\n * Style options for corners.\n *\n * @demo The {@link https://sandcastle.cesium.com/index.html?src=Corridor.html&label=Geometries|Corridor Demo}\n * demonstrates the three corner types, as used by {@link CorridorGraphics}.\n *\n * @enum {Number}\n */\nconst CornerType = {\n  /**\n   * <img src=\"Images/CornerTypeRounded.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n   *\n   * Corner has a smooth edge.\n   * @type {Number}\n   * @constant\n   */\n  ROUNDED: 0,\n\n  /**\n   * <img src=\"Images/CornerTypeMitered.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n   *\n   * Corner point is the intersection of adjacent edges.\n   * @type {Number}\n   * @constant\n   */\n  MITERED: 1,\n\n  /**\n   * <img src=\"Images/CornerTypeBeveled.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n   *\n   * Corner is clipped.\n   * @type {Number}\n   * @constant\n   */\n  BEVELED: 2,\n};\nexport default Object.freeze(CornerType);\n","import arrayFill from \"./arrayFill.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nconst cartesian4 = new Cartesian3();\nconst cartesian5 = new Cartesian3();\nconst cartesian6 = new Cartesian3();\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (let i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\n\nfunction addNormals(attr, normal, left, front, back, vertexFormat) {\n  const normals = attr.normals;\n  const tangents = attr.tangents;\n  const bitangents = attr.bitangents;\n  const forward = Cartesian3.normalize(\n    Cartesian3.cross(left, normal, scratch1),\n    scratch1\n  );\n  if (vertexFormat.normal) {\n    CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n  }\n  if (vertexFormat.tangent) {\n    CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n  }\n  if (vertexFormat.bitangent) {\n    CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n  }\n}\n\nfunction combine(computedPositions, vertexFormat, ellipsoid) {\n  const positions = computedPositions.positions;\n  const corners = computedPositions.corners;\n  const endPositions = computedPositions.endPositions;\n  const computedLefts = computedPositions.lefts;\n  const computedNormals = computedPositions.normals;\n  const attributes = new GeometryAttributes();\n  let corner;\n  let leftCount = 0;\n  let rightCount = 0;\n  let i;\n  let indicesLength = 0;\n  let length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += length * 2;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    const leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += length;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += length;\n    }\n  }\n\n  const addEndPositions = defined(endPositions);\n  let endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 6;\n  }\n  const size = leftCount + rightCount;\n  const finalPositions = new Float64Array(size);\n  const normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n  const tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size)\n    : undefined;\n  const attr = {\n    normals: normals,\n    tangents: tangents,\n    bitangents: bitangents,\n  };\n  let front = 0;\n  let back = size - 1;\n  let UL, LL, UR, LR;\n  let normal = cartesian1;\n  let left = cartesian2;\n  let rightPos, leftPos;\n  const halfLength = endPositionLength / 2;\n\n  const indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n  let index = 0;\n  if (addEndPositions) {\n    // add rounded end\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    const firstEndPositions = endPositions[0];\n    normal = Cartesian3.fromArray(computedNormals, 0, normal);\n    left = Cartesian3.fromArray(computedLefts, 0, left);\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength - 1 - i) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength + i) * 3,\n        rightPos\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  let posIndex = 0;\n  let compIndex = 0;\n  let rightEdge = positions[posIndex++]; //add first two edges\n  let leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n  left = Cartesian3.fromArray(computedLefts, compIndex, left);\n  let rightNormal;\n  let leftNormal;\n  length = leftEdge.length - 3;\n  for (i = 0; i < length; i += 3) {\n    rightNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(rightEdge, i, scratch1),\n      scratch1\n    );\n    leftNormal = ellipsoid.geodeticSurfaceNormal(\n      Cartesian3.fromArray(leftEdge, length - i, scratch2),\n      scratch2\n    );\n    normal = Cartesian3.normalize(\n      Cartesian3.add(rightNormal, leftNormal, normal),\n      normal\n    );\n    addNormals(attr, normal, left, front, back, vertexFormat);\n\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n\n    front += 3;\n    back -= 3;\n  }\n\n  rightNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(rightEdge, length, scratch1),\n    scratch1\n  );\n  leftNormal = ellipsoid.geodeticSurfaceNormal(\n    Cartesian3.fromArray(leftEdge, length, scratch2),\n    scratch2\n  );\n  normal = Cartesian3.normalize(\n    Cartesian3.add(rightNormal, leftNormal, normal),\n    normal\n  );\n  compIndex += 3;\n  for (i = 0; i < corners.length; i++) {\n    let j;\n    corner = corners[i];\n    const l = corner.leftPositions;\n    const r = corner.rightPositions;\n    let pivot;\n    let start;\n    let outsidePoint = cartesian6;\n    let previousPoint = cartesian3;\n    let nextPoint = cartesian4;\n    normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n    if (defined(l)) {\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n      pivot = LR;\n      start = UR;\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          undefined,\n          back\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start - j - 1) * 3,\n          previousPoint\n        );\n        nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left\n        );\n        addNormals(attr, normal, left, undefined, back, vertexFormat);\n        back -= 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, previousPoint),\n        outsidePoint,\n        previousPoint\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint),\n        outsidePoint,\n        nextPoint\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.add(previousPoint, nextPoint, left),\n        left\n      );\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n    } else {\n      addNormals(attr, normal, left, front, undefined, vertexFormat);\n      front += 3;\n      pivot = UR;\n      start = LR;\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = pivot;\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          front\n        );\n        previousPoint = Cartesian3.fromArray(\n          finalPositions,\n          pivot * 3,\n          previousPoint\n        );\n        nextPoint = Cartesian3.fromArray(\n          finalPositions,\n          (start + j) * 3,\n          nextPoint\n        );\n        left = Cartesian3.normalize(\n          Cartesian3.subtract(previousPoint, nextPoint, left),\n          left\n        );\n        addNormals(attr, normal, left, front, undefined, vertexFormat);\n        front += 3;\n      }\n      outsidePoint = Cartesian3.fromArray(\n        finalPositions,\n        pivot * 3,\n        outsidePoint\n      );\n      previousPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint),\n        outsidePoint,\n        previousPoint\n      );\n      nextPoint = Cartesian3.subtract(\n        Cartesian3.fromArray(finalPositions, start * 3, nextPoint),\n        outsidePoint,\n        nextPoint\n      );\n      left = Cartesian3.normalize(\n        Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left),\n        left\n      );\n      addNormals(attr, normal, left, undefined, back, vertexFormat);\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    compIndex += 3;\n    left = Cartesian3.fromArray(computedLefts, compIndex, left);\n    for (j = 0; j < leftEdge.length; j += 3) {\n      rightNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(rightEdge, j, scratch1),\n        scratch1\n      );\n      leftNormal = ellipsoid.geodeticSurfaceNormal(\n        Cartesian3.fromArray(leftEdge, length - j, scratch2),\n        scratch2\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.add(rightNormal, leftNormal, normal),\n        normal\n      );\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n  }\n  normal = Cartesian3.fromArray(\n    computedNormals,\n    computedNormals.length - 3,\n    normal\n  );\n  addNormals(attr, normal, left, front, back, vertexFormat);\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian3;\n    rightPos = cartesian4;\n    const lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        lastEndPositions,\n        (endPositionLength - i - 1) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      addNormals(attr, normal, left, front, back, vertexFormat);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = LL;\n      indices[index++] = UR;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  if (vertexFormat.st) {\n    const st = new Float32Array((size / 3) * 2);\n    let rightSt;\n    let leftSt;\n    let stIndex = 0;\n    if (addEndPositions) {\n      leftCount /= 3;\n      rightCount /= 3;\n      const theta = Math.PI / (endPositionLength + 1);\n      leftSt = 1 / (leftCount - endPositionLength + 1);\n      rightSt = 1 / (rightCount - endPositionLength + 1);\n      let a;\n      const halfEndPos = endPositionLength / 2;\n      for (i = halfEndPos + 1; i < endPositionLength + 1; i++) {\n        // lower left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = 1; i < rightCount - endPositionLength + 1; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = endPositionLength; i > halfEndPos; i--) {\n        // lower right rounded end\n        a = CesiumMath.PI_OVER_TWO - i * theta;\n        st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = halfEndPos; i > 0; i--) {\n        // upper right rounded end\n        a = CesiumMath.PI_OVER_TWO - theta * i;\n        st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n      for (i = leftCount - endPositionLength; i > 0; i--) {\n        // top edge\n        st[stIndex++] = i * leftSt;\n        st[stIndex++] = 1;\n      }\n      for (i = 1; i < halfEndPos + 1; i++) {\n        // upper left rounded end\n        a = CesiumMath.PI_OVER_TWO + theta * i;\n        st[stIndex++] = leftSt * (1 + Math.cos(a));\n        st[stIndex++] = 0.5 * (1 + Math.sin(a));\n      }\n    } else {\n      leftCount /= 3;\n      rightCount /= 3;\n      leftSt = 1 / (leftCount - 1);\n      rightSt = 1 / (rightCount - 1);\n      for (i = 0; i < rightCount; i++) {\n        // bottom edge\n        st[stIndex++] = i * rightSt;\n        st[stIndex++] = 0;\n      }\n      for (i = leftCount; i > 0; i--) {\n        // top edge\n        st[stIndex++] = (i - 1) * leftSt;\n        st[stIndex++] = 1;\n      }\n    }\n\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: attr.bitangents,\n    });\n  }\n\n  return {\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction extrudedAttributes(attributes, vertexFormat) {\n  if (\n    !vertexFormat.normal &&\n    !vertexFormat.tangent &&\n    !vertexFormat.bitangent &&\n    !vertexFormat.st\n  ) {\n    return attributes;\n  }\n  const positions = attributes.position.values;\n  let topNormals;\n  let topBitangents;\n  if (vertexFormat.normal || vertexFormat.bitangent) {\n    topNormals = attributes.normal.values;\n    topBitangents = attributes.bitangent.values;\n  }\n  const size = attributes.position.values.length / 18;\n  const threeSize = size * 3;\n  const twoSize = size * 2;\n  const sixSize = threeSize * 2;\n  let i;\n  if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n    const normals = vertexFormat.normal\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    const tangents = vertexFormat.tangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    const bitangents = vertexFormat.bitangent\n      ? new Float32Array(threeSize * 6)\n      : undefined;\n    let topPosition = cartesian1;\n    let bottomPosition = cartesian2;\n    let previousPosition = cartesian3;\n    let normal = cartesian4;\n    let tangent = cartesian5;\n    let bitangent = cartesian6;\n    let attrIndex = sixSize;\n    for (i = 0; i < threeSize; i += 3) {\n      const attrIndexOffset = attrIndex + sixSize;\n      topPosition = Cartesian3.fromArray(positions, i, topPosition);\n      bottomPosition = Cartesian3.fromArray(\n        positions,\n        i + threeSize,\n        bottomPosition\n      );\n      previousPosition = Cartesian3.fromArray(\n        positions,\n        (i + 3) % threeSize,\n        previousPosition\n      );\n      bottomPosition = Cartesian3.subtract(\n        bottomPosition,\n        topPosition,\n        bottomPosition\n      );\n      previousPosition = Cartesian3.subtract(\n        previousPosition,\n        topPosition,\n        previousPosition\n      );\n      normal = Cartesian3.normalize(\n        Cartesian3.cross(bottomPosition, previousPosition, normal),\n        normal\n      );\n      if (vertexFormat.normal) {\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n        CorridorGeometryLibrary.addAttribute(\n          normals,\n          normal,\n          attrIndexOffset + 3\n        );\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n        CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n      }\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n        if (vertexFormat.bitangent) {\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndexOffset + 3\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex\n          );\n          CorridorGeometryLibrary.addAttribute(\n            bitangents,\n            bitangent,\n            attrIndex + 3\n          );\n        }\n\n        if (vertexFormat.tangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(bitangent, normal, tangent),\n            tangent\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset\n          );\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndexOffset + 3\n          );\n          CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n          CorridorGeometryLibrary.addAttribute(\n            tangents,\n            tangent,\n            attrIndex + 3\n          );\n        }\n      }\n      attrIndex += 6;\n    }\n\n    if (vertexFormat.normal) {\n      normals.set(topNormals); //top\n      for (i = 0; i < threeSize; i += 3) {\n        //bottom normals\n        normals[i + threeSize] = -topNormals[i];\n        normals[i + threeSize + 1] = -topNormals[i + 1];\n        normals[i + threeSize + 2] = -topNormals[i + 2];\n      }\n      attributes.normal.values = normals;\n    } else {\n      attributes.normal = undefined;\n    }\n\n    if (vertexFormat.bitangent) {\n      bitangents.set(topBitangents); //top\n      bitangents.set(topBitangents, threeSize); //bottom\n      attributes.bitangent.values = bitangents;\n    } else {\n      attributes.bitangent = undefined;\n    }\n\n    if (vertexFormat.tangent) {\n      const topTangents = attributes.tangent.values;\n      tangents.set(topTangents); //top\n      tangents.set(topTangents, threeSize); //bottom\n      attributes.tangent.values = tangents;\n    }\n  }\n  if (vertexFormat.st) {\n    const topSt = attributes.st.values;\n    const st = new Float32Array(twoSize * 6);\n    st.set(topSt); //top\n    st.set(topSt, twoSize); //bottom\n    let index = twoSize * 2;\n\n    for (let j = 0; j < 2; j++) {\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n      for (i = 2; i < twoSize; i += 2) {\n        const s = topSt[i];\n        const t = topSt[i + 1];\n        st[index++] = s;\n        st[index++] = t;\n        st[index++] = s;\n        st[index++] = t;\n      }\n      st[index++] = topSt[0];\n      st[index++] = topSt[1];\n    }\n    attributes.st.values = st;\n  }\n\n  return attributes;\n}\n\nfunction addWallPositions(positions, index, wallPositions) {\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n  for (let i = 3; i < positions.length; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n    wallPositions[index++] = x;\n    wallPositions[index++] = y;\n    wallPositions[index++] = z;\n  }\n  wallPositions[index++] = positions[0];\n  wallPositions[index++] = positions[1];\n  wallPositions[index++] = positions[2];\n\n  return wallPositions;\n}\n\nfunction computePositionsExtruded(params, vertexFormat) {\n  const topVertexFormat = new VertexFormat({\n    position: vertexFormat.position,\n    normal:\n      vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume,\n    tangent: vertexFormat.tangent,\n    bitangent: vertexFormat.normal || vertexFormat.bitangent,\n    st: vertexFormat.st,\n  });\n  const ellipsoid = params.ellipsoid;\n  const computedPositions = CorridorGeometryLibrary.computePositions(params);\n  const attr = combine(computedPositions, topVertexFormat, ellipsoid);\n  const height = params.height;\n  const extrudedHeight = params.extrudedHeight;\n  let attributes = attr.attributes;\n  const indices = attr.indices;\n  let positions = attributes.position.values;\n  let length = positions.length;\n  const newPositions = new Float64Array(length * 6);\n  let extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  let wallPositions = new Float64Array(length * 4);\n\n  positions = PolygonPipeline.scaleToGeodeticHeight(\n    positions,\n    height,\n    ellipsoid\n  );\n  wallPositions = addWallPositions(positions, 0, wallPositions);\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\n    extrudedPositions,\n    extrudedHeight,\n    ellipsoid\n  );\n  wallPositions = addWallPositions(\n    extrudedPositions,\n    length * 2,\n    wallPositions\n  );\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  newPositions.set(wallPositions, length * 2);\n  attributes.position.values = newPositions;\n\n  attributes = extrudedAttributes(attributes, vertexFormat);\n  let i;\n  const size = length / 3;\n  if (params.shadowVolume) {\n    const topNormals = attributes.normal.values;\n    length = topNormals.length;\n\n    let extrudeNormals = new Float32Array(length * 6);\n    for (i = 0; i < length; i++) {\n      topNormals[i] = -topNormals[i];\n    }\n    //only get normals for bottom layer that's going to be pushed down\n    extrudeNormals.set(topNormals, length); //bottom face\n    extrudeNormals = addWallPositions(topNormals, length * 4, extrudeNormals); //bottom wall\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n    if (!vertexFormat.normal) {\n      attributes.normal = undefined;\n    }\n  }\n  if (defined(params.offsetAttribute)) {\n    let applyOffset = new Uint8Array(size * 6);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\n      applyOffset = arrayFill(applyOffset, 1, size * 2, size * 4); // top wall\n    } else {\n      const applyOffsetValue =\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, applyOffsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  const iLength = indices.length;\n  const twoSize = size + size;\n  const newIndices = IndexDatatype.createTypedArray(\n    newPositions.length / 3,\n    iLength * 2 + twoSize * 3\n  );\n  newIndices.set(indices);\n  let index = iLength;\n  for (i = 0; i < iLength; i += 3) {\n    // bottom indices\n    const v0 = indices[i];\n    const v1 = indices[i + 1];\n    const v2 = indices[i + 2];\n    newIndices[index++] = v2 + size;\n    newIndices[index++] = v1 + size;\n    newIndices[index++] = v0 + size;\n  }\n\n  let UL, LL, UR, LR;\n\n  for (i = 0; i < twoSize; i += 2) {\n    //wall indices\n    UL = i + twoSize;\n    LL = UL + twoSize;\n    UR = UL + 1;\n    LR = LL + 1;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n    newIndices[index++] = UR;\n    newIndices[index++] = UR;\n    newIndices[index++] = LL;\n    newIndices[index++] = LR;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices,\n  };\n}\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n\nfunction computeOffsetPoints(\n  position1,\n  position2,\n  ellipsoid,\n  halfWidth,\n  min,\n  max\n) {\n  // Compute direction of offset the point\n  const direction = Cartesian3.subtract(\n    position2,\n    position1,\n    scratchCartesian1\n  );\n  Cartesian3.normalize(direction, direction);\n  const normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n  const offsetDirection = Cartesian3.cross(\n    direction,\n    normal,\n    scratchCartesian1\n  );\n  Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n\n  let minLat = min.latitude;\n  let minLon = min.longitude;\n  let maxLat = max.latitude;\n  let maxLon = max.longitude;\n\n  // Compute 2 offset points\n  Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  let lat = scratchCartographic.latitude;\n  let lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n  ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n  lat = scratchCartographic.latitude;\n  lon = scratchCartographic.longitude;\n  minLat = Math.min(minLat, lat);\n  minLon = Math.min(minLon, lon);\n  maxLat = Math.max(maxLat, lat);\n  maxLon = Math.max(maxLon, lon);\n\n  min.latitude = minLat;\n  min.longitude = minLon;\n  max.latitude = maxLat;\n  max.longitude = maxLon;\n}\n\nconst scratchCartesianOffset = new Cartesian3();\nconst scratchCartesianEnds = new Cartesian3();\nconst scratchCartographicMin = new Cartographic();\nconst scratchCartographicMax = new Cartographic();\n\nfunction computeRectangle(positions, ellipsoid, width, cornerType, result) {\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n  const length = cleanPositions.length;\n  if (length < 2 || width <= 0) {\n    return new Rectangle();\n  }\n  const halfWidth = width * 0.5;\n\n  scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n  scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n  scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n\n  let lat, lon;\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute start cap\n    const first = cleanPositions[0];\n    Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n    Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n    Cartesian3.multiplyByScalar(\n      scratchCartesianOffset,\n      halfWidth,\n      scratchCartesianOffset\n    );\n    Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon\n    );\n  }\n\n  // Compute the rest\n  for (let i = 0; i < length - 1; ++i) {\n    computeOffsetPoints(\n      cleanPositions[i],\n      cleanPositions[i + 1],\n      ellipsoid,\n      halfWidth,\n      scratchCartographicMin,\n      scratchCartographicMax\n    );\n  }\n\n  // Compute ending point\n  const last = cleanPositions[length - 1];\n  Cartesian3.subtract(last, cleanPositions[length - 2], scratchCartesianOffset);\n  Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n  Cartesian3.multiplyByScalar(\n    scratchCartesianOffset,\n    halfWidth,\n    scratchCartesianOffset\n  );\n  Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n  computeOffsetPoints(\n    last,\n    scratchCartesianEnds,\n    ellipsoid,\n    halfWidth,\n    scratchCartographicMin,\n    scratchCartographicMax\n  );\n\n  if (cornerType === CornerType.ROUNDED) {\n    // Compute end cap\n    ellipsoid.cartesianToCartographic(\n      scratchCartesianEnds,\n      scratchCartographic\n    );\n    lat = scratchCartographic.latitude;\n    lon = scratchCartographic.longitude;\n    scratchCartographicMin.latitude = Math.min(\n      scratchCartographicMin.latitude,\n      lat\n    );\n    scratchCartographicMin.longitude = Math.min(\n      scratchCartographicMin.longitude,\n      lon\n    );\n    scratchCartographicMax.latitude = Math.max(\n      scratchCartographicMax.latitude,\n      lat\n    );\n    scratchCartographicMax.longitude = Math.max(\n      scratchCartographicMax.longitude,\n      lon\n    );\n  }\n\n  const rectangle = defined(result) ? result : new Rectangle();\n  rectangle.north = scratchCartographicMax.latitude;\n  rectangle.south = scratchCartographicMin.latitude;\n  rectangle.east = scratchCartographicMax.longitude;\n  rectangle.west = scratchCartographicMin.longitude;\n\n  return rectangle;\n}\n\n/**\n * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias CorridorGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {Number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorGeometry.createGeometry\n * @see Packable\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n *\n * @example\n * const corridor = new Cesium.CorridorGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._vertexFormat = VertexFormat.clone(\n    defaultValue(options.vertexFormat, VertexFormat.DEFAULT)\n  );\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createCorridorGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n  this._rectangle = undefined;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    1 +\n    positions.length * Cartesian3.packedLength +\n    Ellipsoid.packedLength +\n    VertexFormat.packedLength +\n    7;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCorridorGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const positions = value._positions;\n  const length = positions.length;\n  array[startingIndex++] = length;\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorGeometry} [result] The object into which to store the result.\n * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n */\nCorridorGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const width = array[startingIndex++];\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new CorridorGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle given the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n * @param {Number} options.width The distance between the edges of the corridor in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n * @param {Rectangle} [result] An object in which to store the result.\n *\n * @returns {Rectangle} The result rectangle.\n */\nCorridorGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.positions\", positions);\n  Check.defined(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  const cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n\n  return computeRectangle(positions, ellipsoid, width, cornerType, result);\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorGeometry.createGeometry = function (corridorGeometry) {\n  let positions = corridorGeometry._positions;\n  const width = corridorGeometry._width;\n  const ellipsoid = corridorGeometry._ellipsoid;\n\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  const height = corridorGeometry._height;\n  const extrudedHeight = corridorGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  const vertexFormat = corridorGeometry._vertexFormat;\n  const params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorGeometry._cornerType,\n    granularity: corridorGeometry._granularity,\n    saveAttributes: true,\n  };\n  let attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.shadowVolume = corridorGeometry._shadowVolume;\n    params.offsetAttribute = corridorGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params, vertexFormat);\n  } else {\n    const computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, vertexFormat, ellipsoid);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      attr.attributes.position.values,\n      height,\n      ellipsoid\n    );\n\n    if (defined(corridorGeometry._offsetAttribute)) {\n      const applyOffsetValue =\n        corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      const length = attr.attributes.position.values.length;\n      const applyOffset = new Uint8Array(length / 3);\n      arrayFill(applyOffset, applyOffsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n  const attributes = attr.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n    undefined,\n    3\n  );\n  if (!vertexFormat.position) {\n    attr.attributes.position.values = undefined;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nCorridorGeometry.createShadowVolume = function (\n  corridorGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  const granularity = corridorGeometry._granularity;\n  const ellipsoid = corridorGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new CorridorGeometry({\n    positions: corridorGeometry._positions,\n    width: corridorGeometry._width,\n    cornerType: corridorGeometry._cornerType,\n    ellipsoid: ellipsoid,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nObject.defineProperties(CorridorGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._positions,\n          this._ellipsoid,\n          this._width,\n          this._cornerType\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n   *\n   * Corridors don't support stRotation,\n   * so just return the corners of the original system.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      return [0, 0, 0, 1, 1, 0];\n    },\n  },\n});\nexport default CorridorGeometry;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport CornerType from \"./CornerType.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\nimport PolylineVolumeGeometryLibrary from \"./PolylineVolumeGeometryLibrary.js\";\nimport Quaternion from \"./Quaternion.js\";\n\n/**\n * @private\n */\nconst CorridorGeometryLibrary = {};\n\nconst scratch1 = new Cartesian3();\nconst scratch2 = new Cartesian3();\nconst scratch3 = new Cartesian3();\nconst scratch4 = new Cartesian3();\n\nconst scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\nconst cartesian4 = new Cartesian3();\nconst cartesian5 = new Cartesian3();\nconst cartesian6 = new Cartesian3();\nconst cartesian7 = new Cartesian3();\nconst cartesian8 = new Cartesian3();\nconst cartesian9 = new Cartesian3();\nconst cartesian10 = new Cartesian3();\n\nconst quaterion = new Quaternion();\nconst rotMatrix = new Matrix3();\nfunction computeRoundCorner(\n  cornerPoint,\n  startPoint,\n  endPoint,\n  cornerType,\n  leftIsOutside\n) {\n  const angle = Cartesian3.angleBetween(\n    Cartesian3.subtract(startPoint, cornerPoint, scratch1),\n    Cartesian3.subtract(endPoint, cornerPoint, scratch2)\n  );\n  const granularity =\n    cornerType === CornerType.BEVELED\n      ? 1\n      : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n  const size = granularity * 3;\n  const array = new Array(size);\n\n  array[size - 3] = endPoint.x;\n  array[size - 2] = endPoint.y;\n  array[size - 1] = endPoint.z;\n\n  let m;\n  if (leftIsOutside) {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(\n        Cartesian3.negate(cornerPoint, scratch1),\n        angle / granularity,\n        quaterion\n      ),\n      rotMatrix\n    );\n  } else {\n    m = Matrix3.fromQuaternion(\n      Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion),\n      rotMatrix\n    );\n  }\n\n  let index = 0;\n  startPoint = Cartesian3.clone(startPoint, scratch1);\n  for (let i = 0; i < granularity; i++) {\n    startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n    array[index++] = startPoint.x;\n    array[index++] = startPoint.y;\n    array[index++] = startPoint.z;\n  }\n\n  return array;\n}\n\nfunction addEndCaps(calculatedPositions) {\n  let cornerPoint = cartesian1;\n  let startPoint = cartesian2;\n  let endPoint = cartesian3;\n\n  let leftEdge = calculatedPositions[1];\n  startPoint = Cartesian3.fromArray(\n    calculatedPositions[1],\n    leftEdge.length - 3,\n    startPoint\n  );\n  endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const firstEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false\n  );\n\n  const length = calculatedPositions.length - 1;\n  const rightEdge = calculatedPositions[length - 1];\n  leftEdge = calculatedPositions[length];\n  startPoint = Cartesian3.fromArray(\n    rightEdge,\n    rightEdge.length - 3,\n    startPoint\n  );\n  endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n  cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n  const lastEndCap = computeRoundCorner(\n    cornerPoint,\n    startPoint,\n    endPoint,\n    CornerType.ROUNDED,\n    false\n  );\n\n  return [firstEndCap, lastEndCap];\n}\n\nfunction computeMiteredCorner(\n  position,\n  leftCornerDirection,\n  lastPoint,\n  leftIsOutside\n) {\n  let cornerPoint = scratch1;\n  if (leftIsOutside) {\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  } else {\n    leftCornerDirection = Cartesian3.negate(\n      leftCornerDirection,\n      leftCornerDirection\n    );\n    cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n  }\n  return [\n    cornerPoint.x,\n    cornerPoint.y,\n    cornerPoint.z,\n    lastPoint.x,\n    lastPoint.y,\n    lastPoint.z,\n  ];\n}\n\nfunction addShiftedPositions(positions, left, scalar, calculatedPositions) {\n  const rightPositions = new Array(positions.length);\n  const leftPositions = new Array(positions.length);\n  const scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n  const scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n  let rightIndex = 0;\n  let leftIndex = positions.length - 1;\n\n  for (let i = 0; i < positions.length; i += 3) {\n    const pos = Cartesian3.fromArray(positions, i, scratch3);\n    const rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n    rightPositions[rightIndex++] = rightPos.x;\n    rightPositions[rightIndex++] = rightPos.y;\n    rightPositions[rightIndex++] = rightPos.z;\n\n    const leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n    leftPositions[leftIndex--] = leftPos.z;\n    leftPositions[leftIndex--] = leftPos.y;\n    leftPositions[leftIndex--] = leftPos.x;\n  }\n  calculatedPositions.push(rightPositions, leftPositions);\n\n  return calculatedPositions;\n}\n\n/**\n * @private\n */\nCorridorGeometryLibrary.addAttribute = function (\n  attribute,\n  value,\n  front,\n  back\n) {\n  const x = value.x;\n  const y = value.y;\n  const z = value.z;\n  if (defined(front)) {\n    attribute[front] = x;\n    attribute[front + 1] = y;\n    attribute[front + 2] = z;\n  }\n  if (defined(back)) {\n    attribute[back] = z;\n    attribute[back - 1] = y;\n    attribute[back - 2] = x;\n  }\n};\n\nconst scratchForwardProjection = new Cartesian3();\nconst scratchBackwardProjection = new Cartesian3();\n\n/**\n * @private\n */\nCorridorGeometryLibrary.computePositions = function (params) {\n  const granularity = params.granularity;\n  const positions = params.positions;\n  const ellipsoid = params.ellipsoid;\n  const width = params.width / 2;\n  const cornerType = params.cornerType;\n  const saveAttributes = params.saveAttributes;\n  let normal = cartesian1;\n  let forward = cartesian2;\n  let backward = cartesian3;\n  let left = cartesian4;\n  let cornerDirection = cartesian5;\n  let startPoint = cartesian6;\n  let previousPos = cartesian7;\n  let rightPos = cartesian8;\n  let leftPos = cartesian9;\n  let center = cartesian10;\n  let calculatedPositions = [];\n  const calculatedLefts = saveAttributes ? [] : undefined;\n  const calculatedNormals = saveAttributes ? [] : undefined;\n  let position = positions[0]; //add first point\n  let nextPosition = positions[1];\n\n  forward = Cartesian3.normalize(\n    Cartesian3.subtract(nextPosition, position, forward),\n    forward\n  );\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n  previousPos = Cartesian3.clone(position, previousPos);\n  position = nextPosition;\n  backward = Cartesian3.negate(forward, backward);\n\n  let subdividedPositions;\n  const corners = [];\n  let i;\n  const length = positions.length;\n  for (i = 1; i < length - 1; i++) {\n    // add middle points and corners\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n    nextPosition = positions[i + 1];\n    forward = Cartesian3.normalize(\n      Cartesian3.subtract(nextPosition, position, forward),\n      forward\n    );\n    cornerDirection = Cartesian3.normalize(\n      Cartesian3.add(forward, backward, cornerDirection),\n      cornerDirection\n    );\n\n    const forwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(forward, normal),\n      scratchForwardProjection\n    );\n    Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n    Cartesian3.normalize(forwardProjection, forwardProjection);\n\n    const backwardProjection = Cartesian3.multiplyByScalar(\n      normal,\n      Cartesian3.dot(backward, normal),\n      scratchBackwardProjection\n    );\n    Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n    Cartesian3.normalize(backwardProjection, backwardProjection);\n\n    const doCorner = !CesiumMath.equalsEpsilon(\n      Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)),\n      1.0,\n      CesiumMath.EPSILON7\n    );\n\n    if (doCorner) {\n      cornerDirection = Cartesian3.cross(\n        cornerDirection,\n        normal,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.cross(\n        normal,\n        cornerDirection,\n        cornerDirection\n      );\n      cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n      const scalar =\n        width /\n        Math.max(\n          0.25,\n          Cartesian3.magnitude(\n            Cartesian3.cross(cornerDirection, backward, scratch1)\n          )\n        );\n      const leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(\n        forward,\n        backward,\n        position,\n        ellipsoid\n      );\n      cornerDirection = Cartesian3.multiplyByScalar(\n        cornerDirection,\n        scalar,\n        cornerDirection\n      );\n      if (leftIsOutside) {\n        rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n        center = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, center),\n          center\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(leftPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left\n        );\n        leftPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width * 2, leftPos),\n          leftPos\n        );\n        previousPos = Cartesian3.add(\n          rightPos,\n          Cartesian3.multiplyByScalar(left, width, previousPos),\n          previousPos\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            leftPositions: computeRoundCorner(\n              rightPos,\n              startPoint,\n              leftPos,\n              cornerType,\n              leftIsOutside\n            ),\n          });\n        } else {\n          corners.push({\n            leftPositions: computeMiteredCorner(\n              position,\n              Cartesian3.negate(cornerDirection, cornerDirection),\n              leftPos,\n              leftIsOutside\n            ),\n          });\n        }\n      } else {\n        leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n        center = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, center),\n            center\n          ),\n          center\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos\n          ),\n          rightPos\n        );\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n          positions: scaleArray2,\n          granularity: granularity,\n          ellipsoid: ellipsoid,\n        });\n        calculatedPositions = addShiftedPositions(\n          subdividedPositions,\n          left,\n          width,\n          calculatedPositions\n        );\n        if (saveAttributes) {\n          calculatedLefts.push(left.x, left.y, left.z);\n          calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        startPoint = Cartesian3.clone(rightPos, startPoint);\n        left = Cartesian3.normalize(\n          Cartesian3.cross(normal, forward, left),\n          left\n        );\n        rightPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width * 2, rightPos),\n            rightPos\n          ),\n          rightPos\n        );\n        previousPos = Cartesian3.add(\n          leftPos,\n          Cartesian3.negate(\n            Cartesian3.multiplyByScalar(left, width, previousPos),\n            previousPos\n          ),\n          previousPos\n        );\n        if (\n          cornerType === CornerType.ROUNDED ||\n          cornerType === CornerType.BEVELED\n        ) {\n          corners.push({\n            rightPositions: computeRoundCorner(\n              leftPos,\n              startPoint,\n              rightPos,\n              cornerType,\n              leftIsOutside\n            ),\n          });\n        } else {\n          corners.push({\n            rightPositions: computeMiteredCorner(\n              position,\n              cornerDirection,\n              rightPos,\n              leftIsOutside\n            ),\n          });\n        }\n      }\n      backward = Cartesian3.negate(forward, backward);\n    }\n    position = nextPosition;\n  }\n\n  normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n  scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n  scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n  subdividedPositions = PolylinePipeline.generateArc({\n    positions: scaleArray2,\n    granularity: granularity,\n    ellipsoid: ellipsoid,\n  });\n  calculatedPositions = addShiftedPositions(\n    subdividedPositions,\n    left,\n    width,\n    calculatedPositions\n  );\n  if (saveAttributes) {\n    calculatedLefts.push(left.x, left.y, left.z);\n    calculatedNormals.push(normal.x, normal.y, normal.z);\n  }\n\n  let endPositions;\n  if (cornerType === CornerType.ROUNDED) {\n    endPositions = addEndCaps(calculatedPositions);\n  }\n\n  return {\n    positions: calculatedPositions,\n    corners: corners,\n    lefts: calculatedLefts,\n    normals: calculatedNormals,\n    endPositions: endPositions,\n  };\n};\nexport default CorridorGeometryLibrary;\n","import arrayFill from \"./arrayFill.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CornerType from \"./CornerType.js\";\nimport CorridorGeometryLibrary from \"./CorridorGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst cartesian1 = new Cartesian3();\nconst cartesian2 = new Cartesian3();\nconst cartesian3 = new Cartesian3();\n\nfunction scaleToSurface(positions, ellipsoid) {\n  for (let i = 0; i < positions.length; i++) {\n    positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n  }\n  return positions;\n}\n\nfunction combine(computedPositions, cornerType) {\n  const wallIndices = [];\n  const positions = computedPositions.positions;\n  const corners = computedPositions.corners;\n  const endPositions = computedPositions.endPositions;\n  const attributes = new GeometryAttributes();\n  let corner;\n  let leftCount = 0;\n  let rightCount = 0;\n  let i;\n  let indicesLength = 0;\n  let length;\n  for (i = 0; i < positions.length; i += 2) {\n    length = positions[i].length - 3;\n    leftCount += length; //subtracting 3 to account for duplicate points at corners\n    indicesLength += (length / 3) * 4;\n    rightCount += positions[i + 1].length - 3;\n  }\n  leftCount += 3; //add back count for end positions\n  rightCount += 3;\n  for (i = 0; i < corners.length; i++) {\n    corner = corners[i];\n    const leftSide = corners[i].leftPositions;\n    if (defined(leftSide)) {\n      length = leftSide.length;\n      leftCount += length;\n      indicesLength += (length / 3) * 2;\n    } else {\n      length = corners[i].rightPositions.length;\n      rightCount += length;\n      indicesLength += (length / 3) * 2;\n    }\n  }\n\n  const addEndPositions = defined(endPositions);\n  let endPositionLength;\n  if (addEndPositions) {\n    endPositionLength = endPositions[0].length - 3;\n    leftCount += endPositionLength;\n    rightCount += endPositionLength;\n    endPositionLength /= 3;\n    indicesLength += endPositionLength * 4;\n  }\n  const size = leftCount + rightCount;\n  const finalPositions = new Float64Array(size);\n  let front = 0;\n  let back = size - 1;\n  let UL, LL, UR, LR;\n  let rightPos, leftPos;\n  const halfLength = endPositionLength / 2;\n\n  const indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n  let index = 0;\n\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n  if (addEndPositions) {\n    // add rounded end\n    wallIndices.push(front / 3);\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    const firstEndPositions = endPositions[0];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength - 1 - i) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(\n        firstEndPositions,\n        (halfLength + i) * 3,\n        rightPos\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n\n      LL = front / 3;\n      LR = LL + 1;\n      UL = (back - 2) / 3;\n      UR = UL - 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n  }\n\n  let posIndex = 0;\n  let rightEdge = positions[posIndex++]; //add first two edges\n  let leftEdge = positions[posIndex++];\n  finalPositions.set(rightEdge, front);\n  finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n  length = leftEdge.length - 3;\n  wallIndices.push(front / 3, (back - 2) / 3);\n  for (i = 0; i < length; i += 3) {\n    LL = front / 3;\n    LR = LL + 1;\n    UL = (back - 2) / 3;\n    UR = UL - 1;\n    indices[index++] = UL;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n\n    front += 3;\n    back -= 3;\n  }\n\n  for (i = 0; i < corners.length; i++) {\n    let j;\n    corner = corners[i];\n    const l = corner.leftPositions;\n    const r = corner.rightPositions;\n    let start;\n    let outsidePoint = cartesian3;\n    if (defined(l)) {\n      back -= 3;\n      start = UR;\n      wallIndices.push(LR);\n      for (j = 0; j < l.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n        indices[index++] = start - j - 1;\n        indices[index++] = start - j;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          undefined,\n          back\n        );\n        back -= 3;\n      }\n      wallIndices.push(start - Math.floor(l.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push((back - 2) / 3 + 1);\n      }\n      front += 3;\n    } else {\n      front += 3;\n      start = LR;\n      wallIndices.push(UR);\n      for (j = 0; j < r.length / 3; j++) {\n        outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n        indices[index++] = start + j;\n        indices[index++] = start + j + 1;\n        CorridorGeometryLibrary.addAttribute(\n          finalPositions,\n          outsidePoint,\n          front\n        );\n        front += 3;\n      }\n      wallIndices.push(start + Math.floor(r.length / 6));\n      if (cornerType === CornerType.BEVELED) {\n        wallIndices.push(front / 3 - 1);\n      }\n      back -= 3;\n    }\n    rightEdge = positions[posIndex++];\n    leftEdge = positions[posIndex++];\n    rightEdge.splice(0, 3); //remove duplicate points added by corner\n    leftEdge.splice(leftEdge.length - 3, 3);\n    finalPositions.set(rightEdge, front);\n    finalPositions.set(leftEdge, back - leftEdge.length + 1);\n    length = leftEdge.length - 3;\n\n    for (j = 0; j < leftEdge.length; j += 3) {\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n      front += 3;\n      back -= 3;\n    }\n    front -= 3;\n    back += 3;\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n\n  if (addEndPositions) {\n    // add rounded end\n    front += 3;\n    back -= 3;\n    leftPos = cartesian1;\n    rightPos = cartesian2;\n    const lastEndPositions = endPositions[1];\n    for (i = 0; i < halfLength; i++) {\n      leftPos = Cartesian3.fromArray(\n        lastEndPositions,\n        (endPositionLength - i - 1) * 3,\n        leftPos\n      );\n      rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n      CorridorGeometryLibrary.addAttribute(\n        finalPositions,\n        leftPos,\n        undefined,\n        back\n      );\n      CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n\n      LR = front / 3;\n      LL = LR - 1;\n      UR = (back - 2) / 3;\n      UL = UR + 1;\n      indices[index++] = UL;\n      indices[index++] = UR;\n      indices[index++] = LL;\n      indices[index++] = LR;\n\n      front += 3;\n      back -= 3;\n    }\n\n    wallIndices.push(front / 3);\n  } else {\n    wallIndices.push(front / 3, (back - 2) / 3);\n  }\n  indices[index++] = front / 3;\n  indices[index++] = (back - 2) / 3;\n\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: finalPositions,\n  });\n\n  return {\n    attributes: attributes,\n    indices: indices,\n    wallIndices: wallIndices,\n  };\n}\n\nfunction computePositionsExtruded(params) {\n  const ellipsoid = params.ellipsoid;\n  const computedPositions = CorridorGeometryLibrary.computePositions(params);\n  const attr = combine(computedPositions, params.cornerType);\n  const wallIndices = attr.wallIndices;\n  const height = params.height;\n  const extrudedHeight = params.extrudedHeight;\n  const attributes = attr.attributes;\n  const indices = attr.indices;\n  let positions = attributes.position.values;\n  let length = positions.length;\n  let extrudedPositions = new Float64Array(length);\n  extrudedPositions.set(positions);\n  const newPositions = new Float64Array(length * 2);\n\n  positions = PolygonPipeline.scaleToGeodeticHeight(\n    positions,\n    height,\n    ellipsoid\n  );\n  extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(\n    extrudedPositions,\n    extrudedHeight,\n    ellipsoid\n  );\n  newPositions.set(positions);\n  newPositions.set(extrudedPositions, length);\n  attributes.position.values = newPositions;\n\n  length /= 3;\n  if (defined(params.offsetAttribute)) {\n    let applyOffset = new Uint8Array(length * 2);\n    if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, length);\n    } else {\n      const applyOffsetValue =\n        params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, applyOffsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  let i;\n  const iLength = indices.length;\n  const newIndices = IndexDatatype.createTypedArray(\n    newPositions.length / 3,\n    (iLength + wallIndices.length) * 2\n  );\n  newIndices.set(indices);\n  let index = iLength;\n  for (i = 0; i < iLength; i += 2) {\n    // bottom indices\n    const v0 = indices[i];\n    const v1 = indices[i + 1];\n    newIndices[index++] = v0 + length;\n    newIndices[index++] = v1 + length;\n  }\n\n  let UL, LL;\n  for (i = 0; i < wallIndices.length; i++) {\n    //wall indices\n    UL = wallIndices[i];\n    LL = UL + length;\n    newIndices[index++] = UL;\n    newIndices[index++] = LL;\n  }\n\n  return {\n    attributes: attributes,\n    indices: newIndices,\n  };\n}\n\n/**\n * A description of a corridor outline.\n *\n * @alias CorridorOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n * @param {Number} options.width The distance between the edges of the corridor outline.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n *\n * @see CorridorOutlineGeometry.createGeometry\n *\n * @example\n * const corridor = new Cesium.CorridorOutlineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n *   width : 100000\n * });\n */\nfunction CorridorOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const positions = options.positions;\n  const width = options.width;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.positions\", positions);\n  Check.typeOf.number(\"options.width\", width);\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._positions = positions;\n  this._ellipsoid = Ellipsoid.clone(\n    defaultValue(options.ellipsoid, Ellipsoid.WGS84)\n  );\n  this._width = width;\n  this._height = Math.max(height, extrudedHeight);\n  this._extrudedHeight = Math.min(height, extrudedHeight);\n  this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n  this._granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCorridorOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CorridorOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCorridorOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const positions = value._positions;\n  const length = positions.length;\n  array[startingIndex++] = length;\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    Cartesian3.pack(positions[i], array, startingIndex);\n  }\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._width;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._cornerType;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\nconst scratchOptions = {\n  positions: undefined,\n  ellipsoid: scratchEllipsoid,\n  width: undefined,\n  height: undefined,\n  extrudedHeight: undefined,\n  cornerType: undefined,\n  granularity: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n */\nCorridorOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const length = array[startingIndex++];\n  const positions = new Array(length);\n\n  for (let i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n    positions[i] = Cartesian3.unpack(array, startingIndex);\n  }\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const width = array[startingIndex++];\n  const height = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const cornerType = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.positions = positions;\n    scratchOptions.width = width;\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.cornerType = cornerType;\n    scratchOptions.granularity = granularity;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CorridorOutlineGeometry(scratchOptions);\n  }\n\n  result._positions = positions;\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._width = width;\n  result._height = height;\n  result._extrudedHeight = extrudedHeight;\n  result._cornerType = cornerType;\n  result._granularity = granularity;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n *\n * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCorridorOutlineGeometry.createGeometry = function (corridorOutlineGeometry) {\n  let positions = corridorOutlineGeometry._positions;\n  const width = corridorOutlineGeometry._width;\n  const ellipsoid = corridorOutlineGeometry._ellipsoid;\n\n  positions = scaleToSurface(positions, ellipsoid);\n  const cleanPositions = arrayRemoveDuplicates(\n    positions,\n    Cartesian3.equalsEpsilon\n  );\n\n  if (cleanPositions.length < 2 || width <= 0) {\n    return;\n  }\n\n  const height = corridorOutlineGeometry._height;\n  const extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  const params = {\n    ellipsoid: ellipsoid,\n    positions: cleanPositions,\n    width: width,\n    cornerType: corridorOutlineGeometry._cornerType,\n    granularity: corridorOutlineGeometry._granularity,\n    saveAttributes: false,\n  };\n  let attr;\n  if (extrude) {\n    params.height = height;\n    params.extrudedHeight = extrudedHeight;\n    params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n    attr = computePositionsExtruded(params);\n  } else {\n    const computedPositions = CorridorGeometryLibrary.computePositions(params);\n    attr = combine(computedPositions, params.cornerType);\n    attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\n      attr.attributes.position.values,\n      height,\n      ellipsoid\n    );\n\n    if (defined(corridorOutlineGeometry._offsetAttribute)) {\n      const length = attr.attributes.position.values.length;\n      const applyOffset = new Uint8Array(length / 3);\n      const offsetValue =\n        corridorOutlineGeometry._offsetAttribute ===\n        GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      attr.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n  const attributes = attr.attributes;\n  const boundingSphere = BoundingSphere.fromVertices(\n    attributes.position.values,\n    undefined,\n    3\n  );\n\n  return new Geometry({\n    attributes: attributes,\n    indices: attr.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: corridorOutlineGeometry._offsetAttribute,\n  });\n};\nexport default CorridorOutlineGeometry;\n","import DOMPurify from \"../ThirdParty/dompurify.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\n\nlet nextCreditId = 0;\nconst creditToId = {};\n\n/**\n * A credit contains data pertaining to how to display attributions/credits for certain content on the screen.\n * @param {String} html An string representing an html code snippet\n * @param {Boolean} [showOnScreen=false] If true, the credit will be visible in the main credit container.  Otherwise, it will appear in a popover\n *\n * @alias Credit\n * @constructor\n *\n * @exception {DeveloperError} html is required.\n *\n * @example\n * //Create a credit with a tooltip, image and link\n * const credit = new Cesium.Credit('<a href=\"https://cesium.com/\" target=\"_blank\"><img src=\"/images/cesium_logo.png\" title=\"Cesium\"/></a>');\n */\nfunction Credit(html, showOnScreen) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"html\", html);\n  //>>includeEnd('debug');\n  let id;\n  const key = html;\n\n  if (defined(creditToId[key])) {\n    id = creditToId[key];\n  } else {\n    id = nextCreditId++;\n    creditToId[key] = id;\n  }\n\n  showOnScreen = defaultValue(showOnScreen, false);\n\n  // Credits are immutable so generate an id to use to optimize equal()\n  this._id = id;\n  this._html = html;\n  this._showOnScreen = showOnScreen;\n  this._element = undefined;\n}\n\nObject.defineProperties(Credit.prototype, {\n  /**\n   * The credit content\n   * @memberof Credit.prototype\n   * @type {String}\n   * @readonly\n   */\n  html: {\n    get: function () {\n      return this._html;\n    },\n  },\n\n  /**\n   * @memberof Credit.prototype\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * Whether the credit should be displayed on screen or in a lightbox\n   * @memberof Credit.prototype\n   * @type {Boolean}\n   */\n  showOnScreen: {\n    get: function () {\n      return this._showOnScreen;\n    },\n    set: function (value) {\n      this._showOnScreen = value;\n    },\n  },\n\n  /**\n   * Gets the credit element\n   * @memberof Credit.prototype\n   * @type {HTMLElement}\n   * @readonly\n   */\n  element: {\n    get: function () {\n      if (!defined(this._element)) {\n        const html = DOMPurify.sanitize(this._html);\n\n        const div = document.createElement(\"div\");\n        div._creditId = this._id;\n        div.style.display = \"inline\";\n        div.innerHTML = html;\n\n        const links = div.querySelectorAll(\"a\");\n        for (let i = 0; i < links.length; i++) {\n          links[i].setAttribute(\"target\", \"_blank\");\n        }\n\n        this._element = div;\n      }\n      return this._element;\n    },\n  },\n});\n\n/**\n * Returns true if the credits are equal\n *\n * @param {Credit} left The first credit\n * @param {Credit} right The second credit\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCredit.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left._id === right._id &&\n      left._showOnScreen === right._showOnScreen)\n  );\n};\n\n/**\n * Returns true if the credits are equal\n *\n * @param {Credit} credit The credit to compare to.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCredit.prototype.equals = function (credit) {\n  return Credit.equals(this, credit);\n};\n\n/**\n * @private\n * @param attribution\n * @return {Credit}\n */\nCredit.getIonCredit = function (attribution) {\n  const showOnScreen =\n    defined(attribution.collapsible) && !attribution.collapsible;\n  const credit = new Credit(attribution.html, showOnScreen);\n\n  credit._isIon = credit.html.indexOf(\"ion-credit.png\") !== -1;\n  return credit;\n};\n\n/**\n * Duplicates a Credit instance.\n *\n * @param {Credit} [credit] The Credit to duplicate.\n * @returns {Credit} A new Credit instance that is a duplicate of the one provided. (Returns undefined if the credit is undefined)\n */\nCredit.clone = function (credit) {\n  if (defined(credit)) {\n    return new Credit(credit.html, credit.showOnScreen);\n  }\n};\nexport default Credit;\n","import DeveloperError from \"./DeveloperError.js\";\nimport QuadraticRealPolynomial from \"./QuadraticRealPolynomial.js\";\n\n/**\n * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.\n *\n * @namespace CubicRealPolynomial\n */\nconst CubicRealPolynomial = {};\n\n/**\n * Provides the discriminant of the cubic equation from the supplied coefficients.\n *\n * @param {Number} a The coefficient of the 3rd order monomial.\n * @param {Number} b The coefficient of the 2nd order monomial.\n * @param {Number} c The coefficient of the 1st order monomial.\n * @param {Number} d The coefficient of the 0th order monomial.\n * @returns {Number} The value of the discriminant.\n */\nCubicRealPolynomial.computeDiscriminant = function (a, b, c, d) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  const a2 = a * a;\n  const b2 = b * b;\n  const c2 = c * c;\n  const d2 = d * d;\n\n  const discriminant =\n    18.0 * a * b * c * d +\n    b2 * c2 -\n    27.0 * a2 * d2 -\n    4.0 * (a * c2 * c + b2 * b * d);\n  return discriminant;\n};\n\nfunction computeRealRoots(a, b, c, d) {\n  const A = a;\n  const B = b / 3.0;\n  const C = c / 3.0;\n  const D = d;\n\n  const AC = A * C;\n  const BD = B * D;\n  const B2 = B * B;\n  const C2 = C * C;\n  const delta1 = A * C - B2;\n  const delta2 = A * D - B * C;\n  const delta3 = B * D - C2;\n\n  const discriminant = 4.0 * delta1 * delta3 - delta2 * delta2;\n  let temp;\n  let temp1;\n\n  if (discriminant < 0.0) {\n    let ABar;\n    let CBar;\n    let DBar;\n\n    if (B2 * BD >= AC * C2) {\n      ABar = A;\n      CBar = delta1;\n      DBar = -2.0 * B * delta1 + A * delta2;\n    } else {\n      ABar = D;\n      CBar = delta3;\n      DBar = -D * delta2 + 2.0 * C * delta3;\n    }\n\n    const s = DBar < 0.0 ? -1.0 : 1.0; // This is not Math.Sign()!\n    const temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);\n    temp1 = -DBar + temp0;\n\n    const x = temp1 / 2.0;\n    const p = x < 0.0 ? -Math.pow(-x, 1.0 / 3.0) : Math.pow(x, 1.0 / 3.0);\n    const q = temp1 === temp0 ? -p : -CBar / p;\n\n    temp = CBar <= 0.0 ? p + q : -DBar / (p * p + q * q + CBar);\n\n    if (B2 * BD >= AC * C2) {\n      return [(temp - B) / A];\n    }\n\n    return [-D / (temp + C)];\n  }\n\n  const CBarA = delta1;\n  const DBarA = -2.0 * B * delta1 + A * delta2;\n\n  const CBarD = delta3;\n  const DBarD = -D * delta2 + 2.0 * C * delta3;\n\n  const squareRootOfDiscriminant = Math.sqrt(discriminant);\n  const halfSquareRootOf3 = Math.sqrt(3.0) / 2.0;\n\n  let theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3.0);\n  temp = 2.0 * Math.sqrt(-CBarA);\n  let cosine = Math.cos(theta);\n  temp1 = temp * cosine;\n  let temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n  const numeratorLarge = temp1 + temp3 > 2.0 * B ? temp1 - B : temp3 - B;\n  const denominatorLarge = A;\n\n  const root1 = numeratorLarge / denominatorLarge;\n\n  theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3.0);\n  temp = 2.0 * Math.sqrt(-CBarD);\n  cosine = Math.cos(theta);\n  temp1 = temp * cosine;\n  temp3 = temp * (-cosine / 2.0 - halfSquareRootOf3 * Math.sin(theta));\n\n  const numeratorSmall = -D;\n  const denominatorSmall = temp1 + temp3 < 2.0 * C ? temp1 + C : temp3 + C;\n\n  const root3 = numeratorSmall / denominatorSmall;\n\n  const E = denominatorLarge * denominatorSmall;\n  const F =\n    -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;\n  const G = numeratorLarge * numeratorSmall;\n\n  const root2 = (C * F - B * G) / (-B * F + C * E);\n\n  if (root1 <= root2) {\n    if (root1 <= root3) {\n      if (root2 <= root3) {\n        return [root1, root2, root3];\n      }\n      return [root1, root3, root2];\n    }\n    return [root3, root1, root2];\n  }\n  if (root1 <= root3) {\n    return [root2, root1, root3];\n  }\n  if (root2 <= root3) {\n    return [root2, root3, root1];\n  }\n  return [root3, root2, root1];\n}\n\n/**\n * Provides the real valued roots of the cubic polynomial with the provided coefficients.\n *\n * @param {Number} a The coefficient of the 3rd order monomial.\n * @param {Number} b The coefficient of the 2nd order monomial.\n * @param {Number} c The coefficient of the 1st order monomial.\n * @param {Number} d The coefficient of the 0th order monomial.\n * @returns {Number[]} The real valued roots.\n */\nCubicRealPolynomial.computeRealRoots = function (a, b, c, d) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof a !== \"number\") {\n    throw new DeveloperError(\"a is a required number.\");\n  }\n  if (typeof b !== \"number\") {\n    throw new DeveloperError(\"b is a required number.\");\n  }\n  if (typeof c !== \"number\") {\n    throw new DeveloperError(\"c is a required number.\");\n  }\n  if (typeof d !== \"number\") {\n    throw new DeveloperError(\"d is a required number.\");\n  }\n  //>>includeEnd('debug');\n\n  let roots;\n  let ratio;\n  if (a === 0.0) {\n    // Quadratic function: b * x^2 + c * x + d = 0.\n    return QuadraticRealPolynomial.computeRealRoots(b, c, d);\n  } else if (b === 0.0) {\n    if (c === 0.0) {\n      if (d === 0.0) {\n        // 3rd order monomial: a * x^3 = 0.\n        return [0.0, 0.0, 0.0];\n      }\n\n      // a * x^3 + d = 0\n      ratio = -d / a;\n      const root =\n        ratio < 0.0 ? -Math.pow(-ratio, 1.0 / 3.0) : Math.pow(ratio, 1.0 / 3.0);\n      return [root, root, root];\n    } else if (d === 0.0) {\n      // x * (a * x^2 + c) = 0.\n      roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);\n\n      // Return the roots in ascending order.\n      if (roots.Length === 0) {\n        return [0.0];\n      }\n      return [roots[0], 0.0, roots[1]];\n    }\n\n    // Deflated cubic polynomial: a * x^3 + c * x + d= 0.\n    return computeRealRoots(a, 0, c, d);\n  } else if (c === 0.0) {\n    if (d === 0.0) {\n      // x^2 * (a * x + b) = 0.\n      ratio = -b / a;\n      if (ratio < 0.0) {\n        return [ratio, 0.0, 0.0];\n      }\n      return [0.0, 0.0, ratio];\n    }\n    // a * x^3 + b * x^2 + d = 0.\n    return computeRealRoots(a, b, 0, d);\n  } else if (d === 0.0) {\n    // x * (a * x^2 + b * x + c) = 0\n    roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);\n\n    // Return the roots in ascending order.\n    if (roots.length === 0) {\n      return [0.0];\n    } else if (roots[1] <= 0.0) {\n      return [roots[0], roots[1], 0.0];\n    } else if (roots[0] >= 0.0) {\n      return [0.0, roots[0], roots[1]];\n    }\n    return [roots[0], 0.0, roots[1]];\n  }\n\n  return computeRealRoots(a, b, c, d);\n};\nexport default CubicRealPolynomial;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Intersect from \"./Intersect.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * The culling volume defined by planes.\n *\n * @alias CullingVolume\n * @constructor\n *\n * @param {Cartesian4[]} [planes] An array of clipping planes.\n */\nfunction CullingVolume(planes) {\n  /**\n   * Each plane is represented by a Cartesian4 object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin.\n   * @type {Cartesian4[]}\n   * @default []\n   */\n  this.planes = defaultValue(planes, []);\n}\n\nconst faces = [new Cartesian3(), new Cartesian3(), new Cartesian3()];\nCartesian3.clone(Cartesian3.UNIT_X, faces[0]);\nCartesian3.clone(Cartesian3.UNIT_Y, faces[1]);\nCartesian3.clone(Cartesian3.UNIT_Z, faces[2]);\n\nconst scratchPlaneCenter = new Cartesian3();\nconst scratchPlaneNormal = new Cartesian3();\nconst scratchPlane = new Plane(new Cartesian3(1.0, 0.0, 0.0), 0.0);\n\n/**\n * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n * The planes are aligned to the x, y, and z axes in world coordinates.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.\n * @param {CullingVolume} [result] The object onto which to store the result.\n * @returns {CullingVolume} The culling volume created from the bounding sphere.\n */\nCullingVolume.fromBoundingSphere = function (boundingSphere, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new CullingVolume();\n  }\n\n  const length = faces.length;\n  const planes = result.planes;\n  planes.length = 2 * length;\n\n  const center = boundingSphere.center;\n  const radius = boundingSphere.radius;\n\n  let planeIndex = 0;\n\n  for (let i = 0; i < length; ++i) {\n    const faceNormal = faces[i];\n\n    let plane0 = planes[planeIndex];\n    let plane1 = planes[planeIndex + 1];\n\n    if (!defined(plane0)) {\n      plane0 = planes[planeIndex] = new Cartesian4();\n    }\n    if (!defined(plane1)) {\n      plane1 = planes[planeIndex + 1] = new Cartesian4();\n    }\n\n    Cartesian3.multiplyByScalar(faceNormal, -radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane0.x = faceNormal.x;\n    plane0.y = faceNormal.y;\n    plane0.z = faceNormal.z;\n    plane0.w = -Cartesian3.dot(faceNormal, scratchPlaneCenter);\n\n    Cartesian3.multiplyByScalar(faceNormal, radius, scratchPlaneCenter);\n    Cartesian3.add(center, scratchPlaneCenter, scratchPlaneCenter);\n\n    plane1.x = -faceNormal.x;\n    plane1.y = -faceNormal.y;\n    plane1.z = -faceNormal.z;\n    plane1.w = -Cartesian3.dot(\n      Cartesian3.negate(faceNormal, scratchPlaneNormal),\n      scratchPlaneCenter\n    );\n\n    planeIndex += 2;\n  }\n\n  return result;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.\n */\nCullingVolume.prototype.computeVisibility = function (boundingVolume) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const planes = this.planes;\n  let intersecting = false;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    const result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane)\n    );\n    if (result === Intersect.OUTSIDE) {\n      return Intersect.OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      intersecting = true;\n    }\n  }\n\n  return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;\n};\n\n/**\n * Determines whether a bounding volume intersects the culling volume.\n *\n * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.\n * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n *                                 and that plane check can be skipped.\n * @returns {Number} A plane mask as described above (which can be applied to this boundingVolume's children).\n *\n * @private\n */\nCullingVolume.prototype.computeVisibilityWithPlaneMask = function (\n  boundingVolume,\n  parentPlaneMask\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingVolume)) {\n    throw new DeveloperError(\"boundingVolume is required.\");\n  }\n  if (!defined(parentPlaneMask)) {\n    throw new DeveloperError(\"parentPlaneMask is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (\n    parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n    parentPlaneMask === CullingVolume.MASK_INSIDE\n  ) {\n    // parent is completely outside or completely inside, so this child is as well.\n    return parentPlaneMask;\n  }\n\n  // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n  // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n  let mask = CullingVolume.MASK_INSIDE;\n\n  const planes = this.planes;\n  for (let k = 0, len = planes.length; k < len; ++k) {\n    // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n    const flag = k < 31 ? 1 << k : 0;\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      // boundingVolume is known to be INSIDE this plane.\n      continue;\n    }\n\n    const result = boundingVolume.intersectPlane(\n      Plane.fromCartesian4(planes[k], scratchPlane)\n    );\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n};\n\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_INSIDE = 0x00000000;\n\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n *\n * @type {Number}\n * @private\n */\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\nexport default CullingVolume;\n","import Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n\n/**\n * @callback CustomHeightmapTerrainProvider.GeometryCallback\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Number[]|Promise.<Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|Number[]>|undefined} An array or a promise to an array of heights in row-major order. If undefined, the globe will render the parent tile.\n */\n\n/**\n * A simple {@link TerrainProvider} that gets height values from a callback function.\n * It can be used for procedurally generated terrain or as a way to load custom\n * heightmap data without creating a subclass of {@link TerrainProvider}.\n *\n * There are some limitations such as no water mask, no vertex normals, and no\n * availability, so a full-fledged {@link TerrainProvider} subclass is better suited\n * for these more sophisticated use cases.\n *\n * @alias CustomHeightmapTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {CustomHeightmapTerrainProvider.GeometryCallback} options.callback The callback function for requesting tile geometry.\n * @param {Number} options.width The number of columns per heightmap tile.\n * @param {Number} options.height The number of rows per heightmap tile.\n * @param {TilingScheme} [options.tilingScheme] The tiling scheme specifying how the ellipsoidal\n * surface is broken into tiles. If this parameter is not provided, a {@link GeographicTilingScheme}\n * is used.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n * this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n * parameter is specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @example\n * const viewer = new Cesium.Viewer(\"cesiumContainer\", {\n *   terrainProvider: new Cesium.CustomHeightmapTerrainProvider({\n *     width: 32,\n *     height: 32,\n *     callback: function (x, y, level) {\n *       return new Float32Array(32 * 32); // all zeros\n *     },\n *   }),\n * });\n *\n * @see TerrainProvider\n */\nfunction CustomHeightmapTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.callback\", options.callback);\n  Check.defined(\"options.width\", options.width);\n  Check.defined(\"options.height\", options.height);\n  //>>includeEnd('debug');\n\n  this._callback = options.callback;\n\n  this._tilingScheme = options.tilingScheme;\n  if (!defined(this._tilingScheme)) {\n    this._tilingScheme = new GeographicTilingScheme({\n      ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.WGS84),\n    });\n  }\n\n  this._width = options.width;\n  this._height = options.height;\n  const maxTileDimensions = Math.max(this._width, this._height);\n\n  this._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    this._tilingScheme.ellipsoid,\n    maxTileDimensions,\n    this._tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n\n  this._errorEvent = new Event();\n\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  this._readyPromise = Promise.resolve(true);\n}\n\nObject.defineProperties(CustomHeightmapTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error. By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it. Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof CustomHeightmapTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active. Typically this is used to credit\n   * the source of the terrain.\n   * @memberof CustomHeightmapTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof CustomHeightmapTerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof CustomHeightmapTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return true;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof CustomHeightmapTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask. The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * Water mask is not supported by {@link CustomHeightmapTerrainProvider}, so the return\n   * value will always be false.\n   * @memberof CustomHeightmapTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * Vertex normals are not supported by {@link CustomHeightmapTerrainProvider}, so the return\n   * value will always be false.\n   * @memberof CustomHeightmapTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets the number of columns per heightmap tile.\n   * @memberof CustomHeightmapTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  width: {\n    get: function () {\n      return this._width;\n    },\n  },\n\n  /**\n   * Gets the number of rows per heightmap tile.\n   * @memberof CustomHeightmapTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  height: {\n    get: function () {\n      return this._height;\n    },\n  },\n});\n\n/**\n * Requests the geometry for a given tile. The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry. If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nCustomHeightmapTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  const promise = this._callback(x, y, level);\n  if (!defined(promise)) {\n    return undefined;\n  }\n\n  const width = this._width;\n  const height = this._height;\n\n  return Promise.resolve(promise).then(function (heightmapData) {\n    let buffer = heightmapData;\n    if (Array.isArray(buffer)) {\n      // HeightmapTerrainData expects a TypedArray, so convert from Number[] to Float64Array\n      buffer = new Float64Array(buffer);\n    }\n\n    return new HeightmapTerrainData({\n      buffer: buffer,\n      width: width,\n      height: height,\n    });\n  });\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nCustomHeightmapTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nCustomHeightmapTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nCustomHeightmapTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\nexport default CustomHeightmapTerrainProvider;\n","import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst radiusScratch = new Cartesian2();\nconst normalScratch = new Cartesian3();\nconst bitangentScratch = new Cartesian3();\nconst tangentScratch = new Cartesian3();\nconst positionScratch = new Cartesian3();\n\n/**\n * A description of a cylinder.\n *\n * @alias CylinderGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * const cylinder = new Cesium.CylinderGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n */\nfunction CylinderGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const length = options.length;\n  const topRadius = options.topRadius;\n  const bottomRadius = options.bottomRadius;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n  const slices = defaultValue(options.slices, 128);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(length)) {\n    throw new DeveloperError(\"options.length must be defined.\");\n  }\n  if (!defined(topRadius)) {\n    throw new DeveloperError(\"options.topRadius must be defined.\");\n  }\n  if (!defined(bottomRadius)) {\n    throw new DeveloperError(\"options.bottomRadius must be defined.\");\n  }\n  if (slices < 3) {\n    throw new DeveloperError(\n      \"options.slices must be greater than or equal to 3.\"\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._slices = slices;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCylinderGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  vertexFormat: scratchVertexFormat,\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderGeometry} [result] The object into which to store the result.\n * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n */\nCylinderGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const length = array[startingIndex++];\n  const topRadius = array[startingIndex++];\n  const bottomRadius = array[startingIndex++];\n  const slices = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderGeometry(scratchOptions);\n  }\n\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderGeometry.createGeometry = function (cylinderGeometry) {\n  let length = cylinderGeometry._length;\n  const topRadius = cylinderGeometry._topRadius;\n  const bottomRadius = cylinderGeometry._bottomRadius;\n  const vertexFormat = cylinderGeometry._vertexFormat;\n  const slices = cylinderGeometry._slices;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  const twoSlices = slices + slices;\n  const threeSlices = slices + twoSlices;\n  const numVertices = twoSlices + twoSlices;\n\n  const positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    true\n  );\n\n  const st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;\n  const normals = vertexFormat.normal\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(numVertices * 3)\n    : undefined;\n\n  let i;\n  const computeNormal =\n    vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent;\n\n  if (computeNormal) {\n    const computeTangent = vertexFormat.tangent || vertexFormat.bitangent;\n\n    let normalIndex = 0;\n    let tangentIndex = 0;\n    let bitangentIndex = 0;\n\n    const theta = Math.atan2(bottomRadius - topRadius, length);\n    const normal = normalScratch;\n    normal.z = Math.sin(theta);\n    const normalScale = Math.cos(theta);\n    let tangent = tangentScratch;\n    let bitangent = bitangentScratch;\n\n    for (i = 0; i < slices; i++) {\n      const angle = (i / slices) * CesiumMath.TWO_PI;\n      const x = normalScale * Math.cos(angle);\n      const y = normalScale * Math.sin(angle);\n      if (computeNormal) {\n        normal.x = x;\n        normal.y = y;\n\n        if (computeTangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent\n          );\n        }\n\n        if (vertexFormat.normal) {\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n          normals[normalIndex++] = normal.x;\n          normals[normalIndex++] = normal.y;\n          normals[normalIndex++] = normal.z;\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent\n          );\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = -1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = -1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n\n    for (i = 0; i < slices; i++) {\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 0;\n        normals[normalIndex++] = 1;\n      }\n      if (vertexFormat.tangent) {\n        tangents[tangentIndex++] = 1;\n        tangents[tangentIndex++] = 0;\n        tangents[tangentIndex++] = 0;\n      }\n      if (vertexFormat.bitangent) {\n        bitangents[bitangentIndex++] = 0;\n        bitangents[bitangentIndex++] = 1;\n        bitangents[bitangentIndex++] = 0;\n      }\n    }\n  }\n\n  const numIndices = 12 * slices - 12;\n  const indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n  let index = 0;\n  let j = 0;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = j;\n    indices[index++] = j + 2;\n    indices[index++] = j + 3;\n\n    indices[index++] = j;\n    indices[index++] = j + 3;\n    indices[index++] = j + 1;\n\n    j += 2;\n  }\n\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 0;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 2;\n  indices[index++] = 1;\n  indices[index++] = twoSlices - 1;\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = twoSlices + i + 1;\n    indices[index++] = twoSlices + i;\n    indices[index++] = twoSlices;\n  }\n\n  for (i = 1; i < slices - 1; i++) {\n    indices[index++] = threeSlices;\n    indices[index++] = threeSlices + i;\n    indices[index++] = threeSlices + i + 1;\n  }\n\n  let textureCoordIndex = 0;\n  if (vertexFormat.st) {\n    const rad = Math.max(topRadius, bottomRadius);\n    for (i = 0; i < numVertices; i++) {\n      const position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n      st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n      st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: st,\n    });\n  }\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch)\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    const applyOffset = new Uint8Array(length / 3);\n    const offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\n\nlet unitCylinderGeometry;\n\n/**\n * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nCylinderGeometry.getUnitCylinder = function () {\n  if (!defined(unitCylinderGeometry)) {\n    unitCylinderGeometry = CylinderGeometry.createGeometry(\n      new CylinderGeometry({\n        topRadius: 1.0,\n        bottomRadius: 1.0,\n        length: 1.0,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n  }\n  return unitCylinderGeometry;\n};\nexport default CylinderGeometry;\n","import CesiumMath from \"./Math.js\";\n\n/**\n * @private\n */\nconst CylinderGeometryLibrary = {};\n\n/**\n * @private\n */\nCylinderGeometryLibrary.computePositions = function (\n  length,\n  topRadius,\n  bottomRadius,\n  slices,\n  fill\n) {\n  const topZ = length * 0.5;\n  const bottomZ = -topZ;\n\n  const twoSlice = slices + slices;\n  const size = fill ? 2 * twoSlice : twoSlice;\n  const positions = new Float64Array(size * 3);\n  let i;\n  let index = 0;\n  let tbIndex = 0;\n  const bottomOffset = fill ? twoSlice * 3 : 0;\n  const topOffset = fill ? (twoSlice + slices) * 3 : slices * 3;\n\n  for (i = 0; i < slices; i++) {\n    const angle = (i / slices) * CesiumMath.TWO_PI;\n    const x = Math.cos(angle);\n    const y = Math.sin(angle);\n    const bottomX = x * bottomRadius;\n    const bottomY = y * bottomRadius;\n    const topX = x * topRadius;\n    const topY = y * topRadius;\n\n    positions[tbIndex + bottomOffset] = bottomX;\n    positions[tbIndex + bottomOffset + 1] = bottomY;\n    positions[tbIndex + bottomOffset + 2] = bottomZ;\n\n    positions[tbIndex + topOffset] = topX;\n    positions[tbIndex + topOffset + 1] = topY;\n    positions[tbIndex + topOffset + 2] = topZ;\n    tbIndex += 3;\n    if (fill) {\n      positions[index++] = bottomX;\n      positions[index++] = bottomY;\n      positions[index++] = bottomZ;\n      positions[index++] = topX;\n      positions[index++] = topY;\n      positions[index++] = topZ;\n    }\n  }\n\n  return positions;\n};\nexport default CylinderGeometryLibrary;\n","import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport CylinderGeometryLibrary from \"./CylinderGeometryLibrary.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst radiusScratch = new Cartesian2();\n\n/**\n * A description of the outline of a cylinder.\n *\n * @alias CylinderOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.length The length of the cylinder.\n * @param {Number} options.topRadius The radius of the top of the cylinder.\n * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n *\n * @exception {DeveloperError} options.length must be greater than 0.\n * @exception {DeveloperError} options.topRadius must be greater than 0.\n * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n *\n * @see CylinderOutlineGeometry.createGeometry\n *\n * @example\n * // create cylinder geometry\n * const cylinder = new Cesium.CylinderOutlineGeometry({\n *     length: 200000,\n *     topRadius: 80000,\n *     bottomRadius: 200000,\n * });\n * const geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n */\nfunction CylinderOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const length = options.length;\n  const topRadius = options.topRadius;\n  const bottomRadius = options.bottomRadius;\n  const slices = defaultValue(options.slices, 128);\n  const numberOfVerticalLines = Math.max(\n    defaultValue(options.numberOfVerticalLines, 16),\n    0\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"options.positions\", length);\n  Check.typeOf.number(\"options.topRadius\", topRadius);\n  Check.typeOf.number(\"options.bottomRadius\", bottomRadius);\n  Check.typeOf.number.greaterThanOrEquals(\"options.slices\", slices, 3);\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._length = length;\n  this._topRadius = topRadius;\n  this._bottomRadius = bottomRadius;\n  this._slices = slices;\n  this._numberOfVerticalLines = numberOfVerticalLines;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createCylinderOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCylinderOutlineGeometry.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {CylinderOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCylinderOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value._length;\n  array[startingIndex++] = value._topRadius;\n  array[startingIndex++] = value._bottomRadius;\n  array[startingIndex++] = value._slices;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchOptions = {\n  length: undefined,\n  topRadius: undefined,\n  bottomRadius: undefined,\n  slices: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n */\nCylinderOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const length = array[startingIndex++];\n  const topRadius = array[startingIndex++];\n  const bottomRadius = array[startingIndex++];\n  const slices = array[startingIndex++];\n  const numberOfVerticalLines = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.length = length;\n    scratchOptions.topRadius = topRadius;\n    scratchOptions.bottomRadius = bottomRadius;\n    scratchOptions.slices = slices;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new CylinderOutlineGeometry(scratchOptions);\n  }\n\n  result._length = length;\n  result._topRadius = topRadius;\n  result._bottomRadius = bottomRadius;\n  result._slices = slices;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n *\n * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nCylinderOutlineGeometry.createGeometry = function (cylinderGeometry) {\n  let length = cylinderGeometry._length;\n  const topRadius = cylinderGeometry._topRadius;\n  const bottomRadius = cylinderGeometry._bottomRadius;\n  const slices = cylinderGeometry._slices;\n  const numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n  if (\n    length <= 0 ||\n    topRadius < 0 ||\n    bottomRadius < 0 ||\n    (topRadius === 0 && bottomRadius === 0)\n  ) {\n    return;\n  }\n\n  const numVertices = slices * 2;\n\n  const positions = CylinderGeometryLibrary.computePositions(\n    length,\n    topRadius,\n    bottomRadius,\n    slices,\n    false\n  );\n  let numIndices = slices * 2;\n  let numSide;\n  if (numberOfVerticalLines > 0) {\n    const numSideLines = Math.min(numberOfVerticalLines, slices);\n    numSide = Math.round(slices / numSideLines);\n    numIndices += numSideLines;\n  }\n\n  const indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n  let index = 0;\n  let i;\n  for (i = 0; i < slices - 1; i++) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n    indices[index++] = i + slices;\n    indices[index++] = i + 1 + slices;\n  }\n\n  indices[index++] = slices - 1;\n  indices[index++] = 0;\n  indices[index++] = slices + slices - 1;\n  indices[index++] = slices;\n\n  if (numberOfVerticalLines > 0) {\n    for (i = 0; i < slices; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + slices;\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n  attributes.position = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positions,\n  });\n\n  radiusScratch.x = length * 0.5;\n  radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n  const boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    Cartesian2.magnitude(radiusScratch)\n  );\n\n  if (defined(cylinderGeometry._offsetAttribute)) {\n    length = positions.length;\n    const applyOffset = new Uint8Array(length / 3);\n    const offsetValue =\n      cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: boundingSphere,\n    offsetAttribute: cylinderGeometry._offsetAttribute,\n  });\n};\nexport default CylinderOutlineGeometry;\n","/**\n * A simple proxy that appends the desired resource as the sole query parameter\n * to the given proxy URL.\n *\n * @alias DefaultProxy\n * @constructor\n * @extends {Proxy}\n *\n * @param {String} proxy The proxy URL that will be used to requests all resources.\n */\nfunction DefaultProxy(proxy) {\n  this.proxy = proxy;\n}\n\n/**\n * Get the final URL to use to request a given resource.\n *\n * @param {String} resource The resource to request.\n * @returns {String} proxied resource\n */\nDefaultProxy.prototype.getURL = function (resource) {\n  const prefix = this.proxy.indexOf(\"?\") === -1 ? \"?\" : \"\";\n  return this.proxy + prefix + encodeURIComponent(resource);\n};\n\nexport default DefaultProxy;\n","import defined from \"./defined.js\";\n\n/**\n * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,\n * argument out of range, etc.  This exception should only be thrown during development;\n * it usually indicates a bug in the calling code.  This exception should never be\n * caught; instead the calling code should strive not to generate it.\n * <br /><br />\n * On the other hand, a {@link RuntimeError} indicates an exception that may\n * be thrown at runtime, e.g., out of memory, that the calling code should be prepared\n * to catch.\n *\n * @alias DeveloperError\n * @constructor\n * @extends Error\n *\n * @param {String} [message] The error message for this exception.\n *\n * @see RuntimeError\n */\nfunction DeveloperError(message) {\n  /**\n   * 'DeveloperError' indicating that this exception was thrown due to a developer error.\n   * @type {String}\n   * @readonly\n   */\n  this.name = \"DeveloperError\";\n\n  /**\n   * The explanation for why this exception was thrown.\n   * @type {String}\n   * @readonly\n   */\n  this.message = message;\n\n  //Browsers such as IE don't have a stack property until you actually throw the error.\n  let stack;\n  try {\n    throw new Error();\n  } catch (e) {\n    stack = e.stack;\n  }\n\n  /**\n   * The stack trace of this exception, if available.\n   * @type {String}\n   * @readonly\n   */\n  this.stack = stack;\n}\n\nif (defined(Object.create)) {\n  DeveloperError.prototype = Object.create(Error.prototype);\n  DeveloperError.prototype.constructor = DeveloperError;\n}\n\nDeveloperError.prototype.toString = function () {\n  let str = `${this.name}: ${this.message}`;\n\n  if (defined(this.stack)) {\n    str += `\\n${this.stack.toString()}`;\n  }\n\n  return str;\n};\n\n/**\n * @private\n */\nDeveloperError.throwInstantiationError = function () {\n  throw new DeveloperError(\n    \"This function defines an interface and should not be called directly.\"\n  );\n};\nexport default DeveloperError;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Determines visibility based on the distance to the camera.\n *\n * @alias DistanceDisplayCondition\n * @constructor\n *\n * @param {Number} [near=0.0] The smallest distance in the interval where the object is visible.\n * @param {Number} [far=Number.MAX_VALUE] The largest distance in the interval where the object is visible.\n *\n * @example\n * // Make a billboard that is only visible when the distance to the camera is between 10 and 20 meters.\n * billboard.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(10.0, 20.0);\n */\nfunction DistanceDisplayCondition(near, far) {\n  near = defaultValue(near, 0.0);\n  this._near = near;\n\n  far = defaultValue(far, Number.MAX_VALUE);\n  this._far = far;\n}\n\nObject.defineProperties(DistanceDisplayCondition.prototype, {\n  /**\n   * The smallest distance in the interval where the object is visible.\n   * @memberof DistanceDisplayCondition.prototype\n   * @type {Number}\n   * @default 0.0\n   */\n  near: {\n    get: function () {\n      return this._near;\n    },\n    set: function (value) {\n      this._near = value;\n    },\n  },\n  /**\n   * The largest distance in the interval where the object is visible.\n   * @memberof DistanceDisplayCondition.prototype\n   * @type {Number}\n   * @default Number.MAX_VALUE\n   */\n  far: {\n    get: function () {\n      return this._far;\n    },\n    set: function (value) {\n      this._far = value;\n    },\n  },\n});\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nDistanceDisplayCondition.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {DistanceDisplayCondition} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nDistanceDisplayCondition.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.near;\n  array[startingIndex] = value.far;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {DistanceDisplayCondition} [result] The object into which to store the result.\n * @returns {DistanceDisplayCondition} The modified result parameter or a new DistanceDisplayCondition instance if one was not provided.\n */\nDistanceDisplayCondition.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new DistanceDisplayCondition();\n  }\n  result.near = array[startingIndex++];\n  result.far = array[startingIndex];\n  return result;\n};\n\n/**\n * Determines if two distance display conditions are equal.\n *\n * @param {DistanceDisplayCondition} left A distance display condition.\n * @param {DistanceDisplayCondition} right Another distance display condition.\n * @return {Boolean} Whether the two distance display conditions are equal.\n */\nDistanceDisplayCondition.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.near === right.near &&\n      left.far === right.far)\n  );\n};\n\n/**\n * Duplicates a distance display condition instance.\n *\n * @param {DistanceDisplayCondition} [value] The distance display condition to duplicate.\n * @param {DistanceDisplayCondition} [result] The result onto which to store the result.\n * @return {DistanceDisplayCondition} The duplicated instance.\n */\nDistanceDisplayCondition.clone = function (value, result) {\n  if (!defined(value)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new DistanceDisplayCondition();\n  }\n\n  result.near = value.near;\n  result.far = value.far;\n  return result;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {DistanceDisplayCondition} [result] The result onto which to store the result.\n * @return {DistanceDisplayCondition} The duplicated instance.\n */\nDistanceDisplayCondition.prototype.clone = function (result) {\n  return DistanceDisplayCondition.clone(this, result);\n};\n\n/**\n * Determines if this distance display condition is equal to another.\n *\n * @param {DistanceDisplayCondition} other Another distance display condition.\n * @return {Boolean} Whether this distance display condition is equal to the other.\n */\nDistanceDisplayCondition.prototype.equals = function (other) {\n  return DistanceDisplayCondition.equals(this, other);\n};\nexport default DistanceDisplayCondition;\n","import ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.\n *\n * @alias DistanceDisplayConditionGeometryInstanceAttribute\n * @constructor\n *\n * @param {Number} [near=0.0] The near distance.\n * @param {Number} [far=Number.MAX_VALUE] The far distance.\n *\n * @exception {DeveloperError} far must be greater than near.\n *\n * @example\n * const instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.BoxGeometry({\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)\n *   }\n * });\n *\n * @see GeometryInstance\n * @see GeometryInstanceAttribute\n */\nfunction DistanceDisplayConditionGeometryInstanceAttribute(near, far) {\n  near = defaultValue(near, 0.0);\n  far = defaultValue(far, Number.MAX_VALUE);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (far <= near) {\n    throw new DeveloperError(\n      \"far distance must be greater than near distance.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The values for the attributes stored in a typed array.\n   *\n   * @type Float32Array\n   *\n   * @default [0.0, 0.0, Number.MAX_VALUE]\n   */\n  this.value = new Float32Array([near, far]);\n}\n\nObject.defineProperties(\n  DistanceDisplayConditionGeometryInstanceAttribute.prototype,\n  {\n    /**\n     * The datatype of each component in the attribute, e.g., individual elements in\n     * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n     *\n     * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n     *\n     * @type {ComponentDatatype}\n     * @readonly\n     *\n     * @default {@link ComponentDatatype.FLOAT}\n     */\n    componentDatatype: {\n      get: function () {\n        return ComponentDatatype.FLOAT;\n      },\n    },\n\n    /**\n     * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n     *\n     * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n     *\n     * @type {Number}\n     * @readonly\n     *\n     * @default 3\n     */\n    componentsPerAttribute: {\n      get: function () {\n        return 2;\n      },\n    },\n\n    /**\n     * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n     * indicate that the components should be mapped to the range [0, 1] (unsigned)\n     * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n     *\n     * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n     *\n     * @type {Boolean}\n     * @readonly\n     *\n     * @default false\n     */\n    normalize: {\n      get: function () {\n        return false;\n      },\n    },\n  }\n);\n\n/**\n * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\n *\n * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition.\n * @returns {DistanceDisplayConditionGeometryInstanceAttribute} The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.\n *\n * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n *\n * @example\n * const distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);\n * const instance = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   attributes : {\n *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n *   }\n * });\n */\nDistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition = function (\n  distanceDisplayCondition\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(distanceDisplayCondition)) {\n    throw new DeveloperError(\"distanceDisplayCondition is required.\");\n  }\n  if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {\n    throw new DeveloperError(\n      \"distanceDisplayCondition.far distance must be greater than distanceDisplayCondition.near distance.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return new DistanceDisplayConditionGeometryInstanceAttribute(\n    distanceDisplayCondition.near,\n    distanceDisplayCondition.far\n  );\n};\n\n/**\n * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\n *\n * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition value.\n * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\n * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\n *\n * @example\n * const attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n */\nDistanceDisplayConditionGeometryInstanceAttribute.toValue = function (\n  distanceDisplayCondition,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(distanceDisplayCondition)) {\n    throw new DeveloperError(\"distanceDisplayCondition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Float32Array([\n      distanceDisplayCondition.near,\n      distanceDisplayCondition.far,\n    ]);\n  }\n  result[0] = distanceDisplayCondition.near;\n  result[1] = distanceDisplayCondition.far;\n  return result;\n};\nexport default DistanceDisplayConditionGeometryInstanceAttribute;\n","import CesiumMath from \"./Math.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * Array-backed min-max heap implementation of a double-ended priority queue.\n * This data structure allows for efficient removal of minimum and maximum elements.\n *\n * @alias DoubleEndedPriorityQueue\n * @constructor\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {DoubleEndedPriorityQueue.ComparatorCallback} options.comparator The comparator to use for the queue. If comparator(a, b) is less than 0, a is lower priority than b.\n * @param {Number} [options.maximumLength] The maximum length of the queue. If an element is inserted when the queue is at full capacity, the minimum element is removed. By default, the size of the queue is unlimited.\n */\nfunction DoubleEndedPriorityQueue(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.defined(\"options.comparator\", options.comparator);\n  if (defined(options.maximumLength)) {\n    Check.typeOf.number.greaterThanOrEquals(\n      \"options.maximumLength\",\n      options.maximumLength,\n      0\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._comparator = options.comparator;\n  this._maximumLength = options.maximumLength;\n  this._array = defined(options.maximumLength)\n    ? new Array(options.maximumLength)\n    : [];\n  this._length = 0;\n}\n\nObject.defineProperties(DoubleEndedPriorityQueue.prototype, {\n  /**\n   * Gets the number of elements in the queue.\n   *\n   * @memberof DoubleEndedPriorityQueue.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n\n  /**\n   * Gets or sets the maximum number of elements in the queue.\n   * If set to a smaller value than the current length of the queue, the lowest priority elements are removed.\n   * If an element is inserted when the queue is at full capacity, the minimum element is removed.\n   * If set to undefined, the size of the queue is unlimited.\n   *\n   * @memberof DoubleEndedPriorityQueue.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  maximumLength: {\n    get: function () {\n      return this._maximumLength;\n    },\n    set: function (value) {\n      if (defined(value)) {\n        //>>includeStart('debug', pragmas.debug);\n        Check.typeOf.number.greaterThanOrEquals(\"maximumLength\", value, 0);\n        //>>includeEnd('debug');\n\n        // Remove elements until the maximum length is met.\n        while (this._length > value) {\n          this.removeMinimum();\n        }\n\n        // The array size is fixed to the maximum length\n        this._array.length = value;\n      }\n      this._maximumLength = value;\n    },\n  },\n\n  /**\n   * Gets the internal array.\n   *\n   * @memberof DoubleEndedPriorityQueue.prototype\n   *\n   * @type {Array}\n   * @readonly\n   */\n  internalArray: {\n    get: function () {\n      return this._array;\n    },\n  },\n\n  /**\n   * The comparator used by the queue.\n   * If comparator(a, b) is less than 0, a is lower priority than b.\n   *\n   * @memberof DoubleEndedPriorityQueue.prototype\n   *\n   * @type {DoubleEndedPriorityQueue.ComparatorCallback}\n   * @readonly\n   */\n  comparator: {\n    get: function () {\n      return this._comparator;\n    },\n  },\n});\n\n/**\n * Clones the double ended priority queue.\n *\n * @returns {DoubleEndedPriorityQueue} The cloned double ended priority queue.\n */\nDoubleEndedPriorityQueue.prototype.clone = function () {\n  const maximumLength = this._maximumLength;\n  const comparator = this._comparator;\n  const array = this._array;\n  const length = this._length;\n\n  const result = new DoubleEndedPriorityQueue({\n    comparator: comparator,\n    maximumLength: maximumLength,\n  });\n\n  result._length = length;\n  for (let i = 0; i < length; i++) {\n    result._array[i] = array[i];\n  }\n\n  return result;\n};\n\n/**\n * Removes all elements from the queue.\n */\nDoubleEndedPriorityQueue.prototype.reset = function () {\n  this._length = 0;\n\n  // Dereference elements\n  const maximumLength = this._maximumLength;\n  if (defined(maximumLength)) {\n    // Dereference all elements but keep the array the same size\n    for (let i = 0; i < maximumLength; i++) {\n      this._array[i] = undefined;\n    }\n  } else {\n    // Dereference all elements by clearing the array\n    this._array.length = 0;\n  }\n};\n\n/**\n * Resort the queue.\n */\nDoubleEndedPriorityQueue.prototype.resort = function () {\n  const length = this._length;\n\n  // Fix the queue from the top-down\n  for (let i = 0; i < length; i++) {\n    pushUp(this, i);\n  }\n};\n\n/**\n * Inserts an element into the queue.\n * If the queue is at full capacity, the minimum element is removed.\n * The new element is returned (and not added) if it is less than or equal priority to the minimum element.\n *\n * @param {*} element\n * @returns {*|undefined} The minimum element if the queue is at full capacity. Returns undefined if there is no maximum length.\n */\nDoubleEndedPriorityQueue.prototype.insert = function (element) {\n  let removedElement;\n\n  const maximumLength = this._maximumLength;\n  if (defined(maximumLength)) {\n    if (maximumLength === 0) {\n      return undefined;\n    } else if (this._length === maximumLength) {\n      // It's faster to access the minimum directly instead of calling the getter\n      // because it avoids the length === 0 check.\n      const minimumElement = this._array[0];\n      if (this._comparator(element, minimumElement) <= 0.0) {\n        // The element that is being inserted is less than or equal to\n        // the minimum element, so don't insert anything and exit early.\n        return element;\n      }\n      removedElement = this.removeMinimum();\n    }\n  }\n\n  const index = this._length;\n  this._array[index] = element;\n  this._length++;\n  pushUp(this, index);\n\n  return removedElement;\n};\n\n/**\n * Removes the minimum element from the queue and returns it.\n * If the queue is empty, the return value is undefined.\n *\n * @returns {*|undefined} The minimum element, or undefined if the queue is empty.\n */\nDoubleEndedPriorityQueue.prototype.removeMinimum = function () {\n  const length = this._length;\n  if (length === 0) {\n    return undefined;\n  }\n\n  this._length--;\n\n  // The minimum element is always the root\n  const minimumElement = this._array[0];\n\n  if (length >= 2) {\n    this._array[0] = this._array[length - 1];\n    pushDown(this, 0);\n  }\n\n  // Dereference removed element\n  this._array[length - 1] = undefined;\n\n  return minimumElement;\n};\n\n/**\n * Removes the maximum element from the queue and returns it.\n * If the queue is empty, the return value is undefined.\n *\n * @returns {*|undefined} The maximum element, or undefined if the queue is empty.\n */\nDoubleEndedPriorityQueue.prototype.removeMaximum = function () {\n  const length = this._length;\n  if (length === 0) {\n    return undefined;\n  }\n\n  this._length--;\n  let maximumElement;\n\n  // If the root has no children, the maximum is the root.\n  // If the root has one child, the maximum is the child.\n  if (length <= 2) {\n    maximumElement = this._array[length - 1];\n  } else {\n    // Otherwise, the maximum is the larger of the root's two children.\n    const maximumElementIndex = greaterThan(this, 1, 2) ? 1 : 2;\n    maximumElement = this._array[maximumElementIndex];\n\n    // Re-balance the heap\n    this._array[maximumElementIndex] = this._array[length - 1];\n    if (length >= 4) {\n      pushDown(this, maximumElementIndex);\n    }\n  }\n\n  // Dereference removed element\n  this._array[length - 1] = undefined;\n\n  return maximumElement;\n};\n\n/**\n * Gets the minimum element in the queue.\n * If the queue is empty, the result is undefined.\n *\n * @returns {*|undefined} element\n */\n\nDoubleEndedPriorityQueue.prototype.getMinimum = function () {\n  const length = this._length;\n  if (length === 0) {\n    return undefined;\n  }\n\n  // The minimum element is always the root\n  return this._array[0];\n};\n\n/**\n * Gets the maximum element in the queue.\n * If the queue is empty, the result is undefined.\n *\n * @returns {*|undefined} element\n */\nDoubleEndedPriorityQueue.prototype.getMaximum = function () {\n  const length = this._length;\n  if (length === 0) {\n    return undefined;\n  }\n\n  // If the root has no children, the maximum is the root.\n  // If the root has one child, the maximum is the child.\n  if (length <= 2) {\n    return this._array[length - 1];\n  }\n\n  // Otherwise, the maximum is the larger of the root's two children.\n  return this._array[greaterThan(this, 1, 2) ? 1 : 2];\n};\n\n// Helper functions\n\nfunction swap(that, indexA, indexB) {\n  const array = that._array;\n  const temp = array[indexA];\n  array[indexA] = array[indexB];\n  array[indexB] = temp;\n}\n\nfunction lessThan(that, indexA, indexB) {\n  return that._comparator(that._array[indexA], that._array[indexB]) < 0.0;\n}\n\nfunction greaterThan(that, indexA, indexB) {\n  return that._comparator(that._array[indexA], that._array[indexB]) > 0.0;\n}\n\nfunction pushUp(that, index) {\n  if (index === 0) {\n    return;\n  }\n  const onMinLevel = Math.floor(CesiumMath.log2(index + 1)) % 2 === 0;\n  const parentIndex = Math.floor((index - 1) / 2);\n  const lessThanParent = lessThan(that, index, parentIndex);\n\n  // Get the element onto the correct level if it's not already\n  if (lessThanParent !== onMinLevel) {\n    swap(that, index, parentIndex);\n    index = parentIndex;\n  }\n\n  // Swap element with grandparent as long as it:\n  // 1) has a grandparent\n  // 2A) is less than the grandparent when on a min level\n  // 2B) is greater than the grandparent when on a max level\n  while (index >= 3) {\n    const grandparentIndex = Math.floor((index - 3) / 4);\n    if (lessThan(that, index, grandparentIndex) !== lessThanParent) {\n      break;\n    }\n    swap(that, index, grandparentIndex);\n    index = grandparentIndex;\n  }\n}\n\nfunction pushDown(that, index) {\n  const length = that._length;\n  const onMinLevel = Math.floor(CesiumMath.log2(index + 1)) % 2 === 0;\n\n  // Loop as long as there is a left child.\n  let leftChildIndex;\n  while ((leftChildIndex = 2 * index + 1) < length) {\n    // Find the minimum (or maximum) child or grandchild\n    let target = leftChildIndex;\n    const rightChildIndex = leftChildIndex + 1;\n    if (rightChildIndex < length) {\n      if (lessThan(that, rightChildIndex, target) === onMinLevel) {\n        target = rightChildIndex;\n      }\n      const grandChildStart = 2 * leftChildIndex + 1;\n      const grandChildCount = Math.max(\n        Math.min(length - grandChildStart, 4),\n        0\n      );\n      for (let i = 0; i < grandChildCount; i++) {\n        const grandChildIndex = grandChildStart + i;\n        if (lessThan(that, grandChildIndex, target) === onMinLevel) {\n          target = grandChildIndex;\n        }\n      }\n    }\n\n    // Swap the element into the correct spot\n    if (lessThan(that, target, index) === onMinLevel) {\n      swap(that, target, index);\n      if (target !== leftChildIndex && target !== rightChildIndex) {\n        const parentOfGrandchildIndex = Math.floor((target - 1) / 2);\n        if (greaterThan(that, target, parentOfGrandchildIndex) === onMinLevel) {\n          swap(that, target, parentOfGrandchildIndex);\n        }\n      }\n    }\n\n    index = target;\n  }\n}\n\n/**\n * The comparator to use for the queue.\n * @callback DoubleEndedPriorityQueue.ComparatorCallback\n * @param {*} a An element in the queue.\n * @param {*} b An element in the queue.\n * @returns {Number} If the result of the comparison is less than 0, a is lower priority than b.\n */\nexport default DoubleEndedPriorityQueue;\n","import defined from \"./defined.js\";\n\n/**\n * @private\n */\nfunction DoublyLinkedList() {\n  this.head = undefined;\n  this.tail = undefined;\n  this._length = 0;\n}\n\nObject.defineProperties(DoublyLinkedList.prototype, {\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n});\n\n/**\n * @private\n */\nfunction DoublyLinkedListNode(item, previous, next) {\n  this.item = item;\n  this.previous = previous;\n  this.next = next;\n}\n\n/**\n * Adds the item to the end of the list\n * @param {*} [item]\n * @return {DoublyLinkedListNode}\n */\nDoublyLinkedList.prototype.add = function (item) {\n  const node = new DoublyLinkedListNode(item, this.tail, undefined);\n\n  if (defined(this.tail)) {\n    this.tail.next = node;\n    this.tail = node;\n  } else {\n    this.head = node;\n    this.tail = node;\n  }\n\n  ++this._length;\n\n  return node;\n};\n\nfunction remove(list, node) {\n  if (defined(node.previous) && defined(node.next)) {\n    node.previous.next = node.next;\n    node.next.previous = node.previous;\n  } else if (defined(node.previous)) {\n    // Remove last node\n    node.previous.next = undefined;\n    list.tail = node.previous;\n  } else if (defined(node.next)) {\n    // Remove first node\n    node.next.previous = undefined;\n    list.head = node.next;\n  } else {\n    // Remove last node in the linked list\n    list.head = undefined;\n    list.tail = undefined;\n  }\n\n  node.next = undefined;\n  node.previous = undefined;\n}\n\n/**\n * Removes the given node from the list\n * @param {DoublyLinkedListNode} node\n */\nDoublyLinkedList.prototype.remove = function (node) {\n  if (!defined(node)) {\n    return;\n  }\n\n  remove(this, node);\n\n  --this._length;\n};\n\n/**\n * Moves nextNode after node\n * @param {DoublyLinkedListNode} node\n * @param {DoublyLinkedListNode} nextNode\n */\nDoublyLinkedList.prototype.splice = function (node, nextNode) {\n  if (node === nextNode) {\n    return;\n  }\n\n  // Remove nextNode, then insert after node\n  remove(this, nextNode);\n\n  const oldNodeNext = node.next;\n  node.next = nextNode;\n\n  // nextNode is the new tail\n  if (this.tail === node) {\n    this.tail = nextNode;\n  } else {\n    oldNodeNext.previous = nextNode;\n  }\n\n  nextNode.next = oldNodeNext;\n  nextNode.previous = node;\n};\nexport default DoublyLinkedList;\n","import binarySearch from \"./binarySearch.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport EarthOrientationParametersSample from \"./EarthOrientationParametersSample.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport LeapSecond from \"./LeapSecond.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TimeConstants from \"./TimeConstants.js\";\nimport TimeStandard from \"./TimeStandard.js\";\n\n/**\n * Specifies Earth polar motion coordinates and the difference between UT1 and UTC.\n * These Earth Orientation Parameters (EOP) are primarily used in the transformation from\n * the International Celestial Reference Frame (ICRF) to the International Terrestrial\n * Reference Frame (ITRF).\n *\n * @alias EarthOrientationParameters\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Resource|String} [options.url] The URL from which to obtain EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.  If options.data is specified, this parameter is\n *                 ignored.\n * @param {Object} [options.data] The actual EOP data.  If neither this\n *                 parameter nor options.data is specified, all EOP values are assumed\n *                 to be 0.0.\n * @param {Boolean} [options.addNewLeapSeconds=true] True if leap seconds that\n *                  are specified in the EOP data but not in {@link JulianDate.leapSeconds}\n *                  should be added to {@link JulianDate.leapSeconds}.  False if\n *                  new leap seconds should be handled correctly in the context\n *                  of the EOP data but otherwise ignored.\n *\n * @example\n * // An example EOP data file, EOP.json:\n * {\n *   \"columnNames\" : [\"dateIso8601\",\"modifiedJulianDateUtc\",\"xPoleWanderRadians\",\"yPoleWanderRadians\",\"ut1MinusUtcSeconds\",\"lengthOfDayCorrectionSeconds\",\"xCelestialPoleOffsetRadians\",\"yCelestialPoleOffsetRadians\",\"taiMinusUtcSeconds\"],\n *   \"samples\" : [\n *      \"2011-07-01T00:00:00Z\",55743.0,2.117957047295119e-7,2.111518721609984e-6,-0.2908948,-2.956e-4,3.393695767766752e-11,3.3452143996557983e-10,34.0,\n *      \"2011-07-02T00:00:00Z\",55744.0,2.193297093339541e-7,2.115460256837405e-6,-0.29065,-1.824e-4,-8.241832578862112e-11,5.623838700870617e-10,34.0,\n *      \"2011-07-03T00:00:00Z\",55745.0,2.262286080161428e-7,2.1191157519929706e-6,-0.2905572,1.9e-6,-3.490658503988659e-10,6.981317007977318e-10,34.0\n *   ]\n * }\n *\n * @example\n * // Loading the EOP data\n * const eop = new Cesium.EarthOrientationParameters({ url : 'Data/EOP.json' });\n * Cesium.Transforms.earthOrientationParameters = eop;\n *\n * @private\n */\nfunction EarthOrientationParameters(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._dates = undefined;\n  this._samples = undefined;\n\n  this._dateColumn = -1;\n  this._xPoleWanderRadiansColumn = -1;\n  this._yPoleWanderRadiansColumn = -1;\n  this._ut1MinusUtcSecondsColumn = -1;\n  this._xCelestialPoleOffsetRadiansColumn = -1;\n  this._yCelestialPoleOffsetRadiansColumn = -1;\n  this._taiMinusUtcSecondsColumn = -1;\n\n  this._columnCount = 0;\n  this._lastIndex = -1;\n\n  this._downloadPromise = undefined;\n  this._dataError = undefined;\n\n  this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);\n\n  if (defined(options.data)) {\n    // Use supplied EOP data.\n    onDataReady(this, options.data);\n  } else if (defined(options.url)) {\n    const resource = Resource.createIfNeeded(options.url);\n\n    // Download EOP data.\n    const that = this;\n    this._downloadPromise = resource\n      .fetchJson()\n      .then(function (eopData) {\n        onDataReady(that, eopData);\n      })\n      .catch(function () {\n        that._dataError = `An error occurred while retrieving the EOP data from the URL ${resource.url}.`;\n      });\n  } else {\n    // Use all zeros for EOP data.\n    onDataReady(this, {\n      columnNames: [\n        \"dateIso8601\",\n        \"modifiedJulianDateUtc\",\n        \"xPoleWanderRadians\",\n        \"yPoleWanderRadians\",\n        \"ut1MinusUtcSeconds\",\n        \"lengthOfDayCorrectionSeconds\",\n        \"xCelestialPoleOffsetRadians\",\n        \"yCelestialPoleOffsetRadians\",\n        \"taiMinusUtcSeconds\",\n      ],\n      samples: [],\n    });\n  }\n}\n\n/**\n * A default {@link EarthOrientationParameters} instance that returns zero for all EOP values.\n */\nEarthOrientationParameters.NONE = Object.freeze({\n  getPromiseToLoad: function () {\n    return Promise.resolve();\n  },\n  compute: function (date, result) {\n    if (!defined(result)) {\n      result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n    } else {\n      result.xPoleWander = 0.0;\n      result.yPoleWander = 0.0;\n      result.xPoleOffset = 0.0;\n      result.yPoleOffset = 0.0;\n      result.ut1MinusUtc = 0.0;\n    }\n    return result;\n  },\n});\n\n/**\n * Gets a promise that, when resolved, indicates that the EOP data has been loaded and is\n * ready to use.\n *\n * @returns {Promise<void>} The promise.\n */\nEarthOrientationParameters.prototype.getPromiseToLoad = function () {\n  return Promise.resolve(this._downloadPromise);\n};\n\n/**\n * Computes the Earth Orientation Parameters (EOP) for a given date by interpolating.\n * If the EOP data has not yet been download, this method returns undefined.\n *\n * @param {JulianDate} date The date for each to evaluate the EOP.\n * @param {EarthOrientationParametersSample} [result] The instance to which to copy the result.\n *        If this parameter is undefined, a new instance is created and returned.\n * @returns {EarthOrientationParametersSample} The EOP evaluated at the given date, or\n *          undefined if the data necessary to evaluate EOP at the date has not yet been\n *          downloaded.\n *\n * @exception {RuntimeError} The loaded EOP data has an error and cannot be used.\n *\n * @see EarthOrientationParameters#getPromiseToLoad\n */\nEarthOrientationParameters.prototype.compute = function (date, result) {\n  // We cannot compute until the samples are available.\n  if (!defined(this._samples)) {\n    if (defined(this._dataError)) {\n      throw new RuntimeError(this._dataError);\n    }\n\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new EarthOrientationParametersSample(0.0, 0.0, 0.0, 0.0, 0.0);\n  }\n\n  if (this._samples.length === 0) {\n    result.xPoleWander = 0.0;\n    result.yPoleWander = 0.0;\n    result.xPoleOffset = 0.0;\n    result.yPoleOffset = 0.0;\n    result.ut1MinusUtc = 0.0;\n    return result;\n  }\n\n  const dates = this._dates;\n  const lastIndex = this._lastIndex;\n\n  let before = 0;\n  let after = 0;\n  if (defined(lastIndex)) {\n    const previousIndexDate = dates[lastIndex];\n    const nextIndexDate = dates[lastIndex + 1];\n    const isAfterPrevious = JulianDate.lessThanOrEquals(\n      previousIndexDate,\n      date\n    );\n    const isAfterLastSample = !defined(nextIndexDate);\n    const isBeforeNext =\n      isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);\n\n    if (isAfterPrevious && isBeforeNext) {\n      before = lastIndex;\n\n      if (!isAfterLastSample && nextIndexDate.equals(date)) {\n        ++before;\n      }\n      after = before + 1;\n\n      interpolate(this, dates, this._samples, date, before, after, result);\n      return result;\n    }\n  }\n\n  let index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);\n  if (index >= 0) {\n    // If the next entry is the same date, use the later entry.  This way, if two entries\n    // describe the same moment, one before a leap second and the other after, then we will use\n    // the post-leap second data.\n    if (index < dates.length - 1 && dates[index + 1].equals(date)) {\n      ++index;\n    }\n    before = index;\n    after = index;\n  } else {\n    after = ~index;\n    before = after - 1;\n\n    // Use the first entry if the date requested is before the beginning of the data.\n    if (before < 0) {\n      before = 0;\n    }\n  }\n\n  this._lastIndex = before;\n\n  interpolate(this, dates, this._samples, date, before, after, result);\n  return result;\n};\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind);\n}\n\nfunction onDataReady(eop, eopData) {\n  if (!defined(eopData.columnNames)) {\n    eop._dataError =\n      \"Error in loaded EOP data: The columnNames property is required.\";\n    return;\n  }\n\n  if (!defined(eopData.samples)) {\n    eop._dataError =\n      \"Error in loaded EOP data: The samples property is required.\";\n    return;\n  }\n\n  const dateColumn = eopData.columnNames.indexOf(\"modifiedJulianDateUtc\");\n  const xPoleWanderRadiansColumn = eopData.columnNames.indexOf(\n    \"xPoleWanderRadians\"\n  );\n  const yPoleWanderRadiansColumn = eopData.columnNames.indexOf(\n    \"yPoleWanderRadians\"\n  );\n  const ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf(\n    \"ut1MinusUtcSeconds\"\n  );\n  const xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"xCelestialPoleOffsetRadians\"\n  );\n  const yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf(\n    \"yCelestialPoleOffsetRadians\"\n  );\n  const taiMinusUtcSecondsColumn = eopData.columnNames.indexOf(\n    \"taiMinusUtcSeconds\"\n  );\n\n  if (\n    dateColumn < 0 ||\n    xPoleWanderRadiansColumn < 0 ||\n    yPoleWanderRadiansColumn < 0 ||\n    ut1MinusUtcSecondsColumn < 0 ||\n    xCelestialPoleOffsetRadiansColumn < 0 ||\n    yCelestialPoleOffsetRadiansColumn < 0 ||\n    taiMinusUtcSecondsColumn < 0\n  ) {\n    eop._dataError =\n      \"Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns\";\n    return;\n  }\n\n  const samples = (eop._samples = eopData.samples);\n  const dates = (eop._dates = []);\n\n  eop._dateColumn = dateColumn;\n  eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;\n  eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;\n  eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;\n  eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;\n  eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;\n  eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;\n\n  eop._columnCount = eopData.columnNames.length;\n  eop._lastIndex = undefined;\n\n  let lastTaiMinusUtc;\n\n  const addNewLeapSeconds = eop._addNewLeapSeconds;\n\n  // Convert the ISO8601 dates to JulianDates.\n  for (let i = 0, len = samples.length; i < len; i += eop._columnCount) {\n    const mjd = samples[i + dateColumn];\n    const taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];\n    const day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;\n    const date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);\n    dates.push(date);\n\n    if (addNewLeapSeconds) {\n      if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {\n        // We crossed a leap second boundary, so add the leap second\n        // if it does not already exist.\n        const leapSeconds = JulianDate.leapSeconds;\n        const leapSecondIndex = binarySearch(\n          leapSeconds,\n          date,\n          compareLeapSecondDates\n        );\n        if (leapSecondIndex < 0) {\n          const leapSecond = new LeapSecond(date, taiMinusUtc);\n          leapSeconds.splice(~leapSecondIndex, 0, leapSecond);\n        }\n      }\n      lastTaiMinusUtc = taiMinusUtc;\n    }\n  }\n}\n\nfunction fillResultFromIndex(eop, samples, index, columnCount, result) {\n  const start = index * columnCount;\n  result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];\n  result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];\n  result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];\n  result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];\n  result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];\n}\n\nfunction linearInterp(dx, y1, y2) {\n  return y1 + dx * (y2 - y1);\n}\n\nfunction interpolate(eop, dates, samples, date, before, after, result) {\n  const columnCount = eop._columnCount;\n\n  // First check the bounds on the EOP data\n  // If we are after the bounds of the data, return zeros.\n  // The 'before' index should never be less than zero.\n  if (after > dates.length - 1) {\n    result.xPoleWander = 0;\n    result.yPoleWander = 0;\n    result.xPoleOffset = 0;\n    result.yPoleOffset = 0;\n    result.ut1MinusUtc = 0;\n    return result;\n  }\n\n  const beforeDate = dates[before];\n  const afterDate = dates[after];\n  if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {\n    fillResultFromIndex(eop, samples, before, columnCount, result);\n    return result;\n  } else if (date.equals(afterDate)) {\n    fillResultFromIndex(eop, samples, after, columnCount, result);\n    return result;\n  }\n\n  const factor =\n    JulianDate.secondsDifference(date, beforeDate) /\n    JulianDate.secondsDifference(afterDate, beforeDate);\n\n  const startBefore = before * columnCount;\n  const startAfter = after * columnCount;\n\n  // Handle UT1 leap second edge case\n  let beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];\n  let afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];\n\n  const offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;\n  if (offsetDifference > 0.5 || offsetDifference < -0.5) {\n    // The absolute difference between the values is more than 0.5, so we may have\n    // crossed a leap second.  Check if this is the case and, if so, adjust the\n    // afterValue to account for the leap second.  This way, our interpolation will\n    // produce reasonable results.\n    const beforeTaiMinusUtc =\n      samples[startBefore + eop._taiMinusUtcSecondsColumn];\n    const afterTaiMinusUtc =\n      samples[startAfter + eop._taiMinusUtcSecondsColumn];\n    if (beforeTaiMinusUtc !== afterTaiMinusUtc) {\n      if (afterDate.equals(date)) {\n        // If we are at the end of the leap second interval, take the second value\n        // Otherwise, the interpolation below will yield the wrong side of the\n        // discontinuity\n        // At the end of the leap second, we need to start accounting for the jump\n        beforeUt1MinusUtc = afterUt1MinusUtc;\n      } else {\n        // Otherwise, remove the leap second so that the interpolation is correct\n        afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;\n      }\n    }\n  }\n\n  result.xPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._xPoleWanderRadiansColumn],\n    samples[startAfter + eop._xPoleWanderRadiansColumn]\n  );\n  result.yPoleWander = linearInterp(\n    factor,\n    samples[startBefore + eop._yPoleWanderRadiansColumn],\n    samples[startAfter + eop._yPoleWanderRadiansColumn]\n  );\n  result.xPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]\n  );\n  result.yPoleOffset = linearInterp(\n    factor,\n    samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn],\n    samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]\n  );\n  result.ut1MinusUtc = linearInterp(\n    factor,\n    beforeUt1MinusUtc,\n    afterUt1MinusUtc\n  );\n  return result;\n}\nexport default EarthOrientationParameters;\n","/**\n * A set of Earth Orientation Parameters (EOP) sampled at a time.\n *\n * @alias EarthOrientationParametersSample\n * @constructor\n *\n * @param {Number} xPoleWander The pole wander about the X axis, in radians.\n * @param {Number} yPoleWander The pole wander about the Y axis, in radians.\n * @param {Number} xPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.\n * @param {Number} yPoleOffset The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.\n * @param {Number} ut1MinusUtc The difference in time standards, UT1 - UTC, in seconds.\n *\n * @private\n */\nfunction EarthOrientationParametersSample(\n  xPoleWander,\n  yPoleWander,\n  xPoleOffset,\n  yPoleOffset,\n  ut1MinusUtc\n) {\n  /**\n   * The pole wander about the X axis, in radians.\n   * @type {Number}\n   */\n  this.xPoleWander = xPoleWander;\n\n  /**\n   * The pole wander about the Y axis, in radians.\n   * @type {Number}\n   */\n  this.yPoleWander = yPoleWander;\n\n  /**\n   * The offset to the Celestial Intermediate Pole (CIP) about the X axis, in radians.\n   * @type {Number}\n   */\n  this.xPoleOffset = xPoleOffset;\n\n  /**\n   * The offset to the Celestial Intermediate Pole (CIP) about the Y axis, in radians.\n   * @type {Number}\n   */\n  this.yPoleOffset = yPoleOffset;\n\n  /**\n   * The difference in time standards, UT1 - UTC, in seconds.\n   * @type {Number}\n   */\n  this.ut1MinusUtc = ut1MinusUtc;\n}\nexport default EarthOrientationParametersSample;\n","import Tween from \"../ThirdParty/Tween.js\";\n\n/**\n * Easing functions for use with TweenCollection.  These function are from\n * {@link https://github.com/sole/tween.js/|Tween.js} and Robert Penner.  See the\n * {@link http://sole.github.io/tween.js/examples/03_graphs.html|Tween.js graphs for each function}.\n *\n * @namespace\n */\nconst EasingFunction = {\n  /**\n   * Linear easing.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  LINEAR_NONE: Tween.Easing.Linear.None,\n\n  /**\n   * Quadratic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUADRATIC_IN: Tween.Easing.Quadratic.In,\n  /**\n   * Quadratic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUADRATIC_OUT: Tween.Easing.Quadratic.Out,\n  /**\n   * Quadratic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUADRATIC_IN_OUT: Tween.Easing.Quadratic.InOut,\n\n  /**\n   * Cubic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CUBIC_IN: Tween.Easing.Cubic.In,\n  /**\n   * Cubic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CUBIC_OUT: Tween.Easing.Cubic.Out,\n  /**\n   * Cubic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CUBIC_IN_OUT: Tween.Easing.Cubic.InOut,\n\n  /**\n   * Quartic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUARTIC_IN: Tween.Easing.Quartic.In,\n  /**\n   * Quartic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUARTIC_OUT: Tween.Easing.Quartic.Out,\n  /**\n   * Quartic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUARTIC_IN_OUT: Tween.Easing.Quartic.InOut,\n\n  /**\n   * Quintic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUINTIC_IN: Tween.Easing.Quintic.In,\n  /**\n   * Quintic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUINTIC_OUT: Tween.Easing.Quintic.Out,\n  /**\n   * Quintic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  QUINTIC_IN_OUT: Tween.Easing.Quintic.InOut,\n\n  /**\n   * Sinusoidal in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  SINUSOIDAL_IN: Tween.Easing.Sinusoidal.In,\n  /**\n   * Sinusoidal out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  SINUSOIDAL_OUT: Tween.Easing.Sinusoidal.Out,\n  /**\n   * Sinusoidal in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  SINUSOIDAL_IN_OUT: Tween.Easing.Sinusoidal.InOut,\n\n  /**\n   * Exponential in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  EXPONENTIAL_IN: Tween.Easing.Exponential.In,\n  /**\n   * Exponential out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  EXPONENTIAL_OUT: Tween.Easing.Exponential.Out,\n  /**\n   * Exponential in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  EXPONENTIAL_IN_OUT: Tween.Easing.Exponential.InOut,\n\n  /**\n   * Circular in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CIRCULAR_IN: Tween.Easing.Circular.In,\n  /**\n   * Circular out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CIRCULAR_OUT: Tween.Easing.Circular.Out,\n  /**\n   * Circular in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  CIRCULAR_IN_OUT: Tween.Easing.Circular.InOut,\n\n  /**\n   * Elastic in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  ELASTIC_IN: Tween.Easing.Elastic.In,\n  /**\n   * Elastic out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  ELASTIC_OUT: Tween.Easing.Elastic.Out,\n  /**\n   * Elastic in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  ELASTIC_IN_OUT: Tween.Easing.Elastic.InOut,\n\n  /**\n   * Back in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BACK_IN: Tween.Easing.Back.In,\n  /**\n   * Back out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BACK_OUT: Tween.Easing.Back.Out,\n  /**\n   * Back in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BACK_IN_OUT: Tween.Easing.Back.InOut,\n\n  /**\n   * Bounce in.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BOUNCE_IN: Tween.Easing.Bounce.In,\n  /**\n   * Bounce out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BOUNCE_OUT: Tween.Easing.Bounce.Out,\n  /**\n   * Bounce in then out.\n   *\n   * @type {EasingFunction.Callback}\n   * @constant\n   */\n  BOUNCE_IN_OUT: Tween.Easing.Bounce.InOut,\n};\n\n/**\n * Function interface for implementing a custom easing function.\n * @callback EasingFunction.Callback\n * @param {Number} time The time in the range <code>[0, 1]</code>.\n * @returns {Number} The value of the function at the given time.\n *\n * @example\n * function quadraticIn(time) {\n *     return time * time;\n * }\n *\n * @example\n * function quadraticOut(time) {\n *     return time * (2.0 - time);\n * }\n */\n\nexport default Object.freeze(EasingFunction);\n","import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryInstance from \"./GeometryInstance.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchCartesian4 = new Cartesian3();\nconst texCoordScratch = new Cartesian2();\nconst textureMatrixScratch = new Matrix3();\nconst tangentMatrixScratch = new Matrix3();\nconst quaternionScratch = new Quaternion();\n\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\n\nconst scratchCartographic = new Cartographic();\nconst projectedCenterScratch = new Cartesian3();\n\nconst scratchMinTexCoord = new Cartesian2();\nconst scratchMaxTexCoord = new Cartesian2();\n\nfunction computeTopBottomAttributes(positions, options, extrude) {\n  const vertexFormat = options.vertexFormat;\n  const center = options.center;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const ellipsoid = options.ellipsoid;\n  const stRotation = options.stRotation;\n  const size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n  const shadowVolume = options.shadowVolume;\n\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(size * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  const extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  let textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n\n  const projection = new GeographicProjection(ellipsoid);\n  const projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch\n  );\n\n  const geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n\n  let textureMatrix = textureMatrixScratch;\n  let tangentMatrix = tangentMatrixScratch;\n  if (stRotation !== 0) {\n    let rotation = Quaternion.fromAxisAngle(\n      geodeticNormal,\n      stRotation,\n      quaternionScratch\n    );\n    textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n    rotation = Quaternion.fromAxisAngle(\n      geodeticNormal,\n      -stRotation,\n      quaternionScratch\n    );\n    tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n  } else {\n    textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n    tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n  }\n\n  const minTexCoord = Cartesian2.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord\n  );\n  const maxTexCoord = Cartesian2.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord\n  );\n\n  let length = positions.length;\n  const bottomOffset = extrude ? length : 0;\n  const stOffset = (bottomOffset / 3) * 2;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n    const position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n\n    if (vertexFormat.st) {\n      const rotatedPoint = Matrix3.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2\n      );\n      const projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3\n      );\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      if (extrude) {\n        textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n        textureCoordinates[textureCoordIndex + 1 + stOffset] =\n          texCoordScratch.y;\n      }\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    if (\n      vertexFormat.normal ||\n      vertexFormat.tangent ||\n      vertexFormat.bitangent ||\n      shadowVolume\n    ) {\n      normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n      if (shadowVolume) {\n        extrudeNormals[i + bottomOffset] = -normal.x;\n        extrudeNormals[i1 + bottomOffset] = -normal.y;\n        extrudeNormals[i2 + bottomOffset] = -normal.z;\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent\n      ) {\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n          tangent = Cartesian3.normalize(\n            Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent),\n            tangent\n          );\n          Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n        }\n        if (vertexFormat.normal) {\n          normals[i] = normal.x;\n          normals[i1] = normal.y;\n          normals[i2] = normal.z;\n          if (extrude) {\n            normals[i + bottomOffset] = -normal.x;\n            normals[i1 + bottomOffset] = -normal.y;\n            normals[i2 + bottomOffset] = -normal.z;\n          }\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[i] = tangent.x;\n          tangents[i1] = tangent.y;\n          tangents[i2] = tangent.z;\n          if (extrude) {\n            tangents[i + bottomOffset] = -tangent.x;\n            tangents[i1 + bottomOffset] = -tangent.y;\n            tangents[i2 + bottomOffset] = -tangent.z;\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = Cartesian3.normalize(\n            Cartesian3.cross(normal, tangent, bitangent),\n            bitangent\n          );\n          bitangents[i] = bitangent.x;\n          bitangents[i1] = bitangent.y;\n          bitangents[i2] = bitangent.z;\n          if (extrude) {\n            bitangents[i + bottomOffset] = bitangent.x;\n            bitangents[i1 + bottomOffset] = bitangent.y;\n            bitangents[i2 + bottomOffset] = bitangent.z;\n          }\n        }\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (let k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    const finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(\n      positions,\n      options,\n      extrude\n    );\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if (extrude && defined(options.offsetAttribute)) {\n    let offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction topIndices(numPts) {\n  // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n  //              = -1 + 4 * ((n * ( n + 1)) / 2)\n  // total triangles = 2 * numTrangles in half\n  // indices = total triangles * 3;\n  // Substitute numPts for n above\n\n  const indices = new Array(12 * (numPts * (numPts + 1)) - 6);\n  let indicesIndex = 0;\n  let prevIndex;\n  let numInterior;\n  let positionIndex;\n  let i;\n  let j;\n  // Indices triangles to the 'right' of the north vector\n\n  prevIndex = 0;\n  positionIndex = 1;\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  for (i = 2; i < numPts + 1; ++i) {\n    positionIndex = i * (i + 1) - 1;\n    prevIndex = (i - 1) * i - 1;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  // Indices for center column of triangles\n  numInterior = numPts * 2;\n  ++positionIndex;\n  ++prevIndex;\n  for (i = 0; i < numInterior - 1; ++i) {\n    indices[indicesIndex++] = positionIndex;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  indices[indicesIndex++] = positionIndex;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  indices[indicesIndex++] = positionIndex++;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  // Reverse the process creating indices to the 'left' of the north vector\n  ++prevIndex;\n  for (i = numPts - 1; i > 1; --i) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = positionIndex++;\n  }\n\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n  return indices;\n}\n\nlet boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  const center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter\n  );\n  boundingSphereCenter = Cartesian3.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter\n  );\n  const boundingSphere = new BoundingSphere(\n    boundingSphereCenter,\n    options.semiMajorAxis\n  );\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    true,\n    false\n  );\n  const positions = cep.positions;\n  const numPts = cep.numPts;\n  const attributes = computeTopBottomAttributes(positions, options, false);\n  let indices = topIndices(numPts);\n  indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction computeWallAttributes(positions, options) {\n  const vertexFormat = options.vertexFormat;\n  const center = options.center;\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const ellipsoid = options.ellipsoid;\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const stRotation = options.stRotation;\n  const size = (positions.length / 3) * 2;\n\n  const finalPositions = new Float64Array(size * 3);\n  const textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  const normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(size * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  const shadowVolume = options.shadowVolume;\n  const extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  let textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  let normal = scratchNormal;\n  let tangent = scratchTangent;\n  let bitangent = scratchBitangent;\n\n  const projection = new GeographicProjection(ellipsoid);\n  const projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch\n  );\n\n  const geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n  const rotation = Quaternion.fromAxisAngle(\n    geodeticNormal,\n    stRotation,\n    quaternionScratch\n  );\n  const textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n\n  const minTexCoord = Cartesian2.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord\n  );\n  const maxTexCoord = Cartesian2.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord\n  );\n\n  let length = positions.length;\n  const stOffset = (length / 3) * 2;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n    let position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    let extrudedPosition;\n\n    if (vertexFormat.st) {\n      const rotatedPoint = Matrix3.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2\n      );\n      const projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3\n      );\n      Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    position = ellipsoid.scaleToGeodeticSurface(position, position);\n    extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n    if (shadowVolume) {\n      extrudeNormals[i + length] = -normal.x;\n      extrudeNormals[i1 + length] = -normal.y;\n      extrudeNormals[i2 + length] = -normal.z;\n    }\n\n    let scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian4\n    );\n    position = Cartesian3.add(position, scaledNormal, position);\n    scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      extrudedHeight,\n      scaledNormal\n    );\n    extrudedPosition = Cartesian3.add(\n      extrudedPosition,\n      scaledNormal,\n      extrudedPosition\n    );\n\n    if (vertexFormat.position) {\n      finalPositions[i + length] = extrudedPosition.x;\n      finalPositions[i1 + length] = extrudedPosition.y;\n      finalPositions[i2 + length] = extrudedPosition.z;\n\n      finalPositions[i] = position.x;\n      finalPositions[i1] = position.y;\n      finalPositions[i2] = position.z;\n    }\n\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      bitangent = Cartesian3.clone(normal, bitangent);\n      const next = Cartesian3.fromArray(\n        positions,\n        (i + 3) % length,\n        scratchCartesian4\n      );\n      Cartesian3.subtract(next, position, next);\n      const bottom = Cartesian3.subtract(\n        extrudedPosition,\n        position,\n        scratchCartesian3\n      );\n\n      normal = Cartesian3.normalize(\n        Cartesian3.cross(bottom, next, normal),\n        normal\n      );\n\n      if (vertexFormat.normal) {\n        normals[i] = normal.x;\n        normals[i1] = normal.y;\n        normals[i2] = normal.z;\n\n        normals[i + length] = normal.x;\n        normals[i1 + length] = normal.y;\n        normals[i2 + length] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangent = Cartesian3.normalize(\n          Cartesian3.cross(bitangent, normal, tangent),\n          tangent\n        );\n        tangents[i] = tangent.x;\n        tangents[i1] = tangent.y;\n        tangents[i2] = tangent.z;\n\n        tangents[i + length] = tangent.x;\n        tangents[i + 1 + length] = tangent.y;\n        tangents[i + 2 + length] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[i] = bitangent.x;\n        bitangents[i1] = bitangent.y;\n        bitangents[i2] = bitangent.z;\n\n        bitangents[i + length] = bitangent.x;\n        bitangents[i1 + length] = bitangent.y;\n        bitangents[i2 + length] = bitangent.z;\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (let k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if (defined(options.offsetAttribute)) {\n    let offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n    }\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction computeWallIndices(positions) {\n  const length = positions.length / 3;\n  const indices = IndexDatatype.createTypedArray(length, length * 6);\n  let index = 0;\n  for (let i = 0; i < length; i++) {\n    const UL = i;\n    const LL = i + length;\n    const UR = (UL + 1) % length;\n    const LR = UR + length;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n  }\n\n  return indices;\n}\n\nconst topBoundingSphere = new BoundingSphere();\nconst bottomBoundingSphere = new BoundingSphere();\n\nfunction computeExtrudedEllipse(options) {\n  const center = options.center;\n  const ellipsoid = options.ellipsoid;\n  const semiMajorAxis = options.semiMajorAxis;\n  let scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1\n  );\n  topBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal\n  );\n  bottomBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    true,\n    true\n  );\n  const positions = cep.positions;\n  const numPts = cep.numPts;\n  const outerPositions = cep.outerPositions;\n  const boundingSphere = BoundingSphere.union(\n    topBoundingSphere,\n    bottomBoundingSphere\n  );\n  const topBottomAttributes = computeTopBottomAttributes(\n    positions,\n    options,\n    true\n  );\n  let indices = topIndices(numPts);\n  const length = indices.length;\n  indices.length = length * 2;\n  const posLength = positions.length / 3;\n  for (let i = 0; i < length; i += 3) {\n    indices[i + length] = indices[i + 2] + posLength;\n    indices[i + 1 + length] = indices[i + 1] + posLength;\n    indices[i + 2 + length] = indices[i] + posLength;\n  }\n\n  const topBottomIndices = IndexDatatype.createTypedArray(\n    (posLength * 2) / 3,\n    indices\n  );\n\n  const topBottomGeo = new Geometry({\n    attributes: topBottomAttributes,\n    indices: topBottomIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  const wallAttributes = computeWallAttributes(outerPositions, options);\n  indices = computeWallIndices(outerPositions);\n  const wallIndices = IndexDatatype.createTypedArray(\n    (outerPositions.length * 2) / 3,\n    indices\n  );\n\n  const wallGeo = new Geometry({\n    attributes: wallAttributes,\n    indices: wallIndices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  });\n\n  const geo = GeometryPipeline.combineInstances([\n    new GeometryInstance({\n      geometry: topBottomGeo,\n    }),\n    new GeometryInstance({\n      geometry: wallGeo,\n    }),\n  ]);\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: geo[0].attributes,\n    indices: geo[0].indices,\n  };\n}\n\nfunction computeRectangle(\n  center,\n  semiMajorAxis,\n  semiMinorAxis,\n  rotation,\n  granularity,\n  ellipsoid,\n  result\n) {\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    {\n      center: center,\n      semiMajorAxis: semiMajorAxis,\n      semiMinorAxis: semiMinorAxis,\n      rotation: rotation,\n      granularity: granularity,\n    },\n    false,\n    true\n  );\n  const positionsFlat = cep.outerPositions;\n  const positionsCount = positionsFlat.length / 3;\n  const positions = new Array(positionsCount);\n  for (let i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n  const rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);\n  // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n  // When this happens, make the rectangle into a \"circle\" around the pole\n  if (rectangle.width > CesiumMath.PI) {\n    rectangle.north =\n      rectangle.north > 0.0\n        ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7\n        : rectangle.north;\n    rectangle.south =\n      rectangle.south < 0.0\n        ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO\n        : rectangle.south;\n    rectangle.east = CesiumMath.PI;\n    rectangle.west = -CesiumMath.PI;\n  }\n  return rectangle;\n}\n\n/**\n * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias EllipseGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n *\n * @example\n * // Create an ellipse.\n * const ellipse = new Cesium.EllipseGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n *\n * @see EllipseGeometry.createGeometry\n */\nfunction EllipseGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\"\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._stRotation = defaultValue(options.stRotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\n  this._workerName = \"createEllipseGeometry\";\n  this._offsetAttribute = options.offsetAttribute;\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipseGeometry.packedLength =\n  Cartesian3.packedLength +\n  Ellipsoid.packedLength +\n  VertexFormat.packedLength +\n  9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipseGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchCenter = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseGeometry} [result] The object into which to store the result.\n * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n */\nEllipseGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const semiMajorAxis = array[startingIndex++];\n  const semiMinorAxis = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const stRotation = array[startingIndex++];\n  const height = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const shadowVolume = array[startingIndex++] === 1.0;\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {Rectangle} [result] An object in which to store the result\n *\n * @returns {Rectangle} The result rectangle\n */\nEllipseGeometry.computeRectangle = function (options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n  const rotation = defaultValue(options.rotation, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"options.center\", center);\n  Check.typeOf.number(\"options.semiMajorAxis\", semiMajorAxis);\n  Check.typeOf.number(\"options.semiMinorAxis\", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\"\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  return computeRectangle(\n    center,\n    semiMajorAxis,\n    semiMinorAxis,\n    rotation,\n    granularity,\n    ellipsoid,\n    result\n  );\n};\n\n/**\n * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  const height = ellipseGeometry._height;\n  const extrudedHeight = ellipseGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center\n  );\n  const options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    vertexFormat: ellipseGeometry._vertexFormat,\n    stRotation: ellipseGeometry._stRotation,\n  };\n  let geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.shadowVolume = ellipseGeometry._shadowVolume;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const applyOffset = new Uint8Array(length / 3);\n      const offsetValue =\n        ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nEllipseGeometry.createShadowVolume = function (\n  ellipseGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  const granularity = ellipseGeometry._granularity;\n  const ellipsoid = ellipseGeometry._ellipsoid;\n\n  const minHeight = minHeightFunc(granularity, ellipsoid);\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new EllipseGeometry({\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    stRotation: ellipseGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: VertexFormat.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nfunction textureCoordinateRotationPoints(ellipseGeometry) {\n  const stRotation = -ellipseGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  const cep = EllipseGeometryLibrary.computeEllipsePositions(\n    {\n      center: ellipseGeometry._center,\n      semiMajorAxis: ellipseGeometry._semiMajorAxis,\n      semiMinorAxis: ellipseGeometry._semiMinorAxis,\n      rotation: ellipseGeometry._rotation,\n      granularity: ellipseGeometry._granularity,\n    },\n    false,\n    true\n  );\n  const positionsFlat = cep.outerPositions;\n  const positionsCount = positionsFlat.length / 3;\n  const positions = new Array(positionsCount);\n  for (let i = 0; i < positionsCount; ++i) {\n    positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n  }\n\n  const ellipsoid = ellipseGeometry._ellipsoid;\n  const boundingRectangle = ellipseGeometry.rectangle;\n  return Geometry._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle\n  );\n}\n\nObject.defineProperties(EllipseGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!defined(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._center,\n          this._semiMajorAxis,\n          this._semiMinorAxis,\n          this._rotation,\n          this._granularity,\n          this._ellipsoid\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!defined(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\n          this\n        );\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\nexport default EllipseGeometry;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nconst EllipseGeometryLibrary = {};\n\nconst rotAxis = new Cartesian3();\nconst tempVec = new Cartesian3();\nconst unitQuat = new Quaternion();\nconst rotMtx = new Matrix3();\n\nfunction pointOnEllipsoid(\n  theta,\n  rotation,\n  northVec,\n  eastVec,\n  aSqr,\n  ab,\n  bSqr,\n  mag,\n  unitPos,\n  result\n) {\n  const azimuth = theta + rotation;\n\n  Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n  Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n  Cartesian3.add(rotAxis, tempVec, rotAxis);\n\n  let cosThetaSquared = Math.cos(theta);\n  cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n  let sinThetaSquared = Math.sin(theta);\n  sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n  const radius =\n    ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n  const angle = radius / mag;\n\n  // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n  Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n  Matrix3.fromQuaternion(unitQuat, rotMtx);\n\n  Matrix3.multiplyByVector(rotMtx, unitPos, result);\n  Cartesian3.normalize(result, result);\n  Cartesian3.multiplyByScalar(result, mag, result);\n  return result;\n}\n\nconst scratchCartesian1 = new Cartesian3();\nconst scratchCartesian2 = new Cartesian3();\nconst scratchCartesian3 = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n/**\n * Returns the positions raised to the given heights\n * @private\n */\nEllipseGeometryLibrary.raisePositionsToHeight = function (\n  positions,\n  options,\n  extrude\n) {\n  const ellipsoid = options.ellipsoid;\n  const height = options.height;\n  const extrudedHeight = options.extrudedHeight;\n  const size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n\n  const finalPositions = new Float64Array(size * 3);\n\n  const length = positions.length;\n  const bottomOffset = extrude ? length : 0;\n  for (let i = 0; i < length; i += 3) {\n    const i1 = i + 1;\n    const i2 = i + 2;\n\n    const position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n    ellipsoid.scaleToGeodeticSurface(position, position);\n\n    const extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n    const normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n    const scaledNormal = Cartesian3.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian3\n    );\n    Cartesian3.add(position, scaledNormal, position);\n\n    if (extrude) {\n      Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n      Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n      finalPositions[i + bottomOffset] = extrudedPosition.x;\n      finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n      finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n    }\n\n    finalPositions[i] = position.x;\n    finalPositions[i1] = position.y;\n    finalPositions[i2] = position.z;\n  }\n\n  return finalPositions;\n};\n\nconst unitPosScratch = new Cartesian3();\nconst eastVecScratch = new Cartesian3();\nconst northVecScratch = new Cartesian3();\n/**\n * Returns an array of positions that make up the ellipse.\n * @private\n */\nEllipseGeometryLibrary.computeEllipsePositions = function (\n  options,\n  addFillPositions,\n  addEdgePositions\n) {\n  const semiMinorAxis = options.semiMinorAxis;\n  const semiMajorAxis = options.semiMajorAxis;\n  const rotation = options.rotation;\n  const center = options.center;\n\n  // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n  // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n  // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n  // the distance along the ellipse boundary more closely match the granularity.\n  const granularity = options.granularity * 8.0;\n\n  const aSqr = semiMinorAxis * semiMinorAxis;\n  const bSqr = semiMajorAxis * semiMajorAxis;\n  const ab = semiMajorAxis * semiMinorAxis;\n\n  const mag = Cartesian3.magnitude(center);\n\n  const unitPos = Cartesian3.normalize(center, unitPosScratch);\n  let eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n  eastVec = Cartesian3.normalize(eastVec, eastVec);\n  const northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n  // The number of points in the first quadrant\n  let numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n\n  const deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n  let theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n  if (theta < 0.0) {\n    numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n  }\n\n  // If the number of points were three, the ellipse\n  // would be tessellated like below:\n  //\n  //         *---*\n  //       / | \\ | \\\n  //     *---*---*---*\n  //   / | \\ | \\ | \\ | \\\n  //  / .*---*---*---*. \\\n  // * ` | \\ | \\ | \\ | `*\n  //  \\`.*---*---*---*.`/\n  //   \\ | \\ | \\ | \\ | /\n  //     *---*---*---*\n  //       \\ | \\ | /\n  //         *---*\n  // The first and last column have one position and fan to connect to the adjacent column.\n  // Each other vertical column contains an even number of positions.\n  const size = 2 * (numPts * (numPts + 2));\n  const positions = addFillPositions ? new Array(size * 3) : undefined;\n  let positionIndex = 0;\n  let position = scratchCartesian1;\n  let reflectedPosition = scratchCartesian2;\n\n  const outerPositionsLength = numPts * 4 * 3;\n  let outerRightIndex = outerPositionsLength - 1;\n  let outerLeftIndex = 0;\n  const outerPositions = addEdgePositions\n    ? new Array(outerPositionsLength)\n    : undefined;\n\n  let i;\n  let j;\n  let numInterior;\n  let t;\n  let interiorPosition;\n\n  // Compute points in the 'eastern' half of the ellipse\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position\n  );\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n  }\n  theta = CesiumMath.PI_OVER_TWO - deltaTheta;\n  for (i = 1; i < numPts + 1; ++i) {\n    position = pointOnEllipsoid(\n      theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position\n    );\n    reflectedPosition = pointOnEllipsoid(\n      Math.PI - theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * i + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n\n    theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n  }\n\n  // Compute points in the 'western' half of the ellipse\n  for (i = numPts; i > 1; --i) {\n    theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n    position = pointOnEllipsoid(\n      -theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position\n    );\n    reflectedPosition = pointOnEllipsoid(\n      theta + Math.PI,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * (i - 1) + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = Cartesian3.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n  }\n\n  theta = CesiumMath.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    -theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position\n  );\n\n  const r = {};\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n    r.positions = positions;\n    r.numPts = numPts;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n    r.outerPositions = outerPositions;\n  }\n\n  return r;\n};\nexport default EllipseGeometryLibrary;\n","import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EllipseGeometryLibrary from \"./EllipseGeometryLibrary.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst scratchCartesian1 = new Cartesian3();\nlet boundingSphereCenter = new Cartesian3();\n\nfunction computeEllipse(options) {\n  const center = options.center;\n  boundingSphereCenter = Cartesian3.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter\n  );\n  boundingSphereCenter = Cartesian3.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter\n  );\n  const boundingSphere = new BoundingSphere(\n    boundingSphereCenter,\n    options.semiMajorAxis\n  );\n  const positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true\n  ).outerPositions;\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        false\n      ),\n    }),\n  });\n\n  const length = positions.length / 3;\n  const indices = IndexDatatype.createTypedArray(length, length * 2);\n  let index = 0;\n  for (let i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nconst topBoundingSphere = new BoundingSphere();\nconst bottomBoundingSphere = new BoundingSphere();\nfunction computeExtrudedEllipse(options) {\n  const center = options.center;\n  const ellipsoid = options.ellipsoid;\n  const semiMajorAxis = options.semiMajorAxis;\n  let scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1\n  );\n  topBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = Cartesian3.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal\n  );\n  bottomBoundingSphere.center = Cartesian3.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  let positions = EllipseGeometryLibrary.computeEllipsePositions(\n    options,\n    false,\n    true\n  ).outerPositions;\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: EllipseGeometryLibrary.raisePositionsToHeight(\n        positions,\n        options,\n        true\n      ),\n    }),\n  });\n\n  positions = attributes.position.values;\n  const boundingSphere = BoundingSphere.union(\n    topBoundingSphere,\n    bottomBoundingSphere\n  );\n  let length = positions.length / 3;\n\n  if (defined(options.offsetAttribute)) {\n    let applyOffset = new Uint8Array(length);\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n      applyOffset = arrayFill(applyOffset, 1, 0, length / 2);\n    } else {\n      const offsetValue =\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n      applyOffset = arrayFill(applyOffset, offsetValue);\n    }\n\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  let numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n  numberOfVerticalLines = CesiumMath.clamp(\n    numberOfVerticalLines,\n    0,\n    length / 2\n  );\n\n  const indices = IndexDatatype.createTypedArray(\n    length,\n    length * 2 + numberOfVerticalLines * 2\n  );\n\n  length /= 2;\n  let index = 0;\n  let i;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  let numSide;\n  if (numberOfVerticalLines > 0) {\n    const numSideLines = Math.min(numberOfVerticalLines, length);\n    numSide = Math.round(length / numSideLines);\n\n    const maxI = Math.min(numSide * numberOfVerticalLines, length);\n    for (i = 0; i < maxI; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + length;\n    }\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\n/**\n * A description of the outline of an ellipse on an ellipsoid.\n *\n * @alias EllipseOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n * @see EllipseOutlineGeometry.createGeometry\n *\n * @example\n * const ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * const geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n */\nfunction EllipseOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const center = options.center;\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  const semiMajorAxis = options.semiMajorAxis;\n  const semiMinorAxis = options.semiMinorAxis;\n  const granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(center)) {\n    throw new DeveloperError(\"center is required.\");\n  }\n  if (!defined(semiMajorAxis)) {\n    throw new DeveloperError(\"semiMajorAxis is required.\");\n  }\n  if (!defined(semiMinorAxis)) {\n    throw new DeveloperError(\"semiMinorAxis is required.\");\n  }\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new DeveloperError(\n      \"semiMajorAxis must be greater than or equal to the semiMinorAxis.\"\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new DeveloperError(\"granularity must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const height = defaultValue(options.height, 0.0);\n  const extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n  this._center = Cartesian3.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\n  this._rotation = defaultValue(options.rotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._numberOfVerticalLines = Math.max(\n    defaultValue(options.numberOfVerticalLines, 16),\n    0\n  );\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipseOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipseOutlineGeometry.packedLength =\n  Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipseOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._center, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += Ellipsoid.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchCenter = new Cartesian3();\nconst scratchEllipsoid = new Ellipsoid();\nconst scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n */\nEllipseOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n  startingIndex += Cartesian3.packedLength;\n\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += Ellipsoid.packedLength;\n\n  const semiMajorAxis = array[startingIndex++];\n  const semiMinorAxis = array[startingIndex++];\n  const rotation = array[startingIndex++];\n  const height = array[startingIndex++];\n  const granularity = array[startingIndex++];\n  const extrudedHeight = array[startingIndex++];\n  const numberOfVerticalLines = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseOutlineGeometry(scratchOptions);\n  }\n\n  result._center = Cartesian3.clone(center, result._center);\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseOutlineGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  const height = ellipseGeometry._height;\n  const extrudedHeight = ellipseGeometry._extrudedHeight;\n  const extrude = !CesiumMath.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    CesiumMath.EPSILON2\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center\n  );\n  const options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    numberOfVerticalLines: ellipseGeometry._numberOfVerticalLines,\n  };\n  let geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if (defined(ellipseGeometry._offsetAttribute)) {\n      const length = geometry.attributes.position.values.length;\n      const applyOffset = new Uint8Array(length / 3);\n      const offsetValue =\n        ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n          ? 0\n          : 1;\n      arrayFill(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\nexport default EllipseOutlineGeometry;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = defaultValue(x, 0.0);\n  y = defaultValue(y, 0.0);\n  z = defaultValue(z, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\n  //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n\n  ellipsoid._radiiToTheFourth = new Cartesian3(\n    x * x * x * x,\n    y * y * y * y,\n    z * z * z * z\n  );\n\n  ellipsoid._oneOverRadii = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / x,\n    y === 0.0 ? 0.0 : 1.0 / y,\n    z === 0.0 ? 0.0 : 1.0 / z\n  );\n\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\n    z === 0.0 ? 0.0 : 1.0 / (z * z)\n  );\n\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ =\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {Number} [x=0] The radius in the x direction.\n * @param {Number} [y=0] The radius in the y direction.\n * @param {Number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    },\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    },\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    },\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    },\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    },\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    },\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n  const radii = ellipsoid._radii;\n\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793)\n);\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(\n  new Ellipsoid(\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS\n  )\n);\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoid.packedLength = Cartesian3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\n  cartographic,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  const longitude = cartographic.longitude;\n  const latitude = cartographic.latitude;\n  const cosLatitude = Math.cos(latitude);\n\n  const x = cosLatitude * Math.cos(longitude);\n  const y = cosLatitude * Math.sin(longitude);\n  const z = Math.sin(latitude);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  if (\n    Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)\n  ) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result = Cartesian3.multiplyComponents(\n    cartesian,\n    this._oneOverRadiiSquared,\n    result\n  );\n  return Cartesian3.normalize(result, result);\n};\n\nconst cartographicToCartesianNormal = new Cartesian3();\nconst cartographicToCartesianK = new Cartesian3();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  const n = cartographicToCartesianNormal;\n  const k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  const gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\n  cartographics,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug')\n\n  const length = cartographics.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\n\nconst cartesianToCartographicN = new Cartesian3();\nconst cartesianToCartographicP = new Cartesian3();\nconst cartesianToCartographicH = new Cartesian3();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  const p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  const n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  const h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  const longitude = Math.atan2(n.y, n.x);\n  const latitude = Math.asin(n.z);\n  const height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (let i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(\n    cartesian,\n    this._oneOverRadii,\n    this._oneOverRadiiSquared,\n    this._centerToleranceSquared,\n    result\n  );\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n  const oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n  const beta =\n    1.0 /\n    Math.sqrt(\n      positionX * positionX * oneOverRadiiSquared.x +\n        positionY * positionY * oneOverRadiiSquared.y +\n        positionZ * positionZ * oneOverRadiiSquared.z\n    );\n\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return (\n    this === right ||\n    (defined(right) && Cartesian3.equals(this._radii, right._radii))\n  );\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\n  position,\n  buffer,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n\n  if (\n    !CesiumMath.equalsEpsilon(\n      this._radii.x,\n      this._radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\n  //>>includeEnd('debug');\n\n  buffer = defaultValue(buffer, 0.0);\n\n  const squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\n\nconst abscissas = [\n  0.14887433898163,\n  0.43339539412925,\n  0.67940956829902,\n  0.86506336668898,\n  0.97390652851717,\n  0.0,\n];\nconst weights = [\n  0.29552422471475,\n  0.26926671930999,\n  0.21908636251598,\n  0.14945134915058,\n  0.066671344308684,\n  0.0,\n];\n\n/**\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\n *\n * @param {Number} a The lower bound for the integration.\n * @param {Number} b The upper bound for the integration.\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\n * @returns {Number} The value of the integral of the given function over the given domain.\n *\n * @private\n */\nfunction gaussLegendreQuadrature(a, b, func) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"a\", a);\n  Check.typeOf.number(\"b\", b);\n  Check.typeOf.func(\"func\", func);\n  //>>includeEnd('debug');\n\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\n  // The values of the abscissas are multiplied by two to account for this.\n  const xMean = 0.5 * (b + a);\n  const xRange = 0.5 * (b - a);\n\n  let sum = 0.0;\n  for (let i = 0; i < 5; i++) {\n    const dx = xRange * abscissas[i];\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\n  }\n\n  // Scale the sum to the range of x.\n  sum *= xRange;\n  return sum;\n}\n\n/**\n * A real valued scalar function.\n * @callback Ellipsoid~RealValuedScalarFunction\n *\n * @param {Number} x The value used to evaluate the function.\n * @returns {Number} The value of the function at x.\n *\n * @private\n */\n\n/**\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\n * Gauss-Legendre 10th order quadrature.\n *\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\n * @returns {Number} The approximate area of the rectangle on the surface of this ellipsoid.\n */\nEllipsoid.prototype.surfaceArea = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  const minLongitude = rectangle.west;\n  let maxLongitude = rectangle.east;\n  const minLatitude = rectangle.south;\n  const maxLatitude = rectangle.north;\n\n  while (maxLongitude < minLongitude) {\n    maxLongitude += CesiumMath.TWO_PI;\n  }\n\n  const radiiSquared = this._radiiSquared;\n  const a2 = radiiSquared.x;\n  const b2 = radiiSquared.y;\n  const c2 = radiiSquared.z;\n  const a2b2 = a2 * b2;\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\n    // phi represents the angle measured from the north pole\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\n    const sinPhi = Math.cos(lat);\n    const cosPhi = Math.sin(lat);\n    return (\n      Math.cos(lat) *\n      gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\n        const cosTheta = Math.cos(lon);\n        const sinTheta = Math.sin(lon);\n        return Math.sqrt(\n          a2b2 * cosPhi * cosPhi +\n            c2 *\n              (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) *\n              sinPhi *\n              sinPhi\n        );\n      })\n    );\n  });\n};\n\nexport default Ellipsoid;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction setConstants(ellipsoidGeodesic) {\n  const uSquared = ellipsoidGeodesic._uSquared;\n  const a = ellipsoidGeodesic._ellipsoid.maximumRadius;\n  const b = ellipsoidGeodesic._ellipsoid.minimumRadius;\n  const f = (a - b) / a;\n\n  const cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\n  const sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\n\n  const tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\n\n  const cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\n  const sineU = cosineU * tanU;\n\n  const sigma = Math.atan2(tanU, cosineHeading);\n\n  const sineAlpha = cosineU * sineHeading;\n  const sineSquaredAlpha = sineAlpha * sineAlpha;\n\n  const cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\n  const cosineAlpha = Math.sqrt(cosineSquaredAlpha);\n\n  const u2Over4 = uSquared / 4.0;\n  const u4Over16 = u2Over4 * u2Over4;\n  const u6Over64 = u4Over16 * u2Over4;\n  const u8Over256 = u4Over16 * u4Over16;\n\n  const a0 =\n    1.0 +\n    u2Over4 -\n    (3.0 * u4Over16) / 4.0 +\n    (5.0 * u6Over64) / 4.0 -\n    (175.0 * u8Over256) / 64.0;\n  const a1 = 1.0 - u2Over4 + (15.0 * u4Over16) / 8.0 - (35.0 * u6Over64) / 8.0;\n  const a2 = 1.0 - 3.0 * u2Over4 + (35.0 * u4Over16) / 4.0;\n  const a3 = 1.0 - 5.0 * u2Over4;\n\n  const distanceRatio =\n    a0 * sigma -\n    (a1 * Math.sin(2.0 * sigma) * u2Over4) / 2.0 -\n    (a2 * Math.sin(4.0 * sigma) * u4Over16) / 16.0 -\n    (a3 * Math.sin(6.0 * sigma) * u6Over64) / 48.0 -\n    (Math.sin(8.0 * sigma) * 5.0 * u8Over256) / 512;\n\n  const constants = ellipsoidGeodesic._constants;\n\n  constants.a = a;\n  constants.b = b;\n  constants.f = f;\n  constants.cosineHeading = cosineHeading;\n  constants.sineHeading = sineHeading;\n  constants.tanU = tanU;\n  constants.cosineU = cosineU;\n  constants.sineU = sineU;\n  constants.sigma = sigma;\n  constants.sineAlpha = sineAlpha;\n  constants.sineSquaredAlpha = sineSquaredAlpha;\n  constants.cosineSquaredAlpha = cosineSquaredAlpha;\n  constants.cosineAlpha = cosineAlpha;\n  constants.u2Over4 = u2Over4;\n  constants.u4Over16 = u4Over16;\n  constants.u6Over64 = u6Over64;\n  constants.u8Over256 = u8Over256;\n  constants.a0 = a0;\n  constants.a1 = a1;\n  constants.a2 = a2;\n  constants.a3 = a3;\n  constants.distanceRatio = distanceRatio;\n}\n\nfunction computeC(f, cosineSquaredAlpha) {\n  return (\n    (f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha))) /\n    16.0\n  );\n}\n\nfunction computeDeltaLambda(\n  f,\n  sineAlpha,\n  cosineSquaredAlpha,\n  sigma,\n  sineSigma,\n  cosineSigma,\n  cosineTwiceSigmaMidpoint\n) {\n  const C = computeC(f, cosineSquaredAlpha);\n\n  return (\n    (1.0 - C) *\n    f *\n    sineAlpha *\n    (sigma +\n      C *\n        sineSigma *\n        (cosineTwiceSigmaMidpoint +\n          C *\n            cosineSigma *\n            (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)))\n  );\n}\n\nfunction vincentyInverseFormula(\n  ellipsoidGeodesic,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  const eff = (major - minor) / major;\n  const l = secondLongitude - firstLongitude;\n\n  const u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\n  const u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\n\n  const cosineU1 = Math.cos(u1);\n  const sineU1 = Math.sin(u1);\n  const cosineU2 = Math.cos(u2);\n  const sineU2 = Math.sin(u2);\n\n  const cc = cosineU1 * cosineU2;\n  const cs = cosineU1 * sineU2;\n  const ss = sineU1 * sineU2;\n  const sc = sineU1 * cosineU2;\n\n  let lambda = l;\n  let lambdaDot = CesiumMath.TWO_PI;\n\n  let cosineLambda = Math.cos(lambda);\n  let sineLambda = Math.sin(lambda);\n\n  let sigma;\n  let cosineSigma;\n  let sineSigma;\n  let cosineSquaredAlpha;\n  let cosineTwiceSigmaMidpoint;\n\n  do {\n    cosineLambda = Math.cos(lambda);\n    sineLambda = Math.sin(lambda);\n\n    const temp = cs - sc * cosineLambda;\n    sineSigma = Math.sqrt(\n      cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp\n    );\n    cosineSigma = ss + cc * cosineLambda;\n\n    sigma = Math.atan2(sineSigma, cosineSigma);\n\n    let sineAlpha;\n\n    if (sineSigma === 0.0) {\n      sineAlpha = 0.0;\n      cosineSquaredAlpha = 1.0;\n    } else {\n      sineAlpha = (cc * sineLambda) / sineSigma;\n      cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\n    }\n\n    lambdaDot = lambda;\n\n    cosineTwiceSigmaMidpoint = cosineSigma - (2.0 * ss) / cosineSquaredAlpha;\n\n    if (!isFinite(cosineTwiceSigmaMidpoint)) {\n      cosineTwiceSigmaMidpoint = 0.0;\n    }\n\n    lambda =\n      l +\n      computeDeltaLambda(\n        eff,\n        sineAlpha,\n        cosineSquaredAlpha,\n        sigma,\n        sineSigma,\n        cosineSigma,\n        cosineTwiceSigmaMidpoint\n      );\n  } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);\n\n  const uSquared =\n    (cosineSquaredAlpha * (major * major - minor * minor)) / (minor * minor);\n  const A =\n    1.0 +\n    (uSquared *\n      (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0))) /\n      16384.0;\n  const B =\n    (uSquared *\n      (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0))) /\n    1024.0;\n\n  const cosineSquaredTwiceSigmaMidpoint =\n    cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\n  const deltaSigma =\n    B *\n    sineSigma *\n    (cosineTwiceSigmaMidpoint +\n      (B *\n        (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) -\n          (B *\n            cosineTwiceSigmaMidpoint *\n            (4.0 * sineSigma * sineSigma - 3.0) *\n            (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0)) /\n            6.0)) /\n        4.0);\n\n  const distance = minor * A * (sigma - deltaSigma);\n\n  const startHeading = Math.atan2(\n    cosineU2 * sineLambda,\n    cs - sc * cosineLambda\n  );\n  const endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\n\n  ellipsoidGeodesic._distance = distance;\n  ellipsoidGeodesic._startHeading = startHeading;\n  ellipsoidGeodesic._endHeading = endHeading;\n  ellipsoidGeodesic._uSquared = uSquared;\n}\n\nconst scratchCart1 = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\nfunction computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\n  const firstCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1\n  );\n  const lastCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"value\",\n    Math.abs(\n      Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI\n    ),\n    0.0125\n  );\n  //>>includeEnd('debug');\n\n  vincentyInverseFormula(\n    ellipsoidGeodesic,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n\n  ellipsoidGeodesic._start = Cartographic.clone(\n    start,\n    ellipsoidGeodesic._start\n  );\n  ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);\n  ellipsoidGeodesic._start.height = 0;\n  ellipsoidGeodesic._end.height = 0;\n\n  setConstants(ellipsoidGeodesic);\n}\n\n/**\n * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidGeodesic\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the geodesic lies.\n */\nfunction EllipsoidGeodesic(start, end, ellipsoid) {\n  const e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n\n  this._constants = {};\n  this._startHeading = undefined;\n  this._endHeading = undefined;\n  this._distance = undefined;\n  this._uSquared = undefined;\n\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidGeodesic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading at the initial point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  startHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._startHeading;\n    },\n  },\n\n  /**\n   * Gets the heading at the final point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  endHeading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._endHeading;\n    },\n  },\n});\n\n/**\n * Sets the start and end points of the geodesic\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidGeodesic.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the geodesic.\n *\n * @param {Number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n */\nEllipsoidGeodesic.prototype.interpolateUsingFraction = function (\n  fraction,\n  result\n) {\n  return this.interpolateUsingSurfaceDistance(\n    this._distance * fraction,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the geodesic.\n *\n * @param {Number} distance The distance from the inital point to the point of interest along the geodesic\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"distance\", this._distance);\n  //>>includeEnd('debug');\n\n  const constants = this._constants;\n\n  const s = constants.distanceRatio + distance / constants.b;\n\n  const cosine2S = Math.cos(2.0 * s);\n  const cosine4S = Math.cos(4.0 * s);\n  const cosine6S = Math.cos(6.0 * s);\n  const sine2S = Math.sin(2.0 * s);\n  const sine4S = Math.sin(4.0 * s);\n  const sine6S = Math.sin(6.0 * s);\n  const sine8S = Math.sin(8.0 * s);\n\n  const s2 = s * s;\n  const s3 = s * s2;\n\n  const u8Over256 = constants.u8Over256;\n  const u2Over4 = constants.u2Over4;\n  const u6Over64 = constants.u6Over64;\n  const u4Over16 = constants.u4Over16;\n  let sigma =\n    (2.0 * s3 * u8Over256 * cosine2S) / 3.0 +\n    s *\n      (1.0 -\n        u2Over4 +\n        (7.0 * u4Over16) / 4.0 -\n        (15.0 * u6Over64) / 4.0 +\n        (579.0 * u8Over256) / 64.0 -\n        (u4Over16 - (15.0 * u6Over64) / 4.0 + (187.0 * u8Over256) / 16.0) *\n          cosine2S -\n        ((5.0 * u6Over64) / 4.0 - (115.0 * u8Over256) / 16.0) * cosine4S -\n        (29.0 * u8Over256 * cosine6S) / 16.0) +\n    (u2Over4 / 2.0 -\n      u4Over16 +\n      (71.0 * u6Over64) / 32.0 -\n      (85.0 * u8Over256) / 16.0) *\n      sine2S +\n    ((5.0 * u4Over16) / 16.0 -\n      (5.0 * u6Over64) / 4.0 +\n      (383.0 * u8Over256) / 96.0) *\n      sine4S -\n    s2 *\n      ((u6Over64 - (11.0 * u8Over256) / 2.0) * sine2S +\n        (5.0 * u8Over256 * sine4S) / 2.0) +\n    ((29.0 * u6Over64) / 96.0 - (29.0 * u8Over256) / 16.0) * sine6S +\n    (539.0 * u8Over256 * sine8S) / 1536.0;\n\n  const theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\n  const latitude = Math.atan((constants.a / constants.b) * Math.tan(theta));\n\n  // Redefine in terms of relative argument of latitude.\n  sigma = sigma - constants.sigma;\n\n  const cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\n\n  const sineSigma = Math.sin(sigma);\n  const cosineSigma = Math.cos(sigma);\n\n  const cc = constants.cosineU * cosineSigma;\n  const ss = constants.sineU * sineSigma;\n\n  const lambda = Math.atan2(\n    sineSigma * constants.sineHeading,\n    cc - ss * constants.cosineHeading\n  );\n\n  const l =\n    lambda -\n    computeDeltaLambda(\n      constants.f,\n      constants.sineAlpha,\n      constants.cosineSquaredAlpha,\n      sigma,\n      sineSigma,\n      cosineSigma,\n      cosineTwiceSigmaMidpoint\n    );\n\n  if (defined(result)) {\n    result.longitude = this._start.longitude + l;\n    result.latitude = latitude;\n    result.height = 0.0;\n    return result;\n  }\n\n  return new Cartographic(this._start.longitude + l, latitude, 0.0);\n};\nexport default EllipsoidGeodesic;\n","import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst scratchPosition = new Cartesian3();\nconst scratchNormal = new Cartesian3();\nconst scratchTangent = new Cartesian3();\nconst scratchBitangent = new Cartesian3();\nconst scratchNormalST = new Cartesian3();\nconst defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\n\nconst cos = Math.cos;\nconst sin = Math.sin;\n\n/**\n * A description of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\n * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slicePartitions cannot be less than three.\n * @exception {DeveloperError} options.stackPartitions cannot be less than three.\n *\n * @see EllipsoidGeometry#createGeometry\n *\n * @example\n * const ellipsoid = new Cesium.EllipsoidGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\n * });\n * const geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const radii = defaultValue(options.radii, defaultRadii);\n  const innerRadii = defaultValue(options.innerRadii, radii);\n  const minimumClock = defaultValue(options.minimumClock, 0.0);\n  const maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\n  const minimumCone = defaultValue(options.minimumCone, 0.0);\n  const maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\n  const stackPartitions = Math.round(defaultValue(options.stackPartitions, 64));\n  const slicePartitions = Math.round(defaultValue(options.slicePartitions, 64));\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (slicePartitions < 3) {\n    throw new DeveloperError(\n      \"options.slicePartitions cannot be less than three.\"\n    );\n  }\n  if (stackPartitions < 3) {\n    throw new DeveloperError(\n      \"options.stackPartitions cannot be less than three.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoidGeometry.packedLength =\n  2 * Cartesian3.packedLength + VertexFormat.packedLength + 7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoidGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchRadii = new Cartesian3();\nconst scratchInnerRadii = new Cartesian3();\nconst scratchVertexFormat = new VertexFormat();\nconst scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  vertexFormat: scratchVertexFormat,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.\n */\nEllipsoidGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n\n  const minimumClock = array[startingIndex++];\n  const maximumClock = array[startingIndex++];\n  const minimumCone = array[startingIndex++];\n  const maximumCone = array[startingIndex++];\n  const stackPartitions = array[startingIndex++];\n  const slicePartitions = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidGeometry.createGeometry = function (ellipsoidGeometry) {\n  const radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  const innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  const minimumClock = ellipsoidGeometry._minimumClock;\n  const maximumClock = ellipsoidGeometry._maximumClock;\n  const minimumCone = ellipsoidGeometry._minimumCone;\n  const maximumCone = ellipsoidGeometry._maximumCone;\n  const vertexFormat = ellipsoidGeometry._vertexFormat;\n\n  // Add an extra slice and stack so that the number of partitions is the\n  // number of surfaces rather than the number of joints\n  let slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  let stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      CesiumMath.TWO_PI\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  let i;\n  let j;\n  let index = 0;\n\n  // Create arrays for theta and phi. Duplicate first and last angle to\n  // allow different normals at the intersections.\n  const phis = [minimumCone];\n  const thetas = [minimumClock];\n  for (i = 0; i < stackPartitions; i++) {\n    phis.push(\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1)\n    );\n  }\n  phis.push(maximumCone);\n  for (j = 0; j < slicePartitions; j++) {\n    thetas.push(\n      minimumClock + (j * (maximumClock - minimumClock)) / (slicePartitions - 1)\n    );\n  }\n  thetas.push(maximumClock);\n  const numPhis = phis.length;\n  const numThetas = thetas.length;\n\n  // Allow for extra indices if there is an inner surface and if we need\n  // to close the sides if the clock range is not a full circle\n  let extraIndices = 0;\n  let vertexMultiplier = 1.0;\n  const hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  let isTopOpen = false;\n  let isBotOpen = false;\n  let isClockOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if ((maximumClock - minimumClock) % CesiumMath.TWO_PI) {\n      isClockOpen = true;\n      extraIndices += (stackPartitions - 1) * 2 + 1;\n    } else {\n      extraIndices += 1;\n    }\n  }\n\n  const vertexCount = numThetas * numPhis * vertexMultiplier;\n  const positions = new Float64Array(vertexCount * 3);\n  const isInner = arrayFill(new Array(vertexCount), false);\n  const negateNormal = arrayFill(new Array(vertexCount), false);\n\n  // Multiply by 6 because there are two triangles per sector\n  const indexCount = slicePartitions * stackPartitions * vertexMultiplier;\n  const numIndices =\n    6 *\n    (indexCount +\n      extraIndices +\n      1 -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  const indices = IndexDatatype.createTypedArray(indexCount, numIndices);\n\n  const normals = vertexFormat.normal\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  const tangents = vertexFormat.tangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  const bitangents = vertexFormat.bitangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  const st = vertexFormat.st ? new Float32Array(vertexCount * 2) : undefined;\n\n  // Calculate sin/cos phi\n  const sinPhi = new Array(numPhis);\n  const cosPhi = new Array(numPhis);\n  for (i = 0; i < numPhis; i++) {\n    sinPhi[i] = sin(phis[i]);\n    cosPhi[i] = cos(phis[i]);\n  }\n\n  // Calculate sin/cos theta\n  const sinTheta = new Array(numThetas);\n  const cosTheta = new Array(numThetas);\n  for (j = 0; j < numThetas; j++) {\n    cosTheta[j] = cos(thetas[j]);\n    sinTheta[j] = sin(thetas[j]);\n  }\n\n  // Create outer surface\n  for (i = 0; i < numPhis; i++) {\n    for (j = 0; j < numThetas; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Create inner surface\n  let vertexIndex = vertexCount / 2.0;\n  if (hasInnerSurface) {\n    for (i = 0; i < numPhis; i++) {\n      for (j = 0; j < numThetas; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n\n        // Keep track of which vertices are the inner and which ones\n        // need the normal to be negated\n        isInner[vertexIndex] = true;\n        if (i > 0 && i !== numPhis - 1 && j !== 0 && j !== numThetas - 1) {\n          negateNormal[vertexIndex] = true;\n        }\n        vertexIndex++;\n      }\n    }\n  }\n\n  // Create indices for outer surface\n  index = 0;\n  let topOffset;\n  let bottomOffset;\n  for (i = 1; i < numPhis - 2; i++) {\n    topOffset = i * numThetas;\n    bottomOffset = (i + 1) * numThetas;\n\n    for (j = 1; j < numThetas - 2; j++) {\n      indices[index++] = bottomOffset + j;\n      indices[index++] = bottomOffset + j + 1;\n      indices[index++] = topOffset + j + 1;\n\n      indices[index++] = bottomOffset + j;\n      indices[index++] = topOffset + j + 1;\n      indices[index++] = topOffset + j;\n    }\n  }\n\n  // Create indices for inner surface\n  if (hasInnerSurface) {\n    const offset = numPhis * numThetas;\n    for (i = 1; i < numPhis - 2; i++) {\n      topOffset = offset + i * numThetas;\n      bottomOffset = offset + (i + 1) * numThetas;\n\n      for (j = 1; j < numThetas - 2; j++) {\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j;\n        indices[index++] = topOffset + j + 1;\n\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j + 1;\n        indices[index++] = bottomOffset + j + 1;\n      }\n    }\n  }\n\n  let outerOffset;\n  let innerOffset;\n  if (hasInnerSurface) {\n    if (isTopOpen) {\n      // Connect the top of the inner surface to the top of the outer surface\n      innerOffset = numPhis * numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = i;\n        indices[index++] = i + 1;\n        indices[index++] = innerOffset + i + 1;\n\n        indices[index++] = i;\n        indices[index++] = innerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Connect the bottom of the inner surface to the bottom of the outer surface\n      outerOffset = numPhis * numThetas - numThetas;\n      innerOffset = numPhis * numThetas * vertexMultiplier - numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n        indices[index++] = innerOffset + i + 1;\n      }\n    }\n  }\n\n  // Connect the edges if clock is not closed\n  if (isClockOpen) {\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * i;\n      outerOffset = numThetas * i;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = outerOffset;\n\n      indices[index++] = innerOffset;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = outerOffset + numThetas;\n    }\n\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * (i + 1) - 1;\n      outerOffset = numThetas * (i + 1) - 1;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset;\n\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = innerOffset;\n    }\n  }\n\n  const attributes = new GeometryAttributes();\n\n  if (vertexFormat.position) {\n    attributes.position = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  let stIndex = 0;\n  let normalIndex = 0;\n  let tangentIndex = 0;\n  let bitangentIndex = 0;\n  const vertexCountHalf = vertexCount / 2.0;\n\n  let ellipsoid;\n  const ellipsoidOuter = Ellipsoid.fromCartesian3(radii);\n  const ellipsoidInner = Ellipsoid.fromCartesian3(innerRadii);\n\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent\n  ) {\n    for (i = 0; i < vertexCount; i++) {\n      ellipsoid = isInner[i] ? ellipsoidInner : ellipsoidOuter;\n      const position = Cartesian3.fromArray(positions, i * 3, scratchPosition);\n      const normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n      if (negateNormal[i]) {\n        Cartesian3.negate(normal, normal);\n      }\n\n      if (vertexFormat.st) {\n        const normalST = Cartesian2.negate(normal, scratchNormalST);\n        st[stIndex++] =\n          Math.atan2(normalST.y, normalST.x) / CesiumMath.TWO_PI + 0.5;\n        st[stIndex++] = Math.asin(normal.z) / Math.PI + 0.5;\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        const tangent = scratchTangent;\n\n        // Use UNIT_X for the poles\n        let tangetOffset = 0;\n        let unit;\n        if (isInner[i]) {\n          tangetOffset = vertexCountHalf;\n        }\n        if (\n          !isTopOpen &&\n          i >= tangetOffset &&\n          i < tangetOffset + numThetas * 2\n        ) {\n          unit = Cartesian3.UNIT_X;\n        } else {\n          unit = Cartesian3.UNIT_Z;\n        }\n        Cartesian3.cross(unit, normal, tangent);\n        Cartesian3.normalize(tangent, tangent);\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          const bitangent = Cartesian3.cross(normal, tangent, scratchBitangent);\n          Cartesian3.normalize(bitangent, bitangent);\n\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    if (vertexFormat.st) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n  }\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const applyOffset = new Uint8Array(length / 3);\n    const offsetValue =\n      ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoidOuter),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\n\nlet unitEllipsoidGeometry;\n\n/**\n * Returns the geometric representation of a unit ellipsoid, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nEllipsoidGeometry.getUnitEllipsoid = function () {\n  if (!defined(unitEllipsoidGeometry)) {\n    unitEllipsoidGeometry = EllipsoidGeometry.createGeometry(\n      new EllipsoidGeometry({\n        radii: new Cartesian3(1.0, 1.0, 1.0),\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n  }\n  return unitEllipsoidGeometry;\n};\nexport default EllipsoidGeometry;\n","import arrayFill from \"./arrayFill.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"./GeometryOffsetAttribute.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\n\nconst defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\nconst cos = Math.cos;\nconst sin = Math.sin;\n\n/**\n * A description of the outline of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidOutlineGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.stackPartitions=10] The count of stacks for the ellipsoid (1 greater than the number of parallel lines).\n * @param {Number} [options.slicePartitions=8] The count of slices for the ellipsoid (Equal to the number of radial lines).\n * @param {Number} [options.subdivisions=128] The number of points per line, determining the granularity of the curvature.\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * const ellipsoid = new Cesium.EllipsoidOutlineGeometry({\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\n *   stackPartitions: 6,\n *   slicePartitions: 5\n * });\n * const geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidOutlineGeometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const radii = defaultValue(options.radii, defaultRadii);\n  const innerRadii = defaultValue(options.innerRadii, radii);\n  const minimumClock = defaultValue(options.minimumClock, 0.0);\n  const maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\n  const minimumCone = defaultValue(options.minimumCone, 0.0);\n  const maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\n  const stackPartitions = Math.round(defaultValue(options.stackPartitions, 10));\n  const slicePartitions = Math.round(defaultValue(options.slicePartitions, 8));\n  const subdivisions = Math.round(defaultValue(options.subdivisions, 128));\n\n  //>>includeStart('debug', pragmas.debug);\n  if (stackPartitions < 1) {\n    throw new DeveloperError(\"options.stackPartitions cannot be less than 1\");\n  }\n  if (slicePartitions < 0) {\n    throw new DeveloperError(\"options.slicePartitions cannot be less than 0\");\n  }\n  if (subdivisions < 0) {\n    throw new DeveloperError(\n      \"options.subdivisions must be greater than or equal to zero.\"\n    );\n  }\n  if (\n    defined(options.offsetAttribute) &&\n    options.offsetAttribute === GeometryOffsetAttribute.TOP\n  ) {\n    throw new DeveloperError(\n      \"GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._radii = Cartesian3.clone(radii);\n  this._innerRadii = Cartesian3.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._subdivisions = subdivisions;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = \"createEllipsoidOutlineGeometry\";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoidOutlineGeometry.packedLength = 2 * Cartesian3.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoidOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(value)) {\n    throw new DeveloperError(\"value is required\");\n  }\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  Cartesian3.pack(value._innerRadii, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex++] = value._subdivisions;\n  array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n  return array;\n};\n\nconst scratchRadii = new Cartesian3();\nconst scratchInnerRadii = new Cartesian3();\nconst scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidOutlineGeometry} The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.\n */\nEllipsoidOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(array)) {\n    throw new DeveloperError(\"array is required\");\n  }\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += Cartesian3.packedLength;\n\n  const minimumClock = array[startingIndex++];\n  const maximumClock = array[startingIndex++];\n  const minimumCone = array[startingIndex++];\n  const maximumCone = array[startingIndex++];\n  const stackPartitions = array[startingIndex++];\n  const slicePartitions = array[startingIndex++];\n  const subdivisions = array[startingIndex++];\n  const offsetAttribute = array[startingIndex];\n\n  if (!defined(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.subdivisions = subdivisions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidOutlineGeometry(scratchOptions);\n  }\n\n  result._radii = Cartesian3.clone(radii, result._radii);\n  result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._subdivisions = subdivisions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidOutlineGeometry} ellipsoidGeometry A description of the ellipsoid outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidOutlineGeometry.createGeometry = function (ellipsoidGeometry) {\n  const radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  const innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  const minimumClock = ellipsoidGeometry._minimumClock;\n  const maximumClock = ellipsoidGeometry._maximumClock;\n  const minimumCone = ellipsoidGeometry._minimumCone;\n  const maximumCone = ellipsoidGeometry._maximumCone;\n  const subdivisions = ellipsoidGeometry._subdivisions;\n  const ellipsoid = Ellipsoid.fromCartesian3(radii);\n\n  // Add an extra slice and stack to remain consistent with EllipsoidGeometry\n  let slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  let stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      CesiumMath.TWO_PI\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / CesiumMath.PI\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  let extraIndices = 0;\n  let vertexMultiplier = 1.0;\n  const hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  let isTopOpen = false;\n  let isBotOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    // Add 2x slicePartitions to connect the top/bottom of the outer to\n    // the top/bottom of the inner\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions;\n    }\n  }\n\n  const vertexCount =\n    subdivisions * vertexMultiplier * (stackPartitions + slicePartitions);\n  const positions = new Float64Array(vertexCount * 3);\n\n  // Multiply by two because two points define each line segment\n  const numIndices =\n    2 *\n    (vertexCount +\n      extraIndices -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  const indices = IndexDatatype.createTypedArray(vertexCount, numIndices);\n\n  let i;\n  let j;\n  let theta;\n  let phi;\n  let index = 0;\n\n  // Calculate sin/cos phi\n  const sinPhi = new Array(stackPartitions);\n  const cosPhi = new Array(stackPartitions);\n  for (i = 0; i < stackPartitions; i++) {\n    phi =\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta\n  const sinTheta = new Array(subdivisions);\n  const cosTheta = new Array(subdivisions);\n  for (i = 0; i < subdivisions; i++) {\n    theta =\n      minimumClock + (i * (maximumClock - minimumClock)) / (subdivisions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the latitude lines on the outer surface\n  for (i = 0; i < stackPartitions; i++) {\n    for (j = 0; j < subdivisions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the latitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < stackPartitions; i++) {\n      for (j = 0; j < subdivisions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Calculate sin/cos phi\n  sinPhi.length = subdivisions;\n  cosPhi.length = subdivisions;\n  for (i = 0; i < subdivisions; i++) {\n    phi = minimumCone + (i * (maximumCone - minimumCone)) / (subdivisions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta for each slice partition\n  sinTheta.length = slicePartitions;\n  cosTheta.length = slicePartitions;\n  for (i = 0; i < slicePartitions; i++) {\n    theta =\n      minimumClock +\n      (i * (maximumClock - minimumClock)) / (slicePartitions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the longitude lines on the outer surface\n  for (i = 0; i < subdivisions; i++) {\n    for (j = 0; j < slicePartitions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the longitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < subdivisions; i++) {\n      for (j = 0; j < slicePartitions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Create indices for the latitude lines\n  index = 0;\n  for (i = 0; i < stackPartitions * vertexMultiplier; i++) {\n    const topOffset = i * subdivisions;\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = topOffset + j;\n      indices[index++] = topOffset + j + 1;\n    }\n  }\n\n  // Create indices for the outer longitude lines\n  let offset = stackPartitions * subdivisions * vertexMultiplier;\n  for (i = 0; i < slicePartitions; i++) {\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = offset + i + j * slicePartitions;\n      indices[index++] = offset + i + (j + 1) * slicePartitions;\n    }\n  }\n\n  // Create indices for the inner longitude lines\n  if (hasInnerSurface) {\n    offset =\n      stackPartitions * subdivisions * vertexMultiplier +\n      slicePartitions * subdivisions;\n    for (i = 0; i < slicePartitions; i++) {\n      for (j = 0; j < subdivisions - 1; j++) {\n        indices[index++] = offset + i + j * slicePartitions;\n        indices[index++] = offset + i + (j + 1) * slicePartitions;\n      }\n    }\n  }\n\n  if (hasInnerSurface) {\n    let outerOffset = stackPartitions * subdivisions * vertexMultiplier;\n    let innerOffset = outerOffset + subdivisions * slicePartitions;\n    if (isTopOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      outerOffset += subdivisions * slicePartitions - slicePartitions;\n      innerOffset += subdivisions * slicePartitions - slicePartitions;\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if (defined(ellipsoidGeometry._offsetAttribute)) {\n    const length = positions.length;\n    const applyOffset = new Uint8Array(length / 3);\n    const offsetValue =\n      ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\n        ? 0\n        : 1;\n    arrayFill(applyOffset, offsetValue);\n    attributes.applyOffset = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromEllipsoid(ellipsoid),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\nexport default EllipsoidOutlineGeometry;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\n\nfunction calculateM(ellipticity, major, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return major * latitude;\n  }\n\n  const e2 = ellipticity * ellipticity;\n  const e4 = e2 * e2;\n  const e6 = e4 * e2;\n  const e8 = e6 * e2;\n  const e10 = e8 * e2;\n  const e12 = e10 * e2;\n  const phi = latitude;\n  const sin2Phi = Math.sin(2 * phi);\n  const sin4Phi = Math.sin(4 * phi);\n  const sin6Phi = Math.sin(6 * phi);\n  const sin8Phi = Math.sin(8 * phi);\n  const sin10Phi = Math.sin(10 * phi);\n  const sin12Phi = Math.sin(12 * phi);\n\n  return (\n    major *\n    ((1 -\n      e2 / 4 -\n      (3 * e4) / 64 -\n      (5 * e6) / 256 -\n      (175 * e8) / 16384 -\n      (441 * e10) / 65536 -\n      (4851 * e12) / 1048576) *\n      phi -\n      ((3 * e2) / 8 +\n        (3 * e4) / 32 +\n        (45 * e6) / 1024 +\n        (105 * e8) / 4096 +\n        (2205 * e10) / 131072 +\n        (6237 * e12) / 524288) *\n        sin2Phi +\n      ((15 * e4) / 256 +\n        (45 * e6) / 1024 +\n        (525 * e8) / 16384 +\n        (1575 * e10) / 65536 +\n        (155925 * e12) / 8388608) *\n        sin4Phi -\n      ((35 * e6) / 3072 +\n        (175 * e8) / 12288 +\n        (3675 * e10) / 262144 +\n        (13475 * e12) / 1048576) *\n        sin6Phi +\n      ((315 * e8) / 131072 + (2205 * e10) / 524288 + (43659 * e12) / 8388608) *\n        sin8Phi -\n      ((693 * e10) / 1310720 + (6237 * e12) / 5242880) * sin10Phi +\n      ((1001 * e12) / 8388608) * sin12Phi)\n  );\n}\n\nfunction calculateInverseM(M, ellipticity, major) {\n  const d = M / major;\n\n  if (ellipticity === 0.0) {\n    // sphere\n    return d;\n  }\n\n  const d2 = d * d;\n  const d3 = d2 * d;\n  const d4 = d3 * d;\n  const e = ellipticity;\n  const e2 = e * e;\n  const e4 = e2 * e2;\n  const e6 = e4 * e2;\n  const e8 = e6 * e2;\n  const e10 = e8 * e2;\n  const e12 = e10 * e2;\n  const sin2D = Math.sin(2 * d);\n  const cos2D = Math.cos(2 * d);\n  const sin4D = Math.sin(4 * d);\n  const cos4D = Math.cos(4 * d);\n  const sin6D = Math.sin(6 * d);\n  const cos6D = Math.cos(6 * d);\n  const sin8D = Math.sin(8 * d);\n  const cos8D = Math.cos(8 * d);\n  const sin10D = Math.sin(10 * d);\n  const cos10D = Math.cos(10 * d);\n  const sin12D = Math.sin(12 * d);\n\n  return (\n    d +\n    (d * e2) / 4 +\n    (7 * d * e4) / 64 +\n    (15 * d * e6) / 256 +\n    (579 * d * e8) / 16384 +\n    (1515 * d * e10) / 65536 +\n    (16837 * d * e12) / 1048576 +\n    ((3 * d * e4) / 16 +\n      (45 * d * e6) / 256 -\n      (d * (32 * d2 - 561) * e8) / 4096 -\n      (d * (232 * d2 - 1677) * e10) / 16384 +\n      (d * (399985 - 90560 * d2 + 512 * d4) * e12) / 5242880) *\n      cos2D +\n    ((21 * d * e6) / 256 +\n      (483 * d * e8) / 4096 -\n      (d * (224 * d2 - 1969) * e10) / 16384 -\n      (d * (33152 * d2 - 112599) * e12) / 1048576) *\n      cos4D +\n    ((151 * d * e8) / 4096 +\n      (4681 * d * e10) / 65536 +\n      (1479 * d * e12) / 16384 -\n      (453 * d3 * e12) / 32768) *\n      cos6D +\n    ((1097 * d * e10) / 65536 + (42783 * d * e12) / 1048576) * cos8D +\n    ((8011 * d * e12) / 1048576) * cos10D +\n    ((3 * e2) / 8 +\n      (3 * e4) / 16 +\n      (213 * e6) / 2048 -\n      (3 * d2 * e6) / 64 +\n      (255 * e8) / 4096 -\n      (33 * d2 * e8) / 512 +\n      (20861 * e10) / 524288 -\n      (33 * d2 * e10) / 512 +\n      (d4 * e10) / 1024 +\n      (28273 * e12) / 1048576 -\n      (471 * d2 * e12) / 8192 +\n      (9 * d4 * e12) / 4096) *\n      sin2D +\n    ((21 * e4) / 256 +\n      (21 * e6) / 256 +\n      (533 * e8) / 8192 -\n      (21 * d2 * e8) / 512 +\n      (197 * e10) / 4096 -\n      (315 * d2 * e10) / 4096 +\n      (584039 * e12) / 16777216 -\n      (12517 * d2 * e12) / 131072 +\n      (7 * d4 * e12) / 2048) *\n      sin4D +\n    ((151 * e6) / 6144 +\n      (151 * e8) / 4096 +\n      (5019 * e10) / 131072 -\n      (453 * d2 * e10) / 16384 +\n      (26965 * e12) / 786432 -\n      (8607 * d2 * e12) / 131072) *\n      sin6D +\n    ((1097 * e8) / 131072 +\n      (1097 * e10) / 65536 +\n      (225797 * e12) / 10485760 -\n      (1097 * d2 * e12) / 65536) *\n      sin8D +\n    ((8011 * e10) / 2621440 + (8011 * e12) / 1048576) * sin10D +\n    ((293393 * e12) / 251658240) * sin12D\n  );\n}\n\nfunction calculateSigma(ellipticity, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude)));\n  }\n\n  const eSinL = ellipticity * Math.sin(latitude);\n  return (\n    Math.log(Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + latitude))) -\n    (ellipticity / 2.0) * Math.log((1 + eSinL) / (1 - eSinL))\n  );\n}\n\nfunction calculateHeading(\n  ellipsoidRhumbLine,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  const sigma1 = calculateSigma(ellipsoidRhumbLine._ellipticity, firstLatitude);\n  const sigma2 = calculateSigma(\n    ellipsoidRhumbLine._ellipticity,\n    secondLatitude\n  );\n  return Math.atan2(\n    CesiumMath.negativePiToPi(secondLongitude - firstLongitude),\n    sigma2 - sigma1\n  );\n}\n\nfunction calculateArcLength(\n  ellipsoidRhumbLine,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  const heading = ellipsoidRhumbLine._heading;\n  const deltaLongitude = secondLongitude - firstLongitude;\n\n  let distance = 0.0;\n\n  //Check to see if the rhumb line has constant latitude\n  //This equation will diverge if heading gets close to 90 degrees\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(heading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8\n    )\n  ) {\n    //If heading is close to 90 degrees\n    if (major === minor) {\n      distance =\n        major *\n        Math.cos(firstLatitude) *\n        CesiumMath.negativePiToPi(deltaLongitude);\n    } else {\n      const sinPhi = Math.sin(firstLatitude);\n      distance =\n        (major *\n          Math.cos(firstLatitude) *\n          CesiumMath.negativePiToPi(deltaLongitude)) /\n        Math.sqrt(1 - ellipsoidRhumbLine._ellipticitySquared * sinPhi * sinPhi);\n    }\n  } else {\n    const M1 = calculateM(\n      ellipsoidRhumbLine._ellipticity,\n      major,\n      firstLatitude\n    );\n    const M2 = calculateM(\n      ellipsoidRhumbLine._ellipticity,\n      major,\n      secondLatitude\n    );\n\n    distance = (M2 - M1) / Math.cos(heading);\n  }\n  return Math.abs(distance);\n}\n\nconst scratchCart1 = new Cartesian3();\nconst scratchCart2 = new Cartesian3();\n\nfunction computeProperties(ellipsoidRhumbLine, start, end, ellipsoid) {\n  const firstCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1\n  );\n  const lastCartesian = Cartesian3.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"value\",\n    Math.abs(\n      Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI\n    ),\n    0.0125\n  );\n  //>>includeEnd('debug');\n\n  const major = ellipsoid.maximumRadius;\n  const minor = ellipsoid.minimumRadius;\n  const majorSquared = major * major;\n  const minorSquared = minor * minor;\n  ellipsoidRhumbLine._ellipticitySquared =\n    (majorSquared - minorSquared) / majorSquared;\n  ellipsoidRhumbLine._ellipticity = Math.sqrt(\n    ellipsoidRhumbLine._ellipticitySquared\n  );\n\n  ellipsoidRhumbLine._start = Cartographic.clone(\n    start,\n    ellipsoidRhumbLine._start\n  );\n  ellipsoidRhumbLine._start.height = 0;\n\n  ellipsoidRhumbLine._end = Cartographic.clone(end, ellipsoidRhumbLine._end);\n  ellipsoidRhumbLine._end.height = 0;\n\n  ellipsoidRhumbLine._heading = calculateHeading(\n    ellipsoidRhumbLine,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n  ellipsoidRhumbLine._distance = calculateArcLength(\n    ellipsoidRhumbLine,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n}\n\nfunction interpolateUsingSurfaceDistance(\n  start,\n  heading,\n  distance,\n  major,\n  ellipticity,\n  result\n) {\n  if (distance === 0.0) {\n    return Cartographic.clone(start, result);\n  }\n\n  const ellipticitySquared = ellipticity * ellipticity;\n\n  let longitude;\n  let latitude;\n  let deltaLongitude;\n\n  //Check to see if the rhumb line has constant latitude\n  //This won't converge if heading is close to 90 degrees\n  if (\n    Math.abs(CesiumMath.PI_OVER_TWO - Math.abs(heading)) > CesiumMath.EPSILON8\n  ) {\n    //Calculate latitude of the second point\n    const M1 = calculateM(ellipticity, major, start.latitude);\n    const deltaM = distance * Math.cos(heading);\n    const M2 = M1 + deltaM;\n    latitude = calculateInverseM(M2, ellipticity, major);\n\n    //Now find the longitude of the second point\n    const sigma1 = calculateSigma(ellipticity, start.latitude);\n    const sigma2 = calculateSigma(ellipticity, latitude);\n    deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n    longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n  } else {\n    //If heading is close to 90 degrees\n    latitude = start.latitude;\n    let localRad;\n\n    if (ellipticity === 0.0) {\n      // sphere\n      localRad = major * Math.cos(start.latitude);\n    } else {\n      const sinPhi = Math.sin(start.latitude);\n      localRad =\n        (major * Math.cos(start.latitude)) /\n        Math.sqrt(1 - ellipticitySquared * sinPhi * sinPhi);\n    }\n\n    deltaLongitude = distance / localRad;\n    if (heading > 0.0) {\n      longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n    } else {\n      longitude = CesiumMath.negativePiToPi(start.longitude - deltaLongitude);\n    }\n  }\n\n  if (defined(result)) {\n    result.longitude = longitude;\n    result.latitude = latitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new Cartographic(longitude, latitude, 0);\n}\n\n/**\n * Initializes a rhumb line on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidRhumbLine\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rhumb line lies.\n *\n * @exception {DeveloperError} angle between start and end must be at least 0.0125 radians.\n */\nfunction EllipsoidRhumbLine(start, end, ellipsoid) {\n  const e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  this._ellipsoid = e;\n  this._start = new Cartographic();\n  this._end = new Cartographic();\n\n  this._heading = undefined;\n  this._distance = undefined;\n  this._ellipticity = undefined;\n  this._ellipticitySquared = undefined;\n\n  if (defined(start) && defined(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidRhumbLine.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading from the start point to the end point.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"distance\", this._distance);\n      //>>includeEnd('debug');\n\n      return this._heading;\n    },\n  },\n});\n\n/**\n * Create a rhumb line using an initial position with a heading and distance.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Number} heading The heading in radians.\n * @param {Number} distance The rhumb line distance between the start and end point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rhumb line lies.\n * @param {EllipsoidRhumbLine} [result] The object in which to store the result.\n * @returns {EllipsoidRhumbLine} The EllipsoidRhumbLine object.\n */\nEllipsoidRhumbLine.fromStartHeadingDistance = function (\n  start,\n  heading,\n  distance,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"heading\", heading);\n  Check.defined(\"distance\", distance);\n  Check.typeOf.number.greaterThan(\"distance\", distance, 0.0);\n  //>>includeEnd('debug');\n\n  const e = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  const major = e.maximumRadius;\n  const minor = e.minimumRadius;\n  const majorSquared = major * major;\n  const minorSquared = minor * minor;\n  const ellipticity = Math.sqrt((majorSquared - minorSquared) / majorSquared);\n\n  heading = CesiumMath.negativePiToPi(heading);\n  const end = interpolateUsingSurfaceDistance(\n    start,\n    heading,\n    distance,\n    e.maximumRadius,\n    ellipticity\n  );\n\n  if (\n    !defined(result) ||\n    (defined(ellipsoid) && !ellipsoid.equals(result.ellipsoid))\n  ) {\n    return new EllipsoidRhumbLine(start, end, e);\n  }\n\n  result.setEndPoints(start, end);\n  return result;\n};\n\n/**\n * Sets the start and end points of the rhumb line.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidRhumbLine.prototype.setEndPoints = function (start, end) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"start\", start);\n  Check.defined(\"end\", end);\n  //>>includeEnd('debug');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the rhumb line.\n *\n * @param {Number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n */\nEllipsoidRhumbLine.prototype.interpolateUsingFraction = function (\n  fraction,\n  result\n) {\n  return this.interpolateUsingSurfaceDistance(\n    fraction * this._distance,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the rhumb line.\n *\n * @param {Number} distance The distance from the inital point to the point of interest along the rhumbLine.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidRhumbLine.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"distance\", distance);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return interpolateUsingSurfaceDistance(\n    this._start,\n    this._heading,\n    distance,\n    this._ellipsoid.maximumRadius,\n    this._ellipticity,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated longitude along the rhumb line.\n * If the longitude is outside the range of start and end points, the first intersection with the longitude from the start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {Number} intersectionLongitude The longitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLongitude = function (\n  intersectionLongitude,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"intersectionLongitude\", intersectionLongitude);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ellipticity = this._ellipticity;\n  const heading = this._heading;\n  const absHeading = Math.abs(heading);\n  const start = this._start;\n\n  intersectionLongitude = CesiumMath.negativePiToPi(intersectionLongitude);\n\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(intersectionLongitude),\n      Math.PI,\n      CesiumMath.EPSILON14\n    )\n  ) {\n    intersectionLongitude = CesiumMath.sign(start.longitude) * Math.PI;\n  }\n\n  if (!defined(result)) {\n    result = new Cartographic();\n  }\n\n  // If heading is -PI/2 or PI/2, this is an E-W rhumb line\n  // If heading is 0 or PI, this is an N-S rhumb line\n  if (Math.abs(CesiumMath.PI_OVER_TWO - absHeading) <= CesiumMath.EPSILON8) {\n    result.longitude = intersectionLongitude;\n    result.latitude = start.latitude;\n    result.height = 0;\n    return result;\n  } else if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(CesiumMath.PI_OVER_TWO - absHeading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8\n    )\n  ) {\n    if (\n      CesiumMath.equalsEpsilon(\n        intersectionLongitude,\n        start.longitude,\n        CesiumMath.EPSILON12\n      )\n    ) {\n      return undefined;\n    }\n\n    result.longitude = intersectionLongitude;\n    result.latitude =\n      CesiumMath.PI_OVER_TWO *\n      CesiumMath.sign(CesiumMath.PI_OVER_TWO - heading);\n    result.height = 0;\n    return result;\n  }\n\n  // Use iterative solver from Equation 9 from http://edwilliams.org/ellipsoid/ellipsoid.pdf\n  const phi1 = start.latitude;\n  const eSinPhi1 = ellipticity * Math.sin(phi1);\n  const leftComponent =\n    Math.tan(0.5 * (CesiumMath.PI_OVER_TWO + phi1)) *\n    Math.exp((intersectionLongitude - start.longitude) / Math.tan(heading));\n  const denominator = (1 + eSinPhi1) / (1 - eSinPhi1);\n\n  let newPhi = start.latitude;\n  let phi;\n  do {\n    phi = newPhi;\n    const eSinPhi = ellipticity * Math.sin(phi);\n    const numerator = (1 + eSinPhi) / (1 - eSinPhi);\n    newPhi =\n      2 *\n        Math.atan(\n          leftComponent * Math.pow(numerator / denominator, ellipticity / 2)\n        ) -\n      CesiumMath.PI_OVER_TWO;\n  } while (!CesiumMath.equalsEpsilon(newPhi, phi, CesiumMath.EPSILON12));\n\n  result.longitude = intersectionLongitude;\n  result.latitude = newPhi;\n  result.height = 0;\n  return result;\n};\n\n/**\n * Provides the location of a point at the indicated latitude along the rhumb line.\n * If the latitude is outside the range of start and end points, the first intersection with the latitude from that start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {Number} intersectionLatitude The latitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLatitude = function (\n  intersectionLatitude,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"intersectionLatitude\", intersectionLatitude);\n  if (!defined(this._distance) || this._distance === 0.0) {\n    throw new DeveloperError(\n      \"EllipsoidRhumbLine must have distinct start and end set.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const ellipticity = this._ellipticity;\n  const heading = this._heading;\n  const start = this._start;\n\n  // If start and end have same latitude, return undefined since it's either no intersection or infinite intersections\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(heading),\n      CesiumMath.PI_OVER_TWO,\n      CesiumMath.EPSILON8\n    )\n  ) {\n    return;\n  }\n\n  // Can be solved using the same equations from interpolateUsingSurfaceDistance\n  const sigma1 = calculateSigma(ellipticity, start.latitude);\n  const sigma2 = calculateSigma(ellipticity, intersectionLatitude);\n  const deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n  const longitude = CesiumMath.negativePiToPi(start.longitude + deltaLongitude);\n\n  if (defined(result)) {\n    result.longitude = longitude;\n    result.latitude = intersectionLatitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new Cartographic(longitude, intersectionLatitude, 0);\n};\nexport default EllipsoidRhumbLine;\n","import AxisAlignedBoundingBox from \"./AxisAlignedBoundingBox.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport Ray from \"./Ray.js\";\nimport Transforms from \"./Transforms.js\";\n\nconst scratchCart4 = new Cartesian4();\n/**\n * A plane tangent to the provided ellipsoid at the provided origin.\n * If origin is not on the surface of the ellipsoid, it's surface projection will be used.\n * If origin is at the center of the ellipsoid, an exception will be thrown.\n * @alias EllipsoidTangentPlane\n * @constructor\n *\n * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n *\n * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n */\nfunction EllipsoidTangentPlane(origin, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"origin\", origin);\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  origin = ellipsoid.scaleToGeodeticSurface(origin);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(origin)) {\n    throw new DeveloperError(\n      \"origin must not be at the center of the ellipsoid.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);\n  this._ellipsoid = ellipsoid;\n  this._origin = origin;\n  this._xAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 0, scratchCart4)\n  );\n  this._yAxis = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 1, scratchCart4)\n  );\n\n  const normal = Cartesian3.fromCartesian4(\n    Matrix4.getColumn(eastNorthUp, 2, scratchCart4)\n  );\n  this._plane = Plane.fromPointNormal(origin, normal);\n}\n\nObject.defineProperties(EllipsoidTangentPlane.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the origin.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Cartesian3}\n   */\n  origin: {\n    get: function () {\n      return this._origin;\n    },\n  },\n\n  /**\n   * Gets the plane which is tangent to the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Plane}\n   */\n  plane: {\n    get: function () {\n      return this._plane;\n    },\n  },\n\n  /**\n   * Gets the local X-axis (east) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  xAxis: {\n    get: function () {\n      return this._xAxis;\n    },\n  },\n\n  /**\n   * Gets the local Y-axis (north) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  yAxis: {\n    get: function () {\n      return this._yAxis;\n    },\n  },\n\n  /**\n   * Gets the local Z-axis (up) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  zAxis: {\n    get: function () {\n      return this._plane.normal;\n    },\n  },\n});\n\nconst tmp = new AxisAlignedBoundingBox();\n/**\n * Creates a new instance from the provided ellipsoid and the center\n * point of the provided Cartesians.\n *\n * @param {Cartesian3[]} cartesians The list of positions surrounding the center point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n * @returns {EllipsoidTangentPlane} The new instance of EllipsoidTangentPlane.\n */\nEllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);\n  return new EllipsoidTangentPlane(box.center, ellipsoid);\n};\n\nconst scratchProjectPointOntoPlaneRay = new Ray();\nconst scratchProjectPointOntoPlaneCartesian3 = new Cartesian3();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n */\nEllipsoidTangentPlane.prototype.projectPointOntoPlane = function (\n  cartesian,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.normalize(cartesian, ray.direction);\n\n  let intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3\n    );\n  }\n\n  if (defined(intersectionPoint)) {\n    const v = Cartesian3.subtract(\n      intersectionPoint,\n      this._origin,\n      intersectionPoint\n    );\n    const x = Cartesian3.dot(this._xAxis, v);\n    const y = Cartesian3.dot(this._yAxis, v);\n\n    if (!defined(result)) {\n      return new Cartesian2(x, y);\n    }\n    result.x = x;\n    result.y = y;\n    return result;\n  }\n  return undefined;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n *\n * @see EllipsoidTangentPlane.projectPointOntoPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  let count = 0;\n  const length = cartesians.length;\n  for (let i = 0; i < length; i++) {\n    const p = this.projectPointOntoPlane(cartesians[i], result[count]);\n    if (defined(p)) {\n      result[count] = p;\n      count++;\n    }\n  }\n  result.length = count;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (\n  cartesian,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  const ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  Cartesian3.clone(this._plane.normal, ray.direction);\n\n  let intersectionPoint = IntersectionTests.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3\n  );\n  if (!defined(intersectionPoint)) {\n    Cartesian3.negate(ray.direction, ray.direction);\n    intersectionPoint = IntersectionTests.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3\n    );\n  }\n\n  const v = Cartesian3.subtract(\n    intersectionPoint,\n    this._origin,\n    intersectionPoint\n  );\n  const x = Cartesian3.dot(this._xAxis, v);\n  const y = Cartesian3.dot(this._yAxis, v);\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n *\n * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n */\nEllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const length = cartesians.length;\n  result.length = length;\n  for (let i = 0; i < length; i++) {\n    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n  }\n  return result;\n};\n\nconst projectPointsOntoEllipsoidScratch = new Cartesian3();\n/**\n * Computes the projection of the provided 2D position onto the 3D ellipsoid.\n *\n * @param {Cartesian2} cartesian The points to project.\n * @param {Cartesian3} [result] The Cartesian3 instance to store result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (\n  cartesian,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const ellipsoid = this._ellipsoid;\n  const origin = this._origin;\n  const xAxis = this._xAxis;\n  const yAxis = this._yAxis;\n  const tmp = projectPointsOntoEllipsoidScratch;\n\n  Cartesian3.multiplyByScalar(xAxis, cartesian.x, tmp);\n  result = Cartesian3.add(origin, tmp, result);\n  Cartesian3.multiplyByScalar(yAxis, cartesian.y, tmp);\n  Cartesian3.add(result, tmp, result);\n  ellipsoid.scaleToGeocentricSurface(result, result);\n\n  return result;\n};\n\n/**\n * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n *\n * @param {Cartesian2[]} cartesians The array of points to project.\n * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  const length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\n  }\n\n  return result;\n};\nexport default EllipsoidTangentPlane;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n\n/**\n * A very simple {@link TerrainProvider} that produces geometry by tessellating an ellipsoidal\n * surface.\n *\n * @alias EllipsoidTerrainProvider\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {TilingScheme} [options.tilingScheme] The tiling scheme specifying how the ellipsoidal\n * surface is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}\n * is used.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n * this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither\n * parameter is specified, the WGS84 ellipsoid is used.\n *\n * @see TerrainProvider\n */\nfunction EllipsoidTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._tilingScheme = options.tilingScheme;\n  if (!defined(this._tilingScheme)) {\n    this._tilingScheme = new GeographicTilingScheme({\n      ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.WGS84),\n    });\n  }\n\n  // Note: the 64 below does NOT need to match the actual vertex dimensions, because\n  // the ellipsoid is significantly smoother than actual terrain.\n  this._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    this._tilingScheme.ellipsoid,\n    64,\n    this._tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n\n  this._errorEvent = new Event();\n  this._readyPromise = Promise.resolve(true);\n}\n\nObject.defineProperties(EllipsoidTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link EllipsoidTerrainProvider#ready} returns true.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return true;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link EllipsoidTerrainProvider#ready} returns true.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link TerrainProvider#ready} returns true.  The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nEllipsoidTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  const width = 16;\n  const height = 16;\n  return Promise.resolve(\n    new HeightmapTerrainData({\n      buffer: new Uint8Array(width * height),\n      width: width,\n      height: height,\n    })\n  );\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nEllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nEllipsoidTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined} This provider does not support loading availability.\n */\nEllipsoidTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\nexport default EllipsoidTerrainProvider;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n * origin of the coordinate system.  This class uses the algorithm described in the\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n *\n * @alias EllipsoidalOccluder\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n *        testing visibility.\n *\n * @constructor\n *\n * @example\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * const cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * const occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n * @private\n */\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  this._ellipsoid = ellipsoid;\n  this._cameraPosition = new Cartesian3();\n  this._cameraPositionInScaledSpace = new Cartesian3();\n  this._distanceToLimbInScaledSpaceSquared = 0.0;\n\n  // cameraPosition fills in the above values\n  if (defined(cameraPosition)) {\n    this.cameraPosition = cameraPosition;\n  }\n}\n\nObject.defineProperties(EllipsoidalOccluder.prototype, {\n  /**\n   * Gets the occluding ellipsoid.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets or sets the position of the camera.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    get: function () {\n      return this._cameraPosition;\n    },\n    set: function (cameraPosition) {\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n      const ellipsoid = this._ellipsoid;\n      const cv = ellipsoid.transformPositionToScaledSpace(\n        cameraPosition,\n        this._cameraPositionInScaledSpace\n      );\n      const vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1.0;\n\n      Cartesian3.clone(cameraPosition, this._cameraPosition);\n      this._cameraPositionInScaledSpace = cv;\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n    },\n  },\n});\n\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point to test for visibility.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true\n */\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\n  const ellipsoid = this._ellipsoid;\n  const occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    occludee,\n    scratchCartesian\n  );\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\n/**\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * const cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * const ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * const occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * const point = new Cesium.Cartesian3(0, -3, -3);\n * const scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (\n  occludeeScaledSpacePosition\n) {\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\nconst scratchCameraPositionInScaledSpaceShrunk = new Cartesian3();\n\n/**\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. This is intended to be used with points generated by\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (\n  occludeeScaledSpacePosition,\n  minimumHeight\n) {\n  const ellipsoid = this._ellipsoid;\n  let vhMagnitudeSquared;\n  let cv;\n\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n    cv = scratchCameraPositionInScaledSpaceShrunk;\n    cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n    cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n    cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n    vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n  } else {\n    cv = this._cameraPositionInScaledSpace;\n    vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n  }\n\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    cv,\n    vhMagnitudeSquared\n  );\n};\n\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (\n  directionToPoint,\n  positions,\n  result\n) {\n  return computeHorizonCullingPointFromPositions(\n    this._ellipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n\nconst scratchEllipsoidShrunk = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid's axes.\n * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  positions,\n  minimumHeight,\n  result\n) {\n  const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromPositions(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  return computeHorizonCullingPointFromVertices(\n    this._ellipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid's axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  minimumHeight,\n  result\n) {\n  const possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromVertices(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\nconst subsampleScratch = [];\n\n/**\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n *                    the ellipsoid used by this instance for occlusion testing.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (\n  rectangle,\n  ellipsoid,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    0.0,\n    subsampleScratch\n  );\n  const bs = BoundingSphere.fromPoints(positions);\n\n  // If the bounding sphere center is too close to the center of the occluder, it doesn't make\n  // sense to try to horizon cull it.\n  if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n    return undefined;\n  }\n\n  return this.computeHorizonCullingPoint(bs.center, positions, result);\n};\n\nconst scratchEllipsoidShrunkRadii = new Cartesian3();\n\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n  if (\n    defined(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    const ellipsoidShrunkRadii = Cartesian3.fromElements(\n      ellipsoid.radii.x + minimumHeight,\n      ellipsoid.radii.y + minimumHeight,\n      ellipsoid.radii.z + minimumHeight,\n      scratchEllipsoidShrunkRadii\n    );\n    ellipsoid = Ellipsoid.fromCartesian3(ellipsoidShrunkRadii, result);\n  }\n  return ellipsoid;\n}\n\nfunction computeHorizonCullingPointFromPositions(\n  ellipsoid,\n  directionToPoint,\n  positions,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"positions\", positions);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  let resultMagnitude = 0.0;\n\n  for (let i = 0, len = positions.length; i < len; ++i) {\n    const position = positions[i];\n    const candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      position,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nconst positionScratch = new Cartesian3();\n\nfunction computeHorizonCullingPointFromVertices(\n  ellipsoid,\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"directionToPoint\", directionToPoint);\n  Check.defined(\"vertices\", vertices);\n  Check.typeOf.number(\"stride\", stride);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  stride = defaultValue(stride, 3);\n  center = defaultValue(center, Cartesian3.ZERO);\n  const scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  let resultMagnitude = 0.0;\n\n  for (let i = 0, len = vertices.length; i < len; i += stride) {\n    positionScratch.x = vertices[i] + center.x;\n    positionScratch.y = vertices[i + 1] + center.y;\n    positionScratch.z = vertices[i + 2] + center.z;\n\n    const candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      positionScratch,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn't, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nfunction isScaledSpacePointVisible(\n  occludeeScaledSpacePosition,\n  cameraPositionInScaledSpace,\n  distanceToLimbInScaledSpaceSquared\n) {\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n  const cv = cameraPositionInScaledSpace;\n  const vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n  const vt = Cartesian3.subtract(\n    occludeeScaledSpacePosition,\n    cv,\n    scratchCartesian\n  );\n  const vtDotVc = -Cartesian3.dot(vt, cv);\n  // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n  // in this case, set the culling plane to be on V.\n  const isOccluded =\n    vhMagnitudeSquared < 0\n      ? vtDotVc > 0\n      : vtDotVc > vhMagnitudeSquared &&\n        (vtDotVc * vtDotVc) / Cartesian3.magnitudeSquared(vt) >\n          vhMagnitudeSquared;\n  return !isOccluded;\n}\n\nconst scaledSpaceScratch = new Cartesian3();\nconst directionScratch = new Cartesian3();\n\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n  const scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    position,\n    scaledSpaceScratch\n  );\n  let magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);\n  let magnitude = Math.sqrt(magnitudeSquared);\n  const direction = Cartesian3.divideByScalar(\n    scaledSpacePosition,\n    magnitude,\n    directionScratch\n  );\n\n  // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\n  magnitude = Math.max(1.0, magnitude);\n\n  const cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);\n  const sinAlpha = Cartesian3.magnitude(\n    Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction)\n  );\n  const cosBeta = 1.0 / magnitude;\n  const sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n}\n\nfunction magnitudeToPoint(\n  scaledSpaceDirectionToPoint,\n  resultMagnitude,\n  result\n) {\n  // The horizon culling point is undefined if there were no positions from which to compute it,\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n  if (\n    resultMagnitude <= 0.0 ||\n    resultMagnitude === 1.0 / 0.0 ||\n    resultMagnitude !== resultMagnitude\n  ) {\n    return undefined;\n  }\n\n  return Cartesian3.multiplyByScalar(\n    scaledSpaceDirectionToPoint,\n    resultMagnitude,\n    result\n  );\n}\n\nconst directionToPointScratch = new Cartesian3();\n\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n  if (Cartesian3.equals(directionToPoint, Cartesian3.ZERO)) {\n    return directionToPoint;\n  }\n\n  ellipsoid.transformPositionToScaledSpace(\n    directionToPoint,\n    directionToPointScratch\n  );\n  return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);\n}\nexport default EllipsoidalOccluder;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * A fixed-point encoding of a {@link Cartesian3} with 64-bit floating-point components, as two {@link Cartesian3}\n * values that, when converted to 32-bit floating-point and added, approximate the original input.\n * <p>\n * This is used to encode positions in vertex buffers for rendering without jittering artifacts\n * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @alias EncodedCartesian3\n * @constructor\n *\n * @private\n */\nfunction EncodedCartesian3() {\n  /**\n   * The high bits for each component.  Bits 0 to 22 store the whole value.  Bits 23 to 31 are not used.\n   *\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.high = Cartesian3.clone(Cartesian3.ZERO);\n\n  /**\n   * The low bits for each component.  Bits 7 to 22 store the whole value, and bits 0 to 6 store the fraction.  Bits 23 to 31 are not used.\n   *\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.low = Cartesian3.clone(Cartesian3.ZERO);\n}\n\n/**\n * Encodes a 64-bit floating-point value as two floating-point values that, when converted to\n * 32-bit floating-point and added, approximate the original input.  The returned object\n * has <code>high</code> and <code>low</code> properties for the high and low bits, respectively.\n * <p>\n * The fixed-point encoding follows {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @param {Number} value The floating-point value to encode.\n * @param {Object} [result] The object onto which to store the result.\n * @returns {Object} The modified result parameter or a new instance if one was not provided.\n *\n * @example\n * const value = 1234567.1234567;\n * const splitValue = Cesium.EncodedCartesian3.encode(value);\n */\nEncodedCartesian3.encode = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = {\n      high: 0.0,\n      low: 0.0,\n    };\n  }\n\n  let doubleHigh;\n  if (value >= 0.0) {\n    doubleHigh = Math.floor(value / 65536.0) * 65536.0;\n    result.high = doubleHigh;\n    result.low = value - doubleHigh;\n  } else {\n    doubleHigh = Math.floor(-value / 65536.0) * 65536.0;\n    result.high = -doubleHigh;\n    result.low = value + doubleHigh;\n  }\n\n  return result;\n};\n\nconst scratchEncode = {\n  high: 0.0,\n  low: 0.0,\n};\n\n/**\n * Encodes a {@link Cartesian3} with 64-bit floating-point components as two {@link Cartesian3}\n * values that, when converted to 32-bit floating-point and added, approximate the original input.\n * <p>\n * The fixed-point encoding follows {@link https://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @param {Cartesian3} cartesian The cartesian to encode.\n * @param {EncodedCartesian3} [result] The object onto which to store the result.\n * @returns {EncodedCartesian3} The modified result parameter or a new EncodedCartesian3 instance if one was not provided.\n *\n * @example\n * const cart = new Cesium.Cartesian3(-10000000.0, 0.0, 10000000.0);\n * const encoded = Cesium.EncodedCartesian3.fromCartesian(cart);\n */\nEncodedCartesian3.fromCartesian = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new EncodedCartesian3();\n  }\n\n  const high = result.high;\n  const low = result.low;\n\n  EncodedCartesian3.encode(cartesian.x, scratchEncode);\n  high.x = scratchEncode.high;\n  low.x = scratchEncode.low;\n\n  EncodedCartesian3.encode(cartesian.y, scratchEncode);\n  high.y = scratchEncode.high;\n  low.y = scratchEncode.low;\n\n  EncodedCartesian3.encode(cartesian.z, scratchEncode);\n  high.z = scratchEncode.high;\n  low.z = scratchEncode.low;\n\n  return result;\n};\n\nconst encodedP = new EncodedCartesian3();\n\n/**\n * Encodes the provided <code>cartesian</code>, and writes it to an array with <code>high</code>\n * components followed by <code>low</code> components, i.e. <code>[high.x, high.y, high.z, low.x, low.y, low.z]</code>.\n * <p>\n * This is used to create interleaved high-precision position vertex attributes.\n * </p>\n *\n * @param {Cartesian3} cartesian The cartesian to encode.\n * @param {Number[]} cartesianArray The array to write to.\n * @param {Number} index The index into the array to start writing.  Six elements will be written.\n *\n * @exception {DeveloperError} index must be a number greater than or equal to 0.\n *\n * @example\n * const positions = [\n *    new Cesium.Cartesian3(),\n *    // ...\n * ];\n * const encodedPositions = new Float32Array(2 * 3 * positions.length);\n * let j = 0;\n * for (let i = 0; i < positions.length; ++i) {\n *   Cesium.EncodedCartesian3.writeElement(positions[i], encodedPositions, j);\n *   j += 6;\n * }\n */\nEncodedCartesian3.writeElements = function (cartesian, cartesianArray, index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesianArray\", cartesianArray);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.number.greaterThanOrEquals(\"index\", index, 0);\n  //>>includeEnd('debug');\n\n  EncodedCartesian3.fromCartesian(cartesian, encodedP);\n  const high = encodedP.high;\n  const low = encodedP.low;\n\n  cartesianArray[index] = high.x;\n  cartesianArray[index + 1] = high.y;\n  cartesianArray[index + 2] = high.z;\n  cartesianArray[index + 3] = low.x;\n  cartesianArray[index + 4] = low.y;\n  cartesianArray[index + 5] = low.z;\n};\nexport default EncodedCartesian3;\n","import Check from \"./Check.js\";\nimport defined from \"./defined.js\";\n\n/**\n * A generic utility class for managing subscribers for a particular event.\n * This class is usually instantiated inside of a container class and\n * exposed as a property for others to subscribe to.\n *\n * @alias Event\n * @template Listener extends (...args: any[]) => void = (...args: any[]) => void\n * @constructor\n * @example\n * MyObject.prototype.myListener = function(arg1, arg2) {\n *     this.myArg1Copy = arg1;\n *     this.myArg2Copy = arg2;\n * }\n *\n * const myObjectInstance = new MyObject();\n * const evt = new Cesium.Event();\n * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);\n * evt.raiseEvent('1', '2');\n * evt.removeEventListener(MyObject.prototype.myListener);\n */\nfunction Event() {\n  this._listeners = [];\n  this._scopes = [];\n  this._toRemove = [];\n  this._insideRaiseEvent = false;\n}\n\nObject.defineProperties(Event.prototype, {\n  /**\n   * The number of listeners currently subscribed to the event.\n   * @memberof Event.prototype\n   * @type {Number}\n   * @readonly\n   */\n  numberOfListeners: {\n    get: function () {\n      return this._listeners.length - this._toRemove.length;\n    },\n  },\n});\n\n/**\n * Registers a callback function to be executed whenever the event is raised.\n * An optional scope can be provided to serve as the <code>this</code> pointer\n * in which the function will execute.\n *\n * @param {Listener} listener The function to be executed when the event is raised.\n * @param {Object} [scope] An optional object scope to serve as the <code>this</code>\n *        pointer in which the listener function will execute.\n * @returns {Event.RemoveCallback} A function that will remove this event listener when invoked.\n *\n * @see Event#raiseEvent\n * @see Event#removeEventListener\n */\nEvent.prototype.addEventListener = function (listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"listener\", listener);\n  //>>includeEnd('debug');\n\n  this._listeners.push(listener);\n  this._scopes.push(scope);\n\n  const event = this;\n  return function () {\n    event.removeEventListener(listener, scope);\n  };\n};\n\n/**\n * Unregisters a previously registered callback.\n *\n * @param {Listener} listener The function to be unregistered.\n * @param {Object} [scope] The scope that was originally passed to addEventListener.\n * @returns {Boolean} <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.\n *\n * @see Event#addEventListener\n * @see Event#raiseEvent\n */\nEvent.prototype.removeEventListener = function (listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.func(\"listener\", listener);\n  //>>includeEnd('debug');\n\n  const listeners = this._listeners;\n  const scopes = this._scopes;\n\n  let index = -1;\n  for (let i = 0; i < listeners.length; i++) {\n    if (listeners[i] === listener && scopes[i] === scope) {\n      index = i;\n      break;\n    }\n  }\n\n  if (index !== -1) {\n    if (this._insideRaiseEvent) {\n      //In order to allow removing an event subscription from within\n      //a callback, we don't actually remove the items here.  Instead\n      //remember the index they are at and undefined their value.\n      this._toRemove.push(index);\n      listeners[index] = undefined;\n      scopes[index] = undefined;\n    } else {\n      listeners.splice(index, 1);\n      scopes.splice(index, 1);\n    }\n    return true;\n  }\n\n  return false;\n};\n\nfunction compareNumber(a, b) {\n  return b - a;\n}\n\n/**\n * Raises the event by calling each registered listener with all supplied arguments.\n *\n * @param {...Parameters<Listener>} arguments This method takes any number of parameters and passes them through to the listener functions.\n *\n * @see Event#addEventListener\n * @see Event#removeEventListener\n */\nEvent.prototype.raiseEvent = function () {\n  this._insideRaiseEvent = true;\n\n  let i;\n  const listeners = this._listeners;\n  const scopes = this._scopes;\n  let length = listeners.length;\n\n  for (i = 0; i < length; i++) {\n    const listener = listeners[i];\n    if (defined(listener)) {\n      listeners[i].apply(scopes[i], arguments);\n    }\n  }\n\n  //Actually remove items removed in removeEventListener.\n  const toRemove = this._toRemove;\n  length = toRemove.length;\n  if (length > 0) {\n    toRemove.sort(compareNumber);\n    for (i = 0; i < length; i++) {\n      const index = toRemove[i];\n      listeners.splice(index, 1);\n      scopes.splice(index, 1);\n    }\n    toRemove.length = 0;\n  }\n\n  this._insideRaiseEvent = false;\n};\n\n/**\n * A function that removes a listener.\n * @callback Event.RemoveCallback\n */\n\nexport default Event;\n","import defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * A convenience object that simplifies the common pattern of attaching event listeners\n * to several events, then removing all those listeners at once later, for example, in\n * a destroy method.\n *\n * @alias EventHelper\n * @constructor\n *\n *\n * @example\n * const helper = new Cesium.EventHelper();\n *\n * helper.add(someObject.event, listener1, this);\n * helper.add(otherObject.event, listener2, this);\n *\n * // later...\n * helper.removeAll();\n *\n * @see Event\n */\nfunction EventHelper() {\n  this._removalFunctions = [];\n}\n\n/**\n * Adds a listener to an event, and records the registration to be cleaned up later.\n *\n * @param {Event} event The event to attach to.\n * @param {Function} listener The function to be executed when the event is raised.\n * @param {Object} [scope] An optional object scope to serve as the <code>this</code>\n *        pointer in which the listener function will execute.\n * @returns {EventHelper.RemoveCallback} A function that will remove this event listener when invoked.\n *\n * @see Event#addEventListener\n */\nEventHelper.prototype.add = function (event, listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(event)) {\n    throw new DeveloperError(\"event is required\");\n  }\n  //>>includeEnd('debug');\n\n  const removalFunction = event.addEventListener(listener, scope);\n  this._removalFunctions.push(removalFunction);\n\n  const that = this;\n  return function () {\n    removalFunction();\n    const removalFunctions = that._removalFunctions;\n    removalFunctions.splice(removalFunctions.indexOf(removalFunction), 1);\n  };\n};\n\n/**\n * Unregisters all previously added listeners.\n *\n * @see Event#removeEventListener\n */\nEventHelper.prototype.removeAll = function () {\n  const removalFunctions = this._removalFunctions;\n  for (let i = 0, len = removalFunctions.length; i < len; ++i) {\n    removalFunctions[i]();\n  }\n  removalFunctions.length = 0;\n};\n\n/**\n * A function that removes a listener.\n * @callback EventHelper.RemoveCallback\n */\nexport default EventHelper;\n","/**\n * Flags to enable experimental features in CesiumJS. Stability and performance\n * may not be optimal when these are enabled. Experimental features are subject\n * to change without Cesium's standard deprecation policy.\n * <p>\n * Experimental features must still uphold Cesium's quality standards. Here\n * are some guidelines:\n * </p>\n * <ul>\n *   <li>Experimental features must have high unit test coverage like any other feature.</li>\n *   <li>Experimental features are intended for large features where there is benefit of merging some of the code sooner (e.g. to avoid long-running staging branches)</li>\n *   <li>Experimental flags should be short-lived. Make it clear in the PR what it would take to promote the feature to a regular feature.</li>\n *   <li>To avoid cluttering the code, check the flag in as few places as possible. Ideally this would be a single place.</li>\n * </ul>\n *\n * @namespace\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst ExperimentalFeatures = {\n  /**\n   * Toggles the usage of the ModelExperimental class.\n   *\n   * @type {Boolean}\n   */\n  enableModelExperimental: false,\n};\n\nexport default ExperimentalFeatures;\n","/**\n * Constants to determine how an interpolated value is extrapolated\n * when querying outside the bounds of available data.\n *\n * @enum {Number}\n *\n * @see SampledProperty\n */\nconst ExtrapolationType = {\n  /**\n   * No extrapolation occurs.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * The first or last value is used when outside the range of sample data.\n   *\n   * @type {Number}\n   * @constant\n   */\n  HOLD: 1,\n\n  /**\n   * The value is extrapolated.\n   *\n   * @type {Number}\n   * @constant\n   */\n  EXTRAPOLATE: 2,\n};\nexport default Object.freeze(ExtrapolationType);\n","import defaultValue from \"./defaultValue.js\";\nimport defer from \"./defer.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Fullscreen from \"./Fullscreen.js\";\n\nlet theNavigator;\nif (typeof navigator !== \"undefined\") {\n  theNavigator = navigator;\n} else {\n  theNavigator = {};\n}\n\nfunction extractVersion(versionString) {\n  const parts = versionString.split(\".\");\n  for (let i = 0, len = parts.length; i < len; ++i) {\n    parts[i] = parseInt(parts[i], 10);\n  }\n  return parts;\n}\n\nlet isChromeResult;\nlet chromeVersionResult;\nfunction isChrome() {\n  if (!defined(isChromeResult)) {\n    isChromeResult = false;\n    // Edge contains Chrome in the user agent too\n    if (!isEdge()) {\n      const fields = / Chrome\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n      if (fields !== null) {\n        isChromeResult = true;\n        chromeVersionResult = extractVersion(fields[1]);\n      }\n    }\n  }\n\n  return isChromeResult;\n}\n\nfunction chromeVersion() {\n  return isChrome() && chromeVersionResult;\n}\n\nlet isSafariResult;\nlet safariVersionResult;\nfunction isSafari() {\n  if (!defined(isSafariResult)) {\n    isSafariResult = false;\n\n    // Chrome and Edge contain Safari in the user agent too\n    if (\n      !isChrome() &&\n      !isEdge() &&\n      / Safari\\/[\\.0-9]+/.test(theNavigator.userAgent)\n    ) {\n      const fields = / Version\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n      if (fields !== null) {\n        isSafariResult = true;\n        safariVersionResult = extractVersion(fields[1]);\n      }\n    }\n  }\n\n  return isSafariResult;\n}\n\nfunction safariVersion() {\n  return isSafari() && safariVersionResult;\n}\n\nlet isWebkitResult;\nlet webkitVersionResult;\nfunction isWebkit() {\n  if (!defined(isWebkitResult)) {\n    isWebkitResult = false;\n\n    const fields = / AppleWebKit\\/([\\.0-9]+)(\\+?)/.exec(theNavigator.userAgent);\n    if (fields !== null) {\n      isWebkitResult = true;\n      webkitVersionResult = extractVersion(fields[1]);\n      webkitVersionResult.isNightly = !!fields[2];\n    }\n  }\n\n  return isWebkitResult;\n}\n\nfunction webkitVersion() {\n  return isWebkit() && webkitVersionResult;\n}\n\nlet isInternetExplorerResult;\nlet internetExplorerVersionResult;\nfunction isInternetExplorer() {\n  if (!defined(isInternetExplorerResult)) {\n    isInternetExplorerResult = false;\n\n    let fields;\n    if (theNavigator.appName === \"Microsoft Internet Explorer\") {\n      fields = /MSIE ([0-9]{1,}[\\.0-9]{0,})/.exec(theNavigator.userAgent);\n      if (fields !== null) {\n        isInternetExplorerResult = true;\n        internetExplorerVersionResult = extractVersion(fields[1]);\n      }\n    } else if (theNavigator.appName === \"Netscape\") {\n      fields = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(\n        theNavigator.userAgent\n      );\n      if (fields !== null) {\n        isInternetExplorerResult = true;\n        internetExplorerVersionResult = extractVersion(fields[1]);\n      }\n    }\n  }\n  return isInternetExplorerResult;\n}\n\nfunction internetExplorerVersion() {\n  return isInternetExplorer() && internetExplorerVersionResult;\n}\n\nlet isEdgeResult;\nlet edgeVersionResult;\nfunction isEdge() {\n  if (!defined(isEdgeResult)) {\n    isEdgeResult = false;\n    const fields = / Edge\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n    if (fields !== null) {\n      isEdgeResult = true;\n      edgeVersionResult = extractVersion(fields[1]);\n    }\n  }\n  return isEdgeResult;\n}\n\nfunction edgeVersion() {\n  return isEdge() && edgeVersionResult;\n}\n\nlet isFirefoxResult;\nlet firefoxVersionResult;\nfunction isFirefox() {\n  if (!defined(isFirefoxResult)) {\n    isFirefoxResult = false;\n\n    const fields = /Firefox\\/([\\.0-9]+)/.exec(theNavigator.userAgent);\n    if (fields !== null) {\n      isFirefoxResult = true;\n      firefoxVersionResult = extractVersion(fields[1]);\n    }\n  }\n  return isFirefoxResult;\n}\n\nlet isWindowsResult;\nfunction isWindows() {\n  if (!defined(isWindowsResult)) {\n    isWindowsResult = /Windows/i.test(theNavigator.appVersion);\n  }\n  return isWindowsResult;\n}\n\nlet isIPadOrIOSResult;\nfunction isIPadOrIOS() {\n  if (!defined(isIPadOrIOSResult)) {\n    isIPadOrIOSResult =\n      navigator.platform === \"iPhone\" ||\n      navigator.platform === \"iPod\" ||\n      navigator.platform === \"iPad\";\n  }\n\n  return isIPadOrIOSResult;\n}\n\nfunction firefoxVersion() {\n  return isFirefox() && firefoxVersionResult;\n}\n\nlet hasPointerEvents;\nfunction supportsPointerEvents() {\n  if (!defined(hasPointerEvents)) {\n    //While navigator.pointerEnabled is deprecated in the W3C specification\n    //we still need to use it if it exists in order to support browsers\n    //that rely on it, such as the Windows WebBrowser control which defines\n    //PointerEvent but sets navigator.pointerEnabled to false.\n\n    //Firefox disabled because of https://github.com/CesiumGS/cesium/issues/6372\n    hasPointerEvents =\n      !isFirefox() &&\n      typeof PointerEvent !== \"undefined\" &&\n      (!defined(theNavigator.pointerEnabled) || theNavigator.pointerEnabled);\n  }\n  return hasPointerEvents;\n}\n\nlet imageRenderingValueResult;\nlet supportsImageRenderingPixelatedResult;\nfunction supportsImageRenderingPixelated() {\n  if (!defined(supportsImageRenderingPixelatedResult)) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\n      \"style\",\n      \"image-rendering: -moz-crisp-edges;\" + \"image-rendering: pixelated;\"\n    );\n    //canvas.style.imageRendering will be undefined, null or an empty string on unsupported browsers.\n    const tmp = canvas.style.imageRendering;\n    supportsImageRenderingPixelatedResult = defined(tmp) && tmp !== \"\";\n    if (supportsImageRenderingPixelatedResult) {\n      imageRenderingValueResult = tmp;\n    }\n  }\n  return supportsImageRenderingPixelatedResult;\n}\n\nfunction imageRenderingValue() {\n  return supportsImageRenderingPixelated()\n    ? imageRenderingValueResult\n    : undefined;\n}\n\nfunction supportsWebP() {\n  //>>includeStart('debug', pragmas.debug);\n  if (!supportsWebP.initialized) {\n    throw new DeveloperError(\n      \"You must call FeatureDetection.supportsWebP.initialize and wait for the promise to resolve before calling FeatureDetection.supportsWebP\"\n    );\n  }\n  //>>includeEnd('debug');\n  return supportsWebP._result;\n}\nsupportsWebP._promise = undefined;\nsupportsWebP._result = undefined;\nsupportsWebP.initialize = function () {\n  // From https://developers.google.com/speed/webp/faq#how_can_i_detect_browser_support_for_webp\n  if (defined(supportsWebP._promise)) {\n    return supportsWebP._promise;\n  }\n\n  const supportsWebPDeferred = defer();\n  supportsWebP._promise = supportsWebPDeferred.promise;\n  if (isEdge()) {\n    // Edge's WebP support with WebGL is incomplete.\n    // See bug report: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/19221241/\n    supportsWebP._result = false;\n    supportsWebPDeferred.resolve(supportsWebP._result);\n    return supportsWebPDeferred.promise;\n  }\n\n  const image = new Image();\n  image.onload = function () {\n    supportsWebP._result = image.width > 0 && image.height > 0;\n    supportsWebPDeferred.resolve(supportsWebP._result);\n  };\n\n  image.onerror = function () {\n    supportsWebP._result = false;\n    supportsWebPDeferred.resolve(supportsWebP._result);\n  };\n\n  image.src =\n    \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n\n  return supportsWebPDeferred.promise;\n};\nObject.defineProperties(supportsWebP, {\n  initialized: {\n    get: function () {\n      return defined(supportsWebP._result);\n    },\n  },\n});\n\nconst typedArrayTypes = [];\nif (typeof ArrayBuffer !== \"undefined\") {\n  typedArrayTypes.push(\n    Int8Array,\n    Uint8Array,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array\n  );\n\n  if (typeof Uint8ClampedArray !== \"undefined\") {\n    typedArrayTypes.push(Uint8ClampedArray);\n  }\n\n  if (typeof Uint8ClampedArray !== \"undefined\") {\n    typedArrayTypes.push(Uint8ClampedArray);\n  }\n\n  if (typeof BigInt64Array !== \"undefined\") {\n    // eslint-disable-next-line no-undef\n    typedArrayTypes.push(BigInt64Array);\n  }\n\n  if (typeof BigUint64Array !== \"undefined\") {\n    // eslint-disable-next-line no-undef\n    typedArrayTypes.push(BigUint64Array);\n  }\n}\n\n/**\n * A set of functions to detect whether the current browser supports\n * various features.\n *\n * @namespace FeatureDetection\n */\nconst FeatureDetection = {\n  isChrome: isChrome,\n  chromeVersion: chromeVersion,\n  isSafari: isSafari,\n  safariVersion: safariVersion,\n  isWebkit: isWebkit,\n  webkitVersion: webkitVersion,\n  isInternetExplorer: isInternetExplorer,\n  internetExplorerVersion: internetExplorerVersion,\n  isEdge: isEdge,\n  edgeVersion: edgeVersion,\n  isFirefox: isFirefox,\n  firefoxVersion: firefoxVersion,\n  isWindows: isWindows,\n  isIPadOrIOS: isIPadOrIOS,\n  hardwareConcurrency: defaultValue(theNavigator.hardwareConcurrency, 3),\n  supportsPointerEvents: supportsPointerEvents,\n  supportsImageRenderingPixelated: supportsImageRenderingPixelated,\n  supportsWebP: supportsWebP,\n  imageRenderingValue: imageRenderingValue,\n  typedArrayTypes: typedArrayTypes,\n};\n\n/**\n * Detects whether the current browser supports Basis Universal textures and the web assembly modules needed to transcode them.\n *\n * @param {Scene} scene\n * @returns {Boolean} true if the browser supports web assembly modules and the scene supports Basis Universal textures, false if not.\n */\nFeatureDetection.supportsBasis = function (scene) {\n  return FeatureDetection.supportsWebAssembly() && scene.context.supportsBasis;\n};\n\n/**\n * Detects whether the current browser supports the full screen standard.\n *\n * @returns {Boolean} true if the browser supports the full screen standard, false if not.\n *\n * @see Fullscreen\n * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}\n */\nFeatureDetection.supportsFullscreen = function () {\n  return Fullscreen.supportsFullscreen();\n};\n\n/**\n * Detects whether the current browser supports typed arrays.\n *\n * @returns {Boolean} true if the browser supports typed arrays, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}\n */\nFeatureDetection.supportsTypedArrays = function () {\n  return typeof ArrayBuffer !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports BigInt64Array typed arrays.\n *\n * @returns {Boolean} true if the browser supports BigInt64Array typed arrays, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}\n */\nFeatureDetection.supportsBigInt64Array = function () {\n  return typeof BigInt64Array !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports BigUint64Array typed arrays.\n *\n * @returns {Boolean} true if the browser supports BigUint64Array typed arrays, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-typedarray-objects|Typed Array Specification}\n */\nFeatureDetection.supportsBigUint64Array = function () {\n  return typeof BigUint64Array !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports BigInt.\n *\n * @returns {Boolean} true if the browser supports BigInt, false if not.\n *\n * @see {@link https://tc39.es/ecma262/#sec-bigint-objects|BigInt Specification}\n */\nFeatureDetection.supportsBigInt = function () {\n  return typeof BigInt !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports Web Workers.\n *\n * @returns {Boolean} true if the browsers supports Web Workers, false if not.\n *\n * @see {@link http://www.w3.org/TR/workers/}\n */\nFeatureDetection.supportsWebWorkers = function () {\n  return typeof Worker !== \"undefined\";\n};\n\n/**\n * Detects whether the current browser supports Web Assembly.\n *\n * @returns {Boolean} true if the browsers supports Web Assembly, false if not.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/WebAssembly}\n */\nFeatureDetection.supportsWebAssembly = function () {\n  return typeof WebAssembly !== \"undefined\";\n};\nexport default FeatureDetection;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport VertexFormat from \"./VertexFormat.js\";\n\nconst PERSPECTIVE = 0;\nconst ORTHOGRAPHIC = 1;\n\n/**\n * Describes a frustum at the given the origin and orientation.\n *\n * @alias FrustumGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n */\nfunction FrustumGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  const frustum = options.frustum;\n  const orientation = options.orientation;\n  const origin = options.origin;\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  const drawNearPlane = defaultValue(options._drawNearPlane, true);\n\n  let frustumType;\n  let frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._vertexFormat = vertexFormat;\n  this._workerName = \"createFrustumGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    2 +\n    frustumPackedLength +\n    Cartesian3.packedLength +\n    Quaternion.packedLength +\n    VertexFormat.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nFrustumGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = value._frustumType;\n  const frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += VertexFormat.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nconst scratchPackPerspective = new PerspectiveFrustum();\nconst scratchPackOrthographic = new OrthographicFrustum();\nconst scratchPackQuaternion = new Quaternion();\nconst scratchPackorigin = new Cartesian3();\nconst scratchVertexFormat = new VertexFormat();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumGeometry} [result] The object into which to store the result.\n */\nFrustumGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = array[startingIndex++];\n\n  let frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  const orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion\n  );\n  startingIndex += Quaternion.packedLength;\n  const vertexFormat = VertexFormat.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += VertexFormat.packedLength;\n  const drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      vertexFormat: vertexFormat,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  const frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\nfunction getAttributes(\n  offset,\n  normals,\n  tangents,\n  bitangents,\n  st,\n  normal,\n  tangent,\n  bitangent\n) {\n  const stOffset = (offset / 3) * 2;\n\n  for (let i = 0; i < 4; ++i) {\n    if (defined(normals)) {\n      normals[offset] = normal.x;\n      normals[offset + 1] = normal.y;\n      normals[offset + 2] = normal.z;\n    }\n    if (defined(tangents)) {\n      tangents[offset] = tangent.x;\n      tangents[offset + 1] = tangent.y;\n      tangents[offset + 2] = tangent.z;\n    }\n    if (defined(bitangents)) {\n      bitangents[offset] = bitangent.x;\n      bitangents[offset + 1] = bitangent.y;\n      bitangents[offset + 2] = bitangent.z;\n    }\n    offset += 3;\n  }\n\n  st[stOffset] = 0.0;\n  st[stOffset + 1] = 0.0;\n  st[stOffset + 2] = 1.0;\n  st[stOffset + 3] = 0.0;\n  st[stOffset + 4] = 1.0;\n  st[stOffset + 5] = 1.0;\n  st[stOffset + 6] = 0.0;\n  st[stOffset + 7] = 1.0;\n}\n\nconst scratchRotationMatrix = new Matrix3();\nconst scratchViewMatrix = new Matrix4();\nconst scratchInverseMatrix = new Matrix4();\n\nconst scratchXDirection = new Cartesian3();\nconst scratchYDirection = new Cartesian3();\nconst scratchZDirection = new Cartesian3();\nconst scratchNegativeX = new Cartesian3();\nconst scratchNegativeY = new Cartesian3();\nconst scratchNegativeZ = new Cartesian3();\n\nconst frustumSplits = new Array(3);\n\nconst frustumCornersNDC = new Array(4);\nfrustumCornersNDC[0] = new Cartesian4(-1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[1] = new Cartesian4(1.0, -1.0, 1.0, 1.0);\nfrustumCornersNDC[2] = new Cartesian4(1.0, 1.0, 1.0, 1.0);\nfrustumCornersNDC[3] = new Cartesian4(-1.0, 1.0, 1.0, 1.0);\n\nconst scratchFrustumCorners = new Array(4);\nfor (let i = 0; i < 4; ++i) {\n  scratchFrustumCorners[i] = new Cartesian4();\n}\n\nFrustumGeometry._computeNearFarPlanes = function (\n  origin,\n  orientation,\n  frustumType,\n  frustum,\n  positions,\n  xDirection,\n  yDirection,\n  zDirection\n) {\n  const rotationMatrix = Matrix3.fromQuaternion(\n    orientation,\n    scratchRotationMatrix\n  );\n  let x = defaultValue(xDirection, scratchXDirection);\n  let y = defaultValue(yDirection, scratchYDirection);\n  let z = defaultValue(zDirection, scratchZDirection);\n\n  x = Matrix3.getColumn(rotationMatrix, 0, x);\n  y = Matrix3.getColumn(rotationMatrix, 1, y);\n  z = Matrix3.getColumn(rotationMatrix, 2, z);\n\n  Cartesian3.normalize(x, x);\n  Cartesian3.normalize(y, y);\n  Cartesian3.normalize(z, z);\n\n  Cartesian3.negate(x, x);\n\n  const view = Matrix4.computeView(origin, z, y, x, scratchViewMatrix);\n\n  let inverseView;\n  let inverseViewProjection;\n  if (frustumType === PERSPECTIVE) {\n    const projection = frustum.projectionMatrix;\n    const viewProjection = Matrix4.multiply(\n      projection,\n      view,\n      scratchInverseMatrix\n    );\n    inverseViewProjection = Matrix4.inverse(\n      viewProjection,\n      scratchInverseMatrix\n    );\n  } else {\n    inverseView = Matrix4.inverseTransformation(view, scratchInverseMatrix);\n  }\n\n  if (defined(inverseViewProjection)) {\n    frustumSplits[0] = frustum.near;\n    frustumSplits[1] = frustum.far;\n  } else {\n    frustumSplits[0] = 0.0;\n    frustumSplits[1] = frustum.near;\n    frustumSplits[2] = frustum.far;\n  }\n\n  for (let i = 0; i < 2; ++i) {\n    for (let j = 0; j < 4; ++j) {\n      let corner = Cartesian4.clone(\n        frustumCornersNDC[j],\n        scratchFrustumCorners[j]\n      );\n\n      if (!defined(inverseViewProjection)) {\n        if (defined(frustum._offCenterFrustum)) {\n          frustum = frustum._offCenterFrustum;\n        }\n\n        const near = frustumSplits[i];\n        const far = frustumSplits[i + 1];\n\n        corner.x =\n          (corner.x * (frustum.right - frustum.left) +\n            frustum.left +\n            frustum.right) *\n          0.5;\n        corner.y =\n          (corner.y * (frustum.top - frustum.bottom) +\n            frustum.bottom +\n            frustum.top) *\n          0.5;\n        corner.z = (corner.z * (near - far) - near - far) * 0.5;\n        corner.w = 1.0;\n\n        Matrix4.multiplyByVector(inverseView, corner, corner);\n      } else {\n        corner = Matrix4.multiplyByVector(\n          inverseViewProjection,\n          corner,\n          corner\n        );\n\n        // Reverse perspective divide\n        const w = 1.0 / corner.w;\n        Cartesian3.multiplyByScalar(corner, w, corner);\n\n        Cartesian3.subtract(corner, origin, corner);\n        Cartesian3.normalize(corner, corner);\n\n        const fac = Cartesian3.dot(z, corner);\n        Cartesian3.multiplyByScalar(corner, frustumSplits[i] / fac, corner);\n        Cartesian3.add(corner, origin, corner);\n      }\n\n      positions[12 * i + j * 3] = corner.x;\n      positions[12 * i + j * 3 + 1] = corner.y;\n      positions[12 * i + j * 3 + 2] = corner.z;\n    }\n  }\n};\n\n/**\n * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumGeometry.createGeometry = function (frustumGeometry) {\n  const frustumType = frustumGeometry._frustumType;\n  const frustum = frustumGeometry._frustum;\n  const origin = frustumGeometry._origin;\n  const orientation = frustumGeometry._orientation;\n  const drawNearPlane = frustumGeometry._drawNearPlane;\n  const vertexFormat = frustumGeometry._vertexFormat;\n\n  const numberOfPlanes = drawNearPlane ? 6 : 5;\n  let positions = new Float64Array(3 * 4 * 6);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions\n  );\n\n  // -x plane\n  let offset = 3 * 4 * 2;\n  positions[offset] = positions[3 * 4];\n  positions[offset + 1] = positions[3 * 4 + 1];\n  positions[offset + 2] = positions[3 * 4 + 2];\n  positions[offset + 3] = positions[0];\n  positions[offset + 4] = positions[1];\n  positions[offset + 5] = positions[2];\n  positions[offset + 6] = positions[3 * 3];\n  positions[offset + 7] = positions[3 * 3 + 1];\n  positions[offset + 8] = positions[3 * 3 + 2];\n  positions[offset + 9] = positions[3 * 7];\n  positions[offset + 10] = positions[3 * 7 + 1];\n  positions[offset + 11] = positions[3 * 7 + 2];\n\n  // -y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 5];\n  positions[offset + 1] = positions[3 * 5 + 1];\n  positions[offset + 2] = positions[3 * 5 + 2];\n  positions[offset + 3] = positions[3];\n  positions[offset + 4] = positions[3 + 1];\n  positions[offset + 5] = positions[3 + 2];\n  positions[offset + 6] = positions[0];\n  positions[offset + 7] = positions[1];\n  positions[offset + 8] = positions[2];\n  positions[offset + 9] = positions[3 * 4];\n  positions[offset + 10] = positions[3 * 4 + 1];\n  positions[offset + 11] = positions[3 * 4 + 2];\n\n  // +x plane\n  offset += 3 * 4;\n  positions[offset] = positions[3];\n  positions[offset + 1] = positions[3 + 1];\n  positions[offset + 2] = positions[3 + 2];\n  positions[offset + 3] = positions[3 * 5];\n  positions[offset + 4] = positions[3 * 5 + 1];\n  positions[offset + 5] = positions[3 * 5 + 2];\n  positions[offset + 6] = positions[3 * 6];\n  positions[offset + 7] = positions[3 * 6 + 1];\n  positions[offset + 8] = positions[3 * 6 + 2];\n  positions[offset + 9] = positions[3 * 2];\n  positions[offset + 10] = positions[3 * 2 + 1];\n  positions[offset + 11] = positions[3 * 2 + 2];\n\n  // +y plane\n  offset += 3 * 4;\n  positions[offset] = positions[3 * 2];\n  positions[offset + 1] = positions[3 * 2 + 1];\n  positions[offset + 2] = positions[3 * 2 + 2];\n  positions[offset + 3] = positions[3 * 6];\n  positions[offset + 4] = positions[3 * 6 + 1];\n  positions[offset + 5] = positions[3 * 6 + 2];\n  positions[offset + 6] = positions[3 * 7];\n  positions[offset + 7] = positions[3 * 7 + 1];\n  positions[offset + 8] = positions[3 * 7 + 2];\n  positions[offset + 9] = positions[3 * 3];\n  positions[offset + 10] = positions[3 * 3 + 1];\n  positions[offset + 11] = positions[3 * 3 + 2];\n\n  if (!drawNearPlane) {\n    positions = positions.subarray(3 * 4);\n  }\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if (\n    defined(vertexFormat.normal) ||\n    defined(vertexFormat.tangent) ||\n    defined(vertexFormat.bitangent) ||\n    defined(vertexFormat.st)\n  ) {\n    const normals = defined(vertexFormat.normal)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    const tangents = defined(vertexFormat.tangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    const bitangents = defined(vertexFormat.bitangent)\n      ? new Float32Array(3 * 4 * numberOfPlanes)\n      : undefined;\n    const st = defined(vertexFormat.st)\n      ? new Float32Array(2 * 4 * numberOfPlanes)\n      : undefined;\n\n    const x = scratchXDirection;\n    const y = scratchYDirection;\n    const z = scratchZDirection;\n\n    const negativeX = Cartesian3.negate(x, scratchNegativeX);\n    const negativeY = Cartesian3.negate(y, scratchNegativeY);\n    const negativeZ = Cartesian3.negate(z, scratchNegativeZ);\n\n    offset = 0;\n    if (drawNearPlane) {\n      getAttributes(offset, normals, tangents, bitangents, st, negativeZ, x, y); // near\n      offset += 3 * 4;\n    }\n    getAttributes(offset, normals, tangents, bitangents, st, z, negativeX, y); // far\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeX,\n      negativeZ,\n      y\n    ); // -x\n    offset += 3 * 4;\n    getAttributes(\n      offset,\n      normals,\n      tangents,\n      bitangents,\n      st,\n      negativeY,\n      negativeZ,\n      negativeX\n    ); // -y\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, x, z, y); // +x\n    offset += 3 * 4;\n    getAttributes(offset, normals, tangents, bitangents, st, y, z, negativeX); // +y\n\n    if (defined(normals)) {\n      attributes.normal = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n    if (defined(tangents)) {\n      attributes.tangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n    if (defined(bitangents)) {\n      attributes.bitangent = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n    if (defined(st)) {\n      attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n  }\n\n  const indices = new Uint16Array(6 * numberOfPlanes);\n  for (let i = 0; i < numberOfPlanes; ++i) {\n    const indexOffset = i * 6;\n    const index = i * 4;\n\n    indices[indexOffset] = index;\n    indices[indexOffset + 1] = index + 1;\n    indices[indexOffset + 2] = index + 2;\n    indices[indexOffset + 3] = index;\n    indices[indexOffset + 4] = index + 2;\n    indices[indexOffset + 5] = index + 3;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumGeometry;\n","import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport FrustumGeometry from \"./FrustumGeometry.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport OrthographicFrustum from \"./OrthographicFrustum.js\";\nimport PerspectiveFrustum from \"./PerspectiveFrustum.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\n\nconst PERSPECTIVE = 0;\nconst ORTHOGRAPHIC = 1;\n\n/**\n * A description of the outline of a frustum with the given the origin and orientation.\n *\n * @alias FrustumOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.\n * @param {Cartesian3} options.origin The origin of the frustum.\n * @param {Quaternion} options.orientation The orientation of the frustum.\n */\nfunction FrustumOutlineGeometry(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.frustum\", options.frustum);\n  Check.typeOf.object(\"options.origin\", options.origin);\n  Check.typeOf.object(\"options.orientation\", options.orientation);\n  //>>includeEnd('debug');\n\n  const frustum = options.frustum;\n  const orientation = options.orientation;\n  const origin = options.origin;\n\n  // This is private because it is used by DebugCameraPrimitive to draw a multi-frustum by\n  // creating multiple FrustumOutlineGeometrys. This way the near plane of one frustum doesn't overlap\n  // the far plane of another.\n  const drawNearPlane = defaultValue(options._drawNearPlane, true);\n\n  let frustumType;\n  let frustumPackedLength;\n  if (frustum instanceof PerspectiveFrustum) {\n    frustumType = PERSPECTIVE;\n    frustumPackedLength = PerspectiveFrustum.packedLength;\n  } else if (frustum instanceof OrthographicFrustum) {\n    frustumType = ORTHOGRAPHIC;\n    frustumPackedLength = OrthographicFrustum.packedLength;\n  }\n\n  this._frustumType = frustumType;\n  this._frustum = frustum.clone();\n  this._origin = Cartesian3.clone(origin);\n  this._orientation = Quaternion.clone(orientation);\n  this._drawNearPlane = drawNearPlane;\n  this._workerName = \"createFrustumOutlineGeometry\";\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength =\n    2 + frustumPackedLength + Cartesian3.packedLength + Quaternion.packedLength;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {FrustumOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nFrustumOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = value._frustumType;\n  const frustum = value._frustum;\n\n  array[startingIndex++] = frustumType;\n\n  if (frustumType === PERSPECTIVE) {\n    PerspectiveFrustum.pack(frustum, array, startingIndex);\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    OrthographicFrustum.pack(frustum, array, startingIndex);\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  Cartesian3.pack(value._origin, array, startingIndex);\n  startingIndex += Cartesian3.packedLength;\n  Quaternion.pack(value._orientation, array, startingIndex);\n  startingIndex += Quaternion.packedLength;\n  array[startingIndex] = value._drawNearPlane ? 1.0 : 0.0;\n\n  return array;\n};\n\nconst scratchPackPerspective = new PerspectiveFrustum();\nconst scratchPackOrthographic = new OrthographicFrustum();\nconst scratchPackQuaternion = new Quaternion();\nconst scratchPackorigin = new Cartesian3();\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {FrustumOutlineGeometry} [result] The object into which to store the result.\n */\nFrustumOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  const frustumType = array[startingIndex++];\n\n  let frustum;\n  if (frustumType === PERSPECTIVE) {\n    frustum = PerspectiveFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackPerspective\n    );\n    startingIndex += PerspectiveFrustum.packedLength;\n  } else {\n    frustum = OrthographicFrustum.unpack(\n      array,\n      startingIndex,\n      scratchPackOrthographic\n    );\n    startingIndex += OrthographicFrustum.packedLength;\n  }\n\n  const origin = Cartesian3.unpack(array, startingIndex, scratchPackorigin);\n  startingIndex += Cartesian3.packedLength;\n  const orientation = Quaternion.unpack(\n    array,\n    startingIndex,\n    scratchPackQuaternion\n  );\n  startingIndex += Quaternion.packedLength;\n  const drawNearPlane = array[startingIndex] === 1.0;\n\n  if (!defined(result)) {\n    return new FrustumOutlineGeometry({\n      frustum: frustum,\n      origin: origin,\n      orientation: orientation,\n      _drawNearPlane: drawNearPlane,\n    });\n  }\n\n  const frustumResult =\n    frustumType === result._frustumType ? result._frustum : undefined;\n  result._frustum = frustum.clone(frustumResult);\n\n  result._frustumType = frustumType;\n  result._origin = Cartesian3.clone(origin, result._origin);\n  result._orientation = Quaternion.clone(orientation, result._orientation);\n  result._drawNearPlane = drawNearPlane;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.\n *\n * @param {FrustumOutlineGeometry} frustumGeometry A description of the frustum.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nFrustumOutlineGeometry.createGeometry = function (frustumGeometry) {\n  const frustumType = frustumGeometry._frustumType;\n  const frustum = frustumGeometry._frustum;\n  const origin = frustumGeometry._origin;\n  const orientation = frustumGeometry._orientation;\n  const drawNearPlane = frustumGeometry._drawNearPlane;\n\n  const positions = new Float64Array(3 * 4 * 2);\n  FrustumGeometry._computeNearFarPlanes(\n    origin,\n    orientation,\n    frustumType,\n    frustum,\n    positions\n  );\n\n  const attributes = new GeometryAttributes({\n    position: new GeometryAttribute({\n      componentDatatype: ComponentDatatype.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  let offset;\n  let index;\n\n  const numberOfPlanes = drawNearPlane ? 2 : 1;\n  const indices = new Uint16Array(8 * (numberOfPlanes + 1));\n\n  // Build the near/far planes\n  let i = drawNearPlane ? 0 : 1;\n  for (; i < 2; ++i) {\n    offset = drawNearPlane ? i * 8 : 0;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 1;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 2;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 3;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index;\n  }\n\n  // Build the sides of the frustums\n  for (i = 0; i < 2; ++i) {\n    offset = (numberOfPlanes + i) * 8;\n    index = i * 4;\n\n    indices[offset] = index;\n    indices[offset + 1] = index + 4;\n    indices[offset + 2] = index + 1;\n    indices[offset + 3] = index + 5;\n    indices[offset + 4] = index + 2;\n    indices[offset + 5] = index + 6;\n    indices[offset + 6] = index + 3;\n    indices[offset + 7] = index + 7;\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: BoundingSphere.fromVertices(positions),\n  });\n};\nexport default FrustumOutlineGeometry;\n","import defined from \"./defined.js\";\n\nlet _supportsFullscreen;\nconst _names = {\n  requestFullscreen: undefined,\n  exitFullscreen: undefined,\n  fullscreenEnabled: undefined,\n  fullscreenElement: undefined,\n  fullscreenchange: undefined,\n  fullscreenerror: undefined,\n};\n\n/**\n * Browser-independent functions for working with the standard fullscreen API.\n *\n * @namespace Fullscreen\n *\n * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}\n */\nconst Fullscreen = {};\n\nObject.defineProperties(Fullscreen, {\n  /**\n   * The element that is currently fullscreen, if any.  To simply check if the\n   * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.\n   * @memberof Fullscreen\n   * @type {Object}\n   * @readonly\n   */\n  element: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return document[_names.fullscreenElement];\n    },\n  },\n\n  /**\n   * The name of the event on the document that is fired when fullscreen is\n   * entered or exited.  This event name is intended for use with addEventListener.\n   * In your event handler, to determine if the browser is in fullscreen mode or not,\n   * use {@link Fullscreen#fullscreen}.\n   * @memberof Fullscreen\n   * @type {String}\n   * @readonly\n   */\n  changeEventName: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return _names.fullscreenchange;\n    },\n  },\n\n  /**\n   * The name of the event that is fired when a fullscreen error\n   * occurs.  This event name is intended for use with addEventListener.\n   * @memberof Fullscreen\n   * @type {String}\n   * @readonly\n   */\n  errorEventName: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return _names.fullscreenerror;\n    },\n  },\n\n  /**\n   * Determine whether the browser will allow an element to be made fullscreen, or not.\n   * For example, by default, iframes cannot go fullscreen unless the containing page\n   * adds an \"allowfullscreen\" attribute (or prefixed equivalent).\n   * @memberof Fullscreen\n   * @type {Boolean}\n   * @readonly\n   */\n  enabled: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return document[_names.fullscreenEnabled];\n    },\n  },\n\n  /**\n   * Determines if the browser is currently in fullscreen mode.\n   * @memberof Fullscreen\n   * @type {Boolean}\n   * @readonly\n   */\n  fullscreen: {\n    get: function () {\n      if (!Fullscreen.supportsFullscreen()) {\n        return undefined;\n      }\n\n      return Fullscreen.element !== null;\n    },\n  },\n});\n\n/**\n * Detects whether the browser supports the standard fullscreen API.\n *\n * @returns {Boolean} <code>true</code> if the browser supports the standard fullscreen API,\n * <code>false</code> otherwise.\n */\nFullscreen.supportsFullscreen = function () {\n  if (defined(_supportsFullscreen)) {\n    return _supportsFullscreen;\n  }\n\n  _supportsFullscreen = false;\n\n  const body = document.body;\n  if (typeof body.requestFullscreen === \"function\") {\n    // go with the unprefixed, standard set of names\n    _names.requestFullscreen = \"requestFullscreen\";\n    _names.exitFullscreen = \"exitFullscreen\";\n    _names.fullscreenEnabled = \"fullscreenEnabled\";\n    _names.fullscreenElement = \"fullscreenElement\";\n    _names.fullscreenchange = \"fullscreenchange\";\n    _names.fullscreenerror = \"fullscreenerror\";\n    _supportsFullscreen = true;\n    return _supportsFullscreen;\n  }\n\n  //check for the correct combination of prefix plus the various names that browsers use\n  const prefixes = [\"webkit\", \"moz\", \"o\", \"ms\", \"khtml\"];\n  let name;\n  for (let i = 0, len = prefixes.length; i < len; ++i) {\n    const prefix = prefixes[i];\n\n    // casing of Fullscreen differs across browsers\n    name = `${prefix}RequestFullscreen`;\n    if (typeof body[name] === \"function\") {\n      _names.requestFullscreen = name;\n      _supportsFullscreen = true;\n    } else {\n      name = `${prefix}RequestFullScreen`;\n      if (typeof body[name] === \"function\") {\n        _names.requestFullscreen = name;\n        _supportsFullscreen = true;\n      }\n    }\n\n    // disagreement about whether it's \"exit\" as per spec, or \"cancel\"\n    name = `${prefix}ExitFullscreen`;\n    if (typeof document[name] === \"function\") {\n      _names.exitFullscreen = name;\n    } else {\n      name = `${prefix}CancelFullScreen`;\n      if (typeof document[name] === \"function\") {\n        _names.exitFullscreen = name;\n      }\n    }\n\n    // casing of Fullscreen differs across browsers\n    name = `${prefix}FullscreenEnabled`;\n    if (document[name] !== undefined) {\n      _names.fullscreenEnabled = name;\n    } else {\n      name = `${prefix}FullScreenEnabled`;\n      if (document[name] !== undefined) {\n        _names.fullscreenEnabled = name;\n      }\n    }\n\n    // casing of Fullscreen differs across browsers\n    name = `${prefix}FullscreenElement`;\n    if (document[name] !== undefined) {\n      _names.fullscreenElement = name;\n    } else {\n      name = `${prefix}FullScreenElement`;\n      if (document[name] !== undefined) {\n        _names.fullscreenElement = name;\n      }\n    }\n\n    // thankfully, event names are all lowercase per spec\n    name = `${prefix}fullscreenchange`;\n    // event names do not have 'on' in the front, but the property on the document does\n    if (document[`on${name}`] !== undefined) {\n      //except on IE\n      if (prefix === \"ms\") {\n        name = \"MSFullscreenChange\";\n      }\n      _names.fullscreenchange = name;\n    }\n\n    name = `${prefix}fullscreenerror`;\n    if (document[`on${name}`] !== undefined) {\n      //except on IE\n      if (prefix === \"ms\") {\n        name = \"MSFullscreenError\";\n      }\n      _names.fullscreenerror = name;\n    }\n  }\n\n  return _supportsFullscreen;\n};\n\n/**\n * Asynchronously requests the browser to enter fullscreen mode on the given element.\n * If fullscreen mode is not supported by the browser, does nothing.\n *\n * @param {Object} element The HTML element which will be placed into fullscreen mode.\n * @param {Object} [vrDevice] The HMDVRDevice device.\n *\n * @example\n * // Put the entire page into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(document.body)\n *\n * // Place only the Cesium canvas into fullscreen.\n * Cesium.Fullscreen.requestFullscreen(scene.canvas)\n */\nFullscreen.requestFullscreen = function (element, vrDevice) {\n  if (!Fullscreen.supportsFullscreen()) {\n    return;\n  }\n\n  element[_names.requestFullscreen]({ vrDisplay: vrDevice });\n};\n\n/**\n * Asynchronously exits fullscreen mode.  If the browser is not currently\n * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.\n */\nFullscreen.exitFullscreen = function () {\n  if (!Fullscreen.supportsFullscreen()) {\n    return;\n  }\n\n  document[_names.exitFullscreen]();\n};\n\n//For unit tests\nFullscreen._names = _names;\nexport default Fullscreen;\n","/**\n * The type of geocoding to be performed by a {@link GeocoderService}.\n * @enum {Number}\n * @see Geocoder\n */\nconst GeocodeType = {\n  /**\n   * Perform a search where the input is considered complete.\n   *\n   * @type {Number}\n   * @constant\n   */\n  SEARCH: 0,\n\n  /**\n   * Perform an auto-complete using partial input, typically\n   * reserved for providing possible results as a user is typing.\n   *\n   * @type {Number}\n   * @constant\n   */\n  AUTOCOMPLETE: 1,\n};\nexport default Object.freeze(GeocodeType);\n","import DeveloperError from \"./DeveloperError.js\";\n\n/**\n * @typedef {Object} GeocoderService.Result\n * @property {String} displayName The display name for a location\n * @property {Rectangle|Cartesian3} destination The bounding box for a location\n */\n\n/**\n * Provides geocoding through an external service. This type describes an interface and\n * is not intended to be used.\n * @alias GeocoderService\n * @constructor\n *\n * @see BingMapsGeocoderService\n * @see PeliasGeocoderService\n * @see OpenCageGeocoderService\n */\nfunction GeocoderService() {}\n\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.\n * @returns {Promise<GeocoderService.Result[]>}\n */\nGeocoderService.prototype.geocode = DeveloperError.throwInstantiationError;\nexport default GeocoderService;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\n\n/**\n * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying\n * them by the {@link Ellipsoid#maximumRadius}.  This projection\n * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It\n * is also known as EPSG:4326.\n *\n * @alias GeographicProjection\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n *\n * @see WebMercatorProjection\n */\nfunction GeographicProjection(ellipsoid) {\n  this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  this._semimajorAxis = this._ellipsoid.maximumRadius;\n  this._oneOverSemimajorAxis = 1.0 / this._semimajorAxis;\n}\n\nObject.defineProperties(GeographicProjection.prototype, {\n  /**\n   * Gets the {@link Ellipsoid}.\n   *\n   * @memberof GeographicProjection.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.\n * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the\n * ellipsoid.  Z is the unmodified height.\n *\n * @param {Cartographic} cartographic The coordinates to project.\n * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is\n *        undefined, a new instance is created and returned.\n * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the\n *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n *          created and returned.\n */\nGeographicProjection.prototype.project = function (cartographic, result) {\n  // Actually this is the special case of equidistant cylindrical called the plate carree\n  const semimajorAxis = this._semimajorAxis;\n  const x = cartographic.longitude * semimajorAxis;\n  const y = cartographic.latitude * semimajorAxis;\n  const z = cartographic.height;\n\n  if (!defined(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}\n * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,\n * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.\n *\n * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.\n * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is\n *        undefined, a new instance is created and returned.\n * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the\n *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is\n *          created and returned.\n */\nGeographicProjection.prototype.unproject = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required\");\n  }\n  //>>includeEnd('debug');\n\n  const oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;\n  const longitude = cartesian.x * oneOverEarthSemimajorAxis;\n  const latitude = cartesian.y * oneOverEarthSemimajorAxis;\n  const height = cartesian.z;\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\nexport default GeographicProjection;\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\n * longitude and latitude are directly mapped to X and Y.  This projection is commonly\n * known as geographic, equirectangular, equidistant cylindrical, or plate carrée.\n *\n * @alias GeographicTilingScheme\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\n * the WGS84 ellipsoid.\n * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\n * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\n * the tile tree.\n * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\n * the tile tree.\n */\nfunction GeographicTilingScheme(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\n  this._projection = new GeographicProjection(this._ellipsoid);\n  this._numberOfLevelZeroTilesX = defaultValue(\n    options.numberOfLevelZeroTilesX,\n    2\n  );\n  this._numberOfLevelZeroTilesY = defaultValue(\n    options.numberOfLevelZeroTilesY,\n    1\n  );\n}\n\nObject.defineProperties(GeographicTilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n\n  /**\n   * Gets the map projection used by this tiling scheme.\n   * @memberof GeographicTilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n});\n\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the X direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesX << level;\n};\n\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the Y direction at the given level.\n */\nGeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {\n  return this._numberOfLevelZeroTilesY << level;\n};\n\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\n *          is undefined.\n */\nGeographicTilingScheme.prototype.rectangleToNativeRectangle = function (\n  rectangle,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n\n  const west = CesiumMath.toDegrees(rectangle.west);\n  const south = CesiumMath.toDegrees(rectangle.south);\n  const east = CesiumMath.toDegrees(rectangle.east);\n  const north = CesiumMath.toDegrees(rectangle.north);\n\n  if (!defined(result)) {\n    return new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToNativeRectangle = function (\n  x,\n  y,\n  level,\n  result\n) {\n  const rectangleRadians = this.tileXYToRectangle(x, y, level, result);\n  rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\n  rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\n  rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\n  rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\n  return rectangleRadians;\n};\n\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.tileXYToRectangle = function (\n  x,\n  y,\n  level,\n  result\n) {\n  const rectangle = this._rectangle;\n\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const xTileWidth = rectangle.width / xTiles;\n  const west = x * xTileWidth + rectangle.west;\n  const east = (x + 1) * xTileWidth + rectangle.west;\n\n  const yTileHeight = rectangle.height / yTiles;\n  const north = rectangle.north - y * yTileHeight;\n  const south = rectangle.north - (y + 1) * yTileHeight;\n\n  if (!defined(result)) {\n    result = new Rectangle(west, south, east, north);\n  }\n\n  result.west = west;\n  result.south = south;\n  result.east = east;\n  result.north = north;\n  return result;\n};\n\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n *\n * @param {Cartographic} position The position.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\n *          if 'result' is undefined.\n */\nGeographicTilingScheme.prototype.positionToTileXY = function (\n  position,\n  level,\n  result\n) {\n  const rectangle = this._rectangle;\n  if (!Rectangle.contains(rectangle, position)) {\n    // outside the bounds of the tiling scheme\n    return undefined;\n  }\n\n  const xTiles = this.getNumberOfXTilesAtLevel(level);\n  const yTiles = this.getNumberOfYTilesAtLevel(level);\n\n  const xTileWidth = rectangle.width / xTiles;\n  const yTileHeight = rectangle.height / yTiles;\n\n  let longitude = position.longitude;\n  if (rectangle.east < rectangle.west) {\n    longitude += CesiumMath.TWO_PI;\n  }\n\n  let xTileCoordinate = ((longitude - rectangle.west) / xTileWidth) | 0;\n  if (xTileCoordinate >= xTiles) {\n    xTileCoordinate = xTiles - 1;\n  }\n\n  let yTileCoordinate =\n    ((rectangle.north - position.latitude) / yTileHeight) | 0;\n  if (yTileCoordinate >= yTiles) {\n    yTileCoordinate = yTiles - 1;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian2(xTileCoordinate, yTileCoordinate);\n  }\n\n  result.x = xTileCoordinate;\n  result.y = yTileCoordinate;\n  return result;\n};\nexport default GeographicTilingScheme;\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Transforms from \"./Transforms.js\";\n\n/**\n * A geometry representation with attributes forming vertices and optional index data\n * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,\n * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can\n * be created from many heterogeneous - in many cases - geometries for performance.\n * <p>\n * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.\n * </p>\n *\n * @alias Geometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.\n * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.\n * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.\n * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.\n *\n * @see PolygonGeometry\n * @see RectangleGeometry\n * @see EllipseGeometry\n * @see CircleGeometry\n * @see WallGeometry\n * @see SimplePolylineGeometry\n * @see BoxGeometry\n * @see EllipsoidGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n *\n * @example\n * // Create geometry with a position attribute and indexed lines.\n * const positions = new Float64Array([\n *   0.0, 0.0, 0.0,\n *   7500000.0, 0.0, 0.0,\n *   0.0, 7500000.0, 0.0\n * ]);\n *\n * const geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\n *       componentsPerAttribute : 3,\n *       values : positions\n *     })\n *   },\n *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\n *   primitiveType : Cesium.PrimitiveType.LINES,\n *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\n * });\n */\nfunction Geometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.attributes\", options.attributes);\n  //>>includeEnd('debug');\n\n  /**\n   * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a\n   * {@link GeometryAttribute} containing the attribute's data.\n   * <p>\n   * Attributes are always stored non-interleaved in a Geometry.\n   * </p>\n   * <p>\n   * There are reserved attribute names with well-known semantics.  The following attributes\n   * are created by a Geometry (depending on the provided {@link VertexFormat}.\n   * <ul>\n   *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>\n   *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>\n   *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>\n   *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>\n   *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>\n   * </ul>\n   * </p>\n   * <p>\n   * The following attribute names are generally not created by a Geometry, but are added\n   * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare\n   * the geometry for rendering.\n   * <ul>\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>\n   * </ul>\n   * </p>\n   *\n   * @type GeometryAttributes\n   *\n   * @default undefined\n   *\n   *\n   * @example\n   * geometry.attributes.position = new Cesium.GeometryAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\n   *   componentsPerAttribute : 3,\n   *   values : new Float32Array(0)\n   * });\n   *\n   * @see GeometryAttribute\n   * @see VertexFormat\n   */\n  this.attributes = options.attributes;\n\n  /**\n   * Optional index data that - along with {@link Geometry#primitiveType} -\n   * determines the primitives in the geometry.\n   *\n   * @type Array\n   *\n   * @default undefined\n   */\n  this.indices = options.indices;\n\n  /**\n   * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},\n   * but can varying based on the specific geometry.\n   *\n   * @type PrimitiveType\n   *\n   * @default undefined\n   */\n  this.primitiveType = defaultValue(\n    options.primitiveType,\n    PrimitiveType.TRIANGLES\n  );\n\n  /**\n   * An optional bounding sphere that fully encloses the geometry.  This is\n   * commonly used for culling.\n   *\n   * @type BoundingSphere\n   *\n   * @default undefined\n   */\n  this.boundingSphere = options.boundingSphere;\n\n  /**\n   * @private\n   */\n  this.geometryType = defaultValue(options.geometryType, GeometryType.NONE);\n\n  /**\n   * @private\n   */\n  this.boundingSphereCV = options.boundingSphereCV;\n\n  /**\n   * Used for computing the bounding sphere for geometry using the applyOffset vertex attribute\n   * @private\n   */\n  this.offsetAttribute = options.offsetAttribute;\n}\n\n/**\n * Computes the number of vertices in a geometry.  The runtime is linear with\n * respect to the number of attributes in a vertex, not the number of vertices.\n *\n * @param {Geometry} geometry The geometry.\n * @returns {Number} The number of vertices in the geometry.\n *\n * @example\n * const numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);\n */\nGeometry.computeNumberOfVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"geometry\", geometry);\n  //>>includeEnd('debug');\n\n  let numberOfVertices = -1;\n  for (const property in geometry.attributes) {\n    if (\n      geometry.attributes.hasOwnProperty(property) &&\n      defined(geometry.attributes[property]) &&\n      defined(geometry.attributes[property].values)\n    ) {\n      const attribute = geometry.attributes[property];\n      const num = attribute.values.length / attribute.componentsPerAttribute;\n      //>>includeStart('debug', pragmas.debug);\n      if (numberOfVertices !== num && numberOfVertices !== -1) {\n        throw new DeveloperError(\n          \"All attribute lists must have the same number of attributes.\"\n        );\n      }\n      //>>includeEnd('debug');\n      numberOfVertices = num;\n    }\n  }\n\n  return numberOfVertices;\n};\n\nconst rectangleCenterScratch = new Cartographic();\nconst enuCenterScratch = new Cartesian3();\nconst fixedFrameToEnuScratch = new Matrix4();\nconst boundingRectanglePointsCartographicScratch = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nconst boundingRectanglePointsEnuScratch = [\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n];\nconst points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nconst pointEnuScratch = new Cartesian3();\nconst enuRotationScratch = new Quaternion();\nconst enuRotationMatrixScratch = new Matrix4();\nconst rotation2DScratch = new Matrix2();\n\n/**\n * For remapping texture coordinates when rendering GroundPrimitives with materials.\n * GroundPrimitive texture coordinates are computed to align with the cartographic coordinate system on the globe.\n * However, EllipseGeometry, RectangleGeometry, and PolygonGeometry all bake rotations to per-vertex texture coordinates\n * using different strategies.\n *\n * This method is used by EllipseGeometry and PolygonGeometry to approximate the same visual effect.\n * We encapsulate rotation and scale by computing a \"transformed\" texture coordinate system and computing\n * a set of reference points from which \"cartographic\" texture coordinates can be remapped to the \"transformed\"\n * system using distances to lines in 2D.\n *\n * This approximation becomes less accurate as the covered area increases, especially for GroundPrimitives near the poles,\n * but is generally reasonable for polygons and ellipses around the size of USA states.\n *\n * RectangleGeometry has its own version of this method that computes remapping coordinates using cartographic space\n * as an intermediary instead of local ENU, which is more accurate for large-area rectangles.\n *\n * @param {Cartesian3[]} positions Array of positions outlining the geometry\n * @param {Number} stRotation Texture coordinate rotation.\n * @param {Ellipsoid} ellipsoid Ellipsoid for projecting and generating local vectors.\n * @param {Rectangle} boundingRectangle Bounding rectangle around the positions.\n * @returns {Number[]} An array of 6 numbers specifying [minimum point, u extent, v extent] as points in the \"cartographic\" system.\n * @private\n */\nGeometry._textureCoordinateRotationPoints = function (\n  positions,\n  stRotation,\n  ellipsoid,\n  boundingRectangle\n) {\n  let i;\n\n  // Create a local east-north-up coordinate system centered on the polygon's bounding rectangle.\n  // Project the southwest, northwest, and southeast corners of the bounding rectangle into the plane of ENU as 2D points.\n  // These are the equivalents of (0,0), (0,1), and (1,0) in the texture coordiante system computed in ShadowVolumeAppearanceFS,\n  // aka \"ENU texture space.\"\n  const rectangleCenter = Rectangle.center(\n    boundingRectangle,\n    rectangleCenterScratch\n  );\n  const enuCenter = Cartographic.toCartesian(\n    rectangleCenter,\n    ellipsoid,\n    enuCenterScratch\n  );\n  const enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(\n    enuCenter,\n    ellipsoid,\n    fixedFrameToEnuScratch\n  );\n  const fixedFrameToEnu = Matrix4.inverse(\n    enuToFixedFrame,\n    fixedFrameToEnuScratch\n  );\n\n  const boundingPointsEnu = boundingRectanglePointsEnuScratch;\n  const boundingPointsCarto = boundingRectanglePointsCartographicScratch;\n\n  boundingPointsCarto[0].longitude = boundingRectangle.west;\n  boundingPointsCarto[0].latitude = boundingRectangle.south;\n\n  boundingPointsCarto[1].longitude = boundingRectangle.west;\n  boundingPointsCarto[1].latitude = boundingRectangle.north;\n\n  boundingPointsCarto[2].longitude = boundingRectangle.east;\n  boundingPointsCarto[2].latitude = boundingRectangle.south;\n\n  let posEnu = pointEnuScratch;\n\n  for (i = 0; i < 3; i++) {\n    Cartographic.toCartesian(boundingPointsCarto[i], ellipsoid, posEnu);\n    posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, posEnu, posEnu);\n    boundingPointsEnu[i].x = posEnu.x;\n    boundingPointsEnu[i].y = posEnu.y;\n  }\n\n  // Rotate each point in the polygon around the up vector in the ENU by -stRotation and project into ENU as 2D.\n  // Compute the bounding box of these rotated points in the 2D ENU plane.\n  // Rotate the corners back by stRotation, then compute their equivalents in the ENU texture space using the corners computed earlier.\n  const rotation = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -stRotation,\n    enuRotationScratch\n  );\n  const textureMatrix = Matrix3.fromQuaternion(\n    rotation,\n    enuRotationMatrixScratch\n  );\n\n  const positionsLength = positions.length;\n  let enuMinX = Number.POSITIVE_INFINITY;\n  let enuMinY = Number.POSITIVE_INFINITY;\n  let enuMaxX = Number.NEGATIVE_INFINITY;\n  let enuMaxY = Number.NEGATIVE_INFINITY;\n  for (i = 0; i < positionsLength; i++) {\n    posEnu = Matrix4.multiplyByPointAsVector(\n      fixedFrameToEnu,\n      positions[i],\n      posEnu\n    );\n    posEnu = Matrix3.multiplyByVector(textureMatrix, posEnu, posEnu);\n\n    enuMinX = Math.min(enuMinX, posEnu.x);\n    enuMinY = Math.min(enuMinY, posEnu.y);\n    enuMaxX = Math.max(enuMaxX, posEnu.x);\n    enuMaxY = Math.max(enuMaxY, posEnu.y);\n  }\n\n  const toDesiredInComputed = Matrix2.fromRotation(\n    stRotation,\n    rotation2DScratch\n  );\n\n  const points2D = points2DScratch;\n  points2D[0].x = enuMinX;\n  points2D[0].y = enuMinY;\n\n  points2D[1].x = enuMinX;\n  points2D[1].y = enuMaxY;\n\n  points2D[2].x = enuMaxX;\n  points2D[2].y = enuMinY;\n\n  const boundingEnuMin = boundingPointsEnu[0];\n  const boundingPointsWidth = boundingPointsEnu[2].x - boundingEnuMin.x;\n  const boundingPointsHeight = boundingPointsEnu[1].y - boundingEnuMin.y;\n\n  for (i = 0; i < 3; i++) {\n    const point2D = points2D[i];\n    // rotate back\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n\n    // Convert point into east-north texture coordinate space\n    point2D.x = (point2D.x - boundingEnuMin.x) / boundingPointsWidth;\n    point2D.y = (point2D.y - boundingEnuMin.y) / boundingPointsHeight;\n  }\n\n  const minXYCorner = points2D[0];\n  const maxYCorner = points2D[1];\n  const maxXCorner = points2D[2];\n  const result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n\n  return result;\n};\nexport default Geometry;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Values and type information for geometry attributes.  A {@link Geometry}\n * generally contains one or more attributes.  All attributes together form\n * the geometry's vertices.\n *\n * @alias GeometryAttribute\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {ComponentDatatype} [options.componentDatatype] The datatype of each component in the attribute, e.g., individual elements in values.\n * @param {Number} [options.componentsPerAttribute] A number between 1 and 4 that defines the number of components in an attributes.\n * @param {Boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n * @param {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} [options.values] The values for the attributes stored in a typed array.\n *\n * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.\n *\n *\n * @example\n * const geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.FLOAT,\n *       componentsPerAttribute : 3,\n *       values : new Float32Array([\n *         0.0, 0.0, 0.0,\n *         7500000.0, 0.0, 0.0,\n *         0.0, 7500000.0, 0.0\n *       ])\n *     })\n *   },\n *   primitiveType : Cesium.PrimitiveType.LINE_LOOP\n * });\n *\n * @see Geometry\n */\nfunction GeometryAttribute(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.componentDatatype)) {\n    throw new DeveloperError(\"options.componentDatatype is required.\");\n  }\n  if (!defined(options.componentsPerAttribute)) {\n    throw new DeveloperError(\"options.componentsPerAttribute is required.\");\n  }\n  if (\n    options.componentsPerAttribute < 1 ||\n    options.componentsPerAttribute > 4\n  ) {\n    throw new DeveloperError(\n      \"options.componentsPerAttribute must be between 1 and 4.\"\n    );\n  }\n  if (!defined(options.values)) {\n    throw new DeveloperError(\"options.values is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link GeometryAttribute#values}.\n   *\n   * @type ComponentDatatype\n   *\n   * @default undefined\n   */\n  this.componentDatatype = options.componentDatatype;\n\n  /**\n   * A number between 1 and 4 that defines the number of components in an attributes.\n   * For example, a position attribute with x, y, and z components would have 3 as\n   * shown in the code example.\n   *\n   * @type Number\n   *\n   * @default undefined\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);\n   */\n  this.componentsPerAttribute = options.componentsPerAttribute;\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   * <p>\n   * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n   * attribute.componentsPerAttribute = 4;\n   * attribute.normalize = true;\n   * attribute.values = new Uint8Array([\n   *   Cesium.Color.floatToByte(color.red),\n   *   Cesium.Color.floatToByte(color.green),\n   *   Cesium.Color.floatToByte(color.blue),\n   *   Cesium.Color.floatToByte(color.alpha)\n   * ]);\n   */\n  this.normalize = defaultValue(options.normalize, false);\n\n  /**\n   * The values for the attributes stored in a typed array.  In the code example,\n   * every three elements in <code>values</code> defines one attributes since\n   * <code>componentsPerAttribute</code> is 3.\n   *\n   * @type {number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array}\n   *\n   * @default undefined\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;\n   * attribute.componentsPerAttribute = 3;\n   * attribute.values = new Float32Array([\n   *   0.0, 0.0, 0.0,\n   *   7500000.0, 0.0, 0.0,\n   *   0.0, 7500000.0, 0.0\n   * ]);\n   */\n  this.values = options.values;\n}\nexport default GeometryAttribute;\n","import defaultValue from \"./defaultValue.js\";\n\n/**\n * Attributes, which make up a geometry's vertices.  Each property in this object corresponds to a\n * {@link GeometryAttribute} containing the attribute's data.\n * <p>\n * Attributes are always stored non-interleaved in a Geometry.\n * </p>\n *\n * @alias GeometryAttributes\n * @constructor\n */\nfunction GeometryAttributes(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The 3D position attribute.\n   * <p>\n   * 64-bit floating-point (for precision).  3 components per attribute.\n   * </p>\n   *\n   * @type GeometryAttribute\n   *\n   * @default undefined\n   */\n  this.position = options.position;\n\n  /**\n   * The normal attribute (normalized), which is commonly used for lighting.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type GeometryAttribute\n   *\n   * @default undefined\n   */\n  this.normal = options.normal;\n\n  /**\n   * The 2D texture coordinate attribute.\n   * <p>\n   * 32-bit floating-point.  2 components per attribute\n   * </p>\n   *\n   * @type GeometryAttribute\n   *\n   * @default undefined\n   */\n  this.st = options.st;\n\n  /**\n   * The bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type GeometryAttribute\n   *\n   * @default undefined\n   */\n  this.bitangent = options.bitangent;\n\n  /**\n   * The tangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type GeometryAttribute\n   *\n   * @default undefined\n   */\n  this.tangent = options.tangent;\n\n  /**\n   * The color attribute.\n   * <p>\n   * 8-bit unsigned integer. 4 components per attribute.\n   * </p>\n   *\n   * @type GeometryAttribute\n   *\n   * @default undefined\n   */\n  this.color = options.color;\n}\nexport default GeometryAttributes;\n","import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * Base class for all geometry creation utility classes that can be passed to {@link GeometryInstance}\n * for asynchronous geometry creation.\n *\n * @constructor\n * @class\n * @abstract\n */\nfunction GeometryFactory() {\n  DeveloperError.throwInstantiationError();\n}\n\n/**\n * Returns a geometry.\n *\n * @param {GeometryFactory} geometryFactory A description of the circle.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nGeometryFactory.createGeometry = function (geometryFactory) {\n  DeveloperError.throwInstantiationError();\n};\n\nexport default GeometryFactory;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Matrix4 from \"./Matrix4.js\";\n\n/**\n * Geometry instancing allows one {@link Geometry} object to be positions in several\n * different locations and colored uniquely.  For example, one {@link BoxGeometry} can\n * be instanced several times, each with a different <code>modelMatrix</code> to change\n * its position, rotation, and scale.\n *\n * @alias GeometryInstance\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Geometry|GeometryFactory} options.geometry The geometry to instance.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The model matrix that transforms to transform the geometry from model to world coordinates.\n * @param {Object} [options.id] A user-defined object to return when the instance is picked with {@link Scene#pick} or get/set per-instance attributes with {@link Primitive#getGeometryInstanceAttributes}.\n * @param {Object} [options.attributes] Per-instance attributes like a show or color attribute shown in the example below.\n *\n *\n * @example\n * // Create geometry for a box, and two instances that refer to it.\n * // One instance positions the box on the bottom and colored aqua.\n * // The other instance positions the box on the top and color white.\n * const geometry = Cesium.BoxGeometry.fromDimensions({\n *   vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *   dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n * });\n * const instanceBottom = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   },\n *   id : 'bottom'\n * });\n * const instanceTop = new Cesium.GeometryInstance({\n *   geometry : geometry,\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 3000000.0), new Cesium.Matrix4()),\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   },\n *   id : 'top'\n * });\n *\n * @see Geometry\n */\nfunction GeometryInstance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.geometry)) {\n    throw new DeveloperError(\"options.geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The geometry being instanced.\n   *\n   * @type Geometry\n   *\n   * @default undefined\n   */\n  this.geometry = options.geometry;\n\n  /**\n   * The 4x4 transformation matrix that transforms the geometry from model to world coordinates.\n   * When this is the identity matrix, the geometry is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n\n  /**\n   * User-defined object returned when the instance is picked or used to get/set per-instance attributes.\n   *\n   * @type Object\n   *\n   * @default undefined\n   *\n   * @see Scene#pick\n   * @see Primitive#getGeometryInstanceAttributes\n   */\n  this.id = options.id;\n\n  /**\n   * Used for picking primitives that wrap geometry instances.\n   *\n   * @private\n   */\n  this.pickPrimitive = options.pickPrimitive;\n\n  /**\n   * Per-instance attributes like {@link ColorGeometryInstanceAttribute} or {@link ShowGeometryInstanceAttribute}.\n   * {@link Geometry} attributes varying per vertex; these attributes are constant for the entire instance.\n   *\n   * @type Object\n   *\n   * @default undefined\n   */\n  this.attributes = defaultValue(options.attributes, {});\n\n  /**\n   * @private\n   */\n  this.westHemisphereGeometry = undefined;\n  /**\n   * @private\n   */\n  this.eastHemisphereGeometry = undefined;\n}\nexport default GeometryInstance;\n","import defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Values and type information for per-instance geometry attributes.\n *\n * @alias GeometryInstanceAttribute\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {ComponentDatatype} options.componentDatatype The datatype of each component in the attribute, e.g., individual elements in values.\n * @param {Number} options.componentsPerAttribute A number between 1 and 4 that defines the number of components in an attributes.\n * @param {Boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n * @param {Number[]} options.value The value for the attribute.\n *\n * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.\n *\n *\n * @example\n * const instance = new Cesium.GeometryInstance({\n *   geometry : Cesium.BoxGeometry.fromDimensions({\n *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : 'box',\n *   attributes : {\n *     color : new Cesium.GeometryInstanceAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n *       componentsPerAttribute : 4,\n *       normalize : true,\n *       value : [255, 255, 0, 255]\n *     })\n *   }\n * });\n *\n * @see ColorGeometryInstanceAttribute\n * @see ShowGeometryInstanceAttribute\n * @see DistanceDisplayConditionGeometryInstanceAttribute\n */\nfunction GeometryInstanceAttribute(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.componentDatatype)) {\n    throw new DeveloperError(\"options.componentDatatype is required.\");\n  }\n  if (!defined(options.componentsPerAttribute)) {\n    throw new DeveloperError(\"options.componentsPerAttribute is required.\");\n  }\n  if (\n    options.componentsPerAttribute < 1 ||\n    options.componentsPerAttribute > 4\n  ) {\n    throw new DeveloperError(\n      \"options.componentsPerAttribute must be between 1 and 4.\"\n    );\n  }\n  if (!defined(options.value)) {\n    throw new DeveloperError(\"options.value is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link GeometryInstanceAttribute#value}.\n   *\n   * @type ComponentDatatype\n   *\n   * @default undefined\n   */\n  this.componentDatatype = options.componentDatatype;\n\n  /**\n   * A number between 1 and 4 that defines the number of components in an attributes.\n   * For example, a position attribute with x, y, and z components would have 3 as\n   * shown in the code example.\n   *\n   * @type Number\n   *\n   * @default undefined\n   *\n   * @example\n   * show : new Cesium.GeometryInstanceAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n   *   componentsPerAttribute : 1,\n   *   normalize : true,\n   *   value : [1.0]\n   * })\n   */\n  this.componentsPerAttribute = options.componentsPerAttribute;\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   * <p>\n   * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   *\n   * @example\n   * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;\n   * attribute.componentsPerAttribute = 4;\n   * attribute.normalize = true;\n   * attribute.value = [\n   *   Cesium.Color.floatToByte(color.red),\n   *   Cesium.Color.floatToByte(color.green),\n   *   Cesium.Color.floatToByte(color.blue),\n   *   Cesium.Color.floatToByte(color.alpha)\n   * ];\n   */\n  this.normalize = defaultValue(options.normalize, false);\n\n  /**\n   * The values for the attributes stored in a typed array.  In the code example,\n   * every three elements in <code>values</code> defines one attributes since\n   * <code>componentsPerAttribute</code> is 3.\n   *\n   * @type {Number[]}\n   *\n   * @default undefined\n   *\n   * @example\n   * show : new Cesium.GeometryInstanceAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,\n   *   componentsPerAttribute : 1,\n   *   normalize : true,\n   *   value : [1.0]\n   * })\n   */\n  this.value = options.value;\n}\nexport default GeometryInstanceAttribute;\n","/**\n * Represents which vertices should have a value of `true` for the `applyOffset` attribute\n * @private\n */\nconst GeometryOffsetAttribute = {\n  NONE: 0,\n  TOP: 1,\n  ALL: 2,\n};\nexport default Object.freeze(GeometryOffsetAttribute);\n","import AttributeCompression from \"./AttributeCompression.js\";\nimport barycentricCoordinates from \"./barycentricCoordinates.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartesian4 from \"./Cartesian4.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport EncodedCartesian3 from \"./EncodedCartesian3.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersect from \"./Intersect.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Tipsify from \"./Tipsify.js\";\n\n/**\n * Content pipeline functions for geometries.\n *\n * @namespace GeometryPipeline\n *\n * @see Geometry\n */\nconst GeometryPipeline = {};\n\nfunction addTriangle(lines, index, i0, i1, i2) {\n  lines[index++] = i0;\n  lines[index++] = i1;\n\n  lines[index++] = i1;\n  lines[index++] = i2;\n\n  lines[index++] = i2;\n  lines[index] = i0;\n}\n\nfunction trianglesToLines(triangles) {\n  const count = triangles.length;\n  const size = (count / 3) * 6;\n  const lines = IndexDatatype.createTypedArray(count, size);\n\n  let index = 0;\n  for (let i = 0; i < count; i += 3, index += 6) {\n    addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);\n  }\n\n  return lines;\n}\n\nfunction triangleStripToLines(triangles) {\n  const count = triangles.length;\n  if (count >= 3) {\n    const size = (count - 2) * 6;\n    const lines = IndexDatatype.createTypedArray(count, size);\n\n    addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);\n    let index = 6;\n\n    for (let i = 3; i < count; ++i, index += 6) {\n      addTriangle(\n        lines,\n        index,\n        triangles[i - 1],\n        triangles[i],\n        triangles[i - 2]\n      );\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\nfunction triangleFanToLines(triangles) {\n  if (triangles.length > 0) {\n    const count = triangles.length - 1;\n    const size = (count - 1) * 6;\n    const lines = IndexDatatype.createTypedArray(count, size);\n\n    const base = triangles[0];\n    let index = 0;\n    for (let i = 1; i < count; ++i, index += 6) {\n      addTriangle(lines, index, base, triangles[i], triangles[i + 1]);\n    }\n\n    return lines;\n  }\n\n  return new Uint16Array();\n}\n\n/**\n * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>\n * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,\n * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.\n * <p>\n * This is commonly used to create a wireframe geometry for visual debugging.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.\n *\n * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.toWireframe(geometry);\n */\nGeometryPipeline.toWireframe = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    switch (geometry.primitiveType) {\n      case PrimitiveType.TRIANGLES:\n        geometry.indices = trianglesToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_STRIP:\n        geometry.indices = triangleStripToLines(indices);\n        break;\n      case PrimitiveType.TRIANGLE_FAN:\n        geometry.indices = triangleFanToLines(indices);\n        break;\n      //>>includeStart('debug', pragmas.debug);\n      default:\n        throw new DeveloperError(\n          \"geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.\"\n        );\n      //>>includeEnd('debug');\n    }\n\n    geometry.primitiveType = PrimitiveType.LINES;\n  }\n\n  return geometry;\n};\n\n/**\n * Creates a new {@link Geometry} with <code>LINES</code> representing the provided\n * attribute (<code>attributeName</code>) for the provided geometry.  This is used to\n * visualize vector attributes like normals, tangents, and bitangents.\n *\n * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.\n * @param {String} [attributeName='normal'] The name of the attribute.\n * @param {Number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.\n * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.\n *\n * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.\n *\n * @example\n * const geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);\n */\nGeometryPipeline.createLineSegmentsForVectors = function (\n  geometry,\n  attributeName,\n  length\n) {\n  attributeName = defaultValue(attributeName, \"normal\");\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(geometry.attributes.position)) {\n    throw new DeveloperError(\"geometry.attributes.position is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      `geometry.attributes must have an attribute with the same name as the attributeName parameter, ${attributeName}.`\n    );\n  }\n  //>>includeEnd('debug');\n\n  length = defaultValue(length, 10000.0);\n\n  const positions = geometry.attributes.position.values;\n  const vectors = geometry.attributes[attributeName].values;\n  const positionsLength = positions.length;\n\n  const newPositions = new Float64Array(2 * positionsLength);\n\n  let j = 0;\n  for (let i = 0; i < positionsLength; i += 3) {\n    newPositions[j++] = positions[i];\n    newPositions[j++] = positions[i + 1];\n    newPositions[j++] = positions[i + 2];\n\n    newPositions[j++] = positions[i] + vectors[i] * length;\n    newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;\n    newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;\n  }\n\n  let newBoundingSphere;\n  const bs = geometry.boundingSphere;\n  if (defined(bs)) {\n    newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);\n  }\n\n  return new Geometry({\n    attributes: {\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: newPositions,\n      }),\n    },\n    primitiveType: PrimitiveType.LINES,\n    boundingSphere: newBoundingSphere,\n  });\n};\n\n/**\n * Creates an object that maps attribute names to unique locations (indices)\n * for matching vertex attributes and shader programs.\n *\n * @param {Geometry} geometry The geometry, which is not modified, to create the object for.\n * @returns {Object} An object with attribute name / index pairs.\n *\n * @example\n * const attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);\n * // Example output\n * // {\n * //   'position' : 0,\n * //   'normal' : 1\n * // }\n */\nGeometryPipeline.createAttributeLocations = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug')\n\n  // There can be a WebGL performance hit when attribute 0 is disabled, so\n  // assign attribute locations to well-known attributes.\n  const semantics = [\n    \"position\",\n    \"positionHigh\",\n    \"positionLow\",\n\n    // From VertexFormat.position - after 2D projection and high-precision encoding\n    \"position3DHigh\",\n    \"position3DLow\",\n    \"position2DHigh\",\n    \"position2DLow\",\n\n    // From Primitive\n    \"pickColor\",\n\n    // From VertexFormat\n    \"normal\",\n    \"st\",\n    \"tangent\",\n    \"bitangent\",\n\n    // For shadow volumes\n    \"extrudeDirection\",\n\n    // From compressing texture coordinates and normals\n    \"compressedAttributes\",\n  ];\n\n  const attributes = geometry.attributes;\n  const indices = {};\n  let j = 0;\n  let i;\n  const len = semantics.length;\n\n  // Attribute locations for well-known attributes\n  for (i = 0; i < len; ++i) {\n    const semantic = semantics[i];\n\n    if (defined(attributes[semantic])) {\n      indices[semantic] = j++;\n    }\n  }\n\n  // Locations for custom attributes\n  for (const name in attributes) {\n    if (attributes.hasOwnProperty(name) && !defined(indices[name])) {\n      indices[name] = j++;\n    }\n  }\n\n  return indices;\n};\n\n/**\n * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.\n *\n * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPostVertexCache\n */\nGeometryPipeline.reorderForPreVertexCache = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const numVertices = Geometry.computeNumberOfVertices(geometry);\n\n  const indices = geometry.indices;\n  if (defined(indices)) {\n    const indexCrossReferenceOldToNew = new Int32Array(numVertices);\n    for (let i = 0; i < numVertices; i++) {\n      indexCrossReferenceOldToNew[i] = -1;\n    }\n\n    // Construct cross reference and reorder indices\n    const indicesIn = indices;\n    const numIndices = indicesIn.length;\n    const indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);\n\n    let intoIndicesIn = 0;\n    let intoIndicesOut = 0;\n    let nextIndex = 0;\n    let tempIndex;\n    while (intoIndicesIn < numIndices) {\n      tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];\n      if (tempIndex !== -1) {\n        indicesOut[intoIndicesOut] = tempIndex;\n      } else {\n        tempIndex = indicesIn[intoIndicesIn];\n        indexCrossReferenceOldToNew[tempIndex] = nextIndex;\n\n        indicesOut[intoIndicesOut] = nextIndex;\n        ++nextIndex;\n      }\n      ++intoIndicesIn;\n      ++intoIndicesOut;\n    }\n    geometry.indices = indicesOut;\n\n    // Reorder attributes\n    const attributes = geometry.attributes;\n    for (const property in attributes) {\n      if (\n        attributes.hasOwnProperty(property) &&\n        defined(attributes[property]) &&\n        defined(attributes[property].values)\n      ) {\n        const attribute = attributes[property];\n        const elementsIn = attribute.values;\n        let intoElementsIn = 0;\n        const numComponents = attribute.componentsPerAttribute;\n        const elementsOut = ComponentDatatype.createTypedArray(\n          attribute.componentDatatype,\n          nextIndex * numComponents\n        );\n        while (intoElementsIn < numVertices) {\n          const temp = indexCrossReferenceOldToNew[intoElementsIn];\n          if (temp !== -1) {\n            for (let j = 0; j < numComponents; j++) {\n              elementsOut[numComponents * temp + j] =\n                elementsIn[numComponents * intoElementsIn + j];\n            }\n          }\n          ++intoElementsIn;\n        }\n        attribute.values = elementsOut;\n      }\n    }\n  }\n\n  return geometry;\n};\n\n/**\n * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's\n * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>\n * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.\n *\n * @exception {DeveloperError} cacheCapacity must be greater than two.\n *\n *\n * @example\n * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);\n *\n * @see GeometryPipeline.reorderForPreVertexCache\n * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}\n * by Sander, Nehab, and Barczak\n */\nGeometryPipeline.reorderForPostVertexCache = function (\n  geometry,\n  cacheCapacity\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  if (geometry.primitiveType === PrimitiveType.TRIANGLES && defined(indices)) {\n    const numIndices = indices.length;\n    let maximumIndex = 0;\n    for (let j = 0; j < numIndices; j++) {\n      if (indices[j] > maximumIndex) {\n        maximumIndex = indices[j];\n      }\n    }\n    geometry.indices = Tipsify.tipsify({\n      indices: indices,\n      maximumIndex: maximumIndex,\n      cacheSize: cacheCapacity,\n    });\n  }\n\n  return geometry;\n};\n\nfunction copyAttributesDescriptions(attributes) {\n  const newAttributes = {};\n\n  for (const attribute in attributes) {\n    if (\n      attributes.hasOwnProperty(attribute) &&\n      defined(attributes[attribute]) &&\n      defined(attributes[attribute].values)\n    ) {\n      const attr = attributes[attribute];\n      newAttributes[attribute] = new GeometryAttribute({\n        componentDatatype: attr.componentDatatype,\n        componentsPerAttribute: attr.componentsPerAttribute,\n        normalize: attr.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return newAttributes;\n}\n\nfunction copyVertex(destinationAttributes, sourceAttributes, index) {\n  for (const attribute in sourceAttributes) {\n    if (\n      sourceAttributes.hasOwnProperty(attribute) &&\n      defined(sourceAttributes[attribute]) &&\n      defined(sourceAttributes[attribute].values)\n    ) {\n      const attr = sourceAttributes[attribute];\n\n      for (let k = 0; k < attr.componentsPerAttribute; ++k) {\n        destinationAttributes[attribute].values.push(\n          attr.values[index * attr.componentsPerAttribute + k]\n        );\n      }\n    }\n  }\n}\n\n/**\n * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the\n * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements\n * when unsigned int indices are not supported.\n * <p>\n * If the geometry does not have any <code>indices</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to be split into multiple geometries.\n * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.\n *\n * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS\n * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.\n *\n * @example\n * const geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);\n */\nGeometryPipeline.fitToUnsignedShortIndices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    defined(geometry.indices) &&\n    geometry.primitiveType !== PrimitiveType.TRIANGLES &&\n    geometry.primitiveType !== PrimitiveType.LINES &&\n    geometry.primitiveType !== PrimitiveType.POINTS\n  ) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const geometries = [];\n\n  // If there's an index list and more than 64K attributes, it is possible that\n  // some indices are outside the range of unsigned short [0, 64K - 1]\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  if (\n    defined(geometry.indices) &&\n    numberOfVertices >= CesiumMath.SIXTY_FOUR_KILOBYTES\n  ) {\n    let oldToNewIndex = [];\n    let newIndices = [];\n    let currentIndex = 0;\n    let newAttributes = copyAttributesDescriptions(geometry.attributes);\n\n    const originalIndices = geometry.indices;\n    const numberOfIndices = originalIndices.length;\n\n    let indicesPerPrimitive;\n\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      indicesPerPrimitive = 3;\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      indicesPerPrimitive = 2;\n    } else if (geometry.primitiveType === PrimitiveType.POINTS) {\n      indicesPerPrimitive = 1;\n    }\n\n    for (let j = 0; j < numberOfIndices; j += indicesPerPrimitive) {\n      for (let k = 0; k < indicesPerPrimitive; ++k) {\n        const x = originalIndices[j + k];\n        let i = oldToNewIndex[x];\n        if (!defined(i)) {\n          i = currentIndex++;\n          oldToNewIndex[x] = i;\n          copyVertex(newAttributes, geometry.attributes, x);\n        }\n        newIndices.push(i);\n      }\n\n      if (\n        currentIndex + indicesPerPrimitive >=\n        CesiumMath.SIXTY_FOUR_KILOBYTES\n      ) {\n        geometries.push(\n          new Geometry({\n            attributes: newAttributes,\n            indices: newIndices,\n            primitiveType: geometry.primitiveType,\n            boundingSphere: geometry.boundingSphere,\n            boundingSphereCV: geometry.boundingSphereCV,\n          })\n        );\n\n        // Reset for next vertex-array\n        oldToNewIndex = [];\n        newIndices = [];\n        currentIndex = 0;\n        newAttributes = copyAttributesDescriptions(geometry.attributes);\n      }\n    }\n\n    if (newIndices.length !== 0) {\n      geometries.push(\n        new Geometry({\n          attributes: newAttributes,\n          indices: newIndices,\n          primitiveType: geometry.primitiveType,\n          boundingSphere: geometry.boundingSphere,\n          boundingSphereCV: geometry.boundingSphereCV,\n        })\n      );\n    }\n  } else {\n    // No need to split into multiple geometries\n    geometries.push(geometry);\n  }\n\n  return geometries;\n};\n\nconst scratchProjectTo2DCartesian3 = new Cartesian3();\nconst scratchProjectTo2DCartographic = new Cartographic();\n\n/**\n * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>\n * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.\n * <p>\n * If the geometry does not have a <code>position</code>, this function has no effect.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {String} attributeName The name of the attribute.\n * @param {String} attributeName3D The name of the attribute in 3D.\n * @param {String} attributeName2D The name of the attribute in 2D.\n * @param {Object} [projection=new GeographicProjection()] The projection to use.\n * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n * @exception {DeveloperError} Could not project a point to 2D.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');\n */\nGeometryPipeline.projectTo2D = function (\n  geometry,\n  attributeName,\n  attributeName3D,\n  attributeName2D,\n  projection\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeName3D)) {\n    throw new DeveloperError(\"attributeName3D is required.\");\n  }\n  if (!defined(attributeName2D)) {\n    throw new DeveloperError(\"attributeName2D is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      `geometry must have attribute matching the attributeName argument: ${attributeName}.`\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const attribute = geometry.attributes[attributeName];\n  projection = defined(projection) ? projection : new GeographicProjection();\n  const ellipsoid = projection.ellipsoid;\n\n  // Project original values to 2D.\n  const values3D = attribute.values;\n  const projectedValues = new Float64Array(values3D.length);\n  let index = 0;\n\n  for (let i = 0; i < values3D.length; i += 3) {\n    const value = Cartesian3.fromArray(\n      values3D,\n      i,\n      scratchProjectTo2DCartesian3\n    );\n\n    const lonLat = ellipsoid.cartesianToCartographic(\n      value,\n      scratchProjectTo2DCartographic\n    );\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(lonLat)) {\n      throw new DeveloperError(\n        `Could not project point (${value.x}, ${value.y}, ${value.z}) to 2D.`\n      );\n    }\n    //>>includeEnd('debug');\n\n    const projectedLonLat = projection.project(\n      lonLat,\n      scratchProjectTo2DCartesian3\n    );\n\n    projectedValues[index++] = projectedLonLat.x;\n    projectedValues[index++] = projectedLonLat.y;\n    projectedValues[index++] = projectedLonLat.z;\n  }\n\n  // Rename original cartesians to WGS84 cartesians.\n  geometry.attributes[attributeName3D] = attribute;\n\n  // Replace original cartesians with 2D projected cartesians\n  geometry.attributes[attributeName2D] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.DOUBLE,\n    componentsPerAttribute: 3,\n    values: projectedValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nconst encodedResult = {\n  high: 0.0,\n  low: 0.0,\n};\n\n/**\n * Encodes floating-point geometry attribute values as two separate attributes to improve\n * rendering precision.\n * <p>\n * This is commonly used to create high-precision position vertex attributes.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @param {String} attributeName The name of the attribute.\n * @param {String} attributeHighName The name of the attribute for the encoded high bits.\n * @param {String} attributeLowName The name of the attribute for the encoded low bits.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.\n *\n * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.\n * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');\n */\nGeometryPipeline.encodeAttribute = function (\n  geometry,\n  attributeName,\n  attributeHighName,\n  attributeLowName\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (!defined(attributeName)) {\n    throw new DeveloperError(\"attributeName is required.\");\n  }\n  if (!defined(attributeHighName)) {\n    throw new DeveloperError(\"attributeHighName is required.\");\n  }\n  if (!defined(attributeLowName)) {\n    throw new DeveloperError(\"attributeLowName is required.\");\n  }\n  if (!defined(geometry.attributes[attributeName])) {\n    throw new DeveloperError(\n      `geometry must have attribute matching the attributeName argument: ${attributeName}.`\n    );\n  }\n  if (\n    geometry.attributes[attributeName].componentDatatype !==\n    ComponentDatatype.DOUBLE\n  ) {\n    throw new DeveloperError(\n      \"The attribute componentDatatype must be ComponentDatatype.DOUBLE.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const attribute = geometry.attributes[attributeName];\n  const values = attribute.values;\n  const length = values.length;\n  const highValues = new Float32Array(length);\n  const lowValues = new Float32Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    EncodedCartesian3.encode(values[i], encodedResult);\n    highValues[i] = encodedResult.high;\n    lowValues[i] = encodedResult.low;\n  }\n\n  const componentsPerAttribute = attribute.componentsPerAttribute;\n\n  geometry.attributes[attributeHighName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: highValues,\n  });\n  geometry.attributes[attributeLowName] = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: componentsPerAttribute,\n    values: lowValues,\n  });\n  delete geometry.attributes[attributeName];\n\n  return geometry;\n};\n\nlet scratchCartesian3 = new Cartesian3();\n\nfunction transformPoint(matrix, attribute) {\n  if (defined(attribute)) {\n    const values = attribute.values;\n    const length = values.length;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nfunction transformVector(matrix, attribute) {\n  if (defined(attribute)) {\n    const values = attribute.values;\n    const length = values.length;\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.unpack(values, i, scratchCartesian3);\n      Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);\n      scratchCartesian3 = Cartesian3.normalize(\n        scratchCartesian3,\n        scratchCartesian3\n      );\n      Cartesian3.pack(scratchCartesian3, values, i);\n    }\n  }\n}\n\nconst inverseTranspose = new Matrix4();\nconst normalMatrix = new Matrix3();\n\n/**\n * Transforms a geometry instance to world coordinates.  This changes\n * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the\n * following attributes if they are present: <code>position</code>, <code>normal</code>,\n * <code>tangent</code>, and <code>bitangent</code>.\n *\n * @param {GeometryInstance} instance The geometry instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.\n *\n * @example\n * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);\n */\nGeometryPipeline.transformToWorldCoordinates = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const modelMatrix = instance.modelMatrix;\n\n  if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    // Already in world coordinates\n    return instance;\n  }\n\n  const attributes = instance.geometry.attributes;\n\n  // Transform attributes in known vertex formats\n  transformPoint(modelMatrix, attributes.position);\n  transformPoint(modelMatrix, attributes.prevPosition);\n  transformPoint(modelMatrix, attributes.nextPosition);\n\n  if (\n    defined(attributes.normal) ||\n    defined(attributes.tangent) ||\n    defined(attributes.bitangent)\n  ) {\n    Matrix4.inverse(modelMatrix, inverseTranspose);\n    Matrix4.transpose(inverseTranspose, inverseTranspose);\n    Matrix4.getMatrix3(inverseTranspose, normalMatrix);\n\n    transformVector(normalMatrix, attributes.normal);\n    transformVector(normalMatrix, attributes.tangent);\n    transformVector(normalMatrix, attributes.bitangent);\n  }\n\n  const boundingSphere = instance.geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    instance.geometry.boundingSphere = BoundingSphere.transform(\n      boundingSphere,\n      modelMatrix,\n      boundingSphere\n    );\n  }\n\n  instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  return instance;\n};\n\nfunction findAttributesInAllGeometries(instances, propertyName) {\n  const length = instances.length;\n\n  const attributesInAllGeometries = {};\n\n  const attributes0 = instances[0][propertyName].attributes;\n  let name;\n\n  for (name in attributes0) {\n    if (\n      attributes0.hasOwnProperty(name) &&\n      defined(attributes0[name]) &&\n      defined(attributes0[name].values)\n    ) {\n      const attribute = attributes0[name];\n      let numberOfComponents = attribute.values.length;\n      let inAllGeometries = true;\n\n      // Does this same attribute exist in all geometries?\n      for (let i = 1; i < length; ++i) {\n        const otherAttribute = instances[i][propertyName].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllGeometries = false;\n          break;\n        }\n\n        numberOfComponents += otherAttribute.values.length;\n      }\n\n      if (inAllGeometries) {\n        attributesInAllGeometries[name] = new GeometryAttribute({\n          componentDatatype: attribute.componentDatatype,\n          componentsPerAttribute: attribute.componentsPerAttribute,\n          normalize: attribute.normalize,\n          values: ComponentDatatype.createTypedArray(\n            attribute.componentDatatype,\n            numberOfComponents\n          ),\n        });\n      }\n    }\n  }\n\n  return attributesInAllGeometries;\n}\n\nconst tempScratch = new Cartesian3();\n\nfunction combineGeometries(instances, propertyName) {\n  const length = instances.length;\n\n  let name;\n  let i;\n  let j;\n  let k;\n\n  const m = instances[0].modelMatrix;\n  const haveIndices = defined(instances[0][propertyName].indices);\n  const primitiveType = instances[0][propertyName].primitiveType;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (i = 1; i < length; ++i) {\n    if (!Matrix4.equals(instances[i].modelMatrix, m)) {\n      throw new DeveloperError(\"All instances must have the same modelMatrix.\");\n    }\n    if (defined(instances[i][propertyName].indices) !== haveIndices) {\n      throw new DeveloperError(\n        \"All instance geometries must have an indices or not have one.\"\n      );\n    }\n    if (instances[i][propertyName].primitiveType !== primitiveType) {\n      throw new DeveloperError(\n        \"All instance geometries must have the same primitiveType.\"\n      );\n    }\n  }\n  //>>includeEnd('debug');\n\n  // Find subset of attributes in all geometries\n  const attributes = findAttributesInAllGeometries(instances, propertyName);\n  let values;\n  let sourceValues;\n  let sourceValuesLength;\n\n  // Combine attributes from each geometry into a single typed array\n  for (name in attributes) {\n    if (attributes.hasOwnProperty(name)) {\n      values = attributes[name].values;\n\n      k = 0;\n      for (i = 0; i < length; ++i) {\n        sourceValues = instances[i][propertyName].attributes[name].values;\n        sourceValuesLength = sourceValues.length;\n\n        for (j = 0; j < sourceValuesLength; ++j) {\n          values[k++] = sourceValues[j];\n        }\n      }\n    }\n  }\n\n  // Combine index lists\n  let indices;\n\n  if (haveIndices) {\n    let numberOfIndices = 0;\n    for (i = 0; i < length; ++i) {\n      numberOfIndices += instances[i][propertyName].indices.length;\n    }\n\n    const numberOfVertices = Geometry.computeNumberOfVertices(\n      new Geometry({\n        attributes: attributes,\n        primitiveType: PrimitiveType.POINTS,\n      })\n    );\n    const destIndices = IndexDatatype.createTypedArray(\n      numberOfVertices,\n      numberOfIndices\n    );\n\n    let destOffset = 0;\n    let offset = 0;\n\n    for (i = 0; i < length; ++i) {\n      const sourceIndices = instances[i][propertyName].indices;\n      const sourceIndicesLen = sourceIndices.length;\n\n      for (k = 0; k < sourceIndicesLen; ++k) {\n        destIndices[destOffset++] = offset + sourceIndices[k];\n      }\n\n      offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);\n    }\n\n    indices = destIndices;\n  }\n\n  // Create bounding sphere that includes all instances\n  let center = new Cartesian3();\n  let radius = 0.0;\n  let bs;\n\n  for (i = 0; i < length; ++i) {\n    bs = instances[i][propertyName].boundingSphere;\n    if (!defined(bs)) {\n      // If any geometries have an undefined bounding sphere, then so does the combined geometry\n      center = undefined;\n      break;\n    }\n\n    Cartesian3.add(bs.center, center, center);\n  }\n\n  if (defined(center)) {\n    Cartesian3.divideByScalar(center, length, center);\n\n    for (i = 0; i < length; ++i) {\n      bs = instances[i][propertyName].boundingSphere;\n      const tempRadius =\n        Cartesian3.magnitude(\n          Cartesian3.subtract(bs.center, center, tempScratch)\n        ) + bs.radius;\n\n      if (tempRadius > radius) {\n        radius = tempRadius;\n      }\n    }\n  }\n\n  return new Geometry({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: primitiveType,\n    boundingSphere: defined(center)\n      ? new BoundingSphere(center, radius)\n      : undefined,\n  });\n}\n\n/**\n * Combines geometry from several {@link GeometryInstance} objects into one geometry.\n * This concatenates the attributes, concatenates and adjusts the indices, and creates\n * a bounding sphere encompassing all instances.\n * <p>\n * If the instances do not have the same attributes, a subset of attributes common\n * to all instances is used, and the others are ignored.\n * </p>\n * <p>\n * This is used by {@link Primitive} to efficiently render a large amount of static data.\n * </p>\n *\n * @private\n *\n * @param {GeometryInstance[]} [instances] The array of {@link GeometryInstance} objects whose geometry will be combined.\n * @returns {Geometry} A single geometry created from the provided geometry instances.\n *\n * @exception {DeveloperError} All instances must have the same modelMatrix.\n * @exception {DeveloperError} All instance geometries must have an indices or not have one.\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n *\n *\n * @example\n * for (let i = 0; i < instances.length; ++i) {\n *   Cesium.GeometryPipeline.transformToWorldCoordinates(instances[i]);\n * }\n * const geometries = Cesium.GeometryPipeline.combineInstances(instances);\n *\n * @see GeometryPipeline.transformToWorldCoordinates\n */\nGeometryPipeline.combineInstances = function (instances) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instances) || instances.length < 1) {\n    throw new DeveloperError(\n      \"instances is required and must have length greater than zero.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const instanceGeometry = [];\n  const instanceSplitGeometry = [];\n  const length = instances.length;\n  for (let i = 0; i < length; ++i) {\n    const instance = instances[i];\n\n    if (defined(instance.geometry)) {\n      instanceGeometry.push(instance);\n    } else if (\n      defined(instance.westHemisphereGeometry) &&\n      defined(instance.eastHemisphereGeometry)\n    ) {\n      instanceSplitGeometry.push(instance);\n    }\n  }\n\n  const geometries = [];\n  if (instanceGeometry.length > 0) {\n    geometries.push(combineGeometries(instanceGeometry, \"geometry\"));\n  }\n\n  if (instanceSplitGeometry.length > 0) {\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"westHemisphereGeometry\")\n    );\n    geometries.push(\n      combineGeometries(instanceSplitGeometry, \"eastHemisphereGeometry\")\n    );\n  }\n\n  return geometries;\n};\n\nconst normal = new Cartesian3();\nconst v0 = new Cartesian3();\nconst v1 = new Cartesian3();\nconst v2 = new Cartesian3();\n\n/**\n * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of\n * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.\n * This assumes a counter-clockwise winding order.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeNormal(geometry);\n */\nGeometryPipeline.computeNormal = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  if (\n    !defined(geometry.attributes.position) ||\n    !defined(geometry.attributes.position.values)\n  ) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\"\n    );\n  }\n  if (!defined(geometry.indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\"\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const indices = geometry.indices;\n  const attributes = geometry.attributes;\n  const vertices = attributes.position.values;\n  const numVertices = attributes.position.values.length / 3;\n  const numIndices = indices.length;\n  const normalsPerVertex = new Array(numVertices);\n  const normalsPerTriangle = new Array(numIndices / 3);\n  const normalIndices = new Array(numIndices);\n  let i;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i] = {\n      indexOffset: 0,\n      count: 0,\n      currentCount: 0,\n    };\n  }\n\n  let j = 0;\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    const i03 = i0 * 3;\n    const i13 = i1 * 3;\n    const i23 = i2 * 3;\n\n    v0.x = vertices[i03];\n    v0.y = vertices[i03 + 1];\n    v0.z = vertices[i03 + 2];\n    v1.x = vertices[i13];\n    v1.y = vertices[i13 + 1];\n    v1.z = vertices[i13 + 2];\n    v2.x = vertices[i23];\n    v2.y = vertices[i23 + 1];\n    v2.z = vertices[i23 + 2];\n\n    normalsPerVertex[i0].count++;\n    normalsPerVertex[i1].count++;\n    normalsPerVertex[i2].count++;\n\n    Cartesian3.subtract(v1, v0, v1);\n    Cartesian3.subtract(v2, v0, v2);\n    normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());\n    j++;\n  }\n\n  let indexOffset = 0;\n  for (i = 0; i < numVertices; i++) {\n    normalsPerVertex[i].indexOffset += indexOffset;\n    indexOffset += normalsPerVertex[i].count;\n  }\n\n  j = 0;\n  let vertexNormalData;\n  for (i = 0; i < numIndices; i += 3) {\n    vertexNormalData = normalsPerVertex[indices[i]];\n    let index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 1]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    vertexNormalData = normalsPerVertex[indices[i + 2]];\n    index = vertexNormalData.indexOffset + vertexNormalData.currentCount;\n    normalIndices[index] = j;\n    vertexNormalData.currentCount++;\n\n    j++;\n  }\n\n  const normalValues = new Float32Array(numVertices * 3);\n  for (i = 0; i < numVertices; i++) {\n    const i3 = i * 3;\n    vertexNormalData = normalsPerVertex[i];\n    Cartesian3.clone(Cartesian3.ZERO, normal);\n    if (vertexNormalData.count > 0) {\n      for (j = 0; j < vertexNormalData.count; j++) {\n        Cartesian3.add(\n          normal,\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]],\n          normal\n        );\n      }\n\n      // We can run into an issue where a vertex is used with 2 primitives that have opposite winding order.\n      if (\n        Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n      ) {\n        Cartesian3.clone(\n          normalsPerTriangle[normalIndices[vertexNormalData.indexOffset]],\n          normal\n        );\n      }\n    }\n\n    // We end up with a zero vector probably because of a degenerate triangle\n    if (\n      Cartesian3.equalsEpsilon(Cartesian3.ZERO, normal, CesiumMath.EPSILON10)\n    ) {\n      // Default to (0,0,1)\n      normal.z = 1.0;\n    }\n\n    Cartesian3.normalize(normal, normal);\n    normalValues[i3] = normal.x;\n    normalValues[i3 + 1] = normal.y;\n    normalValues[i3 + 2] = normal.z;\n  }\n\n  geometry.attributes.normal = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: normalValues,\n  });\n\n  return geometry;\n};\n\nconst normalScratch = new Cartesian3();\nconst normalScale = new Cartesian3();\nconst tScratch = new Cartesian3();\n\n/**\n * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.\n * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.\n * This assumes a counter-clockwise winding order.\n * <p>\n * Based on <a href=\"http://www.terathon.com/code/tangent.html\">Computing Tangent Space Basis Vectors\n * for an Arbitrary Mesh</a> by Eric Lengyel.\n * </p>\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.\n *\n * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.\n * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.\n *\n * @example\n * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);\n */\nGeometryPipeline.computeTangentAndBitangent = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const attributes = geometry.attributes;\n  const indices = geometry.indices;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(attributes.position) || !defined(attributes.position.values)) {\n    throw new DeveloperError(\n      \"geometry.attributes.position.values is required.\"\n    );\n  }\n  if (!defined(attributes.normal) || !defined(attributes.normal.values)) {\n    throw new DeveloperError(\"geometry.attributes.normal.values is required.\");\n  }\n  if (!defined(attributes.st) || !defined(attributes.st.values)) {\n    throw new DeveloperError(\"geometry.attributes.st.values is required.\");\n  }\n  if (!defined(indices)) {\n    throw new DeveloperError(\"geometry.indices is required.\");\n  }\n  if (indices.length < 2 || indices.length % 3 !== 0) {\n    throw new DeveloperError(\n      \"geometry.indices length must be greater than 0 and be a multiple of 3.\"\n    );\n  }\n  if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {\n    throw new DeveloperError(\n      \"geometry.primitiveType must be PrimitiveType.TRIANGLES.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const vertices = geometry.attributes.position.values;\n  const normals = geometry.attributes.normal.values;\n  const st = geometry.attributes.st.values;\n\n  const numVertices = geometry.attributes.position.values.length / 3;\n  const numIndices = indices.length;\n  const tan1 = new Array(numVertices * 3);\n\n  let i;\n  for (i = 0; i < tan1.length; i++) {\n    tan1[i] = 0;\n  }\n\n  let i03;\n  let i13;\n  let i23;\n  for (i = 0; i < numIndices; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n    i03 = i0 * 3;\n    i13 = i1 * 3;\n    i23 = i2 * 3;\n    const i02 = i0 * 2;\n    const i12 = i1 * 2;\n    const i22 = i2 * 2;\n\n    const ux = vertices[i03];\n    const uy = vertices[i03 + 1];\n    const uz = vertices[i03 + 2];\n\n    const wx = st[i02];\n    const wy = st[i02 + 1];\n    const t1 = st[i12 + 1] - wy;\n    const t2 = st[i22 + 1] - wy;\n\n    const r = 1.0 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);\n    const sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;\n    const sdiry =\n      (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;\n    const sdirz =\n      (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;\n\n    tan1[i03] += sdirx;\n    tan1[i03 + 1] += sdiry;\n    tan1[i03 + 2] += sdirz;\n\n    tan1[i13] += sdirx;\n    tan1[i13 + 1] += sdiry;\n    tan1[i13 + 2] += sdirz;\n\n    tan1[i23] += sdirx;\n    tan1[i23 + 1] += sdiry;\n    tan1[i23 + 2] += sdirz;\n  }\n\n  const tangentValues = new Float32Array(numVertices * 3);\n  const bitangentValues = new Float32Array(numVertices * 3);\n\n  for (i = 0; i < numVertices; i++) {\n    i03 = i * 3;\n    i13 = i03 + 1;\n    i23 = i03 + 2;\n\n    const n = Cartesian3.fromArray(normals, i03, normalScratch);\n    const t = Cartesian3.fromArray(tan1, i03, tScratch);\n    const scalar = Cartesian3.dot(n, t);\n    Cartesian3.multiplyByScalar(n, scalar, normalScale);\n    Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);\n\n    tangentValues[i03] = t.x;\n    tangentValues[i13] = t.y;\n    tangentValues[i23] = t.z;\n\n    Cartesian3.normalize(Cartesian3.cross(n, t, t), t);\n\n    bitangentValues[i03] = t.x;\n    bitangentValues[i13] = t.y;\n    bitangentValues[i23] = t.z;\n  }\n\n  geometry.attributes.tangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: tangentValues,\n  });\n\n  geometry.attributes.bitangent = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: 3,\n    values: bitangentValues,\n  });\n\n  return geometry;\n};\n\nconst scratchCartesian2 = new Cartesian2();\nconst toEncode1 = new Cartesian3();\nconst toEncode2 = new Cartesian3();\nconst toEncode3 = new Cartesian3();\nlet encodeResult2 = new Cartesian2();\n/**\n * Compresses and packs geometry normal attribute values to save memory.\n *\n * @param {Geometry} geometry The geometry to modify.\n * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.\n *\n * @example\n * geometry = Cesium.GeometryPipeline.compressVertices(geometry);\n */\nGeometryPipeline.compressVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(geometry)) {\n    throw new DeveloperError(\"geometry is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const extrudeAttribute = geometry.attributes.extrudeDirection;\n  let i;\n  let numVertices;\n  if (defined(extrudeAttribute)) {\n    //only shadow volumes use extrudeDirection, and shadow volumes use vertexFormat: POSITION_ONLY so we don't need to check other attributes\n    const extrudeDirections = extrudeAttribute.values;\n    numVertices = extrudeDirections.length / 3.0;\n    const compressedDirections = new Float32Array(numVertices * 2);\n\n    let i2 = 0;\n    for (i = 0; i < numVertices; ++i) {\n      Cartesian3.fromArray(extrudeDirections, i * 3.0, toEncode1);\n      if (Cartesian3.equals(toEncode1, Cartesian3.ZERO)) {\n        i2 += 2;\n        continue;\n      }\n      encodeResult2 = AttributeCompression.octEncodeInRange(\n        toEncode1,\n        65535,\n        encodeResult2\n      );\n      compressedDirections[i2++] = encodeResult2.x;\n      compressedDirections[i2++] = encodeResult2.y;\n    }\n\n    geometry.attributes.compressedAttributes = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: compressedDirections,\n    });\n    delete geometry.attributes.extrudeDirection;\n    return geometry;\n  }\n\n  const normalAttribute = geometry.attributes.normal;\n  const stAttribute = geometry.attributes.st;\n\n  const hasNormal = defined(normalAttribute);\n  const hasSt = defined(stAttribute);\n  if (!hasNormal && !hasSt) {\n    return geometry;\n  }\n\n  const tangentAttribute = geometry.attributes.tangent;\n  const bitangentAttribute = geometry.attributes.bitangent;\n\n  const hasTangent = defined(tangentAttribute);\n  const hasBitangent = defined(bitangentAttribute);\n\n  let normals;\n  let st;\n  let tangents;\n  let bitangents;\n\n  if (hasNormal) {\n    normals = normalAttribute.values;\n  }\n  if (hasSt) {\n    st = stAttribute.values;\n  }\n  if (hasTangent) {\n    tangents = tangentAttribute.values;\n  }\n  if (hasBitangent) {\n    bitangents = bitangentAttribute.values;\n  }\n\n  const length = hasNormal ? normals.length : st.length;\n  const numComponents = hasNormal ? 3.0 : 2.0;\n  numVertices = length / numComponents;\n\n  let compressedLength = numVertices;\n  let numCompressedComponents = hasSt && hasNormal ? 2.0 : 1.0;\n  numCompressedComponents += hasTangent || hasBitangent ? 1.0 : 0.0;\n  compressedLength *= numCompressedComponents;\n\n  const compressedAttributes = new Float32Array(compressedLength);\n\n  let normalIndex = 0;\n  for (i = 0; i < numVertices; ++i) {\n    if (hasSt) {\n      Cartesian2.fromArray(st, i * 2.0, scratchCartesian2);\n      compressedAttributes[\n        normalIndex++\n      ] = AttributeCompression.compressTextureCoordinates(scratchCartesian2);\n    }\n\n    const index = i * 3.0;\n    if (hasNormal && defined(tangents) && defined(bitangents)) {\n      Cartesian3.fromArray(normals, index, toEncode1);\n      Cartesian3.fromArray(tangents, index, toEncode2);\n      Cartesian3.fromArray(bitangents, index, toEncode3);\n\n      AttributeCompression.octPack(\n        toEncode1,\n        toEncode2,\n        toEncode3,\n        scratchCartesian2\n      );\n      compressedAttributes[normalIndex++] = scratchCartesian2.x;\n      compressedAttributes[normalIndex++] = scratchCartesian2.y;\n    } else {\n      if (hasNormal) {\n        Cartesian3.fromArray(normals, index, toEncode1);\n        compressedAttributes[\n          normalIndex++\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasTangent) {\n        Cartesian3.fromArray(tangents, index, toEncode1);\n        compressedAttributes[\n          normalIndex++\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n\n      if (hasBitangent) {\n        Cartesian3.fromArray(bitangents, index, toEncode1);\n        compressedAttributes[\n          normalIndex++\n        ] = AttributeCompression.octEncodeFloat(toEncode1);\n      }\n    }\n  }\n\n  geometry.attributes.compressedAttributes = new GeometryAttribute({\n    componentDatatype: ComponentDatatype.FLOAT,\n    componentsPerAttribute: numCompressedComponents,\n    values: compressedAttributes,\n  });\n\n  if (hasNormal) {\n    delete geometry.attributes.normal;\n  }\n  if (hasSt) {\n    delete geometry.attributes.st;\n  }\n  if (hasBitangent) {\n    delete geometry.attributes.bitangent;\n  }\n  if (hasTangent) {\n    delete geometry.attributes.tangent;\n  }\n\n  return geometry;\n};\n\nfunction indexTriangles(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  if (numberOfVertices % 3 !== 0) {\n    throw new DeveloperError(\n      \"The number of vertices must be a multiple of three.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices\n  );\n  for (let i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexTriangleFan(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least three.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3\n  );\n  indices[0] = 1;\n  indices[1] = 0;\n  indices[2] = 2;\n\n  let indicesIndex = 3;\n  for (let i = 3; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = 0;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexTriangleStrip(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 3) {\n    throw new DeveloperError(\"The number of vertices must be at least 3.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 2) * 3\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  indices[2] = 2;\n\n  if (numberOfVertices > 3) {\n    indices[3] = 0;\n    indices[4] = 2;\n    indices[5] = 3;\n  }\n\n  let indicesIndex = 6;\n  for (let i = 3; i < numberOfVertices - 1; i += 2) {\n    indices[indicesIndex++] = i;\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i + 1;\n\n    if (i + 2 < numberOfVertices) {\n      indices[indicesIndex++] = i;\n      indices[indicesIndex++] = i + 1;\n      indices[indicesIndex++] = i + 2;\n    }\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.TRIANGLES;\n  return geometry;\n}\n\nfunction indexLines(geometry) {\n  if (defined(geometry.indices)) {\n    return geometry;\n  }\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  if (numberOfVertices % 2 !== 0) {\n    throw new DeveloperError(\"The number of vertices must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices\n  );\n  for (let i = 0; i < numberOfVertices; ++i) {\n    indices[i] = i;\n  }\n\n  geometry.indices = indices;\n  return geometry;\n}\n\nfunction indexLineStrip(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    (numberOfVertices - 1) * 2\n  );\n  indices[0] = 0;\n  indices[1] = 1;\n  let indicesIndex = 2;\n  for (let i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexLineLoop(geometry) {\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (numberOfVertices < 2) {\n    throw new DeveloperError(\"The number of vertices must be at least two.\");\n  }\n  //>>includeEnd('debug');\n\n  const indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    numberOfVertices * 2\n  );\n\n  indices[0] = 0;\n  indices[1] = 1;\n\n  let indicesIndex = 2;\n  for (let i = 2; i < numberOfVertices; ++i) {\n    indices[indicesIndex++] = i - 1;\n    indices[indicesIndex++] = i;\n  }\n\n  indices[indicesIndex++] = numberOfVertices - 1;\n  indices[indicesIndex] = 0;\n\n  geometry.indices = indices;\n  geometry.primitiveType = PrimitiveType.LINES;\n  return geometry;\n}\n\nfunction indexPrimitive(geometry) {\n  switch (geometry.primitiveType) {\n    case PrimitiveType.TRIANGLE_FAN:\n      return indexTriangleFan(geometry);\n    case PrimitiveType.TRIANGLE_STRIP:\n      return indexTriangleStrip(geometry);\n    case PrimitiveType.TRIANGLES:\n      return indexTriangles(geometry);\n    case PrimitiveType.LINE_STRIP:\n      return indexLineStrip(geometry);\n    case PrimitiveType.LINE_LOOP:\n      return indexLineLoop(geometry);\n    case PrimitiveType.LINES:\n      return indexLines(geometry);\n  }\n\n  return geometry;\n}\n\nfunction offsetPointFromXZPlane(p, isBehind) {\n  if (Math.abs(p.y) < CesiumMath.EPSILON6) {\n    if (isBehind) {\n      p.y = -CesiumMath.EPSILON6;\n    } else {\n      p.y = CesiumMath.EPSILON6;\n    }\n  }\n}\n\nfunction offsetTriangleFromXZPlane(p0, p1, p2) {\n  if (p0.y !== 0.0 && p1.y !== 0.0 && p2.y !== 0.0) {\n    offsetPointFromXZPlane(p0, p0.y < 0.0);\n    offsetPointFromXZPlane(p1, p1.y < 0.0);\n    offsetPointFromXZPlane(p2, p2.y < 0.0);\n    return;\n  }\n\n  const p0y = Math.abs(p0.y);\n  const p1y = Math.abs(p1.y);\n  const p2y = Math.abs(p2.y);\n\n  let sign;\n  if (p0y > p1y) {\n    if (p0y > p2y) {\n      sign = CesiumMath.sign(p0.y);\n    } else {\n      sign = CesiumMath.sign(p2.y);\n    }\n  } else if (p1y > p2y) {\n    sign = CesiumMath.sign(p1.y);\n  } else {\n    sign = CesiumMath.sign(p2.y);\n  }\n\n  const isBehind = sign < 0.0;\n  offsetPointFromXZPlane(p0, isBehind);\n  offsetPointFromXZPlane(p1, isBehind);\n  offsetPointFromXZPlane(p2, isBehind);\n}\n\nconst c3 = new Cartesian3();\nfunction getXZIntersectionOffsetPoints(p, p1, u1, v1) {\n  Cartesian3.add(\n    p,\n    Cartesian3.multiplyByScalar(\n      Cartesian3.subtract(p1, p, c3),\n      p.y / (p.y - p1.y),\n      c3\n    ),\n    u1\n  );\n  Cartesian3.clone(u1, v1);\n  offsetPointFromXZPlane(u1, true);\n  offsetPointFromXZPlane(v1, false);\n}\n\nconst u1 = new Cartesian3();\nconst u2 = new Cartesian3();\nconst q1 = new Cartesian3();\nconst q2 = new Cartesian3();\n\nconst splitTriangleResult = {\n  positions: new Array(7),\n  indices: new Array(3 * 3),\n};\n\nfunction splitTriangle(p0, p1, p2) {\n  // In WGS84 coordinates, for a triangle approximately on the\n  // ellipsoid to cross the IDL, first it needs to be on the\n  // negative side of the plane x = 0.\n  if (p0.x >= 0.0 || p1.x >= 0.0 || p2.x >= 0.0) {\n    return undefined;\n  }\n\n  offsetTriangleFromXZPlane(p0, p1, p2);\n\n  const p0Behind = p0.y < 0.0;\n  const p1Behind = p1.y < 0.0;\n  const p2Behind = p2.y < 0.0;\n\n  let numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  const indices = splitTriangleResult.indices;\n\n  if (numBehind === 1) {\n    indices[1] = 3;\n    indices[2] = 4;\n    indices[5] = 6;\n    indices[7] = 6;\n    indices[8] = 5;\n\n    if (p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 0;\n      indices[3] = 1;\n      indices[4] = 2;\n      indices[6] = 1;\n    } else if (p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 1;\n      indices[3] = 2;\n      indices[4] = 0;\n      indices[6] = 2;\n    } else if (p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 2;\n      indices[3] = 0;\n      indices[4] = 1;\n      indices[6] = 0;\n    }\n  } else if (numBehind === 2) {\n    indices[2] = 4;\n    indices[4] = 4;\n    indices[5] = 3;\n    indices[7] = 5;\n    indices[8] = 6;\n\n    if (!p0Behind) {\n      getXZIntersectionOffsetPoints(p0, p1, u1, q1);\n      getXZIntersectionOffsetPoints(p0, p2, u2, q2);\n\n      indices[0] = 1;\n      indices[1] = 2;\n      indices[3] = 1;\n      indices[6] = 0;\n    } else if (!p1Behind) {\n      getXZIntersectionOffsetPoints(p1, p2, u1, q1);\n      getXZIntersectionOffsetPoints(p1, p0, u2, q2);\n\n      indices[0] = 2;\n      indices[1] = 0;\n      indices[3] = 2;\n      indices[6] = 1;\n    } else if (!p2Behind) {\n      getXZIntersectionOffsetPoints(p2, p0, u1, q1);\n      getXZIntersectionOffsetPoints(p2, p1, u2, q2);\n\n      indices[0] = 0;\n      indices[1] = 1;\n      indices[3] = 0;\n      indices[6] = 2;\n    }\n  }\n\n  const positions = splitTriangleResult.positions;\n  positions[0] = p0;\n  positions[1] = p1;\n  positions[2] = p2;\n  positions.length = 3;\n\n  if (numBehind === 1 || numBehind === 2) {\n    positions[3] = u1;\n    positions[4] = u2;\n    positions[5] = q1;\n    positions[6] = q2;\n    positions.length = 7;\n  }\n\n  return splitTriangleResult;\n}\n\nfunction updateGeometryAfterSplit(geometry, computeBoundingSphere) {\n  const attributes = geometry.attributes;\n\n  if (attributes.position.values.length === 0) {\n    return undefined;\n  }\n\n  for (const property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      const attribute = attributes[property];\n      attribute.values = ComponentDatatype.createTypedArray(\n        attribute.componentDatatype,\n        attribute.values\n      );\n    }\n  }\n\n  const numberOfVertices = Geometry.computeNumberOfVertices(geometry);\n  geometry.indices = IndexDatatype.createTypedArray(\n    numberOfVertices,\n    geometry.indices\n  );\n\n  if (computeBoundingSphere) {\n    geometry.boundingSphere = BoundingSphere.fromVertices(\n      attributes.position.values\n    );\n  }\n\n  return geometry;\n}\n\nfunction copyGeometryForSplit(geometry) {\n  const attributes = geometry.attributes;\n  const copiedAttributes = {};\n\n  for (const property in attributes) {\n    if (\n      attributes.hasOwnProperty(property) &&\n      defined(attributes[property]) &&\n      defined(attributes[property].values)\n    ) {\n      const attribute = attributes[property];\n      copiedAttributes[property] = new GeometryAttribute({\n        componentDatatype: attribute.componentDatatype,\n        componentsPerAttribute: attribute.componentsPerAttribute,\n        normalize: attribute.normalize,\n        values: [],\n      });\n    }\n  }\n\n  return new Geometry({\n    attributes: copiedAttributes,\n    indices: [],\n    primitiveType: geometry.primitiveType,\n  });\n}\n\nfunction updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {\n  const computeBoundingSphere = defined(instance.geometry.boundingSphere);\n\n  westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);\n  eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);\n\n  if (defined(eastGeometry) && !defined(westGeometry)) {\n    instance.geometry = eastGeometry;\n  } else if (!defined(eastGeometry) && defined(westGeometry)) {\n    instance.geometry = westGeometry;\n  } else {\n    instance.westHemisphereGeometry = westGeometry;\n    instance.eastHemisphereGeometry = eastGeometry;\n    instance.geometry = undefined;\n  }\n}\n\nfunction generateBarycentricInterpolateFunction(\n  CartesianType,\n  numberOfComponents\n) {\n  const v0Scratch = new CartesianType();\n  const v1Scratch = new CartesianType();\n  const v2Scratch = new CartesianType();\n\n  return function (\n    i0,\n    i1,\n    i2,\n    coords,\n    sourceValues,\n    currentValues,\n    insertedIndex,\n    normalize\n  ) {\n    const v0 = CartesianType.fromArray(\n      sourceValues,\n      i0 * numberOfComponents,\n      v0Scratch\n    );\n    const v1 = CartesianType.fromArray(\n      sourceValues,\n      i1 * numberOfComponents,\n      v1Scratch\n    );\n    const v2 = CartesianType.fromArray(\n      sourceValues,\n      i2 * numberOfComponents,\n      v2Scratch\n    );\n\n    CartesianType.multiplyByScalar(v0, coords.x, v0);\n    CartesianType.multiplyByScalar(v1, coords.y, v1);\n    CartesianType.multiplyByScalar(v2, coords.z, v2);\n\n    const value = CartesianType.add(v0, v1, v0);\n    CartesianType.add(value, v2, value);\n\n    if (normalize) {\n      CartesianType.normalize(value, value);\n    }\n\n    CartesianType.pack(\n      value,\n      currentValues,\n      insertedIndex * numberOfComponents\n    );\n  };\n}\n\nconst interpolateAndPackCartesian4 = generateBarycentricInterpolateFunction(\n  Cartesian4,\n  4\n);\nconst interpolateAndPackCartesian3 = generateBarycentricInterpolateFunction(\n  Cartesian3,\n  3\n);\nconst interpolateAndPackCartesian2 = generateBarycentricInterpolateFunction(\n  Cartesian2,\n  2\n);\nconst interpolateAndPackBoolean = function (\n  i0,\n  i1,\n  i2,\n  coords,\n  sourceValues,\n  currentValues,\n  insertedIndex\n) {\n  const v1 = sourceValues[i0] * coords.x;\n  const v2 = sourceValues[i1] * coords.y;\n  const v3 = sourceValues[i2] * coords.z;\n  currentValues[insertedIndex] = v1 + v2 + v3 > CesiumMath.EPSILON6 ? 1 : 0;\n};\n\nconst p0Scratch = new Cartesian3();\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\nconst barycentricScratch = new Cartesian3();\n\nfunction computeTriangleAttributes(\n  i0,\n  i1,\n  i2,\n  point,\n  positions,\n  normals,\n  tangents,\n  bitangents,\n  texCoords,\n  extrudeDirections,\n  applyOffset,\n  currentAttributes,\n  customAttributeNames,\n  customAttributesLength,\n  allAttributes,\n  insertedIndex\n) {\n  if (\n    !defined(normals) &&\n    !defined(tangents) &&\n    !defined(bitangents) &&\n    !defined(texCoords) &&\n    !defined(extrudeDirections) &&\n    customAttributesLength === 0\n  ) {\n    return;\n  }\n\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n  const p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);\n  const coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);\n  if (!defined(coords)) {\n    return;\n  }\n\n  if (defined(normals)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      normals,\n      currentAttributes.normal.values,\n      insertedIndex,\n      true\n    );\n  }\n\n  if (defined(extrudeDirections)) {\n    const d0 = Cartesian3.fromArray(extrudeDirections, i0 * 3, p0Scratch);\n    const d1 = Cartesian3.fromArray(extrudeDirections, i1 * 3, p1Scratch);\n    const d2 = Cartesian3.fromArray(extrudeDirections, i2 * 3, p2Scratch);\n\n    Cartesian3.multiplyByScalar(d0, coords.x, d0);\n    Cartesian3.multiplyByScalar(d1, coords.y, d1);\n    Cartesian3.multiplyByScalar(d2, coords.z, d2);\n\n    let direction;\n    if (\n      !Cartesian3.equals(d0, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d1, Cartesian3.ZERO) ||\n      !Cartesian3.equals(d2, Cartesian3.ZERO)\n    ) {\n      direction = Cartesian3.add(d0, d1, d0);\n      Cartesian3.add(direction, d2, direction);\n      Cartesian3.normalize(direction, direction);\n    } else {\n      direction = p0Scratch;\n      direction.x = 0;\n      direction.y = 0;\n      direction.z = 0;\n    }\n    Cartesian3.pack(\n      direction,\n      currentAttributes.extrudeDirection.values,\n      insertedIndex * 3\n    );\n  }\n\n  if (defined(applyOffset)) {\n    interpolateAndPackBoolean(\n      i0,\n      i1,\n      i2,\n      coords,\n      applyOffset,\n      currentAttributes.applyOffset.values,\n      insertedIndex\n    );\n  }\n\n  if (defined(tangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      tangents,\n      currentAttributes.tangent.values,\n      insertedIndex,\n      true\n    );\n  }\n\n  if (defined(bitangents)) {\n    interpolateAndPackCartesian3(\n      i0,\n      i1,\n      i2,\n      coords,\n      bitangents,\n      currentAttributes.bitangent.values,\n      insertedIndex,\n      true\n    );\n  }\n\n  if (defined(texCoords)) {\n    interpolateAndPackCartesian2(\n      i0,\n      i1,\n      i2,\n      coords,\n      texCoords,\n      currentAttributes.st.values,\n      insertedIndex\n    );\n  }\n\n  if (customAttributesLength > 0) {\n    for (let i = 0; i < customAttributesLength; i++) {\n      const attributeName = customAttributeNames[i];\n      genericInterpolate(\n        i0,\n        i1,\n        i2,\n        coords,\n        insertedIndex,\n        allAttributes[attributeName],\n        currentAttributes[attributeName]\n      );\n    }\n  }\n}\n\nfunction genericInterpolate(\n  i0,\n  i1,\n  i2,\n  coords,\n  insertedIndex,\n  sourceAttribute,\n  currentAttribute\n) {\n  const componentsPerAttribute = sourceAttribute.componentsPerAttribute;\n  const sourceValues = sourceAttribute.values;\n  const currentValues = currentAttribute.values;\n  switch (componentsPerAttribute) {\n    case 4:\n      interpolateAndPackCartesian4(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false\n      );\n      break;\n    case 3:\n      interpolateAndPackCartesian3(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false\n      );\n      break;\n    case 2:\n      interpolateAndPackCartesian2(\n        i0,\n        i1,\n        i2,\n        coords,\n        sourceValues,\n        currentValues,\n        insertedIndex,\n        false\n      );\n      break;\n    default:\n      currentValues[insertedIndex] =\n        sourceValues[i0] * coords.x +\n        sourceValues[i1] * coords.y +\n        sourceValues[i2] * coords.z;\n  }\n}\n\nfunction insertSplitPoint(\n  currentAttributes,\n  currentIndices,\n  currentIndexMap,\n  indices,\n  currentIndex,\n  point\n) {\n  const insertIndex = currentAttributes.position.values.length / 3;\n\n  if (currentIndex !== -1) {\n    const prevIndex = indices[currentIndex];\n    const newIndex = currentIndexMap[prevIndex];\n\n    if (newIndex === -1) {\n      currentIndexMap[prevIndex] = insertIndex;\n      currentAttributes.position.values.push(point.x, point.y, point.z);\n      currentIndices.push(insertIndex);\n      return insertIndex;\n    }\n\n    currentIndices.push(newIndex);\n    return newIndex;\n  }\n\n  currentAttributes.position.values.push(point.x, point.y, point.z);\n  currentIndices.push(insertIndex);\n  return insertIndex;\n}\n\nconst NAMED_ATTRIBUTES = {\n  position: true,\n  normal: true,\n  bitangent: true,\n  tangent: true,\n  st: true,\n  extrudeDirection: true,\n  applyOffset: true,\n};\nfunction splitLongitudeTriangles(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const normals = defined(attributes.normal)\n    ? attributes.normal.values\n    : undefined;\n  const bitangents = defined(attributes.bitangent)\n    ? attributes.bitangent.values\n    : undefined;\n  const tangents = defined(attributes.tangent)\n    ? attributes.tangent.values\n    : undefined;\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  const extrudeDirections = defined(attributes.extrudeDirection)\n    ? attributes.extrudeDirection.values\n    : undefined;\n  const applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  const indices = geometry.indices;\n\n  const customAttributeNames = [];\n  for (const attributeName in attributes) {\n    if (\n      attributes.hasOwnProperty(attributeName) &&\n      !NAMED_ATTRIBUTES[attributeName] &&\n      defined(attributes[attributeName])\n    ) {\n      customAttributeNames.push(attributeName);\n    }\n  }\n  const customAttributesLength = customAttributeNames.length;\n\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n\n  let currentAttributes;\n  let currentIndices;\n  let currentIndexMap;\n  let insertedIndex;\n  let i;\n\n  const westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  const eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  const len = indices.length;\n  for (i = 0; i < len; i += 3) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n    const i2 = indices[i + 2];\n\n    let p0 = Cartesian3.fromArray(positions, i0 * 3);\n    let p1 = Cartesian3.fromArray(positions, i1 * 3);\n    let p2 = Cartesian3.fromArray(positions, i2 * 3);\n\n    const result = splitTriangle(p0, p1, p2);\n    if (defined(result) && result.positions.length > 3) {\n      const resultPositions = result.positions;\n      const resultIndices = result.indices;\n      const resultLength = resultIndices.length;\n\n      for (let j = 0; j < resultLength; ++j) {\n        const resultIndex = resultIndices[j];\n        const point = resultPositions[resultIndex];\n\n        if (point.y < 0.0) {\n          currentAttributes = westGeometry.attributes;\n          currentIndices = westGeometry.indices;\n          currentIndexMap = westGeometryIndexMap;\n        } else {\n          currentAttributes = eastGeometry.attributes;\n          currentIndices = eastGeometry.indices;\n          currentIndexMap = eastGeometryIndexMap;\n        }\n\n        insertedIndex = insertSplitPoint(\n          currentAttributes,\n          currentIndices,\n          currentIndexMap,\n          indices,\n          resultIndex < 3 ? i + resultIndex : -1,\n          point\n        );\n        computeTriangleAttributes(\n          i0,\n          i1,\n          i2,\n          point,\n          positions,\n          normals,\n          tangents,\n          bitangents,\n          texCoords,\n          extrudeDirections,\n          applyOffset,\n          currentAttributes,\n          customAttributeNames,\n          customAttributesLength,\n          attributes,\n          insertedIndex\n        );\n      }\n    } else {\n      if (defined(result)) {\n        p0 = result.positions[0];\n        p1 = result.positions[1];\n        p2 = result.positions[2];\n      }\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p0,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p1,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex\n      );\n\n      insertedIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 2,\n        p2\n      );\n      computeTriangleAttributes(\n        i0,\n        i1,\n        i2,\n        p2,\n        positions,\n        normals,\n        tangents,\n        bitangents,\n        texCoords,\n        extrudeDirections,\n        applyOffset,\n        currentAttributes,\n        customAttributeNames,\n        customAttributesLength,\n        attributes,\n        insertedIndex\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nconst xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\n\nconst offsetScratch = new Cartesian3();\nconst offsetPointScratch = new Cartesian3();\n\nfunction computeLineAttributes(\n  i0,\n  i1,\n  point,\n  positions,\n  insertIndex,\n  currentAttributes,\n  applyOffset\n) {\n  if (!defined(applyOffset)) {\n    return;\n  }\n\n  const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n  if (Cartesian3.equalsEpsilon(p0, point, CesiumMath.EPSILON10)) {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i0];\n  } else {\n    currentAttributes.applyOffset.values[insertIndex] = applyOffset[i1];\n  }\n}\n\nfunction splitLongitudeLines(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const applyOffset = defined(attributes.applyOffset)\n    ? attributes.applyOffset.values\n    : undefined;\n  const indices = geometry.indices;\n\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n\n  let i;\n  const length = indices.length;\n\n  const westGeometryIndexMap = [];\n  westGeometryIndexMap.length = positions.length / 3;\n\n  const eastGeometryIndexMap = [];\n  eastGeometryIndexMap.length = positions.length / 3;\n\n  for (i = 0; i < westGeometryIndexMap.length; ++i) {\n    westGeometryIndexMap[i] = -1;\n    eastGeometryIndexMap[i] = -1;\n  }\n\n  for (i = 0; i < length; i += 2) {\n    const i0 = indices[i];\n    const i1 = indices[i + 1];\n\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);\n    const p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);\n    let insertIndex;\n\n    if (Math.abs(p0.y) < CesiumMath.EPSILON6) {\n      if (p0.y < 0.0) {\n        p0.y = -CesiumMath.EPSILON6;\n      } else {\n        p0.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    if (Math.abs(p1.y) < CesiumMath.EPSILON6) {\n      if (p1.y < 0.0) {\n        p1.y = -CesiumMath.EPSILON6;\n      } else {\n        p1.y = CesiumMath.EPSILON6;\n      }\n    }\n\n    let p0Attributes = eastGeometry.attributes;\n    let p0Indices = eastGeometry.indices;\n    let p0IndexMap = eastGeometryIndexMap;\n    let p1Attributes = westGeometry.attributes;\n    let p1Indices = westGeometry.indices;\n    let p1IndexMap = westGeometryIndexMap;\n\n    const intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p1,\n      xzPlane,\n      p2Scratch\n    );\n    if (defined(intersection)) {\n      // move point on the xz-plane slightly away from the plane\n      const offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        5.0 * CesiumMath.EPSILON9,\n        offsetScratch\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p0IndexMap = westGeometryIndexMap;\n        p1Attributes = eastGeometry.attributes;\n        p1Indices = eastGeometry.indices;\n        p1IndexMap = eastGeometryIndexMap;\n      }\n\n      const offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        offsetPointScratch\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        i,\n        p0\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset\n      );\n\n      insertIndex = insertSplitPoint(\n        p0Attributes,\n        p0Indices,\n        p0IndexMap,\n        indices,\n        -1,\n        offsetPoint\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p0Attributes,\n        applyOffset\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        -1,\n        offsetPoint\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        offsetPoint,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset\n      );\n\n      insertIndex = insertSplitPoint(\n        p1Attributes,\n        p1Indices,\n        p1IndexMap,\n        indices,\n        i + 1,\n        p1\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        p1Attributes,\n        applyOffset\n      );\n    } else {\n      let currentAttributes;\n      let currentIndices;\n      let currentIndexMap;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n        currentIndexMap = westGeometryIndexMap;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n        currentIndexMap = eastGeometryIndexMap;\n      }\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i,\n        p0\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p0,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset\n      );\n\n      insertIndex = insertSplitPoint(\n        currentAttributes,\n        currentIndices,\n        currentIndexMap,\n        indices,\n        i + 1,\n        p1\n      );\n      computeLineAttributes(\n        i0,\n        i1,\n        p1,\n        positions,\n        insertIndex,\n        currentAttributes,\n        applyOffset\n      );\n    }\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\nconst cartesian2Scratch0 = new Cartesian2();\nconst cartesian2Scratch1 = new Cartesian2();\n\nconst cartesian3Scratch0 = new Cartesian3();\nconst cartesian3Scratch2 = new Cartesian3();\nconst cartesian3Scratch3 = new Cartesian3();\nconst cartesian3Scratch4 = new Cartesian3();\nconst cartesian3Scratch5 = new Cartesian3();\nconst cartesian3Scratch6 = new Cartesian3();\n\nconst cartesian4Scratch0 = new Cartesian4();\n\nfunction updateAdjacencyAfterSplit(geometry) {\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const prevPositions = attributes.prevPosition.values;\n  const nextPositions = attributes.nextPosition.values;\n\n  const length = positions.length;\n  for (let j = 0; j < length; j += 3) {\n    const position = Cartesian3.unpack(positions, j, cartesian3Scratch0);\n    if (position.x > 0.0) {\n      continue;\n    }\n\n    const prevPosition = Cartesian3.unpack(\n      prevPositions,\n      j,\n      cartesian3Scratch2\n    );\n    if (\n      (position.y < 0.0 && prevPosition.y > 0.0) ||\n      (position.y > 0.0 && prevPosition.y < 0.0)\n    ) {\n      if (j - 3 > 0) {\n        prevPositions[j] = positions[j - 3];\n        prevPositions[j + 1] = positions[j - 2];\n        prevPositions[j + 2] = positions[j - 1];\n      } else {\n        Cartesian3.pack(position, prevPositions, j);\n      }\n    }\n\n    const nextPosition = Cartesian3.unpack(\n      nextPositions,\n      j,\n      cartesian3Scratch3\n    );\n    if (\n      (position.y < 0.0 && nextPosition.y > 0.0) ||\n      (position.y > 0.0 && nextPosition.y < 0.0)\n    ) {\n      if (j + 3 < length) {\n        nextPositions[j] = positions[j + 3];\n        nextPositions[j + 1] = positions[j + 4];\n        nextPositions[j + 2] = positions[j + 5];\n      } else {\n        Cartesian3.pack(position, nextPositions, j);\n      }\n    }\n  }\n}\n\nconst offsetScalar = 5.0 * CesiumMath.EPSILON9;\nconst coplanarOffset = CesiumMath.EPSILON6;\n\nfunction splitLongitudePolyline(instance) {\n  const geometry = instance.geometry;\n  const attributes = geometry.attributes;\n  const positions = attributes.position.values;\n  const prevPositions = attributes.prevPosition.values;\n  const nextPositions = attributes.nextPosition.values;\n  const expandAndWidths = attributes.expandAndWidth.values;\n\n  const texCoords = defined(attributes.st) ? attributes.st.values : undefined;\n  const colors = defined(attributes.color)\n    ? attributes.color.values\n    : undefined;\n\n  const eastGeometry = copyGeometryForSplit(geometry);\n  const westGeometry = copyGeometryForSplit(geometry);\n\n  let i;\n  let j;\n  let index;\n\n  let intersectionFound = false;\n\n  const length = positions.length / 3;\n  for (i = 0; i < length; i += 4) {\n    const i0 = i;\n    const i2 = i + 2;\n\n    const p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);\n    const p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);\n\n    // Offset points that are close to the 180 longitude and change the previous/next point\n    // to be the same offset point so it can be projected to 2D. There is special handling in the\n    // shader for when position == prevPosition || position == nextPosition.\n    if (Math.abs(p0.y) < coplanarOffset) {\n      p0.y = coplanarOffset * (p2.y < 0.0 ? -1.0 : 1.0);\n      positions[i * 3 + 1] = p0.y;\n      positions[(i + 1) * 3 + 1] = p0.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        prevPositions[j] = positions[i * 3];\n        prevPositions[j + 1] = positions[i * 3 + 1];\n        prevPositions[j + 2] = positions[i * 3 + 2];\n      }\n    }\n\n    // Do the same but for when the line crosses 180 longitude in the opposite direction.\n    if (Math.abs(p2.y) < coplanarOffset) {\n      p2.y = coplanarOffset * (p0.y < 0.0 ? -1.0 : 1.0);\n      positions[(i + 2) * 3 + 1] = p2.y;\n      positions[(i + 3) * 3 + 1] = p2.y;\n\n      for (j = i0 * 3; j < i0 * 3 + 4 * 3; j += 3) {\n        nextPositions[j] = positions[(i + 2) * 3];\n        nextPositions[j + 1] = positions[(i + 2) * 3 + 1];\n        nextPositions[j + 2] = positions[(i + 2) * 3 + 2];\n      }\n    }\n\n    let p0Attributes = eastGeometry.attributes;\n    let p0Indices = eastGeometry.indices;\n    let p2Attributes = westGeometry.attributes;\n    let p2Indices = westGeometry.indices;\n\n    const intersection = IntersectionTests.lineSegmentPlane(\n      p0,\n      p2,\n      xzPlane,\n      cartesian3Scratch4\n    );\n    if (defined(intersection)) {\n      intersectionFound = true;\n\n      // move point on the xz-plane slightly away from the plane\n      const offset = Cartesian3.multiplyByScalar(\n        Cartesian3.UNIT_Y,\n        offsetScalar,\n        cartesian3Scratch5\n      );\n      if (p0.y < 0.0) {\n        Cartesian3.negate(offset, offset);\n        p0Attributes = westGeometry.attributes;\n        p0Indices = westGeometry.indices;\n        p2Attributes = eastGeometry.attributes;\n        p2Indices = eastGeometry.indices;\n      }\n\n      const offsetPoint = Cartesian3.add(\n        intersection,\n        offset,\n        cartesian3Scratch6\n      );\n      p0Attributes.position.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3],\n        prevPositions[i0 * 3 + 1],\n        prevPositions[i0 * 3 + 2]\n      );\n      p0Attributes.prevPosition.values.push(\n        prevPositions[i0 * 3 + 3],\n        prevPositions[i0 * 3 + 4],\n        prevPositions[i0 * 3 + 5]\n      );\n      p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);\n\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p0Attributes.nextPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n\n      Cartesian3.negate(offset, offset);\n      Cartesian3.add(intersection, offset, offsetPoint);\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.position.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.position.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n      p2Attributes.prevPosition.values.push(\n        offsetPoint.x,\n        offsetPoint.y,\n        offsetPoint.z\n      );\n\n      p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3],\n        nextPositions[i2 * 3 + 1],\n        nextPositions[i2 * 3 + 2]\n      );\n      p2Attributes.nextPosition.values.push(\n        nextPositions[i2 * 3 + 3],\n        nextPositions[i2 * 3 + 4],\n        nextPositions[i2 * 3 + 5]\n      );\n\n      const ew0 = Cartesian2.fromArray(\n        expandAndWidths,\n        i0 * 2,\n        cartesian2Scratch0\n      );\n      const width = Math.abs(ew0.y);\n\n      p0Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n      p2Attributes.expandAndWidth.values.push(-1, width, 1, width);\n      p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);\n\n      let t = Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(intersection, p0, cartesian3Scratch3)\n      );\n      t /= Cartesian3.magnitudeSquared(\n        Cartesian3.subtract(p2, p0, cartesian3Scratch3)\n      );\n\n      if (defined(colors)) {\n        const c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);\n        const c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);\n\n        const r = CesiumMath.lerp(c0.x, c2.x, t);\n        const g = CesiumMath.lerp(c0.y, c2.y, t);\n        const b = CesiumMath.lerp(c0.z, c2.z, t);\n        const a = CesiumMath.lerp(c0.w, c2.w, t);\n\n        for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {\n          p0Attributes.color.values.push(colors[j]);\n        }\n        p0Attributes.color.values.push(r, g, b, a);\n        p0Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        p2Attributes.color.values.push(r, g, b, a);\n        for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {\n          p2Attributes.color.values.push(colors[j]);\n        }\n      }\n\n      if (defined(texCoords)) {\n        const s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);\n        const s3 = Cartesian2.fromArray(\n          texCoords,\n          (i + 3) * 2,\n          cartesian2Scratch1\n        );\n\n        const sx = CesiumMath.lerp(s0.x, s3.x, t);\n\n        for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {\n          p0Attributes.st.values.push(texCoords[j]);\n        }\n        p0Attributes.st.values.push(sx, s0.y);\n        p0Attributes.st.values.push(sx, s3.y);\n        p2Attributes.st.values.push(sx, s0.y);\n        p2Attributes.st.values.push(sx, s3.y);\n        for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {\n          p2Attributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      index = p0Attributes.position.values.length / 3 - 4;\n      p0Indices.push(index, index + 2, index + 1);\n      p0Indices.push(index + 1, index + 2, index + 3);\n\n      index = p2Attributes.position.values.length / 3 - 4;\n      p2Indices.push(index, index + 2, index + 1);\n      p2Indices.push(index + 1, index + 2, index + 3);\n    } else {\n      let currentAttributes;\n      let currentIndices;\n\n      if (p0.y < 0.0) {\n        currentAttributes = westGeometry.attributes;\n        currentIndices = westGeometry.indices;\n      } else {\n        currentAttributes = eastGeometry.attributes;\n        currentIndices = eastGeometry.indices;\n      }\n\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p0.x, p0.y, p0.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n      currentAttributes.position.values.push(p2.x, p2.y, p2.z);\n\n      for (j = i * 3; j < i * 3 + 4 * 3; ++j) {\n        currentAttributes.prevPosition.values.push(prevPositions[j]);\n        currentAttributes.nextPosition.values.push(nextPositions[j]);\n      }\n\n      for (j = i * 2; j < i * 2 + 4 * 2; ++j) {\n        currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);\n        if (defined(texCoords)) {\n          currentAttributes.st.values.push(texCoords[j]);\n        }\n      }\n\n      if (defined(colors)) {\n        for (j = i * 4; j < i * 4 + 4 * 4; ++j) {\n          currentAttributes.color.values.push(colors[j]);\n        }\n      }\n\n      index = currentAttributes.position.values.length / 3 - 4;\n      currentIndices.push(index, index + 2, index + 1);\n      currentIndices.push(index + 1, index + 2, index + 3);\n    }\n  }\n\n  if (intersectionFound) {\n    updateAdjacencyAfterSplit(westGeometry);\n    updateAdjacencyAfterSplit(eastGeometry);\n  }\n\n  updateInstanceAfterSplit(instance, westGeometry, eastGeometry);\n}\n\n/**\n * Splits the instances's geometry, by introducing new vertices and indices,that\n * intersect the International Date Line and Prime Meridian so that no primitives cross longitude\n * -180/180 degrees.  This is not required for 3D drawing, but is required for\n * correcting drawing in 2D and Columbus view.\n *\n * @private\n *\n * @param {GeometryInstance} instance The instance to modify.\n * @returns {GeometryInstance} The modified <code>instance</code> argument, with it's geometry split at the International Date Line.\n *\n * @example\n * instance = Cesium.GeometryPipeline.splitLongitude(instance);\n */\nGeometryPipeline.splitLongitude = function (instance) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(instance)) {\n    throw new DeveloperError(\"instance is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const geometry = instance.geometry;\n  const boundingSphere = geometry.boundingSphere;\n  if (defined(boundingSphere)) {\n    const minX = boundingSphere.center.x - boundingSphere.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(boundingSphere, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      return instance;\n    }\n  }\n\n  if (geometry.geometryType !== GeometryType.NONE) {\n    switch (geometry.geometryType) {\n      case GeometryType.POLYLINES:\n        splitLongitudePolyline(instance);\n        break;\n      case GeometryType.TRIANGLES:\n        splitLongitudeTriangles(instance);\n        break;\n      case GeometryType.LINES:\n        splitLongitudeLines(instance);\n        break;\n    }\n  } else {\n    indexPrimitive(geometry);\n    if (geometry.primitiveType === PrimitiveType.TRIANGLES) {\n      splitLongitudeTriangles(instance);\n    } else if (geometry.primitiveType === PrimitiveType.LINES) {\n      splitLongitudeLines(instance);\n    }\n  }\n\n  return instance;\n};\nexport default GeometryPipeline;\n","/**\n * @private\n */\nconst GeometryType = {\n  NONE: 0,\n  TRIANGLES: 1,\n  LINES: 2,\n  POLYLINES: 3,\n};\nexport default Object.freeze(GeometryType);\n"],"names":["Object","freeze","ROUNDED","MITERED","BEVELED","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","scratch1","scratch2","scaleToSurface","positions","ellipsoid","i","length","scaleToGeodeticSurface","addNormals","attr","normal","left","front","back","vertexFormat","normals","tangents","bitangents","forward","tangent","bitangent","combine","computedPositions","corners","endPositions","computedLefts","lefts","computedNormals","attributes","corner","leftCount","rightCount","indicesLength","leftSide","leftPositions","rightPositions","addEndPositions","endPositionLength","size","finalPositions","Float64Array","Float32Array","undefined","UL","LL","UR","LR","rightPos","leftPos","halfLength","indices","index","firstEndPositions","rightNormal","leftNormal","posIndex","compIndex","rightEdge","leftEdge","set","geodeticSurfaceNormal","j","l","r","pivot","start","outsidePoint","previousPoint","nextPoint","splice","lastEndPositions","position","componentDatatype","componentsPerAttribute","values","st","rightSt","leftSt","stIndex","theta","Math","PI","a","halfEndPos","cos","sin","addWallPositions","wallPositions","x","y","z","computePositionsExtruded","params","topVertexFormat","shadowVolume","height","extrudedHeight","newPositions","extrudedPositions","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","previousPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","t","extrudedAttributes","extrudeNormals","extrudeDirection","offsetAttribute","applyOffset","Uint8Array","applyOffsetValue","iLength","newIndices","v0","v1","v2","scratchCartesian1","scratchCartesian2","scratchCartographic","computeOffsetPoints","position1","position2","halfWidth","min","max","direction","offsetDirection","minLat","latitude","minLon","longitude","maxLat","maxLon","cartesianToCartographic","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","computeRectangle","width","cornerType","result","cleanPositions","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","first","last","rectangle","north","south","east","west","CorridorGeometry","options","this","_positions","_ellipsoid","_vertexFormat","_width","_height","_extrudedHeight","_cornerType","_granularity","granularity","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","value","array","startingIndex","scratchEllipsoid","scratchVertexFormat","scratchOptions","unpack","Array","createGeometry","corridorGeometry","extrude","saveAttributes","boundingSphere","primitiveType","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","defineProperties","prototype","get","textureCoordinateRotationPoints","CorridorGeometryLibrary","scratch3","scratch4","scaleArray2","cartesian7","cartesian8","cartesian9","cartesian10","quaterion","rotMatrix","computeRoundCorner","cornerPoint","startPoint","endPoint","leftIsOutside","angle","ceil","m","computeMiteredCorner","leftCornerDirection","lastPoint","addShiftedPositions","scalar","calculatedPositions","scaledLeft","scaledRight","rightIndex","leftIndex","pos","push","addAttribute","attribute","scratchForwardProjection","scratchBackwardProjection","computePositions","backward","cornerDirection","previousPos","center","calculatedLefts","calculatedNormals","subdividedPositions","nextPosition","forwardProjection","backwardProjection","abs","firstEndCap","addEndCaps","wallIndices","floor","CorridorOutlineGeometry","corridorOutlineGeometry","offsetValue","nextCreditId","creditToId","Credit","html","showOnScreen","id","key","_id","_html","_showOnScreen","_element","element","div","document","createElement","_creditId","style","display","innerHTML","links","querySelectorAll","setAttribute","equals","right","credit","getIonCredit","attribution","collapsible","_isIon","indexOf","clone","CubicRealPolynomial","computeRealRoots","b","c","d","A","B","C","D","AC","BD","B2","C2","delta1","delta2","delta3","discriminant","temp","temp1","ABar","CBar","DBar","temp0","sqrt","p","pow","q","CBarA","DBarA","CBarD","DBarD","squareRootOfDiscriminant","halfSquareRootOf3","atan2","cosine","temp3","numeratorLarge","denominatorLarge","root1","numeratorSmall","denominatorSmall","root3","F","root2","computeDiscriminant","b2","c2","roots","ratio","root","Length","CullingVolume","planes","faces","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","fromBoundingSphere","radius","planeIndex","faceNormal","plane0","plane1","w","computeVisibility","boundingVolume","intersecting","k","len","intersectPlane","computeVisibilityWithPlaneMask","parentPlaneMask","MASK_OUTSIDE","MASK_INSIDE","mask","flag","MASK_INDETERMINATE","CustomHeightmapTerrainProvider","callback","_callback","_tilingScheme","tilingScheme","maxTileDimensions","_levelZeroMaximumGeometricError","getNumberOfXTilesAtLevel","_errorEvent","_credit","_readyPromise","Promise","resolve","errorEvent","ready","readyPromise","hasWaterMask","hasVertexNormals","requestTileGeometry","level","request","promise","then","heightmapData","buffer","isArray","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability","radiusScratch","normalScratch","bitangentScratch","tangentScratch","positionScratch","CylinderGeometry","topRadius","bottomRadius","slices","_length","_topRadius","_bottomRadius","_slices","unitCylinderGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","normalScale","numIndices","textureCoordIndex","rad","getUnitCylinder","CylinderGeometryLibrary","fill","topZ","bottomZ","twoSlice","tbIndex","bottomOffset","topOffset","bottomX","bottomY","topX","topY","CylinderOutlineGeometry","numberOfVerticalLines","_numberOfVerticalLines","numSide","numSideLines","round","DefaultProxy","proxy","getURL","resource","prefix","encodeURIComponent","DeveloperError","message","stack","name","Error","e","create","constructor","toString","str","throwInstantiationError","DistanceDisplayCondition","near","far","_near","MAX_VALUE","_far","other","DistanceDisplayConditionGeometryInstanceAttribute","normalize","fromDistanceDisplayCondition","distanceDisplayCondition","toValue","DoubleEndedPriorityQueue","comparator","maximumLength","_comparator","_maximumLength","_array","swap","that","indexA","indexB","lessThan","greaterThan","pushUp","onMinLevel","parentIndex","lessThanParent","grandparentIndex","pushDown","leftChildIndex","target","rightChildIndex","grandChildStart","grandChildCount","grandChildIndex","parentOfGrandchildIndex","removeMinimum","internalArray","reset","resort","insert","removedElement","minimumElement","removeMaximum","maximumElement","maximumElementIndex","getMinimum","getMaximum","DoublyLinkedList","head","tail","DoublyLinkedListNode","item","previous","next","remove","list","node","add","nextNode","oldNodeNext","EarthOrientationParameters","_dates","_samples","_dateColumn","_xPoleWanderRadiansColumn","_yPoleWanderRadiansColumn","_ut1MinusUtcSecondsColumn","_xCelestialPoleOffsetRadiansColumn","_yCelestialPoleOffsetRadiansColumn","_taiMinusUtcSecondsColumn","_columnCount","_lastIndex","_downloadPromise","_dataError","_addNewLeapSeconds","addNewLeapSeconds","data","onDataReady","url","fetchJson","eopData","catch","columnNames","samples","compareLeapSecondDates","leapSecond","dateToFind","julianDate","eop","dateColumn","xPoleWanderRadiansColumn","yPoleWanderRadiansColumn","ut1MinusUtcSecondsColumn","xCelestialPoleOffsetRadiansColumn","yCelestialPoleOffsetRadiansColumn","taiMinusUtcSecondsColumn","dates","lastTaiMinusUtc","mjd","taiMinusUtc","day","date","leapSeconds","leapSecondIndex","fillResultFromIndex","columnCount","xPoleWander","yPoleWander","xPoleOffset","yPoleOffset","ut1MinusUtc","linearInterp","dx","y1","y2","interpolate","before","after","beforeDate","afterDate","factor","startBefore","startAfter","beforeUt1MinusUtc","afterUt1MinusUtc","offsetDifference","beforeTaiMinusUtc","afterTaiMinusUtc","NONE","getPromiseToLoad","compute","lastIndex","previousIndexDate","nextIndexDate","isAfterPrevious","isAfterLastSample","isBeforeNext","EasingFunction","LINEAR_NONE","QUADRATIC_IN","QUADRATIC_OUT","QUADRATIC_IN_OUT","CUBIC_IN","CUBIC_OUT","CUBIC_IN_OUT","QUARTIC_IN","QUARTIC_OUT","QUARTIC_IN_OUT","QUINTIC_IN","QUINTIC_OUT","QUINTIC_IN_OUT","SINUSOIDAL_IN","SINUSOIDAL_OUT","SINUSOIDAL_IN_OUT","EXPONENTIAL_IN","EXPONENTIAL_OUT","EXPONENTIAL_IN_OUT","CIRCULAR_IN","CIRCULAR_OUT","CIRCULAR_IN_OUT","ELASTIC_IN","ELASTIC_OUT","ELASTIC_IN_OUT","BACK_IN","BACK_OUT","BACK_IN_OUT","BOUNCE_IN","BOUNCE_OUT","BOUNCE_IN_OUT","scratchCartesian3","scratchCartesian4","texCoordScratch","textureMatrixScratch","tangentMatrixScratch","quaternionScratch","scratchNormal","scratchTangent","scratchBitangent","projectedCenterScratch","scratchMinTexCoord","scratchMaxTexCoord","computeTopBottomAttributes","semiMajorAxis","semiMinorAxis","stRotation","textureCoordinates","projection","projectedCenter","project","geodeticNormal","textureMatrix","tangentMatrix","rotation","minTexCoord","maxTexCoord","stOffset","i1","i2","rotatedPoint","projectedPoint","topIndices","numPts","prevIndex","numInterior","positionIndex","indicesIndex","boundingSphereCenter","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","scaledNormal","cep","outerPositions","topBottomAttributes","posLength","topBottomIndices","topBottomGeo","wallAttributes","extrudedPosition","bottom","computeWallAttributes","computeWallIndices","wallGeo","geo","geometry","positionsFlat","positionsCount","EllipseGeometry","_center","_semiMajorAxis","_semiMinorAxis","_rotation","_stRotation","_textureCoordinateRotationPoints","scratchCenter","ellipseGeometry","computeEllipse","boundingRectangle","EllipseGeometryLibrary","rotAxis","tempVec","unitQuat","rotMtx","pointOnEllipsoid","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","azimuth","cosThetaSquared","sinThetaSquared","raisePositionsToHeight","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","deltaTheta","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","interiorPosition","EllipseOutlineGeometry","maxI","initialize","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","_maximumRadius","_centerToleranceSquared","_squaredXOverSquaredZ","Ellipsoid","radii","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","maximumRadius","fromCartesian3","cartesian","WGS84","UNIT_SPHERE","MOON","geocentricSurfaceNormal","geodeticSurfaceNormalCartographic","cartographic","cosLatitude","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","n","gamma","cartographicArrayToCartesianArray","cartographics","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","h","asin","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","positionX","positionY","positionZ","beta","transformPositionToScaledSpace","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","squaredXOverSquaredZ","abscissas","weights","gaussLegendreQuadrature","func","xMean","xRange","sum","surfaceArea","minLongitude","maxLongitude","minLatitude","maxLatitude","a2","a2b2","sinPhi","cosPhi","cosTheta","sinTheta","computeDeltaLambda","f","sineAlpha","cosineSquaredAlpha","sigma","sineSigma","cosineSigma","cosineTwiceSigmaMidpoint","computeC","scratchCart1","scratchCart2","computeProperties","ellipsoidGeodesic","end","firstCartesian","lastCartesian","major","minor","firstLongitude","firstLatitude","secondLongitude","secondLatitude","eff","u1","atan","tan","u2","cosineU1","sineU1","cosineU2","sineU2","cc","cs","ss","sc","lambda","lambdaDot","cosineLambda","sineLambda","isFinite","uSquared","cosineSquaredTwiceSigmaMidpoint","distance","startHeading","endHeading","_distance","_startHeading","_endHeading","_uSquared","vincentyInverseFormula","_start","_end","cosineHeading","sineHeading","tanU","cosineU","sineU","sineSquaredAlpha","cosineAlpha","u2Over4","u4Over16","u6Over64","u8Over256","a0","a1","a3","distanceRatio","constants","_constants","setConstants","EllipsoidGeodesic","surfaceDistance","setEndPoints","interpolateUsingFraction","fraction","interpolateUsingSurfaceDistance","cosine2S","cosine4S","cosine6S","sine2S","sine4S","sine6S","sine8S","s2","s3","scratchPosition","scratchNormalST","defaultRadii","EllipsoidGeometry","innerRadii","minimumClock","maximumClock","minimumCone","maximumCone","stackPartitions","slicePartitions","_innerRadii","_minimumClock","_maximumClock","_minimumCone","_maximumCone","_stackPartitions","_slicePartitions","scratchRadii","scratchInnerRadii","unitEllipsoidGeometry","ellipsoidGeometry","phis","thetas","numPhis","numThetas","extraIndices","vertexMultiplier","hasInnerSurface","isTopOpen","isBotOpen","isClockOpen","vertexCount","isInner","negateNormal","indexCount","outerOffset","innerOffset","vertexIndex","offset","vertexCountHalf","ellipsoidOuter","ellipsoidInner","normalST","unit","tangetOffset","getUnitEllipsoid","EllipsoidOutlineGeometry","subdivisions","_subdivisions","phi","calculateM","ellipticity","e2","e4","e6","e8","e10","e12","calculateSigma","log","eSinL","ellipsoidRhumbLine","majorSquared","minorSquared","_ellipticitySquared","_ellipticity","_heading","sigma1","sigma2","calculateHeading","heading","deltaLongitude","M1","calculateArcLength","ellipticitySquared","M","d2","d3","d4","sin2D","cos2D","sin4D","cos4D","sin6D","cos6D","sin8D","cos8D","sin10D","calculateInverseM","localRad","EllipsoidRhumbLine","fromStartHeadingDistance","findIntersectionWithLongitude","intersectionLongitude","absHeading","phi1","eSinPhi1","leftComponent","exp","denominator","newPhi","eSinPhi","numerator","findIntersectionWithLatitude","intersectionLatitude","scratchCart4","EllipsoidTangentPlane","origin","eastNorthUp","_origin","_xAxis","_yAxis","_plane","plane","xAxis","yAxis","zAxis","tmp","fromPoints","scratchProjectPointOntoPlaneRay","scratchProjectPointOntoPlaneCartesian3","projectPointOntoPlane","ray","intersectionPoint","v","projectPointsOntoPlane","count","projectPointToNearestOnPlane","projectPointsToNearestOnPlane","projectPointsOntoEllipsoidScratch","projectPointOntoEllipsoid","projectPointsOntoEllipsoid","EllipsoidTerrainProvider","availability","EllipsoidalOccluder","cameraPosition","_cameraPosition","_cameraPositionInScaledSpace","_distanceToLimbInScaledSpaceSquared","cv","vhMagnitudeSquared","scratchCartesian","isPointVisible","occludee","isScaledSpacePointVisible","occludeeScaledSpacePosition","scratchCameraPositionInScaledSpaceShrunk","isScaledSpacePointVisiblePossiblyUnderEllipsoid","minimumHeight","computeHorizonCullingPoint","directionToPoint","computeHorizonCullingPointFromPositions","scratchEllipsoidShrunk","computeHorizonCullingPointPossiblyUnderEllipsoid","getPossiblyShrunkEllipsoid","computeHorizonCullingPointFromVertices","vertices","stride","computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid","subsampleScratch","computeHorizonCullingPointFromRectangle","bs","scratchEllipsoidShrunkRadii","ellipsoidShrunkRadii","scaledSpaceDirectionToPoint","computeScaledSpaceDirectionToPoint","resultMagnitude","candidateMagnitude","computeMagnitude","magnitudeToPoint","cameraPositionInScaledSpace","distanceToLimbInScaledSpaceSquared","vt","vtDotVc","scaledSpaceScratch","directionScratch","scaledSpacePosition","magnitudeSquared","magnitude","cosBeta","directionToPointScratch","EncodedCartesian3","high","low","encode","doubleHigh","scratchEncode","fromCartesian","encodedP","writeElements","cartesianArray","Event","_listeners","_scopes","_toRemove","_insideRaiseEvent","compareNumber","numberOfListeners","addEventListener","listener","scope","event","removeEventListener","listeners","scopes","raiseEvent","apply","arguments","toRemove","sort","EventHelper","_removalFunctions","removalFunction","removalFunctions","removeAll","enableModelExperimental","HOLD","EXTRAPOLATE","theNavigator","isChromeResult","chromeVersionResult","isSafariResult","safariVersionResult","isWebkitResult","webkitVersionResult","isInternetExplorerResult","internetExplorerVersionResult","isEdgeResult","edgeVersionResult","isFirefoxResult","firefoxVersionResult","isWindowsResult","isIPadOrIOSResult","hasPointerEvents","imageRenderingValueResult","supportsImageRenderingPixelatedResult","extractVersion","versionString","parts","split","parseInt","isChrome","isEdge","fields","exec","userAgent","isSafari","test","isWebkit","isNightly","isInternetExplorer","appName","isFirefox","supportsImageRenderingPixelated","canvas","imageRendering","supportsWebP","initialized","_result","navigator","_promise","supportsWebPDeferred","image","Image","onload","onerror","src","typedArrayTypes","ArrayBuffer","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Uint8ClampedArray","BigInt64Array","BigUint64Array","FeatureDetection","chromeVersion","safariVersion","webkitVersion","internetExplorerVersion","edgeVersion","firefoxVersion","isWindows","appVersion","isIPadOrIOS","platform","hardwareConcurrency","supportsPointerEvents","PointerEvent","pointerEnabled","imageRenderingValue","scene","supportsWebAssembly","context","supportsBasis","BigInt","Worker","WebAssembly","FrustumGeometry","frustum","orientation","drawNearPlane","_drawNearPlane","frustumType","frustumPackedLength","_frustumType","_frustum","_orientation","scratchPackPerspective","scratchPackOrthographic","scratchPackQuaternion","scratchPackorigin","getAttributes","frustumResult","scratchRotationMatrix","scratchViewMatrix","scratchInverseMatrix","scratchXDirection","scratchYDirection","scratchZDirection","scratchNegativeX","scratchNegativeY","scratchNegativeZ","frustumSplits","frustumCornersNDC","scratchFrustumCorners","_computeNearFarPlanes","xDirection","yDirection","zDirection","rotationMatrix","view","inverseView","inverseViewProjection","projectionMatrix","viewProjection","fac","_offCenterFrustum","top","frustumGeometry","numberOfPlanes","subarray","negativeX","negativeY","negativeZ","indexOffset","FrustumOutlineGeometry","_supportsFullscreen","_names","requestFullscreen","exitFullscreen","fullscreenEnabled","fullscreenElement","fullscreenchange","fullscreenerror","Fullscreen","supportsFullscreen","changeEventName","errorEventName","enabled","fullscreen","body","prefixes","vrDevice","vrDisplay","SEARCH","AUTOCOMPLETE","GeocoderService","geocode","GeographicProjection","_semimajorAxis","_oneOverSemimajorAxis","semimajorAxis","unproject","oneOverEarthSemimajorAxis","GeographicTilingScheme","_projection","_numberOfLevelZeroTilesX","numberOfLevelZeroTilesX","_numberOfLevelZeroTilesY","numberOfLevelZeroTilesY","getNumberOfYTilesAtLevel","rectangleToNativeRectangle","tileXYToNativeRectangle","rectangleRadians","tileXYToRectangle","xTiles","yTiles","xTileWidth","yTileHeight","positionToTileXY","xTileCoordinate","yTileCoordinate","Geometry","geometryType","boundingSphereCV","computeNumberOfVertices","numberOfVertices","property","hasOwnProperty","num","rectangleCenterScratch","enuCenterScratch","fixedFrameToEnuScratch","boundingRectanglePointsCartographicScratch","boundingRectanglePointsEnuScratch","points2DScratch","pointEnuScratch","enuRotationScratch","enuRotationMatrixScratch","rotation2DScratch","rectangleCenter","enuCenter","enuToFixedFrame","fixedFrameToEnu","boundingPointsEnu","boundingPointsCarto","posEnu","positionsLength","enuMinX","enuMinY","enuMaxX","enuMaxY","toDesiredInComputed","points2D","boundingEnuMin","boundingPointsWidth","boundingPointsHeight","point2D","minXYCorner","maxYCorner","maxXCorner","color","GeometryFactory","geometryFactory","modelMatrix","pickPrimitive","westHemisphereGeometry","eastHemisphereGeometry","TOP","ALL","GeometryPipeline","addTriangle","lines","i0","copyAttributesDescriptions","newAttributes","copyVertex","destinationAttributes","sourceAttributes","toWireframe","triangles","trianglesToLines","triangleStripToLines","base","triangleFanToLines","createLineSegmentsForVectors","attributeName","vectors","newBoundingSphere","createAttributeLocations","semantics","semantic","reorderForPreVertexCache","indexCrossReferenceOldToNew","indicesIn","indicesOut","tempIndex","intoIndicesIn","intoIndicesOut","nextIndex","elementsIn","intoElementsIn","numComponents","elementsOut","reorderForPostVertexCache","cacheCapacity","maximumIndex","cacheSize","fitToUnsignedShortIndices","geometries","oldToNewIndex","currentIndex","originalIndices","numberOfIndices","indicesPerPrimitive","scratchProjectTo2DCartesian3","scratchProjectTo2DCartographic","projectTo2D","attributeName3D","attributeName2D","values3D","projectedValues","lonLat","projectedLonLat","encodedResult","encodeAttribute","attributeHighName","attributeLowName","highValues","lowValues","transformPoint","matrix","transformVector","inverseTranspose","normalMatrix","transformToWorldCoordinates","instance","prevPosition","tempScratch","combineGeometries","instances","propertyName","haveIndices","attributesInAllGeometries","attributes0","numberOfComponents","inAllGeometries","otherAttribute","findAttributesInAllGeometries","sourceValues","sourceValuesLength","destIndices","destOffset","sourceIndices","sourceIndicesLen","tempRadius","combineInstances","instanceGeometry","instanceSplitGeometry","normalsPerVertex","normalsPerTriangle","normalIndices","currentCount","i03","i13","i23","vertexNormalData","normalValues","i3","tScratch","computeTangentAndBitangent","tan1","i02","i12","i22","ux","uy","uz","wx","wy","t1","t2","sdirx","sdiry","sdirz","tangentValues","bitangentValues","toEncode1","toEncode2","toEncode3","encodeResult2","indexPrimitive","indexTriangleFan","indexTriangleStrip","indexTriangles","indexLineStrip","indexLineLoop","indexLines","offsetPointFromXZPlane","isBehind","compressVertices","extrudeAttribute","extrudeDirections","compressedDirections","compressedAttributes","normalAttribute","stAttribute","hasNormal","hasSt","tangentAttribute","bitangentAttribute","hasTangent","hasBitangent","compressedLength","numCompressedComponents","c3","getXZIntersectionOffsetPoints","p1","q1","q2","splitTriangleResult","splitTriangle","p0","p2","p0y","p1y","p2y","sign","offsetTriangleFromXZPlane","p0Behind","p1Behind","p2Behind","numBehind","updateGeometryAfterSplit","computeBoundingSphere","copyGeometryForSplit","copiedAttributes","updateInstanceAfterSplit","westGeometry","eastGeometry","generateBarycentricInterpolateFunction","CartesianType","v0Scratch","v1Scratch","v2Scratch","coords","currentValues","insertedIndex","fromArray","multiplyByScalar","interpolateAndPackCartesian4","interpolateAndPackCartesian3","interpolateAndPackCartesian2","p0Scratch","p1Scratch","p2Scratch","barycentricScratch","computeTriangleAttributes","point","texCoords","currentAttributes","customAttributeNames","customAttributesLength","allAttributes","d0","d1","v3","interpolateAndPackBoolean","genericInterpolate","sourceAttribute","currentAttribute","insertSplitPoint","currentIndices","currentIndexMap","insertIndex","newIndex","NAMED_ATTRIBUTES","splitLongitudeTriangles","westGeometryIndexMap","eastGeometryIndexMap","resultPositions","resultIndices","resultLength","resultIndex","xzPlane","offsetScratch","offsetPointScratch","computeLineAttributes","splitLongitudeLines","p0Attributes","p0Indices","p0IndexMap","p1Attributes","p1Indices","p1IndexMap","intersection","offsetPoint","cartesian2Scratch0","cartesian2Scratch1","cartesian3Scratch0","cartesian3Scratch2","cartesian3Scratch3","cartesian3Scratch4","cartesian3Scratch5","cartesian3Scratch6","cartesian4Scratch0","updateAdjacencyAfterSplit","prevPositions","nextPositions","offsetScalar","coplanarOffset","splitLongitude","expandAndWidths","expandAndWidth","colors","intersectionFound","p2Attributes","p2Indices","ew0","c0","g","s0","sx","splitLongitudePolyline","TRIANGLES","LINES","POLYLINES"],"sourceRoot":""}