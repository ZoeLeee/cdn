{"version":3,"file":"js/vender~d62e52c5.60909bcf.js","mappings":"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","sources":["webpack:///../../../node_modules/cesium/Source/Scene/JsonMetadataTable.js","webpack:///../../../node_modules/cesium/Source/Scene/Label.js","webpack:///../../../node_modules/cesium/Source/Scene/LabelCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/LabelStyle.js","webpack:///../../../node_modules/cesium/Source/Scene/Light.js","webpack:///../../../node_modules/cesium/Source/Scene/MapMode2D.js","webpack:///../../../node_modules/cesium/Source/Scene/MapboxImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/MapboxStyleImageryProvider.js","webpack:///../../../node_modules/cesium/Source/Scene/Material.js","webpack:///../../../node_modules/cesium/Source/Scene/MaterialAppearance.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataClass.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataClassProperty.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataComponentType.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataEntity.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataEnum.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataEnumValue.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataSchema.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataSchemaLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataSemantic.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataTable.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataTableProperty.js","webpack:///../../../node_modules/cesium/Source/Scene/MetadataType.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelAnimation.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelAnimationCache.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelAnimationCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelAnimationLoop.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelAnimationState.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelComponents.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/AlphaPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/B3dmLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/BatchTexturePipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/CPUStylingPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/CustomShader.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/CustomShaderMode.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/CustomShaderPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/DequantizationPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/FeatureIdPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/GeoJsonLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/GeometryPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/I3dmLoader.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ImageBasedLightingPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/InstancingPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/LightingModel.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/LightingPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/MaterialPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/MetadataPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelAlphaOptions.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelClippingPlanesPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelColorPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimental.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimental3DTileContent.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalAnimation.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalAnimationChannel.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalAnimationCollection.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalDrawCommand.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalNode.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalPrimitive.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalSceneGraph.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalSkin.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalType.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelExperimentalUtility.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelFeature.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelFeatureTable.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelLightingOptions.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelMatrixUpdateStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelRenderResources.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/ModelSplitterPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/MorphTargetsPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/NodeRenderResources.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/PickingPipelineStage.js","webpack:///../../../node_modules/cesium/Source/Scene/ModelExperimental/PntsLoader.js"],"sourcesContent":["import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport MetadataEntity from \"./MetadataEntity.js\";\n\n/**\n * A table for storing free-form JSON metadata, as in the 3D Tiles batch table.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.count The number of entities in the table.\n * @param {Object.<String, Array>} options.properties The JSON representation of the metadata table. All the arrays must have exactly options.count elements.\n *\n * @alias JsonMetadataTable\n * @constructor\n * @private\n */\n\n// An empty class is used because JsonMetadataTable is an older type of metadata table\n// that does not have a class definition.\nconst emptyClass = {};\n\nexport default function JsonMetadataTable(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"options.count\", options.count, 0);\n  Check.typeOf.object(\"options.properties\", options.properties);\n  //>>includeEnd('debug');\n\n  this._count = options.count;\n  this._properties = clone(options.properties, true);\n}\n\n/**\n * Returns whether the table has this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the table has this property.\n * @private\n */\nJsonMetadataTable.prototype.hasProperty = function (propertyId) {\n  return MetadataEntity.hasProperty(propertyId, this._properties, emptyClass);\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nJsonMetadataTable.prototype.getPropertyIds = function (results) {\n  return MetadataEntity.getPropertyIds(this._properties, emptyClass, results);\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n *\n * @param {Number} index The index of the entity.\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @exception {DeveloperError} index is out of bounds\n * @private\n */\nJsonMetadataTable.prototype.getProperty = function (index, propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.string(\"propertyId\", propertyId);\n\n  if (index < 0 || index >= this._count) {\n    throw new DeveloperError(`index must be in the range [0, ${this._count})`);\n  }\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n  if (defined(property)) {\n    return clone(property[index], true);\n  }\n\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given ID.\n *\n * @param {Number} index The index of the entity.\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} index is out of bounds\n * @private\n */\nJsonMetadataTable.prototype.setProperty = function (index, propertyId, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  Check.typeOf.string(\"propertyId\", propertyId);\n\n  if (index < 0 || index >= this._count) {\n    throw new DeveloperError(`index must be in the range [0, ${this._count})`);\n  }\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n  if (defined(property)) {\n    property[index] = clone(value, true);\n    return true;\n  }\n\n  return false;\n};\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Billboard from \"./Billboard.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\n\nconst fontInfoCache = {};\nlet fontInfoCacheLength = 0;\nconst fontInfoCacheMaxSize = 256;\nconst defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\nconst defaultBackgroundPadding = new Cartesian2(7, 5);\n\nconst textTypes = Object.freeze({\n  LTR: 0,\n  RTL: 1,\n  WEAK: 2,\n  BRACKETS: 3,\n});\n\nfunction rebindAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n  label._rebindAllGlyphs = true;\n}\n\nfunction repositionAllGlyphs(label) {\n  if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {\n    // only push label if it's not already been marked dirty\n    label._labelCollection._labelsToUpdate.push(label);\n  }\n  label._repositionAllGlyphs = true;\n}\n\nfunction getCSSValue(element, property) {\n  return document.defaultView\n    .getComputedStyle(element, null)\n    .getPropertyValue(property);\n}\n\nfunction parseFont(label) {\n  let fontInfo = fontInfoCache[label._font];\n  if (!defined(fontInfo)) {\n    const div = document.createElement(\"div\");\n    div.style.position = \"absolute\";\n    div.style.opacity = 0;\n    div.style.font = label._font;\n    document.body.appendChild(div);\n\n    let lineHeight = parseFloat(getCSSValue(div, \"line-height\"));\n    if (isNaN(lineHeight)) {\n      // line-height isn't a number, i.e. 'normal'; apply default line-spacing\n      lineHeight = undefined;\n    }\n\n    fontInfo = {\n      family: getCSSValue(div, \"font-family\"),\n      size: getCSSValue(div, \"font-size\").replace(\"px\", \"\"),\n      style: getCSSValue(div, \"font-style\"),\n      weight: getCSSValue(div, \"font-weight\"),\n      lineHeight: lineHeight,\n    };\n\n    document.body.removeChild(div);\n    if (fontInfoCacheLength < fontInfoCacheMaxSize) {\n      fontInfoCache[label._font] = fontInfo;\n      fontInfoCacheLength++;\n    }\n  }\n  label._fontFamily = fontInfo.family;\n  label._fontSize = fontInfo.size;\n  label._fontStyle = fontInfo.style;\n  label._fontWeight = fontInfo.weight;\n  label._lineHeight = fontInfo.lineHeight;\n}\n\n/**\n * A Label draws viewport-aligned text positioned in the 3D scene.  This constructor\n * should not be used directly, instead create labels by calling {@link LabelCollection#add}.\n *\n * @alias Label\n * @internalConstructor\n * @class\n *\n * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near\n * @exception {DeveloperError} pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near\n * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n *\n * @see LabelCollection\n * @see LabelCollection#add\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n */\nfunction Label(options, labelCollection) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(options.disableDepthTestDistance) &&\n    options.disableDepthTestDistance < 0.0\n  ) {\n    throw new DeveloperError(\n      \"disableDepthTestDistance must be greater than 0.0.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  let translucencyByDistance = options.translucencyByDistance;\n  let pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;\n  let scaleByDistance = options.scaleByDistance;\n  let distanceDisplayCondition = options.distanceDisplayCondition;\n  if (defined(translucencyByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (translucencyByDistance.far <= translucencyByDistance.near) {\n      throw new DeveloperError(\n        \"translucencyByDistance.far must be greater than translucencyByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    translucencyByDistance = NearFarScalar.clone(translucencyByDistance);\n  }\n  if (defined(pixelOffsetScaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (pixelOffsetScaleByDistance.far <= pixelOffsetScaleByDistance.near) {\n      throw new DeveloperError(\n        \"pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    pixelOffsetScaleByDistance = NearFarScalar.clone(\n      pixelOffsetScaleByDistance\n    );\n  }\n  if (defined(scaleByDistance)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (scaleByDistance.far <= scaleByDistance.near) {\n      throw new DeveloperError(\n        \"scaleByDistance.far must be greater than scaleByDistance.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    scaleByDistance = NearFarScalar.clone(scaleByDistance);\n  }\n  if (defined(distanceDisplayCondition)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (distanceDisplayCondition.far <= distanceDisplayCondition.near) {\n      throw new DeveloperError(\n        \"distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.\"\n      );\n    }\n    //>>includeEnd('debug');\n    distanceDisplayCondition = DistanceDisplayCondition.clone(\n      distanceDisplayCondition\n    );\n  }\n\n  this._renderedText = undefined;\n  this._text = undefined;\n  this._show = defaultValue(options.show, true);\n  this._font = defaultValue(options.font, \"30px sans-serif\");\n  this._fillColor = Color.clone(defaultValue(options.fillColor, Color.WHITE));\n  this._outlineColor = Color.clone(\n    defaultValue(options.outlineColor, Color.BLACK)\n  );\n  this._outlineWidth = defaultValue(options.outlineWidth, 1.0);\n  this._showBackground = defaultValue(options.showBackground, false);\n  this._backgroundColor = Color.clone(\n    defaultValue(options.backgroundColor, defaultBackgroundColor)\n  );\n  this._backgroundPadding = Cartesian2.clone(\n    defaultValue(options.backgroundPadding, defaultBackgroundPadding)\n  );\n  this._style = defaultValue(options.style, LabelStyle.FILL);\n  this._verticalOrigin = defaultValue(\n    options.verticalOrigin,\n    VerticalOrigin.BASELINE\n  );\n  this._horizontalOrigin = defaultValue(\n    options.horizontalOrigin,\n    HorizontalOrigin.LEFT\n  );\n  this._pixelOffset = Cartesian2.clone(\n    defaultValue(options.pixelOffset, Cartesian2.ZERO)\n  );\n  this._eyeOffset = Cartesian3.clone(\n    defaultValue(options.eyeOffset, Cartesian3.ZERO)\n  );\n  this._position = Cartesian3.clone(\n    defaultValue(options.position, Cartesian3.ZERO)\n  );\n  this._scale = defaultValue(options.scale, 1.0);\n  this._id = options.id;\n  this._translucencyByDistance = translucencyByDistance;\n  this._pixelOffsetScaleByDistance = pixelOffsetScaleByDistance;\n  this._scaleByDistance = scaleByDistance;\n  this._heightReference = defaultValue(\n    options.heightReference,\n    HeightReference.NONE\n  );\n  this._distanceDisplayCondition = distanceDisplayCondition;\n  this._disableDepthTestDistance = options.disableDepthTestDistance;\n\n  this._labelCollection = labelCollection;\n  this._glyphs = [];\n  this._backgroundBillboard = undefined;\n  this._batchIndex = undefined; // Used only by Vector3DTilePoints and BillboardCollection\n\n  this._rebindAllGlyphs = true;\n  this._repositionAllGlyphs = true;\n\n  this._actualClampedPosition = undefined;\n  this._removeCallbackFunc = undefined;\n  this._mode = undefined;\n\n  this._clusterShow = true;\n\n  this.text = defaultValue(options.text, \"\");\n\n  this._relativeSize = 1.0;\n\n  parseFont(this);\n\n  this._updateClamping();\n}\n\nObject.defineProperties(Label.prototype, {\n  /**\n   * Determines if this label will be shown.  Use this to hide or show a label, instead\n   * of removing it and re-adding it to the collection.\n   * @memberof Label.prototype\n   * @type {Boolean}\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._show !== value) {\n        this._show = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.show = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.show = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the Cartesian position of this label.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const position = this._position;\n      if (!Cartesian3.equals(position, value)) {\n        Cartesian3.clone(value, position);\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.position = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.position = value;\n        }\n\n        this._updateClamping();\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the height reference of this billboard.\n   * @memberof Label.prototype\n   * @type {HeightReference}\n   * @default HeightReference.NONE\n   */\n  heightReference: {\n    get: function () {\n      return this._heightReference;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (value !== this._heightReference) {\n        this._heightReference = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const billboard = glyphs[i].billboard;\n          if (defined(billboard)) {\n            billboard.heightReference = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.heightReference = value;\n        }\n\n        repositionAllGlyphs(this);\n\n        this._updateClamping();\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the text of this label.\n   * @memberof Label.prototype\n   * @type {String}\n   */\n  text: {\n    get: function () {\n      return this._text;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._text !== value) {\n        this._text = value;\n\n        // Strip soft-hyphen (auto-wrap) characters from input string\n        const renderedValue = value.replace(/\\u00ad/g, \"\");\n        this._renderedText = Label.enableRightToLeftDetection\n          ? reverseRtl(renderedValue)\n          : renderedValue;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.\n   * @memberof Label.prototype\n   * @type {String}\n   * @default '30px sans-serif'\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles|HTML canvas 2D context text styles}\n   */\n  font: {\n    get: function () {\n      return this._font;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._font !== value) {\n        this._font = value;\n        rebindAllGlyphs(this);\n        parseFont(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the fill color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.WHITE\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  fillColor: {\n    get: function () {\n      return this._fillColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const fillColor = this._fillColor;\n      if (!Color.equals(fillColor, value)) {\n        Color.clone(value, fillColor);\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the outline color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default Color.BLACK\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineColor: {\n    get: function () {\n      return this._outlineColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const outlineColor = this._outlineColor;\n      if (!Color.equals(outlineColor, value)) {\n        Color.clone(value, outlineColor);\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the outline width of this label.\n   * @memberof Label.prototype\n   * @type {Number}\n   * @default 1.0\n   * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}\n   */\n  outlineWidth: {\n    get: function () {\n      return this._outlineWidth;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._outlineWidth !== value) {\n        this._outlineWidth = value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Determines if a background behind this label will be shown.\n   * @memberof Label.prototype\n   * @default false\n   * @type {Boolean}\n   */\n  showBackground: {\n    get: function () {\n      return this._showBackground;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._showBackground !== value) {\n        this._showBackground = value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the background color of this label.\n   * @memberof Label.prototype\n   * @type {Color}\n   * @default new Color(0.165, 0.165, 0.165, 0.8)\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const backgroundColor = this._backgroundColor;\n      if (!Color.equals(backgroundColor, value)) {\n        Color.clone(value, backgroundColor);\n\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.color = backgroundColor;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value\n   * controls horizontal padding, and the <code>y</code> value controls vertical padding.\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default new Cartesian2(7, 5)\n   */\n  backgroundPadding: {\n    get: function () {\n      return this._backgroundPadding;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const backgroundPadding = this._backgroundPadding;\n      if (!Cartesian2.equals(backgroundPadding, value)) {\n        Cartesian2.clone(value, backgroundPadding);\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the style of this label.\n   * @memberof Label.prototype\n   * @type {LabelStyle}\n   * @default LabelStyle.FILL\n   */\n  style: {\n    get: function () {\n      return this._style;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._style !== value) {\n        this._style = value;\n        rebindAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used\n   * to align multiple labels and billboards at the same position, e.g., an image and text.  The\n   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n   * left to right, and <code>y</code> increases from top to bottom.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>\n   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>\n   * </tr></table>\n   * The label's origin is indicated by the yellow point.\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian2}\n   * @default Cartesian2.ZERO\n   */\n  pixelOffset: {\n    get: function () {\n      return this._pixelOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const pixelOffset = this._pixelOffset;\n      if (!Cartesian2.equals(pixelOffset, value)) {\n        Cartesian2.clone(value, pixelOffset);\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffset = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffset = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.\n   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,\n   * translucencyByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's translucencyByDistance to 1.0 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable translucency by distance\n   * text.translucencyByDistance = undefined;\n   */\n  translucencyByDistance: {\n    get: function () {\n      return this._translucencyByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      const translucencyByDistance = this._translucencyByDistance;\n      if (!NearFarScalar.equals(translucencyByDistance, value)) {\n        this._translucencyByDistance = NearFarScalar.clone(\n          value,\n          translucencyByDistance\n        );\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.translucencyByDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.translucencyByDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.\n   * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,\n   * pixelOffsetScaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's pixel offset scale to 0.0 when the\n   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels\n   * // in the y direction the camera distance approaches 8.0e6 meters.\n   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);\n   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable pixel offset by distance\n   * text.pixelOffsetScaleByDistance = undefined;\n   */\n  pixelOffsetScaleByDistance: {\n    get: function () {\n      return this._pixelOffsetScaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      const pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;\n      if (!NearFarScalar.equals(pixelOffsetScaleByDistance, value)) {\n        this._pixelOffsetScaleByDistance = NearFarScalar.clone(\n          value,\n          pixelOffsetScaleByDistance\n        );\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.pixelOffsetScaleByDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.pixelOffsetScaleByDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.\n   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,\n   * scaleByDistance will be disabled.\n   * @memberof Label.prototype\n   * @type {NearFarScalar}\n   *\n   * @example\n   * // Example 1.\n   * // Set a label's scaleByDistance to scale by 1.5 when the\n   * // camera is 1500 meters from the label and disappear as\n   * // the camera distance approaches 8.0e6 meters.\n   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);\n   *\n   * @example\n   * // Example 2.\n   * // disable scaling by distance\n   * label.scaleByDistance = undefined;\n   */\n  scaleByDistance: {\n    get: function () {\n      return this._scaleByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      const scaleByDistance = this._scaleByDistance;\n      if (!NearFarScalar.equals(scaleByDistance, value)) {\n        this._scaleByDistance = NearFarScalar.clone(value, scaleByDistance);\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scaleByDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scaleByDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed\n   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and\n   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,\n   * which is typically meters.\n   * <br /><br />\n   * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to\n   * arrange a label above its corresponding 3D model.\n   * <br /><br />\n   * Below, the label is positioned at the center of the Earth but an eye offset makes it always\n   * appear on top of the Earth regardless of the viewer's or Earth's orientation.\n   * <br /><br />\n   * <div align='center'>\n   * <table border='0' cellpadding='5'><tr>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>\n   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>\n   * </tr></table>\n   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   */\n  eyeOffset: {\n    get: function () {\n      return this._eyeOffset;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      const eyeOffset = this._eyeOffset;\n      if (!Cartesian3.equals(eyeOffset, value)) {\n        Cartesian3.clone(value, eyeOffset);\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.eyeOffset = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.eyeOffset = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the horizontal origin of this label, which determines if the label is drawn\n   * to the left, center, or right of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {HorizontalOrigin}\n   * @default HorizontalOrigin.LEFT\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  horizontalOrigin: {\n    get: function () {\n      return this._horizontalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._horizontalOrigin !== value) {\n        this._horizontalOrigin = value;\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the vertical origin of this label, which determines if the label is\n   * to the above, below, or at the center of its anchor position.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />\n   * </div>\n   * @memberof Label.prototype\n   * @type {VerticalOrigin}\n   * @default VerticalOrigin.BASELINE\n   * @example\n   * // Use a top, right origin\n   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;\n   */\n  verticalOrigin: {\n    get: function () {\n      return this._verticalOrigin;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._verticalOrigin !== value) {\n        this._verticalOrigin = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.verticalOrigin = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.verticalOrigin = value;\n        }\n\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the uniform scale that is multiplied with the label's size in pixels.\n   * A scale of <code>1.0</code> does not change the size of the label; a scale greater than\n   * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks\n   * the label.\n   * <br /><br />\n   * Applying a large scale value may pixelate the label.  To make text larger without pixelation,\n   * use a larger font size when calling {@link Label#font} instead.\n   * <br /><br />\n   * <div align='center'>\n   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>\n   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,\n   * and <code>2.0</code>.\n   * </div>\n   * @memberof Label.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._scale !== value) {\n        this._scale = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.scale = value * this._relativeSize;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.scale = value * this._relativeSize;\n        }\n\n        repositionAllGlyphs(this);\n      }\n    },\n  },\n\n  /**\n   * Gets the total scale of the label, which is the label's scale multiplied by the computed relative size\n   * of the desired font compared to the generated glyph size.\n   * @memberof Label.prototype\n   * @type {Number}\n   * @default 1.0\n   */\n  totalScale: {\n    get: function () {\n      return this._scale * this._relativeSize;\n    },\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.\n   * @memberof Label.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      }\n      //>>includeEnd('debug');\n      if (\n        !DistanceDisplayCondition.equals(value, this._distanceDisplayCondition)\n      ) {\n        this._distanceDisplayCondition = DistanceDisplayCondition.clone(\n          value,\n          this._distanceDisplayCondition\n        );\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.distanceDisplayCondition = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.distanceDisplayCondition = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.\n   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.\n   * @memberof Label.prototype\n   * @type {Number}\n   */\n  disableDepthTestDistance: {\n    get: function () {\n      return this._disableDepthTestDistance;\n    },\n    set: function (value) {\n      if (this._disableDepthTestDistance !== value) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(value) && value < 0.0) {\n          throw new DeveloperError(\n            \"disableDepthTestDistance must be greater than 0.0.\"\n          );\n        }\n        //>>includeEnd('debug');\n        this._disableDepthTestDistance = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.disableDepthTestDistance = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.disableDepthTestDistance = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets the user-defined value returned when the label is picked.\n   * @memberof Label.prototype\n   * @type {*}\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n    set: function (value) {\n      if (this._id !== value) {\n        this._id = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.id = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.id = value;\n        }\n      }\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickId: {\n    get: function () {\n      if (this._glyphs.length === 0 || !defined(this._glyphs[0].billboard)) {\n        return undefined;\n      }\n      return this._glyphs[0].billboard.pickId;\n    },\n  },\n\n  /**\n   * Keeps track of the position of the label based on the height reference.\n   * @memberof Label.prototype\n   * @type {Cartesian3}\n   * @private\n   */\n  _clampedPosition: {\n    get: function () {\n      return this._actualClampedPosition;\n    },\n    set: function (value) {\n      this._actualClampedPosition = Cartesian3.clone(\n        value,\n        this._actualClampedPosition\n      );\n\n      const glyphs = this._glyphs;\n      for (let i = 0, len = glyphs.length; i < len; i++) {\n        const glyph = glyphs[i];\n        if (defined(glyph.billboard)) {\n          // Set all the private values here, because we already clamped to ground\n          //  so we don't want to do it again for every glyph\n          glyph.billboard._clampedPosition = value;\n        }\n      }\n      const backgroundBillboard = this._backgroundBillboard;\n      if (defined(backgroundBillboard)) {\n        backgroundBillboard._clampedPosition = value;\n      }\n    },\n  },\n\n  /**\n   * Determines whether or not this label will be shown or hidden because it was clustered.\n   * @memberof Label.prototype\n   * @type {Boolean}\n   * @default true\n   * @private\n   */\n  clusterShow: {\n    get: function () {\n      return this._clusterShow;\n    },\n    set: function (value) {\n      if (this._clusterShow !== value) {\n        this._clusterShow = value;\n\n        const glyphs = this._glyphs;\n        for (let i = 0, len = glyphs.length; i < len; i++) {\n          const glyph = glyphs[i];\n          if (defined(glyph.billboard)) {\n            glyph.billboard.clusterShow = value;\n          }\n        }\n        const backgroundBillboard = this._backgroundBillboard;\n        if (defined(backgroundBillboard)) {\n          backgroundBillboard.clusterShow = value;\n        }\n      }\n    },\n  },\n});\n\nLabel.prototype._updateClamping = function () {\n  Billboard._updateClamping(this._labelCollection, this);\n};\n\n/**\n * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.\n * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from\n * left to right, and <code>y</code> increases from top to bottom.\n *\n * @param {Scene} scene The scene the label is in.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The screen-space position of the label.\n *\n *\n * @example\n * console.log(l.computeScreenSpacePosition(scene).toString());\n *\n * @see Label#eyeOffset\n * @see Label#pixelOffset\n */\nLabel.prototype.computeScreenSpacePosition = function (scene, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  const labelCollection = this._labelCollection;\n  const modelMatrix = labelCollection.modelMatrix;\n  const actualPosition = defined(this._actualClampedPosition)\n    ? this._actualClampedPosition\n    : this._position;\n\n  const windowCoordinates = Billboard._computeScreenSpacePosition(\n    modelMatrix,\n    actualPosition,\n    this._eyeOffset,\n    this._pixelOffset,\n    scene,\n    result\n  );\n  return windowCoordinates;\n};\n\n/**\n * Gets a label's screen space bounding box centered around screenSpacePosition.\n * @param {Label} label The label to get the screen space bounding box for.\n * @param {Cartesian2} screenSpacePosition The screen space center of the label.\n * @param {BoundingRectangle} [result] The object onto which to store the result.\n * @returns {BoundingRectangle} The screen space bounding box.\n *\n * @private\n */\nLabel.getScreenSpaceBoundingBox = function (\n  label,\n  screenSpacePosition,\n  result\n) {\n  let x = 0;\n  let y = 0;\n  let width = 0;\n  let height = 0;\n  const scale = label.totalScale;\n\n  const backgroundBillboard = label._backgroundBillboard;\n  if (defined(backgroundBillboard)) {\n    x = screenSpacePosition.x + backgroundBillboard._translate.x;\n    y = screenSpacePosition.y - backgroundBillboard._translate.y;\n    width = backgroundBillboard.width * scale;\n    height = backgroundBillboard.height * scale;\n\n    if (\n      label.verticalOrigin === VerticalOrigin.BOTTOM ||\n      label.verticalOrigin === VerticalOrigin.BASELINE\n    ) {\n      y -= height;\n    } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n      y -= height * 0.5;\n    }\n  } else {\n    x = Number.POSITIVE_INFINITY;\n    y = Number.POSITIVE_INFINITY;\n    let maxX = 0;\n    let maxY = 0;\n    const glyphs = label._glyphs;\n    const length = glyphs.length;\n    for (let i = 0; i < length; ++i) {\n      const glyph = glyphs[i];\n      const billboard = glyph.billboard;\n      if (!defined(billboard)) {\n        continue;\n      }\n\n      const glyphX = screenSpacePosition.x + billboard._translate.x;\n      let glyphY = screenSpacePosition.y - billboard._translate.y;\n      const glyphWidth = glyph.dimensions.width * scale;\n      const glyphHeight = glyph.dimensions.height * scale;\n\n      if (\n        label.verticalOrigin === VerticalOrigin.BOTTOM ||\n        label.verticalOrigin === VerticalOrigin.BASELINE\n      ) {\n        glyphY -= glyphHeight;\n      } else if (label.verticalOrigin === VerticalOrigin.CENTER) {\n        glyphY -= glyphHeight * 0.5;\n      }\n\n      if (label._verticalOrigin === VerticalOrigin.TOP) {\n        glyphY += SDFSettings.PADDING * scale;\n      } else if (\n        label._verticalOrigin === VerticalOrigin.BOTTOM ||\n        label._verticalOrigin === VerticalOrigin.BASELINE\n      ) {\n        glyphY -= SDFSettings.PADDING * scale;\n      }\n\n      x = Math.min(x, glyphX);\n      y = Math.min(y, glyphY);\n      maxX = Math.max(maxX, glyphX + glyphWidth);\n      maxY = Math.max(maxY, glyphY + glyphHeight);\n    }\n\n    width = maxX - x;\n    height = maxY - y;\n  }\n\n  if (!defined(result)) {\n    result = new BoundingRectangle();\n  }\n\n  result.x = x;\n  result.y = y;\n  result.width = width;\n  result.height = height;\n\n  return result;\n};\n\n/**\n * Determines if this label equals another label.  Labels are equal if all their properties\n * are equal.  Labels in different collections can be equal.\n *\n * @param {Label} other The label to compare for equality.\n * @returns {Boolean} <code>true</code> if the labels are equal; otherwise, <code>false</code>.\n */\nLabel.prototype.equals = function (other) {\n  return (\n    this === other ||\n    (defined(other) &&\n      this._show === other._show &&\n      this._scale === other._scale &&\n      this._outlineWidth === other._outlineWidth &&\n      this._showBackground === other._showBackground &&\n      this._style === other._style &&\n      this._verticalOrigin === other._verticalOrigin &&\n      this._horizontalOrigin === other._horizontalOrigin &&\n      this._heightReference === other._heightReference &&\n      this._renderedText === other._renderedText &&\n      this._font === other._font &&\n      Cartesian3.equals(this._position, other._position) &&\n      Color.equals(this._fillColor, other._fillColor) &&\n      Color.equals(this._outlineColor, other._outlineColor) &&\n      Color.equals(this._backgroundColor, other._backgroundColor) &&\n      Cartesian2.equals(this._backgroundPadding, other._backgroundPadding) &&\n      Cartesian2.equals(this._pixelOffset, other._pixelOffset) &&\n      Cartesian3.equals(this._eyeOffset, other._eyeOffset) &&\n      NearFarScalar.equals(\n        this._translucencyByDistance,\n        other._translucencyByDistance\n      ) &&\n      NearFarScalar.equals(\n        this._pixelOffsetScaleByDistance,\n        other._pixelOffsetScaleByDistance\n      ) &&\n      NearFarScalar.equals(this._scaleByDistance, other._scaleByDistance) &&\n      DistanceDisplayCondition.equals(\n        this._distanceDisplayCondition,\n        other._distanceDisplayCondition\n      ) &&\n      this._disableDepthTestDistance === other._disableDepthTestDistance &&\n      this._id === other._id)\n  );\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nLabel.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Determines whether or not run the algorithm, that match the text of the label to right-to-left languages\n * @memberof Label\n * @type {Boolean}\n * @default false\n *\n * @example\n * // Example 1.\n * // Set a label's rightToLeft before init\n * Cesium.Label.enableRightToLeftDetection = true;\n * const myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: '   \\n   ',\n *   }\n * });\n *\n * @example\n * // Example 2.\n * const myLabelEntity = viewer.entities.add({\n *   label: {\n *     id: 'my label',\n *     text: 'English text'\n *   }\n * });\n * // Set a label's rightToLeft after init\n * Cesium.Label.enableRightToLeftDetection = true;\n * myLabelEntity.text = ' ';\n */\nLabel.enableRightToLeftDetection = false;\n\nfunction convertTextToTypes(text, rtlChars) {\n  const ltrChars = /[a-zA-Z0-9]/;\n  const bracketsChars = /[()[\\]{}<>]/;\n  const parsedText = [];\n  let word = \"\";\n  let lastType = textTypes.LTR;\n  let currentType = \"\";\n  const textLength = text.length;\n  for (let textIndex = 0; textIndex < textLength; ++textIndex) {\n    const character = text.charAt(textIndex);\n    if (rtlChars.test(character)) {\n      currentType = textTypes.RTL;\n    } else if (ltrChars.test(character)) {\n      currentType = textTypes.LTR;\n    } else if (bracketsChars.test(character)) {\n      currentType = textTypes.BRACKETS;\n    } else {\n      currentType = textTypes.WEAK;\n    }\n\n    if (textIndex === 0) {\n      lastType = currentType;\n    }\n\n    if (lastType === currentType && currentType !== textTypes.BRACKETS) {\n      word += character;\n    } else {\n      if (word !== \"\") {\n        parsedText.push({ Type: lastType, Word: word });\n      }\n      lastType = currentType;\n      word = character;\n    }\n  }\n  parsedText.push({ Type: currentType, Word: word });\n  return parsedText;\n}\n\nfunction reverseWord(word) {\n  return word.split(\"\").reverse().join(\"\");\n}\n\nfunction spliceWord(result, pointer, word) {\n  return result.slice(0, pointer) + word + result.slice(pointer);\n}\n\nfunction reverseBrackets(bracket) {\n  switch (bracket) {\n    case \"(\":\n      return \")\";\n    case \")\":\n      return \"(\";\n    case \"[\":\n      return \"]\";\n    case \"]\":\n      return \"[\";\n    case \"{\":\n      return \"}\";\n    case \"}\":\n      return \"{\";\n    case \"<\":\n      return \">\";\n    case \">\":\n      return \"<\";\n  }\n}\n\n//To add another language, simply add its Unicode block range(s) to the below regex.\nconst hebrew = \"\\u05D0-\\u05EA\";\nconst arabic = \"\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\";\nconst rtlChars = new RegExp(`[${hebrew}${arabic}]`);\n\n/**\n *\n * @param {String} value the text to parse and reorder\n * @returns {String} the text as rightToLeft direction\n * @private\n */\nfunction reverseRtl(value) {\n  const texts = value.split(\"\\n\");\n  let result = \"\";\n  for (let i = 0; i < texts.length; i++) {\n    const text = texts[i];\n    // first character of the line is a RTL character, so need to manage different cases\n    const rtlDir = rtlChars.test(text.charAt(0));\n    const parsedText = convertTextToTypes(text, rtlChars);\n\n    let splicePointer = 0;\n    let line = \"\";\n    for (let wordIndex = 0; wordIndex < parsedText.length; ++wordIndex) {\n      const subText = parsedText[wordIndex];\n      const reverse =\n        subText.Type === textTypes.BRACKETS\n          ? reverseBrackets(subText.Word)\n          : reverseWord(subText.Word);\n      if (rtlDir) {\n        if (subText.Type === textTypes.RTL) {\n          line = reverse + line;\n          splicePointer = 0;\n        } else if (subText.Type === textTypes.LTR) {\n          line = spliceWord(line, splicePointer, subText.Word);\n          splicePointer += subText.Word.length;\n        } else if (\n          subText.Type === textTypes.WEAK ||\n          subText.Type === textTypes.BRACKETS\n        ) {\n          // current word is weak, last one was bracket\n          if (\n            subText.Type === textTypes.WEAK &&\n            parsedText[wordIndex - 1].Type === textTypes.BRACKETS\n          ) {\n            line = reverse + line;\n          }\n          // current word is weak or bracket, last one was rtl\n          else if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n            line = reverse + line;\n            splicePointer = 0;\n          }\n          // current word is weak or bracket, there is at least one more word\n          else if (parsedText.length > wordIndex + 1) {\n            // next word is rtl\n            if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n              line = reverse + line;\n              splicePointer = 0;\n            } else {\n              line = spliceWord(line, splicePointer, subText.Word);\n              splicePointer += subText.Word.length;\n            }\n          }\n          // current word is weak or bracket, and it the last in this line\n          else {\n            line = spliceWord(line, 0, reverse);\n          }\n        }\n      }\n      // ltr line, rtl word\n      else if (subText.Type === textTypes.RTL) {\n        line = spliceWord(line, splicePointer, reverse);\n      }\n      // ltr line, ltr word\n      else if (subText.Type === textTypes.LTR) {\n        line += subText.Word;\n        splicePointer = line.length;\n      }\n      // ltr line, weak or bracket word\n      else if (\n        subText.Type === textTypes.WEAK ||\n        subText.Type === textTypes.BRACKETS\n      ) {\n        // not first word in line\n        if (wordIndex > 0) {\n          // last word was rtl\n          if (parsedText[wordIndex - 1].Type === textTypes.RTL) {\n            // there is at least one more word\n            if (parsedText.length > wordIndex + 1) {\n              // next word is rtl\n              if (parsedText[wordIndex + 1].Type === textTypes.RTL) {\n                line = spliceWord(line, splicePointer, reverse);\n              } else {\n                line += subText.Word;\n                splicePointer = line.length;\n              }\n            } else {\n              line += subText.Word;\n            }\n          } else {\n            line += subText.Word;\n            splicePointer = line.length;\n          }\n        } else {\n          line += subText.Word;\n          splicePointer = line.length;\n        }\n      }\n    }\n\n    result += line;\n    if (i < texts.length - 1) {\n      result += \"\\n\";\n    }\n  }\n  return result;\n}\nexport default Label;\n","import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport writeTextToCanvas from \"../Core/writeTextToCanvas.js\";\nimport bitmapSDF from \"../ThirdParty/bitmap-sdf.js\";\nimport BillboardCollection from \"./BillboardCollection.js\";\nimport BlendOption from \"./BlendOption.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport HorizontalOrigin from \"./HorizontalOrigin.js\";\nimport Label from \"./Label.js\";\nimport LabelStyle from \"./LabelStyle.js\";\nimport SDFSettings from \"./SDFSettings.js\";\nimport TextureAtlas from \"./TextureAtlas.js\";\nimport VerticalOrigin from \"./VerticalOrigin.js\";\nimport GraphemeSplitter from \"../ThirdParty/grapheme-splitter.js\";\n\n// A glyph represents a single character in a particular label.  It may or may\n// not have a billboard, depending on whether the texture info has an index into\n// the the label collection's texture atlas.  Invisible characters have no texture, and\n// no billboard.  However, it always has a valid dimensions object.\nfunction Glyph() {\n  this.textureInfo = undefined;\n  this.dimensions = undefined;\n  this.billboard = undefined;\n}\n\n// GlyphTextureInfo represents a single character, drawn in a particular style,\n// shared and reference counted across all labels.  It may or may not have an\n// index into the label collection's texture atlas, depending on whether the character\n// has both width and height, but it always has a valid dimensions object.\nfunction GlyphTextureInfo(labelCollection, index, dimensions) {\n  this.labelCollection = labelCollection;\n  this.index = index;\n  this.dimensions = dimensions;\n}\n\n// Traditionally, leading is %20 of the font size.\nconst defaultLineSpacingPercent = 1.2;\nconst whitePixelCanvasId = \"ID_WHITE_PIXEL\";\nconst whitePixelSize = new Cartesian2(4, 4);\nconst whitePixelBoundingRegion = new BoundingRectangle(1, 1, 1, 1);\n\nfunction addWhitePixelCanvas(textureAtlas) {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = whitePixelSize.x;\n  canvas.height = whitePixelSize.y;\n\n  const context2D = canvas.getContext(\"2d\");\n  context2D.fillStyle = \"#fff\";\n  context2D.fillRect(0, 0, canvas.width, canvas.height);\n\n  // Canvas operations take a frame to draw. Use the asynchronous add function which resolves a promise and allows the draw to complete,\n  // but there's no need to wait on the promise before operation can continue\n  textureAtlas.addImage(whitePixelCanvasId, canvas);\n}\n\n// reusable object for calling writeTextToCanvas\nconst writeTextToCanvasParameters = {};\nfunction createGlyphCanvas(\n  character,\n  font,\n  fillColor,\n  outlineColor,\n  outlineWidth,\n  style,\n  verticalOrigin\n) {\n  writeTextToCanvasParameters.font = font;\n  writeTextToCanvasParameters.fillColor = fillColor;\n  writeTextToCanvasParameters.strokeColor = outlineColor;\n  writeTextToCanvasParameters.strokeWidth = outlineWidth;\n  // Setting the padding to something bigger is necessary to get enough space for the outlining.\n  writeTextToCanvasParameters.padding = SDFSettings.PADDING;\n\n  if (verticalOrigin === VerticalOrigin.CENTER) {\n    writeTextToCanvasParameters.textBaseline = \"middle\";\n  } else if (verticalOrigin === VerticalOrigin.TOP) {\n    writeTextToCanvasParameters.textBaseline = \"top\";\n  } else {\n    // VerticalOrigin.BOTTOM and VerticalOrigin.BASELINE\n    writeTextToCanvasParameters.textBaseline = \"bottom\";\n  }\n\n  writeTextToCanvasParameters.fill =\n    style === LabelStyle.FILL || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.stroke =\n    style === LabelStyle.OUTLINE || style === LabelStyle.FILL_AND_OUTLINE;\n  writeTextToCanvasParameters.backgroundColor = Color.BLACK;\n\n  return writeTextToCanvas(character, writeTextToCanvasParameters);\n}\n\nfunction unbindGlyph(labelCollection, glyph) {\n  glyph.textureInfo = undefined;\n  glyph.dimensions = undefined;\n\n  const billboard = glyph.billboard;\n  if (defined(billboard)) {\n    billboard.show = false;\n    billboard.image = undefined;\n    if (defined(billboard._removeCallbackFunc)) {\n      billboard._removeCallbackFunc();\n      billboard._removeCallbackFunc = undefined;\n    }\n    labelCollection._spareBillboards.push(billboard);\n    glyph.billboard = undefined;\n  }\n}\n\nfunction addGlyphToTextureAtlas(textureAtlas, id, canvas, glyphTextureInfo) {\n  glyphTextureInfo.index = textureAtlas.addImageSync(id, canvas);\n}\n\nconst splitter = new GraphemeSplitter();\n\nfunction rebindAllGlyphs(labelCollection, label) {\n  const text = label._renderedText;\n  const graphemes = splitter.splitGraphemes(text);\n  const textLength = graphemes.length;\n  const glyphs = label._glyphs;\n  const glyphsLength = glyphs.length;\n\n  let glyph;\n  let glyphIndex;\n  let textIndex;\n\n  // Compute a font size scale relative to the sdf font generated size.\n  label._relativeSize = label._fontSize / SDFSettings.FONT_SIZE;\n\n  // if we have more glyphs than needed, unbind the extras.\n  if (textLength < glyphsLength) {\n    for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {\n      unbindGlyph(labelCollection, glyphs[glyphIndex]);\n    }\n  }\n\n  // presize glyphs to match the new text length\n  glyphs.length = textLength;\n\n  const showBackground =\n    label._showBackground && text.split(\"\\n\").join(\"\").length > 0;\n  let backgroundBillboard = label._backgroundBillboard;\n  const backgroundBillboardCollection =\n    labelCollection._backgroundBillboardCollection;\n  if (!showBackground) {\n    if (defined(backgroundBillboard)) {\n      backgroundBillboardCollection.remove(backgroundBillboard);\n      label._backgroundBillboard = backgroundBillboard = undefined;\n    }\n  } else {\n    if (!defined(backgroundBillboard)) {\n      backgroundBillboard = backgroundBillboardCollection.add({\n        collection: labelCollection,\n        image: whitePixelCanvasId,\n        imageSubRegion: whitePixelBoundingRegion,\n      });\n      label._backgroundBillboard = backgroundBillboard;\n    }\n\n    backgroundBillboard.color = label._backgroundColor;\n    backgroundBillboard.show = label._show;\n    backgroundBillboard.position = label._position;\n    backgroundBillboard.eyeOffset = label._eyeOffset;\n    backgroundBillboard.pixelOffset = label._pixelOffset;\n    backgroundBillboard.horizontalOrigin = HorizontalOrigin.LEFT;\n    backgroundBillboard.verticalOrigin = label._verticalOrigin;\n    backgroundBillboard.heightReference = label._heightReference;\n    backgroundBillboard.scale = label.totalScale;\n    backgroundBillboard.pickPrimitive = label;\n    backgroundBillboard.id = label._id;\n    backgroundBillboard.translucencyByDistance = label._translucencyByDistance;\n    backgroundBillboard.pixelOffsetScaleByDistance =\n      label._pixelOffsetScaleByDistance;\n    backgroundBillboard.scaleByDistance = label._scaleByDistance;\n    backgroundBillboard.distanceDisplayCondition =\n      label._distanceDisplayCondition;\n    backgroundBillboard.disableDepthTestDistance =\n      label._disableDepthTestDistance;\n  }\n\n  const glyphTextureCache = labelCollection._glyphTextureCache;\n\n  // walk the text looking for new characters (creating new glyphs for each)\n  // or changed characters (rebinding existing glyphs)\n  for (textIndex = 0; textIndex < textLength; ++textIndex) {\n    const character = graphemes[textIndex];\n    const verticalOrigin = label._verticalOrigin;\n\n    const id = JSON.stringify([\n      character,\n      label._fontFamily,\n      label._fontStyle,\n      label._fontWeight,\n      +verticalOrigin,\n    ]);\n\n    let glyphTextureInfo = glyphTextureCache[id];\n    if (!defined(glyphTextureInfo)) {\n      const glyphFont = `${label._fontStyle} ${label._fontWeight} ${SDFSettings.FONT_SIZE}px ${label._fontFamily}`;\n\n      const canvas = createGlyphCanvas(\n        character,\n        glyphFont,\n        Color.WHITE,\n        Color.WHITE,\n        0.0,\n        LabelStyle.FILL,\n        verticalOrigin\n      );\n\n      glyphTextureInfo = new GlyphTextureInfo(\n        labelCollection,\n        -1,\n        canvas.dimensions\n      );\n      glyphTextureCache[id] = glyphTextureInfo;\n\n      if (canvas.width > 0 && canvas.height > 0) {\n        const sdfValues = bitmapSDF(canvas, {\n          cutoff: SDFSettings.CUTOFF,\n          radius: SDFSettings.RADIUS,\n        });\n\n        const ctx = canvas.getContext(\"2d\");\n        const canvasWidth = canvas.width;\n        const canvasHeight = canvas.height;\n        const imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n        for (let i = 0; i < canvasWidth; i++) {\n          for (let j = 0; j < canvasHeight; j++) {\n            const baseIndex = j * canvasWidth + i;\n            const alpha = sdfValues[baseIndex] * 255;\n            const imageIndex = baseIndex * 4;\n            imgData.data[imageIndex + 0] = alpha;\n            imgData.data[imageIndex + 1] = alpha;\n            imgData.data[imageIndex + 2] = alpha;\n            imgData.data[imageIndex + 3] = alpha;\n          }\n        }\n        ctx.putImageData(imgData, 0, 0);\n        if (character !== \" \") {\n          addGlyphToTextureAtlas(\n            labelCollection._textureAtlas,\n            id,\n            canvas,\n            glyphTextureInfo\n          );\n        }\n      }\n    }\n\n    glyph = glyphs[textIndex];\n\n    if (defined(glyph)) {\n      // clean up leftover information from the previous glyph\n      if (glyphTextureInfo.index === -1) {\n        // no texture, and therefore no billboard, for this glyph.\n        // so, completely unbind glyph.\n        unbindGlyph(labelCollection, glyph);\n      } else if (defined(glyph.textureInfo)) {\n        // we have a texture and billboard.  If we had one before, release\n        // our reference to that texture info, but reuse the billboard.\n        glyph.textureInfo = undefined;\n      }\n    } else {\n      // create a glyph object\n      glyph = new Glyph();\n      glyphs[textIndex] = glyph;\n    }\n\n    glyph.textureInfo = glyphTextureInfo;\n    glyph.dimensions = glyphTextureInfo.dimensions;\n\n    // if we have a texture, configure the existing billboard, or obtain one\n    if (glyphTextureInfo.index !== -1) {\n      let billboard = glyph.billboard;\n      const spareBillboards = labelCollection._spareBillboards;\n      if (!defined(billboard)) {\n        if (spareBillboards.length > 0) {\n          billboard = spareBillboards.pop();\n        } else {\n          billboard = labelCollection._billboardCollection.add({\n            collection: labelCollection,\n          });\n          billboard._labelDimensions = new Cartesian2();\n          billboard._labelTranslate = new Cartesian2();\n        }\n        glyph.billboard = billboard;\n      }\n\n      billboard.show = label._show;\n      billboard.position = label._position;\n      billboard.eyeOffset = label._eyeOffset;\n      billboard.pixelOffset = label._pixelOffset;\n      billboard.horizontalOrigin = HorizontalOrigin.LEFT;\n      billboard.verticalOrigin = label._verticalOrigin;\n      billboard.heightReference = label._heightReference;\n      billboard.scale = label.totalScale;\n      billboard.pickPrimitive = label;\n      billboard.id = label._id;\n      billboard.image = id;\n      billboard.translucencyByDistance = label._translucencyByDistance;\n      billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;\n      billboard.scaleByDistance = label._scaleByDistance;\n      billboard.distanceDisplayCondition = label._distanceDisplayCondition;\n      billboard.disableDepthTestDistance = label._disableDepthTestDistance;\n      billboard._batchIndex = label._batchIndex;\n      billboard.outlineColor = label.outlineColor;\n      if (label.style === LabelStyle.FILL_AND_OUTLINE) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = label.outlineWidth;\n      } else if (label.style === LabelStyle.FILL) {\n        billboard.color = label._fillColor;\n        billboard.outlineWidth = 0.0;\n      } else if (label.style === LabelStyle.OUTLINE) {\n        billboard.color = Color.TRANSPARENT;\n        billboard.outlineWidth = label.outlineWidth;\n      }\n    }\n  }\n\n  // changing glyphs will cause the position of the\n  // glyphs to change, since different characters have different widths\n  label._repositionAllGlyphs = true;\n}\n\nfunction calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {\n  if (horizontalOrigin === HorizontalOrigin.CENTER) {\n    return -lineWidth / 2;\n  } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n    return -(lineWidth + backgroundPadding.x);\n  }\n  return backgroundPadding.x;\n}\n\n// reusable Cartesian2 instances\nconst glyphPixelOffset = new Cartesian2();\nconst scratchBackgroundPadding = new Cartesian2();\n\nfunction repositionAllGlyphs(label) {\n  const glyphs = label._glyphs;\n  const text = label._renderedText;\n  let glyph;\n  let dimensions;\n  let lastLineWidth = 0;\n  let maxLineWidth = 0;\n  const lineWidths = [];\n  let maxGlyphDescent = Number.NEGATIVE_INFINITY;\n  let maxGlyphY = 0;\n  let numberOfLines = 1;\n  let glyphIndex;\n  const glyphLength = glyphs.length;\n\n  const backgroundBillboard = label._backgroundBillboard;\n  const backgroundPadding = Cartesian2.clone(\n    defined(backgroundBillboard) ? label._backgroundPadding : Cartesian2.ZERO,\n    scratchBackgroundPadding\n  );\n\n  // We need to scale the background padding, which is specified in pixels by the inverse of the relative size so it is scaled properly.\n  backgroundPadding.x /= label._relativeSize;\n  backgroundPadding.y /= label._relativeSize;\n\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      lineWidths.push(lastLineWidth);\n      ++numberOfLines;\n      lastLineWidth = 0;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n      maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);\n      maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent);\n\n      //Computing the line width must also account for the kerning that occurs between letters.\n      lastLineWidth += dimensions.width - dimensions.minx;\n      if (glyphIndex < glyphLength - 1) {\n        lastLineWidth += glyphs[glyphIndex + 1].dimensions.minx;\n      }\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n    }\n  }\n  lineWidths.push(lastLineWidth);\n  const maxLineHeight = maxGlyphY + maxGlyphDescent;\n\n  const scale = label.totalScale;\n  const horizontalOrigin = label._horizontalOrigin;\n  const verticalOrigin = label._verticalOrigin;\n  let lineIndex = 0;\n  let lineWidth = lineWidths[lineIndex];\n  let widthOffset = calculateWidthOffset(\n    lineWidth,\n    horizontalOrigin,\n    backgroundPadding\n  );\n  const lineSpacing =\n    (defined(label._lineHeight)\n      ? label._lineHeight\n      : defaultLineSpacingPercent * label._fontSize) / label._relativeSize;\n  const otherLinesHeight = lineSpacing * (numberOfLines - 1);\n  let totalLineWidth = maxLineWidth;\n  let totalLineHeight = maxLineHeight + otherLinesHeight;\n\n  if (defined(backgroundBillboard)) {\n    totalLineWidth += backgroundPadding.x * 2;\n    totalLineHeight += backgroundPadding.y * 2;\n    backgroundBillboard._labelHorizontalOrigin = horizontalOrigin;\n  }\n\n  glyphPixelOffset.x = widthOffset * scale;\n  glyphPixelOffset.y = 0;\n\n  let firstCharOfLine = true;\n\n  let lineOffsetY = 0;\n  for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n    if (text.charAt(glyphIndex) === \"\\n\") {\n      ++lineIndex;\n      lineOffsetY += lineSpacing;\n      lineWidth = lineWidths[lineIndex];\n      widthOffset = calculateWidthOffset(\n        lineWidth,\n        horizontalOrigin,\n        backgroundPadding\n      );\n      glyphPixelOffset.x = widthOffset * scale;\n      firstCharOfLine = true;\n    } else {\n      glyph = glyphs[glyphIndex];\n      dimensions = glyph.dimensions;\n\n      if (verticalOrigin === VerticalOrigin.TOP) {\n        glyphPixelOffset.y =\n          dimensions.height - maxGlyphY - backgroundPadding.y;\n        glyphPixelOffset.y += SDFSettings.PADDING;\n      } else if (verticalOrigin === VerticalOrigin.CENTER) {\n        glyphPixelOffset.y =\n          (otherLinesHeight + dimensions.height - maxGlyphY) / 2;\n      } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n        glyphPixelOffset.y = otherLinesHeight;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      } else {\n        // VerticalOrigin.BOTTOM\n        glyphPixelOffset.y =\n          otherLinesHeight + maxGlyphDescent + backgroundPadding.y;\n        glyphPixelOffset.y -= SDFSettings.PADDING;\n      }\n      glyphPixelOffset.y =\n        (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale;\n\n      // Handle any offsets for the first character of the line since the bounds might not be right on the bottom left pixel.\n      if (firstCharOfLine) {\n        glyphPixelOffset.x -= SDFSettings.PADDING * scale;\n        firstCharOfLine = false;\n      }\n\n      if (defined(glyph.billboard)) {\n        glyph.billboard._setTranslate(glyphPixelOffset);\n        glyph.billboard._labelDimensions.x = totalLineWidth;\n        glyph.billboard._labelDimensions.y = totalLineHeight;\n        glyph.billboard._labelHorizontalOrigin = horizontalOrigin;\n      }\n\n      //Compute the next x offset taking into account the kerning performed\n      //on both the current letter as well as the next letter to be drawn\n      //as well as any applied scale.\n      if (glyphIndex < glyphLength - 1) {\n        const nextGlyph = glyphs[glyphIndex + 1];\n        glyphPixelOffset.x +=\n          (dimensions.width - dimensions.minx + nextGlyph.dimensions.minx) *\n          scale;\n      }\n    }\n  }\n\n  if (defined(backgroundBillboard) && text.split(\"\\n\").join(\"\").length > 0) {\n    if (horizontalOrigin === HorizontalOrigin.CENTER) {\n      widthOffset = -maxLineWidth / 2 - backgroundPadding.x;\n    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {\n      widthOffset = -(maxLineWidth + backgroundPadding.x * 2);\n    } else {\n      widthOffset = 0;\n    }\n    glyphPixelOffset.x = widthOffset * scale;\n\n    if (verticalOrigin === VerticalOrigin.TOP) {\n      glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.CENTER) {\n      glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;\n    } else if (verticalOrigin === VerticalOrigin.BASELINE) {\n      glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;\n    } else {\n      // VerticalOrigin.BOTTOM\n      glyphPixelOffset.y = 0;\n    }\n    glyphPixelOffset.y = glyphPixelOffset.y * scale;\n\n    backgroundBillboard.width = totalLineWidth;\n    backgroundBillboard.height = totalLineHeight;\n    backgroundBillboard._setTranslate(glyphPixelOffset);\n    backgroundBillboard._labelTranslate = Cartesian2.clone(\n      glyphPixelOffset,\n      backgroundBillboard._labelTranslate\n    );\n  }\n\n  if (label.heightReference === HeightReference.CLAMP_TO_GROUND) {\n    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {\n      glyph = glyphs[glyphIndex];\n      const billboard = glyph.billboard;\n      if (defined(billboard)) {\n        billboard._labelTranslate = Cartesian2.clone(\n          glyphPixelOffset,\n          billboard._labelTranslate\n        );\n      }\n    }\n  }\n}\n\nfunction destroyLabel(labelCollection, label) {\n  const glyphs = label._glyphs;\n  for (let i = 0, len = glyphs.length; i < len; ++i) {\n    unbindGlyph(labelCollection, glyphs[i]);\n  }\n  if (defined(label._backgroundBillboard)) {\n    labelCollection._backgroundBillboardCollection.remove(\n      label._backgroundBillboard\n    );\n    label._backgroundBillboard = undefined;\n  }\n  label._labelCollection = undefined;\n\n  if (defined(label._removeCallbackFunc)) {\n    label._removeCallbackFunc();\n  }\n\n  destroyObject(label);\n}\n\n/**\n * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.\n * Each label can have a different font, color, scale, etc.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/Label.png' width='400' height='300' /><br />\n * Example labels\n * </div>\n * <br /><br />\n * Labels are added and removed from the collection using {@link LabelCollection#add}\n * and {@link LabelCollection#remove}.\n *\n * @alias LabelCollection\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each label from model to world coordinates.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {Scene} [options.scene] Must be passed in for labels that use the height reference property or will be depth tested against the globe.\n * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The label blending option. The default\n * is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,\n * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.\n * @param {Boolean} [options.show=true] Determines if the labels in the collection will be shown.\n *\n * @performance For best performance, prefer a few collections, each with many labels, to\n * many collections with only a few labels each.  Avoid having collections where some\n * labels change every frame and others do not; instead, create one or more collections\n * for static labels, and one or more collections for dynamic labels.\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n * @see Label\n * @see BillboardCollection\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}\n *\n * @example\n * // Create a label collection with two labels\n * const labels = scene.primitives.add(new Cesium.LabelCollection());\n * labels.add({\n *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),\n *   text : 'A label'\n * });\n * labels.add({\n *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),\n *   text : 'Another label'\n * });\n */\nfunction LabelCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._scene = options.scene;\n  this._batchTable = options.batchTable;\n\n  this._textureAtlas = undefined;\n  this._backgroundTextureAtlas = undefined;\n\n  this._backgroundBillboardCollection = new BillboardCollection({\n    scene: this._scene,\n  });\n  this._backgroundBillboardCollection.destroyTextureAtlas = false;\n\n  this._billboardCollection = new BillboardCollection({\n    scene: this._scene,\n    batchTable: this._batchTable,\n  });\n  this._billboardCollection.destroyTextureAtlas = false;\n  this._billboardCollection._sdf = true;\n\n  this._spareBillboards = [];\n  this._glyphTextureCache = {};\n  this._labels = [];\n  this._labelsToUpdate = [];\n  this._totalGlyphCount = 0;\n\n  this._highlightColor = Color.clone(Color.WHITE); // Only used by Vector3DTilePoints\n\n  /**\n   * Determines if labels in this collection will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.\n   * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type Matrix4\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),\n   *   text     : 'Center'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),\n   *   text     : 'East'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),\n   *   text     : 'North'\n   * });\n   * labels.add({\n   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),\n   *   text     : 'Up'\n   * });\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * The label blending option. The default is used for rendering both opaque and translucent labels.\n   * However, if either all of the labels are completely opaque or all are completely translucent,\n   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve\n   * performance by up to 2x.\n   * @type {BlendOption}\n   * @default BlendOption.OPAQUE_AND_TRANSLUCENT\n   */\n  this.blendOption = defaultValue(\n    options.blendOption,\n    BlendOption.OPAQUE_AND_TRANSLUCENT\n  );\n}\n\nObject.defineProperties(LabelCollection.prototype, {\n  /**\n   * Returns the number of labels in this collection.  This is commonly used with\n   * {@link LabelCollection#get} to iterate over all the labels\n   * in the collection.\n   * @memberof LabelCollection.prototype\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return this._labels.length;\n    },\n  },\n});\n\n/**\n * Creates and adds a label with the specified initial properties to the collection.\n * The added label is returned so it can be modified or removed from the collection later.\n *\n * @param {Object} [options] A template describing the label's properties as shown in Example 1.\n * @returns {Label} The label that was added to the collection.\n *\n * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten; this operations is <code>O(n)</code> and also incurs\n * CPU to GPU overhead.  For best performance, add as many billboards as possible before\n * calling <code>update</code>.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Example 1:  Add a label, specifying all the default values.\n * const l = labels.add({\n *   show : true,\n *   position : Cesium.Cartesian3.ZERO,\n *   text : '',\n *   font : '30px sans-serif',\n *   fillColor : Cesium.Color.WHITE,\n *   outlineColor : Cesium.Color.BLACK,\n *   outlineWidth : 1.0,\n *   showBackground : false,\n *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),\n *   backgroundPadding : new Cesium.Cartesian2(7, 5),\n *   style : Cesium.LabelStyle.FILL,\n *   pixelOffset : Cesium.Cartesian2.ZERO,\n *   eyeOffset : Cesium.Cartesian3.ZERO,\n *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,\n *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,\n *   scale : 1.0,\n *   translucencyByDistance : undefined,\n *   pixelOffsetScaleByDistance : undefined,\n *   heightReference : HeightReference.NONE,\n *   distanceDisplayCondition : undefined\n * });\n *\n * @example\n * // Example 2:  Specify only the label's cartographic position,\n * // text, and font.\n * const l = labels.add({\n *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),\n *   text : 'Hello World',\n *   font : '24px Helvetica',\n * });\n *\n * @see LabelCollection#remove\n * @see LabelCollection#removeAll\n */\nLabelCollection.prototype.add = function (options) {\n  const label = new Label(options, this);\n\n  this._labels.push(label);\n  this._labelsToUpdate.push(label);\n\n  return label;\n};\n\n/**\n * Removes a label from the collection.  Once removed, a label is no longer usable.\n *\n * @param {Label} label The label to remove.\n * @returns {Boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.\n *\n * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer\n * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For\n * best performance, remove as many labels as possible before calling <code>update</code>.\n * If you intend to temporarily hide a label, it is usually more efficient to call\n * {@link Label#show} instead of removing and re-adding the label.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * const l = labels.add(...);\n * labels.remove(l);  // Returns true\n *\n * @see LabelCollection#add\n * @see LabelCollection#removeAll\n * @see Label#show\n */\nLabelCollection.prototype.remove = function (label) {\n  if (defined(label) && label._labelCollection === this) {\n    const index = this._labels.indexOf(label);\n    if (index !== -1) {\n      this._labels.splice(index, 1);\n      destroyLabel(this, label);\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Removes all labels from the collection.\n *\n * @performance <code>O(n)</code>.  It is more efficient to remove all the labels\n * from a collection and then add new ones than to create a new collection entirely.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels.add(...);\n * labels.add(...);\n * labels.removeAll();\n *\n * @see LabelCollection#add\n * @see LabelCollection#remove\n */\nLabelCollection.prototype.removeAll = function () {\n  const labels = this._labels;\n\n  for (let i = 0, len = labels.length; i < len; ++i) {\n    destroyLabel(this, labels[i]);\n  }\n\n  labels.length = 0;\n};\n\n/**\n * Check whether this collection contains a given label.\n *\n * @param {Label} label The label to check for.\n * @returns {Boolean} true if this collection contains the label, false otherwise.\n *\n * @see LabelCollection#get\n *\n */\nLabelCollection.prototype.contains = function (label) {\n  return defined(label) && label._labelCollection === this;\n};\n\n/**\n * Returns the label in the collection at the specified index.  Indices are zero-based\n * and increase as labels are added.  Removing a label shifts all labels after\n * it to the left, changing their indices.  This function is commonly used with\n * {@link LabelCollection#length} to iterate over all the labels\n * in the collection.\n *\n * @param {Number} index The zero-based index of the billboard.\n *\n * @returns {Label} The label at the specified index.\n *\n * @performance Expected constant time.  If labels were removed from the collection and\n * {@link Scene#render} was not called, an implicit <code>O(n)</code>\n * operation is performed.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * // Toggle the show property of every label in the collection\n * const len = labels.length;\n * for (let i = 0; i < len; ++i) {\n *   const l = billboards.get(i);\n *   l.show = !l.show;\n * }\n *\n * @see LabelCollection#length\n */\nLabelCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._labels[index];\n};\n\n/**\n * @private\n *\n */\nLabelCollection.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  const billboardCollection = this._billboardCollection;\n  const backgroundBillboardCollection = this._backgroundBillboardCollection;\n\n  billboardCollection.modelMatrix = this.modelMatrix;\n  billboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n  backgroundBillboardCollection.modelMatrix = this.modelMatrix;\n  backgroundBillboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;\n\n  const context = frameState.context;\n\n  if (!defined(this._textureAtlas)) {\n    this._textureAtlas = new TextureAtlas({\n      context: context,\n    });\n    billboardCollection.textureAtlas = this._textureAtlas;\n  }\n\n  if (!defined(this._backgroundTextureAtlas)) {\n    this._backgroundTextureAtlas = new TextureAtlas({\n      context: context,\n      initialSize: whitePixelSize,\n    });\n    backgroundBillboardCollection.textureAtlas = this._backgroundTextureAtlas;\n    addWhitePixelCanvas(this._backgroundTextureAtlas);\n  }\n\n  const len = this._labelsToUpdate.length;\n  for (let i = 0; i < len; ++i) {\n    const label = this._labelsToUpdate[i];\n    if (label.isDestroyed()) {\n      continue;\n    }\n\n    const preUpdateGlyphCount = label._glyphs.length;\n\n    if (label._rebindAllGlyphs) {\n      rebindAllGlyphs(this, label);\n      label._rebindAllGlyphs = false;\n    }\n\n    if (label._repositionAllGlyphs) {\n      repositionAllGlyphs(label);\n      label._repositionAllGlyphs = false;\n    }\n\n    const glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;\n    this._totalGlyphCount += glyphCountDifference;\n  }\n\n  const blendOption =\n    backgroundBillboardCollection.length > 0\n      ? BlendOption.TRANSLUCENT\n      : this.blendOption;\n  billboardCollection.blendOption = blendOption;\n  backgroundBillboardCollection.blendOption = blendOption;\n\n  billboardCollection._highlightColor = this._highlightColor;\n  backgroundBillboardCollection._highlightColor = this._highlightColor;\n\n  this._labelsToUpdate.length = 0;\n  backgroundBillboardCollection.update(frameState);\n  billboardCollection.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see LabelCollection#destroy\n */\nLabelCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * labels = labels && labels.destroy();\n *\n * @see LabelCollection#isDestroyed\n */\nLabelCollection.prototype.destroy = function () {\n  this.removeAll();\n  this._billboardCollection = this._billboardCollection.destroy();\n  this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy();\n  this._backgroundBillboardCollection = this._backgroundBillboardCollection.destroy();\n  this._backgroundTextureAtlas =\n    this._backgroundTextureAtlas && this._backgroundTextureAtlas.destroy();\n\n  return destroyObject(this);\n};\nexport default LabelCollection;\n","/**\n * Describes how to draw a label.\n *\n * @enum {Number}\n *\n * @see Label#style\n */\nconst LabelStyle = {\n  /**\n   * Fill the text of the label, but do not outline.\n   *\n   * @type {Number}\n   * @constant\n   */\n  FILL: 0,\n\n  /**\n   * Outline the text of the label, but do not fill.\n   *\n   * @type {Number}\n   * @constant\n   */\n  OUTLINE: 1,\n\n  /**\n   * Fill and outline the text of the label.\n   *\n   * @type {Number}\n   * @constant\n   */\n  FILL_AND_OUTLINE: 2,\n};\nexport default Object.freeze(LabelStyle);\n","import DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * A light source. This type describes an interface and is not intended to be instantiated directly. Together, <code>color</code> and <code>intensity</code> produce a high-dynamic-range light color. <code>intensity</code> can also be used individually to dim or brighten the light without changing the hue.\n *\n * @alias Light\n * @constructor\n *\n * @see DirectionalLight\n * @see SunLight\n */\nfunction Light() {}\n\nObject.defineProperties(Light.prototype, {\n  /**\n   * The color of the light.\n   * @memberof Light.prototype\n   * @type {Color}\n   */\n  color: {\n    get: DeveloperError.throwInstantiationError,\n  },\n\n  /**\n   * The intensity controls the strength of the light. <code>intensity</code> has a minimum value of 0.0 and no maximum value.\n   * @memberof Light.prototype\n   * @type {Number}\n   */\n  intensity: {\n    get: DeveloperError.throwInstantiationError,\n  },\n});\n\nexport default Light;\n","/**\n * Describes how the map will operate in 2D.\n *\n * @enum {Number}\n */\nconst MapMode2D = {\n  /**\n   * The 2D map can be rotated about the z axis.\n   *\n   * @type {Number}\n   * @constant\n   */\n  ROTATE: 0,\n\n  /**\n   * The 2D map can be scrolled infinitely in the horizontal direction.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INFINITE_SCROLL: 1,\n};\nexport default Object.freeze(MapMode2D);\n","import Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Resource from \"../Core/Resource.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\n\nconst trailingSlashRegex = /\\/$/;\nconst defaultCredit = new Credit(\n  '&copy; <a href=\"https://www.mapbox.com/about/maps/\">Mapbox</a> &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> <strong><a href=\"https://www.mapbox.com/map-feedback/\">Improve this map</a></strong>'\n);\n\n/**\n * @typedef {Object} MapboxImageryProvider.ConstructorOptions\n *\n * Initialization options for the MapboxImageryProvider constructor\n *\n * @property {String} [url='https://api.mapbox.com/v4/'] The Mapbox server url.\n * @property {String} mapId The Mapbox Map ID.\n * @property {String} accessToken The public access token for the imagery.\n * @property {String} [format='png'] The format of the image request.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @property {Number} [minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @property {Number} [maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.\n * @property {Rectangle} [rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @property {Credit|String} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * Provides tiled imagery hosted by Mapbox.\n *\n * @alias MapboxImageryProvider\n * @constructor\n *\n * @param {MapboxImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @example\n * // Mapbox tile provider\n * const mapbox = new Cesium.MapboxImageryProvider({\n *     mapId: 'mapbox.streets',\n *     accessToken: 'thisIsMyAccessToken'\n * });\n *\n * @see {@link https://www.mapbox.com/developers/api/maps/#tiles}\n * @see {@link https://www.mapbox.com/developers/api/#access-tokens}\n */\nfunction MapboxImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const mapId = options.mapId;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(mapId)) {\n    throw new DeveloperError(\"options.mapId is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const accessToken = options.accessToken;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(accessToken)) {\n    throw new DeveloperError(\"options.accessToken is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  const resource = Resource.createIfNeeded(\n    defaultValue(options.url, \"https://{s}.tiles.mapbox.com/v4/\")\n  );\n\n  this._mapId = mapId;\n  this._accessToken = accessToken;\n\n  let format = defaultValue(options.format, \"png\");\n  if (!/\\./.test(format)) {\n    format = `.${format}`;\n  }\n  this._format = format;\n\n  let templateUrl = resource.getUrlComponent();\n  if (!trailingSlashRegex.test(templateUrl)) {\n    templateUrl += \"/\";\n  }\n  templateUrl += `${mapId}/{z}/{x}/{y}${this._format}`;\n  resource.url = templateUrl;\n\n  resource.setQueryParameters({\n    access_token: accessToken,\n  });\n\n  let credit;\n  if (defined(options.credit)) {\n    credit = options.credit;\n    if (typeof credit === \"string\") {\n      credit = new Credit(credit);\n    }\n  } else {\n    credit = defaultCredit;\n  }\n\n  this._resource = resource;\n  this._imageryProvider = new UrlTemplateImageryProvider({\n    url: resource,\n    credit: credit,\n    ellipsoid: options.ellipsoid,\n    minimumLevel: options.minimumLevel,\n    maximumLevel: options.maximumLevel,\n    rectangle: options.rectangle,\n  });\n}\n\nObject.defineProperties(MapboxImageryProvider.prototype, {\n  /**\n   * Gets the URL of the Mapbox server.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._imageryProvider.url;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._imageryProvider.ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._imageryProvider.readyPromise;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should\n   * not be called before {@link MapboxImageryProvider#ready} returns true.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._imageryProvider.rectangle;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels.  This function should\n   * not be called before {@link MapboxImageryProvider#ready} returns true.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      return this._imageryProvider.tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link MapboxImageryProvider#ready} returns true.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      return this._imageryProvider.tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link MapboxImageryProvider#ready} returns true.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      return this._imageryProvider.maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link MapboxImageryProvider#ready} returns true. Generally,\n   * a minimum level should only be used when the rectangle of the imagery is small\n   * enough that the number of tiles at the minimum level is small.  An imagery\n   * provider with more than a few tiles at the minimum level will lead to\n   * rendering problems.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      return this._imageryProvider.minimumLevel;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link MapboxImageryProvider#ready} returns true.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._imageryProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link MapboxImageryProvider#ready} returns true.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      return this._imageryProvider.tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error..  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._imageryProvider.errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery. This function should\n   * not be called before {@link MapboxImageryProvider#ready} returns true.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._imageryProvider.credit;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._imageryProvider.proxy;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof MapboxImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return this._imageryProvider.hasAlphaChannel;\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nMapboxImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link MapboxImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nMapboxImageryProvider.prototype.requestImage = function (x, y, level, request) {\n  return this._imageryProvider.requestImage(x, y, level, request);\n};\n\n/**\n * Asynchronously determines what features, if any, are located at a given longitude and latitude within\n * a tile.  This function should not be called before {@link MapboxImageryProvider#ready} returns true.\n * This function is optional, so it may not exist on all ImageryProviders.\n *\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n *\n * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.\n */\nMapboxImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return this._imageryProvider.pickFeatures(x, y, level, longitude, latitude);\n};\n\n// Exposed for tests\nMapboxImageryProvider._defaultCredit = defaultCredit;\nexport default MapboxImageryProvider;\n","import Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Resource from \"../Core/Resource.js\";\nimport UrlTemplateImageryProvider from \"./UrlTemplateImageryProvider.js\";\n\nconst trailingSlashRegex = /\\/$/;\nconst defaultCredit = new Credit(\n  '&copy; <a href=\"https://www.mapbox.com/about/maps/\">Mapbox</a> &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> <strong><a href=\"https://www.mapbox.com/map-feedback/\">Improve this map</a></strong>'\n);\n\n/**\n * @typedef {Object} MapboxStyleImageryProvider.ConstructorOptions\n *\n * Initialization options for the MapboxStyleImageryProvider constructor\n *\n * @property {Resource|String} [url='https://api.mapbox.com/styles/v1/'] The Mapbox server url.\n * @property {String} [username='mapbox'] The username of the map account.\n * @property {String} styleId The Mapbox Style ID.\n * @property {String} accessToken The public access token for the imagery.\n * @property {Number} [tilesize=512] The size of the image tiles.\n * @property {Boolean} [scaleFactor] Determines if tiles are rendered at a @2x scale factor.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @property {Number} [minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying\n *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely\n *                 to result in rendering problems.\n * @property {Number} [maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.\n * @property {Rectangle} [rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.\n * @property {Credit|String} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * Provides tiled imagery hosted by Mapbox.\n *\n * @alias MapboxStyleImageryProvider\n * @constructor\n *\n * @param {MapboxStyleImageryProvider.ConstructorOptions} options Object describing initialization options\n *\n * @example\n * // Mapbox style provider\n * const mapbox = new Cesium.MapboxStyleImageryProvider({\n *     styleId: 'streets-v11',\n *     accessToken: 'thisIsMyAccessToken'\n * });\n *\n * @see {@link https://docs.mapbox.com/api/maps/#styles}\n * @see {@link https://docs.mapbox.com/api/#access-tokens-and-token-scopes}\n */\nfunction MapboxStyleImageryProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const styleId = options.styleId;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(styleId)) {\n    throw new DeveloperError(\"options.styleId is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const accessToken = options.accessToken;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(accessToken)) {\n    throw new DeveloperError(\"options.accessToken is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * The default alpha blending value of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultNightAlpha = undefined;\n\n  /**\n   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and\n   * 1.0 representing fully opaque.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultDayAlpha = undefined;\n\n  /**\n   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0\n   * makes the imagery darker while greater than 1.0 makes it brighter.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultBrightness = undefined;\n\n  /**\n   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces\n   * the contrast while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultContrast = undefined;\n\n  /**\n   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultHue = undefined;\n\n  /**\n   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the\n   * saturation while greater than 1.0 increases it.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultSaturation = undefined;\n\n  /**\n   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.\n   *\n   * @type {Number|undefined}\n   * @default undefined\n   */\n  this.defaultGamma = undefined;\n\n  /**\n   * The default texture minification filter to apply to this provider.\n   *\n   * @type {TextureMinificationFilter}\n   * @default undefined\n   */\n  this.defaultMinificationFilter = undefined;\n\n  /**\n   * The default texture magnification filter to apply to this provider.\n   *\n   * @type {TextureMagnificationFilter}\n   * @default undefined\n   */\n  this.defaultMagnificationFilter = undefined;\n\n  const resource = Resource.createIfNeeded(\n    defaultValue(options.url, \"https://api.mapbox.com/styles/v1/\")\n  );\n\n  this._styleId = styleId;\n  this._accessToken = accessToken;\n\n  const tilesize = defaultValue(options.tilesize, 512);\n  this._tilesize = tilesize;\n\n  const username = defaultValue(options.username, \"mapbox\");\n  this._username = username;\n\n  const scaleFactor = defined(options.scaleFactor) ? \"@2x\" : \"\";\n\n  let templateUrl = resource.getUrlComponent();\n  if (!trailingSlashRegex.test(templateUrl)) {\n    templateUrl += \"/\";\n  }\n  templateUrl += `${this._username}/${styleId}/tiles/${this._tilesize}/{z}/{x}/{y}${scaleFactor}`;\n  resource.url = templateUrl;\n\n  resource.setQueryParameters({\n    access_token: accessToken,\n  });\n\n  let credit;\n  if (defined(options.credit)) {\n    credit = options.credit;\n    if (typeof credit === \"string\") {\n      credit = new Credit(credit);\n    }\n  } else {\n    credit = defaultCredit;\n  }\n\n  this._resource = resource;\n  this._imageryProvider = new UrlTemplateImageryProvider({\n    url: resource,\n    credit: credit,\n    ellipsoid: options.ellipsoid,\n    minimumLevel: options.minimumLevel,\n    maximumLevel: options.maximumLevel,\n    rectangle: options.rectangle,\n  });\n}\n\nObject.defineProperties(MapboxStyleImageryProvider.prototype, {\n  /**\n   * Gets the URL of the Mapbox server.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._imageryProvider.url;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._imageryProvider.ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._imageryProvider.readyPromise;\n    },\n  },\n\n  /**\n   * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should\n   * not be called before {@link MapboxStyleImageryProvider#ready} returns true.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  rectangle: {\n    get: function () {\n      return this._imageryProvider.rectangle;\n    },\n  },\n\n  /**\n   * Gets the width of each tile, in pixels.  This function should\n   * not be called before {@link MapboxStyleImageryProvider#ready} returns true.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileWidth: {\n    get: function () {\n      return this._imageryProvider.tileWidth;\n    },\n  },\n\n  /**\n   * Gets the height of each tile, in pixels.  This function should\n   * not be called before {@link MapboxStyleImageryProvider#ready} returns true.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  tileHeight: {\n    get: function () {\n      return this._imageryProvider.tileHeight;\n    },\n  },\n\n  /**\n   * Gets the maximum level-of-detail that can be requested.  This function should\n   * not be called before {@link MapboxStyleImageryProvider#ready} returns true.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Number|undefined}\n   * @readonly\n   */\n  maximumLevel: {\n    get: function () {\n      return this._imageryProvider.maximumLevel;\n    },\n  },\n\n  /**\n   * Gets the minimum level-of-detail that can be requested.  This function should\n   * not be called before {@link MapboxStyleImageryProvider#ready} returns true. Generally,\n   * a minimum level should only be used when the rectangle of the imagery is small\n   * enough that the number of tiles at the minimum level is small.  An imagery\n   * provider with more than a few tiles at the minimum level will lead to\n   * rendering problems.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumLevel: {\n    get: function () {\n      return this._imageryProvider.minimumLevel;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link MapboxStyleImageryProvider#ready} returns true.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._imageryProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets the tile discard policy.  If not undefined, the discard policy is responsible\n   * for filtering out \"missing\" tiles via its shouldDiscardImage function.  If this function\n   * returns undefined, no tiles are filtered.  This function should\n   * not be called before {@link MapboxStyleImageryProvider#ready} returns true.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {TileDiscardPolicy}\n   * @readonly\n   */\n  tileDiscardPolicy: {\n    get: function () {\n      return this._imageryProvider.tileDiscardPolicy;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error..  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._imageryProvider.errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit\n   * the source of the imagery. This function should\n   * not be called before {@link MapboxStyleImageryProvider#ready} returns true.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._imageryProvider.credit;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._imageryProvider.proxy;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the images provided by this imagery provider\n   * include an alpha channel.  If this property is false, an alpha channel, if present, will\n   * be ignored.  If this property is true, any images without an alpha channel will be treated\n   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage\n   * and texture upload time are reduced.\n   * @memberof MapboxStyleImageryProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasAlphaChannel: {\n    get: function () {\n      return this._imageryProvider.hasAlphaChannel;\n    },\n  },\n});\n\n/**\n * Gets the credits to be displayed when a given tile is displayed.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level;\n * @returns {Credit[]} The credits to be displayed when the tile is displayed.\n *\n * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.\n */\nMapboxStyleImageryProvider.prototype.getTileCredits = function (x, y, level) {\n  return undefined;\n};\n\n/**\n * Requests the image for a given tile.  This function should\n * not be called before {@link MapboxStyleImageryProvider#ready} returns true.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<ImageryTypes>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if there are too many active requests to the server, and the request should be retried later.\n *\n * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.\n */\nMapboxStyleImageryProvider.prototype.requestImage = function (\n  x,\n  y,\n  level,\n  request\n) {\n  return this._imageryProvider.requestImage(x, y, level, request);\n};\n\n/**\n * Asynchronously determines what features, if any, are located at a given longitude and latitude within\n * a tile.  This function should not be called before {@link MapboxStyleImageryProvider#ready} returns true.\n * This function is optional, so it may not exist on all ImageryProviders.\n *\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Number} longitude The longitude at which to pick features.\n * @param {Number} latitude  The latitude at which to pick features.\n * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous\n *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}\n *                   instances.  The array may be empty if no features are found at the given location.\n *                   It may also be undefined if picking is not supported.\n *\n * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.\n */\nMapboxStyleImageryProvider.prototype.pickFeatures = function (\n  x,\n  y,\n  level,\n  longitude,\n  latitude\n) {\n  return this._imageryProvider.pickFeatures(x, y, level, longitude, latitude);\n};\n\n// Exposed for tests\nMapboxStyleImageryProvider._defaultCredit = defaultCredit;\nexport default MapboxStyleImageryProvider;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport loadKTX2 from \"../Core/loadKTX2.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport CubeMap from \"../Renderer/CubeMap.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport AspectRampMaterial from \"../Shaders/Materials/AspectRampMaterial.js\";\nimport BumpMapMaterial from \"../Shaders/Materials/BumpMapMaterial.js\";\nimport CheckerboardMaterial from \"../Shaders/Materials/CheckerboardMaterial.js\";\nimport DotMaterial from \"../Shaders/Materials/DotMaterial.js\";\nimport ElevationBandMaterial from \"../Shaders/Materials/ElevationBandMaterial.js\";\nimport ElevationContourMaterial from \"../Shaders/Materials/ElevationContourMaterial.js\";\nimport ElevationRampMaterial from \"../Shaders/Materials/ElevationRampMaterial.js\";\nimport FadeMaterial from \"../Shaders/Materials/FadeMaterial.js\";\nimport GridMaterial from \"../Shaders/Materials/GridMaterial.js\";\nimport NormalMapMaterial from \"../Shaders/Materials/NormalMapMaterial.js\";\nimport PolylineArrowMaterial from \"../Shaders/Materials/PolylineArrowMaterial.js\";\nimport PolylineDashMaterial from \"../Shaders/Materials/PolylineDashMaterial.js\";\nimport PolylineGlowMaterial from \"../Shaders/Materials/PolylineGlowMaterial.js\";\nimport PolylineOutlineMaterial from \"../Shaders/Materials/PolylineOutlineMaterial.js\";\nimport RimLightingMaterial from \"../Shaders/Materials/RimLightingMaterial.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport SlopeRampMaterial from \"../Shaders/Materials/SlopeRampMaterial.js\";\nimport StripeMaterial from \"../Shaders/Materials/StripeMaterial.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport WaterMaterial from \"../Shaders/Materials/Water.js\";\n\n/**\n * A Material defines surface appearance through a combination of diffuse, specular,\n * normal, emission, and alpha components. These values are specified using a\n * JSON schema called Fabric which gets parsed and assembled into glsl shader code\n * behind-the-scenes. Check out the {@link https://github.com/CesiumGS/cesium/wiki/Fabric|wiki page}\n * for more details on Fabric.\n * <br /><br />\n * <style type=\"text/css\">\n *  #materialDescriptions code {\n *      font-weight: normal;\n *      font-family: Consolas, 'Lucida Console', Monaco, monospace;\n *      color: #A35A00;\n *  }\n *  #materialDescriptions ul, #materialDescriptions ul ul {\n *      list-style-type: none;\n *  }\n *  #materialDescriptions ul ul {\n *      margin-bottom: 10px;\n *  }\n *  #materialDescriptions ul ul li {\n *      font-weight: normal;\n *      color: #000000;\n *      text-indent: -2em;\n *      margin-left: 2em;\n *  }\n *  #materialDescriptions ul li {\n *      font-weight: bold;\n *      color: #0053CF;\n *  }\n * </style>\n *\n * Base material types and their uniforms:\n * <div id='materialDescriptions'>\n * <ul>\n *  <li>Color</li>\n *  <ul>\n *      <li><code>color</code>:  rgba color object.</li>\n *  </ul>\n *  <li>Image</li>\n *  <ul>\n *      <li><code>image</code>:  path to image.</li>\n *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>\n *  </ul>\n *  <li>DiffuseMap</li>\n *  <ul>\n *      <li><code>image</code>:  path to image.</li>\n *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels.</li>\n *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>\n *  </ul>\n *  <li>AlphaMap</li>\n *  <ul>\n *      <li><code>image</code>:  path to image.</li>\n *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>\n *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>\n *  </ul>\n *  <li>SpecularMap</li>\n *  <ul>\n *      <li><code>image</code>: path to image.</li>\n *      <li><code>channel</code>: One character string containing r, g, b, or a for selecting the desired image channel. </li>\n *      <li><code>repeat</code>: Object with x and y values specifying the number of times to repeat the image.</li>\n *  </ul>\n *  <li>EmissionMap</li>\n *  <ul>\n *      <li><code>image</code>:  path to image.</li>\n *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>\n *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>\n *  </ul>\n *  <li>BumpMap</li>\n *  <ul>\n *      <li><code>image</code>:  path to image.</li>\n *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>\n *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>\n *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>\n *  </ul>\n *  <li>NormalMap</li>\n *  <ul>\n *      <li><code>image</code>:  path to image.</li>\n *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>\n *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>\n *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>\n *  </ul>\n *  <li>Grid</li>\n *  <ul>\n *      <li><code>color</code>:  rgba color object for the whole material.</li>\n *      <li><code>cellAlpha</code>: Alpha value for the cells between grid lines.  This will be combined with color.alpha.</li>\n *      <li><code>lineCount</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>\n *      <li><code>lineThickness</code>:  Object with x and y values specifying the thickness of grid lines (in pixels where available).</li>\n *      <li><code>lineOffset</code>:  Object with x and y values specifying the offset of grid lines (range is 0 to 1).</li>\n *  </ul>\n *  <li>Stripe</li>\n *  <ul>\n *      <li><code>horizontal</code>:  Boolean that determines if the stripes are horizontal or vertical.</li>\n *      <li><code>evenColor</code>:  rgba color object for the stripe's first color.</li>\n *      <li><code>oddColor</code>:  rgba color object for the stripe's second color.</li>\n *      <li><code>offset</code>:  Number that controls at which point into the pattern to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning of the odd color, 2.0 being the even color again, and any multiple or fractional values being in between.</li>\n *      <li><code>repeat</code>:  Number that controls the total number of stripes, half light and half dark.</li>\n *  </ul>\n *  <li>Checkerboard</li>\n *  <ul>\n *      <li><code>lightColor</code>:  rgba color object for the checkerboard's light alternating color.</li>\n *      <li><code>darkColor</code>: rgba color object for the checkerboard's dark alternating color.</li>\n *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>\n *  </ul>\n *  <li>Dot</li>\n *  <ul>\n *      <li><code>lightColor</code>:  rgba color object for the dot color.</li>\n *      <li><code>darkColor</code>:  rgba color object for the background color.</li>\n *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows of dots respectively.</li>\n *  </ul>\n *  <li>Water</li>\n *  <ul>\n *      <li><code>baseWaterColor</code>:  rgba color object base color of the water.</li>\n *      <li><code>blendColor</code>:  rgba color object used when blending from water to non-water areas.</li>\n *      <li><code>specularMap</code>:  Single channel texture used to indicate areas of water.</li>\n *      <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>\n *      <li><code>frequency</code>:  Number that controls the number of waves.</li>\n *      <li><code>animationSpeed</code>:  Number that controls the animations speed of the water.</li>\n *      <li><code>amplitude</code>:  Number that controls the amplitude of water waves.</li>\n *      <li><code>specularIntensity</code>:  Number that controls the intensity of specular reflections.</li>\n *  </ul>\n *  <li>RimLighting</li>\n *  <ul>\n *      <li><code>color</code>:  diffuse color and alpha.</li>\n *      <li><code>rimColor</code>:  diffuse color and alpha of the rim.</li>\n *      <li><code>width</code>:  Number that determines the rim's width.</li>\n *  </ul>\n *  <li>Fade</li>\n *  <ul>\n *      <li><code>fadeInColor</code>: diffuse color and alpha at <code>time</code></li>\n *      <li><code>fadeOutColor</code>: diffuse color and alpha at <code>maximumDistance</code> from <code>time</code></li>\n *      <li><code>maximumDistance</code>: Number between 0.0 and 1.0 where the <code>fadeInColor</code> becomes the <code>fadeOutColor</code>. A value of 0.0 gives the entire material a color of <code>fadeOutColor</code> and a value of 1.0 gives the the entire material a color of <code>fadeInColor</code></li>\n *      <li><code>repeat</code>: true if the fade should wrap around the texture coodinates.</li>\n *      <li><code>fadeDirection</code>: Object with x and y values specifying if the fade should be in the x and y directions.</li>\n *      <li><code>time</code>: Object with x and y values between 0.0 and 1.0 of the <code>fadeInColor</code> position</li>\n *  </ul>\n *  <li>PolylineArrow</li>\n *  <ul>\n *      <li><code>color</code>: diffuse color and alpha.</li>\n *  </ul>\n *  <li>PolylineDash</li>\n *  <ul>\n *      <li><code>color</code>: color for the line.</li>\n *      <li><code>gapColor</code>: color for the gaps in the line.</li>\n *      <li><code>dashLength</code>: Dash length in pixels.</li>\n *      <li><code>dashPattern</code>: The 16 bit stipple pattern for the line..</li>\n *  </ul>\n *  <li>PolylineGlow</li>\n *  <ul>\n *      <li><code>color</code>: color and maximum alpha for the glow on the line.</li>\n *      <li><code>glowPower</code>: strength of the glow, as a percentage of the total line width (less than 1.0).</li>\n *      <li><code>taperPower</code>: strength of the tapering effect, as a percentage of the total line length.  If 1.0 or higher, no taper effect is used.</li>\n *  </ul>\n *  <li>PolylineOutline</li>\n *  <ul>\n *      <li><code>color</code>: diffuse color and alpha for the interior of the line.</li>\n *      <li><code>outlineColor</code>: diffuse color and alpha for the outline.</li>\n *      <li><code>outlineWidth</code>: width of the outline in pixels.</li>\n *  </ul>\n *  <li>ElevationContour</li>\n *  <ul>\n *      <li><code>color</code>: color and alpha for the contour line.</li>\n *      <li><code>spacing</code>: spacing for contour lines in meters.</li>\n *      <li><code>width</code>: Number specifying the width of the grid lines in pixels.</li>\n *  </ul>\n *  <li>ElevationRamp</li>\n *  <ul>\n *      <li><code>image</code>: color ramp image to use for coloring the terrain.</li>\n *      <li><code>minimumHeight</code>: minimum height for the ramp.</li>\n *      <li><code>maximumHeight</code>: maximum height for the ramp.</li>\n *  </ul>\n *  <li>SlopeRamp</li>\n *  <ul>\n *      <li><code>image</code>: color ramp image to use for coloring the terrain by slope.</li>\n *  </ul>\n *  <li>AspectRamp</li>\n *  <ul>\n *      <li><code>image</code>: color ramp image to use for color the terrain by aspect.</li>\n *  </ul>\n *  <li>ElevationBand</li>\n *  <ul>\n *      <li><code>heights</code>: image of heights sorted from lowest to highest.</li>\n *      <li><code>colors</code>: image of colors at the corresponding heights.</li>\n * </ul>\n * </ul>\n * </ul>\n * </div>\n *\n * @alias Material\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Boolean} [options.strict=false] Throws errors for issues that would normally be ignored, including unused uniforms or materials.\n * @param {Boolean|Function} [options.translucent=true] When <code>true</code> or a function that returns <code>true</code>, the geometry\n *                           with this material is expected to appear translucent.\n * @param {TextureMinificationFilter} [options.minificationFilter=TextureMinificationFilter.LINEAR] The {@link TextureMinificationFilter} to apply to this material's textures.\n * @param {TextureMagnificationFilter} [options.magnificationFilter=TextureMagnificationFilter.LINEAR] The {@link TextureMagnificationFilter} to apply to this material's textures.\n * @param {Object} options.fabric The fabric JSON used to generate the material.\n *\n * @constructor\n *\n * @exception {DeveloperError} fabric: uniform has invalid type.\n * @exception {DeveloperError} fabric: uniforms and materials cannot share the same property.\n * @exception {DeveloperError} fabric: cannot have source and components in the same section.\n * @exception {DeveloperError} fabric: property name is not valid. It should be 'type', 'materials', 'uniforms', 'components', or 'source'.\n * @exception {DeveloperError} fabric: property name is not valid. It should be 'diffuse', 'specular', 'shininess', 'normal', 'emission', or 'alpha'.\n * @exception {DeveloperError} strict: shader source does not use string.\n * @exception {DeveloperError} strict: shader source does not use uniform.\n * @exception {DeveloperError} strict: shader source does not use material.\n *\n * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric wiki page} for a more detailed options of Fabric.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Materials.html|Cesium Sandcastle Materials Demo}\n *\n * @example\n * // Create a color material with fromType:\n * polygon.material = Cesium.Material.fromType('Color');\n * polygon.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);\n *\n * // Create the default material:\n * polygon.material = new Cesium.Material();\n *\n * // Create a color material with full Fabric notation:\n * polygon.material = new Cesium.Material({\n *     fabric : {\n *         type : 'Color',\n *         uniforms : {\n *             color : new Cesium.Color(1.0, 1.0, 0.0, 1.0)\n *         }\n *     }\n * });\n */\nfunction Material(options) {\n  /**\n   * The material type. Can be an existing type or a new type. If no type is specified in fabric, type is a GUID.\n   * @type {String}\n   * @default undefined\n   */\n  this.type = undefined;\n\n  /**\n   * The glsl shader source for this material.\n   * @type {String}\n   * @default undefined\n   */\n  this.shaderSource = undefined;\n\n  /**\n   * Maps sub-material names to Material objects.\n   * @type {Object}\n   * @default undefined\n   */\n  this.materials = undefined;\n\n  /**\n   * Maps uniform names to their values.\n   * @type {Object}\n   * @default undefined\n   */\n  this.uniforms = undefined;\n  this._uniforms = undefined;\n\n  /**\n   * When <code>true</code> or a function that returns <code>true</code>,\n   * the geometry is expected to appear translucent.\n   * @type {Boolean|Function}\n   * @default undefined\n   */\n  this.translucent = undefined;\n\n  this._minificationFilter = defaultValue(\n    options.minificationFilter,\n    TextureMinificationFilter.LINEAR\n  );\n  this._magnificationFilter = defaultValue(\n    options.magnificationFilter,\n    TextureMagnificationFilter.LINEAR\n  );\n\n  this._strict = undefined;\n  this._template = undefined;\n  this._count = undefined;\n\n  this._texturePaths = {};\n  this._loadedImages = [];\n  this._loadedCubeMaps = [];\n\n  this._textures = {};\n\n  this._updateFunctions = [];\n\n  this._defaultTexture = undefined;\n\n  initializeMaterial(options, this);\n  Object.defineProperties(this, {\n    type: {\n      value: this.type,\n      writable: false,\n    },\n  });\n\n  if (!defined(Material._uniformList[this.type])) {\n    Material._uniformList[this.type] = Object.keys(this._uniforms);\n  }\n}\n\n// Cached list of combined uniform names indexed by type.\n// Used to get the list of uniforms in the same order.\nMaterial._uniformList = {};\n\n/**\n * Creates a new material using an existing material type.\n * <br /><br />\n * Shorthand for: new Material({fabric : {type : type}});\n *\n * @param {String} type The base material type.\n * @param {Object} [uniforms] Overrides for the default uniforms.\n * @returns {Material} New material object.\n *\n * @exception {DeveloperError} material with that type does not exist.\n *\n * @example\n * const material = Cesium.Material.fromType('Color', {\n *     color : new Cesium.Color(1.0, 0.0, 0.0, 1.0)\n * });\n */\nMaterial.fromType = function (type, uniforms) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(Material._materialCache.getMaterial(type))) {\n    throw new DeveloperError(`material with type '${type}' does not exist.`);\n  }\n  //>>includeEnd('debug');\n\n  const material = new Material({\n    fabric: {\n      type: type,\n    },\n  });\n\n  if (defined(uniforms)) {\n    for (const name in uniforms) {\n      if (uniforms.hasOwnProperty(name)) {\n        material.uniforms[name] = uniforms[name];\n      }\n    }\n  }\n\n  return material;\n};\n\n/**\n * Gets whether or not this material is translucent.\n * @returns {Boolean} <code>true</code> if this material is translucent, <code>false</code> otherwise.\n */\nMaterial.prototype.isTranslucent = function () {\n  if (defined(this.translucent)) {\n    if (typeof this.translucent === \"function\") {\n      return this.translucent();\n    }\n\n    return this.translucent;\n  }\n\n  let translucent = true;\n  const funcs = this._translucentFunctions;\n  const length = funcs.length;\n  for (let i = 0; i < length; ++i) {\n    const func = funcs[i];\n    if (typeof func === \"function\") {\n      translucent = translucent && func();\n    } else {\n      translucent = translucent && func;\n    }\n\n    if (!translucent) {\n      break;\n    }\n  }\n  return translucent;\n};\n\n/**\n * @private\n */\nMaterial.prototype.update = function (context) {\n  this._defaultTexture = context.defaultTexture;\n\n  let i;\n  let uniformId;\n\n  const loadedImages = this._loadedImages;\n  let length = loadedImages.length;\n  for (i = 0; i < length; ++i) {\n    const loadedImage = loadedImages[i];\n    uniformId = loadedImage.id;\n    let image = loadedImage.image;\n\n    // Images transcoded from KTX2 can contain multiple mip levels:\n    // https://github.khronos.org/KTX-Specification/#_mip_level_array\n    let mipLevels;\n    if (Array.isArray(image)) {\n      // highest detail mip should be level 0\n      mipLevels = image.slice(1, image.length).map(function (mipLevel) {\n        return mipLevel.bufferView;\n      });\n      image = image[0];\n    }\n\n    const sampler = new Sampler({\n      minificationFilter: this._minificationFilter,\n      magnificationFilter: this._magnificationFilter,\n    });\n\n    let texture;\n    if (defined(image.internalFormat)) {\n      texture = new Texture({\n        context: context,\n        pixelFormat: image.internalFormat,\n        width: image.width,\n        height: image.height,\n        source: {\n          arrayBufferView: image.bufferView,\n          mipLevels: mipLevels,\n        },\n        sampler: sampler,\n      });\n    } else {\n      texture = new Texture({\n        context: context,\n        source: image,\n        sampler: sampler,\n      });\n    }\n\n    // The material destroys its old texture only after the new one has been loaded.\n    // This will ensure a smooth swap of textures and prevent the default texture\n    // from appearing for a few frames.\n    const oldTexture = this._textures[uniformId];\n    if (defined(oldTexture) && oldTexture !== this._defaultTexture) {\n      oldTexture.destroy();\n    }\n\n    this._textures[uniformId] = texture;\n\n    const uniformDimensionsName = `${uniformId}Dimensions`;\n    if (this.uniforms.hasOwnProperty(uniformDimensionsName)) {\n      const uniformDimensions = this.uniforms[uniformDimensionsName];\n      uniformDimensions.x = texture._width;\n      uniformDimensions.y = texture._height;\n    }\n  }\n\n  loadedImages.length = 0;\n\n  const loadedCubeMaps = this._loadedCubeMaps;\n  length = loadedCubeMaps.length;\n\n  for (i = 0; i < length; ++i) {\n    const loadedCubeMap = loadedCubeMaps[i];\n    uniformId = loadedCubeMap.id;\n    const images = loadedCubeMap.images;\n\n    const cubeMap = new CubeMap({\n      context: context,\n      source: {\n        positiveX: images[0],\n        negativeX: images[1],\n        positiveY: images[2],\n        negativeY: images[3],\n        positiveZ: images[4],\n        negativeZ: images[5],\n      },\n      sampler: new Sampler({\n        minificationFilter: this._minificationFilter,\n        magnificationFilter: this._magnificationFilter,\n      }),\n    });\n\n    this._textures[uniformId] = cubeMap;\n  }\n\n  loadedCubeMaps.length = 0;\n\n  const updateFunctions = this._updateFunctions;\n  length = updateFunctions.length;\n  for (i = 0; i < length; ++i) {\n    updateFunctions[i](this, context);\n  }\n\n  const subMaterials = this.materials;\n  for (const name in subMaterials) {\n    if (subMaterials.hasOwnProperty(name)) {\n      subMaterials[name].update(context);\n    }\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see Material#destroy\n */\nMaterial.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * material = material && material.destroy();\n *\n * @see Material#isDestroyed\n */\nMaterial.prototype.destroy = function () {\n  const textures = this._textures;\n  for (const texture in textures) {\n    if (textures.hasOwnProperty(texture)) {\n      const instance = textures[texture];\n      if (instance !== this._defaultTexture) {\n        instance.destroy();\n      }\n    }\n  }\n\n  const materials = this.materials;\n  for (const material in materials) {\n    if (materials.hasOwnProperty(material)) {\n      materials[material].destroy();\n    }\n  }\n  return destroyObject(this);\n};\n\nfunction initializeMaterial(options, result) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  result._strict = defaultValue(options.strict, false);\n  result._count = defaultValue(options.count, 0);\n  result._template = clone(\n    defaultValue(options.fabric, defaultValue.EMPTY_OBJECT)\n  );\n  result._template.uniforms = clone(\n    defaultValue(result._template.uniforms, defaultValue.EMPTY_OBJECT)\n  );\n  result._template.materials = clone(\n    defaultValue(result._template.materials, defaultValue.EMPTY_OBJECT)\n  );\n\n  result.type = defined(result._template.type)\n    ? result._template.type\n    : createGuid();\n\n  result.shaderSource = \"\";\n  result.materials = {};\n  result.uniforms = {};\n  result._uniforms = {};\n  result._translucentFunctions = [];\n\n  let translucent;\n\n  // If the cache contains this material type, build the material template off of the stored template.\n  const cachedMaterial = Material._materialCache.getMaterial(result.type);\n  if (defined(cachedMaterial)) {\n    const template = clone(cachedMaterial.fabric, true);\n    result._template = combine(result._template, template, true);\n    translucent = cachedMaterial.translucent;\n  }\n\n  // Make sure the template has no obvious errors. More error checking happens later.\n  checkForTemplateErrors(result);\n\n  // If the material has a new type, add it to the cache.\n  if (!defined(cachedMaterial)) {\n    Material._materialCache.addMaterial(result.type, result);\n  }\n\n  createMethodDefinition(result);\n  createUniforms(result);\n  createSubMaterials(result);\n\n  const defaultTranslucent =\n    result._translucentFunctions.length === 0 ? true : undefined;\n  translucent = defaultValue(translucent, defaultTranslucent);\n  translucent = defaultValue(options.translucent, translucent);\n\n  if (defined(translucent)) {\n    if (typeof translucent === \"function\") {\n      const wrappedTranslucent = function () {\n        return translucent(result);\n      };\n      result._translucentFunctions.push(wrappedTranslucent);\n    } else {\n      result._translucentFunctions.push(translucent);\n    }\n  }\n}\n\nfunction checkForValidProperties(object, properties, result, throwNotFound) {\n  if (defined(object)) {\n    for (const property in object) {\n      if (object.hasOwnProperty(property)) {\n        const hasProperty = properties.indexOf(property) !== -1;\n        if (\n          (throwNotFound && !hasProperty) ||\n          (!throwNotFound && hasProperty)\n        ) {\n          result(property, properties);\n        }\n      }\n    }\n  }\n}\n\nfunction invalidNameError(property, properties) {\n  //>>includeStart('debug', pragmas.debug);\n  let errorString = `fabric: property name '${property}' is not valid. It should be `;\n  for (let i = 0; i < properties.length; i++) {\n    const propertyName = `'${properties[i]}'`;\n    errorString +=\n      i === properties.length - 1 ? `or ${propertyName}.` : `${propertyName}, `;\n  }\n  throw new DeveloperError(errorString);\n  //>>includeEnd('debug');\n}\n\nfunction duplicateNameError(property, properties) {\n  //>>includeStart('debug', pragmas.debug);\n  const errorString = `fabric: uniforms and materials cannot share the same property '${property}'`;\n  throw new DeveloperError(errorString);\n  //>>includeEnd('debug');\n}\n\nconst templateProperties = [\n  \"type\",\n  \"materials\",\n  \"uniforms\",\n  \"components\",\n  \"source\",\n];\nconst componentProperties = [\n  \"diffuse\",\n  \"specular\",\n  \"shininess\",\n  \"normal\",\n  \"emission\",\n  \"alpha\",\n];\n\nfunction checkForTemplateErrors(material) {\n  const template = material._template;\n  const uniforms = template.uniforms;\n  const materials = template.materials;\n  const components = template.components;\n\n  // Make sure source and components do not exist in the same template.\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(components) && defined(template.source)) {\n    throw new DeveloperError(\n      \"fabric: cannot have source and components in the same template.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Make sure all template and components properties are valid.\n  checkForValidProperties(template, templateProperties, invalidNameError, true);\n  checkForValidProperties(\n    components,\n    componentProperties,\n    invalidNameError,\n    true\n  );\n\n  // Make sure uniforms and materials do not share any of the same names.\n  const materialNames = [];\n  for (const property in materials) {\n    if (materials.hasOwnProperty(property)) {\n      materialNames.push(property);\n    }\n  }\n  checkForValidProperties(uniforms, materialNames, duplicateNameError, false);\n}\n\nfunction isMaterialFused(shaderComponent, material) {\n  const materials = material._template.materials;\n  for (const subMaterialId in materials) {\n    if (materials.hasOwnProperty(subMaterialId)) {\n      if (shaderComponent.indexOf(subMaterialId) > -1) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n// Create the czm_getMaterial method body using source or components.\nfunction createMethodDefinition(material) {\n  const components = material._template.components;\n  const source = material._template.source;\n  if (defined(source)) {\n    material.shaderSource += `${source}\\n`;\n  } else {\n    material.shaderSource +=\n      \"czm_material czm_getMaterial(czm_materialInput materialInput)\\n{\\n\";\n    material.shaderSource +=\n      \"czm_material material = czm_getDefaultMaterial(materialInput);\\n\";\n    if (defined(components)) {\n      const isMultiMaterial =\n        Object.keys(material._template.materials).length > 0;\n      for (const component in components) {\n        if (components.hasOwnProperty(component)) {\n          if (component === \"diffuse\" || component === \"emission\") {\n            const isFusion =\n              isMultiMaterial &&\n              isMaterialFused(components[component], material);\n            const componentSource = isFusion\n              ? components[component]\n              : `czm_gammaCorrect(${components[component]})`;\n            material.shaderSource += `material.${component} = ${componentSource}; \\n`;\n          } else if (component === \"alpha\") {\n            material.shaderSource += `material.alpha = ${components.alpha}; \\n`;\n          } else {\n            material.shaderSource += `material.${component} = ${components[component]};\\n`;\n          }\n        }\n      }\n    }\n    material.shaderSource += \"return material;\\n}\\n\";\n  }\n}\n\nconst matrixMap = {\n  mat2: Matrix2,\n  mat3: Matrix3,\n  mat4: Matrix4,\n};\n\nconst ktx2Regex = /\\.ktx2$/i;\n\nfunction createTexture2DUpdateFunction(uniformId) {\n  let oldUniformValue;\n  return function (material, context) {\n    const uniforms = material.uniforms;\n    const uniformValue = uniforms[uniformId];\n    const uniformChanged = oldUniformValue !== uniformValue;\n    const uniformValueIsDefaultImage =\n      !defined(uniformValue) || uniformValue === Material.DefaultImageId;\n    oldUniformValue = uniformValue;\n\n    let texture = material._textures[uniformId];\n    let uniformDimensionsName;\n    let uniformDimensions;\n\n    if (uniformValue instanceof HTMLVideoElement) {\n      // HTMLVideoElement.readyState >=2 means we have enough data for the current frame.\n      // See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState\n      if (uniformValue.readyState >= 2) {\n        if (uniformChanged && defined(texture)) {\n          if (texture !== context.defaultTexture) {\n            texture.destroy();\n          }\n          texture = undefined;\n        }\n\n        if (!defined(texture) || texture === context.defaultTexture) {\n          const sampler = new Sampler({\n            minificationFilter: material._minificationFilter,\n            magnificationFilter: material._magnificationFilter,\n          });\n          texture = new Texture({\n            context: context,\n            source: uniformValue,\n            sampler: sampler,\n          });\n          material._textures[uniformId] = texture;\n          return;\n        }\n\n        texture.copyFrom({\n          source: uniformValue,\n        });\n      } else if (!defined(texture)) {\n        material._textures[uniformId] = context.defaultTexture;\n      }\n      return;\n    }\n\n    if (uniformValue instanceof Texture && uniformValue !== texture) {\n      material._texturePaths[uniformId] = undefined;\n      const tmp = material._textures[uniformId];\n      if (defined(tmp) && tmp !== material._defaultTexture) {\n        tmp.destroy();\n      }\n      material._textures[uniformId] = uniformValue;\n\n      uniformDimensionsName = `${uniformId}Dimensions`;\n      if (uniforms.hasOwnProperty(uniformDimensionsName)) {\n        uniformDimensions = uniforms[uniformDimensionsName];\n        uniformDimensions.x = uniformValue._width;\n        uniformDimensions.y = uniformValue._height;\n      }\n\n      return;\n    }\n\n    if (uniformChanged && defined(texture) && uniformValueIsDefaultImage) {\n      // If the newly-assigned texture is the default texture,\n      // we don't need to wait for a new image to load before destroying\n      // the old texture.\n      if (texture !== material._defaultTexture) {\n        texture.destroy();\n      }\n      texture = undefined;\n    }\n\n    if (!defined(texture)) {\n      material._texturePaths[uniformId] = undefined;\n      texture = material._textures[uniformId] = material._defaultTexture;\n\n      uniformDimensionsName = `${uniformId}Dimensions`;\n      if (uniforms.hasOwnProperty(uniformDimensionsName)) {\n        uniformDimensions = uniforms[uniformDimensionsName];\n        uniformDimensions.x = texture._width;\n        uniformDimensions.y = texture._height;\n      }\n    }\n\n    if (uniformValueIsDefaultImage) {\n      return;\n    }\n\n    // When using the entity layer, the Resource objects get recreated on getValue because\n    //  they are clonable. That's why we check the url property for Resources\n    //  because the instances aren't the same and we keep trying to load the same\n    //  image if it fails to load.\n    const isResource = uniformValue instanceof Resource;\n    if (\n      !defined(material._texturePaths[uniformId]) ||\n      (isResource &&\n        uniformValue.url !== material._texturePaths[uniformId].url) ||\n      (!isResource && uniformValue !== material._texturePaths[uniformId])\n    ) {\n      if (typeof uniformValue === \"string\" || isResource) {\n        const resource = isResource\n          ? uniformValue\n          : Resource.createIfNeeded(uniformValue);\n\n        let promise;\n        if (ktx2Regex.test(resource.url)) {\n          promise = loadKTX2(resource.url);\n        } else {\n          promise = resource.fetchImage();\n        }\n\n        Promise.resolve(promise)\n          .then(function (image) {\n            material._loadedImages.push({\n              id: uniformId,\n              image: image,\n            });\n          })\n          .catch(function () {\n            if (defined(texture) && texture !== material._defaultTexture) {\n              texture.destroy();\n            }\n            material._textures[uniformId] = material._defaultTexture;\n          });\n      } else if (\n        uniformValue instanceof HTMLCanvasElement ||\n        uniformValue instanceof HTMLImageElement\n      ) {\n        material._loadedImages.push({\n          id: uniformId,\n          image: uniformValue,\n        });\n      }\n\n      material._texturePaths[uniformId] = uniformValue;\n    }\n  };\n}\n\nfunction createCubeMapUpdateFunction(uniformId) {\n  return function (material, context) {\n    const uniformValue = material.uniforms[uniformId];\n\n    if (uniformValue instanceof CubeMap) {\n      const tmp = material._textures[uniformId];\n      if (tmp !== material._defaultTexture) {\n        tmp.destroy();\n      }\n      material._texturePaths[uniformId] = undefined;\n      material._textures[uniformId] = uniformValue;\n      return;\n    }\n\n    if (!defined(material._textures[uniformId])) {\n      material._texturePaths[uniformId] = undefined;\n      material._textures[uniformId] = context.defaultCubeMap;\n    }\n\n    if (uniformValue === Material.DefaultCubeMapId) {\n      return;\n    }\n\n    const path =\n      uniformValue.positiveX +\n      uniformValue.negativeX +\n      uniformValue.positiveY +\n      uniformValue.negativeY +\n      uniformValue.positiveZ +\n      uniformValue.negativeZ;\n\n    if (path !== material._texturePaths[uniformId]) {\n      const promises = [\n        Resource.createIfNeeded(uniformValue.positiveX).fetchImage(),\n        Resource.createIfNeeded(uniformValue.negativeX).fetchImage(),\n        Resource.createIfNeeded(uniformValue.positiveY).fetchImage(),\n        Resource.createIfNeeded(uniformValue.negativeY).fetchImage(),\n        Resource.createIfNeeded(uniformValue.positiveZ).fetchImage(),\n        Resource.createIfNeeded(uniformValue.negativeZ).fetchImage(),\n      ];\n\n      Promise.all(promises).then(function (images) {\n        material._loadedCubeMaps.push({\n          id: uniformId,\n          images: images,\n        });\n      });\n\n      material._texturePaths[uniformId] = path;\n    }\n  };\n}\n\nfunction createUniforms(material) {\n  const uniforms = material._template.uniforms;\n  for (const uniformId in uniforms) {\n    if (uniforms.hasOwnProperty(uniformId)) {\n      createUniform(material, uniformId);\n    }\n  }\n}\n\n// Writes uniform declarations to the shader file and connects uniform values with\n// corresponding material properties through the returnUniforms function.\nfunction createUniform(material, uniformId) {\n  const strict = material._strict;\n  const materialUniforms = material._template.uniforms;\n  const uniformValue = materialUniforms[uniformId];\n  const uniformType = getUniformType(uniformValue);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uniformType)) {\n    throw new DeveloperError(\n      `fabric: uniform '${uniformId}' has invalid type.`\n    );\n  }\n  //>>includeEnd('debug');\n\n  let replacedTokenCount;\n  if (uniformType === \"channels\") {\n    replacedTokenCount = replaceToken(material, uniformId, uniformValue, false);\n    //>>includeStart('debug', pragmas.debug);\n    if (replacedTokenCount === 0 && strict) {\n      throw new DeveloperError(\n        `strict: shader source does not use channels '${uniformId}'.`\n      );\n    }\n    //>>includeEnd('debug');\n  } else {\n    // Since webgl doesn't allow texture dimension queries in glsl, create a uniform to do it.\n    // Check if the shader source actually uses texture dimensions before creating the uniform.\n    if (uniformType === \"sampler2D\") {\n      const imageDimensionsUniformName = `${uniformId}Dimensions`;\n      if (getNumberOfTokens(material, imageDimensionsUniformName) > 0) {\n        materialUniforms[imageDimensionsUniformName] = {\n          type: \"ivec3\",\n          x: 1,\n          y: 1,\n        };\n        createUniform(material, imageDimensionsUniformName);\n      }\n    }\n\n    // Add uniform declaration to source code.\n    const uniformDeclarationRegex = new RegExp(\n      `uniform\\\\s+${uniformType}\\\\s+${uniformId}\\\\s*;`\n    );\n    if (!uniformDeclarationRegex.test(material.shaderSource)) {\n      const uniformDeclaration = `uniform ${uniformType} ${uniformId};`;\n      material.shaderSource = uniformDeclaration + material.shaderSource;\n    }\n\n    const newUniformId = `${uniformId}_${material._count++}`;\n    replacedTokenCount = replaceToken(material, uniformId, newUniformId);\n    //>>includeStart('debug', pragmas.debug);\n    if (replacedTokenCount === 1 && strict) {\n      throw new DeveloperError(\n        `strict: shader source does not use uniform '${uniformId}'.`\n      );\n    }\n    //>>includeEnd('debug');\n\n    // Set uniform value\n    material.uniforms[uniformId] = uniformValue;\n\n    if (uniformType === \"sampler2D\") {\n      material._uniforms[newUniformId] = function () {\n        return material._textures[uniformId];\n      };\n      material._updateFunctions.push(createTexture2DUpdateFunction(uniformId));\n    } else if (uniformType === \"samplerCube\") {\n      material._uniforms[newUniformId] = function () {\n        return material._textures[uniformId];\n      };\n      material._updateFunctions.push(createCubeMapUpdateFunction(uniformId));\n    } else if (uniformType.indexOf(\"mat\") !== -1) {\n      const scratchMatrix = new matrixMap[uniformType]();\n      material._uniforms[newUniformId] = function () {\n        return matrixMap[uniformType].fromColumnMajorArray(\n          material.uniforms[uniformId],\n          scratchMatrix\n        );\n      };\n    } else {\n      material._uniforms[newUniformId] = function () {\n        return material.uniforms[uniformId];\n      };\n    }\n  }\n}\n\n// Determines the uniform type based on the uniform in the template.\nfunction getUniformType(uniformValue) {\n  let uniformType = uniformValue.type;\n  if (!defined(uniformType)) {\n    const type = typeof uniformValue;\n    if (type === \"number\") {\n      uniformType = \"float\";\n    } else if (type === \"boolean\") {\n      uniformType = \"bool\";\n    } else if (\n      type === \"string\" ||\n      uniformValue instanceof Resource ||\n      uniformValue instanceof HTMLCanvasElement ||\n      uniformValue instanceof HTMLImageElement\n    ) {\n      if (/^([rgba]){1,4}$/i.test(uniformValue)) {\n        uniformType = \"channels\";\n      } else if (uniformValue === Material.DefaultCubeMapId) {\n        uniformType = \"samplerCube\";\n      } else {\n        uniformType = \"sampler2D\";\n      }\n    } else if (type === \"object\") {\n      if (Array.isArray(uniformValue)) {\n        if (\n          uniformValue.length === 4 ||\n          uniformValue.length === 9 ||\n          uniformValue.length === 16\n        ) {\n          uniformType = `mat${Math.sqrt(uniformValue.length)}`;\n        }\n      } else {\n        let numAttributes = 0;\n        for (const attribute in uniformValue) {\n          if (uniformValue.hasOwnProperty(attribute)) {\n            numAttributes += 1;\n          }\n        }\n        if (numAttributes >= 2 && numAttributes <= 4) {\n          uniformType = `vec${numAttributes}`;\n        } else if (numAttributes === 6) {\n          uniformType = \"samplerCube\";\n        }\n      }\n    }\n  }\n  return uniformType;\n}\n\n// Create all sub-materials by combining source and uniforms together.\nfunction createSubMaterials(material) {\n  const strict = material._strict;\n  const subMaterialTemplates = material._template.materials;\n  for (const subMaterialId in subMaterialTemplates) {\n    if (subMaterialTemplates.hasOwnProperty(subMaterialId)) {\n      // Construct the sub-material.\n      const subMaterial = new Material({\n        strict: strict,\n        fabric: subMaterialTemplates[subMaterialId],\n        count: material._count,\n      });\n\n      material._count = subMaterial._count;\n      material._uniforms = combine(\n        material._uniforms,\n        subMaterial._uniforms,\n        true\n      );\n      material.materials[subMaterialId] = subMaterial;\n      material._translucentFunctions = material._translucentFunctions.concat(\n        subMaterial._translucentFunctions\n      );\n\n      // Make the material's czm_getMaterial unique by appending the sub-material type.\n      const originalMethodName = \"czm_getMaterial\";\n      const newMethodName = `${originalMethodName}_${material._count++}`;\n      replaceToken(subMaterial, originalMethodName, newMethodName);\n      material.shaderSource = subMaterial.shaderSource + material.shaderSource;\n\n      // Replace each material id with an czm_getMaterial method call.\n      const materialMethodCall = `${newMethodName}(materialInput)`;\n      const tokensReplacedCount = replaceToken(\n        material,\n        subMaterialId,\n        materialMethodCall\n      );\n      //>>includeStart('debug', pragmas.debug);\n      if (tokensReplacedCount === 0 && strict) {\n        throw new DeveloperError(\n          `strict: shader source does not use material '${subMaterialId}'.`\n        );\n      }\n      //>>includeEnd('debug');\n    }\n  }\n}\n\n// Used for searching or replacing a token in a material's shader source with something else.\n// If excludePeriod is true, do not accept tokens that are preceded by periods.\n// http://stackoverflow.com/questions/641407/javascript-negative-lookbehind-equivalent\nfunction replaceToken(material, token, newToken, excludePeriod) {\n  excludePeriod = defaultValue(excludePeriod, true);\n  let count = 0;\n  const suffixChars = \"([\\\\w])?\";\n  const prefixChars = `([\\\\w${excludePeriod ? \".\" : \"\"}])?`;\n  const regExp = new RegExp(prefixChars + token + suffixChars, \"g\");\n  material.shaderSource = material.shaderSource.replace(regExp, function (\n    $0,\n    $1,\n    $2\n  ) {\n    if ($1 || $2) {\n      return $0;\n    }\n    count += 1;\n    return newToken;\n  });\n  return count;\n}\n\nfunction getNumberOfTokens(material, token, excludePeriod) {\n  return replaceToken(material, token, token, excludePeriod);\n}\n\nMaterial._materialCache = {\n  _materials: {},\n  addMaterial: function (type, materialTemplate) {\n    this._materials[type] = materialTemplate;\n  },\n  getMaterial: function (type) {\n    return this._materials[type];\n  },\n};\n\n/**\n * Gets or sets the default texture uniform value.\n * @type {String}\n */\nMaterial.DefaultImageId = \"czm_defaultImage\";\n\n/**\n * Gets or sets the default cube map texture uniform value.\n * @type {String}\n */\nMaterial.DefaultCubeMapId = \"czm_defaultCubeMap\";\n\n/**\n * Gets the name of the color material.\n * @type {String}\n * @readonly\n */\nMaterial.ColorType = \"Color\";\nMaterial._materialCache.addMaterial(Material.ColorType, {\n  fabric: {\n    type: Material.ColorType,\n    uniforms: {\n      color: new Color(1.0, 0.0, 0.0, 0.5),\n    },\n    components: {\n      diffuse: \"color.rgb\",\n      alpha: \"color.a\",\n    },\n  },\n  translucent: function (material) {\n    return material.uniforms.color.alpha < 1.0;\n  },\n});\n\n/**\n * Gets the name of the image material.\n * @type {String}\n * @readonly\n */\nMaterial.ImageType = \"Image\";\nMaterial._materialCache.addMaterial(Material.ImageType, {\n  fabric: {\n    type: Material.ImageType,\n    uniforms: {\n      image: Material.DefaultImageId,\n      repeat: new Cartesian2(1.0, 1.0),\n      color: new Color(1.0, 1.0, 1.0, 1.0),\n    },\n    components: {\n      diffuse:\n        \"texture2D(image, fract(repeat * materialInput.st)).rgb * color.rgb\",\n      alpha: \"texture2D(image, fract(repeat * materialInput.st)).a * color.a\",\n    },\n  },\n  translucent: function (material) {\n    return material.uniforms.color.alpha < 1.0;\n  },\n});\n\n/**\n * Gets the name of the diffuce map material.\n * @type {String}\n * @readonly\n */\nMaterial.DiffuseMapType = \"DiffuseMap\";\nMaterial._materialCache.addMaterial(Material.DiffuseMapType, {\n  fabric: {\n    type: Material.DiffuseMapType,\n    uniforms: {\n      image: Material.DefaultImageId,\n      channels: \"rgb\",\n      repeat: new Cartesian2(1.0, 1.0),\n    },\n    components: {\n      diffuse: \"texture2D(image, fract(repeat * materialInput.st)).channels\",\n    },\n  },\n  translucent: false,\n});\n\n/**\n * Gets the name of the alpha map material.\n * @type {String}\n * @readonly\n */\nMaterial.AlphaMapType = \"AlphaMap\";\nMaterial._materialCache.addMaterial(Material.AlphaMapType, {\n  fabric: {\n    type: Material.AlphaMapType,\n    uniforms: {\n      image: Material.DefaultImageId,\n      channel: \"a\",\n      repeat: new Cartesian2(1.0, 1.0),\n    },\n    components: {\n      alpha: \"texture2D(image, fract(repeat * materialInput.st)).channel\",\n    },\n  },\n  translucent: true,\n});\n\n/**\n * Gets the name of the specular map material.\n * @type {String}\n * @readonly\n */\nMaterial.SpecularMapType = \"SpecularMap\";\nMaterial._materialCache.addMaterial(Material.SpecularMapType, {\n  fabric: {\n    type: Material.SpecularMapType,\n    uniforms: {\n      image: Material.DefaultImageId,\n      channel: \"r\",\n      repeat: new Cartesian2(1.0, 1.0),\n    },\n    components: {\n      specular: \"texture2D(image, fract(repeat * materialInput.st)).channel\",\n    },\n  },\n  translucent: false,\n});\n\n/**\n * Gets the name of the emmision map material.\n * @type {String}\n * @readonly\n */\nMaterial.EmissionMapType = \"EmissionMap\";\nMaterial._materialCache.addMaterial(Material.EmissionMapType, {\n  fabric: {\n    type: Material.EmissionMapType,\n    uniforms: {\n      image: Material.DefaultImageId,\n      channels: \"rgb\",\n      repeat: new Cartesian2(1.0, 1.0),\n    },\n    components: {\n      emission: \"texture2D(image, fract(repeat * materialInput.st)).channels\",\n    },\n  },\n  translucent: false,\n});\n\n/**\n * Gets the name of the bump map material.\n * @type {String}\n * @readonly\n */\nMaterial.BumpMapType = \"BumpMap\";\nMaterial._materialCache.addMaterial(Material.BumpMapType, {\n  fabric: {\n    type: Material.BumpMapType,\n    uniforms: {\n      image: Material.DefaultImageId,\n      channel: \"r\",\n      strength: 0.8,\n      repeat: new Cartesian2(1.0, 1.0),\n    },\n    source: BumpMapMaterial,\n  },\n  translucent: false,\n});\n\n/**\n * Gets the name of the normal map material.\n * @type {String}\n * @readonly\n */\nMaterial.NormalMapType = \"NormalMap\";\nMaterial._materialCache.addMaterial(Material.NormalMapType, {\n  fabric: {\n    type: Material.NormalMapType,\n    uniforms: {\n      image: Material.DefaultImageId,\n      channels: \"rgb\",\n      strength: 0.8,\n      repeat: new Cartesian2(1.0, 1.0),\n    },\n    source: NormalMapMaterial,\n  },\n  translucent: false,\n});\n\n/**\n * Gets the name of the grid material.\n * @type {String}\n * @readonly\n */\nMaterial.GridType = \"Grid\";\nMaterial._materialCache.addMaterial(Material.GridType, {\n  fabric: {\n    type: Material.GridType,\n    uniforms: {\n      color: new Color(0.0, 1.0, 0.0, 1.0),\n      cellAlpha: 0.1,\n      lineCount: new Cartesian2(8.0, 8.0),\n      lineThickness: new Cartesian2(1.0, 1.0),\n      lineOffset: new Cartesian2(0.0, 0.0),\n    },\n    source: GridMaterial,\n  },\n  translucent: function (material) {\n    const uniforms = material.uniforms;\n    return uniforms.color.alpha < 1.0 || uniforms.cellAlpha < 1.0;\n  },\n});\n\n/**\n * Gets the name of the stripe material.\n * @type {String}\n * @readonly\n */\nMaterial.StripeType = \"Stripe\";\nMaterial._materialCache.addMaterial(Material.StripeType, {\n  fabric: {\n    type: Material.StripeType,\n    uniforms: {\n      horizontal: true,\n      evenColor: new Color(1.0, 1.0, 1.0, 0.5),\n      oddColor: new Color(0.0, 0.0, 1.0, 0.5),\n      offset: 0.0,\n      repeat: 5.0,\n    },\n    source: StripeMaterial,\n  },\n  translucent: function (material) {\n    const uniforms = material.uniforms;\n    return uniforms.evenColor.alpha < 1.0 || uniforms.oddColor.alpha < 1.0;\n  },\n});\n\n/**\n * Gets the name of the checkerboard material.\n * @type {String}\n * @readonly\n */\nMaterial.CheckerboardType = \"Checkerboard\";\nMaterial._materialCache.addMaterial(Material.CheckerboardType, {\n  fabric: {\n    type: Material.CheckerboardType,\n    uniforms: {\n      lightColor: new Color(1.0, 1.0, 1.0, 0.5),\n      darkColor: new Color(0.0, 0.0, 0.0, 0.5),\n      repeat: new Cartesian2(5.0, 5.0),\n    },\n    source: CheckerboardMaterial,\n  },\n  translucent: function (material) {\n    const uniforms = material.uniforms;\n    return uniforms.lightColor.alpha < 1.0 || uniforms.darkColor.alpha < 1.0;\n  },\n});\n\n/**\n * Gets the name of the dot material.\n * @type {String}\n * @readonly\n */\nMaterial.DotType = \"Dot\";\nMaterial._materialCache.addMaterial(Material.DotType, {\n  fabric: {\n    type: Material.DotType,\n    uniforms: {\n      lightColor: new Color(1.0, 1.0, 0.0, 0.75),\n      darkColor: new Color(0.0, 1.0, 1.0, 0.75),\n      repeat: new Cartesian2(5.0, 5.0),\n    },\n    source: DotMaterial,\n  },\n  translucent: function (material) {\n    const uniforms = material.uniforms;\n    return uniforms.lightColor.alpha < 1.0 || uniforms.darkColor.alpha < 1.0;\n  },\n});\n\n/**\n * Gets the name of the water material.\n * @type {String}\n * @readonly\n */\nMaterial.WaterType = \"Water\";\nMaterial._materialCache.addMaterial(Material.WaterType, {\n  fabric: {\n    type: Material.WaterType,\n    uniforms: {\n      baseWaterColor: new Color(0.2, 0.3, 0.6, 1.0),\n      blendColor: new Color(0.0, 1.0, 0.699, 1.0),\n      specularMap: Material.DefaultImageId,\n      normalMap: Material.DefaultImageId,\n      frequency: 10.0,\n      animationSpeed: 0.01,\n      amplitude: 1.0,\n      specularIntensity: 0.5,\n      fadeFactor: 1.0,\n    },\n    source: WaterMaterial,\n  },\n  translucent: function (material) {\n    const uniforms = material.uniforms;\n    return (\n      uniforms.baseWaterColor.alpha < 1.0 || uniforms.blendColor.alpha < 1.0\n    );\n  },\n});\n\n/**\n * Gets the name of the rim lighting material.\n * @type {String}\n * @readonly\n */\nMaterial.RimLightingType = \"RimLighting\";\nMaterial._materialCache.addMaterial(Material.RimLightingType, {\n  fabric: {\n    type: Material.RimLightingType,\n    uniforms: {\n      color: new Color(1.0, 0.0, 0.0, 0.7),\n      rimColor: new Color(1.0, 1.0, 1.0, 0.4),\n      width: 0.3,\n    },\n    source: RimLightingMaterial,\n  },\n  translucent: function (material) {\n    const uniforms = material.uniforms;\n    return uniforms.color.alpha < 1.0 || uniforms.rimColor.alpha < 1.0;\n  },\n});\n\n/**\n * Gets the name of the fade material.\n * @type {String}\n * @readonly\n */\nMaterial.FadeType = \"Fade\";\nMaterial._materialCache.addMaterial(Material.FadeType, {\n  fabric: {\n    type: Material.FadeType,\n    uniforms: {\n      fadeInColor: new Color(1.0, 0.0, 0.0, 1.0),\n      fadeOutColor: new Color(0.0, 0.0, 0.0, 0.0),\n      maximumDistance: 0.5,\n      repeat: true,\n      fadeDirection: {\n        x: true,\n        y: true,\n      },\n      time: new Cartesian2(0.5, 0.5),\n    },\n    source: FadeMaterial,\n  },\n  translucent: function (material) {\n    const uniforms = material.uniforms;\n    return (\n      uniforms.fadeInColor.alpha < 1.0 || uniforms.fadeOutColor.alpha < 1.0\n    );\n  },\n});\n\n/**\n * Gets the name of the polyline arrow material.\n * @type {String}\n * @readonly\n */\nMaterial.PolylineArrowType = \"PolylineArrow\";\nMaterial._materialCache.addMaterial(Material.PolylineArrowType, {\n  fabric: {\n    type: Material.PolylineArrowType,\n    uniforms: {\n      color: new Color(1.0, 1.0, 1.0, 1.0),\n    },\n    source: PolylineArrowMaterial,\n  },\n  translucent: true,\n});\n\n/**\n * Gets the name of the polyline glow material.\n * @type {String}\n * @readonly\n */\nMaterial.PolylineDashType = \"PolylineDash\";\nMaterial._materialCache.addMaterial(Material.PolylineDashType, {\n  fabric: {\n    type: Material.PolylineDashType,\n    uniforms: {\n      color: new Color(1.0, 0.0, 1.0, 1.0),\n      gapColor: new Color(0.0, 0.0, 0.0, 0.0),\n      dashLength: 16.0,\n      dashPattern: 255.0,\n    },\n    source: PolylineDashMaterial,\n  },\n  translucent: true,\n});\n\n/**\n * Gets the name of the polyline glow material.\n * @type {String}\n * @readonly\n */\nMaterial.PolylineGlowType = \"PolylineGlow\";\nMaterial._materialCache.addMaterial(Material.PolylineGlowType, {\n  fabric: {\n    type: Material.PolylineGlowType,\n    uniforms: {\n      color: new Color(0.0, 0.5, 1.0, 1.0),\n      glowPower: 0.25,\n      taperPower: 1.0,\n    },\n    source: PolylineGlowMaterial,\n  },\n  translucent: true,\n});\n\n/**\n * Gets the name of the polyline outline material.\n * @type {String}\n * @readonly\n */\nMaterial.PolylineOutlineType = \"PolylineOutline\";\nMaterial._materialCache.addMaterial(Material.PolylineOutlineType, {\n  fabric: {\n    type: Material.PolylineOutlineType,\n    uniforms: {\n      color: new Color(1.0, 1.0, 1.0, 1.0),\n      outlineColor: new Color(1.0, 0.0, 0.0, 1.0),\n      outlineWidth: 1.0,\n    },\n    source: PolylineOutlineMaterial,\n  },\n  translucent: function (material) {\n    const uniforms = material.uniforms;\n    return uniforms.color.alpha < 1.0 || uniforms.outlineColor.alpha < 1.0;\n  },\n});\n\n/**\n * Gets the name of the elevation contour material.\n * @type {String}\n * @readonly\n */\nMaterial.ElevationContourType = \"ElevationContour\";\nMaterial._materialCache.addMaterial(Material.ElevationContourType, {\n  fabric: {\n    type: Material.ElevationContourType,\n    uniforms: {\n      spacing: 100.0,\n      color: new Color(1.0, 0.0, 0.0, 1.0),\n      width: 1.0,\n    },\n    source: ElevationContourMaterial,\n  },\n  translucent: false,\n});\n\n/**\n * Gets the name of the elevation contour material.\n * @type {String}\n * @readonly\n */\nMaterial.ElevationRampType = \"ElevationRamp\";\nMaterial._materialCache.addMaterial(Material.ElevationRampType, {\n  fabric: {\n    type: Material.ElevationRampType,\n    uniforms: {\n      image: Material.DefaultImageId,\n      minimumHeight: 0.0,\n      maximumHeight: 10000.0,\n    },\n    source: ElevationRampMaterial,\n  },\n  translucent: false,\n});\n\n/**\n * Gets the name of the slope ramp material.\n * @type {String}\n * @readonly\n */\nMaterial.SlopeRampMaterialType = \"SlopeRamp\";\nMaterial._materialCache.addMaterial(Material.SlopeRampMaterialType, {\n  fabric: {\n    type: Material.SlopeRampMaterialType,\n    uniforms: {\n      image: Material.DefaultImageId,\n    },\n    source: SlopeRampMaterial,\n  },\n  translucent: false,\n});\n\n/**\n * Gets the name of the aspect ramp material.\n * @type {String}\n * @readonly\n */\nMaterial.AspectRampMaterialType = \"AspectRamp\";\nMaterial._materialCache.addMaterial(Material.AspectRampMaterialType, {\n  fabric: {\n    type: Material.AspectRampMaterialType,\n    uniforms: {\n      image: Material.DefaultImageId,\n    },\n    source: AspectRampMaterial,\n  },\n  translucent: false,\n});\n\n/**\n * Gets the name of the elevation band material.\n * @type {String}\n * @readonly\n */\nMaterial.ElevationBandType = \"ElevationBand\";\nMaterial._materialCache.addMaterial(Material.ElevationBandType, {\n  fabric: {\n    type: Material.ElevationBandType,\n    uniforms: {\n      heights: Material.DefaultImageId,\n      colors: Material.DefaultImageId,\n    },\n    source: ElevationBandMaterial,\n  },\n  translucent: true,\n});\n\nexport default Material;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport AllMaterialAppearanceFS from \"../Shaders/Appearances/AllMaterialAppearanceFS.js\";\nimport AllMaterialAppearanceVS from \"../Shaders/Appearances/AllMaterialAppearanceVS.js\";\nimport BasicMaterialAppearanceFS from \"../Shaders/Appearances/BasicMaterialAppearanceFS.js\";\nimport BasicMaterialAppearanceVS from \"../Shaders/Appearances/BasicMaterialAppearanceVS.js\";\nimport TexturedMaterialAppearanceFS from \"../Shaders/Appearances/TexturedMaterialAppearanceFS.js\";\nimport TexturedMaterialAppearanceVS from \"../Shaders/Appearances/TexturedMaterialAppearanceVS.js\";\nimport Appearance from \"./Appearance.js\";\nimport Material from \"./Material.js\";\n\n/**\n     * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)\n     * that supports shading with materials.\n     *\n     * @alias MaterialAppearance\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.\n     * @param {Boolean} [options.faceForward=!options.closed] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.\n     * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.\n     * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.\n     * @param {MaterialAppearance.MaterialSupportType} [options.materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] The type of materials that will be supported.\n     * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n     * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n     * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n     * @param {Object} [options.renderState] Optional render state to override the default render state.\n     *\n     * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n     * @demo {@link https://sandcastle.cesium.com/index.html?src=Materials.html|Cesium Sandcastle Material Appearance Demo}\n     *\n     * @example\n     * const primitive = new Cesium.Primitive({\n     *   geometryInstances : new Cesium.GeometryInstance({\n     *     geometry : new Cesium.WallGeometry({\n            materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,\n     *       // ...\n     *     })\n     *   }),\n     *   appearance : new Cesium.MaterialAppearance({\n     *     material : Cesium.Material.fromType('Color'),\n     *     faceForward : true\n     *   })\n     *\n     * });\n     */\nfunction MaterialAppearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const translucent = defaultValue(options.translucent, true);\n  const closed = defaultValue(options.closed, false);\n  const materialSupport = defaultValue(\n    options.materialSupport,\n    MaterialAppearance.MaterialSupport.TEXTURED\n  );\n\n  /**\n   * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}\n   * properties, this is not read-only, so an appearance's material can change on the fly.\n   *\n   * @type Material\n   *\n   * @default {@link Material.ColorType}\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n  this.material = defined(options.material)\n    ? options.material\n    : Material.fromType(Material.ColorType);\n\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.translucent = translucent;\n\n  this._vertexShaderSource = defaultValue(\n    options.vertexShaderSource,\n    materialSupport.vertexShaderSource\n  );\n  this._fragmentShaderSource = defaultValue(\n    options.fragmentShaderSource,\n    materialSupport.fragmentShaderSource\n  );\n  this._renderState = Appearance.getDefaultRenderState(\n    translucent,\n    closed,\n    options.renderState\n  );\n  this._closed = closed;\n\n  // Non-derived members\n\n  this._materialSupport = materialSupport;\n  this._vertexFormat = materialSupport.vertexFormat;\n  this._flat = defaultValue(options.flat, false);\n  this._faceForward = defaultValue(options.faceForward, !closed);\n}\n\nObject.defineProperties(MaterialAppearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof MaterialAppearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    },\n  },\n\n  /**\n   * The GLSL source code for the fragment shader.  The full fragment shader\n   * source is built procedurally taking into account {@link MaterialAppearance#material},\n   * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n   * Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.\n   *\n   * @memberof MaterialAppearance.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   * <p>\n   * The render state can be explicitly defined when constructing a {@link MaterialAppearance}\n   * instance, or it is set implicitly via {@link MaterialAppearance#translucent}\n   * and {@link MaterialAppearance#closed}.\n   * </p>\n   *\n   * @memberof MaterialAppearance.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be closed so\n   * {@link MaterialAppearance#renderState} has backface culling enabled.\n   * If the viewer enters the geometry, it will not be visible.\n   *\n   * @memberof MaterialAppearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    },\n  },\n\n  /**\n   * The type of materials supported by this instance.  This impacts the required\n   * {@link VertexFormat} and the complexity of the vertex and fragment shaders.\n   *\n   * @memberof MaterialAppearance.prototype\n   *\n   * @type {MaterialAppearance.MaterialSupportType}\n   * @readonly\n   *\n   * @default {@link MaterialAppearance.MaterialSupport.TEXTURED}\n   */\n  materialSupport: {\n    get: function () {\n      return this._materialSupport;\n    },\n  },\n\n  /**\n   * The {@link VertexFormat} that this appearance instance is compatible with.\n   * A geometry can have more vertex attributes and still be compatible - at a\n   * potential performance cost - but it can't have less.\n   *\n   * @memberof MaterialAppearance.prototype\n   *\n   * @type VertexFormat\n   * @readonly\n   *\n   * @default {@link MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat}\n   */\n  vertexFormat: {\n    get: function () {\n      return this._vertexFormat;\n    },\n  },\n\n  /**\n   * When <code>true</code>, flat shading is used in the fragment shader,\n   * which means lighting is not taking into account.\n   *\n   * @memberof MaterialAppearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  flat: {\n    get: function () {\n      return this._flat;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the fragment shader flips the surface normal\n   * as needed to ensure that the normal faces the viewer to avoid\n   * dark spots.  This is useful when both sides of a geometry should be\n   * shaded like {@link WallGeometry}.\n   *\n   * @memberof MaterialAppearance.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  faceForward: {\n    get: function () {\n      return this._faceForward;\n    },\n  },\n});\n\n/**\n * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},\n * this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},\n * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n *\n * @function\n *\n * @returns {String} The full GLSL fragment shader source.\n */\nMaterialAppearance.prototype.getFragmentShaderSource =\n  Appearance.prototype.getFragmentShaderSource;\n\n/**\n * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.\n *\n * @function\n *\n * @returns {Boolean} <code>true</code> if the appearance is translucent.\n */\nMaterialAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;\n\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @function\n *\n * @returns {Object} The render state.\n */\nMaterialAppearance.prototype.getRenderState =\n  Appearance.prototype.getRenderState;\n\n/**\n * @typedef MaterialAppearance.MaterialSupportType\n * @type {Object}\n * @property {VertexFormat} vertexFormat\n * @property {String} vertexShaderSource\n * @property {String} fragmentShaderSource\n */\n\n/**\n * Determines the type of {@link Material} that is supported by a\n * {@link MaterialAppearance} instance.  This is a trade-off between\n * flexibility (a wide array of materials) and memory/performance\n * (required vertex format and GLSL shader complexity.\n * @namespace\n */\nMaterialAppearance.MaterialSupport = {\n  /**\n   * Only basic materials, which require just <code>position</code> and\n   * <code>normal</code> vertex attributes, are supported.\n   *\n   * @type {MaterialAppearance.MaterialSupportType}\n   * @constant\n   */\n  BASIC: Object.freeze({\n    vertexFormat: VertexFormat.POSITION_AND_NORMAL,\n    vertexShaderSource: BasicMaterialAppearanceVS,\n    fragmentShaderSource: BasicMaterialAppearanceFS,\n  }),\n  /**\n   * Materials with textures, which require <code>position</code>,\n   * <code>normal</code>, and <code>st</code> vertex attributes,\n   * are supported.  The vast majority of materials fall into this category.\n   *\n   * @type {MaterialAppearance.MaterialSupportType}\n   * @constant\n   */\n  TEXTURED: Object.freeze({\n    vertexFormat: VertexFormat.POSITION_NORMAL_AND_ST,\n    vertexShaderSource: TexturedMaterialAppearanceVS,\n    fragmentShaderSource: TexturedMaterialAppearanceFS,\n  }),\n  /**\n   * All materials, including those that work in tangent space, are supported.\n   * This requires <code>position</code>, <code>normal</code>, <code>st</code>,\n   * <code>tangent</code>, and <code>bitangent</code> vertex attributes.\n   *\n   * @type {MaterialAppearance.MaterialSupportType}\n   * @constant\n   */\n  ALL: Object.freeze({\n    vertexFormat: VertexFormat.ALL,\n    vertexShaderSource: AllMaterialAppearanceVS,\n    fragmentShaderSource: AllMaterialAppearanceFS,\n  }),\n};\nexport default MaterialAppearance;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataClassProperty from \"./MetadataClassProperty.js\";\n\n/**\n * A metadata class.\n *\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} options.id The ID of the class.\n * @param {Object} options.class The class JSON object.\n * @param {Object.<String, MetadataEnum>} [options.enums] A dictionary of enums.\n *\n * @alias MetadataClass\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataClass(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const id = options.id;\n  const classDefinition = options.class;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.id\", id);\n  Check.typeOf.object(\"options.class\", classDefinition);\n  //>>includeEnd('debug');\n\n  const properties = {};\n  const propertiesBySemantic = {};\n  for (const propertyId in classDefinition.properties) {\n    if (classDefinition.properties.hasOwnProperty(propertyId)) {\n      const property = new MetadataClassProperty({\n        id: propertyId,\n        property: classDefinition.properties[propertyId],\n        enums: options.enums,\n      });\n      properties[propertyId] = property;\n      if (defined(property.semantic)) {\n        propertiesBySemantic[property.semantic] = property;\n      }\n    }\n  }\n\n  this._properties = properties;\n  this._propertiesBySemantic = propertiesBySemantic;\n  this._id = id;\n  this._name = classDefinition.name;\n  this._description = classDefinition.description;\n  this._extras = classDefinition.extras;\n  this._extensions = classDefinition.extensions;\n}\n\nObject.defineProperties(MetadataClass.prototype, {\n  /**\n   * The class properties.\n   *\n   * @memberof MetadataClass.prototype\n   * @type {Object.<String, MetadataClassProperty>}\n   * @readonly\n   * @private\n   */\n  properties: {\n    get: function () {\n      return this._properties;\n    },\n  },\n\n  /**\n   * A dictionary mapping semantics to class properties.\n   *\n   * @memberof MetadataClass.prototype\n   * @type {Object.<String, MetadataClassProperty>}\n   * @readonly\n   *\n   * @private\n   */\n  propertiesBySemantic: {\n    get: function () {\n      return this._propertiesBySemantic;\n    },\n  },\n\n  /**\n   * The ID of the class.\n   *\n   * @memberof MetadataClass.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * The name of the class.\n   *\n   * @memberof MetadataClass.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The description of the class.\n   *\n   * @memberof MetadataClass.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  description: {\n    get: function () {\n      return this._description;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof MetadataClass.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof MetadataClass.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * The class name given to the metadata class when a batch\n * table is loaded from 3D Tiles 1.0 formats.\n *\n * @private\n */\nMetadataClass.BATCH_TABLE_CLASS_NAME = \"_batchTable\";\n\nexport default MetadataClass;\n","import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport MetadataType from \"./MetadataType.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\n\n/**\n * A metadata property, as part of a {@link MetadataClass}\n *\n * @param {Object} options Object with the following properties:\n * @param {String} options.id The ID of the property.\n * @param {Object} options.property The property JSON object.\n * @param {Object.<String, MetadataEnum>} [options.enums] A dictionary of enums.\n *\n * @alias MetadataClassProperty\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataClassProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const id = options.id;\n  const property = options.property;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.id\", id);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.string(\"options.property.type\", property.type);\n  //>>includeEnd('debug');\n\n  // Try to determine if this is the legacy extension. This is not\n  // always possible, as there are some types that are valid in both\n  // extensions.\n  const isLegacyExtension = isLegacy(property);\n  const parsedType = parseType(property, options.enums);\n  const componentType = parsedType.componentType;\n\n  const normalized =\n    defined(componentType) &&\n    MetadataComponentType.isIntegerType(componentType) &&\n    defaultValue(property.normalized, false);\n\n  // Basic information about this property\n  this._id = id;\n  this._name = property.name;\n  this._description = property.description;\n  this._semantic = property.semantic;\n  this._isLegacyExtension = isLegacyExtension;\n\n  // Details about basic types\n  this._type = parsedType.type;\n  this._componentType = componentType;\n  this._enumType = parsedType.enumType;\n  this._valueType = parsedType.valueType;\n\n  // Details about arrays\n  this._isArray = parsedType.isArray;\n  this._isVariableLengthArray = parsedType.isVariableLengthArray;\n  this._arrayLength = parsedType.arrayLength;\n\n  // min and max allowed values\n  this._min = property.min;\n  this._max = property.max;\n\n  // properties that adjust the range of metadata values\n  this._normalized = normalized;\n\n  let offset = property.offset;\n  let scale = property.scale;\n  const hasValueTransform = defined(offset) || defined(scale);\n\n  const enableNestedArrays = true;\n  if (!defined(offset)) {\n    offset = this.expandConstant(0, enableNestedArrays);\n  }\n\n  if (!defined(scale)) {\n    scale = this.expandConstant(1, enableNestedArrays);\n  }\n\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n\n  // sentinel value for missing data, and a default value to use\n  // in its place if needed.\n  this._noData = property.noData;\n  // For vector and array types, this is stored as an array of values.\n  this._default = property.default;\n\n  // EXT_feature_metadata had an optional flag, while EXT_structural_metadata\n  // has a required flag. The defaults are not the same, and there's some cases\n  // like {type: BOOLEAN} that are ambiguous. Coalesce this into a single\n  // required flag\n  let required;\n  if (!defined(isLegacyExtension)) {\n    // Impossible to tell which extension was used, so don't require\n    // the property\n    required = false;\n  } else if (isLegacyExtension) {\n    required = defined(property.optional) ? !property.optional : true;\n  } else {\n    required = defaultValue(property.required, false);\n  }\n  this._required = required;\n\n  // extras and extensions\n  this._extras = property.extras;\n  this._extensions = property.extensions;\n}\n\nObject.defineProperties(MetadataClassProperty.prototype, {\n  /**\n   * The ID of the property.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * The name of the property.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The description of the property.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  description: {\n    get: function () {\n      return this._description;\n    },\n  },\n\n  /**\n   * The type of the property such as SCALAR, VEC2, VEC3\n   *\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataType}\n   * @readonly\n   * @private\n   */\n  type: {\n    get: function () {\n      return this._type;\n    },\n  },\n\n  /**\n   * The enum type of the property. Only defined when type is ENUM.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataEnum}\n   * @readonly\n   * @private\n   */\n  enumType: {\n    get: function () {\n      return this._enumType;\n    },\n  },\n\n  /**\n   * The component type of the property. This includes integer\n   * (e.g. INT8 or UINT16), and floating point (FLOAT32 and FLOAT64) values\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataComponentType}\n   * @readonly\n   * @private\n   */\n  componentType: {\n    get: function () {\n      return this._componentType;\n    },\n  },\n\n  /**\n   * The datatype used for storing each component of the property. This\n   * is usually the same as componentType except for ENUM, where this\n   * returns an integer type\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {MetadataComponentType}\n   * @readonly\n   * @private\n   */\n  valueType: {\n    get: function () {\n      return this._valueType;\n    },\n  },\n\n  /**\n   * True if a property is an array (either fixed length or variable length),\n   * false otherwise.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  isArray: {\n    get: function () {\n      return this._isArray;\n    },\n  },\n\n  /**\n   * True if a property is a variable length array, false otherwise.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  isVariableLengthArray: {\n    get: function () {\n      return this._isVariableLengthArray;\n    },\n  },\n\n  /**\n   * The number of array elements. Only defined for fixed-size\n   * arrays.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  arrayLength: {\n    get: function () {\n      return this._arrayLength;\n    },\n  },\n\n  /**\n   * Whether the property is normalized.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  normalized: {\n    get: function () {\n      return this._normalized;\n    },\n  },\n\n  /**\n   * A number or an array of numbers storing the maximum allowable value of this property. Only defined when type or componentType is a numeric type.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Number|Number[]}\n   * @readonly\n   * @private\n   */\n  max: {\n    get: function () {\n      return this._max;\n    },\n  },\n\n  /**\n   * A number or an array of numbers storing the minimum allowable value of this property. Only defined when type or componentType is a numeric type.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Number|Number[]}\n   * @readonly\n   * @private\n   */\n  min: {\n    get: function () {\n      return this._min;\n    },\n  },\n\n  /**\n   * The no-data sentinel value that represents null values\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Boolean|Number|String|Array}\n   * @readonly\n   * @private\n   */\n  noData: {\n    get: function () {\n      return this._noData;\n    },\n  },\n\n  /**\n   * A default value to use when an entity's property value is not defined.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Boolean|Number|String|Array}\n   * @readonly\n   * @private\n   */\n  default: {\n    get: function () {\n      return this._default;\n    },\n  },\n\n  /**\n   * Whether the property is required.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  required: {\n    get: function () {\n      return this._required;\n    },\n  },\n\n  /**\n   * An identifier that describes how this property should be interpreted.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  semantic: {\n    get: function () {\n      return this._semantic;\n    },\n  },\n\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    },\n  },\n\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Number|Number[]|Number[][]}\n   * @readonly\n   * @private\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    },\n  },\n\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Number|Number[]|Number[][]}\n   * @readonly\n   * @private\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\nfunction isLegacy(property) {\n  if (property.type === \"ARRAY\") {\n    return true;\n  }\n\n  // New property types in EXT_structural_metadata\n  const type = property.type;\n  if (\n    type === MetadataType.SCALAR ||\n    MetadataType.isMatrixType(type) ||\n    MetadataType.isVectorType(type)\n  ) {\n    return false;\n  }\n\n  // EXT_feature_metadata allowed numeric types as a type. Now they are\n  // represented as {type: SINGLE, componentType: type}\n  if (MetadataComponentType.isNumericType(type)) {\n    return true;\n  }\n\n  // New properties in EXT_structural_metadata\n  if (\n    defined(property.noData) ||\n    defined(property.scale) ||\n    defined(property.offset) ||\n    defined(property.required) ||\n    defined(property.count) ||\n    defined(property.array)\n  ) {\n    return false;\n  }\n\n  // Properties that only exist in EXT_feature_metadata\n  if (defined(property.optional)) {\n    return false;\n  }\n\n  // impossible to tell, give up.\n  return undefined;\n}\n\nfunction parseType(property, enums) {\n  const type = property.type;\n  const componentType = property.componentType;\n\n  // EXT_feature_metadata had an ARRAY type. This is now handled\n  // with array + count, so some details need to be transcoded\n  const isLegacyArray = type === \"ARRAY\";\n  let isArray;\n  let arrayLength;\n  let isVariableLengthArray;\n  if (isLegacyArray) {\n    // definitely EXT_feature_metadata\n    isArray = true;\n    arrayLength = property.componentCount;\n    isVariableLengthArray = !defined(arrayLength);\n  } else if (property.array) {\n    isArray = true;\n    arrayLength = property.count;\n    isVariableLengthArray = !defined(property.count);\n  } else {\n    // Could be either extension. Some cases are impossible to distinguish\n    // Default to a single value\n    isArray = false;\n    arrayLength = undefined;\n    isVariableLengthArray = false;\n  }\n\n  let enumType;\n  if (defined(property.enumType)) {\n    enumType = enums[property.enumType];\n  }\n\n  // In both EXT_feature_metadata and EXT_structural_metadata, ENUM appears\n  // as a type.\n  if (type === MetadataType.ENUM) {\n    return {\n      type: type,\n      componentType: undefined,\n      enumType: enumType,\n      valueType: enumType.valueType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // In EXT_feature_metadata, ENUM also appears as an ARRAY componentType\n  if (isLegacyArray && componentType === MetadataType.ENUM) {\n    return {\n      type: componentType,\n      componentType: undefined,\n      enumType: enumType,\n      valueType: enumType.valueType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // EXT_structural_metadata only: SCALAR, VECN and MATN\n  if (\n    type === MetadataType.SCALAR ||\n    MetadataType.isMatrixType(type) ||\n    MetadataType.isVectorType(type)\n  ) {\n    return {\n      type: type,\n      componentType: componentType,\n      enumType: undefined,\n      valueType: componentType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // In both EXT_structural_metadata and EXT_feature_metadata,\n  // BOOLEAN and STRING appear as types\n  if (type === MetadataType.BOOLEAN || type === MetadataType.STRING) {\n    return {\n      type: type,\n      componentType: undefined,\n      enumType: undefined,\n      valueType: undefined,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // EXT_feature_metadata also allows BOOLEAN and STRING as an ARRAY\n  // componentType\n  if (\n    isLegacyArray &&\n    (componentType === MetadataType.BOOLEAN ||\n      componentType === MetadataType.STRING)\n  ) {\n    return {\n      type: componentType,\n      componentType: undefined,\n      enumType: undefined,\n      valueType: undefined,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // Both EXT_feature_metadata and EXT_structural_metadata allow numeric types like\n  // INT32 or FLOAT64 as a componentType.\n  if (\n    defined(componentType) &&\n    MetadataComponentType.isNumericType(componentType)\n  ) {\n    return {\n      type: MetadataType.SCALAR,\n      componentType: componentType,\n      enumType: undefined,\n      valueType: componentType,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  // EXT_feature_metadata: integer and float types were allowed as types,\n  // but now these are expressed as {type: SCALAR, componentType: type}\n  if (MetadataComponentType.isNumericType(type)) {\n    return {\n      type: MetadataType.SCALAR,\n      componentType: type,\n      enumType: undefined,\n      valueType: type,\n      isArray: isArray,\n      isVariableLengthArray: isVariableLengthArray,\n      arrayLength: arrayLength,\n    };\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  throw new DeveloperError(\n    `unknown metadata type {type: ${type}, componentType: ${componentType})`\n  );\n  //>>includeEnd('debug');\n}\n\n/**\n * Normalizes integer property values. If the property is not normalized\n * the value is returned unmodified.\n * <p>\n * Given the way normalization is defined in {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#normalized-values|the 3D Metadata Specification},\n * normalize and unnormalize are almost, but not quite inverses. In particular,\n * the smallest signed integer value will be off by one after normalizing and\n * unnormalizing. See\n * {@link https://www.desmos.com/calculator/nledg1evut|this Desmos graph} for\n * an example using INT8.\n * </p>\n * <p>\n * Furthermore, for 64-bit integer types, there may be a loss of precision\n * due to conversion to Number\n * </p>\n *\n * @param {*} value The integer value or array of integer values.\n * @returns {*} The normalized value or array of normalized values.\n *\n * @private\n */\nMetadataClassProperty.prototype.normalize = function (value) {\n  if (!this._normalized) {\n    return value;\n  }\n\n  return normalizeInPlace(\n    value,\n    this._valueType,\n    MetadataComponentType.normalize\n  );\n};\n\n/**\n * Unnormalizes integer property values. If the property is not normalized\n * the value is returned unmodified.\n * <p>\n * Given the way normalization is defined in {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#normalized-values|the 3D Metadata Specification},\n * normalize and unnormalize are almost, but not quite inverses. In particular,\n * the smallest signed integer value will be off by one after normalizing and\n * unnormalizing. See\n * {@link https://www.desmos.com/calculator/nledg1evut|this Desmos graph} for\n * an example using INT8.\n * </p>\n * <p>\n * Furthermore, for 64-bit integer types, there may be a loss of precision\n * due to conversion to Number\n * </p>\n *\n * @param {*} value The normalized value or array of normalized values.\n * @returns {*} The integer value or array of integer values.\n *\n * @private\n */\nMetadataClassProperty.prototype.unnormalize = function (value) {\n  if (!this._normalized) {\n    return value;\n  }\n\n  return normalizeInPlace(\n    value,\n    this._valueType,\n    MetadataComponentType.unnormalize\n  );\n};\n\nMetadataClassProperty.prototype.applyValueTransform = function (value) {\n  // variable length arrays do not have a well-defined offset/scale so this\n  // is forbidden by the spec\n  if (!this._hasValueTransform || this._isVariableLengthArray) {\n    return value;\n  }\n\n  return MetadataClassProperty.valueTransformInPlace(\n    value,\n    this._offset,\n    this._scale,\n    MetadataComponentType.applyValueTransform\n  );\n};\n\nMetadataClassProperty.prototype.unapplyValueTransform = function (value) {\n  // variable length arrays do not have a well-defined offset/scale so this\n  // is forbidden by the spec\n  if (!this._hasValueTransform || this._isVariableLengthArray) {\n    return value;\n  }\n\n  return MetadataClassProperty.valueTransformInPlace(\n    value,\n    this._offset,\n    this._scale,\n    MetadataComponentType.unapplyValueTransform\n  );\n};\n\nMetadataClassProperty.prototype.expandConstant = function (\n  constant,\n  enableNestedArrays\n) {\n  enableNestedArrays = defaultValue(enableNestedArrays, false);\n  const isArray = this._isArray;\n  const arrayLength = this._arrayLength;\n  const componentCount = MetadataType.getComponentCount(this._type);\n  const isNested = isArray && componentCount > 1;\n\n  // scalar values can be returned directly\n  if (!isArray && componentCount === 1) {\n    return constant;\n  }\n\n  // vector and matrix values\n  if (!isArray) {\n    return new Array(componentCount).fill(constant);\n  }\n\n  // arrays of scalars\n  if (!isNested) {\n    return new Array(arrayLength).fill(constant);\n  }\n\n  // arrays of vectors/matrices: flattened\n  if (!enableNestedArrays) {\n    return new Array(this._arrayLength * componentCount).fill(constant);\n  }\n\n  // array of vectors/matrices: nested\n  const innerConstant = new Array(componentCount).fill(constant);\n  // This array fill duplicates the pointer to the inner arrays. Since this is\n  // intended for use with constants, no need to clone the array.\n  return new Array(this._arrayLength).fill(innerConstant);\n};\n\n/**\n * If the value is the noData sentinel, return undefined. Otherwise, return\n * the value.\n * @param {*} value The raw value\n * @returns {*} Either the value or undefined if the value was a no data value.\n *\n * @private\n */\nMetadataClassProperty.prototype.handleNoData = function (value) {\n  const sentinel = this._noData;\n  if (!defined(sentinel)) {\n    return value;\n  }\n\n  if (arrayEquals(value, sentinel)) {\n    return undefined;\n  }\n\n  return value;\n};\n\nfunction arrayEquals(left, right) {\n  if (!Array.isArray(left)) {\n    return left === right;\n  }\n\n  if (!Array.isArray(right)) {\n    return false;\n  }\n\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; i++) {\n    if (!arrayEquals(left[i], right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Unpack VECN values into {@link Cartesian2}, {@link Cartesian3}, or\n * {@link Cartesian4} and MATN values into {@link Matrix2}, {@link Matrix3}, or\n * {@link Matrix4} depending on N. All other values (including arrays of\n * other sizes) are passed through unaltered.\n *\n * @param {*} value the original, normalized values.\n * @param {Boolean} [enableNestedArrays=false] If true, arrays of vectors are represented as nested arrays. This is used for JSON encoding but not binary encoding\n * @returns {*} The appropriate vector or matrix type if the value is a vector or matrix type, respectively. If the property is an array of vectors or matrices, an array of the appropriate vector or matrix type is returned. Otherwise, the value is returned unaltered.\n * @private\n */\nMetadataClassProperty.prototype.unpackVectorAndMatrixTypes = function (\n  value,\n  enableNestedArrays\n) {\n  enableNestedArrays = defaultValue(enableNestedArrays, false);\n  const MathType = MetadataType.getMathType(this._type);\n  const isArray = this._isArray;\n  const componentCount = MetadataType.getComponentCount(this._type);\n  const isNested = isArray && componentCount > 1;\n\n  if (!defined(MathType)) {\n    return value;\n  }\n\n  if (enableNestedArrays && isNested) {\n    return value.map(function (x) {\n      return MathType.unpack(x);\n    });\n  }\n\n  if (isArray) {\n    return MathType.unpackArray(value);\n  }\n\n  return MathType.unpack(value);\n};\n\n/**\n * Pack a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} into an\n * array if this property is an <code>VECN</code>.\n * Pack a {@link Matrix2}, {@link Matrix3}, or {@link Matrix4} into an\n * array if this property is an <code>MATN</code>.\n * All other values (including arrays of other sizes) are passed through unaltered.\n *\n * @param {*} value The value of this property\n * @param {Boolean} [enableNestedArrays=false] If true, arrays of vectors are represented as nested arrays. This is used for JSON encoding but not binary encoding\n * @returns {*} An array of the appropriate length if the property is a vector or matrix type. Otherwise, the value is returned unaltered.\n * @private\n */\nMetadataClassProperty.prototype.packVectorAndMatrixTypes = function (\n  value,\n  enableNestedArrays\n) {\n  enableNestedArrays = defaultValue(enableNestedArrays, false);\n  const MathType = MetadataType.getMathType(this._type);\n  const isArray = this._isArray;\n  const componentCount = MetadataType.getComponentCount(this._type);\n  const isNested = isArray && componentCount > 1;\n\n  if (!defined(MathType)) {\n    return value;\n  }\n\n  if (enableNestedArrays && isNested) {\n    return value.map(function (x) {\n      return MathType.pack(x, []);\n    });\n  }\n\n  if (isArray) {\n    return MathType.packArray(value, []);\n  }\n\n  return MathType.pack(value, []);\n};\n\n/**\n * Validates whether the given value conforms to the property.\n *\n * @param {*} value The value.\n * @returns {String|undefined} An error message if the value does not conform to the property, otherwise undefined.\n * @private\n */\nMetadataClassProperty.prototype.validate = function (value) {\n  if (!defined(value) && defined(this._default)) {\n    // no value, but we have a default to use.\n    return undefined;\n  }\n\n  if (this._required && !defined(value)) {\n    return `required property must have a value`;\n  }\n\n  if (this._isArray) {\n    return validateArray(this, value);\n  }\n\n  return validateSingleValue(this, value);\n};\n\nfunction validateArray(classProperty, value) {\n  if (!Array.isArray(value)) {\n    return `value ${value} must be an array`;\n  }\n\n  const length = value.length;\n  if (\n    !classProperty._isVariableLengthArray &&\n    length !== classProperty._arrayLength\n  ) {\n    return \"Array length does not match property.arrayLength\";\n  }\n\n  for (let i = 0; i < length; i++) {\n    const message = validateSingleValue(classProperty, value[i]);\n    if (defined(message)) {\n      return message;\n    }\n  }\n}\n\nfunction validateSingleValue(classProperty, value) {\n  const type = classProperty._type;\n  const componentType = classProperty._componentType;\n  const enumType = classProperty._enumType;\n  const normalized = classProperty._normalized;\n\n  if (MetadataType.isVectorType(type)) {\n    return validateVector(value, type, componentType);\n  } else if (MetadataType.isMatrixType(type)) {\n    return validateMatrix(value, type, componentType);\n  } else if (type === MetadataType.STRING) {\n    return validateString(value);\n  } else if (type === MetadataType.BOOLEAN) {\n    return validateBoolean(value);\n  } else if (type === MetadataType.ENUM) {\n    return validateEnum(value, enumType);\n  }\n\n  return validateScalar(value, componentType, normalized);\n}\n\nfunction validateVector(value, type, componentType) {\n  if (!MetadataComponentType.isVectorCompatible(componentType)) {\n    return `componentType ${componentType} is incompatible with vector type ${type}`;\n  }\n\n  if (type === MetadataType.VEC2 && !(value instanceof Cartesian2)) {\n    return `vector value ${value} must be a Cartesian2`;\n  }\n\n  if (type === MetadataType.VEC3 && !(value instanceof Cartesian3)) {\n    return `vector value ${value} must be a Cartesian3`;\n  }\n\n  if (type === MetadataType.VEC4 && !(value instanceof Cartesian4)) {\n    return `vector value ${value} must be a Cartesian4`;\n  }\n}\n\nfunction validateMatrix(value, type, componentType) {\n  if (!MetadataComponentType.isVectorCompatible(componentType)) {\n    return `componentType ${componentType} is incompatible with matrix type ${type}`;\n  }\n\n  if (type === MetadataType.MAT2 && !(value instanceof Matrix2)) {\n    return `matrix value ${value} must be a Matrix2`;\n  }\n\n  if (type === MetadataType.MAT3 && !(value instanceof Matrix3)) {\n    return `matrix value ${value} must be a Matrix3`;\n  }\n\n  if (type === MetadataType.MAT4 && !(value instanceof Matrix4)) {\n    return `matrix value ${value} must be a Matrix4`;\n  }\n}\n\nfunction validateString(value) {\n  if (typeof value !== \"string\") {\n    return getTypeErrorMessage(value, MetadataType.STRING);\n  }\n}\n\nfunction validateBoolean(value) {\n  if (typeof value !== \"boolean\") {\n    return getTypeErrorMessage(value, MetadataType.BOOLEAN);\n  }\n}\n\nfunction validateEnum(value, enumType) {\n  const javascriptType = typeof value;\n  if (defined(enumType)) {\n    if (javascriptType !== \"string\" || !defined(enumType.valuesByName[value])) {\n      return `value ${value} is not a valid enum name for ${enumType.id}`;\n    }\n    return;\n  }\n}\n\nfunction validateScalar(value, componentType, normalized) {\n  const javascriptType = typeof value;\n\n  switch (componentType) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.FLOAT32:\n    case MetadataComponentType.FLOAT64:\n      if (javascriptType !== \"number\") {\n        return getTypeErrorMessage(value, componentType);\n      }\n      if (!isFinite(value)) {\n        return getNonFiniteErrorMessage(value, componentType);\n      }\n      return checkInRange(value, componentType, normalized);\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n      if (javascriptType !== \"number\" && javascriptType !== \"bigint\") {\n        return getTypeErrorMessage(value, componentType);\n      }\n      if (javascriptType === \"number\" && !isFinite(value)) {\n        return getNonFiniteErrorMessage(value, componentType);\n      }\n      return checkInRange(value, componentType, normalized);\n  }\n}\n\nfunction getTypeErrorMessage(value, type) {\n  return `value ${value} does not match type ${type}`;\n}\n\nfunction getOutOfRangeErrorMessage(value, type, normalized) {\n  let errorMessage = `value ${value} is out of range for type ${type}`;\n  if (normalized) {\n    errorMessage += \" (normalized)\";\n  }\n  return errorMessage;\n}\n\nfunction checkInRange(value, componentType, normalized) {\n  if (normalized) {\n    const min = MetadataComponentType.isUnsignedIntegerType(componentType)\n      ? 0.0\n      : -1.0;\n    const max = 1.0;\n    if (value < min || value > max) {\n      return getOutOfRangeErrorMessage(value, componentType, normalized);\n    }\n    return;\n  }\n\n  if (\n    value < MetadataComponentType.getMinimum(componentType) ||\n    value > MetadataComponentType.getMaximum(componentType)\n  ) {\n    return getOutOfRangeErrorMessage(value, componentType, normalized);\n  }\n}\n\nfunction getNonFiniteErrorMessage(value, type) {\n  return `value ${value} of type ${type} must be finite`;\n}\n\nfunction normalizeInPlace(values, valueType, normalizeFunction) {\n  if (!Array.isArray(values)) {\n    return normalizeFunction(values, valueType);\n  }\n\n  for (let i = 0; i < values.length; i++) {\n    values[i] = normalizeInPlace(values[i], valueType, normalizeFunction);\n  }\n\n  return values;\n}\n\nMetadataClassProperty.valueTransformInPlace = function (\n  values,\n  offsets,\n  scales,\n  transformationFunction\n) {\n  if (!Array.isArray(values)) {\n    // transform a single value\n    return transformationFunction(values, offsets, scales);\n  }\n\n  for (let i = 0; i < values.length; i++) {\n    // offsets and scales must be the same array shape as values.\n    values[i] = MetadataClassProperty.valueTransformInPlace(\n      values[i],\n      offsets[i],\n      scales[i],\n      transformationFunction\n    );\n  }\n\n  return values;\n};\n\nexport default MetadataClassProperty;\n","import CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\n\n/**\n * An enum of metadata component types.\n *\n * @enum MetadataComponentType\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst MetadataComponentType = {\n  /**\n   * An 8-bit signed integer\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  INT8: \"INT8\",\n  /**\n   * An 8-bit unsigned integer\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  UINT8: \"UINT8\",\n  /**\n   * A 16-bit signed integer\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  INT16: \"INT16\",\n  /**\n   * A 16-bit unsigned integer\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  UINT16: \"UINT16\",\n  /**\n   * A 32-bit signed integer\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  INT32: \"INT32\",\n  /**\n   * A 32-bit unsigned integer\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  UINT32: \"UINT32\",\n  /**\n   * A 64-bit signed integer. This type requires BigInt support.\n   *\n   * @see FeatureDetection.supportsBigInt\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  INT64: \"INT64\",\n  /**\n   * A 64-bit signed integer. This type requires BigInt support\n   *\n   * @see FeatureDetection.supportsBigInt\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  UINT64: \"UINT64\",\n  /**\n   * A 32-bit (single precision) floating point number\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  FLOAT32: \"FLOAT32\",\n  /**\n   * A 64-bit (double precision) floating point number\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  FLOAT64: \"FLOAT64\",\n};\n\n/**\n * Gets the minimum value for the numeric type.\n * <p>\n * Returns a BigInt for the INT64 and UINT64 types if BigInt is supported on this platform.\n * Otherwise an approximate number is returned.\n * </p>\n *\n * @param {MetadataComponentType} type The type.\n * @returns {Number|BigInt} The minimum value.\n *\n * @exception {DeveloperError} type must be a numeric type\n *\n * @private\n */\nMetadataComponentType.getMinimum = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!MetadataComponentType.isNumericType(type)) {\n    throw new DeveloperError(\"type must be a numeric type\");\n  }\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n      return -128;\n    case MetadataComponentType.UINT8:\n      return 0;\n    case MetadataComponentType.INT16:\n      return -32768;\n    case MetadataComponentType.UINT16:\n      return 0;\n    case MetadataComponentType.INT32:\n      return -2147483648;\n    case MetadataComponentType.UINT32:\n      return 0;\n    case MetadataComponentType.INT64:\n      if (FeatureDetection.supportsBigInt()) {\n        return BigInt(\"-9223372036854775808\"); // eslint-disable-line\n      }\n      return -Math.pow(2, 63);\n    case MetadataComponentType.UINT64:\n      if (FeatureDetection.supportsBigInt()) {\n        return BigInt(0); // eslint-disable-line\n      }\n      return 0;\n    case MetadataComponentType.FLOAT32:\n      // Maximum 32-bit floating point number. This value will be converted to the nearest 64-bit Number\n      return -340282346638528859811704183484516925440.0;\n    case MetadataComponentType.FLOAT64:\n      return -Number.MAX_VALUE;\n  }\n};\n\n/**\n * Gets the maximum value for the numeric type.\n * <p>\n * Returns a BigInt for the INT64 and UINT64 types if BigInt is supported on this platform.\n * Otherwise an approximate number is returned.\n * </p>\n *\n * @param {MetadataComponentType} type The type.\n * @returns {Number|BigInt} The maximum value.\n *\n * @exception {DeveloperError} type must be a numeric type\n *\n * @private\n */\nMetadataComponentType.getMaximum = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!MetadataComponentType.isNumericType(type)) {\n    throw new DeveloperError(\"type must be a numeric type\");\n  }\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n      return 127;\n    case MetadataComponentType.UINT8:\n      return 255;\n    case MetadataComponentType.INT16:\n      return 32767;\n    case MetadataComponentType.UINT16:\n      return 65535;\n    case MetadataComponentType.INT32:\n      return 2147483647;\n    case MetadataComponentType.UINT32:\n      return 4294967295;\n    case MetadataComponentType.INT64:\n      if (FeatureDetection.supportsBigInt()) {\n        // Need to initialize with a string otherwise the value will be 9223372036854775808\n        return BigInt(\"9223372036854775807\"); // eslint-disable-line\n      }\n      return Math.pow(2, 63) - 1;\n    case MetadataComponentType.UINT64:\n      if (FeatureDetection.supportsBigInt()) {\n        // Need to initialize with a string otherwise the value will be 18446744073709551616\n        return BigInt(\"18446744073709551615\"); // eslint-disable-line\n      }\n      return Math.pow(2, 64) - 1;\n    case MetadataComponentType.FLOAT32:\n      // Maximum 32-bit floating point number\n      return 340282346638528859811704183484516925440.0;\n    case MetadataComponentType.FLOAT64:\n      return Number.MAX_VALUE;\n  }\n};\n\n/**\n * Returns whether the type is a numeric type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {Boolean} Whether the type is a numeric type.\n *\n * @private\n */\nMetadataComponentType.isNumericType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n    case MetadataComponentType.FLOAT32:\n    case MetadataComponentType.FLOAT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns whether the type is an integer type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {Boolean} Whether the type is an integer type.\n *\n * @private\n */\nMetadataComponentType.isIntegerType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns whether the type is an unsigned integer type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {Boolean} Whether the type is an unsigned integer type.\n *\n * @private\n */\nMetadataComponentType.isUnsignedIntegerType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.UINT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns whether a type can be used in a vector, i.e. the {@link Cartesian2},\n * {@link Cartesian3}, or {@link Cartesian4} classes. This includes all numeric\n * types except for types requiring 64-bit integers\n * @param {MetadataComponentType} type The type to check\n * @return {Boolean} <code>true</code> if the type can be encoded as a vector type, or <code>false</code> otherwise\n * @private\n */\nMetadataComponentType.isVectorCompatible = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n    case MetadataComponentType.FLOAT32:\n    case MetadataComponentType.FLOAT64:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Normalizes signed integers to the range [-1.0, 1.0] and unsigned integers to\n * the range [0.0, 1.0].\n * <p>\n * The value may be a BigInt for the INT64 and UINT64 types. The value is converted\n * to a 64-bit floating point number during normalization which may result in\n * small precision differences.\n * </p>\n *\n * @param {Number|BigInt} value The integer value.\n * @param {MetadataComponentType} type The type.\n * @returns {Number} The normalized value.\n *\n * @exception {DeveloperError} value must be a number or a BigInt\n * @exception {DeveloperError} type must be an integer type\n *\n * @private\n */\nMetadataComponentType.normalize = function (value, type) {\n  //>>includeStart('debug', pragmas.debug);\n  if (typeof value !== \"number\" && typeof value !== \"bigint\") {\n    throw new DeveloperError(\"value must be a number or a BigInt\");\n  }\n  if (!MetadataComponentType.isIntegerType(type)) {\n    throw new DeveloperError(\"type must be an integer type\");\n  }\n  //>>includeEnd('debug');\n\n  return Math.max(\n    Number(value) / Number(MetadataComponentType.getMaximum(type)),\n    -1.0\n  );\n};\n\n/**\n * Unnormalizes signed numbers in the range [-1.0, 1.0] to signed integers and\n * unsigned numbers in the range [0.0, 1.0] to unsigned integers. Values outside\n * the range are clamped to the range.\n * <p>\n * Returns a BigInt for the INT64 and UINT64 types if BigInt is supported on this platform.\n * </p>\n *\n * @param {Number} value The normalized value.\n * @param {MetadataComponentType} type The type.\n * @returns {Number|BigInt} The integer value.\n *\n * @exception {DeveloperError} type must be an integer type\n *\n * @private\n */\nMetadataComponentType.unnormalize = function (value, type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  if (!MetadataComponentType.isIntegerType(type)) {\n    throw new DeveloperError(\"type must be an integer type\");\n  }\n  //>>includeEnd('debug');\n\n  const max = MetadataComponentType.getMaximum(type);\n  const min = MetadataComponentType.isUnsignedIntegerType(type) ? 0 : -max;\n\n  value = CesiumMath.sign(value) * Math.round(Math.abs(value) * Number(max));\n\n  if (\n    (type === MetadataComponentType.INT64 ||\n      type === MetadataComponentType.UINT64) &&\n    FeatureDetection.supportsBigInt()\n  ) {\n    value = BigInt(value); // eslint-disable-line\n  }\n\n  if (value > max) {\n    return max;\n  }\n\n  if (value < min) {\n    return min;\n  }\n\n  return value;\n};\n\nMetadataComponentType.applyValueTransform = function (value, offset, scale) {\n  return scale * value + offset;\n};\n\nMetadataComponentType.unapplyValueTransform = function (value, offset, scale) {\n  // if the scale is 0, avoid a divide by zero error. The result can be any\n  // finite number, so 0.0 will do nicely.\n  if (scale === 0) {\n    return 0.0;\n  }\n\n  return (value - offset) / scale;\n};\n\n/**\n * Gets the size in bytes for the numeric type.\n *\n * @param {MetadataComponentType} type The type.\n * @returns {Number} The size in bytes.\n *\n * @exception {DeveloperError} type must be a numeric type\n *\n * @private\n */\nMetadataComponentType.getSizeInBytes = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!MetadataComponentType.isNumericType(type)) {\n    throw new DeveloperError(\"type must be a numeric type\");\n  }\n  //>>includeEnd('debug');\n  switch (type) {\n    case MetadataComponentType.INT8:\n    case MetadataComponentType.UINT8:\n      return 1;\n    case MetadataComponentType.INT16:\n    case MetadataComponentType.UINT16:\n      return 2;\n    case MetadataComponentType.INT32:\n    case MetadataComponentType.UINT32:\n      return 4;\n    case MetadataComponentType.INT64:\n    case MetadataComponentType.UINT64:\n      return 8;\n    case MetadataComponentType.FLOAT32:\n      return 4;\n    case MetadataComponentType.FLOAT64:\n      return 8;\n  }\n};\n\nexport default Object.freeze(MetadataComponentType);\n","import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\n\n/**\n * An entity containing metadata.\n * <p>\n * This type describes an interface and is not intended to be instantiated directly.\n * </p>\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @alias MetadataEntity\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataEntity() {}\n\nObject.defineProperties(MetadataEntity.prototype, {\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof MetadataEntity.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    // eslint-disable-next-line getter-return\n    get: function () {\n      DeveloperError.throwInstantiationError();\n    },\n  },\n});\n\n/**\n * Returns whether the entity has this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the entity has this property.\n * @private\n */\nMetadataEntity.prototype.hasProperty = function (propertyId) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns whether the entity has a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {Boolean} Whether the entity has a property with the given semantic.\n * @private\n */\nMetadataEntity.prototype.hasPropertyBySemantic = function (semantic) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nMetadataEntity.prototype.getPropertyIds = function (results) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n * @private\n */\nMetadataEntity.prototype.getProperty = function (propertyId) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nMetadataEntity.prototype.setProperty = function (propertyId, value) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n * @private\n */\nMetadataEntity.prototype.getPropertyBySemantic = function (semantic) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nMetadataEntity.prototype.setPropertyBySemantic = function (semantic, value) {\n  DeveloperError.throwInstantiationError();\n};\n\n/**\n * Returns whether the entity has this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {Object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {Boolean} Whether the entity has this property.\n *\n * @private\n */\nMetadataEntity.hasProperty = function (\n  propertyId,\n  properties,\n  classDefinition\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  if (defined(properties[propertyId])) {\n    return true;\n  }\n\n  const classProperties = classDefinition.properties;\n  if (!defined(classProperties)) {\n    return false;\n  }\n\n  const classProperty = classProperties[propertyId];\n  if (defined(classProperty) && defined(classProperty.default)) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Returns whether the entity has a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {Object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {Boolean} Whether the entity has a property with the given semantic.\n *\n * @private\n */\nMetadataEntity.hasPropertyBySemantic = function (\n  semantic,\n  properties,\n  classDefinition\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  const propertiesBySemantic = classDefinition.propertiesBySemantic;\n  if (!defined(propertiesBySemantic)) {\n    return false;\n  }\n\n  const property = propertiesBySemantic[semantic];\n  return defined(property);\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {Object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n *\n * @private\n */\nMetadataEntity.getPropertyIds = function (\n  properties,\n  classDefinition,\n  results\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  results = defined(results) ? results : [];\n  results.length = 0;\n\n  // Add entity properties\n  for (const propertyId in properties) {\n    if (\n      properties.hasOwnProperty(propertyId) &&\n      defined(properties[propertyId])\n    ) {\n      results.push(propertyId);\n    }\n  }\n\n  // Add default properties\n  const classProperties = classDefinition.properties;\n  if (defined(classProperties)) {\n    for (const classPropertyId in classProperties) {\n      if (\n        classProperties.hasOwnProperty(classPropertyId) &&\n        !defined(properties[classPropertyId]) &&\n        defined(classProperties[classPropertyId].default)\n      ) {\n        results.push(classPropertyId);\n      }\n    }\n  }\n\n  return results;\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is normalized the normalized value is returned.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {Object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @private\n */\nMetadataEntity.getProperty = function (\n  propertyId,\n  properties,\n  classDefinition\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n\n  if (!defined(classDefinition.properties[propertyId])) {\n    throw new DeveloperError(`Class definition missing property ${propertyId}`);\n  }\n  //>>includeEnd('debug');\n\n  const classProperty = classDefinition.properties[propertyId];\n  let value = properties[propertyId];\n\n  // Clone array values\n  if (Array.isArray(value)) {\n    value = value.slice();\n  }\n\n  // Arrays of vectors are represented as nested arrays in JSON\n  const enableNestedArrays = true;\n\n  // Handle noData and default\n  value = classProperty.handleNoData(value);\n  if (!defined(value) && defined(classProperty.default)) {\n    value = clone(classProperty.default, true);\n    return classProperty.unpackVectorAndMatrixTypes(value, enableNestedArrays);\n  }\n\n  if (!defined(value)) {\n    return undefined;\n  }\n\n  value = classProperty.normalize(value);\n  value = classProperty.applyValueTransform(value);\n  return classProperty.unpackVectorAndMatrixTypes(value, enableNestedArrays);\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is normalized a normalized value must be provided to this function.\n * </p>\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @param {Object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @private\n */\nMetadataEntity.setProperty = function (\n  propertyId,\n  value,\n  properties,\n  classDefinition\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  Check.defined(\"value\", value);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  if (!defined(properties[propertyId])) {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    value = value.slice(); // clone\n  }\n\n  let classProperty;\n  const classProperties = classDefinition.properties;\n  if (defined(classProperties)) {\n    classProperty = classProperties[propertyId];\n  }\n\n  // arrays of vectors are represented as nested arrays in JSON\n  const enableNestedArrays = true;\n  if (defined(classProperty)) {\n    value = classProperty.packVectorAndMatrixTypes(value, enableNestedArrays);\n    value = classProperty.unapplyValueTransform(value);\n    value = classProperty.unnormalize(value);\n  }\n\n  properties[propertyId] = value;\n  return true;\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {Object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @private\n */\nMetadataEntity.getPropertyBySemantic = function (\n  semantic,\n  properties,\n  classDefinition\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  const propertiesBySemantic = classDefinition.propertiesBySemantic;\n  if (!defined(propertiesBySemantic)) {\n    return undefined;\n  }\n\n  const property = propertiesBySemantic[semantic];\n  if (defined(property)) {\n    return MetadataEntity.getProperty(property.id, properties, classDefinition);\n  }\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @param {Object} properties The dictionary containing properties.\n * @param {MetadataClass} classDefinition The class.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n * @private\n */\nMetadataEntity.setPropertyBySemantic = function (\n  semantic,\n  value,\n  properties,\n  classDefinition\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  Check.defined(\"value\", value);\n  Check.typeOf.object(\"properties\", properties);\n  Check.typeOf.object(\"classDefinition\", classDefinition);\n  //>>includeEnd('debug');\n\n  const propertiesBySemantic = classDefinition.propertiesBySemantic;\n  if (!defined(propertiesBySemantic)) {\n    return false;\n  }\n\n  const property = classDefinition.propertiesBySemantic[semantic];\n  if (defined(property)) {\n    return MetadataEntity.setProperty(\n      property.id,\n      value,\n      properties,\n      classDefinition\n    );\n  }\n\n  return false;\n};\n\nexport default MetadataEntity;\n","import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport MetadataEnumValue from \"./MetadataEnumValue.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\n\n/**\n * A metadata enum.\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} options.id The ID of the enum.\n * @param {Object} options.enum The enum JSON object.\n *\n * @alias MetadataEnum\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataEnum(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const id = options.id;\n  const enumDefinition = options.enum;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"options.id\", id);\n  Check.typeOf.object(\"options.enum\", enumDefinition);\n  //>>includeEnd('debug');\n\n  const namesByValue = {};\n  const valuesByName = {};\n  const values = enumDefinition.values.map(function (value) {\n    namesByValue[value.value] = value.name;\n    valuesByName[value.name] = value.value;\n    return new MetadataEnumValue(value);\n  });\n\n  const valueType = defaultValue(\n    MetadataComponentType[enumDefinition.valueType],\n    MetadataComponentType.UINT16\n  );\n\n  this._values = values;\n  this._namesByValue = namesByValue;\n  this._valuesByName = valuesByName;\n  this._valueType = valueType;\n  this._id = id;\n  this._name = enumDefinition.name;\n  this._description = enumDefinition.description;\n  this._extras = enumDefinition.extras;\n  this._extensions = enumDefinition.extensions;\n}\n\nObject.defineProperties(MetadataEnum.prototype, {\n  /**\n   * The enum values.\n   *\n   * @memberof MetadataEnum.prototype\n   * @type {MetadataEnumValue[]}\n   * @readonly\n   * @private\n   */\n  values: {\n    get: function () {\n      return this._values;\n    },\n  },\n\n  /**\n   * A dictionary mapping enum integer values to names.\n   *\n   * @memberof MetadataEnum.prototype\n   * @type {Object.<Number, String>}\n   * @readonly\n   *\n   * @private\n   */\n  namesByValue: {\n    get: function () {\n      return this._namesByValue;\n    },\n  },\n\n  /**\n   * A dictionary mapping enum names to integer values.\n   *\n   * @memberof MetadataEnum.prototype\n   * @type {Object.<String, Number>}\n   * @readonly\n   *\n   * @private\n   */\n  valuesByName: {\n    get: function () {\n      return this._valuesByName;\n    },\n  },\n\n  /**\n   * The enum value type.\n   *\n   * @memberof MetadataEnum.prototype\n   * @type {MetadataComponentType}\n   * @readonly\n   *\n   * @private\n   */\n  valueType: {\n    get: function () {\n      return this._valueType;\n    },\n  },\n\n  /**\n   * The ID of the enum.\n   *\n   * @memberof MetadataEnum.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * The name of the enum.\n   *\n   * @memberof MetadataEnum.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The description of the enum.\n   *\n   * @memberof MetadataEnum.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  description: {\n    get: function () {\n      return this._description;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof MetadataEnum.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof MetadataEnum.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\nexport default MetadataEnum;\n","import Check from \"../Core/Check.js\";\n\n/**\n * A metadata enum value.\n *\n * @param {Object} value The enum value JSON object.\n *\n * @alias MetadataEnumValue\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataEnumValue(value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  //>>includeEnd('debug');\n\n  this._value = value.value;\n  this._name = value.name;\n  this._description = value.description;\n  this._extras = value.extras;\n  this._extensions = value.extensions;\n}\n\nObject.defineProperties(MetadataEnumValue.prototype, {\n  /**\n   * The integer value.\n   *\n   * @memberof MetadataEnumValue.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  value: {\n    get: function () {\n      return this._value;\n    },\n  },\n\n  /**\n   * The name of the enum value.\n   *\n   * @memberof MetadataEnumValue.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The description of the enum value.\n   *\n   * @memberof MetadataEnumValue.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  description: {\n    get: function () {\n      return this._description;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof MetadataEnumValue.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof MetadataEnumValue.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\nexport default MetadataEnumValue;\n","import Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataClass from \"./MetadataClass.js\";\nimport MetadataEnum from \"./MetadataEnum.js\";\n\n/**\n * A schema containing classes and enums.\n * <p>\n * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles\n * </p>\n *\n * @param {Object} schema The schema JSON object.\n *\n * @alias MetadataSchema\n * @constructor\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataSchema(schema) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"schema\", schema);\n  //>>includeEnd('debug');\n\n  const enums = {};\n  if (defined(schema.enums)) {\n    for (const enumId in schema.enums) {\n      if (schema.enums.hasOwnProperty(enumId)) {\n        enums[enumId] = new MetadataEnum({\n          id: enumId,\n          enum: schema.enums[enumId],\n        });\n      }\n    }\n  }\n\n  const classes = {};\n  if (defined(schema.classes)) {\n    for (const classId in schema.classes) {\n      if (schema.classes.hasOwnProperty(classId)) {\n        classes[classId] = new MetadataClass({\n          id: classId,\n          class: schema.classes[classId],\n          enums: enums,\n        });\n      }\n    }\n  }\n\n  this._classes = classes;\n  this._enums = enums;\n  this._id = schema.id;\n  this._name = schema.name;\n  this._description = schema.description;\n  this._version = schema.version;\n  this._extras = schema.extras;\n  this._extensions = schema.extensions;\n}\n\nObject.defineProperties(MetadataSchema.prototype, {\n  /**\n   * Classes defined in the schema.\n   *\n   * @memberof MetadataSchema.prototype\n   * @type {Object.<String, MetadataClass>}\n   * @readonly\n   * @private\n   */\n  classes: {\n    get: function () {\n      return this._classes;\n    },\n  },\n\n  /**\n   * Enums defined in the schema.\n   *\n   * @memberof MetadataSchema.prototype\n   * @type {Object.<String, MetadataEnum>}\n   * @readonly\n   * @private\n   */\n  enums: {\n    get: function () {\n      return this._enums;\n    },\n  },\n\n  /**\n   * The ID of the schema.\n   *\n   * @memberof MetadataSchema.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * The name of the schema.\n   *\n   * @memberof MetadataSchema.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The description of the schema.\n   *\n   * @memberof MetadataSchema.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  description: {\n    get: function () {\n      return this._description;\n    },\n  },\n\n  /**\n   * The application-specific version of the schema.\n   *\n   * @memberof MetadataSchema.prototype\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  version: {\n    get: function () {\n      return this._version;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof MetadataSchema.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof MetadataSchema.prototype\n   * @type {Object}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\nexport default MetadataSchema;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport MetadataSchema from \"./MetadataSchema.js\";\nimport ResourceLoader from \"./ResourceLoader.js\";\nimport ResourceLoaderState from \"./ResourceLoaderState.js\";\n\n/**\n * A {@link MetadataSchema} loader.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias MetadataSchemaLoader\n * @constructor\n * @augments ResourceLoader\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} [options.schema] An object that explicitly defines a schema JSON. Mutually exclusive with options.resource.\n * @param {Resource} [options.resource] The {@link Resource} pointing to the schema JSON. Mutually exclusive with options.schema.\n * @param {String} [options.cacheKey] The cache key of the resource.\n *\n * @exception {DeveloperError} One of options.schema and options.resource must be defined.\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function MetadataSchemaLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const schema = options.schema;\n  const resource = options.resource;\n  const cacheKey = options.cacheKey;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(schema) === defined(resource)) {\n    throw new DeveloperError(\n      \"One of options.schema and options.resource must be defined.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._schema = defined(schema) ? new MetadataSchema(schema) : undefined;\n  this._resource = resource;\n  this._cacheKey = cacheKey;\n  this._state = ResourceLoaderState.UNLOADED;\n  this._promise = undefined;\n}\n\nif (defined(Object.create)) {\n  MetadataSchemaLoader.prototype = Object.create(ResourceLoader.prototype);\n  MetadataSchemaLoader.prototype.constructor = MetadataSchemaLoader;\n}\n\nObject.defineProperties(MetadataSchemaLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof MetadataSchemaLoader.prototype\n   *\n   * @type {Promise.<MetadataSchemaLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof MetadataSchemaLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n  /**\n   * The metadata schema object.\n   *\n   * @memberof MetadataSchemaLoader.prototype\n   *\n   * @type {MetadataSchema}\n   * @readonly\n   * @private\n   */\n  schema: {\n    get: function () {\n      return this._schema;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<MetadataSchemaLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nMetadataSchemaLoader.prototype.load = function () {\n  if (defined(this._schema)) {\n    this._promise = Promise.resolve(this);\n  } else {\n    this._promise = loadExternalSchema(this);\n  }\n\n  return this._promise;\n};\n\nfunction loadExternalSchema(schemaLoader) {\n  const resource = schemaLoader._resource;\n  schemaLoader._state = ResourceLoaderState.LOADING;\n  return resource\n    .fetchJson()\n    .then(function (json) {\n      if (schemaLoader.isDestroyed()) {\n        return;\n      }\n      schemaLoader._schema = new MetadataSchema(json);\n      schemaLoader._state = ResourceLoaderState.READY;\n      return schemaLoader;\n    })\n    .catch(function (error) {\n      if (schemaLoader.isDestroyed()) {\n        return;\n      }\n      schemaLoader._state = ResourceLoaderState.FAILED;\n      const errorMessage = `Failed to load schema: ${resource.url}`;\n      return Promise.reject(schemaLoader.getError(errorMessage, error));\n    });\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nMetadataSchemaLoader.prototype.unload = function () {\n  this._schema = undefined;\n};\n","/**\n * An enum of built-in semantics.\n *\n * @enum MetadataSemantic\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n * @see {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata/Semantics|3D Metadata Semantic Reference}\n */\nconst MetadataSemantic = {\n  /**\n   * A unique identifier, stored as a <code>STRING</code>.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  ID: \"ID\",\n  /**\n   * A name, stored as a <code>STRING</code>. This does not have to be unique.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  NAME: \"NAME\",\n  /**\n   * A description, stored as a <code>STRING</code>.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  DESCRIPTION: \"DESCRIPTION\",\n  /**\n   * A bounding box for a tile, stored as an array of 12 <code>FLOAT32</code> or <code>FLOAT64</code> components. The components are the same format as for <code>boundingVolume.box</code> in 3D Tiles 1.0. This semantic is used to provide a tighter bounding volume than the one implicitly calculated in implicit tiling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  TILE_BOUNDING_BOX: \"TILE_BOUNDING_BOX\",\n  /**\n   * A bounding region for a tile, stored as an array of 6 <code>FLOAT64</code> components. The components are <code>[west, south, east, north, minimumHeight, maximumHeight]</code>. This semantic is used to provide a tighter bounding volume than the one implicitly calculated in implicit tiling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  TILE_BOUNDING_REGION: \"TILE_BOUNDING_REGION\",\n  /**\n   * A bounding sphere for a tile, stored as an array of 4 <code>FLOAT32</code> or <code>FLOAT64</code> components. The components are <code>[centerX, centerY, centerZ, radius]</code>. This semantic is used to provide a tighter bounding volume than the one implicitly calculated in implicit tiling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  TILE_BOUNDING_SPHERE: \"TILE_BOUNDING_SPHERE\",\n  /**\n   * The minimum height of a tile above (or below) the WGS84 ellipsoid, stored as a <code>FLOAT32</code> or a <code>FLOAT64</code>. This semantic is used to tighten bounding regions implicitly calculated in implicit tiling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  TILE_MINIMUM_HEIGHT: \"TILE_MINIMUM_HEIGHT\",\n  /**\n   * The maximum height of a tile above (or below) the WGS84 ellipsoid, stored as a <code>FLOAT32</code> or a <code>FLOAT64</code>. This semantic is used to tighten bounding regions implicitly calculated in implicit tiling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  TILE_MAXIMUM_HEIGHT: \"TILE_MAXIMUM_HEIGHT\",\n  /**\n   * The horizon occlusion point for a tile, stored as an <code>VEC3</code> of <code>FLOAT32</code> or <code>FLOAT64</code> components.\n   *\n   * @see {@link https://cesium.com/blog/2013/04/25/horizon-culling/|Horizon Culling}\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  TILE_HORIZON_OCCLUSION_POINT: \"TILE_HORIZON_OCCLUSION_POINT\",\n  /**\n   * The geometric error for a tile, stored as a <code>FLOAT32</code> or a <code>FLOAT64</code>. This semantic is used to override the geometric error implicitly calculated in implicit tiling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  TILE_GEOMETRIC_ERROR: \"TILE_GEOMETRIC_ERROR\",\n  /**\n   * A bounding box for the content of a tile, stored as an array of 12 <code>FLOAT32</code> or <code>FLOAT64</code> components. The components are the same format as for <code>boundingVolume.box</code> in 3D Tiles 1.0. This semantic is used to provide a tighter bounding volume than the one implicitly calculated in implicit tiling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  CONTENT_BOUNDING_BOX: \"CONTENT_BOUNDING_BOX\",\n  /**\n   * A bounding region for the content of a tile, stored as an array of 6 <code>FLOAT64</code> components. The components are <code>[west, south, east, north, minimumHeight, maximumHeight]</code>. This semantic is used to provide a tighter bounding volume than the one implicitly calculated in implicit tiling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  CONTENT_BOUNDING_REGION: \"CONTENT_BOUNDING_REGION\",\n  /**\n   * A bounding sphere for the content of a tile, stored as an array of 4 <code>FLOAT32</code> or <code>FLOAT64</code> components. The components are <code>[centerX, centerY, centerZ, radius]</code>. This semantic is used to provide a tighter bounding volume than the one implicitly calculated in implicit tiling.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  CONTENT_BOUNDING_SPHERE: \"CONTENT_BOUNDING_SPHERE\",\n  /**\n   * The minimum height of the content of a tile above (or below) the WGS84 ellipsoid, stored as a <code>FLOAT32</code> or a <code>FLOAT64</code>\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  CONTENT_MINIMUM_HEIGHT: \"CONTENT_MINIMUM_HEIGHT\",\n  /**\n   * The maximum height of the content of a tile above (or below) the WGS84 ellipsoid, stored as a <code>FLOAT32</code> or a <code>FLOAT64</code>\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  CONTENT_MAXIMUM_HEIGHT: \"CONTENT_MAXIMUM_HEIGHT\",\n  /**\n   * The horizon occlusion point for the content of a tile, stored as an <code>VEC3</code> of <code>FLOAT32</code> or <code>FLOAT64</code> components.\n   *\n   * @see {@link https://cesium.com/blog/2013/04/25/horizon-culling/|Horizon Culling}\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  CONTENT_HORIZON_OCCLUSION_POINT: \"CONTENT_HORIZON_OCCLUSION_POINT\",\n};\n\nexport default Object.freeze(MetadataSemantic);\n","import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport MetadataEntity from \"./MetadataEntity.js\";\nimport MetadataTableProperty from \"./MetadataTableProperty.js\";\n\n/**\n * A table containing binary metadata for a collection of entities. This is\n * used for representing binary properties of a batch table, as well as binary\n * metadata in 3D Tiles next extensions.\n * <p>\n * For 3D Tiles Next details, see the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension} for 3D Tiles, as well as the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.count The number of entities in the table.\n * @param {Object} [options.properties] A dictionary containing properties.\n * @param {MetadataClass} options.class The class that properties conform to.\n * @param {Object.<String, Uint8Array>} [options.bufferViews] An object mapping bufferView IDs to Uint8Array objects.\n *\n * @alias MetadataTable\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataTable(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const count = options.count;\n  const metadataClass = options.class;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"options.count\", count, 0);\n  Check.typeOf.object(\"options.class\", metadataClass);\n  //>>includeEnd('debug');\n\n  const properties = {};\n  if (defined(options.properties)) {\n    for (const propertyId in options.properties) {\n      if (options.properties.hasOwnProperty(propertyId)) {\n        properties[propertyId] = new MetadataTableProperty({\n          count: count,\n          property: options.properties[propertyId],\n          classProperty: metadataClass.properties[propertyId],\n          bufferViews: options.bufferViews,\n        });\n      }\n    }\n  }\n\n  this._count = count;\n  this._class = metadataClass;\n  this._properties = properties;\n}\n\nObject.defineProperties(MetadataTable.prototype, {\n  /**\n   * The number of entities in the table.\n   *\n   * @memberof MetadataTable.prototype\n   * @type {Number}\n   * @readonly\n   * @private\n   */\n  count: {\n    get: function () {\n      return this._count;\n    },\n  },\n\n  /**\n   * The class that properties conform to.\n   *\n   * @memberof MetadataTable.prototype\n   * @type {MetadataClass}\n   * @readonly\n   * @private\n   */\n  class: {\n    get: function () {\n      return this._class;\n    },\n  },\n});\n\n/**\n * Returns whether the table has this property.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {Boolean} Whether the table has this property.\n * @private\n */\nMetadataTable.prototype.hasProperty = function (propertyId) {\n  return MetadataEntity.hasProperty(propertyId, this._properties, this._class);\n};\n\n/**\n * Returns whether the table has a property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {Boolean} Whether the table has a property with the given semantic.\n * @private\n */\nMetadataTable.prototype.hasPropertyBySemantic = function (semantic) {\n  return MetadataEntity.hasPropertyBySemantic(\n    semantic,\n    this._properties,\n    this._class\n  );\n};\n\n/**\n * Returns an array of property IDs.\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The property IDs.\n * @private\n */\nMetadataTable.prototype.getPropertyIds = function (results) {\n  return MetadataEntity.getPropertyIds(this._properties, this._class, results);\n};\n\n/**\n * Returns a copy of the value of the property with the given ID.\n * <p>\n * If the property is an enum the name of the enum is returned.\n * </p>\n * <p>\n * If the property is normalized the normalized value is returned. The value is\n * in the range [-1.0, 1.0] for signed integer types and [0.0, 1.0] for unsigned\n * integer types.\n * </p>\n * <p>\n * If the property is not normalized and type or componentType is INT64 or\n * UINT64 a BigInt will be returned. On platforms that don't support BigInt a\n * number will be returned instead. Note that numbers only support up to 52 bits\n * of integer precision. Values greater than 2^53 - 1 or less than -(2^53 - 1)\n * may lose precision when read.\n * </p>\n *\n * @param {Number} index The index of the entity.\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this property.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @private\n */\nMetadataTable.prototype.getProperty = function (index, propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n\n  let value;\n  if (defined(property)) {\n    value = property.get(index);\n  } else {\n    value = getDefault(this._class, propertyId);\n  }\n\n  return value;\n};\n\n/**\n * Sets the value of the property with the given ID.\n * <p>\n * If the property is an enum the name of the enum must be provided, not the\n * integer value.\n * </p>\n * <p>\n * If the property is normalized a normalized value must be provided to this\n * function. The value must be in the range [-1.0, 1.0] for signed integer\n * types and [0.0, 1.0] for unsigned integer types.\n * </p>\n * <p>\n * If the property is not normalized and type or componentType is INT64 or\n * UINT64 a BigInt may be provided. On platforms that don't support BigInt a\n * number may be provided instead. Note that numbers only support up to 52 bits\n * of integer precision. Values greater than 2^53 - 1 or less than -(2^53 - 1)\n * may lose precision when set.\"\n * </p>\n *\n * @param {Number} index The index of the entity.\n * @param {String} propertyId The case-sensitive ID of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @exception {DeveloperError} value does not match type\n * @exception {DeveloperError} value is out of range for type\n * @exception {DeveloperError} Array length does not match componentCount\n * @private\n */\nMetadataTable.prototype.setProperty = function (index, propertyId, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n  if (defined(property)) {\n    property.set(index, value);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Returns a copy of the value of the property with the given semantic.\n *\n * @param {Number} index The index of the entity.\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the entity does not have this semantic.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @private\n */\nMetadataTable.prototype.getPropertyBySemantic = function (index, semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let property;\n  const propertiesBySemantic = this._class.propertiesBySemantic;\n  if (defined(propertiesBySemantic)) {\n    property = propertiesBySemantic[semantic];\n  }\n\n  if (defined(property)) {\n    return this.getProperty(index, property.id);\n  }\n\n  return undefined;\n};\n\n/**\n * Sets the value of the property with the given semantic.\n *\n * @param {Number} index The index of the entity.\n * @param {String} semantic The case-sensitive semantic of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} index is required and between zero and count - 1\n * @exception {DeveloperError} value does not match type\n * @exception {DeveloperError} value is out of range for type\n * @exception {DeveloperError} Array length does not match componentCount\n * @private\n */\nMetadataTable.prototype.setPropertyBySemantic = function (\n  index,\n  semantic,\n  value\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let property;\n  const propertiesBySemantic = this._class.propertiesBySemantic;\n  if (defined(propertiesBySemantic)) {\n    property = propertiesBySemantic[semantic];\n  }\n\n  if (defined(property)) {\n    return this.setProperty(index, property.id, value);\n  }\n\n  return false;\n};\n\n/**\n * Returns a typed array containing the property values for a given propertyId.\n *\n * @param {String} propertyId The case-sensitive ID of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nMetadataTable.prototype.getPropertyTypedArray = function (propertyId) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"propertyId\", propertyId);\n  //>>includeEnd('debug');\n\n  const property = this._properties[propertyId];\n\n  if (defined(property)) {\n    return property.getTypedArray();\n  }\n\n  return undefined;\n};\n\n/**\n * Returns a typed array containing the property values for the property with the given semantic.\n *\n * @param {String} semantic The case-sensitive semantic of the property.\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nMetadataTable.prototype.getPropertyTypedArrayBySemantic = function (semantic) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"semantic\", semantic);\n  //>>includeEnd('debug');\n\n  let property;\n  const propertiesBySemantic = this._class.propertiesBySemantic;\n  if (defined(propertiesBySemantic)) {\n    property = propertiesBySemantic[semantic];\n  }\n\n  if (defined(property)) {\n    return this.getPropertyTypedArray(property.id);\n  }\n\n  return undefined;\n};\n\nfunction getDefault(classDefinition, propertyId) {\n  const classProperties = classDefinition.properties;\n  if (!defined(classProperties)) {\n    return undefined;\n  }\n\n  const classProperty = classProperties[propertyId];\n  if (defined(classProperty) && defined(classProperty.default)) {\n    let value = classProperty.default;\n    if (classProperty.isArray) {\n      value = clone(value, true);\n    }\n    value = classProperty.normalize(value);\n    return classProperty.unpackVectorAndMatrixTypes(value);\n  }\n}\n\nexport default MetadataTable;\n","import Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport MetadataComponentType from \"./MetadataComponentType.js\";\nimport MetadataClassProperty from \"./MetadataClassProperty.js\";\nimport MetadataType from \"./MetadataType.js\";\n\n/**\n * A binary property in a {@MetadataTable}\n * <p>\n * For 3D Tiles Next details, see the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension}\n * for 3D Tiles, as well as the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension}\n * for glTF. For the legacy glTF extension, see {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension}\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Number} options.count The number of elements in each property array.\n * @param {Object} options.property The property JSON object.\n * @param {MetadataClassProperty} options.classProperty The class property.\n * @param {Object.<String, Uint8Array>} options.bufferViews An object mapping bufferView IDs to Uint8Array objects.\n *\n * @alias MetadataTableProperty\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction MetadataTableProperty(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const count = options.count;\n  const property = options.property;\n  const classProperty = options.classProperty;\n  const bufferViews = options.bufferViews;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThan(\"options.count\", count, 0);\n  Check.typeOf.object(\"options.property\", property);\n  Check.typeOf.object(\"options.classProperty\", classProperty);\n  Check.typeOf.object(\"options.bufferViews\", bufferViews);\n  //>>includeEnd('debug');\n\n  const type = classProperty.type;\n  const isArray = classProperty.isArray;\n  const isVariableLengthArray = classProperty.isVariableLengthArray;\n\n  let valueType = classProperty.valueType;\n  const enumType = classProperty.enumType;\n\n  const hasStrings = type === MetadataType.STRING;\n  const hasBooleans = type === MetadataType.BOOLEAN;\n\n  let arrayOffsets;\n  if (isVariableLengthArray) {\n    // EXT_structural_metadata uses arrayOffsetType.\n    // EXT_feature_metadata uses offsetType for both arrays and strings\n    let arrayOffsetType = defaultValue(\n      property.arrayOffsetType,\n      property.offsetType\n    );\n    arrayOffsetType = defaultValue(\n      MetadataComponentType[arrayOffsetType],\n      MetadataComponentType.UINT32\n    );\n\n    // EXT_structural_metadata uses arrayOffsets.\n    // EXT_feature_metadata uses arrayOffsetBufferView\n    const arrayOffsetBufferView = defaultValue(\n      property.arrayOffsets,\n      property.arrayOffsetBufferView\n    );\n    arrayOffsets = new BufferView(\n      bufferViews[arrayOffsetBufferView],\n      arrayOffsetType,\n      count + 1\n    );\n  }\n\n  const vectorComponentCount = MetadataType.getComponentCount(type);\n\n  let arrayComponentCount;\n  if (isVariableLengthArray) {\n    arrayComponentCount = arrayOffsets.get(count) - arrayOffsets.get(0);\n  } else if (isArray) {\n    arrayComponentCount = count * classProperty.arrayLength;\n  } else {\n    arrayComponentCount = count;\n  }\n\n  const componentCount = vectorComponentCount * arrayComponentCount;\n\n  let stringOffsets;\n  if (hasStrings) {\n    // EXT_structural_metadata uses stringOffsetType, EXT_feature_metadata uses offsetType for both arrays and strings\n    let stringOffsetType = defaultValue(\n      property.stringOffsetType,\n      property.offsetType\n    );\n    stringOffsetType = defaultValue(\n      MetadataComponentType[stringOffsetType],\n      MetadataComponentType.UINT32\n    );\n\n    // EXT_structural_metadata uses stringOffsets.\n    // EXT_feature_metadata uses stringOffsetBufferView\n    const stringOffsetBufferView = defaultValue(\n      property.stringOffsets,\n      property.stringOffsetBufferView\n    );\n    stringOffsets = new BufferView(\n      bufferViews[stringOffsetBufferView],\n      stringOffsetType,\n      componentCount + 1\n    );\n  }\n\n  if (hasStrings || hasBooleans) {\n    // STRING and BOOLEAN types need to be parsed differently than other types\n    valueType = MetadataComponentType.UINT8;\n  }\n\n  let valueCount;\n  if (hasStrings) {\n    valueCount = stringOffsets.get(componentCount) - stringOffsets.get(0);\n  } else if (hasBooleans) {\n    valueCount = Math.ceil(componentCount / 8);\n  } else {\n    valueCount = componentCount;\n  }\n\n  // EXT_structural_metadata uses values\n  // EXT_feature_metadata uses bufferView\n  const valuesBufferView = defaultValue(property.values, property.bufferView);\n  const values = new BufferView(\n    bufferViews[valuesBufferView],\n    valueType,\n    valueCount\n  );\n\n  let offset = property.offset;\n  let scale = property.scale;\n\n  // This needs to be set before handling default values\n  const hasValueTransform =\n    classProperty.hasValueTransform || defined(offset) || defined(scale);\n\n  // If the table does not define an offset/scale, it inherits from the\n  // class property. The class property handles setting the default of identity:\n  // (offset 0, scale 1) with the same array shape as the property's type\n  // information.\n  offset = defaultValue(offset, classProperty.offset);\n  scale = defaultValue(scale, classProperty.scale);\n\n  // Since metadata table properties are stored as packed typed\n  // arrays, flatten the offset/scale to make it easier to apply the\n  // transformation by iteration.\n  offset = flatten(offset);\n  scale = flatten(scale);\n\n  let getValueFunction;\n  let setValueFunction;\n  const that = this;\n  if (hasStrings) {\n    getValueFunction = function (index) {\n      return getString(index, that._values, that._stringOffsets);\n    };\n  } else if (hasBooleans) {\n    getValueFunction = function (index) {\n      return getBoolean(index, that._values);\n    };\n    setValueFunction = function (index, value) {\n      setBoolean(index, that._values, value);\n    };\n  } else if (defined(enumType)) {\n    getValueFunction = function (index) {\n      const integer = that._values.get(index);\n      return enumType.namesByValue[integer];\n    };\n    setValueFunction = function (index, value) {\n      const integer = enumType.valuesByName[value];\n      that._values.set(index, integer);\n    };\n  } else {\n    getValueFunction = function (index) {\n      return that._values.get(index);\n    };\n    setValueFunction = function (index, value) {\n      that._values.set(index, value);\n    };\n  }\n\n  this._arrayOffsets = arrayOffsets;\n  this._stringOffsets = stringOffsets;\n  this._values = values;\n  this._classProperty = classProperty;\n  this._count = count;\n  this._vectorComponentCount = vectorComponentCount;\n  this._min = property.min;\n  this._max = property.max;\n  this._offset = offset;\n  this._scale = scale;\n  this._hasValueTransform = hasValueTransform;\n  this._getValue = getValueFunction;\n  this._setValue = setValueFunction;\n  this._unpackedValues = undefined;\n  this._extras = property.extras;\n  this._extensions = property.extensions;\n}\n\nObject.defineProperties(MetadataTableProperty.prototype, {\n  /**\n   * True if offset/scale should be applied. If both offset/scale were\n   * undefined, they default to identity so this property is set false\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Boolean}\n   * @readonly\n   * @private\n   */\n  hasValueTransform: {\n    get: function () {\n      return this._hasValueTransform;\n    },\n  },\n\n  /**\n   * The offset to be added to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Number|Number[]|Number[][]}\n   * @readonly\n   * @private\n   */\n  offset: {\n    get: function () {\n      return this._offset;\n    },\n  },\n\n  /**\n   * The scale to be multiplied to property values as part of the value transform.\n   *\n   * @memberof MetadataClassProperty.prototype\n   * @type {Number|Number[]|Number[][]}\n   * @readonly\n   * @private\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n  },\n\n  /**\n   * Extras in the JSON object.\n   *\n   * @memberof MetadataTableProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extras: {\n    get: function () {\n      return this._extras;\n    },\n  },\n\n  /**\n   * Extensions in the JSON object.\n   *\n   * @memberof MetadataTableProperty.prototype\n   * @type {*}\n   * @readonly\n   * @private\n   */\n  extensions: {\n    get: function () {\n      return this._extensions;\n    },\n  },\n});\n\n/**\n * Returns a copy of the value at the given index.\n *\n * @param {Number} index The index.\n * @returns {*} The value of the property.\n *\n * @private\n */\nMetadataTableProperty.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  checkIndex(this, index);\n  //>>includeEnd('debug');\n\n  let value = get(this, index);\n\n  // handle noData and default\n  value = this._classProperty.handleNoData(value);\n  if (!defined(value)) {\n    value = this._classProperty.default;\n    return this._classProperty.unpackVectorAndMatrixTypes(value);\n  }\n\n  value = this._classProperty.normalize(value);\n  value = applyValueTransform(this, value);\n  return this._classProperty.unpackVectorAndMatrixTypes(value);\n};\n\n/**\n * Sets the value at the given index.\n *\n * @param {Number} index The index.\n * @param {*} value The value of the property.\n *\n * @private\n */\nMetadataTableProperty.prototype.set = function (index, value) {\n  const classProperty = this._classProperty;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"value\", value);\n  checkIndex(this, index);\n  const errorMessage = classProperty.validate(value);\n  if (defined(errorMessage)) {\n    throw new DeveloperError(errorMessage);\n  }\n  //>>includeEnd('debug');\n\n  value = classProperty.packVectorAndMatrixTypes(value);\n  value = unapplyValueTransform(this, value);\n  value = classProperty.unnormalize(value);\n\n  set(this, index, value);\n};\n\n/**\n * Returns a typed array containing the property values.\n *\n * @returns {*} The typed array containing the property values or <code>undefined</code> if the property values are not stored in a typed array.\n *\n * @private\n */\nMetadataTableProperty.prototype.getTypedArray = function () {\n  // Note: depending on the class definition some properties are unpacked to\n  // JS arrays when first accessed and values will be undefined. Generally not\n  // a concern for fixed-length arrays of numbers.\n  if (defined(this._values)) {\n    return this._values.typedArray;\n  }\n\n  return undefined;\n};\n\nfunction flatten(values) {\n  if (!Array.isArray(values)) {\n    return values;\n  }\n\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (Array.isArray(value)) {\n      result.push.apply(result, value);\n    } else {\n      result.push(value);\n    }\n  }\n\n  return result;\n}\n\nfunction checkIndex(table, index) {\n  const count = table._count;\n  if (!defined(index) || index < 0 || index >= count) {\n    const maximumIndex = count - 1;\n    throw new DeveloperError(\n      `index is required and between zero and count - 1. Actual value: ${maximumIndex}`\n    );\n  }\n}\n\nfunction get(property, index) {\n  if (requiresUnpackForGet(property)) {\n    unpackProperty(property);\n  }\n\n  const classProperty = property._classProperty;\n  const isArray = classProperty.isArray;\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n\n  if (defined(property._unpackedValues)) {\n    const value = property._unpackedValues[index];\n    if (isArray) {\n      return clone(value, true);\n    }\n    return value;\n  }\n\n  // handle single values\n  if (!isArray && componentCount === 1) {\n    return property._getValue(index);\n  }\n\n  return getArrayValues(property, classProperty, index);\n}\n\nfunction getArrayValues(property, classProperty, index) {\n  let offset;\n  let length;\n  if (classProperty.isVariableLengthArray) {\n    offset = property._arrayOffsets.get(index);\n    length = property._arrayOffsets.get(index + 1) - offset;\n\n    // for vectors and matrices, the offset and length need to be multiplied\n    // by the component count\n    const componentCount = MetadataType.getComponentCount(classProperty.type);\n    offset *= componentCount;\n    length *= componentCount;\n  } else {\n    const arrayLength = defaultValue(classProperty.arrayLength, 1);\n    const componentCount = arrayLength * property._vectorComponentCount;\n    offset = index * componentCount;\n    length = componentCount;\n  }\n\n  const values = new Array(length);\n  for (let i = 0; i < length; i++) {\n    values[i] = property._getValue(offset + i);\n  }\n\n  return values;\n}\n\nfunction set(property, index, value) {\n  if (requiresUnpackForSet(property, index, value)) {\n    unpackProperty(property);\n  }\n\n  const classProperty = property._classProperty;\n  const isArray = classProperty.isArray;\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n\n  if (defined(property._unpackedValues)) {\n    if (classProperty.isArray) {\n      value = clone(value, true);\n    }\n    property._unpackedValues[index] = value;\n    return;\n  }\n\n  // Values are unpacked if the length of a variable-size array changes or the\n  // property has strings. No need to handle these cases below.\n\n  // Handle single values\n  if (!isArray && componentCount === 1) {\n    property._setValue(index, value);\n    return;\n  }\n\n  let offset;\n  let length;\n  if (classProperty.isVariableLengthArray) {\n    offset = property._arrayOffsets.get(index);\n    length = property._arrayOffsets.get(index + 1) - offset;\n  } else {\n    const arrayLength = defaultValue(classProperty.arrayLength, 1);\n    const componentCount = arrayLength * property._vectorComponentCount;\n    offset = index * componentCount;\n    length = componentCount;\n  }\n\n  for (let i = 0; i < length; ++i) {\n    property._setValue(offset + i, value[i]);\n  }\n}\n\nfunction getString(index, values, stringOffsets) {\n  const stringByteOffset = stringOffsets.get(index);\n  const stringByteLength = stringOffsets.get(index + 1) - stringByteOffset;\n  return getStringFromTypedArray(\n    values.typedArray,\n    stringByteOffset,\n    stringByteLength\n  );\n}\n\nfunction getBoolean(index, values) {\n  // byteIndex is floor(index / 8)\n  const byteIndex = index >> 3;\n  const bitIndex = index % 8;\n  return ((values.typedArray[byteIndex] >> bitIndex) & 1) === 1;\n}\n\nfunction setBoolean(index, values, value) {\n  // byteIndex is floor(index / 8)\n  const byteIndex = index >> 3;\n  const bitIndex = index % 8;\n\n  if (value) {\n    values.typedArray[byteIndex] |= 1 << bitIndex;\n  } else {\n    values.typedArray[byteIndex] &= ~(1 << bitIndex);\n  }\n}\n\nfunction getInt64NumberFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n  let value = 0;\n  const isNegative = (dataView.getUint8(byteOffset + 7) & 0x80) > 0;\n  let carrying = true;\n  for (let i = 0; i < 8; ++i) {\n    let byte = dataView.getUint8(byteOffset + i);\n    if (isNegative) {\n      if (carrying) {\n        if (byte !== 0x00) {\n          byte = ~(byte - 1) & 0xff;\n          carrying = false;\n        }\n      } else {\n        byte = ~byte & 0xff;\n      }\n    }\n    value += byte * Math.pow(256, i);\n  }\n  if (isNegative) {\n    value = -value;\n  }\n  return value;\n}\n\nfunction getInt64BigIntFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n  // eslint-disable-next-line no-undef\n  let value = BigInt(0);\n  const isNegative = (dataView.getUint8(byteOffset + 7) & 0x80) > 0;\n  let carrying = true;\n  for (let i = 0; i < 8; ++i) {\n    let byte = dataView.getUint8(byteOffset + i);\n    if (isNegative) {\n      if (carrying) {\n        if (byte !== 0x00) {\n          byte = ~(byte - 1) & 0xff;\n          carrying = false;\n        }\n      } else {\n        byte = ~byte & 0xff;\n      }\n    }\n    value += BigInt(byte) * (BigInt(1) << BigInt(i * 8)); // eslint-disable-line\n  }\n  if (isNegative) {\n    value = -value;\n  }\n  return value;\n}\n\nfunction getUint64NumberFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n\n  // Split 64-bit number into two 32-bit (4-byte) parts\n  const left = dataView.getUint32(byteOffset, true);\n  const right = dataView.getUint32(byteOffset + 4, true);\n\n  // Combine the two 32-bit values\n  const value = left + 4294967296 * right;\n\n  return value;\n}\n\nfunction getUint64BigIntFallback(index, values) {\n  const dataView = values.dataView;\n  const byteOffset = index * 8;\n\n  // Split 64-bit number into two 32-bit (4-byte) parts\n  // eslint-disable-next-line no-undef\n  const left = BigInt(dataView.getUint32(byteOffset, true));\n\n  // eslint-disable-next-line no-undef\n  const right = BigInt(dataView.getUint32(byteOffset + 4, true));\n\n  // Combine the two 32-bit values\n  // eslint-disable-next-line no-undef\n  const value = left + BigInt(4294967296) * right;\n\n  return value;\n}\n\nfunction getComponentDatatype(componentType) {\n  switch (componentType) {\n    case MetadataComponentType.INT8:\n      return ComponentDatatype.BYTE;\n    case MetadataComponentType.UINT8:\n      return ComponentDatatype.UNSIGNED_BYTE;\n    case MetadataComponentType.INT16:\n      return ComponentDatatype.SHORT;\n    case MetadataComponentType.UINT16:\n      return ComponentDatatype.UNSIGNED_SHORT;\n    case MetadataComponentType.INT32:\n      return ComponentDatatype.INT;\n    case MetadataComponentType.UINT32:\n      return ComponentDatatype.UNSIGNED_INT;\n    case MetadataComponentType.FLOAT32:\n      return ComponentDatatype.FLOAT;\n    case MetadataComponentType.FLOAT64:\n      return ComponentDatatype.DOUBLE;\n  }\n}\n\nfunction requiresUnpackForGet(property) {\n  if (defined(property._unpackedValues)) {\n    return false;\n  }\n\n  const classProperty = property._classProperty;\n  const type = classProperty.type;\n  const valueType = classProperty.valueType;\n\n  if (type === MetadataType.STRING) {\n    // Unpack since UTF-8 decoding is expensive\n    return true;\n  }\n\n  if (\n    valueType === MetadataComponentType.INT64 &&\n    !FeatureDetection.supportsBigInt64Array()\n  ) {\n    // Unpack since the fallback INT64 getters are expensive\n    return true;\n  }\n\n  if (\n    valueType === MetadataComponentType.UINT64 &&\n    !FeatureDetection.supportsBigUint64Array()\n  ) {\n    // Unpack since the fallback UINT64 getters are expensive\n    return true;\n  }\n\n  return false;\n}\n\nfunction requiresUnpackForSet(property, index, value) {\n  if (requiresUnpackForGet(property)) {\n    return true;\n  }\n\n  const arrayOffsets = property._arrayOffsets;\n  if (defined(arrayOffsets)) {\n    // Unpacking is required if a variable-size array changes length since it\n    // would be expensive to repack the binary data\n    const oldLength = arrayOffsets.get(index + 1) - arrayOffsets.get(index);\n    const newLength = value.length;\n    if (oldLength !== newLength) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction unpackProperty(property) {\n  property._unpackedValues = unpackValues(property);\n\n  // Free memory\n  property._arrayOffsets = undefined;\n  property._stringOffsets = undefined;\n  property._values = undefined;\n}\n\nfunction unpackValues(property) {\n  const count = property._count;\n  const unpackedValues = new Array(count);\n\n  const classProperty = property._classProperty;\n  const isArray = classProperty.isArray;\n  const type = classProperty.type;\n  const componentCount = MetadataType.getComponentCount(type);\n\n  // Handle single values\n  if (!isArray && componentCount === 1) {\n    for (let i = 0; i < count; ++i) {\n      unpackedValues[i] = property._getValue(i);\n    }\n    return unpackedValues;\n  }\n\n  for (let i = 0; i < count; i++) {\n    unpackedValues[i] = getArrayValues(property, classProperty, i);\n  }\n  return unpackedValues;\n}\n\nfunction applyValueTransform(property, value) {\n  const classProperty = property._classProperty;\n  const isVariableLengthArray = classProperty.isVariableLengthArray;\n  if (!property._hasValueTransform || isVariableLengthArray) {\n    return value;\n  }\n\n  return MetadataClassProperty.valueTransformInPlace(\n    value,\n    property._offset,\n    property._scale,\n    MetadataComponentType.applyValueTransform\n  );\n}\n\nfunction unapplyValueTransform(property, value) {\n  const classProperty = property._classProperty;\n  const isVariableLengthArray = classProperty.isVariableLengthArray;\n  if (!property._hasValueTransform || isVariableLengthArray) {\n    return value;\n  }\n\n  return MetadataClassProperty.valueTransformInPlace(\n    value,\n    property._offset,\n    property._scale,\n    MetadataComponentType.unapplyValueTransform\n  );\n}\n\nfunction BufferView(bufferView, componentType, length) {\n  const that = this;\n\n  let typedArray;\n  let getFunction;\n  let setFunction;\n\n  if (componentType === MetadataComponentType.INT64) {\n    if (!FeatureDetection.supportsBigInt()) {\n      oneTimeWarning(\n        \"INT64 type is not fully supported on this platform. Values greater than 2^53 - 1 or less than -(2^53 - 1) may lose precision when read.\"\n      );\n      typedArray = new Uint8Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length * 8\n      );\n      getFunction = function (index) {\n        return getInt64NumberFallback(index, that);\n      };\n    } else if (!FeatureDetection.supportsBigInt64Array()) {\n      typedArray = new Uint8Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length * 8\n      );\n      getFunction = function (index) {\n        return getInt64BigIntFallback(index, that);\n      };\n    } else {\n      // eslint-disable-next-line\n      typedArray = new BigInt64Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length\n      );\n      setFunction = function (index, value) {\n        // Convert the number to a BigInt before setting the value in the typed array\n        that.typedArray[index] = BigInt(value); // eslint-disable-line\n      };\n    }\n  } else if (componentType === MetadataComponentType.UINT64) {\n    if (!FeatureDetection.supportsBigInt()) {\n      oneTimeWarning(\n        \"UINT64 type is not fully supported on this platform. Values greater than 2^53 - 1 may lose precision when read.\"\n      );\n      typedArray = new Uint8Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length * 8\n      );\n      getFunction = function (index) {\n        return getUint64NumberFallback(index, that);\n      };\n    } else if (!FeatureDetection.supportsBigUint64Array()) {\n      typedArray = new Uint8Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length * 8\n      );\n      getFunction = function (index) {\n        return getUint64BigIntFallback(index, that);\n      };\n    } else {\n      // eslint-disable-next-line\n      typedArray = new BigUint64Array(\n        bufferView.buffer,\n        bufferView.byteOffset,\n        length\n      );\n      setFunction = function (index, value) {\n        // Convert the number to a BigInt before setting the value in the typed array\n        that.typedArray[index] = BigInt(value); // eslint-disable-line\n      };\n    }\n  } else {\n    const componentDatatype = getComponentDatatype(componentType);\n    typedArray = ComponentDatatype.createArrayBufferView(\n      componentDatatype,\n      bufferView.buffer,\n      bufferView.byteOffset,\n      length\n    );\n    setFunction = function (index, value) {\n      that.typedArray[index] = value;\n    };\n  }\n\n  if (!defined(getFunction)) {\n    getFunction = function (index) {\n      return that.typedArray[index];\n    };\n  }\n\n  this.typedArray = typedArray;\n  this.dataView = new DataView(typedArray.buffer, typedArray.byteOffset);\n  this.get = getFunction;\n  this.set = setFunction;\n\n  // for unit testing\n  this._componentType = componentType;\n}\n\nexport default MetadataTableProperty;\n","import Check from \"../Core/Check.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix2 from \"../Core/Matrix2.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\n\n/**\n * An enum of metadata types. These metadata types are containers containing\n * one or more components of type {@link MetadataComponentType}\n *\n * @enum MetadataType\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst MetadataType = {\n  /**\n   * A single component\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  SCALAR: \"SCALAR\",\n  /**\n   * A vector with two components\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  VEC2: \"VEC2\",\n  /**\n   * A vector with three components\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  VEC3: \"VEC3\",\n  /**\n   * A vector with four components\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  VEC4: \"VEC4\",\n  /**\n   * A 2x2 matrix, stored in column-major format.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  MAT2: \"MAT2\",\n  /**\n   * A 2x2 matrix, stored in column-major format.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  MAT3: \"MAT3\",\n  /**\n   * A 2x2 matrix, stored in column-major format.\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  MAT4: \"MAT4\",\n  /**\n   * A boolean (true/false) value\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  BOOLEAN: \"BOOLEAN\",\n  /**\n   * A UTF-8 encoded string value\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  STRING: \"STRING\",\n  /**\n   * An enumerated value. This type is used in conjunction with a {@link MetadataEnum} to describe the valid values.\n   *\n   * @see MetadataEnum\n   *\n   * @type {String}\n   * @constant\n   * @private\n   */\n  ENUM: \"ENUM\",\n};\n\n/**\n * Check if a type is VEC2, VEC3 or VEC4\n *\n * @param {MetadataType} type The type\n * @return {Boolean} <code>true</code> if the type is a vector, <code>false</code> otherwise\n */\nMetadataType.isVectorType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataType.VEC2:\n    case MetadataType.VEC3:\n    case MetadataType.VEC4:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Check if a type is MAT2, MAT3 or MAT4\n *\n * @param {MetadataType} type The type\n * @return {Boolean} <code>true</code> if the type is a matrix, <code>false</code> otherwise\n */\nMetadataType.isMatrixType = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataType.MAT2:\n    case MetadataType.MAT3:\n    case MetadataType.MAT4:\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Get the number of components for a vector or matrix type. e.g.\n * a VECN returns N, and a MATN returns N*N. All other types return 1.\n *\n * @param {MetadataType} type The type to get the component count for\n * @return {Number} The number of components\n */\nMetadataType.getComponentCount = function (type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"type\", type);\n  //>>includeEnd('debug');\n\n  switch (type) {\n    case MetadataType.SCALAR:\n    case MetadataType.STRING:\n    case MetadataType.ENUM:\n    case MetadataType.BOOLEAN:\n      return 1;\n    case MetadataType.VEC2:\n      return 2;\n    case MetadataType.VEC3:\n      return 3;\n    case MetadataType.VEC4:\n      return 4;\n    case MetadataType.MAT2:\n      return 4;\n    case MetadataType.MAT3:\n      return 9;\n    case MetadataType.MAT4:\n      return 16;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(`Invalid metadata type ${type}`);\n    //>>includeEnd('debug');\n  }\n};\n\n/**\n * Get the corresponding vector or matrix class. This is used to simplify\n * packing and unpacking code.\n * @param {MetadataType} type The metadata type\n * @return {Object} The appropriate CartesianN class for vector types, MatrixN class for matrix types, or undefined otherwise.\n * @private\n */\nMetadataType.getMathType = function (type) {\n  switch (type) {\n    case MetadataType.VEC2:\n      return Cartesian2;\n    case MetadataType.VEC3:\n      return Cartesian3;\n    case MetadataType.VEC4:\n      return Cartesian4;\n    case MetadataType.MAT2:\n      return Matrix2;\n    case MetadataType.MAT3:\n      return Matrix3;\n    case MetadataType.MAT4:\n      return Matrix4;\n    default:\n      return undefined;\n  }\n};\n\nexport default Object.freeze(MetadataType);\n","import defaultValue from \"../Core/defaultValue.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport ModelAnimationLoop from \"./ModelAnimationLoop.js\";\nimport ModelAnimationState from \"./ModelAnimationState.js\";\n\n/**\n * An active glTF animation.  A glTF asset can contain animations.  An active animation\n * is an animation that is currently playing or scheduled to be played because it was\n * added to a model's {@link ModelAnimationCollection}.  An active animation is an\n * instance of an animation; for example, there can be multiple active animations\n * for the same glTF animation, each with a different start time.\n * <p>\n * Create this by calling {@link ModelAnimationCollection#add}.\n * </p>\n *\n * @alias ModelAnimation\n * @internalConstructor\n * @class\n *\n * @see ModelAnimationCollection#add\n */\nfunction ModelAnimation(options, model, runtimeAnimation) {\n  this._name = runtimeAnimation.name;\n  this._startTime = JulianDate.clone(options.startTime);\n  this._delay = defaultValue(options.delay, 0.0); // in seconds\n  this._stopTime = options.stopTime;\n\n  /**\n   * When <code>true</code>, the animation is removed after it stops playing.\n   * This is slightly more efficient that not removing it, but if, for example,\n   * time is reversed, the animation is not played again.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.removeOnStop = defaultValue(options.removeOnStop, false);\n  this._multiplier = defaultValue(options.multiplier, 1.0);\n  this._reverse = defaultValue(options.reverse, false);\n  this._loop = defaultValue(options.loop, ModelAnimationLoop.NONE);\n  this._animationTime = options.animationTime;\n  this._prevAnimationDelta = undefined;\n\n  /**\n   * The event fired when this animation is started.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation starts.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.start.addEventListener(function(model, animation) {\n   *   console.log('Animation started: ' + animation.name);\n   * });\n   */\n  this.start = new Event();\n\n  /**\n   * The event fired when on each frame when this animation is updated.  The\n   * current time of the animation, relative to the glTF animation time span, is\n   * passed to the event, which allows, for example, starting new animations at a\n   * specific time relative to a playing animation.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.update.addEventListener(function(model, animation, time) {\n   *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);\n   * });\n   */\n  this.update = new Event();\n\n  /**\n   * The event fired when this animation is stopped.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation stops.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.stop.addEventListener(function(model, animation) {\n   *   console.log('Animation stopped: ' + animation.name);\n   * });\n   */\n  this.stop = new Event();\n\n  this._state = ModelAnimationState.STOPPED;\n  this._runtimeAnimation = runtimeAnimation;\n\n  // Set during animation update\n  this._computedStartTime = undefined;\n  this._duration = undefined;\n\n  // To avoid allocations in ModelAnimationCollection.update\n  const that = this;\n  this._raiseStartEvent = function () {\n    that.start.raiseEvent(model, that);\n  };\n  this._updateEventTime = 0.0;\n  this._raiseUpdateEvent = function () {\n    that.update.raiseEvent(model, that, that._updateEventTime);\n  };\n  this._raiseStopEvent = function () {\n    that.stop.raiseEvent(model, that);\n  };\n}\n\nObject.defineProperties(ModelAnimation.prototype, {\n  /**\n   * The glTF animation name that identifies this animation.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The scene time to start playing this animation.  When this is <code>undefined</code>,\n   * the animation starts at the next frame.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  startTime: {\n    get: function () {\n      return this._startTime;\n    },\n  },\n\n  /**\n   * The delay, in seconds, from {@link ModelAnimation#startTime} to start playing.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @default undefined\n   */\n  delay: {\n    get: function () {\n      return this._delay;\n    },\n  },\n\n  /**\n   * The scene time to stop playing this animation.  When this is <code>undefined</code>,\n   * the animation is played for its full duration and perhaps repeated depending on\n   * {@link ModelAnimation#loop}.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  stopTime: {\n    get: function () {\n      return this._stopTime;\n    },\n  },\n  /**\n   * Values greater than <code>1.0</code> increase the speed that the animation is played relative\n   * to the scene clock speed; values less than <code>1.0</code> decrease the speed.  A value of\n   * <code>1.0</code> plays the animation at the speed in the glTF animation mapped to the scene\n   * clock speed.  For example, if the scene is played at 2x real-time, a two-second glTF animation\n   * will play in one second even if <code>multiplier</code> is <code>1.0</code>.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @default 1.0\n   */\n  multiplier: {\n    get: function () {\n      return this._multiplier;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the animation is played in reverse.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  reverse: {\n    get: function () {\n      return this._reverse;\n    },\n  },\n\n  /**\n   * Determines if and how the animation is looped.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimationLoop}\n   * @readonly\n   *\n   * @default {@link ModelAnimationLoop.NONE}\n   */\n  loop: {\n    get: function () {\n      return this._loop;\n    },\n  },\n\n  /**\n   * If this is defined, it will be used to compute the local animation time\n   * instead of the scene's time.\n   *\n   * @memberof ModelAnimation.prototype\n   *\n   * @type {ModelAnimation.AnimationTimeCallback}\n   * @default undefined\n   */\n  animationTime: {\n    get: function () {\n      return this._animationTime;\n    },\n  },\n});\n/**\n * A function used to compute the local animation time for a ModelAnimation.\n * @callback ModelAnimation.AnimationTimeCallback\n *\n * @param {Number} duration The animation's original duration in seconds.\n * @param {Number} seconds The seconds since the animation started, in scene time.\n * @returns {Number} Returns the local animation time.\n *\n * @example\n * // Use real time for model animation (assuming animateWhilePaused was set to true)\n * function animationTime(duration) {\n *     return Date.now() / 1000 / duration;\n * }\n *\n * @example\n * // Offset the phase of the animation, so it starts halfway through its cycle.\n * function animationTime(duration, seconds) {\n *     return seconds / duration + 0.5;\n * }\n */\nexport default ModelAnimation;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport ConstantSpline from \"../Core/ConstantSpline.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport LinearSpline from \"../Core/LinearSpline.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport MorphWeightSpline from \"../Core/MorphWeightSpline.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport QuaternionSpline from \"../Core/QuaternionSpline.js\";\nimport Spline from \"../Core/Spline.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport getAccessorByteStride from \"./GltfPipeline/getAccessorByteStride.js\";\nimport numberOfComponentsForType from \"./GltfPipeline/numberOfComponentsForType.js\";\nimport AttributeType from \"./AttributeType.js\";\n\n/**\n * @private\n */\nfunction ModelAnimationCache() {}\n\nconst dataUriRegex = /^data\\:/i;\n\nfunction getAccessorKey(model, accessor) {\n  const gltf = model.gltfInternal;\n  const buffers = gltf.buffers;\n  const bufferViews = gltf.bufferViews;\n\n  const bufferView = bufferViews[accessor.bufferView];\n  const buffer = buffers[bufferView.buffer];\n\n  const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  const byteLength = accessor.count * numberOfComponentsForType(accessor.type);\n\n  const uriKey = dataUriRegex.test(buffer.uri) ? \"\" : buffer.uri;\n  return `${model.cacheKey}//${uriKey}/${byteOffset}/${byteLength}`;\n}\n\nconst cachedAnimationParameters = {};\n\nModelAnimationCache.getAnimationParameterValues = function (model, accessor) {\n  const key = getAccessorKey(model, accessor);\n  let values = cachedAnimationParameters[key];\n\n  if (!defined(values)) {\n    // Cache miss\n    const gltf = model.gltfInternal;\n\n    const buffers = gltf.buffers;\n    const bufferViews = gltf.bufferViews;\n\n    const bufferView = bufferViews[accessor.bufferView];\n    const bufferId = bufferView.buffer;\n    const buffer = buffers[bufferId];\n    const source = buffer.extras._pipeline.source;\n\n    const componentType = accessor.componentType;\n    const type = accessor.type;\n    const numberOfComponents = numberOfComponentsForType(type);\n    const count = accessor.count;\n    const byteStride = getAccessorByteStride(gltf, accessor);\n\n    values = new Array(count);\n    const accessorByteOffset = defaultValue(accessor.byteOffset, 0);\n    let byteOffset = bufferView.byteOffset + accessorByteOffset;\n    for (let i = 0; i < count; i++) {\n      const typedArrayView = ComponentDatatype.createArrayBufferView(\n        componentType,\n        source.buffer,\n        source.byteOffset + byteOffset,\n        numberOfComponents\n      );\n      if (type === \"SCALAR\") {\n        values[i] = typedArrayView[0];\n      } else if (type === \"VEC3\") {\n        values[i] = Cartesian3.fromArray(typedArrayView);\n      } else if (type === \"VEC4\") {\n        values[i] = Quaternion.unpack(typedArrayView);\n      }\n      byteOffset += byteStride;\n    }\n    // GLTF_SPEC: Support more parameter types when glTF supports targeting materials. https://github.com/KhronosGroup/glTF/issues/142\n\n    if (defined(model.cacheKey)) {\n      // Only cache when we can create a unique id\n      cachedAnimationParameters[key] = values;\n    }\n  }\n\n  return values;\n};\n\nconst cachedAnimationSplines = {};\n\nfunction getAnimationSplineKey(model, animationName, samplerName) {\n  return `${model.cacheKey}//${animationName}/${samplerName}`;\n}\n\nfunction SteppedSpline(backingSpline) {\n  this._spline = backingSpline;\n  this._lastTimeIndex = 0;\n}\nSteppedSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;\nSteppedSpline.prototype.evaluate = function (time, result) {\n  const i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex\n  ));\n  const times = this._spline.times;\n  const steppedTime = time >= times[i + 1] ? times[i + 1] : times[i];\n  return this._spline.evaluate(steppedTime, result);\n};\nObject.defineProperties(SteppedSpline.prototype, {\n  times: {\n    get: function () {\n      return this._spline.times;\n    },\n  },\n});\nSteppedSpline.prototype.wrapTime = function (time) {\n  return this._spline.wrapTime(time);\n};\nSteppedSpline.prototype.clampTime = function (time) {\n  return this._spline.clampTime(time);\n};\n\nModelAnimationCache.getAnimationSpline = function (\n  model,\n  animationName,\n  animation,\n  samplerName,\n  sampler,\n  input,\n  path,\n  output\n) {\n  const key = getAnimationSplineKey(model, animationName, samplerName);\n  let spline = cachedAnimationSplines[key];\n\n  if (!defined(spline)) {\n    const times = input;\n    const controlPoints = output;\n\n    if (times.length === 1 && controlPoints.length === 1) {\n      spline = new ConstantSpline(controlPoints[0]);\n    } else if (\n      sampler.interpolation === \"LINEAR\" ||\n      sampler.interpolation === \"STEP\"\n    ) {\n      if (path === \"translation\" || path === \"scale\") {\n        spline = new LinearSpline({\n          times: times,\n          points: controlPoints,\n        });\n      } else if (path === \"rotation\") {\n        spline = new QuaternionSpline({\n          times: times,\n          points: controlPoints,\n        });\n      } else if (path === \"weights\") {\n        spline = new MorphWeightSpline({\n          times: times,\n          weights: controlPoints,\n        });\n      }\n\n      if (defined(spline) && sampler.interpolation === \"STEP\") {\n        spline = new SteppedSpline(spline);\n      }\n    }\n\n    if (defined(model.cacheKey)) {\n      // Only cache when we can create a unique id\n      cachedAnimationSplines[key] = spline;\n    }\n  }\n\n  return spline;\n};\n\nconst cachedSkinInverseBindMatrices = {};\n\nModelAnimationCache.getSkinInverseBindMatrices = function (model, accessor) {\n  const key = getAccessorKey(model, accessor);\n  let matrices = cachedSkinInverseBindMatrices[key];\n\n  if (!defined(matrices)) {\n    // Cache miss\n    const gltf = model.gltfInternal;\n    const buffers = gltf.buffers;\n    const bufferViews = gltf.bufferViews;\n\n    const bufferViewId = accessor.bufferView;\n    const bufferView = bufferViews[bufferViewId];\n    const bufferId = bufferView.buffer;\n    const buffer = buffers[bufferId];\n    const source = buffer.extras._pipeline.source;\n\n    const componentType = accessor.componentType;\n    const type = accessor.type;\n    const count = accessor.count;\n    const byteStride = getAccessorByteStride(gltf, accessor);\n    let byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    const numberOfComponents = numberOfComponentsForType(type);\n\n    matrices = new Array(count);\n\n    if (componentType === WebGLConstants.FLOAT && type === AttributeType.MAT4) {\n      for (let i = 0; i < count; ++i) {\n        const typedArrayView = ComponentDatatype.createArrayBufferView(\n          componentType,\n          source.buffer,\n          source.byteOffset + byteOffset,\n          numberOfComponents\n        );\n        matrices[i] = Matrix4.fromArray(typedArrayView);\n        byteOffset += byteStride;\n      }\n    }\n\n    cachedSkinInverseBindMatrices[key] = matrices;\n  }\n\n  return matrices;\n};\nexport default ModelAnimationCache;\n","import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport ModelAnimation from \"./ModelAnimation.js\";\nimport ModelAnimationLoop from \"./ModelAnimationLoop.js\";\nimport ModelAnimationState from \"./ModelAnimationState.js\";\n\n/**\n * A collection of active model animations.  Access this using {@link Model#activeAnimations}.\n *\n * @alias ModelAnimationCollection\n * @internalConstructor\n * @class\n *\n * @see Model#activeAnimations\n */\nfunction ModelAnimationCollection(model) {\n  /**\n   * The event fired when an animation is added to the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n   *   console.log('Animation added: ' + animation.name);\n   * });\n   */\n  this.animationAdded = new Event();\n\n  /**\n   * The event fired when an animation is removed from the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n   *   console.log('Animation removed: ' + animation.name);\n   * });\n   */\n  this.animationRemoved = new Event();\n\n  /**\n   * When true, the animation will play even when the scene time is paused. However,\n   * whether animation takes place will depend on the animationTime functions assigned\n   * to the model's animations. By default, this is based on scene time, so models using\n   * the default will not animate regardless of this setting.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.animateWhilePaused = false;\n\n  this._model = model;\n  this._scheduledAnimations = [];\n  this._previousTime = undefined;\n}\n\nObject.defineProperties(ModelAnimationCollection.prototype, {\n  /**\n   * The number of animations in the collection.\n   *\n   * @memberof ModelAnimationCollection.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._scheduledAnimations.length;\n    },\n  },\n});\n\nfunction add(collection, index, options) {\n  const model = collection._model;\n  const animations = model._runtime.animations;\n  const animation = animations[index];\n  const scheduledAnimation = new ModelAnimation(options, model, animation);\n  collection._scheduledAnimations.push(scheduledAnimation);\n  collection.animationAdded.raiseEvent(model, scheduledAnimation);\n  return scheduledAnimation;\n}\n\n/**\n * Creates and adds an animation with the specified initial properties to the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} [options.name] The glTF animation name that identifies the animation. Must be defined if <code>options.index</code> is <code>undefined</code>.\n * @param {Number} [options.index] The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.\n * @param {JulianDate} [options.startTime] The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.\n * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.\n * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animation is removed after it stops playing.\n * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {Boolean} [options.reverse=false] When <code>true</code>, the animation is played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animation is looped.\n * @param {ModelAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for this animation.\n * @returns {ModelAnimation} The animation that was added to the collection.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.\n * @exception {DeveloperError} options.name must be a valid animation name.\n * @exception {DeveloperError} options.index must be a valid animation index.\n * @exception {DeveloperError} Either options.name or options.index must be defined.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * // Example 1. Add an animation by name\n * model.activeAnimations.add({\n *   name : 'animation name'\n * });\n *\n * // Example 2. Add an animation by index\n * model.activeAnimations.add({\n *   index : 0\n * });\n *\n * @example\n * // Example 3. Add an animation and provide all properties and events\n * const startTime = Cesium.JulianDate.now();\n *\n * const animation = model.activeAnimations.add({\n *   name : 'another animation name',\n *   startTime : startTime,\n *   delay : 0.0,                          // Play at startTime (default)\n *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),\n *   removeOnStop : false,                 // Do not remove when animation stops (default)\n *   multiplier : 2.0,                        // Play at double speed\n *   reverse : true,                       // Play in reverse\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation\n * });\n *\n * animation.start.addEventListener(function(model, animation) {\n *   console.log('Animation started: ' + animation.name);\n * });\n * animation.update.addEventListener(function(model, animation, time) {\n *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);\n * });\n * animation.stop.addEventListener(function(model, animation) {\n *   console.log('Animation stopped: ' + animation.name);\n * });\n */\nModelAnimationCollection.prototype.add = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const model = this._model;\n  const animations = model._runtime.animations;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(animations)) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for Model.readyPromise to resolve.\"\n    );\n  }\n  if (!defined(options.name) && !defined(options.index)) {\n    throw new DeveloperError(\n      \"Either options.name or options.index must be defined.\"\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n  if (\n    defined(options.index) &&\n    (options.index >= animations.length || options.index < 0)\n  ) {\n    throw new DeveloperError(\"options.index must be a valid animation index.\");\n  }\n  //>>includeEnd('debug');\n\n  if (defined(options.index)) {\n    return add(this, options.index, options);\n  }\n\n  // Find the index of the animation with the given name\n  let index;\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    if (animations[i].name === options.name) {\n      index = i;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"options.name must be a valid animation name.\");\n  }\n  //>>includeEnd('debug');\n\n  return add(this, index, options);\n};\n\n/**\n * Creates and adds an animation with the specified initial properties to the collection\n * for each animation in the model.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {Object} [options] Object with the following properties:\n * @param {JulianDate} [options.startTime] The scene time to start playing the animations.  When this is <code>undefined</code>, the animations starts at the next frame.\n * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animations.  When this is <code>undefined</code>, the animations are played for its full duration.\n * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animations are removed after they stop playing.\n * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {Boolean} [options.reverse=false] When <code>true</code>, the animations are played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animations are looped.\n * @param {ModelAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for all of the animations.\n * @returns {ModelAnimation[]} An array of {@link ModelAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * model.activeAnimations.addAll({\n *   multiplier : 0.5,                        // Play at half-speed\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n * });\n */\nModelAnimationCollection.prototype.addAll = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(this._model._runtime.animations)) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for Model.readyPromise to resolve.\"\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const scheduledAnimations = [];\n  const model = this._model;\n  const animations = model._runtime.animations;\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    scheduledAnimations.push(add(this, i, options));\n  }\n  return scheduledAnimations;\n};\n\n/**\n * Removes an animation from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.\n * </p>\n * <p>\n * An animation can also be implicitly removed from the collection by setting {@link ModelAnimation#removeOnStop} to\n * <code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.\n * </p>\n *\n * @param {ModelAnimation} animation The animation to remove.\n * @returns {Boolean} <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.\n *\n * @example\n * const a = model.activeAnimations.add({\n *   name : 'animation name'\n * });\n * model.activeAnimations.remove(a); // Returns true\n */\nModelAnimationCollection.prototype.remove = function (animation) {\n  if (defined(animation)) {\n    const animations = this._scheduledAnimations;\n    const i = animations.indexOf(animation);\n    if (i !== -1) {\n      animations.splice(i, 1);\n      this.animationRemoved.raiseEvent(this._model, animation);\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Removes all animations from the collection.\n * <p>\n * This raises the {@link ModelAnimationCollection#animationRemoved} event for each\n * animation so, for example, a UI can stay in sync.\n * </p>\n */\nModelAnimationCollection.prototype.removeAll = function () {\n  const model = this._model;\n  const animations = this._scheduledAnimations;\n  const length = animations.length;\n\n  this._scheduledAnimations = [];\n\n  for (let i = 0; i < length; ++i) {\n    this.animationRemoved.raiseEvent(model, animations[i]);\n  }\n};\n\n/**\n * Determines whether this collection contains a given animation.\n *\n * @param {ModelAnimation} animation The animation to check for.\n * @returns {Boolean} <code>true</code> if this collection contains the animation, <code>false</code> otherwise.\n */\nModelAnimationCollection.prototype.contains = function (animation) {\n  if (defined(animation)) {\n    return this._scheduledAnimations.indexOf(animation) !== -1;\n  }\n\n  return false;\n};\n\n/**\n * Returns the animation in the collection at the specified index.  Indices are zero-based\n * and increase as animations are added.  Removing an animation shifts all animations after\n * it to the left, changing their indices.  This function is commonly used to iterate over\n * all the animations in the collection.\n *\n * @param {Number} index The zero-based index of the animation.\n * @returns {ModelAnimation} The animation at the specified index.\n *\n * @example\n * // Output the names of all the animations in the collection.\n * const animations = model.activeAnimations;\n * const length = animations.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(animations.get(i).name);\n * }\n */\nModelAnimationCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return this._scheduledAnimations[index];\n};\n\nfunction animateChannels(runtimeAnimation, localAnimationTime) {\n  const channelEvaluators = runtimeAnimation.channelEvaluators;\n  const length = channelEvaluators.length;\n  for (let i = 0; i < length; ++i) {\n    channelEvaluators[i](localAnimationTime);\n  }\n}\n\nconst animationsToRemove = [];\n\nfunction createAnimationRemovedFunction(\n  modelAnimationCollection,\n  model,\n  animation\n) {\n  return function () {\n    modelAnimationCollection.animationRemoved.raiseEvent(model, animation);\n  };\n}\n\n/**\n * @private\n */\nModelAnimationCollection.prototype.update = function (frameState) {\n  const scheduledAnimations = this._scheduledAnimations;\n  let length = scheduledAnimations.length;\n\n  if (length === 0) {\n    // No animations - quick return for performance\n    this._previousTime = undefined;\n    return false;\n  }\n\n  if (\n    !this.animateWhilePaused &&\n    JulianDate.equals(frameState.time, this._previousTime)\n  ) {\n    return false;\n  }\n  this._previousTime = JulianDate.clone(frameState.time, this._previousTime);\n\n  let animationOccured = false;\n  const sceneTime = frameState.time;\n  const model = this._model;\n\n  for (let i = 0; i < length; ++i) {\n    const scheduledAnimation = scheduledAnimations[i];\n    const runtimeAnimation = scheduledAnimation._runtimeAnimation;\n\n    if (!defined(scheduledAnimation._computedStartTime)) {\n      scheduledAnimation._computedStartTime = JulianDate.addSeconds(\n        defaultValue(scheduledAnimation.startTime, sceneTime),\n        scheduledAnimation.delay,\n        new JulianDate()\n      );\n    }\n\n    if (!defined(scheduledAnimation._duration)) {\n      scheduledAnimation._duration =\n        runtimeAnimation.stopTime * (1.0 / scheduledAnimation.multiplier);\n    }\n\n    const startTime = scheduledAnimation._computedStartTime;\n    const duration = scheduledAnimation._duration;\n    const stopTime = scheduledAnimation.stopTime;\n\n    const pastStartTime = JulianDate.lessThanOrEquals(startTime, sceneTime);\n    const pastStopTime =\n      defined(stopTime) && JulianDate.greaterThan(sceneTime, stopTime);\n\n    // [0.0, 1.0] normalized local animation time\n    let delta = 0.0;\n    if (duration !== 0.0) {\n      const seconds = JulianDate.secondsDifference(\n        pastStopTime ? stopTime : sceneTime,\n        startTime\n      );\n      delta = defined(scheduledAnimation._animationTime)\n        ? scheduledAnimation._animationTime(duration, seconds)\n        : seconds / duration;\n    }\n\n    // Play animation if\n    // * we are after the start time or the animation is being repeated, and\n    // * before the end of the animation's duration or the animation is being repeated, and\n    // * we did not reach a user-provided stop time.\n\n    const repeat =\n      scheduledAnimation.loop === ModelAnimationLoop.REPEAT ||\n      scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT;\n\n    const play =\n      (pastStartTime || (repeat && !defined(scheduledAnimation.startTime))) &&\n      (delta <= 1.0 || repeat) &&\n      !pastStopTime;\n\n    if (delta === scheduledAnimation._prevAnimationDelta) {\n      const animationStopped =\n        scheduledAnimation._state === ModelAnimationState.STOPPED;\n      // no change to delta, and no change to the animation state means we can\n      // skip the update this time around.\n      if (play !== animationStopped) {\n        continue;\n      }\n    }\n    scheduledAnimation._prevAnimationDelta = delta;\n\n    // If it IS, or WAS, animating...\n    if (play || scheduledAnimation._state === ModelAnimationState.ANIMATING) {\n      // STOPPED -> ANIMATING state transition?\n      if (play && scheduledAnimation._state === ModelAnimationState.STOPPED) {\n        scheduledAnimation._state = ModelAnimationState.ANIMATING;\n        if (scheduledAnimation.start.numberOfListeners > 0) {\n          frameState.afterRender.push(scheduledAnimation._raiseStartEvent);\n        }\n      }\n\n      // Truncate to [0.0, 1.0] for repeating animations\n      if (scheduledAnimation.loop === ModelAnimationLoop.REPEAT) {\n        delta = delta - Math.floor(delta);\n      } else if (\n        scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT\n      ) {\n        const floor = Math.floor(delta);\n        const fract = delta - floor;\n        // When odd use (1.0 - fract) to mirror repeat\n        delta = floor % 2 === 1.0 ? 1.0 - fract : fract;\n      }\n\n      if (scheduledAnimation.reverse) {\n        delta = 1.0 - delta;\n      }\n\n      let localAnimationTime = delta * duration * scheduledAnimation.multiplier;\n      // Clamp in case floating-point roundoff goes outside the animation's first or last keyframe\n      localAnimationTime = CesiumMath.clamp(\n        localAnimationTime,\n        runtimeAnimation.startTime,\n        runtimeAnimation.stopTime\n      );\n\n      animateChannels(runtimeAnimation, localAnimationTime);\n\n      if (scheduledAnimation.update.numberOfListeners > 0) {\n        scheduledAnimation._updateEventTime = localAnimationTime;\n        frameState.afterRender.push(scheduledAnimation._raiseUpdateEvent);\n      }\n      animationOccured = true;\n\n      if (!play) {\n        // ANIMATING -> STOPPED state transition?\n        scheduledAnimation._state = ModelAnimationState.STOPPED;\n        if (scheduledAnimation.stop.numberOfListeners > 0) {\n          frameState.afterRender.push(scheduledAnimation._raiseStopEvent);\n        }\n\n        if (scheduledAnimation.removeOnStop) {\n          animationsToRemove.push(scheduledAnimation);\n        }\n      }\n    }\n  }\n\n  // Remove animations that stopped\n  length = animationsToRemove.length;\n  for (let j = 0; j < length; ++j) {\n    const animationToRemove = animationsToRemove[j];\n    scheduledAnimations.splice(\n      scheduledAnimations.indexOf(animationToRemove),\n      1\n    );\n    frameState.afterRender.push(\n      createAnimationRemovedFunction(this, model, animationToRemove)\n    );\n  }\n  animationsToRemove.length = 0;\n\n  return animationOccured;\n};\nexport default ModelAnimationCollection;\n","/**\n * Determines if and how a glTF animation is looped.\n *\n * @enum {Number}\n *\n * @see ModelAnimationCollection#add\n */\nconst ModelAnimationLoop = {\n  /**\n   * Play the animation once; do not loop it.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * Loop the animation playing it from the start immediately after it stops.\n   *\n   * @type {Number}\n   * @constant\n   */\n  REPEAT: 1,\n\n  /**\n   * Loop the animation.  First, playing it forward, then in reverse, then forward, and so on.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MIRRORED_REPEAT: 2,\n};\nexport default Object.freeze(ModelAnimationLoop);\n","/**\n * @private\n */\nexport default Object.freeze({\n  STOPPED: 0,\n  ANIMATING: 1,\n});\n","import AlphaMode from \"./AlphaMode.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\n\n/**\n * Components for building models.\n *\n * @namespace ModelComponents\n *\n * @private\n */\nconst ModelComponents = {};\n\n/**\n * Information about the quantized attribute.\n *\n * @alias ModelComponents.Quantization\n * @constructor\n *\n * @private\n */\nfunction Quantization() {\n  /**\n   * Whether the quantized attribute is oct-encoded.\n   *\n   * @type {Boolean}\n   * @private\n   */\n  this.octEncoded = false;\n\n  /**\n   * Whether the oct-encoded values are stored as ZXY instead of XYZ. This is true when decoding from Draco.\n   *\n   * @type {Boolean}\n   */\n  this.octEncodedZXY = false;\n\n  /**\n   * The range used to convert buffer values to normalized values [0.0, 1.0]\n   * This is typically computed as (1 << quantizationBits) - 1.\n   * For oct-encoded values this value is a single Number.\n   *\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @private\n   */\n  this.normalizationRange = undefined;\n\n  /**\n   * The bottom-left corner of the quantization volume. Not applicable for oct encoded attributes.\n   * The type should match the attribute type - e.g. if the attribute type\n   * is AttributeType.VEC4 the offset should be a Cartesian4.\n   *\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @private\n   */\n  this.quantizedVolumeOffset = undefined;\n\n  /**\n   * The dimensions of the quantization volume. Not applicable for oct encoded attributes.\n   * The type should match the attribute type - e.g. if the attribute type\n   * is AttributeType.VEC4 the dimensions should be a Cartesian4.\n   *\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @private\n   */\n  this.quantizedVolumeDimensions = undefined;\n\n  /**\n   * The step size of the quantization volume, equal to\n   * quantizedVolumeDimensions / normalizationRange (component-wise).\n   * Not applicable for oct encoded attributes.\n   * The type should match the attribute type - e.g. if the attribute type\n   * is AttributeType.VEC4 the dimensions should be a Cartesian4.\n   *\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @private\n   */\n  this.quantizedVolumeStepSize = undefined;\n\n  /**\n   * The component data type of the quantized attribute, e.g. ComponentDatatype.UNSIGNED_SHORT.\n   *\n   * <p>\n   * The following component datatypes are not supported:\n   * <ul>\n   *   <li>ComponentDatatype.INT</li>\n   *   <li>ComponentDatatype.UNSIGNED_INT</li>\n   *   <li>ComponentDatatype.DOUBLE</li>\n   * </ul>\n   * </p>\n   *\n   * @type {ComponentDatatype}\n   * @private\n   */\n  this.componentDatatype = undefined;\n\n  /**\n   * The type of the quantized attribute, e.g. AttributeType.VEC2 for oct-encoded normals.\n   *\n   * @type {AttributeType}\n   * @private\n   */\n  this.type = undefined;\n}\n\n/**\n * A per-vertex or per-instance attribute.\n *\n * @alias ModelComponents.Attribute\n * @constructor\n *\n * @private\n */\nfunction Attribute() {\n  /**\n   * The attribute name. Must be unique within the attributes array.\n   *\n   * @type {String}\n   * @private\n   */\n  this.name = undefined;\n\n  /**\n   * The attribute semantic. The combination of semantic and setIndex must be\n   * unique within the attributes array.\n   *\n   * @type {VertexAttributeSemantic|InstanceAttributeSemantic}\n   * @private\n   */\n  this.semantic = undefined;\n\n  /**\n   * The set index of the attribute. Only applicable when the attribute has one\n   * of the following semantics:\n   *\n   * <ul>\n   *   <li>{@link VertexAttributeSemantic.TEXCOORD}</li>\n   *   <li>{@link VertexAttributeSemantic.COLOR}</li>\n   *   <li>{@link VertexAttributeSemantic.JOINTS}</li>\n   *   <li>{@link VertexAttributeSemantic.WEIGHTS}</li>\n   *   <li>{@link VertexAttributeSemantic.FEATURE_ID}</li>\n   *   <li>{@link InstanceAttributeSemantic.FEATURE_ID}</li>\n   * </ul>\n   */\n  this.setIndex = undefined;\n\n  /**\n   * The component data type of the attribute.\n   * <p>\n   * When the data is quantized the componentDatatype should match the\n   * dequantized data, which is typically ComponentDatatype.FLOAT.\n   * </p>\n   * <p>\n   * The following component datatypes are not supported:\n   * <ul>\n   *   <li>ComponentDatatype.INT</li>\n   *   <li>ComponentDatatype.UNSIGNED_INT</li>\n   *   <li>ComponentDatatype.DOUBLE</li>\n   * </ul>\n   * </p>\n   *\n   * @type {ComponentDatatype}\n   * @private\n   */\n  this.componentDatatype = undefined;\n\n  /**\n   * The type of the attribute.\n   * <p>\n   * When the data is oct-encoded the type should match the decoded data, which\n   * is typically AttributeType.VEC3.\n   * </p>\n   *\n   * @type {AttributeType}\n   * @private\n   */\n  this.type = undefined;\n\n  /**\n   * Whether the attribute is normalized.\n   *\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  this.normalized = false;\n\n  /**\n   * The number of elements.\n   *\n   * @type {Number}\n   * @private\n   */\n  this.count = undefined;\n\n  /**\n   * Minimum value of each component in the attribute.\n   * <p>\n   * When the data is quantized the min should match the dequantized data.\n   * The normalized property has no effect on these values.\n   * </p>\n   * <p>\n   * Must be defined for POSITION attributes.\n   * </p>\n   *\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @private\n   */\n  this.min = undefined;\n\n  /**\n   * Maximum value of each component in the attribute.\n   * <p>\n   * When the data is quantized the max should match the dequantized data.\n   * The normalized property has no effect on these values.\n   * </p>\n   * <p>\n   * Must be defined for POSITION attributes.\n   * </p>\n   *\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @private\n   */\n  this.max = undefined;\n\n  /**\n   * A constant value used for all elements when typed array and buffer are undefined.\n   *\n   * @type {Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4}\n   * @private\n   */\n  this.constant = undefined;\n\n  /**\n   * Information about the quantized attribute.\n   *\n   * @type {ModelComponents.Quantization}\n   * @private\n   */\n  this.quantization = undefined;\n\n  /**\n   * A typed array containing tightly-packed attribute values.\n   *\n   * @type {Uint8Array|Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array}\n   * @private\n   */\n  this.packedTypedArray = undefined;\n\n  /**\n   * A vertex buffer. Attribute values are accessed using byteOffset and byteStride.\n   *\n   * @type {Buffer}\n   * @private\n   */\n  this.buffer = undefined;\n\n  /**\n   * A typed array containing vertex buffer data. Attribute values are accessed using byteOffset and byteStride.\n   *\n   * @type {Uint8Array}\n   * @private\n   */\n  this.typedArray = undefined;\n\n  /**\n   * The byte offset of elements in the buffer.\n   *\n   * @type {Number}\n   * @default 0\n   * @private\n   */\n  this.byteOffset = 0;\n\n  /**\n   * The byte stride of elements in the buffer. When undefined the elements are tightly packed.\n   *\n   * @type {Number}\n   * @private\n   */\n  this.byteStride = undefined;\n}\n\n/**\n * Indices used to select vertices for rendering.\n *\n * @alias ModelComponents.Indices\n * @constructor\n *\n * @private\n */\nfunction Indices() {\n  /**\n   * The index data type of the attribute, e.g. IndexDatatype.UNSIGNED_SHORT.\n   *\n   * @type {IndexDatatype}\n   * @private\n   */\n  this.indexDatatype = undefined;\n\n  /**\n   * The number of indices.\n   *\n   * @type {Number}\n   * @private\n   */\n  this.count = undefined;\n\n  /**\n   * An index buffer containing indices.\n   *\n   * @type {Buffer}\n   * @private\n   */\n  this.buffer = undefined;\n\n  /**\n   * A typed array containing indices.\n   *\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   * @private\n   */\n  this.typedArray = undefined;\n}\n\n/**\n * Maps per-vertex or per-instance feature IDs to a property table. Feature\n * IDs are stored in an accessor.\n *\n * @alias ModelComponents.FeatureIdAttribute\n * @constructor\n *\n * @private\n */\nfunction FeatureIdAttribute() {\n  /**\n   * How many unique features are defined in this set of feature IDs\n   *\n   * @type {Number}\n   * @private\n   */\n  this.featureCount = undefined;\n\n  /**\n   * This value indicates that no feature is indicated with this vertex\n   *\n   * @type {Number}\n   * @private\n   */\n  this.nullFeatureId = undefined;\n\n  /**\n   * The ID of the property table that feature IDs index into. If undefined,\n   * feature IDs are used for classification, but no metadata is associated.\n   *\n   *\n   * @type {Number}\n   * @private\n   */\n  this.propertyTableId = undefined;\n\n  /**\n   * The set index of feature ID attribute containing feature IDs.\n   *\n   * @type {Number}\n   * @private\n   */\n  this.setIndex = undefined;\n\n  /**\n   * The label to identify this set of feature IDs. This is used in picking,\n   * styling and shaders.\n   *\n   * @type {String}\n   * @private\n   */\n  this.label = undefined;\n\n  /**\n   * Label to identify this set of feature IDs by its position in the array.\n   * This will always be either \"featureId_N\" for primitives or\n   * \"instanceFeatureId_N\" for instances.\n   *\n   * @type {String}\n   * @private\n   */\n  this.positionalLabel = undefined;\n}\n\n/**\n * Defines a range of implicitly-defined feature IDs, one for each vertex or\n * instance. Such feature IDs may optionally be associated with a property table\n * storing metadata\n *\n * @alias ModelComponents.FeatureIdImplicitRange\n * @constructor\n *\n * @private\n */\nfunction FeatureIdImplicitRange() {\n  /**\n   * How many unique features are defined in this set of feature IDs\n   *\n   * @type {Number}\n   * @private\n   */\n  this.featureCount = undefined;\n\n  /**\n   * This value indicates that no feature is indicated with this vertex\n   *\n   * @type {Number}\n   * @private\n   */\n  this.nullFeatureId = undefined;\n\n  /**\n   * The ID of the property table that feature IDs index into. If undefined,\n   * feature IDs are used for classification, but no metadata is associated.\n   *\n   * @type {Number}\n   * @private\n   */\n  this.propertyTableId = undefined;\n\n  /**\n   * The first feature ID to use when setIndex is undefined\n   *\n   * @type {Number}\n   * @default 0\n   * @private\n   */\n  this.offset = 0;\n\n  /**\n   * Number of times each feature ID is repeated before being incremented.\n   *\n   * @type {Number}\n   * @private\n   */\n  this.repeat = undefined;\n\n  /**\n   * The label to identify this set of feature IDs. This is used in picking,\n   * styling and shaders.\n   *\n   * @type {String}\n   * @private\n   */\n  this.label = undefined;\n\n  /**\n   * Label to identify this set of feature IDs by its position in the array.\n   * This will always be either \"featureId_N\" for primitives or\n   * \"instanceFeatureId_N\" for instances.\n   *\n   * @type {String}\n   * @private\n   */\n  this.positionalLabel = undefined;\n}\n\n/**\n * A texture that contains per-texel feature IDs that index into a property table.\n *\n * @alias ModelComponents.FeatureIdTexture\n * @constructor\n *\n * @private\n */\nfunction FeatureIdTexture() {\n  /**\n   * How many unique features are defined in this set of feature IDs\n   *\n   * @type {Number}\n   * @private\n   */\n  this.featureCount = undefined;\n\n  /**\n   * This value indicates that no feature is indicated with this texel\n   *\n   * @type {Number}\n   * @private\n   */\n  this.nullFeatureId = undefined;\n\n  /**\n   * The ID of the property table that feature IDs index into. If undefined,\n   * feature IDs are used for classification, but no metadata is associated.\n   *\n   * @type {String}\n   * @private\n   */\n  this.propertyTableId = undefined;\n\n  /**\n   * The texture reader containing feature IDs.\n   *\n   * @type {ModelComponents.TextureReader}\n   * @private\n   */\n  this.textureReader = undefined;\n\n  /**\n   * The label to identify this set of feature IDs. This is used in picking,\n   * styling and shaders.\n   *\n   * @type {String}\n   * @private\n   */\n  this.label = undefined;\n\n  /**\n   * Label to identify this set of feature IDs by its position in the array.\n   * This will always be either \"featureId_N\" for primitives or\n   * \"instanceFeatureId_N\" for instances.\n   *\n   * @type {String}\n   * @private\n   */\n  this.positionalLabel = undefined;\n}\n\n/**\n * A morph target where each attribute contains attribute displacement data.\n *\n * @alias ModelComponents.MorphTarget\n * @constructor\n *\n * @private\n */\nfunction MorphTarget() {\n  /**\n   * Attributes that are part of the morph target, e.g. positions, normals, and tangents.\n   *\n   * @type {ModelComponents.Attribute[]}\n   * @private\n   */\n  this.attributes = [];\n}\n\n/**\n * Geometry to be rendered with a material.\n *\n * @alias ModelComponents.Primitive\n * @constructor\n *\n * @private\n */\nfunction Primitive() {\n  /**\n   * The vertex attributes, e.g. positions, normals, etc.\n   *\n   * @type {ModelComponents.Attribute[]}\n   * @private\n   */\n  this.attributes = [];\n\n  /**\n   * The morph targets.\n   *\n   * @type {ModelComponents.MorphTarget[]}\n   * @private\n   */\n  this.morphTargets = [];\n\n  /**\n   * The indices.\n   *\n   * @type {ModelComponents.Indices}\n   * @private\n   */\n  this.indices = undefined;\n\n  /**\n   * The material.\n   *\n   * @type {ModelComponents.Material}\n   * @private\n   */\n  this.material = undefined;\n\n  /**\n   * The primitive type, e.g. PrimitiveType.TRIANGLES.\n   *\n   * @type {PrimitiveType}\n   * @private\n   */\n  this.primitiveType = undefined;\n\n  /**\n   * The feature IDs associated with this primitive. Feature ID types may\n   * be interleaved\n   *\n   * @type {Array.<ModelComponents.FeatureIdAttribute|ModelComponents.FeatureIdImplicitRange|ModelComponents.FeatureIdTexture>}\n   * @private\n   */\n  this.featureIds = [];\n\n  /**\n   * The property texture IDs. These indices correspond to the array of\n   * property textures.\n   *\n   * @type {Number[]}\n   * @private\n   */\n  this.propertyTextureIds = [];\n\n  /**\n   * The property attribute IDs. These indices correspond to the array of\n   * property attributes in the EXT_structural_metadata extension.\n   *\n   * @type {Number[]}\n   * @private\n   */\n  this.propertyAttributeIds = [];\n}\n\n/**\n * Position and metadata information for instances of a node.\n *\n * @alias ModelComponents.Primitive\n * @constructor\n *\n * @private\n */\nfunction Instances() {\n  /**\n   * The instance attributes, e.g. translation, rotation, scale, feature id, etc.\n   *\n   * @type {ModelComponents.Attribute[]}\n   * @private\n   */\n  this.attributes = [];\n\n  /**\n   * The feature ID attributes associated with this set of instances.\n   * Feature ID attribute types may be interleaved.\n   *\n   * @type {Array.<ModelComponents.FeatureIdAttribute|ModelComponents.FeatureIdImplicitRange>}\n   * @private\n   */\n  this.featureIds = [];\n\n  /**\n   * Whether the instancing transforms are applied in world space. For glTF models that\n   * use EXT_mesh_gpu_instancing, the transform is applied in object space. For i3dm files,\n   * the instance transform is in world space.\n   *\n   * @type {Boolean}\n   * @private\n   */\n  this.transformInWorldSpace = false;\n}\n\n/**\n * Joints and matrices defining a skin.\n *\n * @alias ModelComponents.Skin\n * @constructor\n *\n * @private\n */\nfunction Skin() {\n  /**\n   * The index of the skin in the glTF. This is useful for finding the skin\n   * that applies to a node after the skin is instantiated at runtime.\n   *\n   * @type {Number}\n   * @private\n   */\n  this.index = undefined;\n\n  /**\n   * The joints.\n   *\n   * @type {ModelComponents.Node[]}\n   * @private\n   */\n  this.joints = [];\n\n  /**\n   * The inverse bind matrices of the joints.\n   *\n   * @type {Matrix4[]}\n   * @private\n   */\n  this.inverseBindMatrices = [];\n}\n\n/**\n * A node in the node hierarchy.\n *\n * @alias ModelComponents.Node\n * @constructor\n *\n * @private\n */\nfunction Node() {\n  /**\n   * The name of the node.\n   *\n   * @type {String}\n   * @private\n   */\n  this.name = undefined;\n\n  /**\n   * The index of the node in the glTF. This is useful for finding the nodes\n   * that belong to a skin after they have been instantiated at runtime.\n   *\n   * @type {Number}\n   * @private\n   */\n  this.index = undefined;\n\n  /**\n   * The children nodes.\n   *\n   * @type {ModelComponents.Node[]}\n   * @private\n   */\n  this.children = [];\n\n  /**\n   * The mesh primitives.\n   *\n   * @type {ModelComponents.Primitive[]}\n   * @private\n   */\n  this.primitives = [];\n\n  /**\n   * Instances of this node.\n   *\n   * @type {ModelComponents.Instances}\n   * @private\n   */\n  this.instances = undefined;\n\n  /**\n   * The skin.\n   *\n   * @type {ModelComponents.Skin}\n   * @private\n   */\n  this.skin = undefined;\n\n  /**\n   * The local transformation matrix. When matrix is defined translation,\n   * rotation, and scale must be undefined. When matrix is undefined\n   * translation, rotation, and scale must all be defined.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this.matrix = undefined;\n\n  /**\n   * The local translation.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this.translation = undefined;\n\n  /**\n   * The local rotation.\n   *\n   * @type {Quaternion}\n   * @private\n   */\n  this.rotation = undefined;\n\n  /**\n   * The local scale.\n   *\n   * @type {Cartesian3}\n   * @private\n   */\n  this.scale = undefined;\n\n  /**\n   * An array of weights to be applied to the primitives' morph targets.\n   * These are supplied by either the node or its mesh.\n   *\n   * @type {Number[]}\n   * @private\n   */\n  this.morphWeights = [];\n}\n\n/**\n * A scene containing nodes.\n *\n * @alias ModelComponents.Scene\n * @constructor\n *\n * @private\n */\nfunction Scene() {\n  /**\n   * The nodes belonging to the scene.\n   *\n   * @type {ModelComponents.Node[]}\n   * @private\n   */\n  this.nodes = [];\n}\n\n/**\n * The property of the node that is targeted by an animation. The values of\n * this enum are used to look up the appropriate property on the runtime node.\n *\n * @alias {ModelComponents.AnimatedPropertyType}\n * @enum {String}\n *\n * @private\n */\nconst AnimatedPropertyType = {\n  TRANSLATION: \"translation\",\n  ROTATION: \"rotation\",\n  SCALE: \"scale\",\n  WEIGHTS: \"weights\",\n};\n\n/**\n * An animation sampler that describes the sources of animated keyframe data\n * and their interpolation.\n *\n * @alias {ModelComponents.AnimationSampler}\n * @constructor\n *\n * @private\n */\nfunction AnimationSampler() {\n  /**\n   * The timesteps of the animation.\n   *\n   * @type {Number[]}\n   * @private\n   */\n  this.input = [];\n\n  /**\n   * The method used to interpolate between the animation's keyframe data.\n   *\n   * @type {InterpolationType}\n   * @private\n   */\n  this.interpolation = undefined;\n\n  /**\n   * The keyframe data of the animation.\n   *\n   * @type {Number[]|Cartesian3[]|Quaternion[]}\n   * @private\n   */\n  this.output = [];\n}\n\n/**\n * An animation target, which specifies the node and property to animate.\n *\n * @alias {ModelComponents.AnimationTarget}\n * @constructor\n *\n * @private\n */\nfunction AnimationTarget() {\n  /**\n   * The node that will be affected by the animation.\n   *\n   * @type {ModelComponents.Node}\n   * @private\n   */\n  this.node = undefined;\n\n  /**\n   * The property of the node to be animated.\n   *\n   * @type {ModelComponents.AnimatedPropertyType}\n   * @private\n   */\n  this.path = undefined;\n}\n\n/**\n * An animation channel linking an animation sampler and the target it animates.\n *\n * @alias {ModelComponents.AnimationChannel}\n * @constructor\n *\n * @private\n */\nfunction AnimationChannel() {\n  /**\n   * The sampler used as the source of the animation data.\n   *\n   * @type {ModelComponents.AnimationSampler}\n   * @private\n   */\n  this.sampler = undefined;\n\n  /**\n   * The target of the animation.\n   *\n   * @type {ModelComponents.AnimationTarget}\n   * @private\n   */\n  this.target = undefined;\n}\n\n/**\n * An animation in the model.\n *\n * @alias {ModelComponents.Animation}\n * @constructor\n *\n * @private\n */\nfunction Animation() {\n  /**\n   * The name of the animation.\n   *\n   * @type {String}\n   * @private\n   */\n  this.name = undefined;\n\n  /**\n   * The samplers used in this animation.\n   *\n   * @type {ModelComponents.AnimationSampler[]}\n   * @private\n   */\n  this.samplers = [];\n\n  /**\n   * The channels used in this animation.\n   *\n   * @type {ModelComponents.AnimationChannel[]}\n   * @private\n   */\n  this.channels = [];\n}\n\n/**\n * The asset of the model.\n *\n * @alias {ModelComponents.Asset}\n * @constructor\n *\n * @private\n */\nfunction Asset() {\n  /**\n   * The credits of the model.\n   *\n   * @type {Credit[]}\n   * @private\n   */\n  this.credits = [];\n}\n\n/**\n * The components that make up a model.\n *\n * @alias ModelComponents.Components\n * @constructor\n *\n * @private\n */\nfunction Components() {\n  /**\n   * The asset of the model.\n   *\n   * @type {ModelComponents.Asset}\n   * @private\n   */\n  this.asset = new Asset();\n\n  /**\n   * The default scene.\n   *\n   * @type {ModelComponents.Scene}\n   * @private\n   */\n  this.scene = undefined;\n\n  /**\n   * All nodes in the model.\n   *\n   * @type {ModelComponents.Node[]}\n   */\n  this.nodes = [];\n\n  /**\n   * All skins in the model.\n   *\n   * @type {ModelComponents.Skin[]}\n   */\n  this.skins = [];\n\n  /**\n   * All animations in the model.\n   *\n   * @type {ModelComponents.Animation[]}\n   */\n  this.animations = [];\n\n  /**\n   * Structural metadata containing the schema, property tables, property\n   * textures and property mappings\n   *\n   * @type {StructuralMetadata}\n   * @private\n   */\n  this.structuralMetadata = undefined;\n\n  /**\n   * The model's up axis.\n   *\n   * @type {Axis}\n   * @private\n   */\n  this.upAxis = undefined;\n\n  /**\n   * The model's forward axis.\n   *\n   * @type {Axis}\n   * @private\n   */\n  this.forwardAxis = undefined;\n\n  /**\n   * A world-space transform to apply to the primitives.\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this.transform = Matrix4.clone(Matrix4.IDENTITY);\n}\n\n/**\n * Information about a GPU texture, including the texture itself\n *\n * @alias ModelComponents.TextureReader\n * @constructor\n *\n * @private\n */\nfunction TextureReader() {\n  /**\n   * The underlying GPU texture. The {@link Texture} contains the sampler.\n   *\n   * @type {Texture}\n   * @private\n   */\n  this.texture = undefined;\n\n  /**\n   * The index of the texture in the glTF. This is useful for determining\n   * when textures are shared to avoid attaching a texture in multiple uniform\n   * slots in the shader.\n   *\n   * @type {Number}\n   * @private\n   */\n  this.index = undefined;\n\n  /**\n   * The texture coordinate set.\n   *\n   * @type {Number}\n   * @default 0\n   * @private\n   */\n  this.texCoord = 0;\n\n  /**\n   * Transformation matrix to apply to texture coordinates.\n   *\n   * @type {Matrix3}\n   * @default Matrix3.IDENTITY\n   */\n  this.transform = Matrix3.clone(Matrix3.IDENTITY);\n\n  /**\n   * The texture channels to read from. When undefined all channels are read.\n   *\n   * @type {String}\n   */\n  this.channels = undefined;\n}\n\n/**\n * Material properties for the PBR metallic roughness shading model.\n *\n * @alias ModelComponents.MetallicRoughness\n * @constructor\n *\n * @private\n */\nfunction MetallicRoughness() {\n  /**\n   * The base color texture reader.\n   *\n   * @type {ModelComponents.TextureReader}\n   * @private\n   */\n  this.baseColorTexture = undefined;\n\n  /**\n   * The metallic roughness texture reader.\n   *\n   * @type {ModelComponents.TextureReader}\n   * @private\n   */\n  this.metallicRoughnessTexture = undefined;\n\n  /**\n   * The base color factor.\n   *\n   * @type {Cartesian4}\n   * @default new Cartesian4(1.0, 1.0, 1.0, 1.0)\n   * @private\n   */\n  this.baseColorFactor = Cartesian4.clone(\n    MetallicRoughness.DEFAULT_BASE_COLOR_FACTOR\n  );\n\n  /**\n   * The metallic factor.\n   *\n   * @type {Number}\n   * @default 1.0\n   * @private\n   */\n  this.metallicFactor = MetallicRoughness.DEFAULT_METALLIC_FACTOR;\n\n  /**\n   * The roughness factor.\n   *\n   * @type {Number}\n   * @default 1.0\n   * @private\n   */\n  this.roughnessFactor = MetallicRoughness.DEFAULT_ROUGHNESS_FACTOR;\n}\n\n/**\n * @private\n */\nMetallicRoughness.DEFAULT_BASE_COLOR_FACTOR = Cartesian4.ONE;\n\n/**\n * @private\n */\nMetallicRoughness.DEFAULT_METALLIC_FACTOR = 1.0;\n\n/**\n * @private\n */\nMetallicRoughness.DEFAULT_ROUGHNESS_FACTOR = 1.0;\n\n/**\n * Material properties for the PBR specular glossiness shading model.\n *\n * @alias ModelComponents.function SpecularGlossiness\n * @constructor\n *\n * @private\n */\nfunction SpecularGlossiness() {\n  /**\n   * The diffuse texture reader.\n   *\n   * @type {ModelComponents.TextureReader}\n   * @private\n   */\n  this.diffuseTexture = undefined;\n\n  /**\n   * The specular glossiness texture reader.\n   *\n   * @type {ModelComponents.TextureReader}\n   * @private\n   */\n  this.specularGlossinessTexture = undefined;\n\n  /**\n   * The diffuse factor.\n   *\n   * @type {Cartesian4}\n   * @default new Cartesian4(1.0, 1.0, 1.0, 1.0)\n   * @private\n   */\n  this.diffuseFactor = Cartesian4.clone(\n    SpecularGlossiness.DEFAULT_DIFFUSE_FACTOR\n  );\n\n  /**\n   * The specular factor.\n   *\n   * @type {Cartesian3}\n   * @default new Cartesian3(1.0, 1.0, 1.0)\n   * @private\n   */\n  this.specularFactor = Cartesian3.clone(\n    SpecularGlossiness.DEFAULT_SPECULAR_FACTOR\n  );\n\n  /**\n   * The glossiness factor.\n   *\n   * @type {Number}\n   * @default 1.0\n   * @private\n   */\n  this.glossinessFactor = SpecularGlossiness.DEFAULT_GLOSSINESS_FACTOR;\n}\n\n/**\n * @private\n */\nSpecularGlossiness.DEFAULT_DIFFUSE_FACTOR = Cartesian4.ONE;\n\n/**\n * @private\n */\nSpecularGlossiness.DEFAULT_SPECULAR_FACTOR = Cartesian3.ONE;\n\n/**\n * @private\n */\nSpecularGlossiness.DEFAULT_GLOSSINESS_FACTOR = 1.0;\n\n/**\n * The material appearance of a primitive.\n *\n * @alias ModelComponent.Material\n * @constructor\n *\n * @private\n */\nfunction Material() {\n  /**\n   * Material properties for the PBR metallic roughness shading model.\n   *\n   * @type {ModelComponents.MetallicRoughness}\n   * @private\n   */\n  this.metallicRoughness = new MetallicRoughness();\n\n  /**\n   * Material properties for the PBR specular glossiness shading model.\n   *\n   * @type {ModelComponents.SpecularGlossiness}\n   * @private\n   */\n  this.specularGlossiness = undefined;\n\n  /**\n   * The emissive texture reader.\n   *\n   * @type {ModelComponents.TextureReader}\n   * @private\n   */\n  this.emissiveTexture = undefined;\n\n  /**\n   * The normal texture reader.\n   *\n   * @type {ModelComponents.TextureReader}\n   * @private\n   */\n  this.normalTexture = undefined;\n\n  /**\n   * The occlusion texture reader.\n   *\n   * @type {ModelComponents.TextureReader}\n   * @private\n   */\n  this.occlusionTexture = undefined;\n\n  /**\n   * The emissive factor.\n   *\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   * @private\n   */\n  this.emissiveFactor = Cartesian3.clone(Material.DEFAULT_EMISSIVE_FACTOR);\n\n  /**\n   * The alpha mode.\n   *\n   * @type {AlphaMode}\n   * @default AlphaMode.OPAQUE\n   * @private\n   */\n  this.alphaMode = AlphaMode.OPAQUE;\n\n  /**\n   * The alpha cutoff value of the material for the MASK alpha mode.\n   *\n   * @type {Number}\n   * @default 0.5\n   * @private\n   */\n  this.alphaCutoff = 0.5;\n\n  /**\n   * Specifies whether the material is double sided.\n   *\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  this.doubleSided = false;\n\n  /**\n   * Specifies whether the material is unlit.\n   *\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  this.unlit = false;\n}\n\n/**\n * @private\n */\nMaterial.DEFAULT_EMISSIVE_FACTOR = Cartesian3.ZERO;\n\nModelComponents.Quantization = Quantization;\nModelComponents.Attribute = Attribute;\nModelComponents.Indices = Indices;\nModelComponents.FeatureIdAttribute = FeatureIdAttribute;\nModelComponents.FeatureIdTexture = FeatureIdTexture;\nModelComponents.FeatureIdImplicitRange = FeatureIdImplicitRange;\nModelComponents.MorphTarget = MorphTarget;\nModelComponents.Primitive = Primitive;\nModelComponents.Instances = Instances;\nModelComponents.Skin = Skin;\nModelComponents.Node = Node;\nModelComponents.Scene = Scene;\nModelComponents.AnimatedPropertyType = Object.freeze(AnimatedPropertyType);\nModelComponents.AnimationSampler = AnimationSampler;\nModelComponents.AnimationTarget = AnimationTarget;\nModelComponents.AnimationChannel = AnimationChannel;\nModelComponents.Animation = Animation;\nModelComponents.Asset = Asset;\nModelComponents.Components = Components;\nModelComponents.TextureReader = TextureReader;\nModelComponents.MetallicRoughness = MetallicRoughness;\nModelComponents.SpecularGlossiness = SpecularGlossiness;\nModelComponents.Material = Material;\n\nexport default ModelComponents;\n","import defaultValue from \"../../Core/defaultValue.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport BlendingState from \"../BlendingState.js\";\nimport Pass from \"../../Renderer/Pass.js\";\n\n/**\n * A pipeline stage for configuring the alpha options for handling translucency.\n *\n * @namespace MaterialPipelineStage\n *\n * @private\n */\nconst AlphaPipelineStage = {};\nAlphaPipelineStage.name = \"AlphaPipelineStage\"; // Helps with debugging\n\nAlphaPipelineStage.process = function (renderResources, primitive, frameState) {\n  const alphaOptions = renderResources.alphaOptions;\n\n  // Ensure the pass is defined\n  const model = renderResources.model;\n  alphaOptions.pass = defaultValue(alphaOptions.pass, model.opaquePass);\n\n  const renderStateOptions = renderResources.renderStateOptions;\n  if (alphaOptions.pass === Pass.TRANSLUCENT) {\n    renderStateOptions.blending = BlendingState.ALPHA_BLEND;\n  } else {\n    renderStateOptions.blending = BlendingState.DISABLED;\n  }\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  const uniformMap = renderResources.uniformMap;\n  const alphaMode = alphaOptions.alphaMode;\n\n  if (alphaMode === AlphaMode.MASK) {\n    shaderBuilder.addDefine(\n      \"ALPHA_MODE_MASK\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_alphaCutoff\",\n      ShaderDestination.FRAGMENT\n    );\n    uniformMap.u_alphaCutoff = function () {\n      return alphaOptions.alphaCutoff;\n    };\n  } else if (alphaMode === AlphaMode.BLEND) {\n    shaderBuilder.addDefine(\n      \"ALPHA_MODE_BLEND\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  } else {\n    shaderBuilder.addDefine(\n      \"ALPHA_MODE_OPAQUE\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n};\n\nexport default AlphaPipelineStage;\n","import Axis from \"../Axis.js\";\nimport B3dmParser from \"../B3dmParser.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cesium3DTileFeatureTable from \"../Cesium3DTileFeatureTable.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport GltfLoader from \"../GltfLoader.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport MetadataClass from \"../MetadataClass.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\nconst B3dmLoaderState = {\n  UNLOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  READY: 3,\n  FAILED: 4,\n};\n\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\n\n/**\n * Loads a Batched 3D Model.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias B3dmLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.b3dmResource The {@link Resource} containing the b3dm.\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the b3dm contents.\n * @param {Number} [options.byteOffset] The byte offset to the beginning of the b3dm contents in the array buffer.\n * @param {Resource} [options.baseResource] The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the glTF is loaded.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.X] The forward-axis of the glTF model.\n * @param {Boolean} [options.loadAttributesAsTypedArray=false] Load all attributes as typed arrays instead of GPU buffers.\n * @param {Boolean} [options.loadPositionsFor2D=false] If true, load the positions buffer as a typed array for accurately projecting models to 2D.\n * @param {Boolean} [options.loadIndicesForWireframe=false] Load the index buffer as a typed array. This is useful for creating wireframe indices in WebGL1.\n */\nfunction B3dmLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const b3dmResource = options.b3dmResource;\n  let baseResource = options.baseResource;\n  const arrayBuffer = options.arrayBuffer;\n  const byteOffset = defaultValue(options.byteOffset, 0);\n  const releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const incrementallyLoadTextures = defaultValue(\n    options.incrementallyLoadTextures,\n    true\n  );\n  const upAxis = defaultValue(options.upAxis, Axis.Y);\n  const forwardAxis = defaultValue(options.forwardAxis, Axis.X);\n  const loadAttributesAsTypedArray = defaultValue(\n    options.loadAttributesAsTypedArray,\n    false\n  );\n  const loadPositionsFor2D = defaultValue(options.loadPositionsFor2D, false);\n  const loadIndicesForWireframe = defaultValue(\n    options.loadIndicesForWireframe,\n    false\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.b3dmResource\", b3dmResource);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  baseResource = defined(baseResource) ? baseResource : b3dmResource.clone();\n\n  this._b3dmResource = b3dmResource;\n  this._baseResource = baseResource;\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n  this._releaseGltfJson = releaseGltfJson;\n  this._asynchronous = asynchronous;\n  this._incrementallyLoadTextures = incrementallyLoadTextures;\n  this._upAxis = upAxis;\n  this._forwardAxis = forwardAxis;\n  this._loadAttributesAsTypedArray = loadAttributesAsTypedArray;\n  this._loadPositionsFor2D = loadPositionsFor2D;\n  this._loadIndicesForWireframe = loadIndicesForWireframe;\n\n  this._state = B3dmLoaderState.UNLOADED;\n\n  this._promise = undefined;\n\n  this._gltfLoader = undefined;\n\n  // Loaded results.\n  this._batchLength = 0;\n  this._propertyTable = undefined;\n\n  // The batch table object contains a json and a binary component access using keys of the same name.\n  this._batchTable = undefined;\n  this._components = undefined;\n  this._transform = Matrix4.IDENTITY;\n}\n\nif (defined(Object.create)) {\n  B3dmLoader.prototype = Object.create(ResourceLoader.prototype);\n  B3dmLoader.prototype.constructor = B3dmLoader;\n}\n\nObject.defineProperties(B3dmLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof B3dmLoader.prototype\n   *\n   * @type {Promise.<B3dmLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n\n  /**\n   * A promise that resolves when all textures are loaded.\n   * When <code>incrementallyLoadTextures</code> is true this may resolve after\n   * <code>promise</code> resolves.\n   *\n   * @memberof B3dmLoader.prototype\n   *\n   * @type {Promise}\n   * @readonly\n   * @private\n   */\n  texturesLoadedPromise: {\n    get: function () {\n      return this._gltfLoader.texturesLoadedPromise;\n    },\n  },\n  /**\n   * The cache key of the resource\n   *\n   * @memberof B3dmLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * The loaded components.\n   *\n   * @memberof B3dmLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<B3dmLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nB3dmLoader.prototype.load = function () {\n  const b3dm = B3dmParser.parse(this._arrayBuffer, this._byteOffset);\n\n  let batchLength = b3dm.batchLength;\n  const featureTableJson = b3dm.featureTableJson;\n  const featureTableBinary = b3dm.featureTableBinary;\n  const batchTableJson = b3dm.batchTableJson;\n  const batchTableBinary = b3dm.batchTableBinary;\n\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary\n  );\n  batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n  // Set batch length.\n  this._batchLength = batchLength;\n  // Set the RTC Center transform, if present.\n  const rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n  if (defined(rtcCenter)) {\n    this._transform = Matrix4.fromTranslation(Cartesian3.fromArray(rtcCenter));\n  }\n\n  this._batchTable = {\n    json: batchTableJson,\n    binary: batchTableBinary,\n  };\n\n  const gltfLoader = new GltfLoader({\n    typedArray: b3dm.gltf,\n    upAxis: this._upAxis,\n    forwardAxis: this._forwardAxis,\n    gltfResource: this._b3dmResource,\n    baseResource: this._baseResource,\n    releaseGltfJson: this._releaseGltfJson,\n    incrementallyLoadTextures: this._incrementallyLoadTextures,\n    loadAttributesAsTypedArray: this._loadAttributesAsTypedArray,\n    loadPositionsFor2D: this._loadPositionsFor2D,\n    loadIndicesForWireframe: this._loadIndicesForWireframe,\n    renameBatchIdSemantic: true,\n  });\n\n  this._gltfLoader = gltfLoader;\n  this._state = B3dmLoaderState.LOADING;\n\n  const that = this;\n  gltfLoader.load();\n  this._promise = gltfLoader.promise\n    .then(function () {\n      if (that.isDestroyed()) {\n        return;\n      }\n\n      const components = gltfLoader.components;\n      components.transform = that._transform;\n      createStructuralMetadata(that, components);\n      that._components = components;\n\n      that._state = B3dmLoaderState.READY;\n      return that;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n      return handleError(that, error);\n    });\n\n  return this._promise;\n};\n\nfunction handleError(b3dmLoader, error) {\n  b3dmLoader.unload();\n  b3dmLoader._state = B3dmLoaderState.FAILED;\n  const errorMessage = \"Failed to load b3dm\";\n  error = b3dmLoader.getError(errorMessage, error);\n  return Promise.reject(error);\n}\n\nB3dmLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === B3dmLoaderState.LOADING) {\n    this._state = B3dmLoaderState.PROCESSING;\n  }\n\n  if (this._state === B3dmLoaderState.PROCESSING) {\n    this._gltfLoader.process(frameState);\n  }\n};\n\nfunction createStructuralMetadata(loader, components) {\n  const batchTable = loader._batchTable;\n  const batchLength = loader._batchLength;\n\n  if (batchLength === 0) {\n    return;\n  }\n\n  let structuralMetadata;\n  if (defined(batchTable.json)) {\n    // Add the structural metadata from the batch table to the model components.\n    structuralMetadata = parseBatchTable({\n      count: batchLength,\n      batchTable: batchTable.json,\n      binaryBody: batchTable.binary,\n    });\n  } else {\n    // If batch table is not defined, create a property table without any properties.\n    const emptyPropertyTable = new PropertyTable({\n      name: MetadataClass.BATCH_TABLE_CLASS_NAME,\n      count: batchLength,\n    });\n    structuralMetadata = new StructuralMetadata({\n      schema: {},\n      propertyTables: [emptyPropertyTable],\n    });\n  }\n\n  // Add the feature ID attribute to the primitives.\n  const nodes = components.scene.nodes;\n  const length = nodes.length;\n  for (let i = 0; i < length; i++) {\n    processNode(nodes[i]);\n  }\n  components.structuralMetadata = structuralMetadata;\n}\n\n// Recursive function to add the feature ID attribute to all primitives that have a feature ID vertex attribute.\nfunction processNode(node) {\n  const childrenLength = node.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    processNode(node.children[i]);\n  }\n\n  const primitivesLength = node.primitives.length;\n  for (let i = 0; i < primitivesLength; i++) {\n    const primitive = node.primitives[i];\n    const featureIdVertexAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n      primitive,\n      VertexAttributeSemantic.FEATURE_ID\n    );\n    if (defined(featureIdVertexAttribute)) {\n      featureIdVertexAttribute.setIndex = 0;\n      const featureIdAttribute = new FeatureIdAttribute();\n      featureIdAttribute.propertyTableId = 0;\n      featureIdAttribute.setIndex = 0;\n      featureIdAttribute.positionalLabel = \"featureId_0\";\n      primitive.featureIds.push(featureIdAttribute);\n    }\n  }\n}\n\nB3dmLoader.prototype.unload = function () {\n  if (defined(this._gltfLoader)) {\n    this._gltfLoader.unload();\n  }\n\n  this._components = undefined;\n};\n\nexport default B3dmLoader;\n","import combine from \"../../Core/combine.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\n\n/**\n * The batch texture stage is responsible for setting up the batch texture for the primitive.\n *\n * @namespace BatchTexturePipelineStage\n * @private\n */\nconst BatchTexturePipelineStage = {};\nBatchTexturePipelineStage.name = \"BatchTexturePipelineStage\"; // Helps with debugging\n\n/**\n * Processes a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>adds uniforms for the batch texture</li>\n *  <li>adds defines for multiline batch textures</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nBatchTexturePipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const batchTextureUniforms = {};\n\n  const model = renderResources.model;\n\n  const featureTable = model.featureTables[model.featureTableId];\n\n  // Number of features in the feature table.\n  const featuresLength = featureTable.featuresLength;\n  shaderBuilder.addUniform(\"int\", \"model_featuresLength\");\n  batchTextureUniforms.model_featuresLength = function () {\n    return featuresLength;\n  };\n\n  // Batch texture\n  const batchTexture = featureTable.batchTexture;\n  shaderBuilder.addUniform(\"sampler2D\", \"model_batchTexture\");\n  batchTextureUniforms.model_batchTexture = function () {\n    return defaultValue(batchTexture.batchTexture, batchTexture.defaultTexture);\n  };\n\n  // Batch texture step size\n  shaderBuilder.addUniform(\"vec4\", \"model_textureStep\");\n  batchTextureUniforms.model_textureStep = function () {\n    return batchTexture.textureStep;\n  };\n\n  // Batch texture dimensions\n  if (batchTexture.textureDimensions.y > 1) {\n    shaderBuilder.addDefine(\"MULTILINE_BATCH_TEXTURE\");\n    shaderBuilder.addUniform(\"vec2\", \"model_textureDimensions\");\n    batchTextureUniforms.model_textureDimensions = function () {\n      return batchTexture.textureDimensions;\n    };\n  }\n\n  renderResources.uniformMap = combine(\n    batchTextureUniforms,\n    renderResources.uniformMap\n  );\n};\n\nexport default BatchTexturePipelineStage;\n","import CPUStylingStageVS from \"../../Shaders/ModelExperimental/CPUStylingStageVS.js\";\nimport CPUStylingStageFS from \"../../Shaders/ModelExperimental/CPUStylingStageFS.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport ColorBlendMode from \"../ColorBlendMode.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport StyleCommandsNeeded from \"./StyleCommandsNeeded.js\";\nimport ModelColorPipelineStage from \"./ModelColorPipelineStage.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport defined from \"../../Core/defined.js\";\n/**\n * The CPU styling stage is responsible for ensuring that the feature's color is applied at runtime.\n *\n * @namespace CPUStylingPipelineStage\n *\n * @private\n */\nconst CPUStylingPipelineStage = {};\nCPUStylingPipelineStage.name = \"CPUStylingPipelineStage\"; // Helps with debugging\n\n/**\n * Processes a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>adds the styling code to both the vertex and fragment shaders</li>\n *  <li>adds the define to trigger the stage's shader functions</li>\n *  <li>adds a uniform with the model's color blend mode and amount</li>\n *  <li>sets a variable in the render resources denoting whether or not the model has translucent colors that will require multiple draw commands</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nCPUStylingPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const model = renderResources.model;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addVertexLines([CPUStylingStageVS]);\n  shaderBuilder.addFragmentLines([CPUStylingStageFS]);\n  shaderBuilder.addDefine(\"USE_CPU_STYLING\", undefined, ShaderDestination.BOTH);\n\n  // These uniforms may have already been added by the ModelColorStage if a static\n  // color is applied.\n  if (!defined(model.color)) {\n    shaderBuilder.addUniform(\n      \"float\",\n      ModelColorPipelineStage.COLOR_BLEND_UNIFORM_NAME,\n      ShaderDestination.FRAGMENT\n    );\n    renderResources.uniformMap[\n      ModelColorPipelineStage.COLOR_BLEND_UNIFORM_NAME\n    ] = function () {\n      return ColorBlendMode.getColorBlend(\n        model.colorBlendMode,\n        model.colorBlendAmount\n      );\n    };\n  }\n\n  shaderBuilder.addUniform(\n    \"bool\",\n    \"model_commandTranslucent\",\n    ShaderDestination.BOTH\n  );\n  renderResources.uniformMap.model_commandTranslucent = function () {\n    // always check the current value, because custom shaders may\n    // change the value with the isTranslucent flag\n    return renderResources.alphaOptions.pass === Pass.TRANSLUCENT;\n  };\n\n  const featureTable = model.featureTables[model.featureTableId];\n  const styleCommandsNeeded = StyleCommandsNeeded.getStyleCommandsNeeded(\n    featureTable.featuresLength,\n    featureTable.batchTexture.translucentFeaturesLength\n  );\n\n  if (styleCommandsNeeded !== StyleCommandsNeeded.ALL_OPAQUE) {\n    renderResources.alphaOptions.alphaMode = AlphaMode.BLEND;\n  }\n\n  renderResources.styleCommandsNeeded = styleCommandsNeeded;\n};\n\nexport default CPUStylingPipelineStage;\n","import Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport CustomShaderMode from \"./CustomShaderMode.js\";\nimport UniformType from \"./UniformType.js\";\nimport TextureManager from \"./TextureManager.js\";\n\n/**\n * An object describing a uniform, its type, and an initial value\n *\n * @typedef {Object} UniformSpecifier\n * @property {UniformType} type The Glsl type of the uniform.\n * @property {Boolean|Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4|TextureUniform} value The initial value of the uniform\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\n\n/**\n * A set of variables parsed from the user-defined shader code. These can be\n * used for optimizations when generating the overall shader. Though they are\n * represented as JS objects, the intended use is like a set, so only the\n * existence of keys matter. The values will always be <code>true</code> if\n * defined. This data structure is used because:\n * <ul>\n *   <li>We cannot yet use ES6 Set objects</li>\n *   <li>Using a dictionary automatically de-duplicates variable names</li>\n *   <li>Queries such as <code>variableSet.hasOwnProperty(\"position\")</code> are straightforward</li>\n * </ul>\n * @typedef {Object<String, Boolean>} VariableSet\n * @private\n */\n\n/**\n * Variable sets parsed from the user-defined vertex shader text.\n * @typedef {Object} VertexVariableSets\n * @property {VariableSet} attributeSet A set of all unique attributes used in the vertex shader via the <code>vsInput.attributes</code> struct.\n * @property {VariableSet} featureIdSet A set of all unique feature ID sets used in the vertex shader via the <code>vsInput.featureIds</code> struct.\n * @property {VariableSet} metadataSet A set of all unique metadata properties used in the vertex shader via the <code>vsInput.metadata</code> struct.\n * @private\n */\n\n/**\n * Variable sets parsed from the user-defined fragment shader text.\n * @typedef {Object} FragmentVariableSets\n * @property {VariableSet} attributeSet A set of all unique attributes used in the fragment shader via the <code>fsInput.attributes</code> struct\n * @property {VariableSet} featureIdSet A set of all unique feature ID sets used in the fragment shader via the <code>fsInput.featureIds</code> struct.\n * @property {VariableSet} metadataSet A set of all unique metadata properties used in the fragment shader via the <code>fsInput.metadata</code> struct.\n * @property {VariableSet} materialSet A set of all material variables such as diffuse, specular or alpha that are used in the fragment shader via the <code>material</code> struct.\n * @private\n */\n\n/**\n * A user defined GLSL shader used with {@link ModelExperimental} as well\n * as {@link Cesium3DTileset}.\n * <p>\n * If texture uniforms are used, additional resource management must be done:\n * </p>\n * <ul>\n *   <li>\n *      The <code>update</code> function must be called each frame. When a\n *      custom shader is passed to a {@link ModelExperimental} or a\n *      {@link Cesium3DTileset}, this step is handled automaticaly\n *   </li>\n *   <li>\n *      {@link CustomShader#destroy} must be called when the custom shader is\n *      no longer needed to clean up GPU resources properly. The application\n *      is responsible for calling this method.\n *   </li>\n * </ul>\n * <p>\n * To enable the use of {@link ModelExperimental} in {@link Cesium3DTileset}, set {@link ExperimentalFeatures.enableModelExperimental} to <code>true</code> or tileset.enableModelExperimental to <code>true</code>.\n * </p>\n * <p>\n * See the {@link https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide|Custom Shader Guide} for more detailed documentation.\n * </p>\n *\n * @param {Object} options An object with the following options\n * @param {CustomShaderMode} [options.mode=CustomShaderMode.MODIFY_MATERIAL] The custom shader mode, which determines how the custom shader code is inserted into the fragment shader.\n * @param {LightingModel} [options.lightingModel] The lighting model (e.g. PBR or unlit). If present, this overrides the default lighting for the model.\n * @param {Boolean} [options.isTranslucent=false] If set, the model will be rendered as translucent. This overrides the default settings for the model.\n * @param {Object.<String, UniformSpecifier>} [options.uniforms] A dictionary for user-defined uniforms. The key is the uniform name that will appear in the GLSL code. The value is an object that describes the uniform type and initial value\n * @param {Object.<String, VaryingType>} [options.varyings] A dictionary for declaring additional GLSL varyings used in the shader. The key is the varying name that will appear in the GLSL code. The value is the data type of the varying. For each varying, the declaration will be added to the top of the shader automatically. The caller is responsible for assigning a value in the vertex shader and using the value in the fragment shader.\n * @param {String} [options.vertexShaderText] The custom vertex shader as a string of GLSL code. It must include a GLSL function called vertexMain. See the example for the expected signature. If not specified, the custom vertex shader step will be skipped in the computed vertex shader.\n * @param {String} [options.fragmentShaderText] The custom fragment shader as a string of GLSL code. It must include a GLSL function called fragmentMain. See the example for the expected signature. If not specified, the custom fragment shader step will be skipped in the computed fragment shader.\n *\n * @alias CustomShader\n * @constructor\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n *\n * @example\n * const customShader = new CustomShader({\n *   uniforms: {\n *     u_colorIndex: {\n *       type: Cesium.UniformType.FLOAT,\n *       value: 1.0\n *     },\n *     u_normalMap: {\n *       type: Cesium.UniformType.SAMPLER_2D,\n *       value: new Cesium.TextureUniform({\n *         url: \"http://example.com/normal.png\"\n *       })\n *     }\n *   },\n *   varyings: {\n *     v_selectedColor: Cesium.VaryingType.VEC3\n *   },\n *   vertexShaderText: `\n *   void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {\n *     v_selectedColor = mix(vsInput.attributes.color_0, vsInput.attributes.color_1, u_colorIndex);\n *     vsOutput.positionMC += 0.1 * vsInput.attributes.normal;\n *   }\n *   `,\n *   fragmentShaderText: `\n *   void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {\n *     material.normal = texture2D(u_normalMap, fsInput.attributes.texCoord_0);\n *     material.diffuse = v_selectedColor;\n *   }\n *   `\n * });\n */\nexport default function CustomShader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * A value determining how the custom shader interacts with the overall\n   * fragment shader. This is used by {@link CustomShaderPipelineStage}\n   *\n   * @type {CustomShaderMode}\n   * @readonly\n   */\n  this.mode = defaultValue(options.mode, CustomShaderMode.MODIFY_MATERIAL);\n  /**\n   * The lighting model to use when using the custom shader.\n   * This is used by {@link CustomShaderPipelineStage}\n   *\n   * @type {LightingModel}\n   * @readonly\n   */\n  this.lightingModel = options.lightingModel;\n  /**\n   * Additional uniforms as declared by the user.\n   *\n   * @type {Object.<String, UniformSpecifier>}\n   * @readonly\n   */\n  this.uniforms = defaultValue(options.uniforms, defaultValue.EMPTY_OBJECT);\n  /**\n   * Additional varyings as declared by the user.\n   * This is used by {@link CustomShaderPipelineStage}\n   *\n   * @type {Object.<String, VaryingType>}\n   * @readonly\n   */\n  this.varyings = defaultValue(options.varyings, defaultValue.EMPTY_OBJECT);\n  /**\n   * The user-defined GLSL code for the vertex shader\n   *\n   * @type {String}\n   * @readonly\n   */\n  this.vertexShaderText = options.vertexShaderText;\n  /**\n   * The user-defined GLSL code for the fragment shader\n   *\n   * @type {String}\n   * @readonly\n   */\n  this.fragmentShaderText = options.fragmentShaderText;\n  /**\n   * Whether the shader should be rendered as translucent\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  this.isTranslucent = defaultValue(options.isTranslucent, false);\n\n  /**\n   * texture uniforms require some asynchronous processing. This is delegated\n   * to a texture manager.\n   *\n   * @type {TextureManager}\n   * @readonly\n   * @private\n   */\n  this._textureManager = new TextureManager();\n  /**\n   * The default texture (from the {@link Context}) to use while textures\n   * are loading\n   *\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  this._defaultTexture = undefined;\n  /**\n   * The map of uniform names to a function that returns a value. This map\n   * is combined with the overall uniform map used by the {@link DrawCommand}\n   *\n   * @type {Object.<String, Function>}\n   * @readonly\n   * @private\n   */\n  this.uniformMap = buildUniformMap(this);\n\n  /**\n   * A collection of variables used in <code>vertexShaderText</code>. This\n   * is used only for optimizations in {@link CustomShaderPipelineStage}.\n   * @type {VertexVariableSets}\n   * @private\n   */\n  this.usedVariablesVertex = {\n    attributeSet: {},\n    featureIdSet: {},\n    metadataSet: {},\n  };\n  /**\n   * A collection of variables used in <code>fragmentShaderText</code>. This\n   * is used only for optimizations in {@link CustomShaderPipelineStage}.\n   * @type {FragmentVariableSets}\n   * @private\n   */\n  this.usedVariablesFragment = {\n    attributeSet: {},\n    featureIdSet: {},\n    metadataSet: {},\n    materialSet: {},\n  };\n\n  findUsedVariables(this);\n  validateBuiltinVariables(this);\n}\n\nfunction buildUniformMap(customShader) {\n  const uniforms = customShader.uniforms;\n  const uniformMap = {};\n  for (const uniformName in uniforms) {\n    if (uniforms.hasOwnProperty(uniformName)) {\n      const uniform = uniforms[uniformName];\n      const type = uniform.type;\n      //>>includeStart('debug', pragmas.debug);\n      if (type === UniformType.SAMPLER_CUBE) {\n        throw new DeveloperError(\n          \"CustomShader does not support samplerCube uniforms\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      if (type === UniformType.SAMPLER_2D) {\n        customShader._textureManager.loadTexture2D(uniformName, uniform.value);\n        uniformMap[uniformName] = createUniformTexture2DFunction(\n          customShader,\n          uniformName\n        );\n      } else {\n        uniformMap[uniformName] = createUniformFunction(\n          customShader,\n          uniformName\n        );\n      }\n    }\n  }\n  return uniformMap;\n}\n\nfunction createUniformTexture2DFunction(customShader, uniformName) {\n  return function () {\n    return defaultValue(\n      customShader._textureManager.getTexture(uniformName),\n      customShader._defaultTexture\n    );\n  };\n}\n\nfunction createUniformFunction(customShader, uniformName) {\n  return function () {\n    return customShader.uniforms[uniformName].value;\n  };\n}\n\nfunction getVariables(shaderText, regex, outputSet) {\n  let match;\n  while ((match = regex.exec(shaderText)) !== null) {\n    const variableName = match[1];\n\n    // Using a dictionary like a set. The value doesn't\n    // matter, as this will only be used for queries such as\n    // if (set.hasOwnProperty(variableName)) { ... }\n    outputSet[variableName] = true;\n  }\n}\n\nfunction findUsedVariables(customShader) {\n  const attributeRegex = /[vf]sInput\\.attributes\\.(\\w+)/g;\n  const featureIdRegex = /[vf]sInput\\.featureIds\\.(\\w+)/g;\n  const metadataRegex = /[vf]sInput\\.metadata.(\\w+)/g;\n  let attributeSet;\n\n  const vertexShaderText = customShader.vertexShaderText;\n  if (defined(vertexShaderText)) {\n    attributeSet = customShader.usedVariablesVertex.attributeSet;\n    getVariables(vertexShaderText, attributeRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesVertex.featureIdSet;\n    getVariables(vertexShaderText, featureIdRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesVertex.metadataSet;\n    getVariables(vertexShaderText, metadataRegex, attributeSet);\n  }\n\n  const fragmentShaderText = customShader.fragmentShaderText;\n  if (defined(fragmentShaderText)) {\n    attributeSet = customShader.usedVariablesFragment.attributeSet;\n    getVariables(fragmentShaderText, attributeRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesFragment.featureIdSet;\n    getVariables(fragmentShaderText, featureIdRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesFragment.metadataSet;\n    getVariables(fragmentShaderText, metadataRegex, attributeSet);\n\n    const materialRegex = /material\\.(\\w+)/g;\n    const materialSet = customShader.usedVariablesFragment.materialSet;\n    getVariables(fragmentShaderText, materialRegex, materialSet);\n  }\n}\n\nfunction expandCoordinateAbbreviations(variableName) {\n  const modelCoordinatesRegex = /^.*MC$/;\n  const worldCoordinatesRegex = /^.*WC$/;\n  const eyeCoordinatesRegex = /^.*EC$/;\n\n  if (modelCoordinatesRegex.test(variableName)) {\n    return `${variableName} (model coordinates)`;\n  }\n\n  if (worldCoordinatesRegex.test(variableName)) {\n    return `${variableName} (Cartesian world coordinates)`;\n  }\n\n  if (eyeCoordinatesRegex.test(variableName)) {\n    return `${variableName} (eye coordinates)`;\n  }\n\n  return variableName;\n}\n\nfunction validateVariableUsage(\n  variableSet,\n  incorrectVariable,\n  correctVariable,\n  vertexOrFragment\n) {\n  if (variableSet.hasOwnProperty(incorrectVariable)) {\n    const message = `${expandCoordinateAbbreviations(\n      incorrectVariable\n    )} is not available in the ${vertexOrFragment} shader. Did you mean ${expandCoordinateAbbreviations(\n      correctVariable\n    )} instead?`;\n    throw new DeveloperError(message);\n  }\n}\n\nfunction validateBuiltinVariables(customShader) {\n  const attributesVS = customShader.usedVariablesVertex.attributeSet;\n\n  // names without MC/WC/EC are ambiguous\n  validateVariableUsage(attributesVS, \"position\", \"positionMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"normal\", \"normalMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"tangent\", \"tangentMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"bitangent\", \"bitangentMC\", \"vertex\");\n\n  // world and eye coordinate positions are only available in the fragment shader.\n  validateVariableUsage(attributesVS, \"positionWC\", \"positionMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"positionEC\", \"positionMC\", \"vertex\");\n\n  // normal, tangent and bitangent are in model coordinates in the vertex shader\n  validateVariableUsage(attributesVS, \"normalEC\", \"normalMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"tangentEC\", \"tangentMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"bitangentEC\", \"bitangentMC\", \"vertex\");\n\n  const attributesFS = customShader.usedVariablesFragment.attributeSet;\n\n  // names without MC/WC/EC are ambiguous\n  validateVariableUsage(attributesFS, \"position\", \"positionEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"normal\", \"normalEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"tangent\", \"tangentEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"bitangent\", \"bitangentEC\", \"fragment\");\n\n  // normal, tangent, and bitangent are in eye coordinates in the fragment\n  // shader.\n  validateVariableUsage(attributesFS, \"normalMC\", \"normalEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"tangentMC\", \"tangentEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"bitangentMC\", \"bitangentEC\", \"fragment\");\n}\n\n/**\n * Update the value of a uniform declared in the shader\n * @param {String} uniformName The GLSL name of the uniform. This must match one of the uniforms declared in the constructor\n * @param {Boolean|Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4|String|Resource} value The new value of the uniform.\n */\nCustomShader.prototype.setUniform = function (uniformName, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"uniformName\", uniformName);\n  Check.defined(\"value\", value);\n  if (!defined(this.uniforms[uniformName])) {\n    throw new DeveloperError(\n      `Uniform ${uniformName} must be declared in the CustomShader constructor.`\n    );\n  }\n  //>>includeEnd('debug');\n  const uniform = this.uniforms[uniformName];\n  if (uniform.type === UniformType.SAMPLER_2D) {\n    // Textures are loaded asynchronously\n    this._textureManager.loadTexture2D(uniformName, value);\n  } else if (defined(value.clone)) {\n    // clone Cartesian and Matrix types.\n    uniform.value = value.clone(uniform.value);\n  } else {\n    uniform.value = value;\n  }\n};\n\nCustomShader.prototype.update = function (frameState) {\n  this._defaultTexture = frameState.context.defaultTexture;\n  this._textureManager.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see CustomShader#destroy\n * @private\n */\nCustomShader.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * customShader = customShader && customShader.destroy();\n *\n * @see CustomShader#isDestroyed\n * @private\n */\nCustomShader.prototype.destroy = function () {\n  this._textureManager = this._textureManager && this._textureManager.destroy();\n  destroyObject(this);\n};\n","/**\n * An enum describing how the {@link CustomShader} will be added to the\n * fragment shader. This determines how the shader interacts with the material.\n *\n * @enum {String}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst CustomShaderMode = {\n  /**\n   * The custom shader will be used to modify the results of the material stage\n   * before lighting is applied.\n   *\n   * @type {String}\n   * @constant\n   */\n  MODIFY_MATERIAL: \"MODIFY_MATERIAL\",\n  /**\n   * The custom shader will be used instead of the material stage. This is a hint\n   * to optimize out the material processing code.\n   *\n   * @type {String}\n   * @constant\n   */\n  REPLACE_MATERIAL: \"REPLACE_MATERIAL\",\n};\n\n/**\n * Convert the shader mode to an uppercase identifier for use in GLSL define\n * directives. For example:  <code>#define CUSTOM_SHADER_MODIFY_MATERIAL</code>\n * @param {CustomShaderMode} customShaderMode The shader mode\n * @return {String} The name of the GLSL macro to use\n *\n * @private\n */\nCustomShaderMode.getDefineName = function (customShaderMode) {\n  return `CUSTOM_SHADER_${customShaderMode}`;\n};\n\nexport default Object.freeze(CustomShaderMode);\n","import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport oneTimeWarning from \"../../Core/oneTimeWarning.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport CustomShaderStageVS from \"../../Shaders/ModelExperimental/CustomShaderStageVS.js\";\nimport CustomShaderStageFS from \"../../Shaders/ModelExperimental/CustomShaderStageFS.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport CustomShaderMode from \"./CustomShaderMode.js\";\nimport FeatureIdPipelineStage from \"./FeatureIdPipelineStage.js\";\nimport MetadataPipelineStage from \"./MetadataPipelineStage.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\n\n/**\n * The custom shader pipeline stage takes GLSL callbacks from the\n * {@link CustomShader} and inserts them into the overall shader code for the\n * {@link ModelExperimental}. The input to the callback is a struct with many\n * properties that depend on the attributes of the primitive. This shader code\n * is automatically generated by this stage.\n *\n * @namespace CustomShaderPipelineStage\n *\n * @private\n */\nconst CustomShaderPipelineStage = {};\nCustomShaderPipelineStage.name = \"CustomShaderPipelineStage\"; // Helps with debugging\n\nCustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_VS = \"AttributesVS\";\nCustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_FS = \"AttributesFS\";\nCustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES = \"Attributes\";\nCustomShaderPipelineStage.STRUCT_ID_VERTEX_INPUT = \"VertexInput\";\nCustomShaderPipelineStage.STRUCT_NAME_VERTEX_INPUT = \"VertexInput\";\nCustomShaderPipelineStage.STRUCT_ID_FRAGMENT_INPUT = \"FragmentInput\";\nCustomShaderPipelineStage.STRUCT_NAME_FRAGMENT_INPUT = \"FragmentInput\";\nCustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS =\n  \"initializeInputStructVS\";\nCustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS =\n  \"void initializeInputStruct(out VertexInput vsInput, ProcessedAttributes attributes)\";\nCustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS =\n  \"initializeInputStructFS\";\nCustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS =\n  \"void initializeInputStruct(out FragmentInput fsInput, ProcessedAttributes attributes)\";\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the custom shader code to the vertex and fragment shaders</li>\n *   <li>Modifies the shader to include automatically-generated structs that serve as input to the custom shader callbacks </li>\n *   <li>Modifies the shader to include any additional user-defined uniforms</li>\n *   <li>Modifies the shader to include any additional user-defined varyings</li>\n *   <li>Adds any user-defined uniforms to the uniform map</li>\n *   <li>If the user specified a lighting model, the settings are overridden in the render resources</li>\n * </ul>\n * <p>\n * This pipeline stage is designed to fail gracefully where possible. If the\n * primitive does not have the right attributes to satisfy the shader code,\n * defaults will be inferred (when reasonable to do so). If not, the custom\n * shader will be disabled.\n * <p>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nCustomShaderPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const customShader = renderResources.model.customShader;\n\n  // Check the lighting model and translucent options first, as sometimes\n  // these are used even if there is no vertex or fragment shader text.\n\n  // if present, the lighting model overrides the material's lighting model.\n  if (defined(customShader.lightingModel)) {\n    renderResources.lightingOptions.lightingModel = customShader.lightingModel;\n  }\n\n  const alphaOptions = renderResources.alphaOptions;\n  if (customShader.isTranslucent) {\n    alphaOptions.pass = Pass.TRANSLUCENT;\n    alphaOptions.alphaMode = AlphaMode.BLEND;\n  } else {\n    // Use the default pass (either OPAQUE or 3D_TILES), regardless of whether\n    // the material pipeline stage used translucent. The default is configured\n    // in AlphaPipelineStage\n    alphaOptions.pass = undefined;\n    alphaOptions.alphaMode = AlphaMode.OPAQUE;\n  }\n\n  // Generate lines of code for the shader, but don't add them to the shader\n  // yet.\n  const generatedCode = generateShaderLines(customShader, primitive);\n\n  // In some corner cases, the primitive may not be compatible with the\n  // shader. In this case, skip the custom shader.\n  if (!generatedCode.customShaderEnabled) {\n    return;\n  }\n  addLinesToShader(shaderBuilder, customShader, generatedCode);\n\n  // the input to the fragment shader may include a low-precision ECEF position\n  if (generatedCode.shouldComputePositionWC) {\n    shaderBuilder.addDefine(\n      \"COMPUTE_POSITION_WC\",\n      undefined,\n      ShaderDestination.BOTH\n    );\n  }\n\n  if (defined(customShader.vertexShaderText)) {\n    shaderBuilder.addDefine(\n      \"HAS_CUSTOM_VERTEX_SHADER\",\n      undefined,\n      ShaderDestination.VERTEX\n    );\n  }\n\n  if (defined(customShader.fragmentShaderText)) {\n    shaderBuilder.addDefine(\n      \"HAS_CUSTOM_FRAGMENT_SHADER\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n\n    // add defines like CUSTOM_SHADER_MODIFY_MATERIAL\n    const shaderModeDefine = CustomShaderMode.getDefineName(customShader.mode);\n    shaderBuilder.addDefine(\n      shaderModeDefine,\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  const uniforms = customShader.uniforms;\n  for (const uniformName in uniforms) {\n    if (uniforms.hasOwnProperty(uniformName)) {\n      const uniform = uniforms[uniformName];\n      shaderBuilder.addUniform(uniform.type, uniformName);\n    }\n  }\n\n  const varyings = customShader.varyings;\n  for (const varyingName in varyings) {\n    if (varyings.hasOwnProperty(varyingName)) {\n      const varyingType = varyings[varyingName];\n      shaderBuilder.addVarying(varyingType, varyingName);\n    }\n  }\n\n  renderResources.uniformMap = combine(\n    renderResources.uniformMap,\n    customShader.uniformMap\n  );\n};\n\nfunction getAttributesByName(attributes) {\n  const names = {};\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    const attributeInfo = ModelExperimentalUtility.getAttributeInfo(attribute);\n\n    names[attributeInfo.variableName] = attributeInfo;\n  }\n  return names;\n}\n\n// GLSL types of standard attribute types when uniquely defined\nconst attributeTypeLUT = {\n  position: \"vec3\",\n  normal: \"vec3\",\n  tangent: \"vec3\",\n  bitangent: \"vec3\",\n  texCoord: \"vec2\",\n  color: \"vec4\",\n  joints: \"ivec4\",\n  weights: \"vec4\",\n};\n\n// Corresponding attribute values\nconst attributeDefaultValueLUT = {\n  position: \"vec3(0.0)\",\n  normal: \"vec3(0.0, 0.0, 1.0)\",\n  tangent: \"vec3(1.0, 0.0, 0.0)\",\n  bitangent: \"vec3(0.0, 1.0, 0.0)\",\n  texCoord: \"vec2(0.0)\",\n  color: \"vec4(1.0)\",\n  joints: \"ivec4(0)\",\n  weights: \"vec4(0.0)\",\n};\n\nfunction inferAttributeDefaults(attributeName) {\n  // remove trailing set indices. E.g. \"texCoord_0\" -> \"texCoord\"\n  let trimmed = attributeName.replace(/_[0-9]+$/, \"\");\n  // also remove the MC/EC since they will have the same default value\n  trimmed = trimmed.replace(/(MC|EC)$/, \"\");\n\n  const glslType = attributeTypeLUT[trimmed];\n  const value = attributeDefaultValueLUT[trimmed];\n\n  // - _CUSTOM_ATTRIBUTE has an unknown type.\n  if (!defined(glslType)) {\n    return undefined;\n  }\n\n  return {\n    attributeField: [glslType, attributeName],\n    value: value,\n  };\n}\n\nfunction generateVertexShaderLines(\n  customShader,\n  attributesByName,\n  vertexLines\n) {\n  const categories = partitionAttributes(\n    attributesByName,\n    customShader.usedVariablesVertex.attributeSet,\n    false\n  );\n  const addToShader = categories.addToShader;\n  const needsDefault = categories.missingAttributes;\n\n  let variableName;\n  let vertexInitialization;\n  const attributeFields = [];\n  const initializationLines = [];\n  for (variableName in addToShader) {\n    if (addToShader.hasOwnProperty(variableName)) {\n      const attributeInfo = addToShader[variableName];\n      const attributeField = [attributeInfo.glslType, variableName];\n      attributeFields.push(attributeField);\n\n      // Initializing attribute structs are just a matter of copying the\n      // attribute or varying: E.g.:\n      // \"    vsInput.attributes.position = a_position;\"\n      vertexInitialization = `vsInput.attributes.${variableName} = attributes.${variableName};`;\n      initializationLines.push(vertexInitialization);\n    }\n  }\n\n  for (let i = 0; i < needsDefault.length; i++) {\n    variableName = needsDefault[i];\n    const attributeDefaults = inferAttributeDefaults(variableName);\n    if (!defined(attributeDefaults)) {\n      CustomShaderPipelineStage._oneTimeWarning(\n        \"CustomShaderPipelineStage.incompatiblePrimitiveVS\",\n        `Primitive is missing attribute ${variableName}, disabling custom vertex shader`\n      );\n      // This primitive isn't compatible with the shader. Return early\n      // to skip the vertex shader\n      return;\n    }\n\n    attributeFields.push(attributeDefaults.attributeField);\n    vertexInitialization = `vsInput.attributes.${variableName} = ${attributeDefaults.value};`;\n    initializationLines.push(vertexInitialization);\n  }\n\n  vertexLines.enabled = true;\n  vertexLines.attributeFields = attributeFields;\n  vertexLines.initializationLines = initializationLines;\n}\n\nfunction generatePositionBuiltins(customShader) {\n  const attributeFields = [];\n  const initializationLines = [];\n  const usedVariables = customShader.usedVariablesFragment.attributeSet;\n\n  // Model space position is the same position as in the glTF accessor,\n  // this is already added to the shader with other attributes.\n\n  // World coordinates in ECEF coordinates. Note that this is\n  // low precision (32-bit floats) on the GPU.\n  if (usedVariables.hasOwnProperty(\"positionWC\")) {\n    attributeFields.push([\"vec3\", \"positionWC\"]);\n    initializationLines.push(\n      \"fsInput.attributes.positionWC = attributes.positionWC;\"\n    );\n  }\n\n  // position in eye coordinates\n  if (usedVariables.hasOwnProperty(\"positionEC\")) {\n    attributeFields.push([\"vec3\", \"positionEC\"]);\n    initializationLines.push(\n      \"fsInput.attributes.positionEC = attributes.positionEC;\"\n    );\n  }\n\n  return {\n    attributeFields: attributeFields,\n    initializationLines: initializationLines,\n  };\n}\n\nfunction generateFragmentShaderLines(\n  customShader,\n  attributesByName,\n  fragmentLines\n) {\n  const categories = partitionAttributes(\n    attributesByName,\n    customShader.usedVariablesFragment.attributeSet,\n    true\n  );\n  const addToShader = categories.addToShader;\n  const needsDefault = categories.missingAttributes;\n\n  let variableName;\n  let fragmentInitialization;\n  const attributeFields = [];\n  const initializationLines = [];\n  for (variableName in addToShader) {\n    if (addToShader.hasOwnProperty(variableName)) {\n      const attributeInfo = addToShader[variableName];\n\n      const attributeField = [attributeInfo.glslType, variableName];\n      attributeFields.push(attributeField);\n\n      // Initializing attribute structs are just a matter of copying the\n      // value from the processed attributes\n      // \"    fsInput.attributes.positionMC = attributes.positionMC;\"\n      fragmentInitialization = `fsInput.attributes.${variableName} = attributes.${variableName};`;\n      initializationLines.push(fragmentInitialization);\n    }\n  }\n\n  for (let i = 0; i < needsDefault.length; i++) {\n    variableName = needsDefault[i];\n    const attributeDefaults = inferAttributeDefaults(variableName);\n    if (!defined(attributeDefaults)) {\n      CustomShaderPipelineStage._oneTimeWarning(\n        \"CustomShaderPipelineStage.incompatiblePrimitiveFS\",\n        `Primitive is missing attribute ${variableName}, disabling custom fragment shader.`\n      );\n\n      // This primitive isn't compatible with the shader. Return early\n      // so the fragment shader is skipped\n      return;\n    }\n\n    attributeFields.push(attributeDefaults.attributeField);\n    fragmentInitialization = `fsInput.attributes.${variableName} = ${attributeDefaults.value};`;\n    initializationLines.push(fragmentInitialization);\n  }\n\n  // Built-ins for positions in various coordinate systems.\n  const positionBuiltins = generatePositionBuiltins(customShader);\n\n  fragmentLines.enabled = true;\n  fragmentLines.attributeFields = attributeFields.concat(\n    positionBuiltins.attributeFields\n  );\n  fragmentLines.initializationLines = positionBuiltins.initializationLines.concat(\n    initializationLines\n  );\n}\n\n// These attributes are derived from positionMC, and are handled separately\n// from other attributes\nconst builtinAttributes = {\n  positionWC: true,\n  positionEC: true,\n};\n\nfunction partitionAttributes(\n  primitiveAttributes,\n  shaderAttributeSet,\n  isFragmentShader\n) {\n  // shaderAttributes = set of all attributes used in the shader\n  // primitiveAttributes = set of all the primitive's attributes\n  // partition into three categories:\n  // - addToShader = shaderAttributes intersect primitiveAttributes\n  // - missingAttributes = shaderAttributes - primitiveAttributes - builtinAttributes\n  // - unneededAttributes = (primitiveAttributes - shaderAttributes) U builtinAttributes\n  //\n  // addToShader are attributes that should be added to the shader.\n  // missingAttributes are attributes for which we need to provide a default value\n  // unneededAttributes are other attributes that can be skipped.\n\n  let renamed;\n  let attributeName;\n  const addToShader = {};\n  for (attributeName in primitiveAttributes) {\n    if (primitiveAttributes.hasOwnProperty(attributeName)) {\n      const attribute = primitiveAttributes[attributeName];\n\n      // normals and tangents are in model coordinates in the attributes but\n      // in eye coordinates in the fragment shader.\n      renamed = attributeName;\n      if (isFragmentShader && attributeName === \"normalMC\") {\n        renamed = \"normalEC\";\n      } else if (isFragmentShader && attributeName === \"tangentMC\") {\n        renamed = \"tangentEC\";\n      }\n\n      if (shaderAttributeSet.hasOwnProperty(renamed)) {\n        addToShader[renamed] = attribute;\n      }\n    }\n  }\n\n  const missingAttributes = [];\n  for (attributeName in shaderAttributeSet) {\n    if (shaderAttributeSet.hasOwnProperty(attributeName)) {\n      if (builtinAttributes.hasOwnProperty(attributeName)) {\n        // Builtins are handled separately from attributes, so skip them here\n        continue;\n      }\n\n      // normals and tangents are in model coordinates in the attributes but\n      // in eye coordinates in the fragment shader.\n      renamed = attributeName;\n      if (isFragmentShader && attributeName === \"normalEC\") {\n        renamed = \"normalMC\";\n      } else if (isFragmentShader && attributeName === \"tangentEC\") {\n        renamed = \"tangentMC\";\n      }\n\n      if (!primitiveAttributes.hasOwnProperty(renamed)) {\n        missingAttributes.push(attributeName);\n      }\n    }\n  }\n\n  return {\n    addToShader: addToShader,\n    missingAttributes: missingAttributes,\n  };\n}\n\nfunction generateShaderLines(customShader, primitive) {\n  // Assume shader code is disabled unless proven otherwise\n  const vertexLines = {\n    enabled: false,\n  };\n  const fragmentLines = {\n    enabled: false,\n  };\n\n  // Attempt to generate vertex and fragment shader lines before adding any\n  // code to the shader.\n  const attributesByName = getAttributesByName(primitive.attributes);\n  if (defined(customShader.vertexShaderText)) {\n    generateVertexShaderLines(customShader, attributesByName, vertexLines);\n  }\n\n  if (defined(customShader.fragmentShaderText)) {\n    generateFragmentShaderLines(customShader, attributesByName, fragmentLines);\n  }\n\n  // positionWC must be computed in the vertex shader\n  // for use in the fragmentShader. However, this can be skipped if:\n  // - positionWC isn't used in the fragment shader\n  // - or the fragment shader is disabled\n  const attributeSetFS = customShader.usedVariablesFragment.attributeSet;\n  const shouldComputePositionWC =\n    attributeSetFS.hasOwnProperty(\"positionWC\") && fragmentLines.enabled;\n\n  // Return any generated shader code along with some flags to indicate which\n  // defines should be added.\n  return {\n    vertexLines: vertexLines,\n    fragmentLines: fragmentLines,\n    vertexLinesEnabled: vertexLines.enabled,\n    fragmentLinesEnabled: fragmentLines.enabled,\n    customShaderEnabled: vertexLines.enabled || fragmentLines.enabled,\n    shouldComputePositionWC: shouldComputePositionWC,\n  };\n}\n\nfunction addVertexLinesToShader(shaderBuilder, vertexLines) {\n  // Vertex Lines ---------------------------------------------------------\n\n  let i;\n  let structId = CustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_VS;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    ShaderDestination.VERTEX\n  );\n\n  const attributeFields = vertexLines.attributeFields;\n  for (i = 0; i < attributeFields.length; i++) {\n    const field = attributeFields[i];\n    const glslType = field[0];\n    const variableName = field[1];\n    shaderBuilder.addStructField(structId, glslType, variableName);\n  }\n\n  // This could be hard-coded, but the symmetry with other structs makes unit\n  // tests more convenient\n  structId = CustomShaderPipelineStage.STRUCT_ID_VERTEX_INPUT;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_VERTEX_INPUT,\n    ShaderDestination.VERTEX\n  );\n  shaderBuilder.addStructField(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    \"attributes\"\n  );\n  // Add FeatureIds struct from the Feature ID stage\n  shaderBuilder.addStructField(\n    structId,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    \"featureIds\"\n  );\n  // Add Metadata struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    \"metadata\"\n  );\n\n  const functionId =\n    CustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS;\n  shaderBuilder.addFunction(\n    functionId,\n    CustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS,\n    ShaderDestination.VERTEX\n  );\n\n  const initializationLines = vertexLines.initializationLines;\n  shaderBuilder.addFunctionLines(functionId, initializationLines);\n}\n\nfunction addFragmentLinesToShader(shaderBuilder, fragmentLines) {\n  let i;\n  let structId = CustomShaderPipelineStage.STRUCT_ID_ATTRIBUTES_FS;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    ShaderDestination.FRAGMENT\n  );\n\n  let field;\n  let glslType;\n  let variableName;\n  const attributeFields = fragmentLines.attributeFields;\n  for (i = 0; i < attributeFields.length; i++) {\n    field = attributeFields[i];\n    glslType = field[0];\n    variableName = field[1];\n    shaderBuilder.addStructField(structId, glslType, variableName);\n  }\n\n  structId = CustomShaderPipelineStage.STRUCT_ID_FRAGMENT_INPUT;\n  shaderBuilder.addStruct(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_FRAGMENT_INPUT,\n    ShaderDestination.FRAGMENT\n  );\n  shaderBuilder.addStructField(\n    structId,\n    CustomShaderPipelineStage.STRUCT_NAME_ATTRIBUTES,\n    \"attributes\"\n  );\n  // Add FeatureIds struct from the Feature ID stage\n  shaderBuilder.addStructField(\n    structId,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    \"featureIds\"\n  );\n  // Add Metadata struct from the metadata stage\n  shaderBuilder.addStructField(\n    structId,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    \"metadata\"\n  );\n\n  const functionId =\n    CustomShaderPipelineStage.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS;\n  shaderBuilder.addFunction(\n    functionId,\n    CustomShaderPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS,\n    ShaderDestination.FRAGMENT\n  );\n\n  const initializationLines = fragmentLines.initializationLines;\n  shaderBuilder.addFunctionLines(functionId, initializationLines);\n}\n\nfunction addLinesToShader(shaderBuilder, customShader, generatedCode) {\n  const vertexLines = generatedCode.vertexLines;\n  if (vertexLines.enabled) {\n    addVertexLinesToShader(shaderBuilder, vertexLines);\n\n    shaderBuilder.addVertexLines([\n      \"#line 0\",\n      customShader.vertexShaderText,\n      CustomShaderStageVS,\n    ]);\n  }\n\n  const fragmentLines = generatedCode.fragmentLines;\n  if (fragmentLines.enabled) {\n    addFragmentLinesToShader(shaderBuilder, fragmentLines);\n\n    shaderBuilder.addFragmentLines([\n      \"#line 0\",\n      customShader.fragmentShaderText,\n      CustomShaderStageFS,\n    ]);\n  }\n}\n\n// exposed for testing.\nCustomShaderPipelineStage._oneTimeWarning = oneTimeWarning;\n\nexport default CustomShaderPipelineStage;\n","import defined from \"../../Core/defined.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\n\n/**\n * The dequantization stage generates shader code to dequantize attributes\n * in the vertex shader\n *\n * @namespace DequantizationPipelineStage\n *\n * @private\n */\nconst DequantizationPipelineStage = {};\nDequantizationPipelineStage.name = \"DequantizationPipelineStage\"; // Helps with debugging\n\nDequantizationPipelineStage.FUNCTION_ID_DEQUANTIZATION_STAGE_VS =\n  \"dequantizationStage\";\nDequantizationPipelineStage.FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS =\n  \"void dequantizationStage(inout ProcessedAttributes attributes)\";\n\n/**\n * Process a primitive with quantized attributes. This stage modifies the\n * following parts of the render resources:\n * <ul>\n *  <li>generates dequantization function and adds it to the shader</li>\n *  <li>adds any uniforms needed for dequantization to the shader and uniform map</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nDequantizationPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addFunction(\n    DequantizationPipelineStage.FUNCTION_ID_DEQUANTIZATION_STAGE_VS,\n    DequantizationPipelineStage.FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS,\n    ShaderDestination.VERTEX\n  );\n\n  shaderBuilder.addDefine(\n    \"USE_DEQUANTIZATION\",\n    undefined,\n    ShaderDestination.VERTEX\n  );\n\n  const attributes = primitive.attributes;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    const quantization = attribute.quantization;\n    if (!defined(quantization)) {\n      // Non-quantized attributes were already handled in GeometryPipelineStage\n      continue;\n    }\n\n    const attributeInfo = ModelExperimentalUtility.getAttributeInfo(attribute);\n    updateDequantizationFunction(shaderBuilder, attributeInfo);\n    addDequantizationUniforms(renderResources, attributeInfo);\n  }\n};\n\nfunction addDequantizationUniforms(renderResources, attributeInfo) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const uniformMap = renderResources.uniformMap;\n  const variableName = attributeInfo.variableName;\n  const quantization = attributeInfo.attribute.quantization;\n\n  if (quantization.octEncoded) {\n    const normalizationRange = `model_normalizationRange_${variableName}`;\n    shaderBuilder.addUniform(\n      \"float\",\n      normalizationRange,\n      ShaderDestination.VERTEX\n    );\n    uniformMap[normalizationRange] = function () {\n      return quantization.normalizationRange;\n    };\n  } else {\n    const offset = `model_quantizedVolumeOffset_${variableName}`;\n    const stepSize = `model_quantizedVolumeStepSize_${variableName}`;\n    const glslType = attributeInfo.glslType;\n    shaderBuilder.addUniform(glslType, offset, ShaderDestination.VERTEX);\n    shaderBuilder.addUniform(glslType, stepSize, ShaderDestination.VERTEX);\n\n    let quantizedVolumeOffset = quantization.quantizedVolumeOffset;\n    let quantizedVolumeStepSize = quantization.quantizedVolumeStepSize;\n\n    // COLOR_n is promoted to a vec4 in the shader, so the alpha value\n    // defaults to 1. For correctness, the quantization uniforms must be\n    // promoted to vec4s. The alpha values are chosen so the alpha\n    // dequantization is the identity, i.e. 0.0 + 1.0 * color.a\n    if (/^color_\\d+$/.test(variableName)) {\n      quantizedVolumeOffset = promoteToVec4(quantizedVolumeOffset, 0);\n      quantizedVolumeStepSize = promoteToVec4(quantizedVolumeStepSize, 1);\n    }\n\n    uniformMap[offset] = function () {\n      return quantizedVolumeOffset;\n    };\n\n    uniformMap[stepSize] = function () {\n      return quantizedVolumeStepSize;\n    };\n  }\n}\n\nfunction promoteToVec4(value, defaultAlpha) {\n  if (value instanceof Cartesian4) {\n    return value;\n  }\n\n  return new Cartesian4(value.x, value.y, value.z, defaultAlpha);\n}\n\nfunction updateDequantizationFunction(shaderBuilder, attributeInfo) {\n  const variableName = attributeInfo.variableName;\n  const quantization = attributeInfo.attribute.quantization;\n\n  let line;\n  if (quantization.octEncoded) {\n    line = generateOctDecodeLine(variableName, quantization);\n  } else {\n    line = generateDequantizeLine(variableName);\n  }\n\n  shaderBuilder.addFunctionLines(\n    DequantizationPipelineStage.FUNCTION_ID_DEQUANTIZATION_STAGE_VS,\n    [line]\n  );\n}\n\nfunction generateOctDecodeLine(variableName, quantization) {\n  const structField = `attributes.${variableName}`;\n\n  const quantizedAttribute = `a_quantized_${variableName}`;\n  const normalizationRange = `model_normalizationRange_${variableName}`;\n\n  // Draco stores things as .zxy instead of xyz, so be explicit about the\n  // swizzle to avoid confusion\n  const swizzle = quantization.octEncodedZXY ? \".zxy\" : \".xyz\";\n\n  // This generates lines such as:\n  // attributes.normal = czm_octDecode(a_quantized_normal, model_normalizationRange_normal).zxy;\n  return `${structField} = czm_octDecode(${quantizedAttribute}, ${normalizationRange})${swizzle};`;\n}\n\nfunction generateDequantizeLine(variableName) {\n  const structField = `attributes.${variableName}`;\n  const quantizedAttribute = `a_quantized_${variableName}`;\n  const offset = `model_quantizedVolumeOffset_${variableName}`;\n  const stepSize = `model_quantizedVolumeStepSize_${variableName}`;\n\n  // This generates lines such as:\n  // attributes.texCoord_0 = model_quantizedVolumeOffset_texCoord_0 + a_quantized_texCoord_0 * model_quantizedVolumeStepSize;\n  return `${structField} = ${offset} + ${quantizedAttribute} * ${stepSize};`;\n}\n\nexport default DequantizationPipelineStage;\n","import ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport FeatureIdStageFS from \"../../Shaders/ModelExperimental/FeatureIdStageFS.js\";\nimport FeatureIdStageVS from \"../../Shaders/ModelExperimental/FeatureIdStageVS.js\";\n\n/**\n * The feature ID pipeline stage is responsible for processing feature IDs\n * (both attributes and textures), updating the shader in preparation for\n * custom shaders, picking, and/or styling.\n *\n * @namespace FeatureIdPipelineStage\n * @private\n */\nconst FeatureIdPipelineStage = {};\nFeatureIdPipelineStage.name = \"FeatureIdPipelineStage\"; // Helps with debugging\n\nFeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS = \"FeatureIdsVS\";\nFeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS = \"FeatureIdsFS\";\nFeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS = \"FeatureIds\";\nFeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS =\n  \"initializeFeatureIdsVS\";\nFeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS =\n  \"initializeFeatureIdsFS\";\nFeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS =\n  \"initializeFeatureIdAliasesVS\";\nFeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS =\n  \"initializeFeatureIdAliasesFS\";\nFeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS =\n  \"void initializeFeatureIds(out FeatureIds featureIds, ProcessedAttributes attributes)\";\nFeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES =\n  \"void initializeFeatureIdAliases(inout FeatureIds featureIds)\";\nFeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS =\n  \"setFeatureIdVaryings\";\nFeatureIdPipelineStage.FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS =\n  \"void setFeatureIdVaryings()\";\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>Adds the FeatureIds struct and corresponding initialization functions in the vertex and fragment shader</li>\n *  <li>For each feature ID attribute, the attributes were already uploaded in the geometry stage, so just update the shader code </li>\n *  <li>For each feature ID implicit range, a new attribute is created and uploaded to the GPU since gl_VertexID is not available in WebGL 1. The shader is updated with an attribute, varying, and initialization code.</li>\n *  <li>For each feature ID texture, the texture is added to the uniform map, and shader code is added to perform the texture read.</li>\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nFeatureIdPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  declareStructsAndFunctions(shaderBuilder);\n\n  const instances = renderResources.runtimeNode.node.instances;\n  if (defined(instances)) {\n    processInstanceFeatureIds(renderResources, instances, frameState);\n  }\n  processPrimitiveFeatureIds(renderResources, primitive, frameState);\n\n  shaderBuilder.addVertexLines([FeatureIdStageVS]);\n  shaderBuilder.addFragmentLines([FeatureIdStageFS]);\n};\n\nfunction declareStructsAndFunctions(shaderBuilder) {\n  // Declare the FeatureIds struct. The vertex shader will only use\n  // feature ID attributes, while the fragment shader will also use\n  // feature ID textures.\n  shaderBuilder.addStruct(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    ShaderDestination.VERTEX\n  );\n  shaderBuilder.addStruct(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    FeatureIdPipelineStage.STRUCT_NAME_FEATURE_IDS,\n    ShaderDestination.FRAGMENT\n  );\n\n  // declare the initializeFeatureIds() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS,\n    ShaderDestination.VERTEX\n  );\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS,\n    ShaderDestination.FRAGMENT\n  );\n\n  // declare the initializeFeatureIdAliases() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES,\n    ShaderDestination.VERTEX\n  );\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES,\n    ShaderDestination.FRAGMENT\n  );\n\n  // declare the setFeatureIdVaryings() function in the vertex shader only\n  shaderBuilder.addFunction(\n    FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS,\n    FeatureIdPipelineStage.FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS,\n    ShaderDestination.VERTEX\n  );\n}\n\nfunction processInstanceFeatureIds(renderResources, instances, frameState) {\n  const featureIdsArray = instances.featureIds;\n  const count = instances.attributes[0].count;\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const variableName = featureIds.positionalLabel;\n\n    if (featureIds instanceof ModelComponents.FeatureIdAttribute) {\n      processInstanceAttribute(renderResources, featureIds, variableName);\n    } else {\n      const instanceDivisor = 1;\n      processImplicitRange(\n        renderResources,\n        featureIds,\n        variableName,\n        count,\n        instanceDivisor,\n        frameState\n      );\n    }\n\n    const label = featureIds.label;\n    if (defined(label)) {\n      addAlias(renderResources, variableName, label, ShaderDestination.BOTH);\n    }\n  }\n}\n\nfunction processPrimitiveFeatureIds(renderResources, primitive, frameState) {\n  const featureIdsArray = primitive.featureIds;\n  const positionAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.POSITION\n  );\n  const count = positionAttribute.count;\n\n  for (let i = 0; i < featureIdsArray.length; i++) {\n    const featureIds = featureIdsArray[i];\n    const variableName = featureIds.positionalLabel;\n\n    let aliasDestination = ShaderDestination.BOTH;\n    if (featureIds instanceof ModelComponents.FeatureIdAttribute) {\n      processAttribute(renderResources, featureIds, variableName);\n    } else if (featureIds instanceof ModelComponents.FeatureIdImplicitRange) {\n      processImplicitRange(\n        renderResources,\n        featureIds,\n        variableName,\n        count,\n        undefined,\n        frameState\n      );\n    } else {\n      processTexture(renderResources, featureIds, variableName, i, frameState);\n      aliasDestination = ShaderDestination.FRAGMENT;\n    }\n\n    const label = featureIds.label;\n    if (defined(label)) {\n      addAlias(renderResources, variableName, label, aliasDestination);\n    }\n  }\n}\n\nfunction processInstanceAttribute(\n  renderResources,\n  featureIdAttribute,\n  variableName\n) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int instanceFeatureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    \"int\",\n    variableName\n  );\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName\n  );\n\n  // Initialize the field from the corresponding attribute.\n  // Example: featureIds.instanceFeatureId_n = int(czm_round(attributes.instanceFeatureId_0));\n  const setIndex = featureIdAttribute.setIndex;\n  const prefix = variableName.replace(/_\\d+$/, \"_\");\n\n  const attributeName = `a_${prefix}${setIndex}`;\n  const varyingName = `v_${prefix}${setIndex}`;\n  const vertexLine = `featureIds.${variableName} = int(czm_round(${attributeName}));`;\n  const fragmentLine = `featureIds.${variableName} = int(czm_round(${varyingName}));`;\n\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    [vertexLine]\n  );\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    [fragmentLine]\n  );\n\n  // Instanced attributes don't normally need varyings, so add one here\n  shaderBuilder.addVarying(\"float\", varyingName);\n\n  // The varying needs initialization in the vertex shader\n  // Example:\n  // v_instanceFeatureId_n = a_instanceFeatureId_n;\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS,\n    [`${varyingName} = ${attributeName};`]\n  );\n}\n\nfunction processAttribute(renderResources, featureIdAttribute, variableName) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    \"int\",\n    variableName\n  );\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName\n  );\n\n  // Initialize the field from the corresponding attribute.\n  // Example: featureIds.featureId_n = attributes.featureId_0;\n  // Since this uses the ProcessedAttributes struct, the line is the same\n  // for both vertex and fragment shader.\n  const setIndex = featureIdAttribute.setIndex;\n  const prefix = variableName.replace(/_\\d+$/, \"_\");\n\n  const initializationLines = [\n    `featureIds.${variableName} = int(czm_round(attributes.${prefix}${setIndex}));`,\n  ];\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    initializationLines\n  );\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    initializationLines\n  );\n}\n\nfunction processImplicitRange(\n  renderResources,\n  implicitFeatureIds,\n  variableName,\n  count,\n  instanceDivisor,\n  frameState\n) {\n  // Generate a vertex attribute for the implicit IDs since WebGL 1 does not\n  // support gl_VertexID\n  generateImplicitFeatureIdAttribute(\n    renderResources,\n    implicitFeatureIds,\n    count,\n    instanceDivisor,\n    frameState\n  );\n\n  // Declare the vertex attribute in the shader\n  // Example: attribute float a_implicit_feature_id_n;\n  const shaderBuilder = renderResources.shaderBuilder;\n  const implicitAttributeName = `a_implicit_${variableName}`;\n  shaderBuilder.addAttribute(\"float\", implicitAttributeName);\n\n  // Also declare the corresponding varyings\n  // Example: varying float v_implicit_feature_id_n;\n  const implicitVaryingName = `v_implicit_${variableName}`;\n  shaderBuilder.addVarying(\"float\", implicitVaryingName);\n\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n    \"int\",\n    variableName\n  );\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName\n  );\n\n  // The varying needs initialization in the vertex shader\n  // Example:\n  // v_implicit_featureId_n = a_implicit_featureId_n;\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_SET_FEATURE_ID_VARYINGS,\n    [`${implicitVaryingName} = ${implicitAttributeName};`]\n  );\n\n  // Initialize the field from the generated attribute/varying.\n  // Example:\n  // featureIds.featureId_n = a_implicit_featureId_n; (VS)\n  // featureIds.featureId_n = v_implicit_featureId_n; (FS)\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS,\n    [`featureIds.${variableName} = int(czm_round(${implicitAttributeName}));`]\n  );\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    [`featureIds.${variableName} = int(czm_round(${implicitVaryingName}));`]\n  );\n}\n\nfunction processTexture(\n  renderResources,\n  featureIdTexture,\n  variableName,\n  index,\n  frameState\n) {\n  // Create the feature ID texture uniform. The index matches the index from\n  // the featureIds array, even if this is not consecutive.\n  const uniformName = `u_featureIdTexture_${index}`;\n  const uniformMap = renderResources.uniformMap;\n  const textureReader = featureIdTexture.textureReader;\n  uniformMap[uniformName] = function () {\n    return defaultValue(\n      textureReader.texture,\n      frameState.context.defaultTexture\n    );\n  };\n\n  const channels = textureReader.channels;\n\n  // Add a field to the FeatureIds struct in the fragment shader only\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int featureId_n;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    variableName\n  );\n\n  // Declare the uniform in the fragment shader\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    uniformName,\n    ShaderDestination.FRAGMENT\n  );\n\n  // Read one or more channels from the texture\n  // example: texture2D(u_featureIdTexture_0, v_texCoord_1).rg\n  const texCoord = `v_texCoord_${textureReader.texCoord}`;\n  const textureRead = `texture2D(${uniformName}, ${texCoord}).${channels}`;\n\n  // Finally, assign to the struct field. Example:\n  // featureIds.featureId_0 = unpacked;\n  const initializationLine = `featureIds.${variableName} = czm_unpackUint(${textureRead});`;\n\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS,\n    [initializationLine]\n  );\n}\n\nfunction addAlias(renderResources, variableName, alias, shaderDestination) {\n  // Add a field to the FeatureIds struct.\n  // Example:\n  // struct FeatureIds {\n  //   ...\n  //   int alias;\n  //   ...\n  // }\n  const shaderBuilder = renderResources.shaderBuilder;\n  const updateVS = ShaderDestination.includesVertexShader(shaderDestination);\n  if (updateVS) {\n    shaderBuilder.addStructField(\n      FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_VS,\n      \"int\",\n      alias\n    );\n  }\n  shaderBuilder.addStructField(\n    FeatureIdPipelineStage.STRUCT_ID_FEATURE_IDS_FS,\n    \"int\",\n    alias\n  );\n\n  // Initialize the field from the original variable\n  // Example: featureIds.alias = featureIds.featureId_n;\n  const initializationLines = [\n    `featureIds.${alias} = featureIds.${variableName};`,\n  ];\n  if (updateVS) {\n    shaderBuilder.addFunctionLines(\n      FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS,\n      initializationLines\n    );\n  }\n  shaderBuilder.addFunctionLines(\n    FeatureIdPipelineStage.FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS,\n    initializationLines\n  );\n}\n\nfunction generateImplicitFeatureIdAttribute(\n  renderResources,\n  implicitFeatureIds,\n  count,\n  instanceDivisor,\n  frameState\n) {\n  const model = renderResources.model;\n  let vertexBuffer;\n  let value;\n  if (defined(implicitFeatureIds.repeat)) {\n    const typedArray = generateImplicitFeatureIdTypedArray(\n      implicitFeatureIds,\n      count\n    );\n    vertexBuffer = Buffer.createVertexBuffer({\n      context: frameState.context,\n      typedArray: typedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    vertexBuffer.vertexArrayDestroyable = false;\n    model._resources.push(vertexBuffer);\n  } else {\n    value = [implicitFeatureIds.offset];\n  }\n\n  const generatedFeatureIdAttribute = {\n    index: renderResources.attributeIndex++,\n    instanceDivisor: instanceDivisor,\n    value: value,\n    vertexBuffer: vertexBuffer,\n    normalize: false,\n    componentsPerAttribute: 1,\n    componentDatatype: ComponentDatatype.FLOAT,\n    strideInBytes: ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT),\n    offsetInBytes: 0,\n  };\n\n  renderResources.attributes.push(generatedFeatureIdAttribute);\n}\n\n/**\n * Generates a typed array for implicit feature IDs\n * @private\n */\nfunction generateImplicitFeatureIdTypedArray(implicitFeatureIds, count) {\n  const offset = implicitFeatureIds.offset;\n  const repeat = implicitFeatureIds.repeat;\n\n  const typedArray = new Float32Array(count);\n  for (let i = 0; i < count; i++) {\n    typedArray[i] = offset + Math.floor(i / repeat);\n  }\n\n  return typedArray;\n}\n\nexport default FeatureIdPipelineStage;\n","import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport IndexDatatype from \"../../Core/IndexDatatype.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport JsonMetadataTable from \"../JsonMetadataTable.js\";\nimport MetadataSchema from \"../MetadataSchema.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\n\n/**\n * Loads a GeoJson model as part of the <code>MAXAR_content_geojson</code> extension with the following constraints:\n * <ul>\n *   <li>The top level GeoJSON type must be FeatureCollection or Feature.</li>\n *   <li>The geometry types must be LineString, MultiLineString, MultiPolygon, or Polygon.</li>\n *   <li>All geometries are converted to geodesic lines.</li>\n *   <li>Only WGS84 geographic coordinates are supported.</li>\n * </ul>\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias GeoJsonLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {Object} options.geoJson The GeoJson object.\n */\nexport default function GeoJsonLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.geoJson\", options.geoJson);\n  //>>includeEnd('debug');\n\n  this._geoJson = options.geoJson;\n  this._promise = undefined;\n  this._process = function (loader, frameState) {};\n  this._components = undefined;\n}\n\nif (defined(Object.create)) {\n  GeoJsonLoader.prototype = Object.create(ResourceLoader.prototype);\n  GeoJsonLoader.prototype.constructor = GeoJsonLoader;\n}\n\nObject.defineProperties(GeoJsonLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource has not yet started loading.\n   *\n   * @memberof GeoJsonLoader.prototype\n   *\n   * @type {Promise.<GeoJsonLoader>|Undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource.\n   *\n   * @memberof GeoJsonLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The loaded components.\n   *\n   * @memberof GeoJsonLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<GeoJsonLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nGeoJsonLoader.prototype.load = function () {\n  const loader = this;\n  const promise = new Promise(function (resolve) {\n    loader._process = function (loader, frameState) {\n      if (defined(loader._components)) {\n        return;\n      }\n\n      loader._components = parse(loader._geoJson, frameState);\n      loader._geoJson = undefined;\n      resolve(loader);\n    };\n  });\n\n  this._promise = promise;\n  return promise;\n};\n\n/**\n * Processes the resource until it becomes ready.\n *\n * @param {FrameState} frameState The frame state.\n * @private\n */\nGeoJsonLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  this._process(this, frameState);\n};\n\nfunction ParsedFeature() {\n  this.lines = undefined;\n  this.properties = undefined;\n}\n\nfunction ParseResult() {\n  this.features = [];\n}\n\nfunction parsePosition(position) {\n  const x = position[0];\n  const y = position[1];\n  const z = defaultValue(position[2], 0.0);\n  return new Cartesian3(x, y, z);\n}\n\nfunction parseLineString(coordinates) {\n  const positionsLength = coordinates.length;\n  const line = new Array(positionsLength);\n  for (let i = 0; i < positionsLength; i++) {\n    line[i] = parsePosition(coordinates[i]);\n  }\n  const lines = [line];\n  return lines;\n}\n\nfunction parseMultiLineString(coordinates) {\n  const linesLength = coordinates.length;\n  const lines = new Array(linesLength);\n  for (let i = 0; i < linesLength; i++) {\n    lines[i] = parseLineString(coordinates[i])[0];\n  }\n  return lines;\n}\n\nfunction parsePolygon(coordinates) {\n  // Treat exterior polygon and interior polygons as lines\n  const linesLength = coordinates.length;\n  const lines = new Array(linesLength);\n  for (let i = 0; i < linesLength; i++) {\n    lines[i] = parseLineString(coordinates[i])[0];\n  }\n  return lines;\n}\n\nfunction parseMultiPolygon(coordinates) {\n  const polygonsLength = coordinates.length;\n  const lines = [];\n  for (let i = 0; i < polygonsLength; i++) {\n    Array.prototype.push.apply(lines, parsePolygon(coordinates[i]));\n  }\n  return lines;\n}\n\nconst geometryTypes = {\n  LineString: parseLineString,\n  MultiLineString: parseMultiLineString,\n  MultiPolygon: parseMultiPolygon,\n  Polygon: parsePolygon,\n};\n\nfunction parseFeature(feature, result) {\n  if (!defined(feature.geometry)) {\n    return;\n  }\n\n  const geometryType = feature.geometry.type;\n  const geometryFunction = geometryTypes[geometryType];\n  const coordinates = feature.geometry.coordinates;\n\n  if (!defined(geometryFunction)) {\n    return;\n  }\n\n  if (!defined(coordinates)) {\n    return;\n  }\n\n  const parsedFeature = new ParsedFeature();\n  parsedFeature.lines = geometryFunction(coordinates);\n  parsedFeature.properties = feature.properties;\n\n  result.features.push(parsedFeature);\n}\n\nfunction parseFeatureCollection(featureCollection, result) {\n  const features = featureCollection.features;\n  const featuresLength = features.length;\n  for (let i = 0; i < featuresLength; i++) {\n    parseFeature(features[i], result);\n  }\n}\n\nconst geoJsonObjectTypes = {\n  FeatureCollection: parseFeatureCollection,\n  Feature: parseFeature,\n};\n\nconst scratchCartesian = new Cartesian3();\n\nfunction parse(geoJson, frameState) {\n  const result = new ParseResult();\n\n  // Parse the GeoJSON\n  const parseFunction = geoJsonObjectTypes[geoJson.type];\n  if (defined(parseFunction)) {\n    parseFunction(geoJson, result);\n  }\n\n  const featureCount = result.features.length;\n\n  if (featureCount === 0) {\n    throw new RuntimeError(\"GeoJSON must have at least one feature\");\n  }\n\n  // Allocate space for property values\n  const properties = {};\n  for (let i = 0; i < featureCount; i++) {\n    const feature = result.features[i];\n    const featureProperties = defaultValue(\n      feature.properties,\n      defaultValue.EMPTY_OBJECT\n    );\n    for (const propertyId in featureProperties) {\n      if (featureProperties.hasOwnProperty(propertyId)) {\n        if (!defined(properties[propertyId])) {\n          properties[propertyId] = new Array(featureCount);\n        }\n      }\n    }\n  }\n\n  // Fill in the property values. Default to empty string for undefined values.\n  for (let i = 0; i < featureCount; i++) {\n    const feature = result.features[i];\n    for (const propertyId in properties) {\n      if (properties.hasOwnProperty(propertyId)) {\n        const value = defaultValue(feature.properties[propertyId], \"\");\n        properties[propertyId][i] = value;\n      }\n    }\n  }\n\n  const jsonMetadataTable = new JsonMetadataTable({\n    count: featureCount,\n    properties: properties,\n  });\n\n  const propertyTable = new PropertyTable({\n    id: 0,\n    count: featureCount,\n    jsonMetadataTable: jsonMetadataTable,\n  });\n  const propertyTables = [propertyTable];\n\n  const schema = new MetadataSchema({});\n\n  const structuralMetadata = new StructuralMetadata({\n    schema: schema,\n    propertyTables: propertyTables,\n  });\n\n  // Find the cartographic bounding box\n  const cartographicMin = new Cartesian3(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY\n  );\n\n  const cartographicMax = new Cartesian3(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY\n  );\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = result.features[i];\n    const linesLength = feature.lines.length;\n    for (let j = 0; j < linesLength; j++) {\n      const line = feature.lines[j];\n      const positionsLength = line.length;\n      for (let k = 0; k < positionsLength; k++) {\n        Cartesian3.minimumByComponent(\n          cartographicMin,\n          line[k],\n          cartographicMin\n        );\n        Cartesian3.maximumByComponent(\n          cartographicMax,\n          line[k],\n          cartographicMax\n        );\n      }\n    }\n  }\n\n  // Compute the ENU matrix\n  const cartographicCenter = Cartesian3.midpoint(\n    cartographicMin,\n    cartographicMax,\n    new Cartesian3()\n  );\n  const ecefCenter = Cartesian3.fromDegrees(\n    cartographicCenter.x,\n    cartographicCenter.y,\n    cartographicCenter.z,\n    Ellipsoid.WGS84,\n    new Cartesian3()\n  );\n  const toGlobal = Transforms.eastNorthUpToFixedFrame(\n    ecefCenter,\n    Ellipsoid.WGS84,\n    new Matrix4()\n  );\n  const toLocal = Matrix4.inverseTransformation(toGlobal, new Matrix4());\n\n  // Count the number of vertices and indices\n  let vertexCount = 0;\n  let indexCount = 0;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = result.features[i];\n    const linesLength = feature.lines.length;\n    for (let j = 0; j < linesLength; j++) {\n      const line = feature.lines[j];\n      vertexCount += line.length;\n      indexCount += (line.length - 1) * 2;\n    }\n  }\n\n  // Allocate typed arrays\n  const positionsTypedArray = new Float32Array(vertexCount * 3);\n  const featureIdsTypedArray = new Float32Array(vertexCount);\n  const indicesTypedArray = IndexDatatype.createTypedArray(\n    vertexCount,\n    indexCount\n  );\n  const indexDatatype = IndexDatatype.fromTypedArray(indicesTypedArray);\n\n  // Process the data. Convert positions to local ENU. Generate indices.\n  const localMin = new Cartesian3(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY\n  );\n\n  const localMax = new Cartesian3(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY\n  );\n\n  let vertexCounter = 0;\n  let segmentCounter = 0;\n\n  for (let i = 0; i < featureCount; i++) {\n    const feature = result.features[i];\n    const linesLength = feature.lines.length;\n    for (let j = 0; j < linesLength; j++) {\n      const line = feature.lines[j];\n      const positionsLength = line.length;\n      for (let k = 0; k < positionsLength; k++) {\n        const cartographic = line[k];\n        const globalCartesian = Cartesian3.fromDegrees(\n          cartographic.x,\n          cartographic.y,\n          cartographic.z,\n          Ellipsoid.WGS84,\n          scratchCartesian\n        );\n        const localCartesian = Matrix4.multiplyByPoint(\n          toLocal,\n          globalCartesian,\n          scratchCartesian\n        );\n\n        Cartesian3.minimumByComponent(localMin, localCartesian, localMin);\n        Cartesian3.maximumByComponent(localMax, localCartesian, localMax);\n\n        Cartesian3.pack(localCartesian, positionsTypedArray, vertexCounter * 3);\n\n        featureIdsTypedArray[vertexCounter] = i;\n\n        if (k < positionsLength - 1) {\n          indicesTypedArray[segmentCounter * 2] = vertexCounter;\n          indicesTypedArray[segmentCounter * 2 + 1] = vertexCounter + 1;\n          segmentCounter++;\n        }\n\n        vertexCounter++;\n      }\n    }\n  }\n\n  // Create GPU buffers\n  const positionBuffer = Buffer.createVertexBuffer({\n    typedArray: positionsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  positionBuffer.vertexArrayDestroyable = false;\n\n  const featureIdBuffer = Buffer.createVertexBuffer({\n    typedArray: featureIdsTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  featureIdBuffer.vertexArrayDestroyable = false;\n\n  const indexBuffer = Buffer.createIndexBuffer({\n    typedArray: indicesTypedArray,\n    context: frameState.context,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: indexDatatype,\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n\n  // Create ModelComponents\n  const positionAttribute = new ModelComponents.Attribute();\n  positionAttribute.semantic = VertexAttributeSemantic.POSITION;\n  positionAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  positionAttribute.type = AttributeType.VEC3;\n  positionAttribute.count = vertexCount;\n  positionAttribute.min = localMin;\n  positionAttribute.max = localMax;\n  positionAttribute.buffer = positionBuffer;\n\n  const featureIdAttribute = new ModelComponents.Attribute();\n  featureIdAttribute.semantic = VertexAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = vertexCount;\n  featureIdAttribute.buffer = featureIdBuffer;\n\n  const attributes = [positionAttribute, featureIdAttribute];\n\n  const material = new ModelComponents.Material();\n  material.unlit = true;\n\n  const indices = new ModelComponents.Indices();\n  indices.indexDatatype = indexDatatype;\n  indices.count = indicesTypedArray.length;\n  indices.buffer = indexBuffer;\n\n  const featureId = new ModelComponents.FeatureIdAttribute();\n  featureId.featureCount = featureCount;\n  featureId.propertyTableId = 0;\n  featureId.setIndex = 0;\n  featureId.positionalLabel = \"featureId_0\";\n\n  const featureIds = [featureId];\n\n  const primitive = new ModelComponents.Primitive();\n  primitive.attributes = attributes;\n  primitive.indices = indices;\n  primitive.featureIds = featureIds;\n  primitive.primitiveType = PrimitiveType.LINES;\n  primitive.material = material;\n\n  const primitives = [primitive];\n\n  const node = new ModelComponents.Node();\n  node.index = 0;\n  node.primitives = primitives;\n\n  const nodes = [node];\n\n  const scene = new ModelComponents.Scene();\n  scene.nodes = nodes;\n\n  const components = new ModelComponents.Components();\n  components.scene = scene;\n  components.nodes = nodes;\n  components.transform = toGlobal;\n  components.structuralMetadata = structuralMetadata;\n\n  return components;\n}\n\n/**\n * Unloads the resource.\n * @private\n */\nGeoJsonLoader.prototype.unload = function () {\n  this._components = undefined;\n};\n","import AttributeType from \"../AttributeType.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport GeometryStageFS from \"../../Shaders/ModelExperimental/GeometryStageFS.js\";\nimport GeometryStageVS from \"../../Shaders/ModelExperimental/GeometryStageVS.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport ModelExperimentalType from \"./ModelExperimentalType.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SelectedFeatureIdPipelineStage from \"./SelectedFeatureIdPipelineStage.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The geometry pipeline stage processes the vertex attributes of a primitive.\n *\n * @namespace GeometryPipelineStage\n *\n * @private\n */\nconst GeometryPipelineStage = {};\nGeometryPipelineStage.name = \"GeometryPipelineStage\"; // Helps with debugging\n\nGeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS =\n  \"ProcessedAttributesVS\";\nGeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS =\n  \"ProcessedAttributesFS\";\nGeometryPipelineStage.STRUCT_NAME_PROCESSED_ATTRIBUTES = \"ProcessedAttributes\";\nGeometryPipelineStage.FUNCTION_ID_INITIALIZE_ATTRIBUTES =\n  \"initializeAttributes\";\nGeometryPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES =\n  \"void initializeAttributes(out ProcessedAttributes attributes)\";\nGeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS =\n  \"setDynamicVaryingsVS\";\nGeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS =\n  \"setDynamicVaryingsFS\";\nGeometryPipelineStage.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS =\n  \"void setDynamicVaryings(inout ProcessedAttributes attributes)\";\n\n/**\n * This pipeline stage processes the vertex attributes of a primitive, adding the attribute declarations to the shaders,\n * the attribute objects to the render resources and setting the flags as needed.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds attribute and varying declarations for the vertex attributes in the vertex and fragment shaders\n *  <li> creates the objects required to create VertexArrays\n *  <li> sets the flag for point primitive types\n * </ul>\n *\n * If the scene is in either 2D or CV mode, this stage also:\n * <ul>\n *  <li> adds an attribute for the 2D positions\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nGeometryPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  // These structs are similar, though the fragment shader version has a couple\n  // additional fields.\n  shaderBuilder.addStruct(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS,\n    \"ProcessedAttributes\",\n    ShaderDestination.VERTEX\n  );\n  shaderBuilder.addStruct(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"ProcessedAttributes\",\n    ShaderDestination.FRAGMENT\n  );\n\n  // The Feature struct is always added since it's required for compilation. It may be unused if features are not present.\n  shaderBuilder.addStruct(\n    SelectedFeatureIdPipelineStage.STRUCT_ID_SELECTED_FEATURE,\n    SelectedFeatureIdPipelineStage.STRUCT_NAME_SELECTED_FEATURE,\n    ShaderDestination.BOTH\n  );\n\n  // This initialization function is only needed in the vertex shader,\n  // it assigns the non-quantized attribute struct fields from the\n  // physical attributes\n  shaderBuilder.addFunction(\n    GeometryPipelineStage.FUNCTION_ID_INITIALIZE_ATTRIBUTES,\n    GeometryPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES,\n    ShaderDestination.VERTEX\n  );\n\n  // Positions in other coordinate systems need more variables\n  shaderBuilder.addVarying(\"vec3\", \"v_positionWC\");\n  shaderBuilder.addVarying(\"vec3\", \"v_positionEC\");\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"vec3\",\n    \"positionWC\"\n  );\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"vec3\",\n    \"positionEC\"\n  );\n\n  // Though they have identical signatures, the implementation is different\n  // between vertex and fragment shaders. The VS stores attributes in\n  // varyings, while the FS unpacks the varyings for use by other stages.\n  shaderBuilder.addFunction(\n    GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS,\n    GeometryPipelineStage.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS,\n    ShaderDestination.VERTEX\n  );\n  shaderBuilder.addFunction(\n    GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS,\n    GeometryPipelineStage.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS,\n    ShaderDestination.FRAGMENT\n  );\n\n  // .pnts point clouds store sRGB color rather than linear color\n  const model = renderResources.model;\n  const modelType = model.type;\n  if (modelType === ModelExperimentalType.TILE_PNTS) {\n    shaderBuilder.addDefine(\n      \"HAS_SRGB_COLOR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  // The attributes, structs, and functions will need to be modified for 2D / CV.\n  const use2D =\n    frameState.mode !== SceneMode.SCENE3D &&\n    !frameState.scene3DOnly &&\n    model._projectTo2D;\n\n  for (let i = 0; i < primitive.attributes.length; i++) {\n    const attribute = primitive.attributes[i];\n    const attributeLocationCount = AttributeType.getAttributeLocationCount(\n      attribute.type\n    );\n    const isPositionAttribute =\n      attribute.semantic === VertexAttributeSemantic.POSITION;\n\n    let index;\n    if (attributeLocationCount > 1) {\n      index = renderResources.attributeIndex;\n      renderResources.attributeIndex += attributeLocationCount;\n    } else if (isPositionAttribute && !use2D) {\n      // If the scene is in 3D, the 2D position attribute is not needed,\n      // so don't increment attributeIndex.\n      index = 0;\n    } else {\n      index = renderResources.attributeIndex++;\n    }\n\n    processAttribute(\n      renderResources,\n      attribute,\n      index,\n      attributeLocationCount,\n      use2D\n    );\n  }\n\n  handleBitangents(shaderBuilder, primitive.attributes);\n\n  if (primitive.primitiveType === PrimitiveType.POINTS) {\n    shaderBuilder.addDefine(\"PRIMITIVE_TYPE_POINTS\");\n  }\n\n  shaderBuilder.addVertexLines([GeometryStageVS]);\n  shaderBuilder.addFragmentLines([GeometryStageFS]);\n};\n\nfunction processAttribute(\n  renderResources,\n  attribute,\n  attributeIndex,\n  attributeLocationCount,\n  use2D\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  const attributeInfo = ModelExperimentalUtility.getAttributeInfo(attribute);\n\n  if (attributeLocationCount > 1) {\n    // Matrices are stored as multiple attributes, one per column vector.\n    addMatrixAttributeToRenderResources(\n      renderResources,\n      attribute,\n      attributeIndex,\n      attributeLocationCount\n    );\n  } else {\n    addAttributeToRenderResources(\n      renderResources,\n      attribute,\n      attributeIndex,\n      use2D\n    );\n  }\n\n  addAttributeDeclaration(shaderBuilder, attributeInfo, use2D);\n  addVaryingDeclaration(shaderBuilder, attributeInfo);\n\n  // For common attributes like normals and tangents, the code is\n  // already in GeometryStageVS, we just need to enable it.\n  if (defined(attribute.semantic)) {\n    addSemanticDefine(shaderBuilder, attribute);\n  }\n\n  // Some GLSL code must be dynamically generated\n  updateAttributesStruct(shaderBuilder, attributeInfo, use2D);\n  updateInitializeAttributesFunction(shaderBuilder, attributeInfo, use2D);\n  updateSetDynamicVaryingsFunction(shaderBuilder, attributeInfo);\n}\n\nfunction addSemanticDefine(shaderBuilder, attribute) {\n  const semantic = attribute.semantic;\n  const setIndex = attribute.setIndex;\n  switch (semantic) {\n    case VertexAttributeSemantic.NORMAL:\n      shaderBuilder.addDefine(\"HAS_NORMALS\");\n      break;\n    case VertexAttributeSemantic.TANGENT:\n      shaderBuilder.addDefine(\"HAS_TANGENTS\");\n      break;\n    case VertexAttributeSemantic.FEATURE_ID:\n      // `_FEATURE_ID starts with an underscore so no need to double the\n      // underscore.\n      shaderBuilder.addDefine(`HAS${semantic}_${setIndex}`);\n      break;\n    case VertexAttributeSemantic.TEXCOORD:\n    case VertexAttributeSemantic.COLOR:\n      shaderBuilder.addDefine(`HAS_${semantic}_${setIndex}`);\n  }\n}\n\nfunction addAttributeToRenderResources(\n  renderResources,\n  attribute,\n  attributeIndex,\n  use2D\n) {\n  const quantization = attribute.quantization;\n  let type;\n  let componentDatatype;\n  if (defined(quantization)) {\n    type = quantization.type;\n    componentDatatype = quantization.componentDatatype;\n  } else {\n    type = attribute.type;\n    componentDatatype = attribute.componentDatatype;\n  }\n\n  const semantic = attribute.semantic;\n  const setIndex = attribute.setIndex;\n  if (\n    semantic === VertexAttributeSemantic.FEATURE_ID &&\n    setIndex >= renderResources.featureIdVertexAttributeSetIndex\n  ) {\n    renderResources.featureIdVertexAttributeSetIndex = setIndex + 1;\n  }\n\n  // The position attribute should always be in the first index.\n  const isPositionAttribute = semantic === VertexAttributeSemantic.POSITION;\n  const index = isPositionAttribute ? 0 : attributeIndex;\n  const componentsPerAttribute = AttributeType.getNumberOfComponents(type);\n\n  const vertexAttribute = {\n    index: index,\n    value: defined(attribute.buffer) ? undefined : attribute.constant,\n    vertexBuffer: attribute.buffer,\n    count: attribute.count,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: componentDatatype,\n    offsetInBytes: attribute.byteOffset,\n    strideInBytes: attribute.byteStride,\n    normalize: attribute.normalized,\n  };\n\n  renderResources.attributes.push(vertexAttribute);\n\n  if (!isPositionAttribute || !use2D) {\n    return;\n  }\n\n  // Add an additional attribute for the projected positions in 2D / CV.\n  const buffer2D = renderResources.runtimePrimitive.positionBuffer2D;\n  const positionAttribute2D = {\n    index: attributeIndex,\n    vertexBuffer: buffer2D,\n    count: attribute.count,\n    componentsPerAttribute: componentsPerAttribute,\n    componentDatatype: ComponentDatatype.FLOAT, // Projected positions will always be floats.\n    offsetInBytes: attribute.byteOffset,\n    strideInBytes: attribute.byteStride,\n    normalize: attribute.normalized,\n  };\n\n  renderResources.attributes.push(positionAttribute2D);\n}\n\nfunction addMatrixAttributeToRenderResources(\n  renderResources,\n  attribute,\n  attributeIndex,\n  columnCount\n) {\n  const quantization = attribute.quantization;\n  let type;\n  let componentDatatype;\n  if (defined(quantization)) {\n    type = quantization.type;\n    componentDatatype = quantization.componentDatatype;\n  } else {\n    type = attribute.type;\n    componentDatatype = attribute.componentDatatype;\n  }\n\n  const normalized = attribute.normalized;\n\n  // componentCount is either 4, 9 or 16\n  const componentCount = AttributeType.getNumberOfComponents(type);\n  // componentsPerColumn is either 2, 3, or 4\n  const componentsPerColumn = componentCount / columnCount;\n\n  const componentSizeInBytes = ComponentDatatype.getSizeInBytes(\n    componentDatatype\n  );\n\n  const columnLengthInBytes = componentsPerColumn * componentSizeInBytes;\n\n  // The stride between corresponding columns of two matrices is constant\n  // regardless of where you start\n  const strideInBytes = attribute.byteStride;\n\n  for (let i = 0; i < columnCount; i++) {\n    const offsetInBytes = attribute.byteOffset + i * columnLengthInBytes;\n\n    // upload a single column vector.\n    const columnAttribute = {\n      index: attributeIndex + i,\n      vertexBuffer: attribute.buffer,\n      componentsPerAttribute: componentsPerColumn,\n      componentDatatype: componentDatatype,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes,\n      normalize: normalized,\n    };\n\n    renderResources.attributes.push(columnAttribute);\n  }\n}\n\nfunction addVaryingDeclaration(shaderBuilder, attributeInfo) {\n  const variableName = attributeInfo.variableName;\n  let varyingName = `v_${variableName}`;\n\n  let glslType;\n  if (variableName === \"normalMC\") {\n    // though the attribute is in model coordinates, the varying is\n    // in eye coordinates.\n    varyingName = \"v_normalEC\";\n    glslType = attributeInfo.glslType;\n  } else if (variableName === \"tangentMC\") {\n    // Tangent's glslType is vec4, but in the shader it is split into\n    // vec3 tangent and vec3 bitangent\n    glslType = \"vec3\";\n    // like normalMC, the varying is converted to eye coordinates\n    varyingName = \"v_tangentEC\";\n  } else {\n    glslType = attributeInfo.glslType;\n  }\n\n  shaderBuilder.addVarying(glslType, varyingName);\n}\n\nfunction addAttributeDeclaration(shaderBuilder, attributeInfo, use2D) {\n  const semantic = attributeInfo.attribute.semantic;\n  const variableName = attributeInfo.variableName;\n\n  let attributeName;\n  let glslType;\n  if (attributeInfo.isQuantized) {\n    attributeName = `a_quantized_${variableName}`;\n    glslType = attributeInfo.quantizedGlslType;\n  } else {\n    attributeName = `a_${variableName}`;\n    glslType = attributeInfo.glslType;\n  }\n\n  const isPosition = semantic === VertexAttributeSemantic.POSITION;\n  if (isPosition) {\n    shaderBuilder.setPositionAttribute(glslType, attributeName);\n  } else {\n    shaderBuilder.addAttribute(glslType, attributeName);\n  }\n\n  if (isPosition && use2D) {\n    shaderBuilder.addAttribute(\"vec3\", \"a_position2D\");\n  }\n}\n\nfunction updateAttributesStruct(shaderBuilder, attributeInfo, use2D) {\n  const vsStructId = GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS;\n  const fsStructId = GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS;\n  const variableName = attributeInfo.variableName;\n\n  if (variableName === \"tangentMC\") {\n    // The w component of the tangent is only used for computing the bitangent,\n    // so it can be separated from the other tangent components.\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"tangentMC\");\n    shaderBuilder.addStructField(vsStructId, \"float\", \"tangentSignMC\");\n    // The tangent is in model coordinates in the vertex shader\n    // but in eye space in the fragment coordinates\n    shaderBuilder.addStructField(fsStructId, \"vec3\", \"tangentEC\");\n  } else if (variableName === \"normalMC\") {\n    // Normals are in model coordinates in the vertex shader but in eye\n    // coordinates in the fragment shader\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"normalMC\");\n    shaderBuilder.addStructField(fsStructId, \"vec3\", \"normalEC\");\n  } else {\n    shaderBuilder.addStructField(\n      vsStructId,\n      attributeInfo.glslType,\n      variableName\n    );\n    shaderBuilder.addStructField(\n      fsStructId,\n      attributeInfo.glslType,\n      variableName\n    );\n  }\n\n  if (variableName === \"positionMC\" && use2D) {\n    shaderBuilder.addStructField(vsStructId, \"vec3\", \"position2D\");\n  }\n}\n\nfunction updateInitializeAttributesFunction(\n  shaderBuilder,\n  attributeInfo,\n  use2D\n) {\n  const functionId = GeometryPipelineStage.FUNCTION_ID_INITIALIZE_ATTRIBUTES;\n  const variableName = attributeInfo.variableName;\n\n  // If the scene is in 2D / CV mode, this line should always be added\n  // regardless of whether the data is quantized.\n  const use2DPosition = variableName === \"positionMC\" && use2D;\n  if (use2DPosition) {\n    const line = \"attributes.position2D = a_position2D;\";\n    shaderBuilder.addFunctionLines(functionId, [line]);\n  }\n\n  if (attributeInfo.isQuantized) {\n    // Skip initialization, it will be handled in the dequantization stage.\n    return;\n  }\n\n  const lines = [];\n  if (variableName === \"tangentMC\") {\n    lines.push(\"attributes.tangentMC = a_tangentMC.xyz;\");\n    lines.push(\"attributes.tangentSignMC = a_tangentMC.w;\");\n  } else {\n    lines.push(`attributes.${variableName} = a_${variableName};`);\n  }\n\n  shaderBuilder.addFunctionLines(functionId, lines);\n}\n\nfunction updateSetDynamicVaryingsFunction(shaderBuilder, attributeInfo) {\n  const semantic = attributeInfo.attribute.semantic;\n  const setIndex = attributeInfo.attribute.setIndex;\n  if (defined(semantic) && !defined(setIndex)) {\n    // positions, normals, and tangents are handled statically in\n    // GeometryStageVS\n    return;\n  }\n\n  // In the vertex shader, we want things like\n  // v_texCoord_1 = attributes.texCoord_1;\n  let functionId = GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS;\n  const variableName = attributeInfo.variableName;\n  let line = `v_${variableName} = attributes.${variableName};`;\n  shaderBuilder.addFunctionLines(functionId, [line]);\n\n  // In the fragment shader, we do the opposite:\n  // attributes.texCoord_1 = v_texCoord_1;\n  functionId = GeometryPipelineStage.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS;\n  line = `attributes.${variableName} = v_${variableName};`;\n  shaderBuilder.addFunctionLines(functionId, [line]);\n}\n\nfunction handleBitangents(shaderBuilder, attributes) {\n  let hasNormals = false;\n  let hasTangents = false;\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.semantic === VertexAttributeSemantic.NORMAL) {\n      hasNormals = true;\n    } else if (attribute.semantic === VertexAttributeSemantic.TANGENT) {\n      hasTangents = true;\n    }\n  }\n\n  // Bitangents are only defined if we have normals and tangents\n  if (!hasNormals || !hasTangents) {\n    return;\n  }\n\n  shaderBuilder.addDefine(\"HAS_BITANGENTS\");\n\n  shaderBuilder.addVarying(\"vec3\", \"v_bitangentEC\");\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_VS,\n    \"vec3\",\n    \"bitangentMC\"\n  );\n  shaderBuilder.addStructField(\n    GeometryPipelineStage.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\n    \"vec3\",\n    \"bitangentEC\"\n  );\n}\n\nexport default GeometryPipelineStage;\n","import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport Axis from \"../Axis.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cesium3DTileFeatureTable from \"../Cesium3DTileFeatureTable.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Ellipsoid from \"../../Core/Ellipsoid.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport getStringFromTypedArray from \"../../Core/getStringFromTypedArray.js\";\nimport GltfLoader from \"../GltfLoader.js\";\nimport I3dmParser from \"../I3dmParser.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport MetadataClass from \"../MetadataClass.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Transforms from \"../../Core/Transforms.js\";\nimport InstanceAttributeSemantic from \"../InstanceAttributeSemantic.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\n\nconst I3dmLoaderState = {\n  UNLOADED: 0,\n  LOADING: 1,\n  PROCESSING: 2,\n  READY: 3,\n  FAILED: 4,\n};\n\nconst Attribute = ModelComponents.Attribute;\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\nconst Instances = ModelComponents.Instances;\n\n/**\n * Loads an Instanced 3D Model.\n * <p>\n * Implements the {@link ResourceLoader} interface.\n * </p>\n *\n * @alias I3dmLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.i3dmResource The {@link Resource} containing the i3dm.\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the i3dm contents.\n * @param {Number} [options.byteOffset=0] The byte offset to the beginning of the i3dm contents in the array buffer.\n * @param {Resource} [options.baseResource] The {@link Resource} that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {Boolean} [options.asynchronous=true] Determines if WebGL resource creation will be spread out over several frames or block until all WebGL resources are created.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the glTF is loaded.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.X] The forward-axis of the glTF model.\n * @param {Boolean} [options.loadAttributesAsTypedArray=false] Load all attributes as typed arrays instead of GPU buffers.\n * @param {Boolean} [options.loadIndicesForWireframe=false] Load the index buffer as a typed array so wireframe indices can be created for WebGL1.\n */\nfunction I3dmLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const i3dmResource = options.i3dmResource;\n  const arrayBuffer = options.arrayBuffer;\n  let baseResource = options.baseResource;\n  const byteOffset = defaultValue(options.byteOffset, 0);\n  const releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n  const asynchronous = defaultValue(options.asynchronous, true);\n  const incrementallyLoadTextures = defaultValue(\n    options.incrementallyLoadTextures,\n    true\n  );\n  const upAxis = defaultValue(options.upAxis, Axis.Y);\n  const forwardAxis = defaultValue(options.forwardAxis, Axis.X);\n  const loadAttributesAsTypedArray = defaultValue(\n    options.loadAttributesAsTypedArray,\n    false\n  );\n  const loadIndicesForWireframe = defaultValue(\n    options.loadIndicesForWireframe,\n    false\n  );\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.i3dmResource\", i3dmResource);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  baseResource = defined(baseResource) ? baseResource : i3dmResource.clone();\n\n  this._i3dmResource = i3dmResource;\n  this._baseResource = baseResource;\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n  this._releaseGltfJson = releaseGltfJson;\n  this._asynchronous = asynchronous;\n  this._incrementallyLoadTextures = incrementallyLoadTextures;\n  this._upAxis = upAxis;\n  this._forwardAxis = forwardAxis;\n  this._loadAttributesAsTypedArray = loadAttributesAsTypedArray;\n  this._loadIndicesForWireframe = loadIndicesForWireframe;\n\n  this._state = I3dmLoaderState.UNLOADED;\n  this._promise = undefined;\n\n  this._gltfLoader = undefined;\n\n  this._transform = Matrix4.IDENTITY;\n  this._batchTable = undefined;\n  this._featureTable = undefined;\n  this._instancesLength = 0;\n}\n\nif (defined(Object.create)) {\n  I3dmLoader.prototype = Object.create(ResourceLoader.prototype);\n  I3dmLoader.prototype.constructor = I3dmLoader;\n}\n\nObject.defineProperties(I3dmLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {Promise.<I3dmLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n\n  /**\n   * A promise that resolves when all textures are loaded.\n   * When <code>incrementallyLoadTextures</code> is true this may resolve after\n   * <code>promise</code> resolves.\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {Promise}\n   * @readonly\n   * @private\n   */\n  texturesLoadedPromise: {\n    get: function () {\n      return this._gltfLoader.texturesLoadedPromise;\n    },\n  },\n  /**\n   * The cache key of the resource\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * The loaded components.\n   *\n   * @memberof I3dmLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @default {@link Matrix4.IDENTITY}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<I3dmLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nI3dmLoader.prototype.load = function () {\n  // Parse the i3dm into its various sections.\n  const i3dm = I3dmParser.parse(this._arrayBuffer, this._byteOffset);\n\n  const featureTableJson = i3dm.featureTableJson;\n  const featureTableBinary = i3dm.featureTableBinary;\n  const batchTableJson = i3dm.batchTableJson;\n  const batchTableBinary = i3dm.batchTableBinary;\n  const gltfFormat = i3dm.gltfFormat;\n\n  // Generate the feature table.\n  const featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary\n  );\n  this._featureTable = featureTable;\n\n  // Get the number of instances in the i3dm.\n  const instancesLength = featureTable.getGlobalProperty(\"INSTANCES_LENGTH\");\n  featureTable.featuresLength = instancesLength;\n  if (!defined(instancesLength)) {\n    throw new RuntimeError(\n      \"Feature table global property: INSTANCES_LENGTH must be defined\"\n    );\n  }\n  this._instancesLength = instancesLength;\n\n  // Get the RTC center, if available, and set the loader's transform.\n  const rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n  if (defined(rtcCenter)) {\n    this._transform = Matrix4.fromTranslation(Cartesian3.fromArray(rtcCenter));\n  }\n\n  // Save the batch table section to use for StructuralMetadata generation.\n  this._batchTable = {\n    json: batchTableJson,\n    binary: batchTableBinary,\n  };\n\n  const loaderOptions = {\n    upAxis: this._upAxis,\n    forwardAxis: this._forwardAxis,\n    releaseGltfJson: this._releaseGltfJson,\n    incrementallyLoadTextures: this._incrementallyLoadTextures,\n    loadAttributesAsTypedArray: this._loadAttributesAsTypedArray,\n    loadIndicesForWireframe: this._loadIndicesForWireframe,\n  };\n\n  if (gltfFormat === 0) {\n    let gltfUrl = getStringFromTypedArray(i3dm.gltf);\n\n    // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n    // This removes all white space and null characters from the end of the string.\n    gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, \"\");\n    const gltfResource = this._baseResource.getDerivedResource({\n      url: gltfUrl,\n    });\n    loaderOptions.gltfResource = gltfResource;\n    loaderOptions.baseResource = gltfResource;\n  } else {\n    loaderOptions.gltfResource = this._i3dmResource;\n    loaderOptions.typedArray = i3dm.gltf;\n  }\n\n  // Create the GltfLoader, update the state and load the glTF.\n  const gltfLoader = new GltfLoader(loaderOptions);\n\n  this._gltfLoader = gltfLoader;\n  this._state = I3dmLoaderState.LOADING;\n\n  const that = this;\n  gltfLoader.load();\n  this._promise = gltfLoader.promise\n    .then(function () {\n      if (that.isDestroyed()) {\n        return;\n      }\n\n      const components = gltfLoader.components;\n      components.transform = that._transform;\n      createInstances(that, components);\n      createStructuralMetadata(that, components);\n      that._components = components;\n\n      that._state = I3dmLoaderState.READY;\n      return that;\n    })\n    .catch(function (error) {\n      if (that.isDestroyed()) {\n        return;\n      }\n      return handleError(that, error);\n    });\n\n  return this._promise;\n};\n\nfunction handleError(i3dmLoader, error) {\n  i3dmLoader.unload();\n  i3dmLoader._state = I3dmLoaderState.FAILED;\n  const errorMessage = \"Failed to load i3dm\";\n  error = i3dmLoader.getError(errorMessage, error);\n  return Promise.reject(error);\n}\n\nI3dmLoader.prototype.process = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"frameState\", frameState);\n  //>>includeEnd('debug');\n\n  if (this._state === I3dmLoaderState.LOADING) {\n    this._state = I3dmLoaderState.PROCESSING;\n  }\n\n  if (this._state === I3dmLoaderState.PROCESSING) {\n    this._gltfLoader.process(frameState);\n  }\n};\n\nfunction createStructuralMetadata(loader, components) {\n  const batchTable = loader._batchTable;\n  const instancesLength = loader._instancesLength;\n\n  if (instancesLength === 0) {\n    return;\n  }\n\n  let structuralMetadata;\n  if (defined(batchTable.json)) {\n    // Add the structural metadata from the batch table to the model components.\n    structuralMetadata = parseBatchTable({\n      count: instancesLength,\n      batchTable: batchTable.json,\n      binaryBody: batchTable.binary,\n    });\n  } else {\n    // If batch table is not defined, create a property table without any properties.\n    const emptyPropertyTable = new PropertyTable({\n      name: MetadataClass.BATCH_TABLE_CLASS_NAME,\n      count: instancesLength,\n    });\n    structuralMetadata = new StructuralMetadata({\n      schema: {},\n      propertyTables: [emptyPropertyTable],\n    });\n  }\n\n  components.structuralMetadata = structuralMetadata;\n}\n\nconst positionScratch = new Cartesian3();\nconst propertyScratch1 = new Array(4);\nfunction createInstances(loader, components) {\n  let i;\n  const featureTable = loader._featureTable;\n  const instancesLength = loader._instancesLength;\n\n  if (instancesLength === 0) {\n    return;\n  }\n\n  const rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n\n  const eastNorthUp = featureTable.getGlobalProperty(\"EAST_NORTH_UP\");\n  const hasRotation =\n    featureTable.hasProperty(\"NORMAL_UP\") ||\n    featureTable.hasProperty(\"NORMAL_UP_OCT32P\") ||\n    eastNorthUp;\n\n  const hasScale =\n    featureTable.hasProperty(\"SCALE\") ||\n    featureTable.hasProperty(\"SCALE_NON_UNIFORM\");\n\n  const translationTypedArray = getPositions(featureTable, instancesLength);\n  let rotationTypedArray;\n  if (hasRotation) {\n    rotationTypedArray = new Float32Array(4 * instancesLength);\n  }\n  let scaleTypedArray;\n  if (hasScale) {\n    scaleTypedArray = new Float32Array(3 * instancesLength);\n  }\n  const featureIdArray = new Float32Array(instancesLength);\n\n  const instancePositions = Cartesian3.unpackArray(translationTypedArray);\n  let instancePosition = new Cartesian3();\n\n  const instanceNormalRight = new Cartesian3();\n  const instanceNormalUp = new Cartesian3();\n  const instanceNormalForward = new Cartesian3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceQuaternionArray = new Array(4);\n\n  const instanceScale = new Cartesian3();\n  const instanceScaleArray = new Array(3);\n\n  const instanceTransform = new Matrix4();\n\n  // For I3DMs that do not define an RTC center, we manually compute a BoundingSphere and store\n  // positions relative to the center, to be uploaded to the GPU. This avoids jittering at higher\n  // precisions.\n  if (!defined(rtcCenter)) {\n    const positionBoundingSphere = BoundingSphere.fromPoints(instancePositions);\n\n    for (i = 0; i < instancePositions.length; i++) {\n      Cartesian3.subtract(\n        instancePositions[i],\n        positionBoundingSphere.center,\n        positionScratch\n      );\n\n      translationTypedArray[3 * i + 0] = positionScratch.x;\n      translationTypedArray[3 * i + 1] = positionScratch.y;\n      translationTypedArray[3 * i + 2] = positionScratch.z;\n    }\n\n    // Set the center of the bounding sphere as the RTC center transform.\n    components.transform = Matrix4.fromTranslation(\n      positionBoundingSphere.center\n    );\n  }\n\n  for (i = 0; i < instancesLength; i++) {\n    // Get the instance position\n    instancePosition = Cartesian3.clone(instancePositions[i]);\n\n    if (defined(rtcCenter)) {\n      Cartesian3.add(\n        instancePosition,\n        Cartesian3.unpack(rtcCenter),\n        instancePosition\n      );\n    }\n\n    // Get the instance rotation, if present\n    if (hasRotation) {\n      processRotation(\n        featureTable,\n        eastNorthUp,\n        i,\n        instanceQuaternion,\n        instancePosition,\n        instanceNormalUp,\n        instanceNormalRight,\n        instanceNormalForward,\n        instanceRotation,\n        instanceTransform\n      );\n      Quaternion.pack(instanceQuaternion, instanceQuaternionArray, 0);\n      rotationTypedArray[4 * i + 0] = instanceQuaternionArray[0];\n      rotationTypedArray[4 * i + 1] = instanceQuaternionArray[1];\n      rotationTypedArray[4 * i + 2] = instanceQuaternionArray[2];\n      rotationTypedArray[4 * i + 3] = instanceQuaternionArray[3];\n    }\n\n    // Get the instance scale, if present\n    if (hasScale) {\n      processScale(featureTable, i, instanceScale);\n      Cartesian3.pack(instanceScale, instanceScaleArray, 0);\n      scaleTypedArray[3 * i + 0] = instanceScaleArray[0];\n      scaleTypedArray[3 * i + 1] = instanceScaleArray[1];\n      scaleTypedArray[3 * i + 2] = instanceScaleArray[2];\n    }\n\n    // Get the batchId\n    let batchId = featureTable.getProperty(\n      \"BATCH_ID\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      1,\n      i\n    );\n    if (!defined(batchId)) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n    featureIdArray[i] = batchId;\n  }\n\n  // Create instances.\n  const instances = new Instances();\n  instances.transformInWorldSpace = true;\n\n  // Create translation vertex attribute.\n  const translationAttribute = new Attribute();\n  translationAttribute.name = \"Instance Translation\";\n  translationAttribute.semantic = InstanceAttributeSemantic.TRANSLATION;\n  translationAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  translationAttribute.type = AttributeType.VEC3;\n  translationAttribute.count = instancesLength;\n  translationAttribute.packedTypedArray = translationTypedArray;\n  instances.attributes.push(translationAttribute);\n\n  // Create rotation vertex attribute.\n  if (hasRotation) {\n    const rotationAttribute = new Attribute();\n    rotationAttribute.name = \"Instance Rotation\";\n    rotationAttribute.semantic = InstanceAttributeSemantic.ROTATION;\n    rotationAttribute.componentDatatype = ComponentDatatype.FLOAT;\n    rotationAttribute.type = AttributeType.VEC4;\n    rotationAttribute.count = instancesLength;\n    rotationAttribute.packedTypedArray = rotationTypedArray;\n    instances.attributes.push(rotationAttribute);\n  }\n\n  // Create scale vertex attribute.\n  if (hasScale) {\n    const scaleAttribute = new Attribute();\n    scaleAttribute.name = \"Instance Scale\";\n    scaleAttribute.semantic = InstanceAttributeSemantic.SCALE;\n    scaleAttribute.componentDatatype = ComponentDatatype.FLOAT;\n    scaleAttribute.type = AttributeType.VEC3;\n    scaleAttribute.count = instancesLength;\n    scaleAttribute.packedTypedArray = scaleTypedArray;\n    instances.attributes.push(scaleAttribute);\n  }\n\n  // Create feature ID vertex attribute.\n  const featureIdAttribute = new Attribute();\n  featureIdAttribute.name = \"Instance Feature ID\";\n  featureIdAttribute.setIndex = 0;\n  featureIdAttribute.semantic = InstanceAttributeSemantic.FEATURE_ID;\n  featureIdAttribute.componentDatatype = ComponentDatatype.FLOAT;\n  featureIdAttribute.type = AttributeType.SCALAR;\n  featureIdAttribute.count = instancesLength;\n  featureIdAttribute.packedTypedArray = featureIdArray;\n  instances.attributes.push(featureIdAttribute);\n\n  // Create feature ID attribute.\n  const featureIdInstanceAttribute = new FeatureIdAttribute();\n  featureIdInstanceAttribute.propertyTableId = 0;\n  featureIdInstanceAttribute.setIndex = 0;\n  featureIdInstanceAttribute.positionalLabel = \"instanceFeatureId_0\";\n  instances.featureIds.push(featureIdInstanceAttribute);\n\n  // Apply instancing to every node that has at least one primitive.\n  for (i = 0; i < components.nodes.length; i++) {\n    const node = components.nodes[i];\n    if (node.primitives.length > 0) {\n      node.instances = instances;\n    }\n  }\n}\n\n/**\n * Returns a typed array of positions from the i3dm's feature table. The positions\n * returned are dequantized, if dequantization is applied.\n *\n * @private\n */\nfunction getPositions(featureTable, instancesLength) {\n  if (featureTable.hasProperty(\"POSITION\")) {\n    // Handle positions.\n    return featureTable.getPropertyArray(\n      \"POSITION\",\n      ComponentDatatype.FLOAT,\n      3\n    );\n  } else if (featureTable.hasProperty(\"POSITION_QUANTIZED\")) {\n    // Handle quantized positions.\n    const quantizedPositions = featureTable.getPropertyArray(\n      \"POSITION_QUANTIZED\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      3\n    );\n\n    const quantizedVolumeOffset = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_OFFSET\",\n      ComponentDatatype.FLOAT,\n      3\n    );\n    if (!defined(quantizedVolumeOffset)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\"\n      );\n    }\n\n    const quantizedVolumeScale = featureTable.getGlobalProperty(\n      \"QUANTIZED_VOLUME_SCALE\",\n      ComponentDatatype.FLOAT,\n      3\n    );\n    if (!defined(quantizedVolumeScale)) {\n      throw new RuntimeError(\n        \"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\"\n      );\n    }\n\n    for (let i = 0; i < quantizedPositions.length / 3; i++) {\n      const quantizedPosition = quantizedPositions[i];\n      for (let j = 0; j < 3; j++) {\n        quantizedPositions[3 * i + j] =\n          (quantizedPosition[j] / 65535.0) * quantizedVolumeScale[j] +\n          quantizedVolumeOffset[j];\n      }\n    }\n\n    return quantizedPositions;\n\n    // eslint-disable-next-line no-else-return\n  } else {\n    throw new RuntimeError(\n      \"Either POSITION or POSITION_QUANTIZED must be defined for each instance.\"\n    );\n  }\n}\n\nconst propertyScratch2 = new Array(4);\nfunction processRotation(\n  featureTable,\n  eastNorthUp,\n  i,\n  instanceQuaternion,\n  instancePosition,\n  instanceNormalUp,\n  instanceNormalRight,\n  instanceNormalForward,\n  instanceRotation,\n  instanceTransform\n) {\n  // Get the instance rotation\n  const normalUp = featureTable.getProperty(\n    \"NORMAL_UP\",\n    ComponentDatatype.FLOAT,\n    3,\n    i,\n    propertyScratch1\n  );\n  const normalRight = featureTable.getProperty(\n    \"NORMAL_RIGHT\",\n    ComponentDatatype.FLOAT,\n    3,\n    i,\n    propertyScratch2\n  );\n  let hasCustomOrientation = false;\n  if (defined(normalUp)) {\n    if (!defined(normalRight)) {\n      throw new RuntimeError(\n        \"To define a custom orientation, both NORMAL_UP and NORMAL_RIGHT must be defined.\"\n      );\n    }\n    Cartesian3.unpack(normalUp, 0, instanceNormalUp);\n    Cartesian3.unpack(normalRight, 0, instanceNormalRight);\n    hasCustomOrientation = true;\n  } else {\n    const octNormalUp = featureTable.getProperty(\n      \"NORMAL_UP_OCT32P\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      2,\n      i,\n      propertyScratch1\n    );\n    const octNormalRight = featureTable.getProperty(\n      \"NORMAL_RIGHT_OCT32P\",\n      ComponentDatatype.UNSIGNED_SHORT,\n      2,\n      i,\n      propertyScratch2\n    );\n    if (defined(octNormalUp)) {\n      if (!defined(octNormalRight)) {\n        throw new RuntimeError(\n          \"To define a custom orientation with oct-encoded vectors, both NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P must be defined.\"\n        );\n      }\n      AttributeCompression.octDecodeInRange(\n        octNormalUp[0],\n        octNormalUp[1],\n        65535,\n        instanceNormalUp\n      );\n      AttributeCompression.octDecodeInRange(\n        octNormalRight[0],\n        octNormalRight[1],\n        65535,\n        instanceNormalRight\n      );\n      hasCustomOrientation = true;\n    } else if (eastNorthUp) {\n      Transforms.eastNorthUpToFixedFrame(\n        instancePosition,\n        Ellipsoid.WGS84,\n        instanceTransform\n      );\n      Matrix4.getMatrix3(instanceTransform, instanceRotation);\n    } else {\n      Matrix3.clone(Matrix3.IDENTITY, instanceRotation);\n    }\n  }\n  if (hasCustomOrientation) {\n    Cartesian3.cross(\n      instanceNormalRight,\n      instanceNormalUp,\n      instanceNormalForward\n    );\n    Cartesian3.normalize(instanceNormalForward, instanceNormalForward);\n    Matrix3.setColumn(\n      instanceRotation,\n      0,\n      instanceNormalRight,\n      instanceRotation\n    );\n    Matrix3.setColumn(instanceRotation, 1, instanceNormalUp, instanceRotation);\n    Matrix3.setColumn(\n      instanceRotation,\n      2,\n      instanceNormalForward,\n      instanceRotation\n    );\n  }\n  Quaternion.fromRotationMatrix(instanceRotation, instanceQuaternion);\n}\n\nfunction processScale(featureTable, i, instanceScale) {\n  instanceScale = Cartesian3.fromElements(1.0, 1.0, 1.0, instanceScale);\n  const scale = featureTable.getProperty(\n    \"SCALE\",\n    ComponentDatatype.FLOAT,\n    1,\n    i\n  );\n  if (defined(scale)) {\n    Cartesian3.multiplyByScalar(instanceScale, scale, instanceScale);\n  }\n  const nonUniformScale = featureTable.getProperty(\n    \"SCALE_NON_UNIFORM\",\n    ComponentDatatype.FLOAT,\n    3,\n    i,\n    propertyScratch1\n  );\n  if (defined(nonUniformScale)) {\n    instanceScale.x *= nonUniformScale[0];\n    instanceScale.y *= nonUniformScale[1];\n    instanceScale.z *= nonUniformScale[2];\n  }\n}\n\nI3dmLoader.prototype.unload = function () {\n  if (defined(this._gltfLoader)) {\n    this._gltfLoader.unload();\n  }\n  this._components = undefined;\n};\n\nexport default I3dmLoader;\n","import combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ImageBasedLightingStageFS from \"../../Shaders/ModelExperimental/ImageBasedLightingStageFS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport OctahedralProjectedCubeMap from \"../OctahedralProjectedCubeMap.js\";\n\nconst ImageBasedLightingPipelineStage = {};\nImageBasedLightingPipelineStage.name = \"ImageBasedLightingPipelineStage\"; // Helps with debugging\n\nImageBasedLightingPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState\n) {\n  const imageBasedLighting = model.imageBasedLighting;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"USE_IBL_LIGHTING\",\n    undefined,\n    ShaderDestination.FRAGMENT\n  );\n  shaderBuilder.addUniform(\n    \"vec2\",\n    \"model_iblFactor\",\n    ShaderDestination.FRAGMENT\n  );\n\n  if (OctahedralProjectedCubeMap.isSupported(frameState.context)) {\n    const addMatrix =\n      imageBasedLighting.useSphericalHarmonics ||\n      imageBasedLighting.useSpecularEnvironmentMaps ||\n      imageBasedLighting.enabled;\n    if (addMatrix) {\n      shaderBuilder.addUniform(\n        \"mat3\",\n        \"model_iblReferenceFrameMatrix\",\n        ShaderDestination.FRAGMENT\n      );\n    }\n\n    if (defined(imageBasedLighting.sphericalHarmonicCoefficients)) {\n      shaderBuilder.addDefine(\n        \"DIFFUSE_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT\n      );\n      shaderBuilder.addDefine(\n        \"CUSTOM_SPHERICAL_HARMONICS\",\n        undefined,\n        ShaderDestination.FRAGMENT\n      );\n      shaderBuilder.addUniform(\n        \"vec3\",\n        \"model_sphericalHarmonicCoefficients[9]\",\n        ShaderDestination.FRAGMENT\n      );\n    } else if (imageBasedLighting.useDefaultSphericalHarmonics) {\n      shaderBuilder.addDefine(\n        \"DIFFUSE_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT\n      );\n    }\n\n    if (\n      defined(imageBasedLighting.specularEnvironmentMapAtlas) &&\n      imageBasedLighting.specularEnvironmentMapAtlas.ready\n    ) {\n      shaderBuilder.addDefine(\n        \"SPECULAR_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT\n      );\n      shaderBuilder.addDefine(\n        \"CUSTOM_SPECULAR_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT\n      );\n      shaderBuilder.addUniform(\n        \"sampler2D\",\n        \"model_specularEnvironmentMaps\",\n        ShaderDestination.FRAGMENT\n      );\n      shaderBuilder.addUniform(\n        \"vec2\",\n        \"model_specularEnvironmentMapsSize\",\n        ShaderDestination.FRAGMENT\n      );\n      shaderBuilder.addUniform(\n        \"float\",\n        \"model_specularEnvironmentMapsMaximumLOD\",\n        ShaderDestination.FRAGMENT\n      );\n    } else if (model.useDefaultSpecularMaps) {\n      shaderBuilder.addDefine(\n        \"SPECULAR_IBL\",\n        undefined,\n        ShaderDestination.FRAGMENT\n      );\n    }\n  }\n\n  if (defined(imageBasedLighting.luminanceAtZenith)) {\n    shaderBuilder.addDefine(\n      \"USE_SUN_LUMINANCE\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n    shaderBuilder.addUniform(\n      \"float\",\n      \"model_luminanceAtZenith\",\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  shaderBuilder.addFragmentLines([ImageBasedLightingStageFS]);\n\n  const uniformMap = {\n    model_iblFactor: function () {\n      return imageBasedLighting.imageBasedLightingFactor;\n    },\n    model_iblReferenceFrameMatrix: function () {\n      return model._iblReferenceFrameMatrix;\n    },\n    model_luminanceAtZenith: function () {\n      return imageBasedLighting.luminanceAtZenith;\n    },\n    model_sphericalHarmonicCoefficients: function () {\n      return imageBasedLighting.sphericalHarmonicCoefficients;\n    },\n    model_specularEnvironmentMaps: function () {\n      return imageBasedLighting.specularEnvironmentMapAtlas.texture;\n    },\n    model_specularEnvironmentMapsSize: function () {\n      return imageBasedLighting.specularEnvironmentMapAtlas.texture.dimensions;\n    },\n    model_specularEnvironmentMapsMaximumLOD: function () {\n      return imageBasedLighting.specularEnvironmentMapAtlas.maximumMipmapLevel;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nexport default ImageBasedLightingPipelineStage;\n","import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport InstanceAttributeSemantic from \"../InstanceAttributeSemantic.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport InstancingStageCommon from \"../../Shaders/ModelExperimental/InstancingStageCommon.js\";\nimport InstancingStageVS from \"../../Shaders/ModelExperimental/InstancingStageVS.js\";\nimport LegacyInstancingStageVS from \"../../Shaders/ModelExperimental/LegacyInstancingStageVS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\nconst modelViewScratch = new Matrix4();\nconst nodeTransformScratch = new Matrix4();\n\n/**\n * The instancing pipeline stage is responsible for handling GPU mesh instancing at the node\n * level.\n *\n * @namespace InstancingPipelineStage\n * @private\n */\nconst InstancingPipelineStage = {};\nInstancingPipelineStage.name = \"InstancingPipelineStage\"; // Helps with debugging\n\n/**\n * Process a node. This modifies the following parts of the render resources:\n * <ul>\n *  <li>adds attribute declarations for the instancing vertex attributes in the vertex shader</li>\n *  <li>adds an instancing translation min and max to compute an accurate bounding volume</li>\n * </ul>\n * @param {NodeRenderResources} renderResources The render resources for this node.\n * @param {ModelComponents.Node} node The node.\n * @param {FrameState} frameState The frame state.\n */\nInstancingPipelineStage.process = function (renderResources, node, frameState) {\n  const instances = node.instances;\n  const count = instances.attributes[0].count;\n  let instancingVertexAttributes = [];\n  const sceneGraph = renderResources.model.sceneGraph;\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_INSTANCING\");\n  shaderBuilder.addVertexLines([InstancingStageCommon]);\n\n  const translationAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.TRANSLATION\n  );\n\n  let translationMax;\n  let translationMin;\n  if (defined(translationAttribute)) {\n    translationMax = translationAttribute.max;\n    translationMin = translationAttribute.min;\n  }\n\n  const rotationAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.ROTATION\n  );\n  if (\n    defined(rotationAttribute) ||\n    !defined(translationMax) ||\n    !defined(translationMin)\n  ) {\n    instancingVertexAttributes = processMatrixAttributes(\n      node,\n      count,\n      renderResources,\n      frameState\n    );\n  } else {\n    if (defined(translationAttribute)) {\n      instancingVertexAttributes.push({\n        index: renderResources.attributeIndex++,\n        vertexBuffer: translationAttribute.buffer,\n        componentsPerAttribute: AttributeType.getNumberOfComponents(\n          translationAttribute.type\n        ),\n        componentDatatype: translationAttribute.componentDatatype,\n        normalize: false,\n        offsetInBytes: translationAttribute.byteOffset,\n        strideInBytes: translationAttribute.byteStride,\n        instanceDivisor: 1,\n      });\n\n      renderResources.instancingTranslationMax = translationMax;\n      renderResources.instancingTranslationMin = translationMin;\n\n      shaderBuilder.addDefine(\"HAS_INSTANCE_TRANSLATION\");\n      shaderBuilder.addAttribute(\"vec3\", \"a_instanceTranslation\");\n    }\n\n    const scaleAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n      instances,\n      InstanceAttributeSemantic.SCALE\n    );\n\n    if (defined(scaleAttribute)) {\n      instancingVertexAttributes.push({\n        index: renderResources.attributeIndex++,\n        vertexBuffer: scaleAttribute.buffer,\n        componentsPerAttribute: AttributeType.getNumberOfComponents(\n          scaleAttribute.type\n        ),\n        componentDatatype: scaleAttribute.componentDatatype,\n        normalize: false,\n        offsetInBytes: scaleAttribute.byteOffset,\n        strideInBytes: scaleAttribute.byteStride,\n        instanceDivisor: 1,\n      });\n\n      shaderBuilder.addDefine(\"HAS_INSTANCE_SCALE\");\n      shaderBuilder.addAttribute(\"vec3\", \"a_instanceScale\");\n    }\n  }\n\n  processFeatureIdAttributes(\n    renderResources,\n    frameState,\n    instances,\n    instancingVertexAttributes\n  );\n\n  if (instances.transformInWorldSpace) {\n    const uniformMap = renderResources.uniformMap;\n    shaderBuilder.addDefine(\n      \"USE_LEGACY_INSTANCING\",\n      undefined,\n      ShaderDestination.VERTEX\n    );\n    shaderBuilder.addUniform(\n      \"mat4\",\n      \"u_instance_modifiedModelView\",\n      ShaderDestination.VERTEX\n    );\n    shaderBuilder.addUniform(\n      \"mat4\",\n      \"u_instance_nodeTransform\",\n      ShaderDestination.VERTEX\n    );\n\n    // The i3dm format applies the instancing transforms in world space.\n    // Instancing matrices come from a vertex attribute rather than a\n    // uniform, and they are multiplied in the middle of the modelView matrix\n    // product. This means czm_modelView can't be used. Instead, we split the\n    // matrix into two parts, modifiedModelView and nodeTransform, and handle\n    // this in LegacyInstancingStageVS.glsl. Conceptually the product looks like\n    // this:\n    //\n    // modelView = u_modifiedModelView * a_instanceTransform * u_nodeTransform\n    uniformMap.u_instance_modifiedModelView = function () {\n      // Model matrix without the node hierarchy or axis correction\n      // (see u_instance_nodeTransform).\n      const modifiedModelMatrix = Matrix4.multiplyTransformation(\n        // For 3D Tiles, model.modelMatrix is the computed tile\n        // transform (which includes tileset.modelMatrix). This always applies\n        // for i3dm, since such models are always part of a tileset.\n        renderResources.model.modelMatrix,\n        // For i3dm models, components.transform contains the RTC_CENTER\n        // translation.\n        sceneGraph.components.transform,\n        modelViewScratch\n      );\n\n      // modifiedModelView = view * modifiedModel\n      return Matrix4.multiplyTransformation(\n        frameState.context.uniformState.view,\n        modifiedModelMatrix,\n        modelViewScratch\n      );\n    };\n\n    uniformMap.u_instance_nodeTransform = function () {\n      // nodeTransform = axisCorrection * nodeHierarchyTransform\n      return Matrix4.multiplyTransformation(\n        // glTF y-up to 3D Tiles z-up\n        sceneGraph.axisCorrectionMatrix,\n        // This transforms from the node's coordinate system to the root\n        // of the node hierarchy\n        renderResources.runtimeNode.computedTransform,\n        nodeTransformScratch\n      );\n    };\n\n    shaderBuilder.addVertexLines([LegacyInstancingStageVS]);\n  } else {\n    shaderBuilder.addVertexLines([InstancingStageVS]);\n  }\n\n  renderResources.instanceCount = count;\n  renderResources.attributes.push.apply(\n    renderResources.attributes,\n    instancingVertexAttributes\n  );\n};\n\nconst translationScratch = new Cartesian3();\nconst rotationScratch = new Quaternion();\nconst scaleScratch = new Cartesian3();\nconst transformScratch = new Matrix4();\n\nfunction getInstanceTransformsTypedArray(instances, count, renderResources) {\n  const elements = 12;\n  const transformsTypedArray = new Float32Array(count * elements);\n\n  const translationAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.TRANSLATION\n  );\n  const rotationAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.ROTATION\n  );\n  const scaleAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    instances,\n    InstanceAttributeSemantic.SCALE\n  );\n\n  const instancingTranslationMax = new Cartesian3(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE\n  );\n  const instancingTranslationMin = new Cartesian3(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE\n  );\n\n  const hasTranslation = defined(translationAttribute);\n  const hasRotation = defined(rotationAttribute);\n  const hasScale = defined(scaleAttribute);\n\n  // Translations get initialized to (0, 0, 0).\n  const translationTypedArray = hasTranslation\n    ? translationAttribute.packedTypedArray\n    : new Float32Array(count * 3);\n  // Rotations get initialized to (0, 0, 0, 0). The w-component is set to 1 in the loop below.\n  const rotationTypedArray = hasRotation\n    ? rotationAttribute.packedTypedArray\n    : new Float32Array(count * 4);\n  // Scales get initialized to (1, 1, 1).\n  let scaleTypedArray;\n  if (hasScale) {\n    scaleTypedArray = scaleAttribute.packedTypedArray;\n  } else {\n    scaleTypedArray = new Float32Array(count * 3);\n    scaleTypedArray.fill(1);\n  }\n\n  for (let i = 0; i < count; i++) {\n    const translation = new Cartesian3(\n      translationTypedArray[i * 3],\n      translationTypedArray[i * 3 + 1],\n      translationTypedArray[i * 3 + 2],\n      translationScratch\n    );\n\n    Cartesian3.maximumByComponent(\n      instancingTranslationMax,\n      translation,\n      instancingTranslationMax\n    );\n    Cartesian3.minimumByComponent(\n      instancingTranslationMin,\n      translation,\n      instancingTranslationMin\n    );\n\n    const rotation = new Quaternion(\n      rotationTypedArray[i * 4],\n      rotationTypedArray[i * 4 + 1],\n      rotationTypedArray[i * 4 + 2],\n      hasRotation ? rotationTypedArray[i * 4 + 3] : 1,\n      rotationScratch\n    );\n\n    const scale = new Cartesian3(\n      scaleTypedArray[i * 3],\n      scaleTypedArray[i * 3 + 1],\n      scaleTypedArray[i * 3 + 2],\n      scaleScratch\n    );\n\n    const transform = Matrix4.fromTranslationQuaternionRotationScale(\n      translation,\n      rotation,\n      scale,\n      transformScratch\n    );\n\n    const offset = elements * i;\n\n    transformsTypedArray[offset + 0] = transform[0];\n    transformsTypedArray[offset + 1] = transform[4];\n    transformsTypedArray[offset + 2] = transform[8];\n    transformsTypedArray[offset + 3] = transform[12];\n    transformsTypedArray[offset + 4] = transform[1];\n    transformsTypedArray[offset + 5] = transform[5];\n    transformsTypedArray[offset + 6] = transform[9];\n    transformsTypedArray[offset + 7] = transform[13];\n    transformsTypedArray[offset + 8] = transform[2];\n    transformsTypedArray[offset + 9] = transform[6];\n    transformsTypedArray[offset + 10] = transform[10];\n    transformsTypedArray[offset + 11] = transform[14];\n\n    renderResources.instancingTranslationMax = instancingTranslationMax;\n    renderResources.instancingTranslationMin = instancingTranslationMin;\n  }\n\n  return transformsTypedArray;\n}\n\nfunction processFeatureIdAttributes(\n  renderResources,\n  frameState,\n  instances,\n  instancingVertexAttributes\n) {\n  const attributes = instances.attributes;\n  const model = renderResources.model;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  // Load Feature ID vertex attributes. These are loaded as typed arrays in GltfLoader\n  // because we want to expose the instance feature ID when picking.\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (attribute.semantic !== InstanceAttributeSemantic.FEATURE_ID) {\n      continue;\n    }\n\n    if (\n      attribute.setIndex >= renderResources.featureIdVertexAttributeSetIndex\n    ) {\n      renderResources.featureIdVertexAttributeSetIndex = attribute.setIndex + 1;\n    }\n\n    const vertexBuffer = Buffer.createVertexBuffer({\n      context: frameState.context,\n      typedArray: attribute.packedTypedArray,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    vertexBuffer.vertexArrayDestroyable = false;\n    model._resources.push(vertexBuffer);\n\n    instancingVertexAttributes.push({\n      index: renderResources.attributeIndex++,\n      vertexBuffer: vertexBuffer,\n      componentsPerAttribute: AttributeType.getNumberOfComponents(\n        attribute.type\n      ),\n      componentDatatype: attribute.componentDatatype,\n      normalize: false,\n      offsetInBytes: attribute.byteOffset,\n      strideInBytes: attribute.byteStride,\n      instanceDivisor: 1,\n    });\n\n    shaderBuilder.addAttribute(\n      \"float\",\n      `a_instanceFeatureId_${attribute.setIndex}`\n    );\n  }\n}\n\nfunction processMatrixAttributes(node, count, renderResources, frameState) {\n  const transformsTypedArray = getInstanceTransformsTypedArray(\n    node.instances,\n    count,\n    renderResources\n  );\n  const transformsVertexBuffer = Buffer.createVertexBuffer({\n    context: frameState.context,\n    typedArray: transformsTypedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  // Destruction of resources allocated by the ModelExperimental is handled by ModelExperimental.destroy().\n  transformsVertexBuffer.vertexArrayDestroyable = false;\n  renderResources.model._resources.push(transformsVertexBuffer);\n\n  const vertexSizeInFloats = 12;\n  const componentByteSize = ComponentDatatype.getSizeInBytes(\n    ComponentDatatype.FLOAT\n  );\n  const strideInBytes = componentByteSize * vertexSizeInFloats;\n\n  const instancingVertexAttributes = [\n    {\n      index: renderResources.attributeIndex++,\n      vertexBuffer: transformsVertexBuffer,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: strideInBytes,\n      instanceDivisor: 1,\n    },\n    {\n      index: renderResources.attributeIndex++,\n      vertexBuffer: transformsVertexBuffer,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n      offsetInBytes: componentByteSize * 4,\n      strideInBytes: strideInBytes,\n      instanceDivisor: 1,\n    },\n    {\n      index: renderResources.attributeIndex++,\n      vertexBuffer: transformsVertexBuffer,\n      componentsPerAttribute: 4,\n      componentDatatype: ComponentDatatype.FLOAT,\n      normalize: false,\n      offsetInBytes: componentByteSize * 8,\n      strideInBytes: strideInBytes,\n      instanceDivisor: 1,\n    },\n  ];\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"HAS_INSTANCE_MATRICES\");\n  shaderBuilder.addAttribute(\"vec4\", \"a_instancingTransformRow0\");\n  shaderBuilder.addAttribute(\"vec4\", \"a_instancingTransformRow1\");\n  shaderBuilder.addAttribute(\"vec4\", \"a_instancingTransformRow2\");\n\n  return instancingVertexAttributes;\n}\n\n// Exposed for testing\nInstancingPipelineStage._getInstanceTransformsTypedArray = getInstanceTransformsTypedArray;\n\nexport default InstancingPipelineStage;\n","/**\n * The lighting model to use for lighting a {@link ModelExperimental}.\n *\n * @enum {Number}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst LightingModel = {\n  /**\n   * Use unlit shading, i.e. skip lighting calculations. The model's\n   * diffuse color (assumed to be linear RGB, not sRGB) is used directly\n   * when computing <code>gl_FragColor</code>. The alpha mode is still\n   * applied.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNLIT: 0,\n  /**\n   * Use physically-based rendering lighting calculations. This includes\n   * both PBR metallic roughness and PBR specular glossiness. Image-based\n   * lighting is also applied when possible.\n   *\n   * @type {Number}\n   * @constant\n   */\n  PBR: 1,\n};\n\nexport default Object.freeze(LightingModel);\n","import defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport LightingStageFS from \"../../Shaders/ModelExperimental/LightingStageFS.js\";\nimport LightingModel from \"./LightingModel.js\";\n\n/**\n * The lighting pipeline stage is responsible for taking a material and rendering\n * it with a lighting model such as physically based rendering (PBR) or unlit\n * shading\n *\n * @namespace LightingPipelineStage\n *\n * @private\n */\nconst LightingPipelineStage = {};\nLightingPipelineStage.name = \"LightingPipelineStage\"; // Helps with debugging\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>modifies the shader to include the lighting stage</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n *\n * @private\n */\nLightingPipelineStage.process = function (renderResources, primitive) {\n  const model = renderResources.model;\n  const lightingOptions = renderResources.lightingOptions;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  if (defined(model.lightColor)) {\n    shaderBuilder.addDefine(\n      \"USE_CUSTOM_LIGHT_COLOR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"model_lightColorHdr\",\n      ShaderDestination.FRAGMENT\n    );\n\n    const uniformMap = renderResources.uniformMap;\n    uniformMap.model_lightColorHdr = function () {\n      return model.lightColor;\n    };\n  }\n\n  // The lighting model is always set by the material. However, custom shaders\n  // can override this.\n  const lightingModel = lightingOptions.lightingModel;\n\n  if (lightingModel === LightingModel.PBR) {\n    shaderBuilder.addDefine(\n      \"LIGHTING_PBR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  } else {\n    shaderBuilder.addDefine(\n      \"LIGHTING_UNLIT\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  shaderBuilder.addFragmentLines([LightingStageFS]);\n};\n\nexport default LightingPipelineStage;\n","import defined from \"../../Core/defined.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport LightingModel from \"./LightingModel.js\";\nimport MaterialStageFS from \"../../Shaders/ModelExperimental/MaterialStageFS.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartesian4 from \"../../Core/Cartesian4.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\n\nconst Material = ModelComponents.Material;\nconst MetallicRoughness = ModelComponents.MetallicRoughness;\nconst SpecularGlossiness = ModelComponents.SpecularGlossiness;\n\n/**\n * The material pipeline stage processes textures and other uniforms needed\n * to render a primitive. This handles the following material types:\n * <ul>\n *   <li>Basic glTF materials (PBR metallic roughness model)</li>\n *   <li>The `KHR_materials_pbrSpecularGlossiness` glTF extension</li>\n *   <li>The `KHR_materials_unlit` glTF extension</li>\n * </ul>\n *\n * @namespace MaterialPipelineStage\n *\n * @private\n */\nconst MaterialPipelineStage = {};\nMaterialPipelineStage.name = \"MaterialPipelineStage\"; // Helps with debugging\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Modifies the shader to include the material processing stage</li>\n *   <li>Modifies the shader to include additional uniforms for textures and other rendering details</li>\n *   <li>Modifies the lighting options to set either PBR or unlit lighting</li>\n *   <li>Sets the render state for back-face culling</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state.\n * @private\n */\nMaterialPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const material = primitive.material;\n\n  const uniformMap = renderResources.uniformMap;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  // When textures are loaded incrementally, fall back to a default 1x1 texture\n  const defaultTexture = frameState.context.defaultTexture;\n  const defaultNormalTexture = frameState.context.defaultNormalTexture;\n  const defaultEmissiveTexture = frameState.context.defaultEmissiveTexture;\n\n  processMaterialUniforms(\n    material,\n    uniformMap,\n    shaderBuilder,\n    defaultTexture,\n    defaultNormalTexture,\n    defaultEmissiveTexture\n  );\n\n  if (defined(material.specularGlossiness)) {\n    processSpecularGlossinessUniforms(\n      material,\n      uniformMap,\n      shaderBuilder,\n      defaultTexture\n    );\n  } else {\n    processMetallicRoughnessUniforms(\n      material,\n      uniformMap,\n      shaderBuilder,\n      defaultTexture\n    );\n  }\n\n  // If the primitive does not have normals, fall back to unlit lighting.\n  const hasNormals = ModelExperimentalUtility.getAttributeBySemantic(\n    primitive,\n    VertexAttributeSemantic.NORMAL\n  );\n\n  const lightingOptions = renderResources.lightingOptions;\n  if (material.unlit || !hasNormals) {\n    lightingOptions.lightingModel = LightingModel.UNLIT;\n  } else {\n    lightingOptions.lightingModel = LightingModel.PBR;\n  }\n\n  // Configure back-face culling\n  const model = renderResources.model;\n  const cull = model.backFaceCulling && !material.doubleSided;\n  const translucent = defined(model.color) && model.color.alpha < 1.0;\n  renderResources.renderStateOptions.cull = {\n    enabled: cull && !translucent,\n  };\n\n  const alphaOptions = renderResources.alphaOptions;\n  if (!defined(alphaOptions.alphaMode)) {\n    alphaOptions.alphaMode = material.alphaMode;\n    if (material.alphaMode === AlphaMode.BLEND) {\n      alphaOptions.pass = Pass.TRANSLUCENT;\n    } else if (material.alphaMode === AlphaMode.MASK) {\n      alphaOptions.alphaCutoff = material.alphaCutoff;\n    }\n  }\n\n  shaderBuilder.addFragmentLines([MaterialStageFS]);\n\n  // Check if the model's debug wireframe is enabled. If so, add a define\n  // to disable normal mapping.\n  if (model.debugWireframe) {\n    shaderBuilder.addDefine(\n      \"USE_WIREFRAME\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n};\n\n/**\n * Process a single texture transformation and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object.<String, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {String} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {String} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTextureTransform(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName\n) {\n  // Add a define to enable the texture transformation code in the shader.\n  const transformDefine = `HAS_${defineName}_TEXTURE_TRANSFORM`;\n  shaderBuilder.addDefine(\n    transformDefine,\n    undefined,\n    ShaderDestination.FRAGMENT\n  );\n\n  // Add a uniform for the transformation matrix\n  const transformUniformName = `${uniformName}Transform`;\n  shaderBuilder.addUniform(\n    \"mat3\",\n    transformUniformName,\n    ShaderDestination.FRAGMENT\n  );\n  uniformMap[transformUniformName] = function () {\n    return textureReader.transform;\n  };\n}\n\n/**\n * Process a single texture and add it to the shader and uniform map.\n *\n * @param {ShaderBuilder} shaderBuilder The shader builder to modify\n * @param {Object.<String, Function>} uniformMap The uniform map to modify.\n * @param {ModelComponents.TextureReader} textureReader The texture to add to the shader\n * @param {String} uniformName The name of the sampler uniform such as <code>u_baseColorTexture</code>\n * @param {String} defineName The name of the texture for use in the defines, minus any prefix or suffix. For example, \"BASE_COLOR\" or \"EMISSIVE\"\n *\n * @private\n */\nfunction processTexture(\n  shaderBuilder,\n  uniformMap,\n  textureReader,\n  uniformName,\n  defineName,\n  defaultTexture\n) {\n  // Add a uniform for the texture itself\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    uniformName,\n    ShaderDestination.FRAGMENT\n  );\n  uniformMap[uniformName] = function () {\n    return defaultValue(textureReader.texture, defaultTexture);\n  };\n\n  // Add a #define directive to enable using the texture in the shader\n  const textureDefine = `HAS_${defineName}_TEXTURE`;\n  shaderBuilder.addDefine(textureDefine, undefined, ShaderDestination.FRAGMENT);\n\n  // Add a #define to tell the shader which texture coordinates varying to use.\n  const texCoordIndex = textureReader.texCoord;\n  const texCoordVarying = `v_texCoord_${texCoordIndex}`;\n  const texCoordDefine = `TEXCOORD_${defineName}`;\n  shaderBuilder.addDefine(\n    texCoordDefine,\n    texCoordVarying,\n    ShaderDestination.FRAGMENT\n  );\n\n  // Some textures have matrix transforms (e.g. for texture atlases). Add those\n  // to the shader if present.\n  const textureTransform = textureReader.transform;\n  if (\n    defined(textureTransform) &&\n    !Matrix3.equals(textureTransform, Matrix3.IDENTITY)\n  ) {\n    processTextureTransform(\n      shaderBuilder,\n      uniformMap,\n      textureReader,\n      uniformName,\n      defineName\n    );\n  }\n}\n\nfunction processMaterialUniforms(\n  material,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture,\n  defaultNormalTexture,\n  defaultEmissiveTexture\n) {\n  const emissiveTexture = material.emissiveTexture;\n  if (defined(emissiveTexture)) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      emissiveTexture,\n      \"u_emissiveTexture\",\n      \"EMISSIVE\",\n      defaultEmissiveTexture\n    );\n  }\n\n  const emissiveFactor = material.emissiveFactor;\n  if (\n    defined(emissiveFactor) &&\n    !Cartesian3.equals(emissiveFactor, Material.DEFAULT_EMISSIVE_FACTOR)\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_emissiveFactor\",\n      ShaderDestination.FRAGMENT\n    );\n    uniformMap.u_emissiveFactor = function () {\n      return material.emissiveFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_EMISSIVE_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  const normalTexture = material.normalTexture;\n  if (defined(normalTexture)) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      normalTexture,\n      \"u_normalTexture\",\n      \"NORMAL\",\n      defaultNormalTexture\n    );\n  }\n\n  const occlusionTexture = material.occlusionTexture;\n  if (defined(occlusionTexture)) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      occlusionTexture,\n      \"u_occlusionTexture\",\n      \"OCCLUSION\",\n      defaultTexture\n    );\n  }\n}\n\nfunction processSpecularGlossinessUniforms(\n  material,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture\n) {\n  const specularGlossiness = material.specularGlossiness;\n  shaderBuilder.addDefine(\n    \"USE_SPECULAR_GLOSSINESS\",\n    undefined,\n    ShaderDestination.FRAGMENT\n  );\n\n  const diffuseTexture = specularGlossiness.diffuseTexture;\n  if (defined(diffuseTexture)) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      diffuseTexture,\n      \"u_diffuseTexture\",\n      \"DIFFUSE\",\n      defaultTexture\n    );\n  }\n\n  const diffuseFactor = specularGlossiness.diffuseFactor;\n  if (\n    defined(diffuseFactor) &&\n    !Cartesian4.equals(diffuseFactor, SpecularGlossiness.DEFAULT_DIFFUSE_FACTOR)\n  ) {\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_diffuseFactor\",\n      ShaderDestination.FRAGMENT\n    );\n    uniformMap.u_diffuseFactor = function () {\n      return specularGlossiness.diffuseFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_DIFFUSE_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  const specularGlossinessTexture =\n    specularGlossiness.specularGlossinessTexture;\n  if (defined(specularGlossinessTexture)) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      specularGlossinessTexture,\n      \"u_specularGlossinessTexture\",\n      \"SPECULAR_GLOSSINESS\",\n      defaultTexture\n    );\n  }\n\n  const specularFactor = specularGlossiness.specularFactor;\n  if (\n    defined(specularFactor) &&\n    !Cartesian3.equals(\n      specularFactor,\n      SpecularGlossiness.DEFAULT_SPECULAR_FACTOR\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec3\",\n      \"u_specularFactor\",\n      ShaderDestination.FRAGMENT\n    );\n    uniformMap.u_specularFactor = function () {\n      return specularGlossiness.specularFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_SPECULAR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  const glossinessFactor = specularGlossiness.glossinessFactor;\n  if (\n    defined(glossinessFactor) &&\n    glossinessFactor !== SpecularGlossiness.DEFAULT_GLOSSINESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_glossinessFactor\",\n      ShaderDestination.FRAGMENT\n    );\n    uniformMap.u_glossinessFactor = function () {\n      return specularGlossiness.glossinessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_GLOSSINESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n}\n\nfunction processMetallicRoughnessUniforms(\n  material,\n  uniformMap,\n  shaderBuilder,\n  defaultTexture\n) {\n  const metallicRoughness = material.metallicRoughness;\n  shaderBuilder.addDefine(\n    \"USE_METALLIC_ROUGHNESS\",\n    undefined,\n    ShaderDestination.FRAGMENT\n  );\n\n  const baseColorTexture = metallicRoughness.baseColorTexture;\n  if (defined(baseColorTexture)) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      baseColorTexture,\n      \"u_baseColorTexture\",\n      \"BASE_COLOR\",\n      defaultTexture\n    );\n  }\n\n  const baseColorFactor = metallicRoughness.baseColorFactor;\n  if (\n    defined(baseColorFactor) &&\n    !Cartesian4.equals(\n      baseColorFactor,\n      MetallicRoughness.DEFAULT_BASE_COLOR_FACTOR\n    )\n  ) {\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"u_baseColorFactor\",\n      ShaderDestination.FRAGMENT\n    );\n    uniformMap.u_baseColorFactor = function () {\n      return metallicRoughness.baseColorFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_BASE_COLOR_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  const metallicRoughnessTexture = metallicRoughness.metallicRoughnessTexture;\n  if (defined(metallicRoughnessTexture)) {\n    processTexture(\n      shaderBuilder,\n      uniformMap,\n      metallicRoughnessTexture,\n      \"u_metallicRoughnessTexture\",\n      \"METALLIC_ROUGHNESS\",\n      defaultTexture\n    );\n  }\n\n  const metallicFactor = metallicRoughness.metallicFactor;\n  if (\n    defined(metallicFactor) &&\n    metallicFactor !== MetallicRoughness.DEFAULT_METALLIC_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_metallicFactor\",\n      ShaderDestination.FRAGMENT\n    );\n    uniformMap.u_metallicFactor = function () {\n      return metallicRoughness.metallicFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_METALLIC_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  const roughnessFactor = metallicRoughness.roughnessFactor;\n  if (\n    defined(roughnessFactor) &&\n    roughnessFactor !== MetallicRoughness.DEFAULT_ROUGHNESS_FACTOR\n  ) {\n    shaderBuilder.addUniform(\n      \"float\",\n      \"u_roughnessFactor\",\n      ShaderDestination.FRAGMENT\n    );\n    uniformMap.u_roughnessFactor = function () {\n      return metallicRoughness.roughnessFactor;\n    };\n    shaderBuilder.addDefine(\n      \"HAS_ROUGHNESS_FACTOR\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n}\n\n// Exposed for testing\nMaterialPipelineStage._processTexture = processTexture;\nMaterialPipelineStage._processTextureTransform = processTextureTransform;\n\nexport default MaterialPipelineStage;\n","import defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport MetadataStageFS from \"../../Shaders/ModelExperimental/MetadataStageFS.js\";\nimport MetadataStageVS from \"../../Shaders/ModelExperimental/MetadataStageVS.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\n\n/**\n * The metadata pipeline stage processes metadata properties from\n * EXT_structural_metadata and inserts them into a struct in the shader.\n * This struct will be used by {@link CustomShaderPipelineStage} to allow the\n * user to access metadata using {@link CustomShader}\n *\n * @namespace MetadataPipelineStage\n *\n * @private\n */\nconst MetadataPipelineStage = {};\nMetadataPipelineStage.name = \"MetadataPipelineStage\";\n\nMetadataPipelineStage.STRUCT_ID_METADATA_VS = \"MetadataVS\";\nMetadataPipelineStage.STRUCT_ID_METADATA_FS = \"MetadataFS\";\nMetadataPipelineStage.STRUCT_NAME_METADATA = \"Metadata\";\nMetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS =\n  \"initializeMetadataVS\";\nMetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS =\n  \"initializeMetadataFS\";\nMetadataPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_METADATA =\n  \"void initializeMetadata(out Metadata metadata, ProcessedAttributes attributes)\";\nMetadataPipelineStage.FUNCTION_ID_SET_METADATA_VARYINGS = \"setMetadataVaryings\";\nMetadataPipelineStage.FUNCTION_SIGNATURE_SET_METADATA_VARYINGS =\n  \"void setMetadataVaryings()\";\n\n/**\n * Process a primitive. This modifies the following parts of the render\n * resources:\n * <ul>\n *   <li>Adds a Metadata struct to the shader</li>\n *   <li>If the primitive has structural metadata, properties are added to the Metadata struct</li>\n *   <li>dynamic functions are added to the shader to initialize the metadata properties</li>\n *   <li>Adds uniforms for property textures to the uniform map as needed</li>\n *   <li>Adds uniforms for offset/scale to the uniform map as needed</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for the primitive\n * @param {ModelComponents.Primitive} primitive The primitive to be rendered\n * @param {FrameState} frameState The frame state\n * @private\n */\nMetadataPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  // Always declare structs, even if not used\n  declareStructsAndFunctions(shaderBuilder);\n  shaderBuilder.addVertexLines([MetadataStageVS]);\n  shaderBuilder.addFragmentLines([MetadataStageFS]);\n\n  const structuralMetadata = renderResources.model.structuralMetadata;\n  if (!defined(structuralMetadata)) {\n    return;\n  }\n\n  processPropertyAttributes(renderResources, primitive, structuralMetadata);\n  processPropertyTextures(renderResources, structuralMetadata);\n};\n\nfunction declareStructsAndFunctions(shaderBuilder) {\n  // Declare the Metadata struct.\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_VS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    ShaderDestination.VERTEX\n  );\n  shaderBuilder.addStruct(\n    MetadataPipelineStage.STRUCT_ID_METADATA_FS,\n    MetadataPipelineStage.STRUCT_NAME_METADATA,\n    ShaderDestination.FRAGMENT\n  );\n\n  // declare the initializeMetadata() function. The details may differ\n  // between vertex and fragment shader\n  shaderBuilder.addFunction(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    MetadataPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_METADATA,\n    ShaderDestination.VERTEX\n  );\n  shaderBuilder.addFunction(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    MetadataPipelineStage.FUNCTION_SIGNATURE_INITIALIZE_METADATA,\n    ShaderDestination.FRAGMENT\n  );\n\n  // declare the setMetadataVaryings() function in the vertex shader only.\n  shaderBuilder.addFunction(\n    MetadataPipelineStage.FUNCTION_ID_SET_METADATA_VARYINGS,\n    MetadataPipelineStage.FUNCTION_SIGNATURE_SET_METADATA_VARYINGS,\n    ShaderDestination.VERTEX\n  );\n}\n\nfunction processPropertyAttributes(\n  renderResources,\n  primitive,\n  structuralMetadata\n) {\n  const propertyAttributes = structuralMetadata.propertyAttributes;\n\n  if (!defined(propertyAttributes)) {\n    return;\n  }\n\n  for (let i = 0; i < propertyAttributes.length; i++) {\n    const propertyAttribute = propertyAttributes[i];\n    const properties = propertyAttribute.properties;\n    for (const propertyId in properties) {\n      if (properties.hasOwnProperty(propertyId)) {\n        const property = properties[propertyId];\n\n        // Get information about the attribute the same way as the\n        // GeometryPipelineStage to ensure we have the correct GLSL type and\n        // variable name.\n        const modelAttribute = ModelExperimentalUtility.getAttributeByName(\n          primitive,\n          property.attribute\n        );\n        const attributeInfo = ModelExperimentalUtility.getAttributeInfo(\n          modelAttribute\n        );\n\n        addPropertyAttributeProperty(\n          renderResources,\n          attributeInfo,\n          propertyId,\n          property\n        );\n      }\n    }\n  }\n}\n\nfunction addPropertyAttributeProperty(\n  renderResources,\n  attributeInfo,\n  propertyId,\n  property\n) {\n  const metadataVariable = sanitizeGlslIdentifier(propertyId);\n  const attributeVariable = attributeInfo.variableName;\n\n  // in WebGL 1, attributes must have floating point components, so it's safe\n  // to assume here that the types will match. Even if the property was\n  // normalized, this is handled at upload time, not in the shader.\n  const glslType = attributeInfo.glslType;\n\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  // declare the struct field, e.g.\n  // struct Metadata {\n  //   float property;\n  // }\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_VS,\n    glslType,\n    metadataVariable\n  );\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_FS,\n    glslType,\n    metadataVariable\n  );\n\n  let unpackedValue = `attributes.${attributeVariable}`;\n\n  // handle offset/scale transform. This wraps the GLSL expression with\n  // the czm_valueTransform() call.\n  if (property.hasValueTransform) {\n    unpackedValue = addValueTransformUniforms(unpackedValue, {\n      renderResources: renderResources,\n      glslType: glslType,\n      metadataVariable: metadataVariable,\n      shaderDestination: ShaderDestination.BOTH,\n      offset: property.offset,\n      scale: property.scale,\n    });\n  }\n\n  // assign the result to the metadata struct property.\n  // e.g. metadata.property = unpackingSteps(attributes.property);\n  const initializationLine = `metadata.${metadataVariable} = ${unpackedValue};`;\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_VS,\n    [initializationLine]\n  );\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    [initializationLine]\n  );\n}\n\nfunction processPropertyTextures(renderResources, structuralMetadata) {\n  const propertyTextures = structuralMetadata.propertyTextures;\n\n  if (!defined(propertyTextures)) {\n    return;\n  }\n\n  for (let i = 0; i < propertyTextures.length; i++) {\n    const propertyTexture = propertyTextures[i];\n\n    const properties = propertyTexture.properties;\n    for (const propertyId in properties) {\n      if (properties.hasOwnProperty(propertyId)) {\n        const property = properties[propertyId];\n        if (property.isGpuCompatible()) {\n          addPropertyTextureProperty(renderResources, propertyId, property);\n        }\n      }\n    }\n  }\n}\n\nfunction addPropertyTextureProperty(renderResources, propertyId, property) {\n  // Property texture properties may share the same physical texture, so only\n  // add the texture uniform the first time we encounter it.\n  const textureReader = property.textureReader;\n  const textureIndex = textureReader.index;\n  const textureUniformName = `u_propertyTexture_${textureIndex}`;\n  if (!renderResources.uniformMap.hasOwnProperty(textureUniformName)) {\n    addPropertyTextureUniform(\n      renderResources,\n      textureUniformName,\n      textureReader\n    );\n  }\n\n  const metadataVariable = sanitizeGlslIdentifier(propertyId);\n  const glslType = property.getGlslType();\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addStructField(\n    MetadataPipelineStage.STRUCT_ID_METADATA_FS,\n    glslType,\n    metadataVariable\n  );\n\n  const texCoord = textureReader.texCoord;\n  const texCoordVariable = `attributes.texCoord_${texCoord}`;\n  const channels = textureReader.channels;\n  let unpackedValue = `texture2D(${textureUniformName}, ${texCoordVariable}).${channels}`;\n\n  // Some types need an unpacking step or two. For example, since texture reads\n  // are always normalized, UINT8 (not normalized) properties need to be\n  // un-normalized in the shader.\n  unpackedValue = property.unpackInShader(unpackedValue);\n\n  // handle offset/scale transform. This wraps the GLSL expression with\n  // the czm_valueTransform() call.\n  if (property.hasValueTransform) {\n    unpackedValue = addValueTransformUniforms(unpackedValue, {\n      renderResources: renderResources,\n      glslType: glslType,\n      metadataVariable: metadataVariable,\n      shaderDestination: ShaderDestination.FRAGMENT,\n      offset: property.offset,\n      scale: property.scale,\n    });\n  }\n\n  const initializationLine = `metadata.${metadataVariable} = ${unpackedValue};`;\n  shaderBuilder.addFunctionLines(\n    MetadataPipelineStage.FUNCTION_ID_INITIALIZE_METADATA_FS,\n    [initializationLine]\n  );\n}\n\nfunction addPropertyTextureUniform(\n  renderResources,\n  uniformName,\n  textureReader\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    uniformName,\n    ShaderDestination.FRAGMENT\n  );\n\n  const uniformMap = renderResources.uniformMap;\n  uniformMap[uniformName] = function () {\n    return textureReader.texture;\n  };\n}\n\nfunction addValueTransformUniforms(valueExpression, options) {\n  const metadataVariable = options.metadataVariable;\n  const offsetUniformName = `u_${metadataVariable}_offset`;\n  const scaleUniformName = `u_${metadataVariable}_scale`;\n\n  const renderResources = options.renderResources;\n  const shaderBuilder = renderResources.shaderBuilder;\n  const glslType = options.glslType;\n  const shaderDestination = options.shaderDestination;\n  shaderBuilder.addUniform(glslType, offsetUniformName, shaderDestination);\n  shaderBuilder.addUniform(glslType, scaleUniformName, shaderDestination);\n\n  const uniformMap = renderResources.uniformMap;\n  uniformMap[offsetUniformName] = function () {\n    return options.offset;\n  };\n  uniformMap[scaleUniformName] = function () {\n    return options.scale;\n  };\n\n  return `czm_valueTransform(${offsetUniformName}, ${scaleUniformName}, ${valueExpression})`;\n}\n\nfunction sanitizeGlslIdentifier(identifier) {\n  // for use in the shader, the property ID must be a valid GLSL identifier,\n  // so replace invalid characters with _\n  return identifier.replaceAll(/[^_a-zA-Z0-9]+/g, \"_\");\n}\n\nexport default MetadataPipelineStage;\n","/**\n * Options for configuring the {@link AlphaPipelineStage}\n *\n * @alias ModelAlphaOptions\n * @constructor\n *\n * @private\n */\nexport default function ModelAlphaOptions() {\n  /**\n   * Which render pass will render the model.\n   *\n   * @type {Pass}\n   * @private\n   */\n  this.pass = undefined;\n  /**\n   * Which method to use for handling the alpha channel in the fragment shader.\n   *\n   * @type {AlphaMode}\n   * @private\n   */\n  this.alphaMode = undefined;\n  /**\n   * When the alpha mode is MASK, this determines the alpha threshold\n   * below which fragments are discarded\n   *\n   * @type {Number}\n   * @private\n   */\n  this.alphaCutoff = undefined;\n}\n","import Cartesian2 from \"../../Core/Cartesian2.js\";\nimport ClippingPlaneCollection from \"../ClippingPlaneCollection.js\";\nimport combine from \"../../Core/combine.js\";\nimport Color from \"../../Core/Color.js\";\nimport ModelClippingPlanesStageFS from \"../../Shaders/ModelExperimental/ModelClippingPlanesStageFS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\n/**\n * The model clipping planes stage is responsible for applying clipping planes to the model.\n *\n * @namespace ModelClippingPlanesPipelineStage\n *\n * @private\n */\nconst ModelClippingPlanesPipelineStage = {};\nModelClippingPlanesPipelineStage.name = \"ModelClippingPlanesPipelineStage\"; // Helps with debugging\n\nconst textureResolutionScratch = new Cartesian2();\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the fragment shader to indicate that the model has clipping planes</li>\n *  <li>adds the defines to the fragment shader for parameters related to clipping planes, such as the number of planes</li>\n *  <li>adds a function to the fragment shader to apply the clipping planes to the model's base color</li>\n *  <li>adds the uniforms for the fragment shader for the clipping plane texture and matrix</li>\n *</ul>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {ModelExperimental} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelClippingPlanesPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState\n) {\n  const clippingPlanes = model.clippingPlanes;\n  const context = frameState.context;\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_CLIPPING_PLANES\",\n    undefined,\n    ShaderDestination.FRAGMENT\n  );\n\n  shaderBuilder.addDefine(\n    \"CLIPPING_PLANES_LENGTH\",\n    clippingPlanes.length,\n    ShaderDestination.FRAGMENT\n  );\n\n  if (clippingPlanes.unionClippingRegions) {\n    shaderBuilder.addDefine(\n      \"UNION_CLIPPING_REGIONS\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  if (ClippingPlaneCollection.useFloatTexture(context)) {\n    shaderBuilder.addDefine(\n      \"USE_CLIPPING_PLANES_FLOAT_TEXTURE\",\n      undefined,\n      ShaderDestination.FRAGMENT\n    );\n  }\n\n  const textureResolution = ClippingPlaneCollection.getTextureResolution(\n    clippingPlanes,\n    context,\n    textureResolutionScratch\n  );\n\n  shaderBuilder.addDefine(\n    \"CLIPPING_PLANES_TEXTURE_WIDTH\",\n    textureResolution.x,\n    ShaderDestination.FRAGMENT\n  );\n\n  shaderBuilder.addDefine(\n    \"CLIPPING_PLANES_TEXTURE_HEIGHT\",\n    textureResolution.y,\n    ShaderDestination.FRAGMENT\n  );\n\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    \"model_clippingPlanes\",\n    ShaderDestination.FRAGMENT\n  );\n  shaderBuilder.addUniform(\n    \"vec4\",\n    \"model_clippingPlanesEdgeStyle\",\n    ShaderDestination.FRAGMENT\n  );\n  shaderBuilder.addUniform(\n    \"mat4\",\n    \"model_clippingPlanesMatrix\",\n    ShaderDestination.FRAGMENT\n  );\n\n  shaderBuilder.addFragmentLines([ModelClippingPlanesStageFS]);\n\n  const uniformMap = {\n    model_clippingPlanes: function () {\n      return clippingPlanes.texture;\n    },\n    model_clippingPlanesEdgeStyle: function () {\n      const style = Color.clone(clippingPlanes.edgeColor);\n      style.alpha = clippingPlanes.edgeWidth;\n      return style;\n    },\n    model_clippingPlanesMatrix: function () {\n      return model._clippingPlanesMatrix;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nexport default ModelClippingPlanesPipelineStage;\n","import AlphaMode from \"../AlphaMode.js\";\nimport ColorBlendMode from \"../ColorBlendMode.js\";\nimport combine from \"../../Core/combine.js\";\nimport ModelColorStageFS from \"../../Shaders/ModelExperimental/ModelColorStageFS.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\n/**\n * The model color pipeline stage is responsible for handling the application of a static color to the model.\n *\n * @namespace ModelColorPipelineStage\n *\n * @private\n */\nconst ModelColorPipelineStage = {};\nModelColorPipelineStage.name = \"ModelColorPipelineStage\"; // Helps with debugging\n\nModelColorPipelineStage.COLOR_UNIFORM_NAME = \"model_color\";\nModelColorPipelineStage.COLOR_BLEND_UNIFORM_NAME = \"model_colorBlend\";\n\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the fragment shader to indicate that the model has a color</li>\n *  <li>adds a function to the fragment shader to apply the color to the model's base color</li>\n *  <li>adds the uniforms for the fragment shader for the model's color and blending properties</li>\n *  <li>updates the pass type in the render resources based on translucency of the model's color</li>\n *</ul>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {ModelExperimental} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelColorPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_MODEL_COLOR\",\n    undefined,\n    ShaderDestination.FRAGMENT\n  );\n  shaderBuilder.addFragmentLines([ModelColorStageFS]);\n\n  const stageUniforms = {};\n\n  // Pass the model's color as a uniform. Set the pass type to translucent, if needed.\n  const color = model.color;\n  const renderStateOptions = renderResources.renderStateOptions;\n  if (color.alpha === 0.0) {\n    // When the model is invisible, disable color and depth writes, but still write into the stencil buffer.\n    renderStateOptions.colorMask = {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    };\n    renderStateOptions.depthMask = false;\n  } else if (color.alpha < 1.0) {\n    renderResources.alphaOptions.pass = Pass.TRANSLUCENT;\n    renderResources.alphaOptions.alphaMode = AlphaMode.BLEND;\n  }\n\n  shaderBuilder.addUniform(\n    \"vec4\",\n    ModelColorPipelineStage.COLOR_UNIFORM_NAME,\n    ShaderDestination.FRAGMENT\n  );\n  stageUniforms[ModelColorPipelineStage.COLOR_UNIFORM_NAME] = function () {\n    return model.color;\n  };\n\n  // Create a colorBlend from the model's colorBlendMode and colorBlendAmount and pass it as a uniform.\n  shaderBuilder.addUniform(\n    \"float\",\n    ModelColorPipelineStage.COLOR_BLEND_UNIFORM_NAME,\n    ShaderDestination.FRAGMENT\n  );\n  stageUniforms[\n    ModelColorPipelineStage.COLOR_BLEND_UNIFORM_NAME\n  ] = function () {\n    return ColorBlendMode.getColorBlend(\n      model.colorBlendMode,\n      model.colorBlendAmount\n    );\n  };\n\n  renderResources.uniformMap = combine(\n    stageUniforms,\n    renderResources.uniformMap\n  );\n};\n\nexport default ModelColorPipelineStage;\n","import BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Cartographic from \"../../Core/Cartographic.js\";\nimport Check from \"../../Core/Check.js\";\nimport ColorBlendMode from \"../ColorBlendMode.js\";\nimport ClippingPlaneCollection from \"../ClippingPlaneCollection.js\";\nimport defined from \"../../Core/defined.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport GltfLoader from \"../GltfLoader.js\";\nimport ImageBasedLighting from \"../ImageBasedLighting.js\";\nimport ModelExperimentalAnimationCollection from \"./ModelExperimentalAnimationCollection.js\";\nimport ModelExperimentalSceneGraph from \"./ModelExperimentalSceneGraph.js\";\nimport ModelExperimentalType from \"./ModelExperimentalType.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport Resource from \"../../Core/Resource.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelFeatureTable from \"./ModelFeatureTable.js\";\nimport PointCloudShading from \"../PointCloudShading.js\";\nimport B3dmLoader from \"./B3dmLoader.js\";\nimport GeoJsonLoader from \"./GeoJsonLoader.js\";\nimport I3dmLoader from \"./I3dmLoader.js\";\nimport PntsLoader from \"./PntsLoader.js\";\nimport Color from \"../../Core/Color.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShadowMode from \"../ShadowMode.js\";\nimport SplitDirection from \"../SplitDirection.js\";\n\n/**\n * A 3D model. This is a new architecture that is more decoupled than the older {@link Model}. This class is still experimental.\n * <p>\n * Do not call this function directly, instead use the `from` functions to create\n * the Model from your source data type.\n * </p>\n *\n * @alias ModelExperimental\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource} options.resource The Resource to the 3D model.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY]  The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.enableDebugWireframe=false] For debugging only. This must be set to true for debugWireframe to work in WebGL1. This cannot be set after the model has loaded.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe. Will only work for WebGL1 if enableDebugWireframe is set to true.\n * @param {Boolean} [options.cull=true]  Whether or not to cull the model using frustum/horizon culling. If the model is part of a 3D Tiles tileset, this property will always be false, since the 3D Tiles culling system is used.\n * @param {Boolean} [options.opaquePass=Pass.OPAQUE] The pass to use in the {@link DrawCommand} for the opaque portions of the model.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each primitive is pickable with {@link Scene#pick}.\n * @param {CustomShader} [options.customShader] A custom shader. This will add user-defined GLSL code to the vertex and fragment shaders. Using custom shaders with a {@link Cesium3DTileStyle} may lead to undefined behavior.\n * @param {Cesium3DTileContent} [options.content] The tile content this model belongs to. This property will be undefined if model is not loaded as part of a tileset.\n * @param {Boolean} [options.show=true] Whether or not to render the model.\n * @param {Color} [options.color] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {String|Number} [options.featureIdLabel=\"featureId_0\"] Label of the feature ID set to use for picking and styling. For EXT_mesh_features, this is the feature ID's label property, or \"featureId_N\" (where N is the index in the featureIds array) when not specified. EXT_feature_metadata did not have a label field, so such feature ID sets are always labeled \"featureId_N\" where N is the index in the list of all feature Ids, where feature ID attributes are listed before feature ID textures. If featureIdLabel is an integer N, it is converted to the string \"featureId_N\" automatically. If both per-primitive and per-instance feature IDs are present, the instance feature IDs take priority.\n * @param {String|Number} [options.instanceFeatureIdLabel=\"instanceFeatureId_0\"] Label of the instance feature ID set used for picking and styling. If instanceFeatureIdLabel is set to an integer N, it is converted to the string \"instanceFeatureId_N\" automatically. If both per-primitive and per-instance feature IDs are present, the instance feature IDs take priority.\n * @param {Object} [options.pointCloudShading] Options for constructing a {@link PointCloudShading} object to control point attenuation based on geometric error and lighting.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Cartesian3} [options.lightColor] The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n * @param {ImageBasedLighting} [options.imageBasedLighting] The properties for managing image-based lighting on this model.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the material's doubleSided property; when false, back face culling is disabled. Back faces are not culled if the model's color is translucent.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.showCreditsOnScreen=false] Whether to display the credits of this model on screen.\n * @param {SplitDirection} [options.splitDirection=SplitDirection.NONE] The {@link SplitDirection} split to apply to this model.\n * @param {Boolean} [options.projectTo2D=false] Whether to accurately project the model's positions in 2D. If a model is part of a 3D Tiles tileset, this will always be true. If this is false, the model will show up in 2D / CV mode but its positions may be inaccurate. This disables minimumPixelSize and prevents future modification to its model matrix. This also cannot be set after the model has loaded.\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function ModelExperimental(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.loader\", options.loader);\n  Check.typeOf.object(\"options.resource\", options.resource);\n  //>>includeEnd('debug');\n\n  /**\n   * The loader used to load resources for this model.\n   * The corresponding constructor parameter is undocumented, since\n   * ResourceLoader is part of the private API.\n   *\n   * @type {ResourceLoader}\n   * @private\n   */\n  this._loader = options.loader;\n  this._resource = options.resource;\n\n  /**\n   * Type of this model, to distinguish individual glTF files from 3D Tiles\n   * internally. The corresponding constructor parameter is undocumented, since\n   * ModelExperimentalType is part of the private API.\n   *\n   * @type {ModelExperimentalType}\n   * @private\n   * @readonly\n   */\n  this.type = defaultValue(options.type, ModelExperimentalType.GLTF);\n\n  /**\n   * The 4x4 transformation matrix that transforms the model from model to world coordinates.\n   * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's Cartesian WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n  this._scale = defaultValue(options.scale, 1.0);\n\n  this._minimumPixelSize = defaultValue(options.minimumPixelSize, 0.0);\n\n  this._maximumScale = options.maximumScale;\n\n  /**\n   * The scale value after being clamped by the maximum scale parameter.\n   * Used to adjust bounding spheres without repeated calculation.\n   *\n   * @type {Number}\n   * @private\n   */\n  this._clampedScale = defined(this._maximumScale)\n    ? Math.min(this._scale, this._maximumScale)\n    : this._scale;\n\n  this._computedScale = this._clampedScale;\n\n  /**\n   * Whether or not the ModelExperimentalSceneGraph should call updateModelMatrix.\n   * This will be true if any of the model matrix, scale, minimum pixel size, or maximum scale are dirty.\n   *\n   * @type {Number}\n   * @private\n   */\n  this._updateModelMatrix = false;\n\n  /**\n   * If defined, this matrix is used to transform miscellaneous properties like\n   * clipping planes and image-based lighting instead of the modelMatrix. This is\n   * so that when models are part of a tileset, these properties get transformed\n   * relative to a common reference (such as the root).\n   *\n   * @type {Matrix4}\n   * @private\n   */\n  this.referenceMatrix = undefined;\n  this._iblReferenceFrameMatrix = Matrix3.clone(Matrix3.IDENTITY); // Derived from reference matrix and the current view matrix\n\n  this._resourcesLoaded = false;\n  this._drawCommandsBuilt = false;\n\n  this._ready = false;\n  this._customShader = options.customShader;\n  this._content = options.content;\n\n  this._texturesLoaded = false;\n  this._defaultTexture = undefined;\n\n  this._activeAnimations = new ModelExperimentalAnimationCollection(this);\n  this._clampAnimations = defaultValue(options.clampAnimations, true);\n\n  const color = options.color;\n  this._color = defaultValue(color) ? Color.clone(color) : undefined;\n  this._colorBlendMode = defaultValue(\n    options.colorBlendMode,\n    ColorBlendMode.HIGHLIGHT\n  );\n  this._colorBlendAmount = defaultValue(options.colorBlendAmount, 0.5);\n\n  this._cull = defaultValue(options.cull, true);\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._show = defaultValue(options.show, true);\n\n  this._style = undefined;\n\n  let featureIdLabel = defaultValue(options.featureIdLabel, \"featureId_0\");\n  if (typeof featureIdLabel === \"number\") {\n    featureIdLabel = `featureId_${featureIdLabel}`;\n  }\n  this._featureIdLabel = featureIdLabel;\n\n  let instanceFeatureIdLabel = defaultValue(\n    options.instanceFeatureIdLabel,\n    \"instanceFeatureId_0\"\n  );\n  if (typeof instanceFeatureIdLabel === \"number\") {\n    instanceFeatureIdLabel = `instanceFeatureId_${instanceFeatureIdLabel}`;\n  }\n  this._instanceFeatureIdLabel = instanceFeatureIdLabel;\n\n  this._featureTables = [];\n  this._featureTableId = undefined;\n  this._featureTableIdDirty = true;\n\n  // Keeps track of resources that need to be destroyed when the draw commands are reset.\n  this._resources = [];\n\n  // Keeps track of resources that need to be destroyed when the Model is destroyed.\n  this._modelResources = [];\n\n  // Computation of the model's bounding sphere and its initial radius is done in ModelExperimentalSceneGraph\n  this._boundingSphere = new BoundingSphere();\n  this._initialRadius = undefined;\n\n  const pointCloudShading = new PointCloudShading(options.pointCloudShading);\n  this._attenuation = pointCloudShading.attenuation;\n  this._pointCloudShading = pointCloudShading;\n\n  // If the given clipping planes don't have an owner, make this model its owner.\n  // Otherwise, the clipping planes are passed down from a tileset.\n  const clippingPlanes = options.clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.owner === undefined) {\n    ClippingPlaneCollection.setOwner(clippingPlanes, this, \"_clippingPlanes\");\n  } else {\n    this._clippingPlanes = clippingPlanes;\n  }\n  this._clippingPlanesState = 0; // If this value changes, the shaders need to be regenerated.\n  this._clippingPlanesMatrix = Matrix4.clone(Matrix4.IDENTITY); // Derived from reference matrix and the current view matrix\n\n  this._lightColor = Cartesian3.clone(options.lightColor);\n\n  this._imageBasedLighting = defined(options.imageBasedLighting)\n    ? options.imageBasedLighting\n    : new ImageBasedLighting();\n  this._shouldDestroyImageBasedLighting = !defined(options.imageBasedLighting);\n\n  this._backFaceCulling = defaultValue(options.backFaceCulling, true);\n  this._backFaceCullingDirty = false;\n\n  this._shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadowsDirty = false;\n\n  this._debugShowBoundingVolumeDirty = false;\n  this._debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  this._enableDebugWireframe = defaultValue(\n    options.enableDebugWireframe,\n    false\n  );\n  this._debugWireframe = defaultValue(options.debugWireframe, false);\n\n  this._showCreditsOnScreen = defaultValue(options.showCreditsOnScreen, false);\n\n  this._splitDirection = defaultValue(\n    options.splitDirection,\n    SplitDirection.NONE\n  );\n\n  this._sceneMode = undefined;\n  this._projectTo2D = defaultValue(options.projectTo2D, false);\n\n  this._completeLoad = function (model, frameState) {};\n  this._texturesLoadedPromise = undefined;\n  this._readyPromise = initialize(this);\n}\n\nfunction createModelFeatureTables(model, structuralMetadata) {\n  const featureTables = model._featureTables;\n\n  const propertyTables = structuralMetadata.propertyTables;\n  for (let i = 0; i < propertyTables.length; i++) {\n    const propertyTable = propertyTables[i];\n    const modelFeatureTable = new ModelFeatureTable({\n      model: model,\n      propertyTable: propertyTable,\n    });\n\n    featureTables.push(modelFeatureTable);\n  }\n\n  return featureTables;\n}\n\nfunction selectFeatureTableId(components, model) {\n  const featureIdLabel = model._featureIdLabel;\n  const instanceFeatureIdLabel = model._instanceFeatureIdLabel;\n\n  let i, j;\n  let featureIdAttribute;\n\n  let node;\n  // Scan the nodes till we find one with instances, get the feature table ID\n  // if the feature ID attribute of the user-selected index is present.\n  for (i = 0; i < components.nodes.length; i++) {\n    node = components.nodes[i];\n    if (defined(node.instances)) {\n      featureIdAttribute = ModelExperimentalUtility.getFeatureIdsByLabel(\n        node.instances.featureIds,\n        instanceFeatureIdLabel\n      );\n      if (\n        defined(featureIdAttribute) &&\n        defined(featureIdAttribute.propertyTableId)\n      ) {\n        return featureIdAttribute.propertyTableId;\n      }\n    }\n  }\n\n  // Scan the primitives till we find one with textures or attributes, get the feature table ID\n  // if the feature ID attribute/texture of the user-selected index is present.\n  for (i = 0; i < components.nodes.length; i++) {\n    node = components.nodes[i];\n    for (j = 0; j < node.primitives.length; j++) {\n      const primitive = node.primitives[j];\n      const featureIds = ModelExperimentalUtility.getFeatureIdsByLabel(\n        primitive.featureIds,\n        featureIdLabel\n      );\n\n      if (defined(featureIds)) {\n        return featureIds.propertyTableId;\n      }\n    }\n  }\n}\n\nfunction initialize(model) {\n  const loader = model._loader;\n  const resource = model._resource;\n\n  loader.load();\n\n  const loaderPromise = loader.promise.then(function (loader) {\n    const components = loader.components;\n    const structuralMetadata = components.structuralMetadata;\n\n    if (\n      defined(structuralMetadata) &&\n      structuralMetadata.propertyTableCount > 0\n    ) {\n      createModelFeatureTables(model, structuralMetadata);\n    }\n\n    model._sceneGraph = new ModelExperimentalSceneGraph({\n      model: model,\n      modelComponents: components,\n    });\n    model._resourcesLoaded = true;\n  });\n\n  // Transcoded .pnts models do not have textures\n  const texturesLoadedPromise = defaultValue(\n    loader.texturesLoadedPromise,\n    Promise.resolve()\n  );\n  model._texturesLoadedPromise = texturesLoadedPromise\n    .then(function () {\n      model._texturesLoaded = true;\n    })\n    .catch(\n      ModelExperimentalUtility.getFailedLoadFunction(model, \"model\", resource)\n    );\n\n  const promise = new Promise(function (resolve, reject) {\n    model._completeLoad = function (model, frameState) {\n      // Set the model as ready after the first frame render since the user might set up events subscribed to\n      // the post render event, and the model may not be ready for those past the first frame.\n      frameState.afterRender.push(function () {\n        model._ready = true;\n        resolve(model);\n      });\n    };\n  });\n\n  return loaderPromise\n    .then(function () {\n      return promise;\n    })\n    .catch(\n      ModelExperimentalUtility.getFailedLoadFunction(model, \"model\", resource)\n    );\n}\n\nObject.defineProperties(ModelExperimental.prototype, {\n  /**\n   * When <code>true</code>, this model is ready to render, i.e., the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.  This is set to\n   * <code>true</code> right before {@link ModelExperimental#readyPromise} is resolved.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets the promise that will be resolved when this model is ready to render, i.e. when the external resources\n   * have been downloaded and the WebGL resources are created.\n   * <p>\n   * This promise is resolved at the end of the frame before the first frame the model is rendered in.\n   * </p>\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Promise.<ModelExperimental>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * A promise that resolves when all textures are loaded.\n   * When <code>incrementallyLoadTextures</code> is true this may resolve after\n   * <code>promise</code> resolves.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Promise<void>}\n   * @readonly\n   *\n   * @private\n   */\n  texturesLoadedPromise: {\n    get: function () {\n      return this._texturesLoadedPromise;\n    },\n  },\n\n  /**\n   * @private\n   */\n  loader: {\n    get: function () {\n      return this._loader;\n    },\n  },\n\n  /**\n   * The currently playing glTF animations.\n   *\n   * @memberof ModelExperimental.prototype\n   * @type {ModelExperimentalAnimationCollection}\n   * @readonly\n   */\n  activeAnimations: {\n    get: function () {\n      return this._activeAnimations;\n    },\n  },\n\n  /**\n   * Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n   *\n   * @memberof ModelExperimental.prototype\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  clampAnimations: {\n    get: function () {\n      return this._clampAnimations;\n    },\n    set: function (value) {\n      this._clampAnimations = value;\n    },\n  },\n\n  /**\n   * Whether or not to cull the model using frustum/horizon culling. If the model is part of a 3D Tiles tileset, this property\n   * will always be false, since the 3D Tiles culling system is used.\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  cull: {\n    get: function () {\n      return this._cull;\n    },\n  },\n\n  /**\n   * The pass to use in the {@link DrawCommand} for the opaque portions of the model.\n   *\n   * @type {Pass}\n   * @readonly\n   *\n   * @private\n   */\n  opaquePass: {\n    get: function () {\n      return this._opaquePass;\n    },\n  },\n\n  /**\n   * Point cloud shading settings for controlling point cloud attenuation\n   * and lighting. For 3D Tiles, this is inherited from the\n   * {@link Cesium3DTileset}.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {PointCloudShading}\n   */\n  pointCloudShading: {\n    get: function () {\n      return this._pointCloudShading;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"pointCloudShading\", value);\n      //>>includeEnd('debug');\n      if (value !== this._pointCloudShading) {\n        this.resetDrawCommands();\n      }\n      this._pointCloudShading = value;\n    },\n  },\n\n  /**\n   * The model's custom shader, if it exists. Using custom shaders with a {@link Cesium3DTileStyle}\n   * may lead to undefined behavior.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {CustomShader}\n   */\n  customShader: {\n    get: function () {\n      return this._customShader;\n    },\n    set: function (value) {\n      if (value !== this._customShader) {\n        this.resetDrawCommands();\n      }\n      this._customShader = value;\n    },\n  },\n\n  /**\n   * The scene graph of this model.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {ModelExperimentalSceneGraph}\n   * @private\n   */\n  sceneGraph: {\n    get: function () {\n      return this._sceneGraph;\n    },\n  },\n\n  /**\n   * The tile content this model belongs to, if it is loaded as part of a {@link Cesium3DTileset}.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Cesium3DTileContent}\n   * @readonly\n   *\n   * @private\n   */\n  content: {\n    get: function () {\n      return this._content;\n    },\n  },\n\n  /**\n   * The structural metadata from the EXT_structural_metadata extension\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {StructuralMetadata}\n   * @readonly\n   * @private\n   */\n  structuralMetadata: {\n    get: function () {\n      return this._sceneGraph.components.structuralMetadata;\n    },\n  },\n\n  /**\n   * The ID for the feature table to use for picking and styling in this model.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Number}\n   *\n   * @private\n   */\n  featureTableId: {\n    get: function () {\n      return this._featureTableId;\n    },\n    set: function (value) {\n      this._featureTableId = value;\n    },\n  },\n\n  /**\n   * The feature tables for this model.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Array}\n   * @readonly\n   *\n   * @private\n   */\n  featureTables: {\n    get: function () {\n      return this._featureTables;\n    },\n    set: function (value) {\n      this._featureTables = value;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each primitive is pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n\n  /**\n   * The style to apply the to the features in the model. Cannot be applied if a {@link CustomShader} is also applied.\n   *\n   * @type {Cesium3DTileStyle}\n   */\n  style: {\n    get: function () {\n      return this._style;\n    },\n    set: function (value) {\n      if (value !== this._style) {\n        this.applyStyle(value);\n      }\n      this._style = value;\n    },\n  },\n\n  /**\n   * The color to blend with the model's rendered color.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Color}\n   */\n  color: {\n    get: function () {\n      return this._color;\n    },\n    set: function (value) {\n      if (!Color.equals(this._color, value)) {\n        this.resetDrawCommands();\n      }\n      this._color = Color.clone(value, this._color);\n    },\n  },\n\n  /**\n   * Defines how the color blends with the model.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Cesium3DTileColorBlendMode|ColorBlendMode}\n   * @default ColorBlendMode.HIGHLIGHT\n   */\n  colorBlendMode: {\n    get: function () {\n      return this._colorBlendMode;\n    },\n    set: function (value) {\n      this._colorBlendMode = value;\n    },\n  },\n\n  /**\n   * Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Number}\n   * @default 0.5\n   */\n  colorBlendAmount: {\n    get: function () {\n      return this._colorBlendAmount;\n    },\n    set: function (value) {\n      this._colorBlendAmount = value;\n    },\n  },\n\n  /**\n   * Gets the model's bounding sphere in world space. This does not take into account\n   * glTF animations, skins, or morph targets. It also does not account for\n   * {@link ModelExperimental#minimumPixelSize}.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"The model is not loaded. Use ModelExperimental.readyPromise or wait for ModelExperimental.ready to be true.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._boundingSphere;\n    },\n  },\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the model.\n   * </p>\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  debugShowBoundingVolume: {\n    get: function () {\n      return this._debugShowBoundingVolume;\n    },\n    set: function (value) {\n      if (this._debugShowBoundingVolume !== value) {\n        this._debugShowBoundingVolumeDirty = true;\n      }\n      this._debugShowBoundingVolume = value;\n    },\n  },\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the model in wireframe.\n   * </p>\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  debugWireframe: {\n    get: function () {\n      return this._debugWireframe;\n    },\n    set: function (value) {\n      if (this._debugWireframe !== value) {\n        this.resetDrawCommands();\n      }\n      this._debugWireframe = value;\n    },\n  },\n\n  /**\n   * Whether or not to render the model.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      this._show = value;\n    },\n  },\n\n  /**\n   * Label of the feature ID set to use for picking and styling.\n   * <p>\n   * For EXT_mesh_features, this is the feature ID's label property, or\n   * \"featureId_N\" (where N is the index in the featureIds array) when not\n   * specified. EXT_feature_metadata did not have a label field, so such\n   * feature ID sets are always labeled \"featureId_N\" where N is the index in\n   * the list of all feature Ids, where feature ID attributes are listed before\n   * feature ID textures.\n   * </p>\n   * <p>\n   * If featureIdLabel is set to an integer N, it is converted to\n   * the string \"featureId_N\" automatically. If both per-primitive and\n   * per-instance feature IDs are present, the instance feature IDs take\n   * priority.\n   * </p>\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {String}\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  featureIdLabel: {\n    get: function () {\n      return this._featureIdLabel;\n    },\n    set: function (value) {\n      // indices get converted into featureId_N\n      if (typeof value === \"number\") {\n        value = `featureId_${value}`;\n      }\n\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.string(\"value\", value);\n      //>>includeEnd('debug');\n\n      if (value !== this._featureIdLabel) {\n        this._featureTableIdDirty = true;\n      }\n\n      this._featureIdLabel = value;\n    },\n  },\n\n  /**\n   * Label of the instance feature ID set used for picking and styling.\n   * <p>\n   * If instanceFeatureIdLabel is set to an integer N, it is converted to\n   * the string \"instanceFeatureId_N\" automatically.\n   * If both per-primitive and per-instance feature IDs are present, the\n   * instance feature IDs take priority.\n   * </p>\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {String}\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  instanceFeatureIdLabel: {\n    get: function () {\n      return this._instanceFeatureIdLabel;\n    },\n    set: function (value) {\n      // indices get converted into instanceFeatureId_N\n      if (typeof value === \"number\") {\n        value = `instanceFeatureId_${value}`;\n      }\n\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.string(\"value\", value);\n      //>>includeEnd('debug');\n\n      if (value !== this._instanceFeatureIdLabel) {\n        this._featureTableIdDirty = true;\n      }\n\n      this._instanceFeatureIdLabel = value;\n    },\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      if (value !== this._clippingPlanes) {\n        // Handle destroying old clipping planes, new clipping planes ownership\n        ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n        this.resetDrawCommands();\n      }\n    },\n  },\n\n  /**\n   * The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n   * <p>\n   * Disabling additional light sources by setting\n   * <code>model.imageBasedLighting.imageBasedLightingFactor = new Cartesian2(0.0, 0.0)</code>\n   * will make the model much darker. Here, increasing the intensity of the light source will make the model brighter.\n   * </p>\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    },\n    set: function (value) {\n      if (defined(value) !== defined(this._lightColor)) {\n        this.resetDrawCommands();\n      }\n\n      this._lightColor = Cartesian3.clone(value, this._lightColor);\n    },\n  },\n\n  /**\n   * The properties for managing image-based lighting on this model.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {ImageBasedLighting}\n   */\n  imageBasedLighting: {\n    get: function () {\n      return this._imageBasedLighting;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLighting\", this._imageBasedLighting);\n      //>>includeEnd('debug');\n\n      if (value !== this._imageBasedLighting) {\n        if (\n          this._shouldDestroyImageBasedLighting &&\n          !this._imageBasedLighting.isDestroyed()\n        ) {\n          this._imageBasedLighting.destroy();\n        }\n        this._imageBasedLighting = value;\n        this._shouldDestroyImageBasedLighting = false;\n        this.resetDrawCommands();\n      }\n    },\n  },\n\n  /**\n   * Whether to cull back-facing geometry. When true, back face culling is\n   * determined by the material's doubleSided property; when false, back face\n   * culling is disabled. Back faces are not culled if the model's color is\n   * translucent.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  backFaceCulling: {\n    get: function () {\n      return this._backFaceCulling;\n    },\n    set: function (value) {\n      if (value !== this._backFaceCulling) {\n        this._backFaceCullingDirty = true;\n      }\n\n      this._backFaceCulling = value;\n    },\n  },\n\n  /**\n   * A uniform scale applied to this model before the {@link Model#modelMatrix}.\n   * Values greater than <code>1.0</code> increase the size of the model; values\n   * less than <code>1.0</code> decrease.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Number}\n   *\n   * @default 1.0\n   */\n  scale: {\n    get: function () {\n      return this._scale;\n    },\n    set: function (value) {\n      if (value !== this._scale) {\n        this._updateModelMatrix = true;\n      }\n      this._scale = value;\n    },\n  },\n\n  /**\n   * The true scale of the model after being affected by the model's scale,\n   * minimum pixel size, and maximum scale parameters.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Number}\n   * @private\n   */\n  computedScale: {\n    get: function () {\n      return this._computedScale;\n    },\n  },\n\n  /**\n   * The approximate minimum pixel size of the model regardless of zoom.\n   * This can be used to ensure that a model is visible even when the viewer\n   * zooms out.  When <code>0.0</code>, no minimum size is enforced.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n  minimumPixelSize: {\n    get: function () {\n      return this._minimumPixelSize;\n    },\n    set: function (value) {\n      if (value !== this._minimumPixelSize) {\n        this._updateModelMatrix = true;\n      }\n      this._minimumPixelSize = value;\n    },\n  },\n\n  /**\n   * The maximum scale size for a model. This can be used to give\n   * an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model\n   * is never an unreasonable scale.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Number}\n   */\n  maximumScale: {\n    get: function () {\n      return this._maximumScale;\n    },\n    set: function (value) {\n      if (value !== this._maximumScale) {\n        this._updateModelMatrix = true;\n      }\n      this._maximumScale = value;\n    },\n  },\n\n  /**\n   * Determines whether the model casts or receives shadows from light sources.\n\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.ENABLED\n   */\n  shadows: {\n    get: function () {\n      return this._shadows;\n    },\n    set: function (value) {\n      if (value !== this._shadows) {\n        this._shadowsDirty = true;\n      }\n\n      this._shadows = value;\n    },\n  },\n\n  /**\n   * Gets or sets whether the credits of the model will be displayed on the screen\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  showCreditsOnScreen: {\n    get: function () {\n      return this._showCreditsOnScreen;\n    },\n    set: function (value) {\n      this._showCreditsOnScreen = value;\n    },\n  },\n\n  /**\n   * The {@link SplitDirection} to apply to this model.\n   *\n   * @memberof ModelExperimental.prototype\n   *\n   * @type {SplitDirection}\n   * @default {@link SplitDirection.NONE}\n   */\n  splitDirection: {\n    get: function () {\n      return this._splitDirection;\n    },\n    set: function (value) {\n      if (this._splitDirection !== value) {\n        this.resetDrawCommands();\n      }\n      this._splitDirection = value;\n    },\n  },\n});\n\n/**\n * Resets the draw commands for this model.\n *\n * @private\n */\nModelExperimental.prototype.resetDrawCommands = function () {\n  if (!this._drawCommandsBuilt) {\n    return;\n  }\n  this.destroyResources();\n  this._drawCommandsBuilt = false;\n};\n\nconst scratchIBLReferenceFrameMatrix4 = new Matrix4();\nconst scratchIBLReferenceFrameMatrix3 = new Matrix3();\nconst scratchClippingPlanesMatrix = new Matrix4();\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Failed to load external reference.\n */\nModelExperimental.prototype.update = function (frameState) {\n  // Keep processing the model every frame until the main resources\n  // (buffer views) and textures (which may be loaded asynchronously)\n  // are processed.\n  if (!this._resourcesLoaded || !this._texturesLoaded) {\n    this._loader.process(frameState);\n  }\n\n  // A custom shader may have to load texture uniforms.\n  if (defined(this._customShader)) {\n    this._customShader.update(frameState);\n  }\n\n  // Check if the shader needs to be updated for point cloud attenuation\n  // settings.\n  if (this.pointCloudShading.attenuation !== this._attenuation) {\n    this.resetDrawCommands();\n    this._attenuation = this.pointCloudShading.attenuation;\n  }\n\n  const context = frameState.context;\n  const referenceMatrix = defaultValue(this.referenceMatrix, this.modelMatrix);\n\n  // Update the image-based lighting for this model to detect any changes in parameters.\n  this._imageBasedLighting.update(frameState);\n\n  if (\n    this._imageBasedLighting.useSphericalHarmonicCoefficients ||\n    this._imageBasedLighting.useSpecularEnvironmentMaps\n  ) {\n    let iblReferenceFrameMatrix3 = scratchIBLReferenceFrameMatrix3;\n    let iblReferenceFrameMatrix4 = scratchIBLReferenceFrameMatrix4;\n\n    iblReferenceFrameMatrix4 = Matrix4.multiply(\n      context.uniformState.view3D,\n      referenceMatrix,\n      iblReferenceFrameMatrix4\n    );\n    iblReferenceFrameMatrix3 = Matrix4.getMatrix3(\n      iblReferenceFrameMatrix4,\n      iblReferenceFrameMatrix3\n    );\n    iblReferenceFrameMatrix3 = Matrix3.getRotation(\n      iblReferenceFrameMatrix3,\n      iblReferenceFrameMatrix3\n    );\n    this._iblReferenceFrameMatrix = Matrix3.transpose(\n      iblReferenceFrameMatrix3,\n      this._iblReferenceFrameMatrix\n    );\n  }\n\n  if (this._imageBasedLighting.shouldRegenerateShaders) {\n    this.resetDrawCommands();\n  }\n\n  // Update the clipping planes collection for this model to detect any changes.\n  let currentClippingPlanesState = 0;\n  if (this.isClippingEnabled()) {\n    if (this._clippingPlanes.owner === this) {\n      this._clippingPlanes.update(frameState);\n    }\n\n    let clippingPlanesMatrix = scratchClippingPlanesMatrix;\n    clippingPlanesMatrix = Matrix4.multiply(\n      context.uniformState.view3D,\n      referenceMatrix,\n      clippingPlanesMatrix\n    );\n    clippingPlanesMatrix = Matrix4.multiply(\n      clippingPlanesMatrix,\n      this._clippingPlanes.modelMatrix,\n      clippingPlanesMatrix\n    );\n    this._clippingPlanesMatrix = Matrix4.inverseTranspose(\n      clippingPlanesMatrix,\n      this._clippingPlanesMatrix\n    );\n\n    currentClippingPlanesState = this._clippingPlanes.clippingPlanesState;\n  }\n\n  if (currentClippingPlanesState !== this._clippingPlanesState) {\n    this.resetDrawCommands();\n    this._clippingPlanesState = currentClippingPlanesState;\n  }\n\n  this._defaultTexture = context.defaultTexture;\n\n  // short-circuit if the model resources aren't ready.\n  if (!this._resourcesLoaded || frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (frameState.mode !== this._sceneMode) {\n    if (this._projectTo2D) {\n      this.resetDrawCommands();\n    } else {\n      this._updateModelMatrix = true;\n    }\n    this._sceneMode = frameState.mode;\n  }\n\n  if (this._featureTableIdDirty) {\n    updateFeatureTableId(this);\n    this._featureTableIdDirty = false;\n  }\n\n  const featureTables = this._featureTables;\n  for (let i = 0; i < featureTables.length; i++) {\n    featureTables[i].update(frameState);\n    // Check if the types of style commands needed have changed and trigger a reset of the draw commands\n    // to ensure that translucent and opaque features are handled in the correct passes.\n    if (featureTables[i].styleCommandsNeededDirty) {\n      this.resetDrawCommands();\n    }\n  }\n\n  if (!this._drawCommandsBuilt) {\n    this._sceneGraph.buildDrawCommands(frameState);\n    this._drawCommandsBuilt = true;\n\n    const model = this;\n\n    if (!model._ready) {\n      model._completeLoad(model, frameState);\n\n      // Don't render until the next frame after the ready promise is resolved\n      return;\n    }\n  }\n\n  // This is done without a dirty flag so that the model matrix can be updated in-place\n  // without needing to use a setter.\n  if (!Matrix4.equals(this.modelMatrix, this._modelMatrix)) {\n    //>>includeStart('debug', pragmas.debug);\n    if (frameState.mode !== SceneMode.SCENE3D && this._projectTo2D) {\n      throw new DeveloperError(\n        \"ModelExperimental.modelMatrix cannot be changed in 2D or Columbus View if projectTo2D is true.\"\n      );\n    }\n    //>>includeEnd('debug');\n    this._updateModelMatrix = true;\n    this._modelMatrix = Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    this._boundingSphere = BoundingSphere.transform(\n      this._sceneGraph.boundingSphere,\n      this.modelMatrix,\n      this._boundingSphere\n    );\n  }\n\n  if (this._updateModelMatrix || this._minimumPixelSize !== 0.0) {\n    this._clampedScale = defined(this._maximumScale)\n      ? Math.min(this._scale, this._maximumScale)\n      : this._scale;\n    this._boundingSphere.radius = this._initialRadius * this._clampedScale;\n    this._computedScale = getScale(this, frameState);\n    this._sceneGraph.updateModelMatrix(frameState);\n    this._updateModelMatrix = false;\n  }\n\n  if (this._backFaceCullingDirty) {\n    this.sceneGraph.updateBackFaceCulling(this._backFaceCulling);\n    this._backFaceCullingDirty = false;\n  }\n\n  if (this._shadowsDirty) {\n    this.sceneGraph.updateShadows(this._shadows);\n    this._shadowsDirty = false;\n  }\n\n  if (this._debugShowBoundingVolumeDirty) {\n    this._sceneGraph.updateShowBoundingVolume(this._debugShowBoundingVolume);\n    this._debugShowBoundingVolumeDirty = false;\n  }\n\n  const updateForAnimations = this._activeAnimations.update(frameState);\n  this._sceneGraph.update(frameState, updateForAnimations);\n\n  // Check for show here because we still want the draw commands to be built so user can instantly see the model\n  // when show is set to true.\n  if (this._show && this._computedScale !== 0) {\n    const asset = this._sceneGraph.components.asset;\n    const credits = asset.credits;\n\n    const length = credits.length;\n    for (let i = 0; i < length; i++) {\n      const credit = credits[i];\n      credit.showOnScreen = this._showCreditsOnScreen;\n      frameState.creditDisplay.addCredit(credit);\n    }\n\n    const drawCommands = this._sceneGraph.getDrawCommands(frameState);\n    frameState.commandList.push.apply(frameState.commandList, drawCommands);\n  }\n};\n\nfunction updateFeatureTableId(model) {\n  const components = model._sceneGraph.components;\n  const structuralMetadata = components.structuralMetadata;\n\n  if (\n    defined(structuralMetadata) &&\n    structuralMetadata.propertyTableCount > 0\n  ) {\n    model.featureTableId = selectFeatureTableId(components, model);\n    // Re-apply the style to reflect the new feature ID table.\n    // This in turn triggers a rebuild of the draw commands.\n    model.applyStyle(model._style);\n  }\n}\n\nconst scratchBoundingSphere = new BoundingSphere();\n\nfunction scaleInPixels(positionWC, radius, frameState) {\n  scratchBoundingSphere.center = positionWC;\n  scratchBoundingSphere.radius = radius;\n  return frameState.camera.getPixelSize(\n    scratchBoundingSphere,\n    frameState.context.drawingBufferWidth,\n    frameState.context.drawingBufferHeight\n  );\n}\n\nconst scratchPosition = new Cartesian3();\nconst scratchCartographic = new Cartographic();\n\nfunction getScale(model, frameState) {\n  let scale = model.scale;\n\n  if (model.minimumPixelSize !== 0.0 && !model._projectTo2D) {\n    // Compute size of bounding sphere in pixels\n    const context = frameState.context;\n    const maxPixelSize = Math.max(\n      context.drawingBufferWidth,\n      context.drawingBufferHeight\n    );\n    const m = model.modelMatrix;\n    scratchPosition.x = m[12];\n    scratchPosition.y = m[13];\n    scratchPosition.z = m[14];\n\n    if (model._sceneMode !== SceneMode.SCENE3D) {\n      const projection = frameState.mapProjection;\n      const cartographic = projection.ellipsoid.cartesianToCartographic(\n        scratchPosition,\n        scratchCartographic\n      );\n      projection.project(cartographic, scratchPosition);\n\n      // In 2D / CV mode, the map is a yz-plane in world space, so the coordinates\n      // need to be reordered accordingly.\n      Cartesian3.fromElements(\n        scratchPosition.z,\n        scratchPosition.x,\n        scratchPosition.y,\n        scratchPosition\n      );\n    }\n\n    const radius = model._boundingSphere.radius;\n    const metersPerPixel = scaleInPixels(scratchPosition, radius, frameState);\n\n    // metersPerPixel is always > 0.0\n    const pixelsPerMeter = 1.0 / metersPerPixel;\n    const diameterInPixels = Math.min(\n      pixelsPerMeter * (2.0 * radius),\n      maxPixelSize\n    );\n\n    // Maintain model's minimum pixel size\n    if (diameterInPixels < model.minimumPixelSize) {\n      scale =\n        (model.minimumPixelSize * metersPerPixel) /\n        (2.0 * model._initialRadius);\n    }\n  }\n\n  return defined(model.maximumScale)\n    ? Math.min(model.maximumScale, scale)\n    : scale;\n}\n\n/**\n * Gets whether or not clipping planes are enabled for this model.\n *\n * @returns {Boolean} <code>true</code> if clipping planes are enabled for this model, <code>false</code>.\n * @private\n */\nModelExperimental.prototype.isClippingEnabled = function () {\n  const clippingPlanes = this._clippingPlanes;\n  return (\n    defined(clippingPlanes) &&\n    clippingPlanes.enabled &&\n    clippingPlanes.length !== 0\n  );\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ModelExperimental#destroy\n */\nModelExperimental.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * model = model && model.destroy();\n *\n * @see ModelExperimental#isDestroyed\n */\nModelExperimental.prototype.destroy = function () {\n  const loader = this._loader;\n  if (defined(loader)) {\n    loader.destroy();\n  }\n\n  const featureTables = this._featureTables;\n  if (defined(featureTables)) {\n    for (let i = 0; i < featureTables.length; i++) {\n      featureTables[i].destroy();\n    }\n  }\n\n  this.destroyResources();\n  this.destroyModelResources();\n\n  // Only destroy the ClippingPlaneCollection if this is the owner.\n  const clippingPlaneCollection = this._clippingPlanes;\n  if (\n    defined(clippingPlaneCollection) &&\n    !clippingPlaneCollection.isDestroyed() &&\n    clippingPlaneCollection.owner === this\n  ) {\n    clippingPlaneCollection.destroy();\n  }\n  this._clippingPlanes = undefined;\n\n  // Only destroy the ImageBasedLighting if this is the owner.\n  if (\n    this._shouldDestroyImageBasedLighting &&\n    !this._imageBasedLighting.isDestroyed()\n  ) {\n    this._imageBasedLighting.destroy();\n  }\n  this._imageBasedLighting = undefined;\n\n  destroyObject(this);\n};\n\n/**\n * Destroys resources generated in the pipeline stages.\n * @private\n */\nModelExperimental.prototype.destroyResources = function () {\n  const resources = this._resources;\n  for (let i = 0; i < resources.length; i++) {\n    resources[i].destroy();\n  }\n  this._resources = [];\n};\n\n/**\n * Destroys resources generated for the model.\n * @private\n */\nModelExperimental.prototype.destroyModelResources = function () {\n  const resources = this._modelResources;\n  for (let i = 0; i < resources.length; i++) {\n    resources[i].destroy();\n  }\n  this._modelResources = [];\n};\n\n/**\n * <p>\n * Creates a model from a glTF asset.  When the model is ready to render, i.e., when the external binary, image,\n * and shader files are downloaded and the WebGL resources are created, the {@link Model#readyPromise} is resolved.\n * </p>\n * <p>\n * The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the .glb extension.\n *\n * @param {Object} options Object with the following properties:\n * @param {String|Resource} options.url The url to the .gltf or .glb file.\n * @param {String|Resource} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.releaseGltfJson=false] When true, the glTF JSON is released once the glTF is loaded. This is is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.enableDebugWireframe=false] For debugging only. This must be set to true for debugWireframe to work in WebGL1. This cannot be set after the model has loaded.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe. Will only work for WebGL1 if enableDebugWireframe is set to true.\n * @param {Boolean} [options.cull=true]  Whether or not to cull the model using frustum/horizon culling. If the model is part of a 3D Tiles tileset, this property will always be false, since the 3D Tiles culling system is used.\n * @param {Boolean} [options.opaquePass=Pass.OPAQUE] The pass to use in the {@link DrawCommand} for the opaque portions of the model.\n * @param {Axis} [options.upAxis=Axis.Y] The up-axis of the glTF model.\n * @param {Axis} [options.forwardAxis=Axis.Z] The forward-axis of the glTF model.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each primitive is pickable with {@link Scene#pick}.\n * @param {CustomShader} [options.customShader] A custom shader. This will add user-defined GLSL code to the vertex and fragment shaders. Using custom shaders with a {@link Cesium3DTileStyle} may lead to undefined behavior.\n * @param {Cesium3DTileContent} [options.content] The tile content this model belongs to. This property will be undefined if model is not loaded as part of a tileset.\n * @param {Boolean} [options.show=true] Whether or not to render the model.\n * @param {Color} [options.color] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {String|Number} [options.featureIdLabel=\"featureId_0\"] Label of the feature ID set to use for picking and styling. For EXT_mesh_features, this is the feature ID's label property, or \"featureId_N\" (where N is the index in the featureIds array) when not specified. EXT_feature_metadata did not have a label field, so such feature ID sets are always labeled \"featureId_N\" where N is the index in the list of all feature Ids, where feature ID attributes are listed before feature ID textures. If featureIdLabel is an integer N, it is converted to the string \"featureId_N\" automatically. If both per-primitive and per-instance feature IDs are present, the instance feature IDs take priority.\n * @param {String|Number} [options.instanceFeatureIdLabel=\"instanceFeatureId_0\"] Label of the instance feature ID set used for picking and styling. If instanceFeatureIdLabel is set to an integer N, it is converted to the string \"instanceFeatureId_N\" automatically. If both per-primitive and per-instance feature IDs are present, the instance feature IDs take priority.\n * @param {Object} [options.pointCloudShading] Options for constructing a {@link PointCloudShading} object to control point attenuation and lighting.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Cartesian3} [options.lightColor] The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n * @param {ImageBasedLighting} [options.imageBasedLighting] The properties for managing image-based lighting on this model.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the material's doubleSided property; when false, back face culling is disabled. Back faces are not culled if the model's color is translucent.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.showCreditsOnScreen=false] Whether to display the credits of this model on screen.\n * @param {SplitDirection} [options.splitDirection=SplitDirection.NONE] The {@link SplitDirection} split to apply to this model.\n * @param {Boolean} [options.projectTo2D=false] Whether to accurately project the model's positions in 2D. If a model is part of a 3D Tiles tileset, this will always be true. If this is false, the model will show up in 2D / CV mode but its positions may be inaccurate. This disables minimumPixelSize and prevents future modification to its model matrix. This also cannot be set after the model has loaded.\n * @returns {ModelExperimental} The newly created model.\n */\nModelExperimental.fromGltf = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.url) && !defined(options.gltf)) {\n    throw new DeveloperError(\"options.url is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // options.gltf is used internally for 3D Tiles. It can be a Resource, a URL\n  // to a glTF/glb file, a binary glTF buffer, or a JSON object containing the\n  // glTF contents.\n  const gltf = defaultValue(options.url, options.gltf);\n\n  const loaderOptions = {\n    releaseGltfJson: options.releaseGltfJson,\n    incrementallyLoadTextures: options.incrementallyLoadTextures,\n    upAxis: options.upAxis,\n    forwardAxis: options.forwardAxis,\n    loadPositionsFor2D: options.projectTo2D,\n    loadIndicesForWireframe: options.enableDebugWireframe,\n  };\n\n  const basePath = defaultValue(options.basePath, \"\");\n  const baseResource = Resource.createIfNeeded(basePath);\n\n  if (defined(gltf.asset)) {\n    loaderOptions.gltfJson = gltf;\n    loaderOptions.baseResource = baseResource;\n    loaderOptions.gltfResource = baseResource;\n  } else if (gltf instanceof Uint8Array) {\n    loaderOptions.typedArray = gltf;\n    loaderOptions.baseResource = baseResource;\n    loaderOptions.gltfResource = baseResource;\n  } else {\n    loaderOptions.gltfResource = Resource.createIfNeeded(gltf);\n  }\n\n  const loader = new GltfLoader(loaderOptions);\n\n  const is3DTiles = defined(options.content);\n  const type = is3DTiles\n    ? ModelExperimentalType.TILE_GLTF\n    : ModelExperimentalType.GLTF;\n\n  const modelOptions = makeModelOptions(loader, type, options);\n  modelOptions.resource = loaderOptions.gltfResource;\n\n  const model = new ModelExperimental(modelOptions);\n\n  return model;\n};\n\n/*\n * @private\n */\nModelExperimental.fromB3dm = function (options) {\n  const loaderOptions = {\n    b3dmResource: options.resource,\n    arrayBuffer: options.arrayBuffer,\n    byteOffset: options.byteOffset,\n    releaseGltfJson: options.releaseGltfJson,\n    incrementallyLoadTextures: options.incrementallyLoadTextures,\n    upAxis: options.upAxis,\n    forwardAxis: options.forwardAxis,\n    loadPositionsFor2D: options.projectTo2D,\n    loadIndicesForWireframe: options.enableDebugWireframe,\n  };\n\n  const loader = new B3dmLoader(loaderOptions);\n\n  const modelOptions = makeModelOptions(\n    loader,\n    ModelExperimentalType.TILE_B3DM,\n    options\n  );\n  const model = new ModelExperimental(modelOptions);\n  return model;\n};\n\n/**\n * @private\n */\nModelExperimental.fromPnts = function (options) {\n  const loaderOptions = {\n    arrayBuffer: options.arrayBuffer,\n    byteOffset: options.byteOffset,\n  };\n  const loader = new PntsLoader(loaderOptions);\n\n  const modelOptions = makeModelOptions(\n    loader,\n    ModelExperimentalType.TILE_PNTS,\n    options\n  );\n  const model = new ModelExperimental(modelOptions);\n  return model;\n};\n\n/*\n * @private\n */\nModelExperimental.fromI3dm = function (options) {\n  const loaderOptions = {\n    i3dmResource: options.resource,\n    arrayBuffer: options.arrayBuffer,\n    byteOffset: options.byteOffset,\n    releaseGltfJson: options.releaseGltfJson,\n    incrementallyLoadTextures: options.incrementallyLoadTextures,\n    upAxis: options.upAxis,\n    forwardAxis: options.forwardAxis,\n    loadIndicesForWireframe: options.enableDebugWireframe,\n  };\n  const loader = new I3dmLoader(loaderOptions);\n\n  const modelOptions = makeModelOptions(\n    loader,\n    ModelExperimentalType.TILE_I3DM,\n    options\n  );\n  const model = new ModelExperimental(modelOptions);\n  return model;\n};\n\n/*\n * @private\n */\nModelExperimental.fromGeoJson = function (options) {\n  const loaderOptions = {\n    geoJson: options.geoJson,\n  };\n  const loader = new GeoJsonLoader(loaderOptions);\n  const modelOptions = makeModelOptions(\n    loader,\n    ModelExperimentalType.TILE_GEOJSON,\n    options\n  );\n  const model = new ModelExperimental(modelOptions);\n  return model;\n};\n\n/**\n * @private\n */\nModelExperimental.prototype.applyColorAndShow = function (style) {\n  const hasColorStyle = defined(style) && defined(style.color);\n  const hasShowStyle = defined(style) && defined(style.show);\n\n  this._color = hasColorStyle\n    ? style.color.evaluateColor(undefined, this._color)\n    : Color.clone(Color.WHITE, this._color);\n  this._show = hasShowStyle ? style.show.evaluate(undefined) : true;\n};\n\n/**\n * @private\n */\nModelExperimental.prototype.applyStyle = function (style) {\n  // The style is only set by the ModelFeatureTable. If there are no features,\n  // the color and show from the style are directly applied.\n  if (\n    defined(this.featureTableId) &&\n    this.featureTables[this.featureTableId].featuresLength > 0\n  ) {\n    const featureTable = this.featureTables[this.featureTableId];\n    featureTable.applyStyle(style);\n  } else {\n    this.applyColorAndShow(style);\n  }\n\n  this.resetDrawCommands();\n};\n\nfunction makeModelOptions(loader, modelType, options) {\n  return {\n    loader: loader,\n    type: modelType,\n    resource: options.resource,\n    modelMatrix: options.modelMatrix,\n    scale: options.scale,\n    minimumPixelSize: options.minimumPixelSize,\n    maximumScale: options.maximumScale,\n    debugShowBoundingVolume: options.debugShowBoundingVolume,\n    enableDebugWireframe: options.enableDebugWireframe,\n    debugWireframe: options.debugWireframe,\n    cull: options.cull,\n    opaquePass: options.opaquePass,\n    allowPicking: options.allowPicking,\n    customShader: options.customShader,\n    content: options.content,\n    show: options.show,\n    color: options.color,\n    colorBlendAmount: options.colorBlendAmount,\n    colorBlendMode: options.colorBlendMode,\n    featureIdLabel: options.featureIdLabel,\n    instanceFeatureIdLabel: options.instanceFeatureIdLabel,\n    pointCloudShading: options.pointCloudShading,\n    clippingPlanes: options.clippingPlanes,\n    lightColor: options.lightColor,\n    imageBasedLighting: options.imageBasedLighting,\n    backFaceCulling: options.backFaceCulling,\n    shadows: options.shadows,\n    showCreditsOnScreen: options.showCreditsOnScreen,\n    splitDirection: options.splitDirection,\n    projectTo2D: options.projectTo2D,\n  };\n}\n","import Axis from \"../Axis.js\";\nimport Color from \"../../Core/Color.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport ModelExperimental from \"./ModelExperimental.js\";\n\n/**\n * Represents the contents of a glTF, glb or\n * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/Batched3DModel|Batched 3D Model}\n * tile in a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles} tileset.\n * <p>\n * Implements the {@link Cesium3DTileContent} interface.\n * </p>\n * @alias ModelExperimental3DTileContent\n * @constructor\n * @private\n */\nexport default function ModelExperimental3DTileContent(\n  tileset,\n  tile,\n  resource\n) {\n  this._tileset = tileset;\n  this._tile = tile;\n  this._resource = resource;\n\n  this._model = undefined;\n  this._metadata = undefined;\n  this._group = undefined;\n}\n\nObject.defineProperties(ModelExperimental3DTileContent.prototype, {\n  featuresLength: {\n    get: function () {\n      const model = this._model;\n      const featureTables = model.featureTables;\n      const featureTableId = model.featureTableId;\n\n      if (defined(featureTables) && defined(featureTables[featureTableId])) {\n        return featureTables[featureTableId].featuresLength;\n      }\n\n      return 0;\n    },\n  },\n\n  pointsLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  trianglesLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  texturesByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  batchTableByteLength: {\n    get: function () {\n      return 0;\n    },\n  },\n\n  innerContents: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._model.readyPromise;\n    },\n  },\n\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n\n  url: {\n    get: function () {\n      return this._resource.getUrlComponent(true);\n    },\n  },\n\n  batchTable: {\n    get: function () {\n      const model = this._model;\n      const featureTables = model.featureTables;\n      const featureTableId = model.featureTableId;\n\n      if (defined(featureTables) && defined(featureTables[featureTableId])) {\n        return featureTables[featureTableId];\n      }\n\n      return undefined;\n    },\n  },\n\n  metadata: {\n    get: function () {\n      return this._metadata;\n    },\n    set: function (value) {\n      this._metadata = value;\n    },\n  },\n\n  group: {\n    get: function () {\n      return this._group;\n    },\n    set: function (value) {\n      this._group = value;\n    },\n  },\n});\n\nModelExperimental3DTileContent.prototype.getFeature = function (featureId) {\n  const model = this._model;\n  const featureTableId = model.featureTableId;\n  if (!defined(featureTableId)) {\n    return undefined;\n  }\n\n  const featureTable = model.featureTables[featureTableId];\n  return featureTable.getFeature(featureId);\n};\n\nModelExperimental3DTileContent.prototype.hasProperty = function (\n  featureId,\n  name\n) {\n  const model = this._model;\n  const featureTableId = model.featureTableId;\n  if (!defined(featureTableId)) {\n    return false;\n  }\n\n  const featureTable = model.featureTables[featureTableId];\n  return featureTable.hasProperty(featureId, name);\n};\n\nModelExperimental3DTileContent.prototype.applyDebugSettings = function (\n  enabled,\n  color\n) {\n  color = enabled ? color : Color.WHITE;\n  if (this.featuresLength === 0) {\n    this._model.color = color;\n  } else if (defined(this.batchTable)) {\n    this.batchTable.setAllColor(color);\n  }\n};\n\nModelExperimental3DTileContent.prototype.applyStyle = function (style) {\n  // the setter will call model.applyStyle()\n  this._model.style = style;\n};\n\nModelExperimental3DTileContent.prototype.update = function (\n  tileset,\n  frameState\n) {\n  const model = this._model;\n  const tile = this._tile;\n\n  model.colorBlendAmount = tileset.colorBlendAmount;\n  model.colorBlendMode = tileset.colorBlendMode;\n  model.modelMatrix = tile.computedTransform;\n  model.customShader = tileset.customShader;\n  model.pointCloudShading = tileset.pointCloudShading;\n  model.featureIdLabel = tileset.featureIdLabel;\n  model.instanceFeatureIdLabel = tileset.instanceFeatureIdLabel;\n  model.lightColor = tileset.lightColor;\n  model.imageBasedLighting = tileset.imageBasedLighting;\n  model.backFaceCulling = tileset.backFaceCulling;\n  model.shadows = tileset.shadows;\n  model.showCreditsOnScreen = tileset.showCreditsOnScreen;\n  model.splitDirection = tileset.splitDirection;\n  model.debugWireframe = tileset.debugWireframe;\n\n  // Updating clipping planes requires more effort because of ownership checks\n  const tilesetClippingPlanes = tileset.clippingPlanes;\n  model.referenceMatrix = tileset.clippingPlanesOriginMatrix;\n  if (defined(tilesetClippingPlanes) && tile.clippingPlanesDirty) {\n    // Dereference the clipping planes from the model if they are irrelevant.\n    model._clippingPlanes =\n      tilesetClippingPlanes.enabled && tile._isClipped\n        ? tilesetClippingPlanes\n        : undefined;\n  }\n\n  // If the model references a different ClippingPlaneCollection from the tileset,\n  // update the model to use the new ClippingPlaneCollection.\n  if (\n    defined(tilesetClippingPlanes) &&\n    defined(model._clippingPlanes) &&\n    model._clippingPlanes !== tilesetClippingPlanes\n  ) {\n    model._clippingPlanes = tilesetClippingPlanes;\n  }\n\n  model.update(frameState);\n};\n\nModelExperimental3DTileContent.prototype.isDestroyed = function () {\n  return false;\n};\n\nModelExperimental3DTileContent.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n  return destroyObject(this);\n};\n\nModelExperimental3DTileContent.fromGltf = function (\n  tileset,\n  tile,\n  resource,\n  gltf\n) {\n  const content = new ModelExperimental3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    gltf: gltf,\n    basePath: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions\n  );\n  content._model = ModelExperimental.fromGltf(modelOptions);\n  return content;\n};\n\nModelExperimental3DTileContent.fromB3dm = function (\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset\n) {\n  const content = new ModelExperimental3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions\n  );\n  content._model = ModelExperimental.fromB3dm(modelOptions);\n  return content;\n};\n\nModelExperimental3DTileContent.fromI3dm = function (\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset\n) {\n  const content = new ModelExperimental3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions\n  );\n  content._model = ModelExperimental.fromI3dm(modelOptions);\n  return content;\n};\n\nModelExperimental3DTileContent.fromPnts = function (\n  tileset,\n  tile,\n  resource,\n  arrayBuffer,\n  byteOffset\n) {\n  const content = new ModelExperimental3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    arrayBuffer: arrayBuffer,\n    byteOffset: byteOffset,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions\n  );\n  content._model = ModelExperimental.fromPnts(modelOptions);\n  return content;\n};\n\nModelExperimental3DTileContent.fromGeoJson = function (\n  tileset,\n  tile,\n  resource,\n  geoJson\n) {\n  const content = new ModelExperimental3DTileContent(tileset, tile, resource);\n\n  const additionalOptions = {\n    geoJson: geoJson,\n    resource: resource,\n  };\n\n  const modelOptions = makeModelOptions(\n    tileset,\n    tile,\n    content,\n    additionalOptions\n  );\n  content._model = ModelExperimental.fromGeoJson(modelOptions);\n  return content;\n};\n\nfunction makeModelOptions(tileset, tile, content, additionalOptions) {\n  const mainOptions = {\n    cull: false, // The model is already culled by 3D Tiles\n    releaseGltfJson: true, // Models are unique and will not benefit from caching so save memory\n    opaquePass: Pass.CESIUM_3D_TILE, // Draw opaque portions of the model during the 3D Tiles pass\n    modelMatrix: tile.computedTransform,\n    upAxis: tileset._gltfUpAxis,\n    forwardAxis: Axis.X,\n    incrementallyLoadTextures: false,\n    customShader: tileset.customShader,\n    content: content,\n    show: tileset.show,\n    colorBlendMode: tileset.colorBlendMode,\n    colorBlendAmount: tileset.colorBlendAmount,\n    lightColor: tileset.lightColor,\n    imageBasedLighting: tileset.imageBasedLighting,\n    featureIdLabel: tileset.featureIdLabel,\n    instanceFeatureIdLabel: tileset.instanceFeatureIdLabel,\n    pointCloudShading: tileset.pointCloudShading,\n    clippingPlanes: tileset.clippingPlanes,\n    backFaceCulling: tileset.backFaceCulling,\n    shadows: tileset.shadows,\n    showCreditsOnScreen: tileset.showCreditsOnScreen,\n    splitDirection: tileset.splitDirection,\n    enableDebugWireframe: tileset._enableDebugWireframe,\n    debugWireframe: tileset.debugWireframe,\n    projectTo2D: true,\n  };\n\n  return combine(additionalOptions, mainOptions);\n}\n","import defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Event from \"../../Core/Event.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\nimport ModelAnimationLoop from \".././ModelAnimationLoop.js\";\nimport ModelAnimationState from \".././ModelAnimationState.js\";\nimport ModelExperimentalAnimationChannel from \"../ModelExperimental/ModelExperimentalAnimationChannel.js\";\n\n/**\n * An active animation derived from a glTF asset. An active animation is an\n * animation that is either currently playing or scheduled to be played due to\n * being added to a model's {@link ModelExperimentalAnimationCollection}. An active animation\n * is an instance of an animation; for example, there can be multiple active\n * animations for the same glTF animation, each with a different start time.\n * <p>\n * Create this by calling {@link ModelExperimentalAnimationCollection#add}.\n * </p>\n *\n * @alias ModelExperimentalAnimation\n * @internalConstructor\n * @class\n *\n * @see ModelExperimentalAnimationCollection#add\n */\nfunction ModelExperimentalAnimation(model, animation, options) {\n  this._animation = animation;\n  this._name = animation.name;\n  this._runtimeChannels = undefined;\n\n  this._startTime = JulianDate.clone(options.startTime);\n  this._delay = defaultValue(options.delay, 0.0); // in seconds\n  this._stopTime = JulianDate.clone(options.stopTime);\n\n  /**\n   * When <code>true</code>, the animation is removed after it stops playing.\n   * This is slightly more efficient that not removing it, but if, for example,\n   * time is reversed, the animation is not played again.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.removeOnStop = defaultValue(options.removeOnStop, false);\n  this._multiplier = defaultValue(options.multiplier, 1.0);\n  this._reverse = defaultValue(options.reverse, false);\n  this._loop = defaultValue(options.loop, ModelAnimationLoop.NONE);\n  this._animationTime = options.animationTime;\n  this._prevAnimationDelta = undefined;\n\n  /**\n   * The event fired when this animation is started.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation starts.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.start.addEventListener(function(model, animation) {\n   *   console.log('Animation started: ' + animation.name);\n   * });\n   */\n  this.start = new Event();\n\n  /**\n   * The event fired when on each frame when this animation is updated.  The\n   * current time of the animation, relative to the glTF animation time span, is\n   * passed to the event, which allows, for example, starting new animations at a\n   * specific time relative to a playing animation.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.update.addEventListener(function(model, animation, time) {\n   *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);\n   * });\n   */\n  this.update = new Event();\n\n  /**\n   * The event fired when this animation is stopped.  This can be used, for\n   * example, to play a sound or start a particle system, when the animation stops.\n   * <p>\n   * This event is fired at the end of the frame after the scene is rendered.\n   * </p>\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * animation.stop.addEventListener(function(model, animation) {\n   *   console.log('Animation stopped: ' + animation.name);\n   * });\n   */\n  this.stop = new Event();\n\n  this._state = ModelAnimationState.STOPPED;\n\n  // Set during animation update\n  this._computedStartTime = undefined;\n  this._duration = undefined;\n\n  // To avoid allocations in ModelExperimentalAnimationCollection.update\n  const that = this;\n  this._raiseStartEvent = function () {\n    that.start.raiseEvent(model, that);\n  };\n  this._updateEventTime = 0.0;\n  this._raiseUpdateEvent = function () {\n    that.update.raiseEvent(model, that, that._updateEventTime);\n  };\n  this._raiseStopEvent = function () {\n    that.stop.raiseEvent(model, that);\n  };\n\n  this._model = model;\n\n  this._localStartTime = undefined;\n  this._localStopTime = undefined;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelExperimentalAnimation.prototype, {\n  /**\n   * The glTF animation.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {ModelComponents.Animation}\n   * @readonly\n   *\n   * @private\n   */\n  animation: {\n    get: function () {\n      return this._animation;\n    },\n  },\n\n  /**\n   * The name that identifies this animation in the model, if it exists.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The runtime animation channels for this animation.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {ModelExperimentalAnimationChannel[]}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeChannels: {\n    get: function () {\n      return this._runtimeChannels;\n    },\n  },\n\n  /**\n   * The {@link ModelExperimental} that owns this animation.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {ModelExperimental}\n   * @readonly\n   *\n   * @private\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n\n  /**\n   * The starting point of the animation in local animation time. This is the minimum\n   * time value across all of the keyframes belonging to this animation.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  localStartTime: {\n    get: function () {\n      return this._localStartTime;\n    },\n  },\n\n  /**\n   * The stopping point of the animation in local animation time. This is the maximum\n   * time value across all of the keyframes belonging to this animation.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  localStopTime: {\n    get: function () {\n      return this._localStopTime;\n    },\n  },\n\n  /**\n   * The scene time to start playing this animation. When this is <code>undefined</code>,\n   * the animation starts at the next frame.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  startTime: {\n    get: function () {\n      return this._startTime;\n    },\n  },\n\n  /**\n   * The delay, in seconds, from {@link ModelExperimentalAnimation#startTime} to start playing.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @default undefined\n   */\n  delay: {\n    get: function () {\n      return this._delay;\n    },\n  },\n\n  /**\n   * The scene time to stop playing this animation. When this is <code>undefined</code>,\n   * the animation is played for its full duration and perhaps repeated depending on\n   * {@link ModelExperimentalAnimation#loop}.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {JulianDate}\n   * @readonly\n   *\n   * @default undefined\n   */\n  stopTime: {\n    get: function () {\n      return this._stopTime;\n    },\n  },\n\n  /**\n   * Values greater than <code>1.0</code> increase the speed that the animation is played relative\n   * to the scene clock speed; values less than <code>1.0</code> decrease the speed.  A value of\n   * <code>1.0</code> plays the animation at the speed in the glTF animation mapped to the scene\n   * clock speed.  For example, if the scene is played at 2x real-time, a two-second glTF animation\n   * will play in one second even if <code>multiplier</code> is <code>1.0</code>.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @default 1.0\n   */\n  multiplier: {\n    get: function () {\n      return this._multiplier;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the animation is played in reverse.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  reverse: {\n    get: function () {\n      return this._reverse;\n    },\n  },\n\n  /**\n   * Determines if and how the animation is looped.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {ModelAnimationLoop}\n   * @readonly\n   *\n   * @default {@link ModelAnimationLoop.NONE}\n   */\n  loop: {\n    get: function () {\n      return this._loop;\n    },\n  },\n\n  /**\n   * If this is defined, it will be used to compute the local animation time\n   * instead of the scene's time.\n   *\n   * @memberof ModelExperimentalAnimation.prototype\n   *\n   * @type {ModelExperimentalAnimation.AnimationTimeCallback}\n   * @default undefined\n   */\n  animationTime: {\n    get: function () {\n      return this._animationTime;\n    },\n  },\n});\n\nfunction initialize(runtimeAnimation) {\n  let localStartTime = Number.MAX_VALUE;\n  let localStopTime = -Number.MAX_VALUE;\n\n  const sceneGraph = runtimeAnimation._model.sceneGraph;\n  const animation = runtimeAnimation._animation;\n  const channels = animation.channels;\n  const length = channels.length;\n\n  const runtimeChannels = [];\n  for (let i = 0; i < length; i++) {\n    const channel = channels[i];\n    const target = channel.target;\n\n    // Ignore this channel if the target is invalid, i.e. if the node\n    // it references doesn't exist.\n    if (!defined(target)) {\n      continue;\n    }\n\n    const nodeIndex = target.node.index;\n    const runtimeNode = sceneGraph._runtimeNodes[nodeIndex];\n\n    const runtimeChannel = new ModelExperimentalAnimationChannel({\n      channel: channel,\n      runtimeAnimation: runtimeAnimation,\n      runtimeNode: runtimeNode,\n    });\n\n    const times = channel.sampler.input;\n    localStartTime = Math.min(localStartTime, times[0]);\n    localStopTime = Math.max(localStopTime, times[times.length - 1]);\n\n    runtimeChannels.push(runtimeChannel);\n  }\n\n  runtimeAnimation._runtimeChannels = runtimeChannels;\n  runtimeAnimation._localStartTime = localStartTime;\n  runtimeAnimation._localStopTime = localStopTime;\n}\n\n/**\n * Evaluate all animation channels to advance this animation.\n *\n * @param {Number} time The local animation time.\n *\n * @private\n */\nModelExperimentalAnimation.prototype.animate = function (time) {\n  const runtimeChannels = this._runtimeChannels;\n  const length = runtimeChannels.length;\n  for (let i = 0; i < length; i++) {\n    runtimeChannels[i].animate(time);\n  }\n};\n\n/**\n * A function used to compute the local animation time for a ModelExperimentalAnimation.\n * @callback ModelExperimentalAnimation.AnimationTimeCallback\n *\n * @param {Number} duration The animation's original duration in seconds.\n * @param {Number} seconds The seconds since the animation started, in scene time.\n * @returns {Number} Returns the local animation time.\n *\n * @example\n * // Use real time for model animation (assuming animateWhilePaused was set to true)\n * function animationTime(duration) {\n *     return Date.now() / 1000 / duration;\n * }\n *\n * @example\n * // Offset the phase of the animation, so it starts halfway through its cycle.\n * function animationTime(duration, seconds) {\n *     return seconds / duration + 0.5;\n * }\n */\nexport default ModelExperimentalAnimation;\n","import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport ConstantSpline from \"../../Core/ConstantSpline.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport HermiteSpline from \"../../Core/HermiteSpline.js\";\nimport InterpolationType from \"../../Core/InterpolationType.js\";\nimport LinearSpline from \"../../Core/LinearSpline.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport SteppedSpline from \"../../Core/SteppedSpline.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport QuaternionSpline from \"../../Core/QuaternionSpline.js\";\n\nconst AnimatedPropertyType = ModelComponents.AnimatedPropertyType;\n\n/**\n * A runtime animation channel for a {@link ModelExperimentalAnimation}. An animation\n * channel is responsible for interpolating between the keyframe values of an animated\n * property, then applying the change to the target node.\n *\n * @param {Object} options An object containing the following options:\n * @param {ModelComponents.AnimationChannel} options.channel The corresponding animation channel components from the 3D model.\n * @param {ModelExperimentalAnimation} options.runtimeAnimation The runtime animation containing this channel.\n * @param {ModelExperimentalNode} options.runtimeNode The runtime node that this channel will animate.\n *\n * @alias ModelExperimentalAnimationChannel\n * @constructor\n *\n * @private\n */\nfunction ModelExperimentalAnimationChannel(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const channel = options.channel;\n  const runtimeAnimation = options.runtimeAnimation;\n  const runtimeNode = options.runtimeNode;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.channel\", channel);\n  Check.typeOf.object(\"options.runtimeAnimation\", runtimeAnimation);\n  Check.typeOf.object(\"options.runtimeNode\", runtimeNode);\n  //>>includeEnd('debug');\n\n  this._channel = channel;\n  this._runtimeAnimation = runtimeAnimation;\n  this._runtimeNode = runtimeNode;\n\n  // An animation channel can have multiple splines if it animates\n  // a node's morph weights, which will involve multiple morph targets.\n  this._splines = [];\n  this._path = undefined;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelExperimentalAnimationChannel.prototype, {\n  /**\n   * The glTF animation channel.\n   *\n   * @memberof ModelExperimentalAnimationChannel.prototype\n   *\n   * @type {ModelComponents.AnimationChannel}\n   * @readonly\n   *\n   * @private\n   */\n  channel: {\n    get: function () {\n      return this._channel;\n    },\n  },\n\n  /**\n   * The runtime animation that owns this channel.\n   *\n   * @memberof ModelExperimentalAnimationChannel.prototype\n   *\n   * @type {ModelExperimentalAnimation}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeAnimation: {\n    get: function () {\n      return this._runtimeAnimation;\n    },\n  },\n\n  /**\n   * The runtime node that this channel animates.\n   *\n   * @memberof ModelExperimentalAnimationChannel.prototype\n   *\n   * @type {ModelExperimentalNode}\n   * @readonly\n   *\n   * @private\n   */\n  runtimeNode: {\n    get: function () {\n      return this._runtimeNode;\n    },\n  },\n\n  /**\n   * The splines used to evaluate this animation channel.\n   *\n   * @memberof ModelExperimentalAnimationChannel.prototype\n   *\n   * @type {Spline[]}\n   * @readonly\n   *\n   * @private\n   */\n  splines: {\n    get: function () {\n      return this._splines;\n    },\n  },\n});\n\nfunction createCubicSpline(times, points) {\n  const cubicPoints = [];\n  const inTangents = [];\n  const outTangents = [];\n\n  const length = points.length;\n  for (let i = 0; i < length; i += 3) {\n    inTangents.push(points[i]);\n    cubicPoints.push(points[i + 1]);\n    outTangents.push(points[i + 2]);\n  }\n\n  // Remove the first in-tangent and last out-tangent, since they\n  // are not used in the spline calculations\n  inTangents.splice(0, 1);\n  outTangents.length = outTangents.length - 1;\n\n  return new HermiteSpline({\n    times: times,\n    points: cubicPoints,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n}\n\nfunction createSpline(times, points, interpolation, path) {\n  if (times.length === 1 && points.length === 1) {\n    return new ConstantSpline(points[0]);\n  }\n\n  switch (interpolation) {\n    case InterpolationType.STEP:\n      return new SteppedSpline({\n        times: times,\n        points: points,\n      });\n    case InterpolationType.CUBICSPLINE:\n      return createCubicSpline(times, points);\n    case InterpolationType.LINEAR:\n      if (path === AnimatedPropertyType.ROTATION) {\n        return new QuaternionSpline({\n          times: times,\n          points: points,\n        });\n      }\n      return new LinearSpline({\n        times: times,\n        points: points,\n      });\n  }\n}\n\nfunction createSplines(times, points, interpolation, path, count) {\n  const splines = [];\n  if (path === AnimatedPropertyType.WEIGHTS) {\n    const pointsLength = points.length;\n    // Get the number of keyframes in each weight's output.\n    const outputLength = pointsLength / count;\n\n    // Iterate over the array using the number of morph targets in the model.\n    let targetIndex, i;\n    for (targetIndex = 0; targetIndex < count; targetIndex++) {\n      const output = new Array(outputLength);\n\n      // Weights are ordered such that they are keyframed in the order in which\n      // their targets appear the glTF. For example, the weights of three targets\n      // may appear as [w(0,0), w(0,1), w(0,2), w(1,0), w(1,1), w(1,2) ...],\n      // where i and j in w(i,j) are the time indices and target indices, respectively.\n\n      // However, for morph targets with cubic interpolation, the data is stored per\n      // keyframe in the order [a1, a2, ..., an, v1, v2, ... vn, b1, b2, ..., bn],\n      // where ai, vi, and bi are the in-tangent, property, and out-tangents of\n      // the ith morph target respectively.\n      let pointsIndex = targetIndex;\n      if (interpolation === InterpolationType.CUBICSPLINE) {\n        for (i = 0; i < outputLength; i += 3) {\n          output[i] = points[pointsIndex];\n          output[i + 1] = points[pointsIndex + count];\n          output[i + 2] = points[pointsIndex + 2 * count];\n          pointsIndex += count * 3;\n        }\n      } else {\n        for (i = 0; i < outputLength; i++) {\n          output[i] = points[pointsIndex];\n          pointsIndex += count;\n        }\n      }\n\n      splines.push(createSpline(times, output, interpolation, path));\n    }\n  } else {\n    splines.push(createSpline(times, points, interpolation, path));\n  }\n\n  return splines;\n}\n\nlet scratchVariable;\n\nfunction initialize(runtimeChannel) {\n  const channel = runtimeChannel._channel;\n\n  const sampler = channel.sampler;\n  const times = sampler.input;\n  const points = sampler.output;\n\n  const interpolation = sampler.interpolation;\n  const target = channel.target;\n  const path = target.path;\n\n  const runtimeNode = runtimeChannel._runtimeNode;\n  const count = defined(runtimeNode.morphWeights)\n    ? runtimeNode.morphWeights.length\n    : 1;\n  const splines = createSplines(times, points, interpolation, path, count);\n\n  runtimeChannel._splines = splines;\n  runtimeChannel._path = path;\n\n  switch (path) {\n    case AnimatedPropertyType.TRANSLATION:\n    case AnimatedPropertyType.SCALE:\n      scratchVariable = new Cartesian3();\n      break;\n    case AnimatedPropertyType.ROTATION:\n      scratchVariable = new Quaternion();\n      break;\n    case AnimatedPropertyType.WEIGHTS:\n      // This is unused when setting a node's morph weights.\n      break;\n  }\n}\n\n/**\n * Animates the target node property based on its spline.\n *\n * @param {Number} time The local animation time.\n *\n * @private\n */\nModelExperimentalAnimationChannel.prototype.animate = function (time) {\n  const splines = this._splines;\n  const path = this._path;\n  const model = this._runtimeAnimation.model;\n\n  // Weights are handled differently than the other properties because\n  // they need to be updated in place.\n  if (path === AnimatedPropertyType.WEIGHTS) {\n    const morphWeights = this._runtimeNode.morphWeights;\n    const length = morphWeights.length;\n    for (let i = 0; i < length; i++) {\n      const spline = splines[i];\n      const localAnimationTime = model.clampAnimations\n        ? spline.clampTime(time)\n        : spline.wrapTime(time);\n      morphWeights[i] = spline.evaluate(localAnimationTime);\n    }\n  } else {\n    const spline = splines[0];\n    const localAnimationTime = model.clampAnimations\n      ? spline.clampTime(time)\n      : spline.wrapTime(time);\n\n    // This sets the translate, rotate, and scale properties.\n    this._runtimeNode[path] = spline.evaluate(\n      localAnimationTime,\n      scratchVariable\n    );\n  }\n};\n\nexport default ModelExperimentalAnimationChannel;\n","import defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Event from \"../../Core/Event.js\";\nimport JulianDate from \"../../Core/JulianDate.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport ModelExperimentalAnimation from \"./ModelExperimentalAnimation.js\";\nimport ModelAnimationLoop from \".././ModelAnimationLoop.js\";\nimport ModelAnimationState from \".././ModelAnimationState.js\";\n\n/**\n * A collection of active model animations. Access this using {@link ModelExperimental#activeAnimations}.\n *\n * @alias ModelExperimentalAnimationCollection\n * @internalConstructor\n * @class\n *\n * @see ModelExperimental#activeAnimations\n */\nfunction ModelExperimentalAnimationCollection(model) {\n  /**\n   * The event fired when an animation is added to the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {\n   *   console.log('Animation added: ' + animation.name);\n   * });\n   */\n  this.animationAdded = new Event();\n\n  /**\n   * The event fired when an animation is removed from the collection.  This can be used, for\n   * example, to keep a UI in sync.\n   *\n   * @type {Event}\n   * @default new Event()\n   *\n   * @example\n   * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {\n   *   console.log('Animation removed: ' + animation.name);\n   * });\n   */\n  this.animationRemoved = new Event();\n\n  /**\n   * When true, the animation will play even when the scene time is paused. However,\n   * whether animation takes place will depend on the animationTime functions assigned\n   * to the model's animations. By default, this is based on scene time, so models using\n   * the default will not animate regardless of this setting.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.animateWhilePaused = false;\n\n  this._model = model;\n  this._runtimeAnimations = [];\n  this._previousTime = undefined;\n}\n\nObject.defineProperties(ModelExperimentalAnimationCollection.prototype, {\n  /**\n   * The number of animations in the collection.\n   *\n   * @memberof ModelExperimentalAnimationCollection.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._runtimeAnimations.length;\n    },\n  },\n\n  /**\n   * The model that owns this animation collection.\n   *\n   * @memberof ModelExperimentalAnimationCollection.prototype\n   *\n   * @type {ModelExperimental}\n   * @readonly\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n});\n\nfunction addAnimation(collection, animation, options) {\n  const model = collection._model;\n  const runtimeAnimation = new ModelExperimentalAnimation(\n    model,\n    animation,\n    options\n  );\n  collection._runtimeAnimations.push(runtimeAnimation);\n  collection.animationAdded.raiseEvent(model, runtimeAnimation);\n  return runtimeAnimation;\n}\n\n/**\n * Creates and adds an animation with the specified initial properties to the collection.\n * <p>\n * This raises the {@link ModelExperimentalAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {String} [options.name] The glTF animation name that identifies the animation. Must be defined if <code>options.index</code> is <code>undefined</code>.\n * @param {Number} [options.index] The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.\n * @param {JulianDate} [options.startTime] The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.\n * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.\n * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animation is removed after it stops playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {Boolean} [options.reverse=false] When <code>true</code>, the animation is played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animation is looped.\n * @param {ModelExperimentalAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for this animation.\n * @returns {ModelExperimentalAnimation} The animation that was added to the collection.\n *\n * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link ModelExperimental#readyPromise} to resolve.\n * @exception {DeveloperError} options.name must be a valid animation name.\n * @exception {DeveloperError} options.index must be a valid animation index.\n * @exception {DeveloperError} Either options.name or options.index must be defined.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * // Example 1. Add an animation by name\n * model.activeAnimations.add({\n *   name : 'animation name'\n * });\n *\n * @example\n * // Example 2. Add an animation by index\n * model.activeAnimations.add({\n *   index : 0\n * });\n *\n * @example\n * // Example 3. Add an animation and provide all properties and events\n * const startTime = Cesium.JulianDate.now();\n *\n * const animation = model.activeAnimations.add({\n *   name : 'another animation name',\n *   startTime : startTime,\n *   delay : 0.0,                                 // Play at startTime (default)\n *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),\n *   removeOnStop : false,                        // Do not remove when animation stops (default)\n *   multiplier : 2.0,                            // Play at double speed\n *   reverse : true,                              // Play in reverse\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation\n * });\n *\n * animation.start.addEventListener(function(model, animation) {\n *   console.log('Animation started: ' + animation.name);\n * });\n * animation.update.addEventListener(function(model, animation, time) {\n *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);\n * });\n * animation.stop.addEventListener(function(model, animation) {\n *   console.log('Animation stopped: ' + animation.name);\n * });\n */\nModelExperimentalAnimationCollection.prototype.add = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const model = this._model;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!model.ready) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for ModelExperimental.readyPromise to resolve.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  const animations = model.sceneGraph.components.animations;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.name) && !defined(options.index)) {\n    throw new DeveloperError(\n      \"Either options.name or options.index must be defined.\"\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n\n  if (\n    defined(options.index) &&\n    (options.index >= animations.length || options.index < 0)\n  ) {\n    throw new DeveloperError(\"options.index must be a valid animation index.\");\n  }\n  //>>includeEnd('debug');\n\n  let index = options.index;\n  if (defined(index)) {\n    return addAnimation(this, animations[index], options);\n  }\n\n  // Find the index of the animation with the given name\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    if (animations[i].name === options.name) {\n      index = i;\n      break;\n    }\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"options.name must be a valid animation name.\");\n  }\n  //>>includeEnd('debug');\n\n  return addAnimation(this, animations[index], options);\n};\n\n/**\n * Creates and adds animations with the specified initial properties to the collection\n * for all animations in the model.\n * <p>\n * This raises the {@link ModelExperimentalAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.\n * </p>\n *\n * @param {Object} [options] Object with the following properties:\n * @param {JulianDate} [options.startTime] The scene time to start playing the animations. When this is <code>undefined</code>, the animations starts at the next frame.\n * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {JulianDate} [options.stopTime] The scene time to stop playing the animations. When this is <code>undefined</code>, the animations are played for its full duration.\n * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animations are removed after they stop playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.\n * @param {Number} [options.multiplier=1.0] Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.\n * @param {Boolean} [options.reverse=false] When <code>true</code>, the animations are played in reverse.\n * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animations are looped.\n * @param {ModelExperimentalAnimation.AnimationTimeCallback} [options.animationTime=undefined] If defined, computes the local animation time for all of the animations.\n * @returns {ModelExperimentalAnimation[]} An array of {@link ModelExperimentalAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.\n *\n * @exception {DeveloperError} Animations are not loaded. Wait for the {@link ModelExperimental#readyPromise} to resolve.\n * @exception {DeveloperError} options.multiplier must be greater than zero.\n *\n * @example\n * model.activeAnimations.addAll({\n *   multiplier : 0.5,                            // Play at half-speed\n *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations\n * });\n */\nModelExperimentalAnimationCollection.prototype.addAll = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const model = this._model;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!model.ready) {\n    throw new DeveloperError(\n      \"Animations are not loaded.  Wait for Model.readyPromise to resolve.\"\n    );\n  }\n\n  if (defined(options.multiplier) && options.multiplier <= 0.0) {\n    throw new DeveloperError(\"options.multiplier must be greater than zero.\");\n  }\n  //>>includeEnd('debug');\n\n  const animations = model.sceneGraph.components.animations;\n\n  const addedAnimations = [];\n  const length = animations.length;\n  for (let i = 0; i < length; ++i) {\n    const animation = addAnimation(this, animations[i], options);\n    addedAnimations.push(animation);\n  }\n  return addedAnimations;\n};\n\n/**\n * Removes an animation from the collection.\n * <p>\n * This raises the {@link ModelExperimentalAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.\n * </p>\n * <p>\n * An animation can also be implicitly removed from the collection by setting {@link ModelExperimentalAnimationCollection#removeOnStop} to\n * <code>true</code>.  The {@link ModelExperimentalAnimationCollection#animationRemoved} event is still fired when the animation is removed.\n * </p>\n *\n * @param {ModelExperimentalAnimation} runtimeAnimation The runtime animation to remove.\n * @returns {Boolean} <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.\n *\n * @example\n * const a = model.activeAnimations.add({\n *   name : 'animation name'\n * });\n * model.activeAnimations.remove(a); // Returns true\n */\nModelExperimentalAnimationCollection.prototype.remove = function (\n  runtimeAnimation\n) {\n  if (!defined(runtimeAnimation)) {\n    return false;\n  }\n\n  const animations = this._runtimeAnimations;\n  const i = animations.indexOf(runtimeAnimation);\n  if (i !== -1) {\n    animations.splice(i, 1);\n    this.animationRemoved.raiseEvent(this._model, runtimeAnimation);\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Removes all animations from the collection.\n * <p>\n * This raises the {@link ModelExperimentalAnimationCollection#animationRemoved} event for each\n * animation so, for example, a UI can stay in sync.\n * </p>\n */\nModelExperimentalAnimationCollection.prototype.removeAll = function () {\n  const model = this._model;\n  const animations = this._runtimeAnimations;\n  const length = animations.length;\n\n  this._runtimeAnimations.length = 0;\n\n  for (let i = 0; i < length; ++i) {\n    this.animationRemoved.raiseEvent(model, animations[i]);\n  }\n};\n\n/**\n * Determines whether this collection contains a given animation.\n *\n * @param {ModelExperimentalAnimation} runtimeAnimation The runtime animation to check for.\n * @returns {Boolean} <code>true</code> if this collection contains the animation, <code>false</code> otherwise.\n */\nModelExperimentalAnimationCollection.prototype.contains = function (\n  runtimeAnimation\n) {\n  if (defined(runtimeAnimation)) {\n    return this._runtimeAnimations.indexOf(runtimeAnimation) !== -1;\n  }\n\n  return false;\n};\n\n/**\n * Returns the animation in the collection at the specified index.  Indices are zero-based\n * and increase as animations are added.  Removing an animation shifts all animations after\n * it to the left, changing their indices.  This function is commonly used to iterate over\n * all the animations in the collection.\n *\n * @param {Number} index The zero-based index of the animation.\n * @returns {ModelExperimentalAnimation} The runtime animation at the specified index.\n *\n * @example\n * // Output the names of all the animations in the collection.\n * const animations = model.activeAnimations;\n * const length = animations.length;\n * for (let i = 0; i < length; ++i) {\n *   console.log(animations.get(i).name);\n * }\n */\nModelExperimentalAnimationCollection.prototype.get = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(index)) {\n    throw new DeveloperError(\"index is required.\");\n  }\n\n  if (index >= this._runtimeAnimations.length || index < 0) {\n    throw new DeveloperError(\n      \"index must be valid within the range of the collection\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return this._runtimeAnimations[index];\n};\n\nconst animationsToRemove = [];\n\nfunction createAnimationRemovedFunction(\n  modelAnimationCollection,\n  model,\n  animation\n) {\n  return function () {\n    modelAnimationCollection.animationRemoved.raiseEvent(model, animation);\n  };\n}\n\n/**\n * Updates the runtime animations in this collection, removing any animations\n * that have stopped.\n *\n * @param {FrameState} frameState The current frame state.\n * @returns {Boolean} <code>true</code> if an animation played during this update, <code>false</code> otherwise.\n *\n * @private\n */\nModelExperimentalAnimationCollection.prototype.update = function (frameState) {\n  const runtimeAnimations = this._runtimeAnimations;\n  let length = runtimeAnimations.length;\n\n  if (length === 0) {\n    this._previousTime = undefined;\n    return false;\n  }\n\n  if (\n    !this.animateWhilePaused &&\n    JulianDate.equals(frameState.time, this._previousTime)\n  ) {\n    return false;\n  }\n  this._previousTime = JulianDate.clone(frameState.time, this._previousTime);\n\n  let animationOccurred = false;\n  const sceneTime = frameState.time;\n  const model = this._model;\n\n  for (let i = 0; i < length; ++i) {\n    const runtimeAnimation = runtimeAnimations[i];\n\n    if (!defined(runtimeAnimation._computedStartTime)) {\n      runtimeAnimation._computedStartTime = JulianDate.addSeconds(\n        defaultValue(runtimeAnimation.startTime, sceneTime),\n        runtimeAnimation.delay,\n        new JulianDate()\n      );\n    }\n\n    if (!defined(runtimeAnimation._duration)) {\n      runtimeAnimation._duration =\n        runtimeAnimation.localStopTime * (1.0 / runtimeAnimation.multiplier);\n    }\n\n    const startTime = runtimeAnimation._computedStartTime;\n    const duration = runtimeAnimation._duration;\n    const stopTime = runtimeAnimation.stopTime;\n\n    const pastStartTime = JulianDate.lessThanOrEquals(startTime, sceneTime);\n    const reachedStopTime =\n      defined(stopTime) && JulianDate.greaterThan(sceneTime, stopTime);\n\n    // [0.0, 1.0] normalized local animation time\n    let delta = 0.0;\n    if (duration !== 0.0) {\n      const seconds = JulianDate.secondsDifference(\n        reachedStopTime ? stopTime : sceneTime,\n        startTime\n      );\n      delta = defined(runtimeAnimation._animationTime)\n        ? runtimeAnimation._animationTime(duration, seconds)\n        : seconds / duration;\n    }\n\n    // Play animation if\n    // * we are after the start time or the animation is being repeated, and\n    // * before the end of the animation's duration or the animation is being repeated, and\n    // * we did not reach a user-provided stop time.\n\n    const repeat =\n      runtimeAnimation.loop === ModelAnimationLoop.REPEAT ||\n      runtimeAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT;\n\n    const play =\n      (pastStartTime || (repeat && !defined(runtimeAnimation.startTime))) &&\n      (delta <= 1.0 || repeat) &&\n      !reachedStopTime;\n\n    if (delta === runtimeAnimation._prevAnimationDelta) {\n      const animationStopped =\n        runtimeAnimation._state === ModelAnimationState.STOPPED;\n      // no change to delta, and no change to the animation state means we can\n      // skip the update this time around.\n      if (play !== animationStopped) {\n        continue;\n      }\n    }\n    runtimeAnimation._prevAnimationDelta = delta;\n\n    // If it IS, or WAS, animating...\n    if (play || runtimeAnimation._state === ModelAnimationState.ANIMATING) {\n      // ...transition from STOPPED to ANIMATING\n      if (play && runtimeAnimation._state === ModelAnimationState.STOPPED) {\n        runtimeAnimation._state = ModelAnimationState.ANIMATING;\n        if (runtimeAnimation.start.numberOfListeners > 0) {\n          frameState.afterRender.push(runtimeAnimation._raiseStartEvent);\n        }\n      }\n\n      // Truncate to [0.0, 1.0] for repeating animations\n      if (runtimeAnimation.loop === ModelAnimationLoop.REPEAT) {\n        delta = delta - Math.floor(delta);\n      } else if (runtimeAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT) {\n        const floor = Math.floor(delta);\n        const fract = delta - floor;\n        // When odd use (1.0 - fract) to mirror repeat\n        delta = floor % 2 === 1.0 ? 1.0 - fract : fract;\n      }\n\n      if (runtimeAnimation.reverse) {\n        delta = 1.0 - delta;\n      }\n\n      let localAnimationTime = delta * duration * runtimeAnimation.multiplier;\n      // Clamp in case floating-point roundoff goes outside the animation's first or last keyframe\n      localAnimationTime = CesiumMath.clamp(\n        localAnimationTime,\n        runtimeAnimation.localStartTime,\n        runtimeAnimation.localStopTime\n      );\n\n      runtimeAnimation.animate(localAnimationTime);\n\n      if (runtimeAnimation.update.numberOfListeners > 0) {\n        runtimeAnimation._updateEventTime = localAnimationTime;\n        frameState.afterRender.push(runtimeAnimation._raiseUpdateEvent);\n      }\n      animationOccurred = true;\n\n      if (!play) {\n        // transition from ANIMATING to STOPPED\n        runtimeAnimation._state = ModelAnimationState.STOPPED;\n        if (runtimeAnimation.stop.numberOfListeners > 0) {\n          frameState.afterRender.push(runtimeAnimation._raiseStopEvent);\n        }\n\n        if (runtimeAnimation.removeOnStop) {\n          animationsToRemove.push(runtimeAnimation);\n        }\n      }\n    }\n  }\n\n  // Remove animations that stopped\n  length = animationsToRemove.length;\n  for (let j = 0; j < length; ++j) {\n    const animationToRemove = animationsToRemove[j];\n    runtimeAnimations.splice(runtimeAnimations.indexOf(animationToRemove), 1);\n    frameState.afterRender.push(\n      createAnimationRemovedFunction(this, model, animationToRemove)\n    );\n  }\n  animationsToRemove.length = 0;\n\n  return animationOccurred;\n};\n\nexport default ModelExperimentalAnimationCollection;\n","import BlendingState from \"../BlendingState.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DrawCommand from \"../../Renderer/DrawCommand.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Pass from \"../../Renderer/Pass.js\";\nimport RenderState from \"../../Renderer/RenderState.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport ShadowMode from \"../ShadowMode.js\";\nimport StyleCommandsNeeded from \"./StyleCommandsNeeded.js\";\n\n/**\n * A wrapper around the draw commands used to render a {@link ModelExperimentalPrimitive}.\n * This manages the derived commands and returns only the necessary commands depending\n * on the given frame state.\n *\n * @param {Object} options An object containing the following options:\n * @param {DrawCommand} options.command The draw command from which to derive other commands from.\n * @param {PrimitiveRenderResources} options.primitiveRenderResources The render resources of the primitive associated with the command.\n * @alias ModelExperimentalDrawCommand\n * @constructor\n *\n * @private\n */\nfunction ModelExperimentalDrawCommand(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const command = options.command;\n  const renderResources = options.primitiveRenderResources;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.command\", command);\n  Check.typeOf.object(\"options.primitiveRenderResources\", renderResources);\n  //>>includeEnd('debug');\n\n  this._command = command;\n\n  this._modelMatrix = Matrix4.clone(command.modelMatrix, new Matrix4());\n\n  // The 2D projection of the model matrix depends on the frame state's\n  // map projection, so it must be updated when the commands are being\n  // retrieved in getCommands.\n  this._modelMatrix2DDirty = false;\n\n  this._styleCommandsNeeded = renderResources.styleCommandsNeeded;\n  this._backFaceCulling = command.renderState.cull.enabled;\n  this._cullFace = command.renderState.cull.face;\n  this._shadows = renderResources.model.shadows;\n  this._debugShowBoundingVolume = command.debugShowBoundingVolume;\n\n  this._commandList = [];\n  this._commandList2D = [];\n\n  this._runtimePrimitive = renderResources.runtimePrimitive;\n  this._model = renderResources.model;\n\n  initialize(this);\n}\n\nfunction initialize(drawCommand, frameState) {\n  const commandList = drawCommand._commandList;\n  const command = drawCommand._command;\n\n  const styleCommandsNeeded = drawCommand._styleCommandsNeeded;\n\n  // If the command was originally translucent then there's no need to derive\n  // new commands. As of now, a style can't change an originally translucent\n  // feature to opaque since the style's alpha is modulated, not a replacement.\n  // When this changes, we need to derive new opaque commands in the constructor\n  // of ModelExperimentalDrawCommand.\n  if (defined(styleCommandsNeeded) && command.pass !== Pass.TRANSLUCENT) {\n    const translucentCommand = deriveTranslucentCommand(command);\n    switch (styleCommandsNeeded) {\n      case StyleCommandsNeeded.ALL_OPAQUE:\n        commandList.push(command);\n        break;\n      case StyleCommandsNeeded.ALL_TRANSLUCENT:\n        commandList.push(translucentCommand);\n        break;\n      case StyleCommandsNeeded.OPAQUE_AND_TRANSLUCENT:\n        commandList.push(command, translucentCommand);\n        break;\n      //>>includeStart('debug', pragmas.debug);\n      default:\n        throw new RuntimeError(\"styleCommandsNeeded is not a valid value.\");\n      //>>includeEnd('debug');\n    }\n  } else {\n    commandList.push(command);\n  }\n}\n\nObject.defineProperties(ModelExperimentalDrawCommand.prototype, {\n  /**\n   * The main draw command that the other commands are derived from.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {DrawCommand}\n   *\n   * @readonly\n   * @private\n   */\n  command: {\n    get: function () {\n      return this._command;\n    },\n  },\n\n  /**\n   * The runtime primitive that the draw command belongs to.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {ModelExperimentalPrimitive}\n   *\n   * @readonly\n   * @private\n   */\n  runtimePrimitive: {\n    get: function () {\n      return this._runtimePrimitive;\n    },\n  },\n\n  /**\n   * The model that the draw command belongs to.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {ModelExperimental}\n   *\n   * @readonly\n   * @private\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n  },\n\n  /**\n   * The primitive type of the main draw command.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {PrimitiveType}\n   *\n   * @readonly\n   * @private\n   */\n  primitiveType: {\n    get: function () {\n      return this._command.primitiveType;\n    },\n  },\n\n  /**\n   * The current model matrix applied to the draw commands. If there are\n   * 2D draw commands, their model matrix will be derived from the 3D one.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {Matrix4}\n   *\n   * @readonly\n   * @private\n   */\n  modelMatrix: {\n    get: function () {\n      return this._modelMatrix;\n    },\n    set: function (value) {\n      this._modelMatrix = Matrix4.clone(value, this._modelMatrix);\n      this._modelMatrix2DDirty = true;\n      updateModelMatrix(this);\n    },\n  },\n\n  /**\n   * The bounding volume of the main draw command. This is equivalent\n   * to the the primitive's bounding sphere transformed by the draw\n   * command's model matrix.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {BoundingSphere}\n   *\n   * @readonly\n   * @private\n   */\n  boundingVolume: {\n    get: function () {\n      return this._command.boundingVolume;\n    },\n  },\n\n  /**\n   * Whether the geometry casts or receives shadows from light sources.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {ShadowMode}\n   *\n   * @private\n   */\n  shadows: {\n    get: function () {\n      return this._shadows;\n    },\n    set: function (value) {\n      this._shadows = value;\n      updateShadows(this);\n    },\n  },\n\n  /**\n   * Whether to cull back-facing geometry. When true, back face culling is\n   * determined by the material's doubleSided property; when false, back face\n   * culling is disabled. Back faces are not culled if the model's color is\n   * translucent, or if the command is drawing translucent geometry.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {Boolean}\n   *\n   * @private\n   */\n  backFaceCulling: {\n    get: function () {\n      return this._backFaceCulling;\n    },\n    set: function (value) {\n      const doubleSided = this.runtimePrimitive.primitive.material.doubleSided;\n      const translucent =\n        defined(this._model.color) && this._model.color.alpha < 1.0;\n      const backFaceCulling = value && !doubleSided && !translucent;\n\n      if (this._backFaceCulling === backFaceCulling) {\n        return;\n      }\n\n      this._backFaceCulling = backFaceCulling;\n      updateBackFaceCulling(this);\n    },\n  },\n\n  /**\n   * Determines which faces to cull, if culling is enabled.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {CullFace}\n   *\n   * @private\n   */\n  cullFace: {\n    get: function () {\n      return this._cullFace;\n    },\n    set: function (value) {\n      if (this._cullFace === value) {\n        return;\n      }\n\n      this._cullFace = value;\n      updateCullFace(this);\n    },\n  },\n\n  /**\n   * Whether to draw the bounding sphere associated with this draw command.\n   *\n   * @memberof ModelExperimentalDrawCommand.prototype\n   * @type {Boolean}\n   *\n   * @private\n   */\n  debugShowBoundingVolume: {\n    get: function () {\n      return this._debugShowBoundingVolume;\n    },\n    set: function (value) {\n      this._debugShowBoundingVolume = value;\n      updateShowBoundingVolume(this);\n    },\n  },\n});\n\nfunction getAllCommands(drawCommand) {\n  const commandList = [];\n  commandList.push.apply(commandList, drawCommand._commandList);\n  commandList.push.apply(commandList, drawCommand._commandList2D);\n  return commandList;\n}\n\nconst scratchMatrix2D = new Matrix4();\n\nfunction updateModelMatrix(drawCommand) {\n  const modelMatrix = drawCommand.modelMatrix;\n  const boundingSphere = drawCommand.runtimePrimitive.boundingSphere;\n  const commandList = drawCommand._commandList;\n  const length = commandList.length;\n\n  for (let i = 0; i < length; i++) {\n    const command = commandList[i];\n    command.modelMatrix = Matrix4.clone(modelMatrix, command.modelMatrix);\n    command.boundingVolume = BoundingSphere.transform(\n      boundingSphere,\n      command.modelMatrix,\n      command.boundingVolume\n    );\n  }\n}\n\nfunction updateModelMatrix2D(drawCommand, frameState) {\n  const modelMatrix = drawCommand.modelMatrix;\n  const boundingSphere = drawCommand.runtimePrimitive.boundingSphere;\n  const commandList2D = drawCommand._commandList2D;\n  const length2D = commandList2D.length;\n  if (length2D === 0) {\n    return;\n  }\n\n  const modelMatrix2D = Matrix4.clone(modelMatrix, scratchMatrix2D);\n\n  // Change the translation's y-component so it appears on the opposite side\n  // of the map.\n  modelMatrix2D[13] -=\n    CesiumMath.sign(modelMatrix[13]) *\n    2.0 *\n    CesiumMath.PI *\n    frameState.mapProjection.ellipsoid.maximumRadius;\n\n  for (let i = 0; i < length2D; i++) {\n    const command = commandList2D[i];\n    command.modelMatrix = Matrix4.clone(modelMatrix2D, command.modelMatrix);\n    command.boundingVolume = BoundingSphere.transform(\n      boundingSphere,\n      command.modelMatrix,\n      command.boundingVolume\n    );\n  }\n}\n\nfunction updateShadows(drawCommand) {\n  const shadows = drawCommand.shadows;\n  const castShadows = ShadowMode.castShadows(shadows);\n  const receiveShadows = ShadowMode.receiveShadows(shadows);\n\n  const commandList = getAllCommands(drawCommand);\n  const commandLength = commandList.length;\n  for (let i = 0; i < commandLength; i++) {\n    const command = commandList[i];\n    command.castShadows = castShadows;\n    command.receiveShadows = receiveShadows;\n  }\n}\n\nfunction updateBackFaceCulling(drawCommand) {\n  const backFaceCulling = drawCommand.backFaceCulling;\n  const commandList = getAllCommands(drawCommand);\n  const commandLength = commandList.length;\n\n  for (let i = 0; i < commandLength; i++) {\n    const command = commandList[i];\n\n    // Back-face culling should stay disabled if the command\n    // is drawing translucent geometry.\n    if (command.pass === Pass.TRANSLUCENT) {\n      continue;\n    }\n\n    const renderState = clone(command.renderState, true);\n    renderState.cull.enabled = backFaceCulling;\n    command.renderState = RenderState.fromCache(renderState);\n  }\n}\n\nfunction updateCullFace(drawCommand) {\n  const cullFace = drawCommand.cullFace;\n  const commandList = getAllCommands(drawCommand);\n  const commandLength = commandList.length;\n\n  for (let i = 0; i < commandLength; i++) {\n    const command = commandList[i];\n    const renderState = clone(command.renderState, true);\n    renderState.cull.face = cullFace;\n    command.renderState = RenderState.fromCache(renderState);\n  }\n}\n\nfunction updateShowBoundingVolume(drawCommand) {\n  const debugShowBoundingVolume = drawCommand.debugShowBoundingVolume;\n\n  const commandList = getAllCommands(drawCommand);\n  const commandLength = commandList.length;\n  for (let i = 0; i < commandLength; i++) {\n    const command = commandList[i];\n    command.debugShowBoundingVolume = debugShowBoundingVolume;\n  }\n}\n\n/**\n * Returns an array of the draw commands necessary to render the primitive.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @returns {DrawCommand[]} The draw commands.\n *\n * @private\n */\nModelExperimentalDrawCommand.prototype.getCommands = function (frameState) {\n  const commandList = this._commandList;\n  const commandList2D = this._commandList2D;\n\n  const use2D = shouldUse2DCommands(this, frameState);\n\n  if (use2D && commandList2D.length === 0) {\n    const length = commandList.length;\n    for (let i = 0; i < length; i++) {\n      const command2D = derive2DCommand(commandList[i]);\n      commandList2D.push(command2D);\n    }\n\n    this._modelMatrix2DDirty = true;\n  }\n\n  if (this._modelMatrix2DDirty) {\n    updateModelMatrix2D(this, frameState);\n    this._modelMatrix2DDirty = false;\n  }\n\n  const commands = [];\n  commands.push.apply(commands, commandList);\n\n  if (use2D) {\n    commands.push.apply(commands, commandList2D);\n  }\n\n  return commands;\n};\n\n/**\n * @private\n */\nfunction deriveTranslucentCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n  derivedCommand.pass = Pass.TRANSLUCENT;\n  const rs = clone(command.renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  derivedCommand.renderState = RenderState.fromCache(rs);\n\n  return derivedCommand;\n}\n\n/**\n * If the model crosses the IDL in 2D, it will be drawn in one viewport but get\n * clipped by the other viewport. We create a second command that translates\n * the model matrix to the opposite side of the map so the part that was clipped\n * in one viewport is drawn in the other.\n *\n * @param {DrawCommand} command The original draw command.\n *\n * @returns {DrawCommand} The derived command for rendering across the IDL in 2D.\n *\n * @private\n */\nfunction derive2DCommand(command) {\n  const derivedCommand = DrawCommand.shallowClone(command);\n\n  // These will be computed in updateModelMatrix2D()\n  derivedCommand.modelMatrix = new Matrix4();\n  derivedCommand.boundingVolume = new BoundingSphere();\n\n  return derivedCommand;\n}\n\nfunction shouldUse2DCommands(drawCommand, frameState) {\n  if (frameState.mode !== SceneMode.SCENE2D || drawCommand.model._projectTo2D) {\n    return;\n  }\n\n  const idl2D =\n    frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n\n  // Using the draw command's bounding sphere might cause primitives to not render\n  // over the IDL, even if they are part of the same model.\n  const model = drawCommand.model;\n  const boundingSphere = model.sceneGraph._boundingSphere2D;\n  const left = boundingSphere.center.y - boundingSphere.radius;\n  const right = boundingSphere.center.y + boundingSphere.radius;\n\n  return (left < idl2D && right > idl2D) || (left < -idl2D && right > -idl2D);\n}\n\nexport default ModelExperimentalDrawCommand;\n","import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport InstancingPipelineStage from \"./InstancingPipelineStage.js\";\nimport ModelMatrixUpdateStage from \"./ModelMatrixUpdateStage.js\";\nimport TranslationRotationScale from \"../../Core/TranslationRotationScale.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\n\n/**\n * An in-memory representation of a node as part of the {@link ModelExperimentalSceneGraph}.\n *\n *\n * @param {Object} options An object containing the following options:\n * @param {ModelComponents.Node} options.node The corresponding node components from the 3D model\n * @param {Matrix4} options.transform The transform of this node, excluding transforms from the node's ancestors or children.\n * @param {Matrix4} options.transformToRoot The product of the transforms of all the node's ancestors, excluding the node's own transform.\n * @param {ModelExperimentalSceneGraph} options.sceneGraph The scene graph this node belongs to.\n * @param {Number[]} options.children The indices of the children of this node in the runtime nodes array of the scene graph.\n *\n * @alias ModelExperimentalNode\n * @constructor\n *\n * @private\n */\nexport default function ModelExperimentalNode(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.node\", options.node);\n  Check.typeOf.object(\"options.transform\", options.transform);\n  Check.typeOf.object(\"options.transformToRoot\", options.transformToRoot);\n  Check.typeOf.object(\"options.sceneGraph\", options.sceneGraph);\n  Check.typeOf.object(\"options.children\", options.children);\n  //>>includeEnd('debug');\n\n  const sceneGraph = options.sceneGraph;\n  const transform = options.transform;\n  const transformToRoot = options.transformToRoot;\n  const node = options.node;\n\n  this._sceneGraph = sceneGraph;\n  this._children = options.children;\n  this._node = node;\n\n  this._name = node.name; // Helps with debugging\n\n  this._originalTransform = Matrix4.clone(transform, this._originalTransform);\n  this._transform = Matrix4.clone(transform, this._transform);\n  this._transformToRoot = Matrix4.clone(transformToRoot, this._transformToRoot);\n\n  this._originalTransform = Matrix4.clone(transform, this._originalTransform);\n  const computedTransform = Matrix4.multiply(\n    transformToRoot,\n    transform,\n    new Matrix4()\n  );\n  this._computedTransform = computedTransform;\n  this._transformDirty = false;\n\n  // Used for animation\n  this._transformParameters = defined(node.matrix)\n    ? undefined\n    : new TranslationRotationScale(node.translation, node.rotation, node.scale);\n  this._morphWeights = defined(node.morphWeights)\n    ? node.morphWeights.slice()\n    : [];\n\n  // Will be set by the scene graph after the skins have been created\n  this._runtimeSkin = undefined;\n  this._computedJointMatrices = [];\n\n  /**\n   * Pipeline stages to apply across all the mesh primitives of this node. This\n   * is an array of classes, each with a static method called\n   * <code>process()</code>\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.pipelineStages = [];\n\n  /**\n   * The mesh primitives that belong to this node\n   *\n   * @type {ModelExperimentalPrimitive[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimePrimitives = [];\n\n  /**\n   * Update stages to apply to this primitive.\n   *\n   * @private\n   */\n  this.updateStages = [];\n}\n\nObject.defineProperties(ModelExperimentalNode.prototype, {\n  /**\n   * The internal node this runtime node represents.\n   *\n   * @type {ModelComponents.Node}\n   * @readonly\n   *\n   * @private\n   */\n  node: {\n    get: function () {\n      return this._node;\n    },\n  },\n  /**\n   * The scene graph this node belongs to.\n   *\n   * @type {ModelExperimentalSceneGraph}\n   * @readonly\n   *\n   * @private\n   */\n  sceneGraph: {\n    get: function () {\n      return this._sceneGraph;\n    },\n  },\n\n  /**\n   * The indices of the children of this node in the scene graph.\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  children: {\n    get: function () {\n      return this._children;\n    },\n  },\n\n  /**\n   * The node's local space transform. This can be changed externally so animation\n   * can be driven by another source, not just an animation in the model's asset.\n   * <p>\n   * For changes to take effect, this property must be assigned to;\n   * setting individual elements of the matrix will not work.\n   * </p>\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {Matrix4}\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n    set: function (value) {\n      if (Matrix4.equals(this._transform, value)) {\n        return;\n      }\n      this._transformDirty = true;\n      this._transform = Matrix4.clone(value, this._transform);\n    },\n  },\n\n  /**\n   * The transforms of all the node's ancestors, not including this node's\n   * transform.\n   *\n   * @see ModelExperimentalNode#computedTransform\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  transformToRoot: {\n    get: function () {\n      return this._transformToRoot;\n    },\n  },\n\n  /**\n   * A transform from the node's local space to the model's scene graph space.\n   * This is the product of transformToRoot * transform.\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  computedTransform: {\n    get: function () {\n      return this._computedTransform;\n    },\n  },\n\n  /**\n   * The node's original transform, as specified in the model. Does not include transformations from the node's ancestors.\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {Matrix4}\n   * @readonly\n   */\n  originalTransform: {\n    get: function () {\n      return this._originalTransform;\n    },\n  },\n\n  /**\n   * The node's local space translation. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {Cartesian3}\n   *\n   * @exception {DeveloperError} The translation of a node cannot be set if it was defined using a matrix in the model.\n   *\n   * @private\n   */\n  translation: {\n    get: function () {\n      return defined(this._transformParameters)\n        ? this._transformParameters.translation\n        : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\n          \"The translation of a node cannot be set if it was defined using a matrix in the model.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      const currentTranslation = transformParameters.translation;\n      if (Cartesian3.equals(currentTranslation, value)) {\n        return;\n      }\n\n      transformParameters.translation = Cartesian3.clone(\n        value,\n        transformParameters.translation\n      );\n\n      updateTransformFromParameters(this, transformParameters);\n    },\n  },\n\n  /**\n   * The node's local space rotation. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {Quaternion}\n   *\n   * @exception {DeveloperError} The rotation of a node cannot be set if it was defined using a matrix in the model.\n   *\n   * @private\n   */\n  rotation: {\n    get: function () {\n      return defined(this._transformParameters)\n        ? this._transformParameters.rotation\n        : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\n          \"The rotation of a node cannot be set if it was defined using a matrix in the model.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      const currentRotation = transformParameters.rotation;\n      if (Quaternion.equals(currentRotation, value)) {\n        return;\n      }\n\n      transformParameters.rotation = Quaternion.clone(\n        value,\n        transformParameters.rotation\n      );\n\n      updateTransformFromParameters(this, transformParameters);\n    },\n  },\n\n  /**\n   * The node's local space scale. This is used internally to allow\n   * animations in the model's asset to affect the node's properties.\n   *\n   * If the node's transformation was originally described using a matrix\n   * in the model, then this will return undefined.\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {Cartesian3}\n   *\n   * @exception {DeveloperError} The scale of a node cannot be set if it was defined using a matrix in the model.\n   * @private\n   */\n  scale: {\n    get: function () {\n      return defined(this._transformParameters)\n        ? this._transformParameters.scale\n        : undefined;\n    },\n    set: function (value) {\n      const transformParameters = this._transformParameters;\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(transformParameters)) {\n        throw new DeveloperError(\n          \"The scale of a node cannot be set if it was defined using a matrix in the model.\"\n        );\n      }\n      //>>includeEnd('debug');\n      const currentScale = transformParameters.scale;\n      if (Cartesian3.equals(currentScale, value)) {\n        return;\n      }\n\n      transformParameters.scale = Cartesian3.clone(\n        value,\n        transformParameters.scale\n      );\n\n      updateTransformFromParameters(this, transformParameters);\n    },\n  },\n\n  /**\n   * The node's morph weights. This is used internally to allow animations\n   * in the model's asset to affect the node's properties.\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {Number[]}\n   *\n   * @private\n   */\n  morphWeights: {\n    get: function () {\n      return this._morphWeights;\n    },\n    set: function (value) {\n      const valueLength = value.length;\n      //>>includeStart('debug', pragmas.debug);\n      if (this._morphWeights.length !== valueLength) {\n        throw new DeveloperError(\n          \"value must have the same length as the original weights array.\"\n        );\n      }\n      //>>includeEnd('debug');\n      for (let i = 0; i < valueLength; i++) {\n        this._morphWeights[i] = value[i];\n      }\n    },\n  },\n\n  /**\n   * The skin applied to this node, if it exists.\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {ModelExperimentalSkin}\n   * @readonly\n   */\n  runtimeSkin: {\n    get: function () {\n      return this._runtimeSkin;\n    },\n  },\n\n  /**\n   * The computed joint matrices of this node, derived from its skin.\n   *\n   * @memberof ModelExperimentalNode.prototype\n   * @type {Matrix4[]}\n   * @readonly\n   */\n  computedJointMatrices: {\n    get: function () {\n      return this._computedJointMatrices;\n    },\n  },\n});\n\nfunction updateTransformFromParameters(runtimeNode, transformParameters) {\n  runtimeNode._transformDirty = true;\n\n  runtimeNode._transform = Matrix4.fromTranslationRotationScale(\n    transformParameters,\n    runtimeNode._transform\n  );\n}\n\n/**\n * Returns the child with the given index.\n *\n * @param {Number} index The index of the child.\n *\n * @returns {ModelExperimentalNode}\n *\n * @example\n * // Iterate through all children of a runtime node.\n * for (let i = 0; i < runtimeNode.children.length; i++)\n * {\n *   const childNode = runtimeNode.getChild(i);\n * }\n */\nModelExperimentalNode.prototype.getChild = function (index) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"index\", index);\n  if (index < 0 || index >= this.children.length) {\n    throw new DeveloperError(\n      \"index must be greater than or equal to 0 and less than the number of children.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  return this.sceneGraph.runtimeNodes[this.children[index]];\n};\n\n/**\n * Configure the node pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @private\n */\nModelExperimentalNode.prototype.configurePipeline = function () {\n  const node = this.node;\n  const pipelineStages = this.pipelineStages;\n  pipelineStages.length = 0;\n  const updateStages = this.updateStages;\n  updateStages.length = 0;\n\n  if (defined(node.instances)) {\n    pipelineStages.push(InstancingPipelineStage);\n  }\n\n  updateStages.push(ModelMatrixUpdateStage);\n};\n\n/**\n * Updates the computed transform used for rendering and instancing.\n *\n * @private\n */\nModelExperimentalNode.prototype.updateComputedTransform = function () {\n  this._computedTransform = Matrix4.multiply(\n    this._transformToRoot,\n    this._transform,\n    this._computedTransform\n  );\n};\n\n/**\n * Updates the joint matrices for this node, where each matrix is computed as\n * computedJointMatrix = nodeWorldTransform^(-1) * skinJointMatrix.\n *\n * @private\n */\nModelExperimentalNode.prototype.updateJointMatrices = function () {\n  const runtimeSkin = this._runtimeSkin;\n  if (!defined(runtimeSkin)) {\n    return;\n  }\n\n  runtimeSkin.updateJointMatrices();\n\n  const computedJointMatrices = this._computedJointMatrices;\n  const skinJointMatrices = runtimeSkin.jointMatrices;\n  const length = skinJointMatrices.length;\n\n  for (let i = 0; i < length; i++) {\n    if (!defined(computedJointMatrices[i])) {\n      computedJointMatrices[i] = new Matrix4();\n    }\n\n    const nodeWorldTransform = Matrix4.multiplyTransformation(\n      this.transformToRoot,\n      this.transform,\n      computedJointMatrices[i]\n    );\n\n    const inverseNodeWorldTransform = Matrix4.inverseTransformation(\n      nodeWorldTransform,\n      computedJointMatrices[i]\n    );\n\n    computedJointMatrices[i] = Matrix4.multiplyTransformation(\n      inverseNodeWorldTransform,\n      skinJointMatrices[i],\n      computedJointMatrices[i]\n    );\n  }\n};\n","import Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport AlphaPipelineStage from \"./AlphaPipelineStage.js\";\nimport BatchTexturePipelineStage from \"./BatchTexturePipelineStage.js\";\nimport CustomShaderMode from \"./CustomShaderMode.js\";\nimport CustomShaderPipelineStage from \"./CustomShaderPipelineStage.js\";\nimport FeatureIdPipelineStage from \"./FeatureIdPipelineStage.js\";\nimport CPUStylingPipelineStage from \"./CPUStylingPipelineStage.js\";\nimport DequantizationPipelineStage from \"./DequantizationPipelineStage.js\";\nimport GeometryPipelineStage from \"./GeometryPipelineStage.js\";\nimport LightingPipelineStage from \"./LightingPipelineStage.js\";\nimport MaterialPipelineStage from \"./MaterialPipelineStage.js\";\nimport MetadataPipelineStage from \"./MetadataPipelineStage.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport MorphTargetsPipelineStage from \"./MorphTargetsPipelineStage.js\";\nimport PickingPipelineStage from \"./PickingPipelineStage.js\";\nimport PointCloudAttenuationPipelineStage from \"./PointCloudAttenuationPipelineStage.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SceneMode2DPipelineStage from \"./SceneMode2DPipelineStage.js\";\nimport SelectedFeatureIdPipelineStage from \"./SelectedFeatureIdPipelineStage.js\";\nimport SkinningPipelineStage from \"./SkinningPipelineStage.js\";\nimport WireframePipelineStage from \"./WireframePipelineStage.js\";\n\n/**\n * In memory representation of a single primitive, that is, a primitive\n * and its corresponding mesh.\n *\n * @param {Object} options An object containing the following options:\n * @param {ModelComponents.Primitive} options.primitive The primitive component.\n * @param {ModelComponents.Node} options.node The node that this primitive belongs to.\n * @param {ModelExperimental} options.model The {@link ModelExperimental} this primitive belongs to.\n *\n * @alias ModelExperimentalPrimitive\n * @constructor\n *\n * @private\n */\nexport default function ModelExperimentalPrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const primitive = options.primitive;\n  const node = options.node;\n  const model = options.model;\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.primitive\", primitive);\n  Check.typeOf.object(\"options.node\", node);\n  Check.typeOf.object(\"options.model\", model);\n  //>>includeEnd('debug');\n\n  /**\n   * The primitive component associated with this primitive.\n   *\n   * @type {ModelComponents.Primitive}\n   *\n   * @private\n   */\n  this.primitive = primitive;\n\n  /**\n   * A reference to the node this primitive belongs to.\n   *\n   * @type {ModelComponents.Node}\n   *\n   * @private\n   */\n  this.node = node;\n\n  /**\n   * A reference to the model\n   *\n   * @type {ModelExperimental}\n   *\n   * @private\n   */\n  this.model = model;\n\n  /**\n   * Pipeline stages to apply to this primitive. This\n   * is an array of classes, each with a static method called\n   * <code>process()</code>\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.pipelineStages = [];\n\n  /**\n   * The generated {@link ModelExperimentalDrawCommand} associated with this primitive.\n   *\n   * @type {ModelExperimentalDrawCommand}\n   *\n   * @private\n   */\n  this.drawCommand = undefined;\n\n  /**\n   * The bounding sphere of this primitive in object-space.\n   *\n   * @type {BoundingSphere}\n   *\n   * @private\n   */\n  this.boundingSphere = undefined;\n\n  /**\n   * The bounding sphere of this primitive in 2D world space.\n   *\n   * @type {BoundingSphere}\n   *\n   * @private\n   */\n  this.boundingSphere2D = undefined;\n\n  /**\n   * A buffer containing the primitive's positions projected to 2D world coordinates.\n   * Used for rendering in 2D / CV mode. The memory is managed by ModelExperimental;\n   * this is just a reference.\n   *\n   * @type {Buffer}\n   * @readonly\n   *\n   * @private\n   */\n  this.positionBuffer2D = undefined;\n\n  /**\n   * Update stages to apply to this primitive.\n   *\n   * @private\n   */\n  this.updateStages = [];\n}\n\n/**\n * Configure the primitive pipeline stages. If the pipeline needs to be re-run,\n * call this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nModelExperimentalPrimitive.prototype.configurePipeline = function (frameState) {\n  const pipelineStages = this.pipelineStages;\n  pipelineStages.length = 0;\n\n  const primitive = this.primitive;\n  const node = this.node;\n  const model = this.model;\n  const customShader = model.customShader;\n  const useWebgl2 = frameState.context.webgl2;\n  const mode = frameState.mode;\n\n  const use2D =\n    mode !== SceneMode.SCENE3D && !frameState.scene3DOnly && model._projectTo2D;\n  const hasMorphTargets =\n    defined(primitive.morphTargets) && primitive.morphTargets.length > 0;\n  const hasSkinning = defined(node.skin);\n  const hasCustomShader = defined(customShader);\n  const hasCustomFragmentShader =\n    hasCustomShader && defined(customShader.fragmentShaderText);\n  const materialsEnabled =\n    !hasCustomFragmentShader ||\n    customShader.mode !== CustomShaderMode.REPLACE_MATERIAL;\n  const hasQuantization = ModelExperimentalUtility.hasQuantizedAttributes(\n    primitive.attributes\n  );\n  const generateWireframeIndices =\n    model.debugWireframe &&\n    PrimitiveType.isTriangles(primitive.primitiveType) &&\n    // Generating index buffers for wireframes is always possible in WebGL2.\n    // However, this will only work in WebGL1 if the model was constructed with\n    // enableDebugWireframe set to true.\n    (model._enableDebugWireframe || useWebgl2);\n\n  const pointCloudShading = model.pointCloudShading;\n  const hasAttenuation =\n    defined(pointCloudShading) && pointCloudShading.attenuation;\n\n  const featureIdFlags = inspectFeatureIds(model, node, primitive);\n\n  // Start of pipeline -----------------------------------------------------\n  if (use2D) {\n    pipelineStages.push(SceneMode2DPipelineStage);\n  }\n\n  pipelineStages.push(GeometryPipelineStage);\n\n  if (generateWireframeIndices) {\n    pipelineStages.push(WireframePipelineStage);\n  }\n\n  if (hasMorphTargets) {\n    pipelineStages.push(MorphTargetsPipelineStage);\n  }\n\n  if (hasSkinning) {\n    pipelineStages.push(SkinningPipelineStage);\n  }\n\n  if (hasAttenuation && primitive.primitiveType === PrimitiveType.POINTS) {\n    pipelineStages.push(PointCloudAttenuationPipelineStage);\n  }\n\n  if (hasQuantization) {\n    pipelineStages.push(DequantizationPipelineStage);\n  }\n\n  if (materialsEnabled) {\n    pipelineStages.push(MaterialPipelineStage);\n  }\n\n  // These stages are always run to ensure structs\n  // are declared to avoid compilation errors.\n  pipelineStages.push(FeatureIdPipelineStage);\n  pipelineStages.push(MetadataPipelineStage);\n\n  if (featureIdFlags.hasPropertyTable) {\n    pipelineStages.push(SelectedFeatureIdPipelineStage);\n    pipelineStages.push(BatchTexturePipelineStage);\n    pipelineStages.push(CPUStylingPipelineStage);\n  }\n\n  if (hasCustomShader) {\n    pipelineStages.push(CustomShaderPipelineStage);\n  }\n\n  pipelineStages.push(LightingPipelineStage);\n\n  if (model.allowPicking) {\n    pipelineStages.push(PickingPipelineStage);\n  }\n\n  pipelineStages.push(AlphaPipelineStage);\n\n  return;\n};\n\nfunction inspectFeatureIds(model, node, primitive) {\n  let featureIds;\n  // Check instances first, as this is the most specific type of\n  // feature ID\n  if (defined(node.instances)) {\n    featureIds = ModelExperimentalUtility.getFeatureIdsByLabel(\n      node.instances.featureIds,\n      model.instanceFeatureIdLabel\n    );\n\n    if (defined(featureIds)) {\n      return {\n        hasFeatureIds: true,\n        hasPropertyTable: defined(featureIds.propertyTableId),\n      };\n    }\n  }\n\n  featureIds = ModelExperimentalUtility.getFeatureIdsByLabel(\n    primitive.featureIds,\n    model.featureIdLabel\n  );\n  if (defined(featureIds)) {\n    return {\n      hasFeatureIds: true,\n      hasPropertyTable: defined(featureIds.propertyTableId),\n    };\n  }\n\n  return {\n    hasFeatureIds: false,\n    hasPropertyTable: false,\n  };\n}\n","import buildDrawCommand from \"./buildDrawCommand.js\";\nimport BoundingSphere from \"../../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport ImageBasedLightingPipelineStage from \"./ImageBasedLightingPipelineStage.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelColorPipelineStage from \"./ModelColorPipelineStage.js\";\nimport ModelClippingPlanesPipelineStage from \"./ModelClippingPlanesPipelineStage.js\";\nimport ModelExperimentalPrimitive from \"./ModelExperimentalPrimitive.js\";\nimport ModelExperimentalNode from \"./ModelExperimentalNode.js\";\nimport ModelExperimentalSkin from \"./ModelExperimentalSkin.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport ModelRenderResources from \"./ModelRenderResources.js\";\nimport ModelSplitterPipelineStage from \"./ModelSplitterPipelineStage.js\";\nimport NodeRenderResources from \"./NodeRenderResources.js\";\nimport PrimitiveRenderResources from \"./PrimitiveRenderResources.js\";\nimport SceneMode from \"../SceneMode.js\";\nimport SplitDirection from \"../SplitDirection.js\";\nimport Transforms from \"../../Core/Transforms.js\";\n\n/**\n * An in memory representation of the scene graph for a {@link ModelExperimental}\n *\n * @param {Object} options An object containing the following options\n * @param {ModelExperimental} options.model The model this scene graph belongs to\n * @param {ModelComponents} options.modelComponents The model components describing the model\n *\n * @alias ModelExperimentalSceneGraph\n * @constructor\n *\n * @private\n */\nexport default function ModelExperimentalSceneGraph(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  const components = options.modelComponents;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.model\", options.model);\n  Check.typeOf.object(\"options.modelComponents\", components);\n  //>>includeEnd('debug');\n\n  /**\n   * A reference to the {@link ModelExperimental} that owns this scene graph.\n   *\n   * @type {ModelExperimental}\n   * @readonly\n   *\n   * @private\n   */\n  this._model = options.model;\n\n  /**\n   * The model components that represent the contents of the 3D model file.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  this._components = components;\n\n  /**\n   * Pipeline stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._pipelineStages = [];\n\n  /**\n   * Update stages to apply across the model.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._updateStages = [];\n\n  /**\n   * The runtime nodes that make up the scene graph\n   *\n   * @type {ModelExperimentalNode[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeNodes = [];\n\n  /**\n   * The indices of the root nodes in the runtime nodes array.\n   *\n   * @type {Number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._rootNodes = [];\n\n  /**\n   * The indices of the skinned nodes in the runtime nodes array. These refer\n   * to the nodes that will be manipulated by their skin, as opposed to the nodes\n   * acting as joints for the skin.\n   *\n   * @type {Number[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._skinnedNodes = [];\n\n  /**\n   * The runtime skins that affect nodes in the scene graph.\n   *\n   * @type {ModelExperimentalSkin[]}\n   * @readonly\n   *\n   * @private\n   */\n  this._runtimeSkins = [];\n\n  /**\n   * Pipeline stages to apply to this model. This\n   * is an array of classes, each with a static method called\n   * <code>process()</code>\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.modelPipelineStages = [];\n\n  // The scene graph's bounding sphere is model space, so that\n  // the model's bounding sphere can be recomputed when given a\n  // new model matrix.\n  this._boundingSphere = undefined;\n\n  // The 2D bounding sphere is in world space. This is checked\n  // by the draw commands to see if the model is over the IDL,\n  // and if so, renders the primitives using extra commands.\n  this._boundingSphere2D = undefined;\n\n  this._computedModelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._computedModelMatrix2D = Matrix4.clone(Matrix4.IDENTITY);\n\n  this._axisCorrectionMatrix = ModelExperimentalUtility.getAxisCorrectionMatrix(\n    components.upAxis,\n    components.forwardAxis,\n    new Matrix4()\n  );\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelExperimentalSceneGraph.prototype, {\n  /**\n   * The model components this scene graph represents.\n   *\n   * @type {ModelComponents}\n   * @readonly\n   *\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n\n  /**\n   * The axis-corrected model matrix.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  computedModelMatrix: {\n    get: function () {\n      return this._computedModelMatrix;\n    },\n  },\n\n  /**\n   * A matrix to correct from y-up in some model formats (e.g. glTF) to the\n   * z-up coordinate system Cesium uses.\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @private\n   */\n  axisCorrectionMatrix: {\n    get: function () {\n      return this._axisCorrectionMatrix;\n    },\n  },\n\n  /**\n   * The bounding sphere containing all the primitives in the scene graph\n   * in model space.\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @private\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\nfunction initialize(sceneGraph) {\n  const components = sceneGraph._components;\n  const scene = components.scene;\n\n  computeModelMatrix(sceneGraph);\n\n  const nodes = components.nodes;\n  const nodesLength = nodes.length;\n\n  // Initialize this array to be the same size as the nodes array in the model's file.\n  // This is so nodes can be stored by their index in the file, for future ease of access.\n  sceneGraph._runtimeNodes = new Array(nodesLength);\n\n  const rootNodes = scene.nodes;\n  const rootNodesLength = rootNodes.length;\n  const transformToRoot = Matrix4.IDENTITY;\n  for (let i = 0; i < rootNodesLength; i++) {\n    const rootNode = scene.nodes[i];\n\n    const rootNodeIndex = traverseSceneGraph(\n      sceneGraph,\n      rootNode,\n      transformToRoot\n    );\n\n    sceneGraph._rootNodes.push(rootNodeIndex);\n  }\n\n  // Handle skins after all runtime nodes are created\n  const skins = components.skins;\n  const runtimeSkins = sceneGraph._runtimeSkins;\n\n  const skinsLength = skins.length;\n  for (let i = 0; i < skinsLength; i++) {\n    const skin = skins[i];\n    runtimeSkins.push(\n      new ModelExperimentalSkin({\n        skin: skin,\n        sceneGraph: sceneGraph,\n      })\n    );\n  }\n\n  const skinnedNodes = sceneGraph._skinnedNodes;\n  const skinnedNodesLength = skinnedNodes.length;\n  for (let i = 0; i < skinnedNodesLength; i++) {\n    const skinnedNodeIndex = skinnedNodes[i];\n    const skinnedNode = sceneGraph._runtimeNodes[skinnedNodeIndex];\n\n    // Use the index of the skin in the model components to find\n    // the corresponding runtime skin.\n    const skin = nodes[skinnedNodeIndex].skin;\n    const skinIndex = skin.index;\n\n    skinnedNode._runtimeSkin = runtimeSkins[skinIndex];\n    skinnedNode.updateJointMatrices();\n  }\n}\n\nfunction computeModelMatrix(sceneGraph) {\n  const components = sceneGraph._components;\n  const model = sceneGraph._model;\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(\n    model.modelMatrix,\n    components.transform,\n    sceneGraph._computedModelMatrix\n  );\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyTransformation(\n    sceneGraph._computedModelMatrix,\n    sceneGraph._axisCorrectionMatrix,\n    sceneGraph._computedModelMatrix\n  );\n\n  sceneGraph._computedModelMatrix = Matrix4.multiplyByUniformScale(\n    sceneGraph._computedModelMatrix,\n    model.computedScale,\n    sceneGraph._computedModelMatrix\n  );\n}\n\nconst scratchComputedTranslation = new Cartesian3();\n\nfunction computeModelMatrix2D(sceneGraph, frameState) {\n  const computedModelMatrix = sceneGraph._computedModelMatrix;\n  const translation = Matrix4.getTranslation(\n    computedModelMatrix,\n    scratchComputedTranslation\n  );\n\n  if (!Cartesian3.equals(translation, Cartesian3.ZERO)) {\n    sceneGraph._computedModelMatrix2D = Transforms.basisTo2D(\n      frameState.mapProjection,\n      computedModelMatrix,\n      sceneGraph._computedModelMatrix2D\n    );\n  } else {\n    const center = sceneGraph.boundingSphere.center;\n    const to2D = Transforms.wgs84To2DModelMatrix(\n      frameState.mapProjection,\n      center,\n      sceneGraph._computedModelMatrix2D\n    );\n    sceneGraph._computedModelMatrix2D = Matrix4.multiply(\n      to2D,\n      computedModelMatrix,\n      sceneGraph._computedModelMatrix2D\n    );\n  }\n\n  sceneGraph._boundingSphere2D = BoundingSphere.transform(\n    sceneGraph._boundingSphere,\n    sceneGraph._computedModelMatrix2D,\n    sceneGraph._boundingSphere2D\n  );\n}\n\n/**\n * Recursively traverse through the nodes in the scene graph, using depth-first\n * post-order traversal.\n *\n * @param {ModelSceneGraph} sceneGraph The scene graph\n * @param {ModelComponents.Node} node The current node\n * @param {Matrix4} transformToRoot The transforms of this node's ancestors.\n *\n * @returns {Number} The index of this node in the runtimeNodes array.\n *\n * @private\n */\nfunction traverseSceneGraph(sceneGraph, node, transformToRoot) {\n  // The indices of the children of this node in the runtimeNodes array.\n  const childrenIndices = [];\n  const transform = ModelExperimentalUtility.getNodeTransform(node);\n\n  // Traverse through scene graph.\n  const childrenLength = node.children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childNode = node.children[i];\n    const childNodeTransformToRoot = Matrix4.multiplyTransformation(\n      transformToRoot,\n      transform,\n      new Matrix4()\n    );\n\n    const childIndex = traverseSceneGraph(\n      sceneGraph,\n      childNode,\n      childNodeTransformToRoot\n    );\n    childrenIndices.push(childIndex);\n  }\n\n  // Process node and mesh primitives.\n  const runtimeNode = new ModelExperimentalNode({\n    node: node,\n    transform: transform,\n    transformToRoot: transformToRoot,\n    children: childrenIndices,\n    sceneGraph: sceneGraph,\n  });\n\n  const primitivesLength = node.primitives.length;\n  for (let i = 0; i < primitivesLength; i++) {\n    runtimeNode.runtimePrimitives.push(\n      new ModelExperimentalPrimitive({\n        primitive: node.primitives[i],\n        node: node,\n        model: sceneGraph._model,\n      })\n    );\n  }\n\n  const index = node.index;\n  sceneGraph._runtimeNodes[index] = runtimeNode;\n  if (defined(node.skin)) {\n    sceneGraph._skinnedNodes.push(index);\n  }\n\n  return index;\n}\n\nconst scratchModelPositionMin = new Cartesian3();\nconst scratchModelPositionMax = new Cartesian3();\nconst scratchPrimitivePositionMin = new Cartesian3();\nconst scratchPrimitivePositionMax = new Cartesian3();\n/**\n * Generates the {@link ModelExperimentalDrawCommand} for each primitive in the model.\n *\n * @param {FrameState} frameState The current frame state. This is needed to\n * allocate GPU resources as needed.\n *\n * @private\n */\nModelExperimentalSceneGraph.prototype.buildDrawCommands = function (\n  frameState\n) {\n  const model = this._model;\n  const modelRenderResources = new ModelRenderResources(model);\n\n  this.configurePipeline();\n  const modelPipelineStages = this.modelPipelineStages;\n\n  let i, j, k;\n  for (i = 0; i < modelPipelineStages.length; i++) {\n    const modelPipelineStage = modelPipelineStages[i];\n    modelPipelineStage.process(modelRenderResources, model, frameState);\n  }\n\n  const modelPositionMin = Cartesian3.fromElements(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    scratchModelPositionMin\n  );\n  const modelPositionMax = Cartesian3.fromElements(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    scratchModelPositionMax\n  );\n\n  for (i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n    runtimeNode.configurePipeline();\n    const nodePipelineStages = runtimeNode.pipelineStages;\n\n    const nodeRenderResources = new NodeRenderResources(\n      modelRenderResources,\n      runtimeNode\n    );\n\n    for (j = 0; j < nodePipelineStages.length; j++) {\n      const nodePipelineStage = nodePipelineStages[j];\n\n      nodePipelineStage.process(\n        nodeRenderResources,\n        runtimeNode.node,\n        frameState\n      );\n    }\n\n    const nodeTransform = runtimeNode.computedTransform;\n    for (j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n\n      runtimePrimitive.configurePipeline(frameState);\n      const primitivePipelineStages = runtimePrimitive.pipelineStages;\n\n      const primitiveRenderResources = new PrimitiveRenderResources(\n        nodeRenderResources,\n        runtimePrimitive\n      );\n\n      for (k = 0; k < primitivePipelineStages.length; k++) {\n        const primitivePipelineStage = primitivePipelineStages[k];\n\n        primitivePipelineStage.process(\n          primitiveRenderResources,\n          runtimePrimitive.primitive,\n          frameState\n        );\n      }\n\n      runtimePrimitive.boundingSphere = BoundingSphere.clone(\n        primitiveRenderResources.boundingSphere,\n        new BoundingSphere()\n      );\n\n      const primitivePositionMin = Matrix4.multiplyByPoint(\n        nodeTransform,\n        primitiveRenderResources.positionMin,\n        scratchPrimitivePositionMin\n      );\n      const primitivePositionMax = Matrix4.multiplyByPoint(\n        nodeTransform,\n        primitiveRenderResources.positionMax,\n        scratchPrimitivePositionMax\n      );\n\n      Cartesian3.minimumByComponent(\n        modelPositionMin,\n        primitivePositionMin,\n        modelPositionMin\n      );\n      Cartesian3.maximumByComponent(\n        modelPositionMax,\n        primitivePositionMax,\n        modelPositionMax\n      );\n\n      const drawCommand = buildDrawCommand(\n        primitiveRenderResources,\n        frameState\n      );\n\n      runtimePrimitive.drawCommand = drawCommand;\n    }\n  }\n\n  this._boundingSphere = BoundingSphere.fromCornerPoints(\n    modelPositionMin,\n    modelPositionMax,\n    new BoundingSphere()\n  );\n\n  this._boundingSphere = BoundingSphere.transformWithoutScale(\n    this._boundingSphere,\n    this._axisCorrectionMatrix,\n    this._boundingSphere\n  );\n\n  model._boundingSphere = BoundingSphere.transform(\n    this._boundingSphere,\n    model.modelMatrix,\n    model._boundingSphere\n  );\n  model._initialRadius = model._boundingSphere.radius;\n  model._boundingSphere.radius *= model._clampedScale;\n};\n\n/**\n * Configure the model pipeline stages. If the pipeline needs to be re-run, call\n * this method again to ensure the correct sequence of pipeline stages are\n * used.\n *\n * @private\n */\nModelExperimentalSceneGraph.prototype.configurePipeline = function () {\n  const modelPipelineStages = this.modelPipelineStages;\n  modelPipelineStages.length = 0;\n\n  const model = this._model;\n\n  if (defined(model.color)) {\n    modelPipelineStages.push(ModelColorPipelineStage);\n  }\n\n  if (model.imageBasedLighting.enabled) {\n    modelPipelineStages.push(ImageBasedLightingPipelineStage);\n  }\n\n  if (model.isClippingEnabled()) {\n    modelPipelineStages.push(ModelClippingPlanesPipelineStage);\n  }\n\n  if (\n    defined(model.splitDirection) &&\n    model.splitDirection !== SplitDirection.NONE\n  ) {\n    modelPipelineStages.push(ModelSplitterPipelineStage);\n  }\n};\n\nModelExperimentalSceneGraph.prototype.update = function (\n  frameState,\n  updateForAnimations\n) {\n  let i, j, k;\n\n  for (i = 0; i < this._runtimeNodes.length; i++) {\n    const runtimeNode = this._runtimeNodes[i];\n\n    for (j = 0; j < runtimeNode.updateStages.length; j++) {\n      const nodeUpdateStage = runtimeNode.updateStages[j];\n      nodeUpdateStage.update(runtimeNode, this, frameState);\n    }\n\n    const disableAnimations =\n      frameState.mode !== SceneMode.SCENE3D && this._model._projectTo2D;\n    if (updateForAnimations && !disableAnimations) {\n      this.updateJointMatrices();\n    }\n\n    for (j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      for (k = 0; k < runtimePrimitive.updateStages.length; k++) {\n        const stage = runtimePrimitive.updateStages[k];\n        stage.update(runtimePrimitive);\n      }\n    }\n  }\n};\n\nModelExperimentalSceneGraph.prototype.updateModelMatrix = function (\n  frameState\n) {\n  computeModelMatrix(this);\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    computeModelMatrix2D(this, frameState);\n  }\n\n  // Mark all root nodes as dirty. Any and all children will be\n  // affected recursively in the update stage.\n  const rootNodes = this._rootNodes;\n  for (let i = 0; i < rootNodes.length; i++) {\n    const node = this._runtimeNodes[rootNodes[i]];\n    node._transformDirty = true;\n  }\n};\n\n/**\n * Updates the joint matrices for the skins and nodes of the model.\n *\n * @private\n */\nModelExperimentalSceneGraph.prototype.updateJointMatrices = function () {\n  const skinnedNodes = this._skinnedNodes;\n  const length = skinnedNodes.length;\n\n  for (let i = 0; i < length; i++) {\n    const nodeIndex = skinnedNodes[i];\n    const runtimeNode = this._runtimeNodes[nodeIndex];\n    runtimeNode.updateJointMatrices();\n  }\n};\n\nfunction forEachRuntimePrimitive(sceneGraph, callback) {\n  for (let i = 0; i < sceneGraph._runtimeNodes.length; i++) {\n    const runtimeNode = sceneGraph._runtimeNodes[i];\n    for (let j = 0; j < runtimeNode.runtimePrimitives.length; j++) {\n      const runtimePrimitive = runtimeNode.runtimePrimitives[j];\n      callback(runtimePrimitive);\n    }\n  }\n}\n\n/**\n * Traverses through all draw commands and changes the back-face culling setting.\n *\n * @param {Boolean} backFaceCulling The new value for the back-face culling setting.\n *\n * @private\n */\nModelExperimentalSceneGraph.prototype.updateBackFaceCulling = function (\n  backFaceCulling\n) {\n  forEachRuntimePrimitive(this, function (runtimePrimitive) {\n    const drawCommand = runtimePrimitive.drawCommand;\n    drawCommand.backFaceCulling = backFaceCulling;\n  });\n};\n\n/**\n * Traverses through all draw commands and changes the shadow settings.\n *\n * @param {ShadowMode} shadowMode The new shadow settings.\n *\n * @private\n */\nModelExperimentalSceneGraph.prototype.updateShadows = function (shadowMode) {\n  forEachRuntimePrimitive(this, function (runtimePrimitive) {\n    const drawCommand = runtimePrimitive.drawCommand;\n    drawCommand.shadows = shadowMode;\n  });\n};\n\n/**\n * Traverses through all draw commands and changes whether to show the debug bounding volume.\n *\n * @param {Boolean} debugShowBoundingVolume The new value for showing the debug bounding volume.\n *\n * @private\n */\nModelExperimentalSceneGraph.prototype.updateShowBoundingVolume = function (\n  debugShowBoundingVolume\n) {\n  forEachRuntimePrimitive(this, function (runtimePrimitive) {\n    const drawCommand = runtimePrimitive.drawCommand;\n    drawCommand.debugShowBoundingVolume = debugShowBoundingVolume;\n  });\n};\n\n/**\n * Returns an array of draw commands, obtained by traversing through the scene graph and collecting\n * the draw commands associated with each primitive.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @returns {DrawCommand[]} The draw commands of the primitives in the scene graph.\n *\n * @private\n */\nModelExperimentalSceneGraph.prototype.getDrawCommands = function (frameState) {\n  const drawCommands = [];\n  forEachRuntimePrimitive(this, function (runtimePrimitive) {\n    const primitiveDrawCommand = runtimePrimitive.drawCommand;\n    const result = primitiveDrawCommand.getCommands(frameState);\n    drawCommands.push.apply(drawCommands, result);\n  });\n  return drawCommands;\n};\n","import Matrix4 from \"../../Core/Matrix4.js\";\nimport Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\n\n/**\n * An in-memory representation of a skin that affects nodes in the {@link ModelExperimentalSceneGraph}.\n * Skins should only be initialized after all of the {@link ModelExperimentalNode}s have been instantiated\n * by the scene graph.\n *\n * @param {Object} options An object containing the following options:\n * @param {ModelComponents.Skin} options.skin The corresponding skin components from the 3D model\n * @param {ModelExperimentalSceneGraph} options.sceneGraph The scene graph this skin belongs to.\n *\n * @alias ModelExperimentalSkin\n * @constructor\n *\n * @private\n */\nexport default function ModelExperimentalSkin(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.skin\", options.skin);\n  Check.typeOf.object(\"options.sceneGraph\", options.sceneGraph);\n  //>>includeEnd('debug');\n\n  this._sceneGraph = options.sceneGraph;\n  const skin = options.skin;\n\n  this._skin = skin;\n\n  this._inverseBindMatrices = undefined;\n  this._joints = [];\n  this._jointMatrices = [];\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelExperimentalSkin.prototype, {\n  /**\n   * The internal skin this runtime skin represents.\n   *\n   * @memberof ModelExperimentalSkin.prototype\n   * @type {ModelComponents.Skin}\n   * @readonly\n   *\n   * @private\n   */\n  skin: {\n    get: function () {\n      return this._skin;\n    },\n  },\n\n  /**\n   * The scene graph this skin belongs to.\n   *\n   * @type {ModelExperimentalSceneGraph}\n   * @readonly\n   *\n   * @private\n   */\n  sceneGraph: {\n    get: function () {\n      return this._sceneGraph;\n    },\n  },\n\n  /**\n   * The inverse bind matrices of the skin.\n   *\n   * @memberof ModelExperimentalSkin.prototype\n   * @type {Matrix4[]}\n   * @readonly\n   *\n   * @private\n   */\n  inverseBindMatrices: {\n    get: function () {\n      return this._inverseBindMatrices;\n    },\n  },\n\n  /**\n   * The joints of the skin.\n   *\n   * @memberof ModelExperimentalSkin.prototype\n   * @type {ModelExperimentalNode[]}\n   * @readonly\n   *\n   * @private\n   */\n  joints: {\n    get: function () {\n      return this._joints;\n    },\n  },\n\n  /**\n   * The joint matrices for the skin, where each joint matrix is computed as\n   * jointMatrix = jointWorldTransform * inverseBindMatrix.\n   *\n   * Each node that references this skin is responsible for pre-multiplying its inverse\n   * world transform to the joint matrices for its own use.\n   *\n   * @memberof ModelExperimentalSkin.prototype\n   * @type {Matrix4[]}\n   * @readonly\n   *\n   * @private\n   */\n  jointMatrices: {\n    get: function () {\n      return this._jointMatrices;\n    },\n  },\n});\n\nfunction initialize(runtimeSkin) {\n  const skin = runtimeSkin.skin;\n  const inverseBindMatrices = skin.inverseBindMatrices;\n  runtimeSkin._inverseBindMatrices = inverseBindMatrices;\n\n  const joints = skin.joints;\n  const length = joints.length;\n\n  const runtimeNodes = runtimeSkin.sceneGraph._runtimeNodes;\n  const runtimeJoints = runtimeSkin.joints;\n  const runtimeJointMatrices = runtimeSkin._jointMatrices;\n  for (let i = 0; i < length; i++) {\n    const jointIndex = joints[i].index;\n    const runtimeNode = runtimeNodes[jointIndex];\n    runtimeJoints.push(runtimeNode);\n\n    const inverseBindMatrix = inverseBindMatrices[i];\n    const jointMatrix = computeJointMatrix(\n      runtimeNode,\n      inverseBindMatrix,\n      new Matrix4()\n    );\n    runtimeJointMatrices.push(jointMatrix);\n  }\n}\n\nfunction computeJointMatrix(joint, inverseBindMatrix, result) {\n  const jointWorldTransform = Matrix4.multiplyTransformation(\n    joint.transformToRoot,\n    joint.transform,\n    result\n  );\n\n  result = Matrix4.multiplyTransformation(\n    jointWorldTransform,\n    inverseBindMatrix,\n    result\n  );\n\n  return result;\n}\n\n/**\n * Updates the joint matrices for the skin.\n *\n * @private\n */\nModelExperimentalSkin.prototype.updateJointMatrices = function () {\n  const jointMatrices = this._jointMatrices;\n  const length = jointMatrices.length;\n  for (let i = 0; i < length; i++) {\n    const joint = this.joints[i];\n    const inverseBindMatrix = this.inverseBindMatrices[i];\n    jointMatrices[i] = computeJointMatrix(\n      joint,\n      inverseBindMatrix,\n      jointMatrices[i]\n    );\n  }\n};\n","import Check from \"../../Core/Check.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\n\n/**\n * An enum to distinguish the different uses for {@link ModelExperimental},\n * which include individual glTF models, and various 3D Tiles formats\n * (including glTF via <code>3DTILES_content_gltf</code>).\n *\n * @enum {String}\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst ModelExperimentalType = {\n  /**\n   * An individual glTF model.\n   * <p>\n   * Not to be confused with {@link ModelExperimentalType.TILE_GLTF}\n   * which is for 3D Tiles\n   * </p>\n   *\n   * @type {String}\n   * @constant\n   */\n  GLTF: \"GLTF\",\n  /**\n   * A glTF model used as tile content in a 3D Tileset via\n   * <code>3DTILES_content_gltf</code>.\n   * <p>\n   * Not to be confused with {@link ModelExperimentalType.GLTF}\n   * which is for individual models\n   * </p>\n   *\n   * @type {String}\n   * @constant\n   */\n  TILE_GLTF: \"TILE_GLTF\",\n  /**\n   * A 3D Tiles 1.0 Batched 3D Model\n   *\n   * @type {String}\n   * @constant\n   */\n  TILE_B3DM: \"B3DM\",\n  /**\n   * A 3D Tiles 1.0 Instanced 3D Model\n   *\n   * @type {String}\n   * @constant\n   */\n  TILE_I3DM: \"I3DM\",\n  /**\n   * A 3D Tiles 1.0 Point Cloud\n   *\n   * @type {String}\n   * @constant\n   */\n  TILE_PNTS: \"PNTS\",\n\n  /**\n   * GeoJSON content for <code>MAXAR_content_geojson</code> extension\n   *\n   * @type {String}\n   * @constant\n   */\n  TILE_GEOJSON: \"TILE_GEOJSON\",\n};\n\n/**\n * Check if a model is used for 3D Tiles.\n * @param {ModelExperimentalType} modelType The type of model\n * @returns {Boolean} <code>true</code> if the model is a 3D Tiles format, <code>false</code> otherwise\n */\nModelExperimentalType.is3DTiles = function (modelType) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"modelType\", modelType);\n  //>>includeEnd('debug');\n\n  switch (modelType) {\n    case ModelExperimentalType.TILE_GLTF:\n    case ModelExperimentalType.TILE_B3DM:\n    case ModelExperimentalType.TILE_I3DM:\n    case ModelExperimentalType.TILE_PNTS:\n    case ModelExperimentalType.TILE_GEOJSON:\n      return true;\n    case ModelExperimentalType.GLTF:\n      return false;\n    //>>includeStart('debug', pragmas.debug);\n    default:\n      throw new DeveloperError(\"modelType is not a valid value.\");\n    //>>includeEnd('debug');\n  }\n};\n\nexport default Object.freeze(ModelExperimentalType);\n","import Cartesian3 from \"../../Core/Cartesian3.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport Quaternion from \"../../Core/Quaternion.js\";\nimport RuntimeError from \"../../Core/RuntimeError.js\";\nimport Axis from \"../Axis.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\nimport CullFace from \"../CullFace.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport Matrix3 from \"../../Core/Matrix3.js\";\n\n/**\n * Utility functions for {@link ModelExperimental}.\n *\n * @private\n */\nexport default function ModelExperimentalUtility() {}\n\n/**\n * Create a function for reporting when a model fails to load\n *\n * @param {ModelExperimental} model The model to report about\n * @param {String} type The type of object to report about\n * @param {String} path The URI of the model file\n * @return {Function} An error function that throws an error for the failed model\n *\n * @private\n */\nModelExperimentalUtility.getFailedLoadFunction = function (model, type, path) {\n  return function (error) {\n    let message = `Failed to load ${type}: ${path}`;\n    if (defined(error)) {\n      message += `\\n${error.message}`;\n    }\n    return Promise.reject(new RuntimeError(message));\n  };\n};\n\n/**\n * Get a transformation matrix from a node in the model.\n *\n * @param {ModelComponents.Node} node The node components\n * @return {Matrix4} The computed transformation matrix. If no transformation matrix or parameters are specified, this will be the identity matrix.\n *\n * @private\n */\nModelExperimentalUtility.getNodeTransform = function (node) {\n  if (defined(node.matrix)) {\n    return node.matrix;\n  }\n\n  return Matrix4.fromTranslationQuaternionRotationScale(\n    defined(node.translation) ? node.translation : Cartesian3.ZERO,\n    defined(node.rotation) ? node.rotation : Quaternion.IDENTITY,\n    defined(node.scale) ? node.scale : Cartesian3.ONE\n  );\n};\n\n/**\n * Find an attribute by semantic such as POSITION or TANGENT.\n *\n * @param {ModelComponents.Primitive|ModelComponents.Instances} object The primitive components or instances object\n * @param {VertexAttributeSemantic|InstanceAttributeSemantic} semantic The semantic to search for\n * @param {Number} setIndex The set index of the semantic. May be undefined for some semantics (POSITION, NORMAL, TRANSLATION, ROTATION, for example)\n * @return {ModelComponents.Attribute} The selected attribute, or undefined if not found.\n *\n * @private\n */\nModelExperimentalUtility.getAttributeBySemantic = function (\n  object,\n  semantic,\n  setIndex\n) {\n  const attributes = object.attributes;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    const matchesSetIndex = defined(setIndex)\n      ? attribute.setIndex === setIndex\n      : true;\n    if (attribute.semantic === semantic && matchesSetIndex) {\n      return attribute;\n    }\n  }\n};\n\n/**\n * Similar to getAttributeBySemantic, but search using the name field only,\n * as custom attributes do not have a semantic.\n *\n * @param {ModelComponents.Primitive|ModelComponents.Instances} object The primitive components or instances object\n * @param {String} name The name of the attribute as it appears in the model file.\n * @return {ModelComponents.Attribute} The selected attribute, or undefined if not found.\n *\n * @private\n */\nModelExperimentalUtility.getAttributeByName = function (object, name) {\n  const attributes = object.attributes;\n  const attributesLength = attributes.length;\n  for (let i = 0; i < attributesLength; ++i) {\n    const attribute = attributes[i];\n    if (attribute.name === name) {\n      return attribute;\n    }\n  }\n};\n\n/**\n * Find a feature ID from an array with label or positionalLabel matching the\n * given label\n * @param {Array.<ModelComponents.FeatureIdAttribute|ModelComponents.FeatureIdImplicitRange|ModelComponents.FeatureIdTexture>} featureIds\n * @param {String} label the label to search for\n * @return {ModelComponents.FeatureIdAttribute|ModelComponents.FeatureIdImplicitRange|ModelComponents.FeatureIdTexture} The feature ID set if found, otherwise <code>undefined</code>\n *\n * @private\n */\nModelExperimentalUtility.getFeatureIdsByLabel = function (featureIds, label) {\n  for (let i = 0; i < featureIds.length; i++) {\n    const featureIdSet = featureIds[i];\n    if (\n      featureIdSet.positionalLabel === label ||\n      featureIdSet.label === label\n    ) {\n      return featureIdSet;\n    }\n  }\n\n  return undefined;\n};\n\nModelExperimentalUtility.hasQuantizedAttributes = function (attributes) {\n  if (!defined(attributes)) {\n    return false;\n  }\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    if (defined(attribute.quantization)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @param {ModelComponents.Attribute} attribute\n *\n * @private\n */\nModelExperimentalUtility.getAttributeInfo = function (attribute) {\n  const semantic = attribute.semantic;\n  const setIndex = attribute.setIndex;\n\n  let variableName;\n  let hasSemantic = false;\n  if (defined(semantic)) {\n    variableName = VertexAttributeSemantic.getVariableName(semantic, setIndex);\n    hasSemantic = true;\n  } else {\n    variableName = attribute.name;\n    // According to the glTF 2.0 spec, custom attributes must be prepended with\n    // an underscore.\n    variableName = variableName.replace(/^_/, \"\");\n    variableName = variableName.toLowerCase();\n  }\n\n  const isVertexColor = /^color_\\d+$/.test(variableName);\n  const attributeType = attribute.type;\n  let glslType = AttributeType.getGlslType(attributeType);\n\n  // color_n can be either a vec3 or a vec4. But in GLSL we can always use\n  // attribute vec4 since GLSL promotes vec3 attribute data to vec4 with\n  // the .a channel set to 1.0.\n  if (isVertexColor) {\n    glslType = \"vec4\";\n  }\n\n  const isQuantized = defined(attribute.quantization);\n  let quantizedGlslType;\n  if (isQuantized) {\n    // The quantized color_n attribute also is promoted to a vec4 in the shader\n    quantizedGlslType = isVertexColor\n      ? \"vec4\"\n      : AttributeType.getGlslType(attribute.quantization.type);\n  }\n\n  return {\n    attribute: attribute,\n    isQuantized: isQuantized,\n    variableName: variableName,\n    hasSemantic: hasSemantic,\n    glslType: glslType,\n    quantizedGlslType: quantizedGlslType,\n  };\n};\n\nconst cartesianMaxScratch = new Cartesian3();\nconst cartesianMinScratch = new Cartesian3();\n\n/**\n * Get the minimum and maximum values for a primitive's POSITION attribute.\n * This is used to compute the bounding sphere of the primitive, as well as\n * the bounding sphere of the whole model.\n *\n * @param {ModelComponents.Primitive} primitive The primitive components.\n * @param {Cartesian3} [instancingTranslationMin] The component-wise minimum value of the instancing translation attribute.\n * @param {Cartesian3} [instancingTranslationMax] The component-wise maximum value of the instancing translation attribute.\n *\n * @return {Object} An object containing the minimum and maximum position values.\n *\n * @private\n */\nModelExperimentalUtility.getPositionMinMax = function (\n  primitive,\n  instancingTranslationMin,\n  instancingTranslationMax\n) {\n  const positionGltfAttribute = ModelExperimentalUtility.getAttributeBySemantic(\n    primitive,\n    \"POSITION\"\n  );\n\n  let positionMax = positionGltfAttribute.max;\n  let positionMin = positionGltfAttribute.min;\n\n  if (defined(instancingTranslationMax) && defined(instancingTranslationMin)) {\n    positionMin = Cartesian3.add(\n      positionMin,\n      instancingTranslationMin,\n      cartesianMinScratch\n    );\n    positionMax = Cartesian3.add(\n      positionMax,\n      instancingTranslationMax,\n      cartesianMaxScratch\n    );\n  }\n\n  return {\n    min: positionMin,\n    max: positionMax,\n  };\n};\n\n/**\n * Model matrices in a model file (e.g. glTF) are typically in a different\n * coordinate system, such as with y-up instead of z-up in 3D Tiles.\n * This function returns a matrix that will correct this such that z is up,\n * and x is forward.\n *\n * @param {Axis} upAxis The original up direction\n * @param {Axis} forwardAxis The original forward direction\n * @param {Matrix4} result The matrix in which to store the result.\n * @return {Matrix4} The axis correction matrix\n *\n * @private\n */\nModelExperimentalUtility.getAxisCorrectionMatrix = function (\n  upAxis,\n  forwardAxis,\n  result\n) {\n  result = Matrix4.clone(Matrix4.IDENTITY, result);\n\n  if (upAxis === Axis.Y) {\n    result = Matrix4.clone(Axis.Y_UP_TO_Z_UP, result);\n  } else if (upAxis === Axis.X) {\n    result = Matrix4.clone(Axis.X_UP_TO_Z_UP, result);\n  }\n\n  if (forwardAxis === Axis.Z) {\n    // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n    result = Matrix4.multiplyTransformation(result, Axis.Z_UP_TO_X_UP, result);\n  }\n\n  return result;\n};\n\nconst scratchMatrix3 = new Matrix3();\n\n/**\n * Get the cull face to use in the command's render state.\n * <p>\n * From the glTF spec section 3.7.4:\n * When a mesh primitive uses any triangle-based topology (i.e., triangles,\n * triangle strip, or triangle fan), the determinant of the nodes global\n * transform defines the winding order of that primitive. If the determinant\n * is a positive value, the winding order triangle faces is counterclockwise;\n * in the opposite case, the winding order is clockwise.\n * </p>\n *\n * @param {Matrix4} modelMatrix The model matrix\n * @param {PrimitiveType} primitiveType The primitive type\n * @return {CullFace} The cull face\n *\n * @private\n */\nModelExperimentalUtility.getCullFace = function (modelMatrix, primitiveType) {\n  if (!PrimitiveType.isTriangles(primitiveType)) {\n    return CullFace.BACK;\n  }\n\n  const matrix3 = Matrix4.getMatrix3(modelMatrix, scratchMatrix3);\n  return Matrix3.determinant(matrix3) < 0.0 ? CullFace.FRONT : CullFace.BACK;\n};\n","import Color from \"../../Core/Color.js\";\nimport defined from \"../../Core/defined.js\";\n\n/**\n * A feature of a {@link ModelExperimental}.\n * <p>\n * Provides access to a feature's properties stored in the model's feature table.\n * </p>\n * <p>\n * Modifications to a <code>ModelFeature</code> object have the lifetime of the model.\n * </p>\n * <p>\n * Do not construct this directly. Access it through picking using {@link Scene#pick}.\n * </p>\n *\n * @alias ModelFeature\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {ModelExperimental} options.model The model the feature belongs to.\n * @param {Number} options.featureId The unique integral identifier for this feature.\n *\n * @example\n * // On mouse over, display all the properties for a feature in the console log.\n * handler.setInputAction(function(movement) {\n *     const feature = scene.pick(movement.endPosition);\n *     if (feature instanceof Cesium.ModelFeature) {\n *         console.log(feature);\n *     }\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function ModelFeature(options) {\n  this._model = options.model;\n\n  // This ModelFeatureTable is not documented as an option since it is\n  // part of the private API and should not appear in the documentation.\n  this._featureTable = options.featureTable;\n\n  this._featureId = options.featureId;\n  this._color = undefined; // for calling getColor\n}\n\nObject.defineProperties(ModelFeature.prototype, {\n  /**\n   * Gets or sets if the feature will be shown. This is set for all features\n   * when a style's show is evaluated.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._featureTable.getShow(this._featureId);\n    },\n    set: function (value) {\n      this._featureTable.setShow(this._featureId, value);\n    },\n  },\n\n  /**\n   * Gets or sets the highlight color multiplied with the feature's color.  When\n   * this is white, the feature's color is not changed. This is set for all features\n   * when a style's color is evaluated.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {Color}\n   *\n   * @default {@link Color.WHITE}\n   */\n  color: {\n    get: function () {\n      if (!defined(this._color)) {\n        this._color = new Color();\n      }\n      return this._featureTable.getColor(this._featureId, this._color);\n    },\n    set: function (value) {\n      this._featureTable.setColor(this._featureId, value);\n    },\n  },\n  /**\n   * All objects returned by {@link Scene#pick} have a <code>primitive</code> property. This returns\n   * the model containing the feature.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {ModelExperimental}\n   *\n   * @readonly\n   * @private\n   */\n  primitive: {\n    get: function () {\n      return this._model;\n    },\n  },\n\n  /**\n   *  The {@link ModelFeatureTable} that this feature belongs to.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {ModelFeatureTable}\n   *\n   * @readonly\n   * @private\n   */\n  featureTable: {\n    get: function () {\n      return this._featureTable;\n    },\n  },\n\n  /**\n   * Get the feature ID associated with this feature. For 3D Tiles 1.0, the\n   * batch ID is returned. For EXT_mesh_features, this is the feature ID from\n   * the selected feature ID set.\n   *\n   * @memberof ModelFeature.prototype\n   *\n   * @type {Number}\n   *\n   * @readonly\n   * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n   */\n  featureId: {\n    get: function () {\n      return this._featureId;\n    },\n  },\n});\n\n/**\n * Returns whether the feature contains this property.\n *\n * @param {String} name The case-sensitive name of the property.\n * @returns {Boolean} Whether the feature contains this property.\n */\nModelFeature.prototype.hasProperty = function (name) {\n  return this._featureTable.hasProperty(this._featureId, name);\n};\n\n/**\n * Returns a copy of the value of the feature's property with the given name.\n *\n * @param {String} name The case-sensitive name of the property.\n * @returns {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n *\n * @example\n * // Display all the properties for a feature in the console log.\n * const propertyNames = feature.getPropertyNames();\n * const length = propertyNames.length;\n * for (let i = 0; i < length; ++i) {\n *     const propertyName = propertyNames[i];\n *     console.log(propertyName + ': ' + feature.getProperty(propertyName));\n * }\n */\nModelFeature.prototype.getProperty = function (name) {\n  return this._featureTable.getProperty(this._featureId, name);\n};\n\n/**\n * Returns a copy of the feature's property with the given name, examining all\n * the metadata from the EXT_structural_metadata and legacy EXT_feature_metadata glTF\n * extensions. Metadata is checked against name from most specific to most\n * general and the first match is returned. Metadata is checked in this order:\n * <ol>\n *   <li>structural metadata property by semantic</li>\n *   <li>structural metadata property by property ID</li>\n * </ol>\n * <p>\n * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the\n * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.\n * </p>\n *\n * @param {String} name The semantic or property ID of the feature. Semantics are checked before property IDs in each granularity of metadata.\n * @return {*} The value of the property or <code>undefined</code> if the feature does not have this property.\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nModelFeature.prototype.getPropertyInherited = function (name) {\n  if (this._featureTable.hasPropertyBySemantic(this._featureId, name)) {\n    return this._featureTable.getPropertyBySemantic(this._featureId, name);\n  }\n\n  return this._featureTable.getProperty(this._featureId, name);\n};\n\n/**\n * Returns an array of property names for the feature.\n *\n * @param {String[]} [results] An array into which to store the results.\n * @returns {String[]} The names of the feature's properties.\n */\nModelFeature.prototype.getPropertyNames = function (results) {\n  return this._featureTable.getPropertyNames(results);\n};\n\n/**\n * Sets the value of the feature's property with the given name.\n *\n * @param {String} name The case-sensitive name of the property.\n * @param {*} value The value of the property that will be copied.\n * @returns {Boolean} <code>true</code> if the property was set, <code>false</code> otherwise.\n *\n * @exception {DeveloperError} Inherited batch table hierarchy property is read only.\n *\n * @example\n * const height = feature.getProperty('Height'); // e.g., the height of a building\n *\n * @example\n * const name = 'clicked';\n * if (feature.getProperty(name)) {\n *     console.log('already clicked');\n * } else {\n *     feature.setProperty(name, true);\n *     console.log('first click');\n * }\n */\nModelFeature.prototype.setProperty = function (name, value) {\n  return this._featureTable.setProperty(this._featureId, name, value);\n};\n","import BatchTexture from \"../BatchTexture.js\";\nimport Cesium3DTileFeature from \"../Cesium3DTileFeature.js\";\nimport Check from \"../../Core/Check.js\";\nimport Color from \"../../Core/Color.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport ModelFeature from \"./ModelFeature.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport StyleCommandsNeeded from \"./StyleCommandsNeeded.js\";\nimport ModelExperimentalType from \"./ModelExperimentalType.js\";\n\n/**\n * Manages the {@link ModelFeature}s in a {@link ModelExperimental}.\n * Extracts the properties from a {@link PropertyTable}.\n *\n * @param {Object} options An object containing the following options:\n * @param {ModelExperimental} options.model The model that owns this feature table.\n * @param {PropertyTable} options.propertyTable The property table from the model used to initialize the model.\n *\n * @alias ModelFeatureTable\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nexport default function ModelFeatureTable(options) {\n  const model = options.model;\n  const propertyTable = options.propertyTable;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"propertyTable\", propertyTable);\n  Check.typeOf.object(\"model\", model);\n  //>>includeEnd('debug');\n\n  this._propertyTable = propertyTable;\n  this._model = model;\n\n  this._features = undefined;\n  this._featuresLength = 0;\n\n  this._batchTexture = undefined;\n\n  this._styleCommandsNeededDirty = false;\n  this._styleCommandsNeeded = StyleCommandsNeeded.ALL_OPAQUE;\n\n  initialize(this);\n}\n\nObject.defineProperties(ModelFeatureTable.prototype, {\n  /**\n   * The batch texture created for the features in this table.\n   *\n   * @memberof ModelFeatureTable.prototype\n   *\n   * @type {BatchTexture}\n   * @readonly\n   *\n   * @private\n   */\n  batchTexture: {\n    get: function () {\n      return this._batchTexture;\n    },\n  },\n\n  /**\n   * The number of features in this table.\n   *\n   * @memberof ModelFeatureTable.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  featuresLength: {\n    get: function () {\n      return this._featuresLength;\n    },\n  },\n\n  /**\n   * A flag to indicate whether or not the types of style commands needed by this feature table have changed.\n   *\n   * @memberof ModelFeatureTable.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  styleCommandsNeededDirty: {\n    get: function () {\n      return this._styleCommandsNeededDirty;\n    },\n  },\n});\n\nfunction initialize(modelFeatureTable) {\n  const model = modelFeatureTable._model;\n  const is3DTiles = ModelExperimentalType.is3DTiles(model.type);\n\n  const featuresLength = modelFeatureTable._propertyTable.count;\n  if (featuresLength === 0) {\n    return;\n  }\n\n  let i;\n  const features = new Array(featuresLength);\n  if (is3DTiles) {\n    const content = model.content;\n    for (i = 0; i < featuresLength; i++) {\n      features[i] = new Cesium3DTileFeature(content, i);\n    }\n  } else {\n    for (i = 0; i < featuresLength; i++) {\n      features[i] = new ModelFeature({\n        model: model,\n        featureId: i,\n        featureTable: modelFeatureTable,\n      });\n    }\n  }\n\n  modelFeatureTable._features = features;\n  modelFeatureTable._featuresLength = featuresLength;\n\n  modelFeatureTable._batchTexture = new BatchTexture({\n    featuresLength: featuresLength,\n    owner: modelFeatureTable,\n    statistics: is3DTiles\n      ? model.content.tileset.statistics\n      : modelFeatureTable._statistics,\n  });\n}\n\n/**\n * Creates/updates the batch texture.\n *\n * @param {FrameState} frameState The frame state.\n *\n * @private\n */\nModelFeatureTable.prototype.update = function (frameState) {\n  // Assume the number of translucent features has not changed.\n  this._styleCommandsNeededDirty = false;\n  this._batchTexture.update(undefined, frameState);\n\n  const currentStyleCommandsNeeded = StyleCommandsNeeded.getStyleCommandsNeeded(\n    this._featuresLength,\n    this._batchTexture.translucentFeaturesLength\n  );\n\n  if (this._styleCommandsNeeded !== currentStyleCommandsNeeded) {\n    this._styleCommandsNeededDirty = true;\n    this._styleCommandsNeeded = currentStyleCommandsNeeded;\n  }\n};\n\nModelFeatureTable.prototype.setShow = function (featureId, show) {\n  this._batchTexture.setShow(featureId, show);\n};\n\nModelFeatureTable.prototype.setAllShow = function (show) {\n  this._batchTexture.setAllShow(show);\n};\n\nModelFeatureTable.prototype.getShow = function (featureId) {\n  return this._batchTexture.getShow(featureId);\n};\n\nModelFeatureTable.prototype.setColor = function (featureId, color) {\n  this._batchTexture.setColor(featureId, color);\n};\n\nModelFeatureTable.prototype.setAllColor = function (color) {\n  this._batchTexture.setAllColor(color);\n};\n\nModelFeatureTable.prototype.getColor = function (featureId, result) {\n  return this._batchTexture.getColor(featureId, result);\n};\n\nModelFeatureTable.prototype.getPickColor = function (featureId) {\n  return this._batchTexture.getPickColor(featureId);\n};\n\nModelFeatureTable.prototype.getFeature = function (featureId) {\n  return this._features[featureId];\n};\n\nModelFeatureTable.prototype.hasProperty = function (featureId, propertyName) {\n  return this._propertyTable.hasProperty(featureId, propertyName);\n};\n\nModelFeatureTable.prototype.hasPropertyBySemantic = function (\n  featureId,\n  propertyName\n) {\n  return this._propertyTable.hasPropertyBySemantic(featureId, propertyName);\n};\n\nModelFeatureTable.prototype.getProperty = function (featureId, name) {\n  return this._propertyTable.getProperty(featureId, name);\n};\n\nModelFeatureTable.prototype.getPropertyBySemantic = function (\n  featureId,\n  semantic\n) {\n  return this._propertyTable.getPropertyBySemantic(featureId, semantic);\n};\n\nModelFeatureTable.prototype.getPropertyNames = function (results) {\n  return this._propertyTable.getPropertyIds(results);\n};\n\nModelFeatureTable.prototype.setProperty = function (featureId, name, value) {\n  return this._propertyTable.setProperty(featureId, name, value);\n};\n\nconst scratchColor = new Color();\n/**\n * @private\n */\nModelFeatureTable.prototype.applyStyle = function (style) {\n  if (!defined(style)) {\n    this.setAllColor(BatchTexture.DEFAULT_COLOR_VALUE);\n    this.setAllShow(BatchTexture.DEFAULT_SHOW_VALUE);\n    return;\n  }\n\n  for (let i = 0; i < this._featuresLength; i++) {\n    const feature = this.getFeature(i);\n    const color = defined(style.color)\n      ? defaultValue(\n          style.color.evaluateColor(feature, scratchColor),\n          BatchTexture.DEFAULT_COLOR_VALUE\n        )\n      : BatchTexture.DEFAULT_COLOR_VALUE;\n    const show = defined(style.show)\n      ? defaultValue(\n          style.show.evaluate(feature),\n          BatchTexture.DEFAULT_SHOW_VALUE\n        )\n      : BatchTexture.DEFAULT_SHOW_VALUE;\n\n    this.setColor(i, color);\n    this.setShow(i, show);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ModelFeatureTable#destroy\n * @private\n */\nModelFeatureTable.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * e = e && e.destroy();\n *\n * @see ModelFeatureTable#isDestroyed\n * @private\n */\nModelFeatureTable.prototype.destroy = function (frameState) {\n  this._batchTexture.destroy();\n  destroyObject(this);\n};\n","import defaultValue from \"../../Core/defaultValue.js\";\nimport LightingModel from \"./LightingModel.js\";\n\n/**\n * Options for configuring the {@link LightingPipelineStage}\n *\n * @param {Object} options An object containing the following options\n * @param {LightingModel} [options.lightingModel=LightingModel.UNLIT] The lighting model to use\n *\n * @alias ModelLightingOptions\n * @constructor\n *\n * @private\n */\nexport default function ModelLightingOptions(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The lighting model to use, such as UNLIT or PBR. This is determined by\n   * the primitive's material.\n   *\n   * @type {LightingModel}\n   *\n   * @private\n   */\n  this.lightingModel = defaultValue(options.lightingModel, LightingModel.UNLIT);\n}\n","import Matrix4 from \"../../Core/Matrix4.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\nimport SceneMode from \"../SceneMode.js\";\n\n/**\n * The model matrix update stage is responsible for updating the model matrices and bounding volumes of the draw commands.\n *\n * @namespace ModelMatrixUpdateStage\n *\n * @private\n */\nconst ModelMatrixUpdateStage = {};\nModelMatrixUpdateStage.name = \"ModelMatrixUpdateStage\"; // Helps with debugging\n\n/**\n * Processes a runtime node. This modifies the following parts of the scene graph and draw commands:\n * <ul>\n *  <li>updates the transforms the children of any nodes with a dirty transform</li>\n *  <li>updates the model matrix of each draw command in each primitive of the the dirty nodes and their children</li>\n *  <li>updates the bounding volume of each draw command in each primitive of the the dirty nodes and their children</li>\n * </ul>\n *\n * @param {ModelExperimentalNode} runtimeNode\n * @param {ModelExperimentalSceneGraph} sceneGraph\n * @param {FrameState} frameState\n *\n * @private\n */\nModelMatrixUpdateStage.update = function (runtimeNode, sceneGraph, frameState) {\n  // Skip the update stage if the model is being projected to 2D\n  const use2D = frameState.mode !== SceneMode.SCENE3D;\n  if (use2D && sceneGraph._model._projectTo2D) {\n    return;\n  }\n\n  if (runtimeNode._transformDirty) {\n    const modelMatrix = use2D\n      ? sceneGraph._computedModelMatrix2D\n      : sceneGraph._computedModelMatrix;\n\n    updateRuntimeNode(\n      runtimeNode,\n      sceneGraph,\n      modelMatrix,\n      runtimeNode.transformToRoot\n    );\n    runtimeNode._transformDirty = false;\n  }\n};\n\n/**\n * Recursively update all child runtime nodes and their runtime primitives.\n *\n * @private\n */\nfunction updateRuntimeNode(\n  runtimeNode,\n  sceneGraph,\n  modelMatrix,\n  transformToRoot\n) {\n  let i;\n\n  // Apply the current node's transform to the end of the chain\n  transformToRoot = Matrix4.multiplyTransformation(\n    transformToRoot,\n    runtimeNode.transform,\n    new Matrix4()\n  );\n\n  runtimeNode.updateComputedTransform();\n\n  const primitivesLength = runtimeNode.runtimePrimitives.length;\n  for (i = 0; i < primitivesLength; i++) {\n    const runtimePrimitive = runtimeNode.runtimePrimitives[i];\n    const drawCommand = runtimePrimitive.drawCommand;\n    drawCommand.modelMatrix = Matrix4.multiplyTransformation(\n      modelMatrix,\n      transformToRoot,\n      drawCommand.modelMatrix\n    );\n    drawCommand.cullFace = ModelExperimentalUtility.getCullFace(\n      drawCommand.modelMatrix,\n      drawCommand.primitiveType\n    );\n  }\n\n  const childrenLength = runtimeNode.children.length;\n  for (i = 0; i < childrenLength; i++) {\n    const childRuntimeNode = sceneGraph._runtimeNodes[runtimeNode.children[i]];\n\n    // Update transformToRoot to accommodate changes in the transforms of this node and its ancestors\n    childRuntimeNode._transformToRoot = Matrix4.clone(\n      transformToRoot,\n      childRuntimeNode._transformToRoot\n    );\n\n    updateRuntimeNode(\n      childRuntimeNode,\n      sceneGraph,\n      modelMatrix,\n      transformToRoot\n    );\n    childRuntimeNode._transformDirty = false;\n  }\n}\n\nexport default ModelMatrixUpdateStage;\n","import Check from \"../../Core/Check.js\";\nimport ModelAlphaOptions from \"./ModelAlphaOptions.js\";\nimport ShaderBuilder from \"../../Renderer/ShaderBuilder.js\";\n\n/**\n * Model render resources are for setting details that are consistent across\n * the entire model.\n *\n * @constructor\n * @param {ModelExperimental} model The model that will be rendered\n *\n * @private\n */\nexport default function ModelRenderResources(model) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"model\", model);\n  //>>includeEnd('debug');\n\n  /**\n   * An object used to build a shader incrementally. Each pipeline stage\n   * may add lines of shader code to this object.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = new ShaderBuilder();\n  /**\n   * A reference to the model.\n   *\n   * @type {ModelExperimental}\n   * @readonly\n   *\n   * @private\n   */\n  this.model = model;\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values.\n   *\n   * @type {Object.<String, Function>}\n   * @readonly\n   *\n   * @private\n   */\n  this.uniformMap = {};\n\n  /**\n   * Options for configuring the alpha stage such as pass and alpha mode.\n   *\n   * @type {ModelAlphaOptions}\n   * @readonly\n   *\n   * @private\n   */\n  this.alphaOptions = new ModelAlphaOptions();\n\n  /**\n   * An object storing options for creating a {@link RenderState}.\n   * The pipeline stages simply set the options, the render state is created\n   * when the {@link DrawCommand} is constructed.\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @private\n   */\n  this.renderStateOptions = {};\n}\n","import combine from \"../../Core/combine.js\";\nimport ModelSplitterStageFS from \"../../Shaders/ModelExperimental/ModelSplitterStageFS.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\n\n/**\n * The model splitting pipeline stage is responsible for discarding fragments on the wrong side of the splitter.\n *\n * @namespace ModelSplitterPipelineStage\n *\n * @private\n */\nconst ModelSplitterPipelineStage = {};\nModelSplitterPipelineStage.name = \"ModelSplitterPipelineStage\"; // Helps with debugging\n\nModelSplitterPipelineStage.SPLIT_DIRECTION_UNIFORM_NAME =\n  \"model_splitDirection\";\n\n/**\n * Process a model. This modifies the following parts of the render resources:\n *\n * <ul>\n *  <li>adds a define to the fragment shader to indicate that the model is split</li>\n *  <li>adds a function to the fragment shader to discard the fragment if it's on the wrong side of the splitter.</li>\n *  <li>adds a uniform indicating the \"splitDirection\" (side of the screen on which to show the model)\n *</ul>\n *\n * @param {ModelRenderResources} renderResources The render resources for this model.\n * @param {ModelExperimental} model The model.\n * @param {FrameState} frameState The frameState.\n *\n * @private\n */\nModelSplitterPipelineStage.process = function (\n  renderResources,\n  model,\n  frameState\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_MODEL_SPLITTER\",\n    undefined,\n    ShaderDestination.FRAGMENT\n  );\n  shaderBuilder.addFragmentLines([ModelSplitterStageFS]);\n\n  const stageUniforms = {};\n\n  shaderBuilder.addUniform(\n    \"float\",\n    ModelSplitterPipelineStage.SPLIT_DIRECTION_UNIFORM_NAME,\n    ShaderDestination.FRAGMENT\n  );\n  stageUniforms[\n    ModelSplitterPipelineStage.SPLIT_DIRECTION_UNIFORM_NAME\n  ] = function () {\n    return model.splitDirection;\n  };\n\n  renderResources.uniformMap = combine(\n    stageUniforms,\n    renderResources.uniformMap\n  );\n};\n\nexport default ModelSplitterPipelineStage;\n","import AttributeType from \"../AttributeType.js\";\nimport combine from \"../../Core/combine.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport MorphTargetsStageVS from \"../../Shaders/ModelExperimental/MorphTargetsStageVS.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\n/**\n * The morph targets pipeline stage processes the morph targets and weights of a primitive.\n *\n * @namespace MorphTargetsPipelineStage\n *\n * @private\n */\n\nconst MorphTargetsPipelineStage = {};\nMorphTargetsPipelineStage.name = \"MorphTargetsPipelineStage\"; // Helps with debugging\nMorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION =\n  \"getMorphedPosition\";\nMorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_POSITION =\n  \"vec3 getMorphedPosition(in vec3 position)\";\nMorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL = \"getMorphedNormal\";\nMorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_NORMAL =\n  \"vec3 getMorphedNormal(in vec3 normal)\";\nMorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT = \"getMorphedTangent\";\nMorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_TANGENT =\n  \"vec3 getMorphedTangent(in vec3 tangent)\";\n\n/**\n * This pipeline stage processes the morph targets and weights of a primitive,\n * adding the relevant attribute declarations and functions to the shaders.\n *\n * Processes a primitive. This stage modifies the following parts of the render resources:\n * <ul>\n *  <li> adds attribute declarations for the morph targets in the vertex shader\n *  <li> adds the uniform declaration for the morph weights in the vertex shader\n *  <li> adds functions to apply the morphs in the vertex shader\n * </ul>\n *\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n *\n * @private\n */\nMorphTargetsPipelineStage.process = function (renderResources, primitive) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  shaderBuilder.addDefine(\n    \"HAS_MORPH_TARGETS\",\n    undefined,\n    ShaderDestination.VERTEX\n  );\n\n  addGetMorphedAttributeFunctionDeclarations(shaderBuilder);\n\n  for (let i = 0; i < primitive.morphTargets.length; i++) {\n    const morphTarget = primitive.morphTargets[i];\n    const attributes = morphTarget.attributes;\n\n    for (let j = 0; j < attributes.length; j++) {\n      const attribute = attributes[j];\n      const semantic = attribute.semantic;\n\n      // Cesium only supports morph targets for positions, normals, and tangents\n      if (\n        semantic !== VertexAttributeSemantic.POSITION &&\n        semantic !== VertexAttributeSemantic.NORMAL &&\n        semantic !== VertexAttributeSemantic.TANGENT\n      ) {\n        continue;\n      }\n\n      processMorphTargetAttribute(\n        renderResources,\n        attribute,\n        renderResources.attributeIndex,\n        i\n      );\n      renderResources.attributeIndex++;\n    }\n  }\n\n  addGetMorphedAttributeFunctionReturns(shaderBuilder);\n\n  const weights = renderResources.runtimeNode.morphWeights;\n  const weightsLength = weights.length;\n  shaderBuilder.addUniform(\n    \"float\",\n    `u_morphWeights[${weightsLength}]`,\n    ShaderDestination.VERTEX\n  );\n\n  shaderBuilder.addVertexLines([MorphTargetsStageVS]);\n\n  const uniformMap = {\n    u_morphWeights: function () {\n      return renderResources.runtimeNode.morphWeights;\n    },\n  };\n\n  renderResources.uniformMap = combine(uniformMap, renderResources.uniformMap);\n};\n\nconst scratchAttributeInfo = {\n  attributeString: undefined,\n  functionId: undefined,\n};\n\nfunction processMorphTargetAttribute(\n  renderResources,\n  attribute,\n  attributeIndex,\n  morphTargetIndex\n) {\n  const shaderBuilder = renderResources.shaderBuilder;\n\n  addMorphTargetAttributeToRenderResources(\n    renderResources,\n    attribute,\n    attributeIndex\n  );\n\n  const attributeInfo = getMorphTargetAttributeInfo(\n    attribute,\n    scratchAttributeInfo\n  );\n\n  addMorphTargetAttributeDeclarationAndFunctionLine(\n    shaderBuilder,\n    attributeInfo,\n    morphTargetIndex\n  );\n}\n\nfunction addMorphTargetAttributeToRenderResources(\n  renderResources,\n  attribute,\n  attributeIndex\n) {\n  const vertexAttribute = {\n    index: attributeIndex,\n    value: defined(attribute.buffer) ? undefined : attribute.constant,\n    vertexBuffer: attribute.buffer,\n    componentsPerAttribute: AttributeType.getNumberOfComponents(attribute.type),\n    componentDatatype: attribute.componentDatatype,\n    offsetInBytes: attribute.byteOffset,\n    strideInBytes: attribute.byteStride,\n    normalize: attribute.normalized,\n  };\n\n  renderResources.attributes.push(vertexAttribute);\n}\n\nfunction getMorphTargetAttributeInfo(attribute, result) {\n  const semantic = attribute.semantic;\n  switch (semantic) {\n    case VertexAttributeSemantic.POSITION:\n      result.attributeString = \"Position\";\n      result.functionId =\n        MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION;\n      break;\n    case VertexAttributeSemantic.NORMAL:\n      result.attributeString = \"Normal\";\n      result.functionId =\n        MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL;\n      break;\n    case VertexAttributeSemantic.TANGENT:\n      result.attributeString = \"Tangent\";\n      result.functionId =\n        MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT;\n      break;\n    default:\n      break;\n  }\n  return result;\n}\n\nfunction addMorphTargetAttributeDeclarationAndFunctionLine(\n  shaderBuilder,\n  attributeInfo,\n  morphTargetIndex\n) {\n  const attributeString = attributeInfo.attributeString;\n  const attributeName = `a_target${attributeString}_${morphTargetIndex}`;\n  const line = `morphed${attributeString} += u_morphWeights[${morphTargetIndex}] * a_target${attributeString}_${morphTargetIndex};`;\n  shaderBuilder.addAttribute(\"vec3\", attributeName);\n  shaderBuilder.addFunctionLines(attributeInfo.functionId, [line]);\n}\n\nfunction addGetMorphedAttributeFunctionDeclarations(shaderBuilder) {\n  shaderBuilder.addFunction(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION,\n    MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_POSITION,\n    ShaderDestination.VERTEX\n  );\n\n  const positionLine = \"vec3 morphedPosition = position;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION,\n    [positionLine]\n  );\n\n  shaderBuilder.addFunction(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL,\n    MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_NORMAL,\n    ShaderDestination.VERTEX\n  );\n\n  const normalLine = \"vec3 morphedNormal = normal;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL,\n    [normalLine]\n  );\n\n  shaderBuilder.addFunction(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT,\n    MorphTargetsPipelineStage.FUNCTION_SIGNATURE_GET_MORPHED_TANGENT,\n    ShaderDestination.VERTEX\n  );\n\n  const tangentLine = \"vec3 morphedTangent = tangent;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT,\n    [tangentLine]\n  );\n}\n\nfunction addGetMorphedAttributeFunctionReturns(shaderBuilder) {\n  const positionLine = \"return morphedPosition;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_POSITION,\n    [positionLine]\n  );\n\n  const normalLine = \"return morphedNormal;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_NORMAL,\n    [normalLine]\n  );\n\n  const tangentLine = \"return morphedTangent;\";\n  shaderBuilder.addFunctionLines(\n    MorphTargetsPipelineStage.FUNCTION_ID_GET_MORPHED_TANGENT,\n    [tangentLine]\n  );\n}\n\nexport default MorphTargetsPipelineStage;\n","import Check from \"../../Core/Check.js\";\nimport clone from \"../../Core/clone.js\";\n\n/**\n * A model is made up of one or more nodes in the scene graph. Some details\n * such as instancing are computed on a per-node basis. This class provides\n * a place to store such details. It also inherits some properties from\n * the model render resources.\n *\n * @constructor\n *\n * @param {ModelRenderResources} modelRenderResources The model resources to inherit\n * @param {ModelExperimentalNode} runtimeNode The in-memory representation of the scene graph node.\n *\n * @private\n */\nexport default function NodeRenderResources(modelRenderResources, runtimeNode) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"modelRenderResources\", modelRenderResources);\n  Check.typeOf.object(\"runtimeNode\", runtimeNode);\n  //>>includeEnd('debug');\n\n  // Properties inherited from the ModelRenderResources.\n  /**\n   * A reference to the model. Inherited from the model render resources.\n   *\n   * @type {ModelExperimental}\n   * @readonly\n   *\n   * @private\n   */\n  this.model = modelRenderResources.model;\n  /**\n   * An object used to build a shader incrementally. This is cloned from the\n   * model render resources because each node can compute a different shader.\n   *\n   * @type {ShaderBuilder}\n   * @readonly\n   *\n   * @private\n   */\n  this.shaderBuilder = modelRenderResources.shaderBuilder.clone();\n\n  /**\n   * A dictionary mapping uniform name to functions that return the uniform\n   * values. Inherited from the model render resources.\n   *\n   * @type {Object.<String, Function>}\n   *\n   * @readonly\n   *\n   * @private\n   */\n  this.uniformMap = clone(modelRenderResources.uniformMap);\n\n  /**\n   * Options for configuring the alpha stage such as pass and alpha mode. Inherited from the model\n   * render resources.\n   *\n   * @type {ModelAlphaOptions}\n   * @readonly\n   *\n   * @private\n   */\n  this.alphaOptions = clone(modelRenderResources.alphaOptions);\n\n  /**\n   * An object storing options for creating a {@link RenderState}.\n   * The pipeline stages simply set the options, the render state is created\n   * when the {@link DrawCommand} is constructed. Inherited from the model\n   * render resources.\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @private\n   */\n  this.renderStateOptions = clone(modelRenderResources.renderStateOptions);\n\n  // Other properties.\n  /**\n   * A reference to the runtime node\n   *\n   * @type {ModelExperimentalNode}\n   * @readonly\n   *\n   * @private\n   */\n  this.runtimeNode = runtimeNode;\n\n  /**\n   * An array of objects describing vertex attributes that will eventually\n   * be used to create a {@link VertexArray} for the draw command. Attributes\n   * at the node level may be needed for extensions such as EXT_mesh_gpu_instancing.\n   *\n   * @type {Object[]}\n   * @readonly\n   *\n   * @private\n   */\n  this.attributes = [];\n\n  /**\n   * The index to give to the next vertex attribute added to the attributes array. POSITION\n   * takes index 0.\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  this.attributeIndex = 1;\n\n  /**\n   * The set index to assign to feature ID vertex attribute(s) created from the offset/repeat in the feature ID attribute.\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  this.featureIdVertexAttributeSetIndex = 0;\n\n  /**\n   * The number of instances. Default is 0, if instancing is not used.\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @private\n   */\n  this.instanceCount = 0;\n\n  /**\n   * The component-wise maximum value of the translations of the instances.\n   *\n   * @type {Cartesian3}\n   * @readonly\n   *\n   * @private\n   */\n  this.instancingTranslationMax = undefined;\n\n  /**\n   * The component-wise minimum value of the translations of the instances.\n   *\n   * @type {Cartesian3}\n   * @readonly\n   *\n   * @private\n   */\n  this.instancingTranslationMin = undefined;\n}\n","import Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport Color from \"../../Core/Color.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport ShaderDestination from \"../../Renderer/ShaderDestination.js\";\nimport ModelExperimentalType from \"./ModelExperimentalType.js\";\nimport ModelExperimentalUtility from \"./ModelExperimentalUtility.js\";\n\n/**\n * The picking pipeline stage is responsible for handling picking of primitives.\n *\n * @namespace PickingPipelineStage\n * @private\n */\nconst PickingPipelineStage = {};\nPickingPipelineStage.name = \"PickingPipelineStage\"; // Helps with debugging\n\n/**\n * Process a primitive. This modifies the following parts of the render resources:\n * <ul>\n *  <li>adds attribute and varying declaration for the pick color vertex attribute in the vertex shader for instanced meshes</li>\n *  <li>adds declaration for the pick color uniform for non-instanced meshes</li>\n *  <li>adds defines in the shader for when picking is enabled</li>\n *  <li>creates the pick ID objects in the context</li>\n * </ul>\n * @param {PrimitiveRenderResources} renderResources The render resources for this primitive.\n * @param {ModelComponents.Primitive} primitive The primitive.\n * @param {FrameState} frameState The frame state.\n */\nPickingPipelineStage.process = function (\n  renderResources,\n  primitive,\n  frameState\n) {\n  const context = frameState.context;\n  const runtimeNode = renderResources.runtimeNode;\n  const shaderBuilder = renderResources.shaderBuilder;\n  const model = renderResources.model;\n  const instances = runtimeNode.node.instances;\n\n  if (renderResources.hasPropertyTable) {\n    processPickTexture(renderResources, primitive, instances, context);\n  } else if (defined(instances)) {\n    // For instanced meshes, a pick color vertex attribute is used.\n    processInstancedPickIds(renderResources, instances, context);\n  } else {\n    // For non-instanced meshes, a pick color uniform is used.\n    const pickObject = buildPickObject(renderResources);\n\n    const pickId = context.createPickId(pickObject);\n    model._resources.push(pickId);\n    shaderBuilder.addUniform(\n      \"vec4\",\n      \"czm_pickColor\",\n      ShaderDestination.FRAGMENT\n    );\n\n    const uniformMap = renderResources.uniformMap;\n    uniformMap.czm_pickColor = function () {\n      return pickId.color;\n    };\n\n    renderResources.pickId = \"czm_pickColor\";\n  }\n};\n\n/**\n * @private\n */\nfunction buildPickObject(renderResources, instanceId) {\n  const model = renderResources.model;\n\n  const detailPickObject = {\n    model: model,\n    node: renderResources.runtimeNode,\n    primitive: renderResources.runtimePrimitive,\n  };\n\n  let pickObject;\n\n  if (ModelExperimentalType.is3DTiles(model.type)) {\n    // For 3D Tiles, the pick object's content and primitive are set to the Cesium3DTileContent that owns the model\n    // and the tileset it belongs to, respectively. The detail pick object is returned under the detail key.\n    const content = model.content;\n    pickObject = {\n      content: content,\n      primitive: content.tileset,\n      detail: detailPickObject,\n    };\n  } else {\n    // For models, the model itself is returned as the primitive, with the detail pick object under the detail key.\n    pickObject = {\n      primitive: model,\n      detail: detailPickObject,\n    };\n  }\n\n  if (defined(instanceId)) {\n    // For instanced models, an instanceId property is added to the pick object.\n    pickObject.instanceId = instanceId;\n  }\n\n  return pickObject;\n}\n\nfunction processPickTexture(renderResources, primitive, instances) {\n  const model = renderResources.model;\n  let featureTableId;\n  let featureIdAttribute;\n  const featureIdLabel = model.featureIdLabel;\n  const instanceFeatureIdLabel = model.instanceFeatureIdLabel;\n\n  if (defined(model.featureTableId)) {\n    // Extract the Feature Table ID from the Cesium3DTileContent.\n    featureTableId = model.featureTableId;\n  } else if (defined(instances)) {\n    // Extract the Feature Table ID from the instanced Feature ID attributes.\n    featureIdAttribute = ModelExperimentalUtility.getFeatureIdsByLabel(\n      instances.featureIds,\n      instanceFeatureIdLabel\n    );\n    featureTableId = featureIdAttribute.propertyTableId;\n  } else {\n    // Extract the Feature Table ID from the primitive Feature ID attributes.\n    featureIdAttribute = ModelExperimentalUtility.getFeatureIdsByLabel(\n      primitive.featureIds,\n      featureIdLabel\n    );\n    featureTableId = featureIdAttribute.propertyTableId;\n  }\n\n  const featureTable = model.featureTables[featureTableId];\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addUniform(\n    \"sampler2D\",\n    \"model_pickTexture\",\n    ShaderDestination.FRAGMENT\n  );\n\n  const batchTexture = featureTable.batchTexture;\n  renderResources.uniformMap.model_pickTexture = function () {\n    return defaultValue(batchTexture.pickTexture, batchTexture.defaultTexture);\n  };\n\n  // The feature ID  is ignored if it is greater than the number of features.\n  renderResources.pickId =\n    \"((selectedFeature.id < int(model_featuresLength)) ? texture2D(model_pickTexture, selectedFeature.st) : vec4(0.0))\";\n}\n\nfunction processInstancedPickIds(renderResources, instances, context) {\n  const instanceCount = renderResources.instanceCount;\n  const pickIds = new Array(instanceCount);\n  const pickIdsTypedArray = new Uint8Array(instanceCount * 4);\n\n  const model = renderResources.model;\n\n  const modelResources = model._resources;\n  for (let i = 0; i < instanceCount; i++) {\n    const pickObject = buildPickObject(renderResources, i);\n\n    const pickId = context.createPickId(pickObject);\n    modelResources.push(pickId);\n    pickIds[i] = pickId;\n\n    const pickColor = pickId.color;\n    pickIdsTypedArray[i * 4 + 0] = Color.floatToByte(pickColor.red);\n    pickIdsTypedArray[i * 4 + 1] = Color.floatToByte(pickColor.green);\n    pickIdsTypedArray[i * 4 + 2] = Color.floatToByte(pickColor.blue);\n    pickIdsTypedArray[i * 4 + 3] = Color.floatToByte(pickColor.alpha);\n  }\n\n  const pickIdsBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: pickIdsTypedArray,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  // Destruction of resources allocated by the ModelExperimental is handled by ModelExperimental.destroy().\n  pickIdsBuffer.vertexArrayDestroyable = false;\n  modelResources.push(pickIdsBuffer);\n\n  const pickIdsVertexAttribute = {\n    index: renderResources.attributeIndex++,\n    vertexBuffer: pickIdsBuffer,\n    componentsPerAttribute: 4,\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    normalize: true,\n    offsetInBytes: 0,\n    strideInBytes: 0,\n    instanceDivisor: 1,\n  };\n\n  renderResources.attributes.push(pickIdsVertexAttribute);\n\n  const shaderBuilder = renderResources.shaderBuilder;\n  shaderBuilder.addDefine(\"USE_PICKING\", undefined, ShaderDestination.BOTH);\n  shaderBuilder.addAttribute(\"vec4\", \"a_pickColor\");\n  shaderBuilder.addVarying(\"vec4\", \"v_pickColor\");\n  renderResources.pickId = \"v_pickColor\";\n}\n\nexport default PickingPipelineStage;\n","import AttributeCompression from \"../../Core/AttributeCompression.js\";\nimport Cartesian3 from \"../../Core/Cartesian3.js\";\nimport Color from \"../../Core/Color.js\";\nimport Check from \"../../Core/Check.js\";\nimport ComponentDatatype from \"../../Core/ComponentDatatype.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport Matrix4 from \"../../Core/Matrix4.js\";\nimport PrimitiveType from \"../../Core/PrimitiveType.js\";\nimport MersenneTwister from \"../../ThirdParty/mersenne-twister.js\";\nimport Buffer from \"../../Renderer/Buffer.js\";\nimport BufferUsage from \"../../Renderer/BufferUsage.js\";\nimport AlphaMode from \"../AlphaMode.js\";\nimport AttributeType from \"../AttributeType.js\";\nimport Axis from \"../Axis.js\";\nimport parseBatchTable from \"../parseBatchTable.js\";\nimport DracoLoader from \"../DracoLoader.js\";\nimport StructuralMetadata from \"../StructuralMetadata.js\";\nimport ResourceLoader from \"../ResourceLoader.js\";\nimport MetadataClass from \"../MetadataClass.js\";\nimport ModelComponents from \"../ModelComponents.js\";\nimport PntsParser from \"../PntsParser.js\";\nimport PropertyTable from \"../PropertyTable.js\";\nimport ResourceLoaderState from \"../ResourceLoaderState.js\";\nimport VertexAttributeSemantic from \"../VertexAttributeSemantic.js\";\n\nconst Components = ModelComponents.Components;\nconst Scene = ModelComponents.Scene;\nconst Node = ModelComponents.Node;\nconst Primitive = ModelComponents.Primitive;\nconst Attribute = ModelComponents.Attribute;\nconst Quantization = ModelComponents.Quantization;\nconst FeatureIdAttribute = ModelComponents.FeatureIdAttribute;\nconst Material = ModelComponents.Material;\nconst MetallicRoughness = ModelComponents.MetallicRoughness;\n\n/**\n * Loads a .pnts point cloud and transcodes it into a {@link ModelComponents}\n *\n * @alias PntsLoader\n * @constructor\n * @augments ResourceLoader\n * @private\n *\n * @param {Object} options An object containing the following properties\n * @param {ArrayBuffer} options.arrayBuffer The array buffer of the pnts contents\n * @param {Number} [options.byteOffset] The byte offset to the beginning of the pnts contents in the array buffer\n */\nexport default function PntsLoader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const arrayBuffer = options.arrayBuffer;\n  const byteOffset = defaultValue(options.byteOffset, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.arrayBuffer\", arrayBuffer);\n  //>>includeEnd('debug');\n\n  this._arrayBuffer = arrayBuffer;\n  this._byteOffset = byteOffset;\n\n  this._parsedContent = undefined;\n  this._decodePromise = undefined;\n  this._decodedAttributes = undefined;\n\n  this._promise = undefined;\n  this._process = function (frameState) {};\n  this._state = ResourceLoaderState.UNLOADED;\n  this._buffers = [];\n\n  // The batch table object contains a json and a binary component access using keys of the same name.\n  this._components = undefined;\n  this._transform = Matrix4.IDENTITY;\n}\n\nif (defined(Object.create)) {\n  PntsLoader.prototype = Object.create(ResourceLoader.prototype);\n  PntsLoader.prototype.constructor = PntsLoader;\n}\n\nObject.defineProperties(PntsLoader.prototype, {\n  /**\n   * A promise that resolves to the resource when the resource is ready, or undefined if the resource hasn't started loading.\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {Promise.<PntsLoader>|undefined}\n   * @readonly\n   * @private\n   */\n  promise: {\n    get: function () {\n      return this._promise;\n    },\n  },\n  /**\n   * The cache key of the resource\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {String}\n   * @readonly\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * The loaded components.\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {ModelComponents.Components}\n   * @readonly\n   * @private\n   */\n  components: {\n    get: function () {\n      return this._components;\n    },\n  },\n\n  /**\n   * A world-space transform to apply to the primitives.\n   * See {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/TileFormats/PointCloud#global-semantics}\n   *\n   * @memberof PntsLoader.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   * @private\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n  },\n});\n\n/**\n * Loads the resource.\n * @returns {Promise.<PntsLoader>} A promise which resolves to the loader when the resource loading is completed.\n * @private\n */\nPntsLoader.prototype.load = function () {\n  this._parsedContent = PntsParser.parse(this._arrayBuffer, this._byteOffset);\n  this._state = ResourceLoaderState.PROCESSING;\n\n  const loader = this;\n  this._promise = new Promise(function (resolve, reject) {\n    loader._process = function (frameState) {\n      if (loader._state === ResourceLoaderState.PROCESSING) {\n        if (!defined(loader._decodePromise)) {\n          decodeDraco(loader, frameState.context).then(resolve).catch(reject);\n        }\n      }\n    };\n  });\n};\n\nPntsLoader.prototype.process = function (frameState) {\n  this._process(frameState);\n};\n\nfunction decodeDraco(loader, context) {\n  const parsedContent = loader._parsedContent;\n  const draco = parsedContent.draco;\n\n  let decodePromise;\n  if (!defined(draco)) {\n    // The draco extension wasn't present,\n    decodePromise = Promise.resolve();\n  } else {\n    decodePromise = DracoLoader.decodePointCloud(draco, context);\n  }\n\n  if (!defined(decodePromise)) {\n    // Could not schedule Draco decoding this frame.\n    return;\n  }\n\n  loader._decodePromise = decodePromise;\n  return decodePromise\n    .then(function (decodeDracoResult) {\n      if (loader.isDestroyed()) {\n        return;\n      }\n\n      if (defined(decodeDracoResult)) {\n        processDracoAttributes(loader, draco, decodeDracoResult);\n      }\n      makeComponents(loader, context);\n      loader._state = ResourceLoaderState.READY;\n      return loader;\n    })\n    .catch(function (error) {\n      loader.unload();\n      loader._state = ResourceLoaderState.FAILED;\n      const errorMessage = \"Failed to load Draco\";\n      return Promise.reject(loader.getError(errorMessage, error));\n    });\n}\n\nfunction processDracoAttributes(loader, draco, result) {\n  loader._state = ResourceLoaderState.READY;\n  const parsedContent = loader._parsedContent;\n\n  let attribute;\n  if (defined(result.POSITION)) {\n    attribute = {\n      name: \"POSITION\",\n      semantic: VertexAttributeSemantic.POSITION,\n      typedArray: result.POSITION.array,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      isQuantized: false,\n    };\n\n    if (defined(result.POSITION.data.quantization)) {\n      // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n      // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n      const quantization = result.POSITION.data.quantization;\n      const range = quantization.range;\n      const quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n      const quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n      const quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n\n      attribute.isQuantized = true;\n      attribute.quantizedRange = quantizedRange;\n      attribute.quantizedVolumeOffset = quantizedVolumeOffset;\n      attribute.quantizedVolumeScale = quantizedVolumeScale;\n      attribute.quantizedComponentDatatype = ComponentDatatype.UNSIGNED_SHORT;\n      attribute.quantizedType = AttributeType.VEC3;\n    }\n\n    parsedContent.positions = attribute;\n  }\n\n  if (defined(result.NORMAL)) {\n    attribute = {\n      name: \"NORMAL\",\n      semantic: VertexAttributeSemantic.NORMAL,\n      typedArray: result.NORMAL.array,\n      componentDatatype: ComponentDatatype.FLOAT,\n      type: AttributeType.VEC3,\n      isQuantized: false,\n      octEncoded: false,\n      octEncodedZXY: false,\n    };\n\n    if (defined(result.NORMAL.data.quantization)) {\n      const octEncodedRange =\n        (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n      attribute.quantizedRange = octEncodedRange;\n      attribute.octEncoded = true;\n      attribute.octEncodedZXY = true;\n      attribute.quantizedComponentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n      attribute.quantizedType = AttributeType.VEC2;\n    }\n\n    parsedContent.normals = attribute;\n  }\n\n  if (defined(result.RGBA)) {\n    parsedContent.colors = {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: result.RGBA.array,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC4,\n      normalized: true,\n      isTranslucent: true,\n    };\n  } else if (defined(result.RGB)) {\n    parsedContent.colors = {\n      name: \"COLOR\",\n      semantic: VertexAttributeSemantic.COLOR,\n      setIndex: 0,\n      typedArray: result.RGB.array,\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n      type: AttributeType.VEC3,\n      normalized: true,\n      isTranslucent: false,\n    };\n  }\n\n  // Transcode Batch ID (3D Tiles 1.0) -> Feature ID (3D Tiles Next)\n  if (defined(result.BATCH_ID)) {\n    const batchIds = result.BATCH_ID.array;\n    parsedContent.batchIds = {\n      name: \"_FEATURE_ID\",\n      semantic: VertexAttributeSemantic.FEATURE_ID,\n      setIndex: 0,\n      typedArray: batchIds,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      type: AttributeType.SCALAR,\n    };\n  }\n\n  let styleableProperties = parsedContent.styleableProperties;\n  const batchTableProperties = draco.batchTableProperties;\n  for (const name in batchTableProperties) {\n    if (batchTableProperties.hasOwnProperty(name)) {\n      const property = result[name];\n      if (!defined(styleableProperties)) {\n        styleableProperties = {};\n      }\n      styleableProperties[name] = {\n        typedArray: property.array,\n        componentCount: property.data.componentsPerAttribute,\n      };\n    }\n  }\n  parsedContent.styleableProperties = styleableProperties;\n}\n\nfunction makeAttribute(loader, attributeInfo, context) {\n  let typedArray = attributeInfo.typedArray;\n  let quantization;\n  if (attributeInfo.octEncoded) {\n    quantization = new Quantization();\n    quantization.octEncoded = attributeInfo.octEncoded;\n    quantization.octEncodedZXY = attributeInfo.octEncodedZXY;\n    quantization.normalizationRange = attributeInfo.quantizedRange;\n    quantization.type = attributeInfo.quantizedType;\n    quantization.componentDatatype = attributeInfo.quantizedComponentDatatype;\n  }\n  if (attributeInfo.isQuantized) {\n    quantization = new Quantization();\n    const normalizationRange = attributeInfo.quantizedRange;\n    quantization.normalizationRange = normalizationRange;\n    // volume offset sometimes requires 64-bit precision so this is handled\n    // in the components.transform matrix.\n    quantization.quantizedVolumeOffset = Cartesian3.ZERO;\n    const quantizedVolumeDimensions = attributeInfo.quantizedVolumeScale;\n    quantization.quantizedVolumeDimensions = quantizedVolumeDimensions;\n    quantization.quantizedVolumeStepSize = Cartesian3.divideByScalar(\n      quantizedVolumeDimensions,\n      normalizationRange,\n      new Cartesian3()\n    );\n    quantization.componentDatatype = attributeInfo.quantizedComponentDatatype;\n    quantization.type = attributeInfo.quantizedType;\n  }\n\n  const attribute = new Attribute();\n  attribute.name = attributeInfo.name;\n  attribute.semantic = attributeInfo.semantic;\n  attribute.setIndex = attributeInfo.setIndex;\n  attribute.componentDatatype = attributeInfo.componentDatatype;\n  attribute.type = attributeInfo.type;\n  attribute.normalized = defaultValue(attributeInfo.normalized, false);\n  attribute.min = attributeInfo.min;\n  attribute.max = attributeInfo.max;\n  attribute.quantization = quantization;\n\n  if (attributeInfo.isRGB565) {\n    typedArray = AttributeCompression.decodeRGB565(typedArray);\n  }\n\n  if (defined(attributeInfo.constantColor)) {\n    const packedColor = new Array(4);\n    attribute.constant = Color.pack(attributeInfo.constantColor, packedColor);\n  } else {\n    const buffer = Buffer.createVertexBuffer({\n      typedArray: typedArray,\n      context: context,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    buffer.vertexArrayDestroyable = false;\n    loader._buffers.push(buffer);\n    attribute.buffer = buffer;\n  }\n\n  return attribute;\n}\n\nlet randomNumberGenerator;\nlet randomValues;\n\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    // Use MersenneTwister directly to avoid interfering with CesiumMath.nextRandomNumber()\n    // See https://github.com/CesiumGS/cesium/issues/9730\n    randomNumberGenerator = new MersenneTwister(0);\n    randomValues = new Array(samplesLength);\n    for (let i = 0; i < samplesLength; ++i) {\n      randomValues[i] = randomNumberGenerator.random();\n    }\n  }\n  return randomValues;\n}\n\nconst scratchMin = new Cartesian3();\nconst scratchMax = new Cartesian3();\nconst scratchPosition = new Cartesian3();\nfunction computeApproximateExtrema(positions) {\n  const positionsArray = positions.typedArray;\n  const maximumSamplesLength = 20;\n  const pointsLength = positionsArray.length / 3;\n  const samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  const randomValues = getRandomValues(maximumSamplesLength);\n  const maxValue = Number.MAX_VALUE;\n  const minValue = -Number.MAX_VALUE;\n  let min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  let max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n  let i;\n  let index;\n  let position;\n  if (positions.isQuantized) {\n    // The quantized volume offset is not used here since it will become part of\n    // the model matrix.\n    min = Cartesian3.ZERO;\n    max = positions.quantizedVolumeScale;\n  } else {\n    for (i = 0; i < samplesLength; ++i) {\n      index = Math.floor(randomValues[i] * pointsLength);\n      position = Cartesian3.unpack(positionsArray, index * 3, scratchPosition);\n\n      Cartesian3.minimumByComponent(min, position, min);\n      Cartesian3.maximumByComponent(max, position, max);\n    }\n  }\n\n  positions.min = Cartesian3.clone(min);\n  positions.max = Cartesian3.clone(max);\n}\n\n// By default, point clouds are rendered as dark gray.\nconst defaultColorAttribute = {\n  name: VertexAttributeSemantic.COLOR,\n  semantic: VertexAttributeSemantic.COLOR,\n  setIndex: 0,\n  constantColor: Color.DARKGRAY,\n  componentDatatype: ComponentDatatype.FLOAT,\n  type: AttributeType.VEC4,\n  isQuantized: false,\n  isTranslucent: false,\n};\n\nfunction makeAttributes(loader, parsedContent, context) {\n  const attributes = [];\n  let attribute;\n  const positions = parsedContent.positions;\n  if (defined(positions)) {\n    computeApproximateExtrema(positions);\n    attribute = makeAttribute(loader, positions, context);\n    attribute.count = parsedContent.pointsLength;\n    attributes.push(attribute);\n  }\n\n  if (defined(parsedContent.normals)) {\n    attribute = makeAttribute(loader, parsedContent.normals, context);\n    attributes.push(attribute);\n  }\n\n  if (defined(parsedContent.colors)) {\n    attribute = makeAttribute(loader, parsedContent.colors, context);\n    attributes.push(attribute);\n  } else {\n    attribute = makeAttribute(loader, defaultColorAttribute, context);\n    attributes.push(attribute);\n  }\n\n  if (defined(parsedContent.batchIds)) {\n    attribute = makeAttribute(loader, parsedContent.batchIds, context);\n    attributes.push(attribute);\n  }\n\n  return attributes;\n}\n\nfunction makeStructuralMetadata(parsedContent) {\n  const batchLength = parsedContent.batchLength;\n  const pointsLength = parsedContent.pointsLength;\n  const batchTableBinary = parsedContent.batchTableBinary;\n\n  if (defined(batchTableBinary)) {\n    const count = defaultValue(batchLength, pointsLength);\n    return parseBatchTable({\n      count: count,\n      batchTable: parsedContent.batchTableJson,\n      binaryBody: batchTableBinary,\n    });\n  }\n\n  // If batch table is not defined, create a property table without any properties.\n  const emptyPropertyTable = new PropertyTable({\n    name: MetadataClass.BATCH_TABLE_CLASS_NAME,\n    count: pointsLength,\n  });\n  return new StructuralMetadata({\n    schema: {},\n    propertyTables: [emptyPropertyTable],\n  });\n}\n\nfunction makeComponents(loader, context) {\n  const parsedContent = loader._parsedContent;\n\n  const metallicRoughness = new MetallicRoughness();\n  metallicRoughness.metallicFactor = 0;\n  metallicRoughness.roughnessFactor = 0.9;\n\n  const material = new Material();\n  material.metallicRoughness = metallicRoughness;\n\n  const colors = parsedContent.colors;\n  if (defined(colors) && colors.isTranslucent) {\n    material.alphaMode = AlphaMode.BLEND;\n  }\n\n  // Render point clouds as unlit, unless normals are present, in which case\n  // render as a PBR material.\n  const isUnlit = !defined(parsedContent.normals);\n  material.unlit = isUnlit;\n\n  const primitive = new Primitive();\n  primitive.attributes = makeAttributes(loader, parsedContent, context);\n  primitive.primitiveType = PrimitiveType.POINTS;\n  primitive.material = material;\n\n  if (defined(parsedContent.batchIds)) {\n    const featureIdAttribute = new FeatureIdAttribute();\n    featureIdAttribute.propertyTableId = 0;\n    featureIdAttribute.setIndex = 0;\n    featureIdAttribute.positionalLabel = \"featureId_0\";\n    primitive.featureIds.push(featureIdAttribute);\n  }\n\n  const node = new Node();\n  node.index = 0;\n  node.primitives = [primitive];\n\n  const scene = new Scene();\n  scene.nodes = [node];\n  scene.upAxis = Axis.Z;\n  scene.forwardAxis = Axis.X;\n\n  const components = new Components();\n  components.scene = scene;\n  components.nodes = [node];\n  components.structuralMetadata = makeStructuralMetadata(parsedContent);\n\n  if (defined(parsedContent.rtcCenter)) {\n    components.transform = Matrix4.multiplyByTranslation(\n      components.transform,\n      parsedContent.rtcCenter,\n      components.transform\n    );\n  }\n\n  const positions = parsedContent.positions;\n  if (defined(positions) && positions.isQuantized) {\n    // The volume offset is sometimes in ECEF, so this is applied here rather\n    // than the dequantization shader to avoid jitter\n    components.transform = Matrix4.multiplyByTranslation(\n      components.transform,\n      positions.quantizedVolumeOffset,\n      components.transform\n    );\n  }\n\n  loader._components = components;\n\n  // Free the parsed content so we don't hold onto the large typed arrays.\n  loader._parsedContent = undefined;\n}\n\nPntsLoader.prototype.unload = function () {\n  const buffers = this._buffers;\n  for (let i = 0; i < buffers.length; i++) {\n    buffers[i].destroy();\n  }\n  buffers.length = 0;\n\n  this._components = undefined;\n  this._parsedContent = undefined;\n};\n"],"names":["emptyClass","JsonMetadataTable","options","count","properties","this","_count","_properties","prototype","hasProperty","propertyId","getPropertyIds","results","getProperty","index","property","setProperty","value","fontInfoCache","fontInfoCacheLength","defaultBackgroundColor","defaultBackgroundPadding","textTypes","Object","freeze","LTR","RTL","WEAK","BRACKETS","rebindAllGlyphs","label","_rebindAllGlyphs","_repositionAllGlyphs","_labelCollection","_labelsToUpdate","push","repositionAllGlyphs","getCSSValue","element","document","defaultView","getComputedStyle","getPropertyValue","parseFont","fontInfo","_font","div","createElement","style","position","opacity","font","body","appendChild","lineHeight","parseFloat","isNaN","undefined","family","size","replace","weight","removeChild","_fontFamily","_fontSize","_fontStyle","_fontWeight","_lineHeight","Label","labelCollection","disableDepthTestDistance","translucencyByDistance","pixelOffsetScaleByDistance","scaleByDistance","distanceDisplayCondition","far","near","_renderedText","_text","_show","show","_fillColor","fillColor","_outlineColor","outlineColor","_outlineWidth","outlineWidth","_showBackground","showBackground","_backgroundColor","backgroundColor","_backgroundPadding","backgroundPadding","_style","_verticalOrigin","verticalOrigin","_horizontalOrigin","horizontalOrigin","_pixelOffset","pixelOffset","_eyeOffset","eyeOffset","_position","_scale","scale","_id","id","_translucencyByDistance","_pixelOffsetScaleByDistance","_scaleByDistance","_heightReference","heightReference","_distanceDisplayCondition","_disableDepthTestDistance","_glyphs","_backgroundBillboard","_batchIndex","_actualClampedPosition","_removeCallbackFunc","_mode","_clusterShow","text","_relativeSize","_updateClamping","convertTextToTypes","rtlChars","ltrChars","bracketsChars","parsedText","word","lastType","currentType","textLength","length","textIndex","character","charAt","test","Type","Word","reverseWord","split","reverse","join","spliceWord","result","pointer","slice","reverseBrackets","bracket","defineProperties","get","set","glyphs","i","len","billboard","backgroundBillboard","renderedValue","enableRightToLeftDetection","texts","rtlDir","splicePointer","line","wordIndex","subText","reverseRtl","color","glyph","totalScale","pickId","_clampedPosition","clusterShow","computeScreenSpacePosition","scene","modelMatrix","actualPosition","getScreenSpaceBoundingBox","screenSpacePosition","x","y","width","height","_translate","Number","POSITIVE_INFINITY","maxX","maxY","glyphX","glyphY","glyphWidth","dimensions","glyphHeight","Math","min","max","equals","other","isDestroyed","RegExp","Glyph","textureInfo","GlyphTextureInfo","whitePixelCanvasId","whitePixelSize","whitePixelBoundingRegion","writeTextToCanvasParameters","createGlyphCanvas","strokeColor","strokeWidth","padding","textBaseline","fill","stroke","unbindGlyph","image","_spareBillboards","addGlyphToTextureAtlas","textureAtlas","canvas","glyphTextureInfo","addImageSync","splitter","graphemes","splitGraphemes","glyphsLength","glyphIndex","backgroundBillboardCollection","_backgroundBillboardCollection","add","collection","imageSubRegion","pickPrimitive","remove","glyphTextureCache","_glyphTextureCache","JSON","stringify","sdfValues","cutoff","radius","ctx","getContext","canvasWidth","canvasHeight","imgData","getImageData","j","baseIndex","alpha","imageIndex","data","putImageData","_textureAtlas","spareBillboards","pop","_billboardCollection","_labelDimensions","_labelTranslate","calculateWidthOffset","lineWidth","glyphPixelOffset","scratchBackgroundPadding","lastLineWidth","maxLineWidth","lineWidths","maxGlyphDescent","NEGATIVE_INFINITY","maxGlyphY","numberOfLines","glyphLength","descent","minx","maxLineHeight","lineIndex","widthOffset","lineSpacing","otherLinesHeight","totalLineWidth","totalLineHeight","_labelHorizontalOrigin","firstCharOfLine","lineOffsetY","_setTranslate","nextGlyph","destroyLabel","LabelCollection","_scene","_batchTable","batchTable","_backgroundTextureAtlas","destroyTextureAtlas","_sdf","_labels","_totalGlyphCount","_highlightColor","debugShowBoundingVolume","blendOption","indexOf","splice","removeAll","labels","contains","update","frameState","billboardCollection","context","initialSize","context2D","fillStyle","fillRect","addImage","addWhitePixelCanvas","preUpdateGlyphCount","glyphCountDifference","destroy","FILL","OUTLINE","FILL_AND_OUTLINE","Light","intensity","ROTATE","INFINITE_SCROLL","trailingSlashRegex","defaultCredit","MapboxImageryProvider","mapId","accessToken","defaultAlpha","defaultNightAlpha","defaultDayAlpha","defaultBrightness","defaultContrast","defaultHue","defaultSaturation","defaultGamma","defaultMinificationFilter","defaultMagnificationFilter","resource","url","_mapId","_accessToken","format","_format","credit","templateUrl","getUrlComponent","setQueryParameters","access_token","_resource","_imageryProvider","ellipsoid","minimumLevel","maximumLevel","rectangle","ready","readyPromise","tileWidth","tileHeight","tilingScheme","tileDiscardPolicy","errorEvent","proxy","hasAlphaChannel","getTileCredits","level","requestImage","request","pickFeatures","longitude","latitude","_defaultCredit","MapboxStyleImageryProvider","styleId","_styleId","tilesize","_tilesize","username","_username","scaleFactor","Material","type","shaderSource","materials","uniforms","_uniforms","translucent","_minificationFilter","minificationFilter","_magnificationFilter","magnificationFilter","_strict","_template","_texturePaths","_loadedImages","_loadedCubeMaps","_textures","_updateFunctions","_defaultTexture","strict","fabric","_translucentFunctions","cachedMaterial","_materialCache","getMaterial","template","material","components","source","checkForValidProperties","templateProperties","invalidNameError","componentProperties","materialNames","hasOwnProperty","duplicateNameError","checkForTemplateErrors","addMaterial","isMultiMaterial","keys","component","componentSource","isMaterialFused","createMethodDefinition","uniformId","createUniform","createUniforms","subMaterialTemplates","subMaterialId","subMaterial","concat","originalMethodName","newMethodName","replaceToken","createSubMaterials","defaultTranslucent","wrappedTranslucent","initializeMaterial","writable","_uniformList","object","throwNotFound","errorString","propertyName","fromType","name","isTranslucent","funcs","func","defaultTexture","loadedImages","loadedImage","mipLevels","Array","isArray","map","mipLevel","bufferView","sampler","texture","internalFormat","pixelFormat","arrayBufferView","oldTexture","uniformDimensionsName","uniformDimensions","_width","_height","loadedCubeMaps","loadedCubeMap","images","cubeMap","positiveX","negativeX","positiveY","negativeY","positiveZ","negativeZ","updateFunctions","subMaterials","textures","instance","shaderComponent","matrixMap","mat2","mat3","mat4","ktx2Regex","materialUniforms","uniformValue","uniformType","HTMLCanvasElement","HTMLImageElement","DefaultCubeMapId","sqrt","numAttributes","attribute","getUniformType","replacedTokenCount","imageDimensionsUniformName","token","excludePeriod","getNumberOfTokens","uniformDeclaration","newUniformId","oldUniformValue","uniformChanged","uniformValueIsDefaultImage","DefaultImageId","HTMLVideoElement","readyState","copyFrom","tmp","isResource","promise","fetchImage","Promise","resolve","then","catch","createTexture2DUpdateFunction","defaultCubeMap","path","promises","all","createCubeMapUpdateFunction","scratchMatrix","fromColumnMajorArray","newToken","regExp","$0","$1","$2","_materials","materialTemplate","ColorType","diffuse","ImageType","repeat","DiffuseMapType","channels","AlphaMapType","channel","SpecularMapType","specular","EmissionMapType","emission","BumpMapType","strength","NormalMapType","GridType","cellAlpha","lineCount","lineThickness","lineOffset","StripeType","horizontal","evenColor","oddColor","offset","CheckerboardType","lightColor","darkColor","DotType","WaterType","baseWaterColor","blendColor","specularMap","normalMap","frequency","animationSpeed","amplitude","specularIntensity","fadeFactor","RimLightingType","rimColor","FadeType","fadeInColor","fadeOutColor","maximumDistance","fadeDirection","time","PolylineArrowType","PolylineDashType","gapColor","dashLength","dashPattern","PolylineGlowType","glowPower","taperPower","PolylineOutlineType","ElevationContourType","spacing","ElevationRampType","minimumHeight","maximumHeight","SlopeRampMaterialType","AspectRampMaterialType","ElevationBandType","heights","colors","MaterialAppearance","closed","materialSupport","MaterialSupport","TEXTURED","_vertexShaderSource","vertexShaderSource","_fragmentShaderSource","fragmentShaderSource","_renderState","renderState","_closed","_materialSupport","_vertexFormat","vertexFormat","_flat","flat","_faceForward","faceForward","getFragmentShaderSource","getRenderState","BASIC","ALL","MetadataClass","classDefinition","class","propertiesBySemantic","enums","semantic","_propertiesBySemantic","_name","_description","description","_extras","extras","_extensions","extensions","BATCH_TABLE_CLASS_NAME","MetadataClassProperty","isLegacyExtension","noData","required","array","optional","isLegacy","parsedType","componentType","isLegacyArray","arrayLength","isVariableLengthArray","enumType","componentCount","valueType","parseType","normalized","_semantic","_isLegacyExtension","_type","_componentType","_enumType","_valueType","_isArray","_isVariableLengthArray","_arrayLength","_min","_max","_normalized","hasValueTransform","expandConstant","_offset","_hasValueTransform","_noData","_default","default","_required","arrayEquals","left","right","validateSingleValue","classProperty","validateVector","validateMatrix","getTypeErrorMessage","validateString","validateBoolean","javascriptType","valuesByName","validateEnum","isFinite","checkInRange","getNonFiniteErrorMessage","validateScalar","getOutOfRangeErrorMessage","errorMessage","normalizeInPlace","values","normalizeFunction","normalize","unnormalize","applyValueTransform","valueTransformInPlace","unapplyValueTransform","constant","enableNestedArrays","isNested","innerConstant","handleNoData","sentinel","unpackVectorAndMatrixTypes","MathType","unpack","unpackArray","packVectorAndMatrixTypes","pack","packArray","validate","message","validateArray","offsets","scales","transformationFunction","MetadataComponentType","INT8","UINT8","INT16","UINT16","INT32","UINT32","INT64","UINT64","FLOAT32","FLOAT64","isNumericType","BigInt","pow","MAX_VALUE","isIntegerType","getMaximum","isUnsignedIntegerType","round","abs","MetadataEntity","hasPropertyBySemantic","getPropertyBySemantic","setPropertyBySemantic","classProperties","classPropertyId","MetadataEnum","enumDefinition","enum","namesByValue","_values","_namesByValue","_valuesByName","MetadataEnumValue","_value","MetadataSchema","schema","enumId","classes","classId","_classes","_enums","_version","version","MetadataSchemaLoader","cacheKey","_schema","_cacheKey","_state","_promise","create","constructor","load","schemaLoader","fetchJson","json","error","reject","getError","loadExternalSchema","unload","ID","NAME","DESCRIPTION","TILE_BOUNDING_BOX","TILE_BOUNDING_REGION","TILE_BOUNDING_SPHERE","TILE_MINIMUM_HEIGHT","TILE_MAXIMUM_HEIGHT","TILE_HORIZON_OCCLUSION_POINT","TILE_GEOMETRIC_ERROR","CONTENT_BOUNDING_BOX","CONTENT_BOUNDING_REGION","CONTENT_BOUNDING_SPHERE","CONTENT_MINIMUM_HEIGHT","CONTENT_MAXIMUM_HEIGHT","CONTENT_HORIZON_OCCLUSION_POINT","MetadataTable","metadataClass","bufferViews","_class","getDefault","getPropertyTypedArray","getTypedArray","getPropertyTypedArrayBySemantic","MetadataTableProperty","hasStrings","hasBooleans","arrayOffsets","arrayOffsetType","offsetType","BufferView","arrayOffsetBufferView","vectorComponentCount","arrayComponentCount","stringOffsets","valueCount","stringOffsetType","stringOffsetBufferView","ceil","getValueFunction","setValueFunction","flatten","that","stringByteOffset","stringByteLength","typedArray","getString","_stringOffsets","byteIndex","bitIndex","getBoolean","setBoolean","integer","_arrayOffsets","_classProperty","_vectorComponentCount","_getValue","_setValue","_unpackedValues","apply","checkIndex","table","maximumIndex","getArrayValues","requiresUnpackForGet","unpackProperty","unpackedValues","unpackValues","getFunction","setFunction","BigInt64Array","buffer","byteOffset","Uint8Array","dataView","isNegative","getUint8","carrying","byte","getInt64BigIntFallback","getInt64NumberFallback","BigUint64Array","getUint32","getUint64BigIntFallback","getUint64NumberFallback","componentDatatype","getComponentDatatype","DataView","requiresUnpackForSet","MetadataType","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BOOLEAN","STRING","ENUM","ModelAnimation","model","runtimeAnimation","_startTime","startTime","_delay","delay","_stopTime","stopTime","removeOnStop","_multiplier","multiplier","_reverse","_loop","loop","_animationTime","animationTime","_prevAnimationDelta","start","stop","_runtimeAnimation","_computedStartTime","_duration","_raiseStartEvent","raiseEvent","_updateEventTime","_raiseUpdateEvent","_raiseStopEvent","ModelAnimationCache","dataUriRegex","getAccessorKey","accessor","gltf","gltfInternal","buffers","byteLength","uriKey","uri","cachedAnimationParameters","getAnimationParameterValues","key","_pipeline","numberOfComponents","byteStride","accessorByteOffset","typedArrayView","cachedAnimationSplines","SteppedSpline","backingSpline","_spline","_lastTimeIndex","findTimeInterval","evaluate","times","steppedTime","wrapTime","clampTime","getAnimationSpline","animationName","animation","samplerName","input","output","getAnimationSplineKey","spline","controlPoints","interpolation","points","weights","cachedSkinInverseBindMatrices","getSkinInverseBindMatrices","matrices","ModelAnimationCollection","animationAdded","animationRemoved","animateWhilePaused","_model","_scheduledAnimations","_previousTime","_runtime","animations","scheduledAnimation","animateChannels","localAnimationTime","channelEvaluators","addAll","scheduledAnimations","animationsToRemove","createAnimationRemovedFunction","modelAnimationCollection","animationOccured","sceneTime","duration","pastStartTime","pastStopTime","delta","seconds","play","numberOfListeners","afterRender","floor","fract","animationToRemove","NONE","REPEAT","MIRRORED_REPEAT","STOPPED","ANIMATING","ModelComponents","Asset","credits","MetallicRoughness","baseColorTexture","metallicRoughnessTexture","baseColorFactor","DEFAULT_BASE_COLOR_FACTOR","metallicFactor","DEFAULT_METALLIC_FACTOR","roughnessFactor","DEFAULT_ROUGHNESS_FACTOR","SpecularGlossiness","diffuseTexture","specularGlossinessTexture","diffuseFactor","DEFAULT_DIFFUSE_FACTOR","specularFactor","DEFAULT_SPECULAR_FACTOR","glossinessFactor","DEFAULT_GLOSSINESS_FACTOR","metallicRoughness","specularGlossiness","emissiveTexture","normalTexture","occlusionTexture","emissiveFactor","DEFAULT_EMISSIVE_FACTOR","alphaMode","alphaCutoff","doubleSided","unlit","Quantization","octEncoded","octEncodedZXY","normalizationRange","quantizedVolumeOffset","quantizedVolumeDimensions","quantizedVolumeStepSize","Attribute","setIndex","quantization","packedTypedArray","Indices","indexDatatype","FeatureIdAttribute","featureCount","nullFeatureId","propertyTableId","positionalLabel","FeatureIdTexture","textureReader","FeatureIdImplicitRange","MorphTarget","attributes","Primitive","morphTargets","indices","primitiveType","featureIds","propertyTextureIds","propertyAttributeIds","Instances","transformInWorldSpace","Skin","joints","inverseBindMatrices","Node","children","primitives","instances","skin","matrix","translation","rotation","morphWeights","Scene","nodes","AnimatedPropertyType","TRANSLATION","ROTATION","SCALE","WEIGHTS","AnimationSampler","AnimationTarget","node","AnimationChannel","target","Animation","samplers","Components","asset","skins","structuralMetadata","upAxis","forwardAxis","transform","TextureReader","texCoord","AlphaPipelineStage","renderResources","primitive","alphaOptions","pass","opaquePass","renderStateOptions","blending","shaderBuilder","uniformMap","addDefine","addUniform","u_alphaCutoff","B3dmLoaderState","B3dmLoader","b3dmResource","baseResource","arrayBuffer","releaseGltfJson","asynchronous","incrementallyLoadTextures","loadAttributesAsTypedArray","loadPositionsFor2D","loadIndicesForWireframe","clone","_b3dmResource","_baseResource","_arrayBuffer","_byteOffset","_releaseGltfJson","_asynchronous","_incrementallyLoadTextures","_upAxis","_forwardAxis","_loadAttributesAsTypedArray","_loadPositionsFor2D","_loadIndicesForWireframe","_gltfLoader","_batchLength","_propertyTable","_components","_transform","processNode","childrenLength","primitivesLength","featureIdVertexAttribute","featureIdAttribute","texturesLoadedPromise","b3dm","batchLength","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","featureTable","getGlobalProperty","rtcCenter","binary","gltfLoader","gltfResource","renameBatchIdSemantic","loader","binaryBody","emptyPropertyTable","propertyTables","createStructuralMetadata","b3dmLoader","handleError","process","BatchTexturePipelineStage","batchTextureUniforms","featureTables","featureTableId","featuresLength","model_featuresLength","batchTexture","model_batchTexture","model_textureStep","textureStep","textureDimensions","model_textureDimensions","CPUStylingPipelineStage","addVertexLines","addFragmentLines","colorBlendMode","colorBlendAmount","model_commandTranslucent","styleCommandsNeeded","translucentFeaturesLength","CustomShader","mode","lightingModel","varyings","vertexShaderText","fragmentShaderText","_textureManager","customShader","uniformName","uniform","loadTexture2D","createUniformTexture2DFunction","createUniformFunction","buildUniformMap","usedVariablesVertex","attributeSet","featureIdSet","metadataSet","usedVariablesFragment","materialSet","attributeRegex","featureIdRegex","metadataRegex","getVariables","findUsedVariables","attributesVS","validateVariableUsage","attributesFS","validateBuiltinVariables","getTexture","shaderText","regex","outputSet","match","exec","expandCoordinateAbbreviations","variableName","variableSet","incorrectVariable","correctVariable","vertexOrFragment","setUniform","CustomShaderMode","MODIFY_MATERIAL","REPLACE_MATERIAL","customShaderMode","CustomShaderPipelineStage","STRUCT_ID_ATTRIBUTES_VS","STRUCT_ID_ATTRIBUTES_FS","STRUCT_NAME_ATTRIBUTES","STRUCT_ID_VERTEX_INPUT","STRUCT_NAME_VERTEX_INPUT","STRUCT_ID_FRAGMENT_INPUT","STRUCT_NAME_FRAGMENT_INPUT","FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS","FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS","FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS","FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS","lightingOptions","generatedCode","vertexLines","enabled","fragmentLines","attributesByName","names","attributeInfo","getAttributesByName","categories","partitionAttributes","addToShader","needsDefault","missingAttributes","vertexInitialization","attributeFields","initializationLines","attributeField","glslType","attributeDefaults","inferAttributeDefaults","_oneTimeWarning","generateVertexShaderLines","fragmentInitialization","positionBuiltins","usedVariables","generatePositionBuiltins","generateFragmentShaderLines","shouldComputePositionWC","vertexLinesEnabled","fragmentLinesEnabled","customShaderEnabled","generateShaderLines","structId","addStruct","field","addStructField","functionId","addFunction","addFunctionLines","addVertexLinesToShader","addFragmentLinesToShader","addLinesToShader","shaderModeDefine","varyingName","varyingType","addVarying","attributeTypeLUT","normal","tangent","bitangent","attributeDefaultValueLUT","attributeName","trimmed","builtinAttributes","positionWC","positionEC","primitiveAttributes","shaderAttributeSet","isFragmentShader","renamed","DequantizationPipelineStage","addDequantizationUniforms","stepSize","promoteToVec4","z","updateDequantizationFunction","structField","quantizedAttribute","swizzle","generateOctDecodeLine","generateDequantizeLine","FUNCTION_ID_DEQUANTIZATION_STAGE_VS","FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS","FeatureIdPipelineStage","processInstanceAttribute","STRUCT_ID_FEATURE_IDS_VS","STRUCT_ID_FEATURE_IDS_FS","prefix","vertexLine","fragmentLine","FUNCTION_ID_INITIALIZE_FEATURE_IDS_VS","FUNCTION_ID_INITIALIZE_FEATURE_IDS_FS","FUNCTION_ID_SET_FEATURE_ID_VARYINGS","processAttribute","processImplicitRange","implicitFeatureIds","instanceDivisor","vertexBuffer","Float32Array","generateImplicitFeatureIdTypedArray","usage","vertexArrayDestroyable","_resources","generatedFeatureIdAttribute","attributeIndex","componentsPerAttribute","strideInBytes","offsetInBytes","generateImplicitFeatureIdAttribute","implicitAttributeName","addAttribute","implicitVaryingName","processTexture","featureIdTexture","initializationLine","addAlias","alias","shaderDestination","updateVS","FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_VS","FUNCTION_ID_INITIALIZE_FEATURE_ID_ALIASES_FS","STRUCT_NAME_FEATURE_IDS","FUNCTION_SIGNATURE_INITIALIZE_FEATURE_IDS","FUNCTION_SIGNATURE_INITIALIZE_FEATURE_ID_ALIASES","FUNCTION_SIGNATURE_SET_FEATURE_ID_VARYINGS","declareStructsAndFunctions","runtimeNode","featureIdsArray","processInstanceFeatureIds","aliasDestination","processPrimitiveFeatureIds","GeoJsonLoader","geoJson","_geoJson","_process","ParsedFeature","lines","ParseResult","features","parsePosition","parseLineString","coordinates","positionsLength","parsePolygon","linesLength","parseFunction","geoJsonObjectTypes","feature","featureProperties","jsonMetadataTable","cartographicMin","cartographicMax","k","cartographicCenter","ecefCenter","toGlobal","toLocal","vertexCount","indexCount","positionsTypedArray","featureIdsTypedArray","indicesTypedArray","localMin","localMax","vertexCounter","segmentCounter","cartographic","globalCartesian","scratchCartesian","localCartesian","positionBuffer","featureIdBuffer","indexBuffer","positionAttribute","featureId","parse","geometryTypes","LineString","MultiLineString","MultiPolygon","polygonsLength","Polygon","parseFeature","geometry","geometryType","geometryFunction","parsedFeature","FeatureCollection","featureCollection","Feature","GeometryPipelineStage","attributeLocationCount","use2D","columnCount","componentsPerColumn","componentSizeInBytes","columnLengthInBytes","columnAttribute","addMatrixAttributeToRenderResources","featureIdVertexAttributeSetIndex","isPositionAttribute","vertexAttribute","buffer2D","runtimePrimitive","positionBuffer2D","positionAttribute2D","addAttributeToRenderResources","isQuantized","quantizedGlslType","isPosition","setPositionAttribute","addAttributeDeclaration","addVaryingDeclaration","addSemanticDefine","vsStructId","STRUCT_ID_PROCESSED_ATTRIBUTES_VS","fsStructId","STRUCT_ID_PROCESSED_ATTRIBUTES_FS","updateAttributesStruct","FUNCTION_ID_INITIALIZE_ATTRIBUTES","updateInitializeAttributesFunction","FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS","FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS","updateSetDynamicVaryingsFunction","STRUCT_NAME_PROCESSED_ATTRIBUTES","FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES","FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS","scene3DOnly","_projectTo2D","hasNormals","hasTangents","handleBitangents","I3dmLoaderState","I3dmLoader","i3dmResource","_i3dmResource","_featureTable","_instancesLength","i3dm","gltfFormat","instancesLength","loaderOptions","gltfUrl","getDerivedResource","eastNorthUp","hasRotation","hasScale","translationTypedArray","getPropertyArray","quantizedPositions","quantizedVolumeScale","quantizedPosition","getPositions","rotationTypedArray","scaleTypedArray","featureIdArray","instancePositions","instancePosition","instanceNormalRight","instanceNormalUp","instanceNormalForward","instanceRotation","instanceQuaternion","instanceQuaternionArray","instanceScale","instanceScaleArray","instanceTransform","positionBoundingSphere","center","positionScratch","processRotation","processScale","batchId","translationAttribute","rotationAttribute","scaleAttribute","featureIdInstanceAttribute","createInstances","i3dmLoader","propertyScratch1","propertyScratch2","normalUp","normalRight","hasCustomOrientation","octNormalUp","octNormalRight","nonUniformScale","ImageBasedLightingPipelineStage","imageBasedLighting","useSphericalHarmonics","useSpecularEnvironmentMaps","sphericalHarmonicCoefficients","useDefaultSphericalHarmonics","specularEnvironmentMapAtlas","useDefaultSpecularMaps","luminanceAtZenith","model_iblFactor","imageBasedLightingFactor","model_iblReferenceFrameMatrix","_iblReferenceFrameMatrix","model_luminanceAtZenith","model_sphericalHarmonicCoefficients","model_specularEnvironmentMaps","model_specularEnvironmentMapsSize","model_specularEnvironmentMapsMaximumLOD","maximumMipmapLevel","modelViewScratch","nodeTransformScratch","InstancingPipelineStage","instancingVertexAttributes","sceneGraph","translationMax","translationMin","instancingTranslationMax","instancingTranslationMin","transformsTypedArray","getInstanceTransformsTypedArray","transformsVertexBuffer","vertexSizeInFloats","componentByteSize","processMatrixAttributes","processFeatureIdAttributes","u_instance_modifiedModelView","modifiedModelMatrix","uniformState","view","u_instance_nodeTransform","axisCorrectionMatrix","computedTransform","instanceCount","translationScratch","rotationScratch","scaleScratch","transformScratch","hasTranslation","_getInstanceTransformsTypedArray","UNLIT","PBR","LightingPipelineStage","model_lightColorHdr","MaterialPipelineStage","processTextureTransform","defineName","transformDefine","transformUniformName","textureDefine","texCoordVarying","texCoordDefine","textureTransform","defaultNormalTexture","defaultEmissiveTexture","u_emissiveFactor","processMaterialUniforms","u_diffuseFactor","u_specularFactor","u_glossinessFactor","processSpecularGlossinessUniforms","u_baseColorFactor","u_metallicFactor","u_roughnessFactor","processMetallicRoughnessUniforms","cull","backFaceCulling","debugWireframe","_processTexture","_processTextureTransform","MetadataPipelineStage","addPropertyAttributeProperty","metadataVariable","sanitizeGlslIdentifier","attributeVariable","STRUCT_ID_METADATA_VS","STRUCT_ID_METADATA_FS","unpackedValue","addValueTransformUniforms","FUNCTION_ID_INITIALIZE_METADATA_VS","FUNCTION_ID_INITIALIZE_METADATA_FS","addPropertyTextureProperty","textureUniformName","addPropertyTextureUniform","getGlslType","unpackInShader","valueExpression","offsetUniformName","scaleUniformName","identifier","replaceAll","STRUCT_NAME_METADATA","FUNCTION_SIGNATURE_INITIALIZE_METADATA","FUNCTION_ID_SET_METADATA_VARYINGS","FUNCTION_SIGNATURE_SET_METADATA_VARYINGS","propertyAttributes","modelAttribute","processPropertyAttributes","propertyTextures","isGpuCompatible","processPropertyTextures","ModelAlphaOptions","ModelClippingPlanesPipelineStage","textureResolutionScratch","clippingPlanes","unionClippingRegions","textureResolution","model_clippingPlanes","model_clippingPlanesEdgeStyle","edgeColor","edgeWidth","model_clippingPlanesMatrix","_clippingPlanesMatrix","ModelColorPipelineStage","stageUniforms","colorMask","red","green","blue","depthMask","COLOR_UNIFORM_NAME","COLOR_BLEND_UNIFORM_NAME","ModelExperimental","_loader","_modelMatrix","_minimumPixelSize","minimumPixelSize","_maximumScale","maximumScale","_clampedScale","_computedScale","_updateModelMatrix","referenceMatrix","_resourcesLoaded","_drawCommandsBuilt","_ready","_customShader","_content","content","_texturesLoaded","_activeAnimations","_clampAnimations","clampAnimations","_color","_colorBlendMode","_colorBlendAmount","_cull","_opaquePass","_allowPicking","allowPicking","featureIdLabel","_featureIdLabel","instanceFeatureIdLabel","_instanceFeatureIdLabel","_featureTables","_featureTableId","_featureTableIdDirty","_modelResources","_boundingSphere","_initialRadius","pointCloudShading","_attenuation","attenuation","_pointCloudShading","owner","_clippingPlanes","_clippingPlanesState","_lightColor","_imageBasedLighting","_shouldDestroyImageBasedLighting","_backFaceCulling","_backFaceCullingDirty","_shadows","shadows","_shadowsDirty","_debugShowBoundingVolumeDirty","_debugShowBoundingVolume","_enableDebugWireframe","enableDebugWireframe","_debugWireframe","_showCreditsOnScreen","showCreditsOnScreen","_splitDirection","splitDirection","_sceneMode","projectTo2D","_completeLoad","_texturesLoadedPromise","_readyPromise","loaderPromise","propertyTableCount","propertyTable","modelFeatureTable","createModelFeatureTables","_sceneGraph","modelComponents","initialize","activeAnimations","resetDrawCommands","applyStyle","boundingSphere","computedScale","destroyResources","scratchIBLReferenceFrameMatrix4","scratchIBLReferenceFrameMatrix3","scratchClippingPlanesMatrix","useSphericalHarmonicCoefficients","iblReferenceFrameMatrix3","iblReferenceFrameMatrix4","view3D","shouldRegenerateShaders","currentClippingPlanesState","isClippingEnabled","clippingPlanesMatrix","clippingPlanesState","selectFeatureTableId","updateFeatureTableId","styleCommandsNeededDirty","buildDrawCommands","maxPixelSize","drawingBufferWidth","drawingBufferHeight","m","scratchPosition","projection","mapProjection","cartesianToCartographic","scratchCartographic","project","metersPerPixel","scratchBoundingSphere","camera","getPixelSize","scaleInPixels","pixelsPerMeter","getScale","updateModelMatrix","updateBackFaceCulling","updateShadows","updateShowBoundingVolume","updateForAnimations","showOnScreen","creditDisplay","addCredit","drawCommands","getDrawCommands","commandList","makeModelOptions","modelType","destroyModelResources","clippingPlaneCollection","resources","fromGltf","basePath","gltfJson","modelOptions","fromB3dm","fromPnts","fromI3dm","fromGeoJson","applyColorAndShow","hasColorStyle","hasShowStyle","evaluateColor","ModelExperimental3DTileContent","tileset","tile","_tileset","_tile","_metadata","_group","additionalOptions","mainOptions","_gltfUpAxis","pointsLength","trianglesLength","geometryByteLength","texturesByteLength","batchTableByteLength","innerContents","metadata","group","getFeature","applyDebugSettings","setAllColor","tilesetClippingPlanes","clippingPlanesOriginMatrix","clippingPlanesDirty","_isClipped","ModelExperimentalAnimation","_animation","_runtimeChannels","_localStartTime","_localStopTime","localStartTime","localStopTime","runtimeChannels","nodeIndex","_runtimeNodes","runtimeChannel","animate","ModelExperimentalAnimationChannel","_channel","_runtimeNode","_splines","_path","splines","outputLength","targetIndex","pointsIndex","createSpline","createSplines","scratchVariable","cubicPoints","inTangents","outTangents","createCubicSpline","ModelExperimentalAnimationCollection","_runtimeAnimations","addAnimation","addedAnimations","runtimeAnimations","animationOccurred","reachedStopTime","ModelExperimentalDrawCommand","command","primitiveRenderResources","_command","_modelMatrix2DDirty","_styleCommandsNeeded","_cullFace","face","_commandList","_commandList2D","_runtimePrimitive","drawCommand","translucentCommand","derivedCommand","rs","depthTest","deriveTranslucentCommand","getAllCommands","boundingVolume","castShadows","receiveShadows","commandLength","cullFace","updateCullFace","scratchMatrix2D","derive2DCommand","getCommands","commandList2D","idl2D","maximumRadius","_boundingSphere2D","shouldUse2DCommands","command2D","length2D","modelMatrix2D","updateModelMatrix2D","commands","ModelExperimentalNode","transformToRoot","_children","_node","_originalTransform","_transformToRoot","_computedTransform","_transformDirty","_transformParameters","_morphWeights","_runtimeSkin","_computedJointMatrices","pipelineStages","runtimePrimitives","updateStages","updateTransformFromParameters","transformParameters","originalTransform","currentTranslation","currentRotation","currentScale","valueLength","runtimeSkin","computedJointMatrices","getChild","runtimeNodes","configurePipeline","updateComputedTransform","updateJointMatrices","skinJointMatrices","jointMatrices","nodeWorldTransform","inverseNodeWorldTransform","ModelExperimentalPrimitive","boundingSphere2D","useWebgl2","webgl2","hasMorphTargets","hasSkinning","hasCustomShader","materialsEnabled","hasQuantization","generateWireframeIndices","hasAttenuation","featureIdFlags","hasFeatureIds","hasPropertyTable","inspectFeatureIds","ModelExperimentalSceneGraph","_pipelineStages","_updateStages","_rootNodes","_skinnedNodes","_runtimeSkins","modelPipelineStages","_computedModelMatrix","_computedModelMatrix2D","_axisCorrectionMatrix","computeModelMatrix","nodesLength","rootNodesLength","rootNodeIndex","traverseSceneGraph","runtimeSkins","skinsLength","skinnedNodes","skinnedNodesLength","skinnedNodeIndex","skinnedNode","skinIndex","computedModelMatrix","scratchComputedTranslation","childrenIndices","childIndex","scratchModelPositionMin","scratchModelPositionMax","scratchPrimitivePositionMin","scratchPrimitivePositionMax","forEachRuntimePrimitive","callback","modelRenderResources","modelPositionMin","modelPositionMax","nodePipelineStages","nodeRenderResources","nodeTransform","primitivePipelineStages","primitivePositionMin","positionMin","primitivePositionMax","positionMax","disableAnimations","to2D","computeModelMatrix2D","rootNodes","shadowMode","ModelExperimentalSkin","_skin","_inverseBindMatrices","_joints","_jointMatrices","runtimeJoints","runtimeJointMatrices","jointMatrix","computeJointMatrix","joint","inverseBindMatrix","jointWorldTransform","ModelExperimentalType","GLTF","TILE_GLTF","TILE_B3DM","TILE_I3DM","TILE_PNTS","TILE_GEOJSON","ModelExperimentalUtility","getFailedLoadFunction","getNodeTransform","getAttributeBySemantic","attributesLength","matchesSetIndex","getAttributeByName","getFeatureIdsByLabel","hasQuantizedAttributes","getAttributeInfo","hasSemantic","toLowerCase","isVertexColor","attributeType","cartesianMaxScratch","cartesianMinScratch","getPositionMinMax","positionGltfAttribute","getAxisCorrectionMatrix","scratchMatrix3","getCullFace","matrix3","ModelFeature","_featureId","getShow","setShow","getColor","setColor","getPropertyInherited","getPropertyNames","ModelFeatureTable","_features","_featuresLength","_batchTexture","_styleCommandsNeededDirty","is3DTiles","statistics","_statistics","currentStyleCommandsNeeded","setAllShow","getPickColor","scratchColor","ModelLightingOptions","ModelMatrixUpdateStage","updateRuntimeNode","childRuntimeNode","ModelRenderResources","ModelSplitterPipelineStage","SPLIT_DIRECTION_UNIFORM_NAME","MorphTargetsPipelineStage","FUNCTION_ID_GET_MORPHED_POSITION","FUNCTION_SIGNATURE_GET_MORPHED_POSITION","positionLine","FUNCTION_ID_GET_MORPHED_NORMAL","FUNCTION_SIGNATURE_GET_MORPHED_NORMAL","normalLine","FUNCTION_ID_GET_MORPHED_TANGENT","FUNCTION_SIGNATURE_GET_MORPHED_TANGENT","tangentLine","addGetMorphedAttributeFunctionDeclarations","processMorphTargetAttribute","addGetMorphedAttributeFunctionReturns","weightsLength","u_morphWeights","scratchAttributeInfo","attributeString","morphTargetIndex","addMorphTargetAttributeToRenderResources","getMorphTargetAttributeInfo","addMorphTargetAttributeDeclarationAndFunctionLine","NodeRenderResources","PickingPipelineStage","buildPickObject","instanceId","detailPickObject","pickObject","detail","model_pickTexture","pickTexture","processPickTexture","pickIds","pickIdsTypedArray","modelResources","createPickId","pickColor","pickIdsBuffer","pickIdsVertexAttribute","processInstancedPickIds","czm_pickColor","PntsLoader","_parsedContent","_decodePromise","_decodedAttributes","_buffers","makeAttribute","quantizedRange","quantizedType","quantizedComponentDatatype","isRGB565","constantColor","packedColor","randomNumberGenerator","randomValues","getRandomValues","samplesLength","random","draco","decodePromise","decodeDracoResult","parsedContent","POSITION","range","minValues","quantizationBits","positions","NORMAL","octEncodedRange","normals","RGBA","RGB","BATCH_ID","batchIds","styleableProperties","batchTableProperties","processDracoAttributes","isUnlit","positionsArray","maximumSamplesLength","maxValue","minValue","scratchMin","scratchMax","computeApproximateExtrema","defaultColorAttribute","makeAttributes","makeStructuralMetadata","makeComponents","decodeDraco"],"sourceRoot":""}